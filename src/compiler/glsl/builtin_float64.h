ir_function_signature *
fabs64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r000B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r000B);
   body.emit(assign(r000B, bit_and(swizzle_y(r000B), body.constant(2147483647u)), 0x02));

   body.emit(ret(r000B));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
is_nan(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r000C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r000C);
   ir_expression *const r000D = lshift(swizzle_y(r000C), body.constant(int(1)));
   ir_expression *const r000E = lequal(body.constant(4292870144u), r000D);
   ir_expression *const r000F = nequal(swizzle_x(r000C), body.constant(0u));
   ir_expression *const r0010 = bit_and(swizzle_y(r000C), body.constant(1048575u));
   ir_expression *const r0011 = nequal(r0010, body.constant(0u));
   ir_expression *const r0012 = logic_or(r000F, r0011);
   ir_expression *const r0013 = logic_and(r000E, r0012);
   body.emit(ret(r0013));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fneg64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0014 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0014);
   ir_variable *const r0015 = body.make_temp(glsl_type::uvec2_type, "return_value");
   /* IF CONDITION */
   ir_expression *const r0017 = lshift(swizzle_y(r0014), body.constant(int(1)));
   ir_expression *const r0018 = lequal(body.constant(4292870144u), r0017);
   ir_expression *const r0019 = nequal(swizzle_x(r0014), body.constant(0u));
   ir_expression *const r001A = bit_and(swizzle_y(r0014), body.constant(1048575u));
   ir_expression *const r001B = nequal(r001A, body.constant(0u));
   ir_expression *const r001C = logic_or(r0019, r001B);
   ir_expression *const r001D = logic_and(r0018, r001C);
   ir_if *f0016 = new(mem_ctx) ir_if(operand(r001D).val);
   exec_list *const f0016_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0016->then_instructions;

      body.emit(assign(r0015, r0014, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0016->else_instructions;

      body.emit(assign(r0014, bit_xor(swizzle_y(r0014), body.constant(2147483648u)), 0x02));

      body.emit(assign(r0015, r0014, 0x03));


   body.instructions = f0016_parent_instructions;
   body.emit(f0016);

   /* END IF */

   body.emit(ret(r0015));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat64FracLo(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r001E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r001E);
   ir_swizzle *const r001F = swizzle_x(r001E);
   body.emit(ret(r001F));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat64FracHi(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0020 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0020);
   ir_expression *const r0021 = bit_and(swizzle_y(r0020), body.constant(1048575u));
   body.emit(ret(r0021));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat64Exp(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::int_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0022 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0022);
   ir_expression *const r0023 = rshift(swizzle_y(r0022), body.constant(int(20)));
   ir_expression *const r0024 = bit_and(r0023, body.constant(2047u));
   ir_expression *const r0025 = expr(ir_unop_u2i, r0024);
   body.emit(ret(r0025));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
feq64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0026 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0026);
   ir_variable *const r0027 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0027);
   ir_variable *const r0028 = body.make_temp(glsl_type::bool_type, "return_value");
   ir_variable *const r0029 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
   body.emit(r0029);
   ir_variable *const r002A = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
   body.emit(r002A);
   ir_expression *const r002B = rshift(swizzle_y(r0026), body.constant(int(20)));
   ir_expression *const r002C = bit_and(r002B, body.constant(2047u));
   ir_expression *const r002D = expr(ir_unop_u2i, r002C);
   ir_expression *const r002E = equal(r002D, body.constant(int(2047)));
   ir_expression *const r002F = bit_and(swizzle_y(r0026), body.constant(1048575u));
   ir_expression *const r0030 = bit_or(r002F, swizzle_x(r0026));
   ir_expression *const r0031 = nequal(r0030, body.constant(0u));
   body.emit(assign(r002A, logic_and(r002E, r0031), 0x01));

   ir_expression *const r0032 = rshift(swizzle_y(r0027), body.constant(int(20)));
   ir_expression *const r0033 = bit_and(r0032, body.constant(2047u));
   ir_expression *const r0034 = expr(ir_unop_u2i, r0033);
   ir_expression *const r0035 = equal(r0034, body.constant(int(2047)));
   ir_expression *const r0036 = bit_and(swizzle_y(r0027), body.constant(1048575u));
   ir_expression *const r0037 = bit_or(r0036, swizzle_x(r0027));
   ir_expression *const r0038 = nequal(r0037, body.constant(0u));
   body.emit(assign(r0029, logic_and(r0035, r0038), 0x01));

   /* IF CONDITION */
   ir_expression *const r003A = logic_or(r002A, r0029);
   ir_if *f0039 = new(mem_ctx) ir_if(operand(r003A).val);
   exec_list *const f0039_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0039->then_instructions;

      body.emit(assign(r0028, body.constant(false), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0039->else_instructions;

      ir_expression *const r003B = equal(swizzle_x(r0026), swizzle_x(r0027));
      ir_expression *const r003C = equal(swizzle_y(r0026), swizzle_y(r0027));
      ir_expression *const r003D = equal(swizzle_x(r0026), body.constant(0u));
      ir_expression *const r003E = bit_or(swizzle_y(r0026), swizzle_y(r0027));
      ir_expression *const r003F = lshift(r003E, body.constant(int(1)));
      ir_expression *const r0040 = equal(r003F, body.constant(0u));
      ir_expression *const r0041 = logic_and(r003D, r0040);
      ir_expression *const r0042 = logic_or(r003C, r0041);
      body.emit(assign(r0028, logic_and(r003B, r0042), 0x01));


   body.instructions = f0039_parent_instructions;
   body.emit(f0039);

   /* END IF */

   body.emit(ret(r0028));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat64Sign(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0043 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0043);
   ir_expression *const r0044 = rshift(swizzle_y(r0043), body.constant(int(31)));
   body.emit(ret(r0044));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
le64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0045 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r0045);
   ir_variable *const r0046 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r0046);
   ir_variable *const r0047 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r0047);
   ir_variable *const r0048 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r0048);
   ir_expression *const r0049 = less(r0045, r0047);
   ir_expression *const r004A = equal(r0045, r0047);
   ir_expression *const r004B = lequal(r0046, r0048);
   ir_expression *const r004C = logic_and(r004A, r004B);
   ir_expression *const r004D = logic_or(r0049, r004C);
   body.emit(ret(r004D));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fle64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r004E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r004E);
   ir_variable *const r004F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r004F);
   ir_variable *const r0050 = body.make_temp(glsl_type::bool_type, "return_value");
   ir_variable *const r0051 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
   body.emit(r0051);
   ir_variable *const r0052 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
   body.emit(r0052);
   ir_expression *const r0053 = rshift(swizzle_y(r004E), body.constant(int(20)));
   ir_expression *const r0054 = bit_and(r0053, body.constant(2047u));
   ir_expression *const r0055 = expr(ir_unop_u2i, r0054);
   ir_expression *const r0056 = equal(r0055, body.constant(int(2047)));
   ir_expression *const r0057 = bit_and(swizzle_y(r004E), body.constant(1048575u));
   ir_expression *const r0058 = bit_or(r0057, swizzle_x(r004E));
   ir_expression *const r0059 = nequal(r0058, body.constant(0u));
   body.emit(assign(r0052, logic_and(r0056, r0059), 0x01));

   ir_expression *const r005A = rshift(swizzle_y(r004F), body.constant(int(20)));
   ir_expression *const r005B = bit_and(r005A, body.constant(2047u));
   ir_expression *const r005C = expr(ir_unop_u2i, r005B);
   ir_expression *const r005D = equal(r005C, body.constant(int(2047)));
   ir_expression *const r005E = bit_and(swizzle_y(r004F), body.constant(1048575u));
   ir_expression *const r005F = bit_or(r005E, swizzle_x(r004F));
   ir_expression *const r0060 = nequal(r005F, body.constant(0u));
   body.emit(assign(r0051, logic_and(r005D, r0060), 0x01));

   /* IF CONDITION */
   ir_expression *const r0062 = logic_or(r0052, r0051);
   ir_if *f0061 = new(mem_ctx) ir_if(operand(r0062).val);
   exec_list *const f0061_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0061->then_instructions;

      body.emit(assign(r0050, body.constant(false), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0061->else_instructions;

      ir_variable *const r0063 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r0063, rshift(swizzle_y(r004E), body.constant(int(31))), 0x01));

      ir_variable *const r0064 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r0064, rshift(swizzle_y(r004F), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r0066 = nequal(r0063, r0064);
      ir_if *f0065 = new(mem_ctx) ir_if(operand(r0066).val);
      exec_list *const f0065_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0065->then_instructions;

         ir_expression *const r0067 = nequal(r0063, body.constant(0u));
         ir_expression *const r0068 = bit_or(swizzle_y(r004E), swizzle_y(r004F));
         ir_expression *const r0069 = lshift(r0068, body.constant(int(1)));
         ir_expression *const r006A = bit_or(r0069, swizzle_x(r004E));
         ir_expression *const r006B = bit_or(r006A, swizzle_x(r004F));
         ir_expression *const r006C = equal(r006B, body.constant(0u));
         body.emit(assign(r0050, logic_or(r0067, r006C), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0065->else_instructions;

         ir_variable *const r006D = body.make_temp(glsl_type::bool_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r006F = nequal(r0063, body.constant(0u));
         ir_if *f006E = new(mem_ctx) ir_if(operand(r006F).val);
         exec_list *const f006E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f006E->then_instructions;

            ir_expression *const r0070 = less(swizzle_y(r004F), swizzle_y(r004E));
            ir_expression *const r0071 = equal(swizzle_y(r004F), swizzle_y(r004E));
            ir_expression *const r0072 = lequal(swizzle_x(r004F), swizzle_x(r004E));
            ir_expression *const r0073 = logic_and(r0071, r0072);
            body.emit(assign(r006D, logic_or(r0070, r0073), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f006E->else_instructions;

            ir_expression *const r0074 = less(swizzle_y(r004E), swizzle_y(r004F));
            ir_expression *const r0075 = equal(swizzle_y(r004E), swizzle_y(r004F));
            ir_expression *const r0076 = lequal(swizzle_x(r004E), swizzle_x(r004F));
            ir_expression *const r0077 = logic_and(r0075, r0076);
            body.emit(assign(r006D, logic_or(r0074, r0077), 0x01));


         body.instructions = f006E_parent_instructions;
         body.emit(f006E);

         /* END IF */

         body.emit(assign(r0050, r006D, 0x01));


      body.instructions = f0065_parent_instructions;
      body.emit(f0065);

      /* END IF */


   body.instructions = f0061_parent_instructions;
   body.emit(f0061);

   /* END IF */

   body.emit(ret(r0050));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
lt64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0078 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r0078);
   ir_variable *const r0079 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r0079);
   ir_variable *const r007A = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r007A);
   ir_variable *const r007B = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r007B);
   ir_expression *const r007C = less(r0078, r007A);
   ir_expression *const r007D = equal(r0078, r007A);
   ir_expression *const r007E = less(r0079, r007B);
   ir_expression *const r007F = logic_and(r007D, r007E);
   ir_expression *const r0080 = logic_or(r007C, r007F);
   body.emit(ret(r0080));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
flt64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0081 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0081);
   ir_variable *const r0082 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0082);
   ir_variable *const r0083 = body.make_temp(glsl_type::bool_type, "return_value");
   ir_variable *const r0084 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
   body.emit(r0084);
   ir_variable *const r0085 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
   body.emit(r0085);
   ir_expression *const r0086 = rshift(swizzle_y(r0081), body.constant(int(20)));
   ir_expression *const r0087 = bit_and(r0086, body.constant(2047u));
   ir_expression *const r0088 = expr(ir_unop_u2i, r0087);
   ir_expression *const r0089 = equal(r0088, body.constant(int(2047)));
   ir_expression *const r008A = bit_and(swizzle_y(r0081), body.constant(1048575u));
   ir_expression *const r008B = bit_or(r008A, swizzle_x(r0081));
   ir_expression *const r008C = nequal(r008B, body.constant(0u));
   body.emit(assign(r0085, logic_and(r0089, r008C), 0x01));

   ir_expression *const r008D = rshift(swizzle_y(r0082), body.constant(int(20)));
   ir_expression *const r008E = bit_and(r008D, body.constant(2047u));
   ir_expression *const r008F = expr(ir_unop_u2i, r008E);
   ir_expression *const r0090 = equal(r008F, body.constant(int(2047)));
   ir_expression *const r0091 = bit_and(swizzle_y(r0082), body.constant(1048575u));
   ir_expression *const r0092 = bit_or(r0091, swizzle_x(r0082));
   ir_expression *const r0093 = nequal(r0092, body.constant(0u));
   body.emit(assign(r0084, logic_and(r0090, r0093), 0x01));

   /* IF CONDITION */
   ir_expression *const r0095 = logic_or(r0085, r0084);
   ir_if *f0094 = new(mem_ctx) ir_if(operand(r0095).val);
   exec_list *const f0094_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0094->then_instructions;

      body.emit(assign(r0083, body.constant(false), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0094->else_instructions;

      ir_variable *const r0096 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r0096, rshift(swizzle_y(r0081), body.constant(int(31))), 0x01));

      ir_variable *const r0097 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r0097, rshift(swizzle_y(r0082), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r0099 = nequal(r0096, r0097);
      ir_if *f0098 = new(mem_ctx) ir_if(operand(r0099).val);
      exec_list *const f0098_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0098->then_instructions;

         ir_expression *const r009A = nequal(r0096, body.constant(0u));
         ir_expression *const r009B = bit_or(swizzle_y(r0081), swizzle_y(r0082));
         ir_expression *const r009C = lshift(r009B, body.constant(int(1)));
         ir_expression *const r009D = bit_or(r009C, swizzle_x(r0081));
         ir_expression *const r009E = bit_or(r009D, swizzle_x(r0082));
         ir_expression *const r009F = nequal(r009E, body.constant(0u));
         body.emit(assign(r0083, logic_and(r009A, r009F), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0098->else_instructions;

         ir_variable *const r00A0 = body.make_temp(glsl_type::bool_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r00A2 = nequal(r0096, body.constant(0u));
         ir_if *f00A1 = new(mem_ctx) ir_if(operand(r00A2).val);
         exec_list *const f00A1_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f00A1->then_instructions;

            ir_expression *const r00A3 = less(swizzle_y(r0082), swizzle_y(r0081));
            ir_expression *const r00A4 = equal(swizzle_y(r0082), swizzle_y(r0081));
            ir_expression *const r00A5 = less(swizzle_x(r0082), swizzle_x(r0081));
            ir_expression *const r00A6 = logic_and(r00A4, r00A5);
            body.emit(assign(r00A0, logic_or(r00A3, r00A6), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f00A1->else_instructions;

            ir_expression *const r00A7 = less(swizzle_y(r0081), swizzle_y(r0082));
            ir_expression *const r00A8 = equal(swizzle_y(r0081), swizzle_y(r0082));
            ir_expression *const r00A9 = less(swizzle_x(r0081), swizzle_x(r0082));
            ir_expression *const r00AA = logic_and(r00A8, r00A9);
            body.emit(assign(r00A0, logic_or(r00A7, r00AA), 0x01));


         body.instructions = f00A1_parent_instructions;
         body.emit(f00A1);

         /* END IF */

         body.emit(assign(r0083, r00A0, 0x01));


      body.instructions = f0098_parent_instructions;
      body.emit(f0098);

      /* END IF */


   body.instructions = f0094_parent_instructions;
   body.emit(f0094);

   /* END IF */

   body.emit(ret(r0083));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
add64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00AB = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00AB);
   ir_variable *const r00AC = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00AC);
   ir_variable *const r00AD = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r00AD);
   ir_variable *const r00AE = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r00AE);
   ir_variable *const r00AF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00AF);
   ir_variable *const r00B0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00B0);
   ir_variable *const r00B1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r00B1, add(r00AC, r00AE), 0x01));

   body.emit(assign(r00B0, r00B1, 0x01));

   ir_expression *const r00B2 = add(r00AB, r00AD);
   ir_expression *const r00B3 = less(r00B1, r00AC);
   ir_expression *const r00B4 = expr(ir_unop_b2i, r00B3);
   ir_expression *const r00B5 = expr(ir_unop_i2u, r00B4);
   body.emit(assign(r00AF, add(r00B2, r00B5), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
sub64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00B6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00B6);
   ir_variable *const r00B7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00B7);
   ir_variable *const r00B8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r00B8);
   ir_variable *const r00B9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r00B9);
   ir_variable *const r00BA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00BA);
   ir_variable *const r00BB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00BB);
   body.emit(assign(r00BB, sub(r00B7, r00B9), 0x01));

   ir_expression *const r00BC = sub(r00B6, r00B8);
   ir_expression *const r00BD = less(r00B7, r00B9);
   ir_expression *const r00BE = expr(ir_unop_b2i, r00BD);
   ir_expression *const r00BF = expr(ir_unop_i2u, r00BE);
   body.emit(assign(r00BA, sub(r00BC, r00BF), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
eq64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00C0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00C0);
   ir_variable *const r00C1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00C1);
   ir_variable *const r00C2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r00C2);
   ir_variable *const r00C3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r00C3);
   ir_expression *const r00C4 = equal(r00C0, r00C2);
   ir_expression *const r00C5 = equal(r00C1, r00C3);
   ir_expression *const r00C6 = logic_and(r00C4, r00C5);
   body.emit(ret(r00C6));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
float64_is_signaling_nan(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00C7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r00C7);
   ir_expression *const r00C8 = rshift(swizzle_y(r00C7), body.constant(int(19)));
   ir_expression *const r00C9 = bit_and(r00C8, body.constant(4095u));
   ir_expression *const r00CA = equal(r00C9, body.constant(4094u));
   ir_expression *const r00CB = nequal(swizzle_x(r00C7), body.constant(0u));
   ir_expression *const r00CC = bit_and(swizzle_y(r00C7), body.constant(524287u));
   ir_expression *const r00CD = nequal(r00CC, body.constant(0u));
   ir_expression *const r00CE = logic_or(r00CB, r00CD);
   ir_expression *const r00CF = logic_and(r00CA, r00CE);
   body.emit(ret(r00CF));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift64RightJamming(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00D0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00D0);
   ir_variable *const r00D1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00D1);
   ir_variable *const r00D2 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r00D2);
   ir_variable *const r00D3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00D3);
   ir_variable *const r00D4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00D4);
   ir_variable *const r00D5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r00D5);
   ir_variable *const r00D6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r00D6);
   ir_variable *const r00D7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r00D8 = neg(r00D2);
   body.emit(assign(r00D7, bit_and(r00D8, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r00DA = equal(r00D2, body.constant(int(0)));
   ir_if *f00D9 = new(mem_ctx) ir_if(operand(r00DA).val);
   exec_list *const f00D9_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f00D9->then_instructions;

      body.emit(assign(r00D5, r00D1, 0x01));

      body.emit(assign(r00D6, r00D0, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f00D9->else_instructions;

      /* IF CONDITION */
      ir_expression *const r00DC = less(r00D2, body.constant(int(32)));
      ir_if *f00DB = new(mem_ctx) ir_if(operand(r00DC).val);
      exec_list *const f00DB_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f00DB->then_instructions;

         ir_expression *const r00DD = lshift(r00D0, r00D7);
         ir_expression *const r00DE = rshift(r00D1, r00D2);
         ir_expression *const r00DF = bit_or(r00DD, r00DE);
         ir_expression *const r00E0 = lshift(r00D1, r00D7);
         ir_expression *const r00E1 = nequal(r00E0, body.constant(0u));
         ir_expression *const r00E2 = expr(ir_unop_b2i, r00E1);
         ir_expression *const r00E3 = expr(ir_unop_i2u, r00E2);
         body.emit(assign(r00D5, bit_or(r00DF, r00E3), 0x01));

         body.emit(assign(r00D6, rshift(r00D0, r00D2), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f00DB->else_instructions;

         /* IF CONDITION */
         ir_expression *const r00E5 = equal(r00D2, body.constant(int(32)));
         ir_if *f00E4 = new(mem_ctx) ir_if(operand(r00E5).val);
         exec_list *const f00E4_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f00E4->then_instructions;

            ir_expression *const r00E6 = nequal(r00D1, body.constant(0u));
            ir_expression *const r00E7 = expr(ir_unop_b2i, r00E6);
            ir_expression *const r00E8 = expr(ir_unop_i2u, r00E7);
            body.emit(assign(r00D5, bit_or(r00D0, r00E8), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f00E4->else_instructions;

            /* IF CONDITION */
            ir_expression *const r00EA = less(r00D2, body.constant(int(64)));
            ir_if *f00E9 = new(mem_ctx) ir_if(operand(r00EA).val);
            exec_list *const f00E9_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f00E9->then_instructions;

               ir_expression *const r00EB = bit_and(r00D2, body.constant(int(31)));
               ir_expression *const r00EC = rshift(r00D0, r00EB);
               ir_expression *const r00ED = lshift(r00D0, r00D7);
               ir_expression *const r00EE = bit_or(r00ED, r00D1);
               ir_expression *const r00EF = nequal(r00EE, body.constant(0u));
               ir_expression *const r00F0 = expr(ir_unop_b2i, r00EF);
               ir_expression *const r00F1 = expr(ir_unop_i2u, r00F0);
               body.emit(assign(r00D5, bit_or(r00EC, r00F1), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f00E9->else_instructions;

               ir_expression *const r00F2 = bit_or(r00D0, r00D1);
               ir_expression *const r00F3 = nequal(r00F2, body.constant(0u));
               ir_expression *const r00F4 = expr(ir_unop_b2i, r00F3);
               body.emit(assign(r00D5, expr(ir_unop_i2u, r00F4), 0x01));


            body.instructions = f00E9_parent_instructions;
            body.emit(f00E9);

            /* END IF */


         body.instructions = f00E4_parent_instructions;
         body.emit(f00E4);

         /* END IF */

         body.emit(assign(r00D6, body.constant(0u), 0x01));


      body.instructions = f00DB_parent_instructions;
      body.emit(f00DB);

      /* END IF */


   body.instructions = f00D9_parent_instructions;
   body.emit(f00D9);

   /* END IF */

   body.emit(assign(r00D4, r00D5, 0x01));

   body.emit(assign(r00D3, r00D6, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift64ExtraRightJamming(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00F5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00F5);
   ir_variable *const r00F6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00F6);
   ir_variable *const r00F7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a2", ir_var_function_in);
   sig_parameters.push_tail(r00F7);
   ir_variable *const r00F8 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r00F8);
   ir_variable *const r00F9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00F9);
   ir_variable *const r00FA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00FA);
   ir_variable *const r00FB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00FB);
   ir_variable *const r00FC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
   body.emit(r00FC);
   ir_variable *const r00FD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r00FD);
   ir_variable *const r00FE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r00FE);
   ir_variable *const r00FF = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r0100 = neg(r00F8);
   body.emit(assign(r00FF, bit_and(r0100, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r0102 = equal(r00F8, body.constant(int(0)));
   ir_if *f0101 = new(mem_ctx) ir_if(operand(r0102).val);
   exec_list *const f0101_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0101->then_instructions;

      body.emit(assign(r00FC, r00F7, 0x01));

      body.emit(assign(r00FD, r00F6, 0x01));

      body.emit(assign(r00FE, r00F5, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0101->else_instructions;

      /* IF CONDITION */
      ir_expression *const r0104 = less(r00F8, body.constant(int(32)));
      ir_if *f0103 = new(mem_ctx) ir_if(operand(r0104).val);
      exec_list *const f0103_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0103->then_instructions;

         body.emit(assign(r00FC, lshift(r00F6, r00FF), 0x01));

         ir_expression *const r0105 = lshift(r00F5, r00FF);
         ir_expression *const r0106 = rshift(r00F6, r00F8);
         body.emit(assign(r00FD, bit_or(r0105, r0106), 0x01));

         body.emit(assign(r00FE, rshift(r00F5, r00F8), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0103->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0108 = equal(r00F8, body.constant(int(32)));
         ir_if *f0107 = new(mem_ctx) ir_if(operand(r0108).val);
         exec_list *const f0107_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0107->then_instructions;

            body.emit(assign(r00FC, r00F6, 0x01));

            body.emit(assign(r00FD, r00F5, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0107->else_instructions;

            body.emit(assign(r00F7, bit_or(r00F7, r00F6), 0x01));

            /* IF CONDITION */
            ir_expression *const r010A = less(r00F8, body.constant(int(64)));
            ir_if *f0109 = new(mem_ctx) ir_if(operand(r010A).val);
            exec_list *const f0109_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0109->then_instructions;

               body.emit(assign(r00FC, lshift(r00F5, r00FF), 0x01));

               ir_expression *const r010B = bit_and(r00F8, body.constant(int(31)));
               body.emit(assign(r00FD, rshift(r00F5, r010B), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0109->else_instructions;

               ir_variable *const r010C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r010E = equal(r00F8, body.constant(int(64)));
               ir_if *f010D = new(mem_ctx) ir_if(operand(r010E).val);
               exec_list *const f010D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f010D->then_instructions;

                  body.emit(assign(r010C, r00F5, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f010D->else_instructions;

                  ir_expression *const r010F = nequal(r00F5, body.constant(0u));
                  ir_expression *const r0110 = expr(ir_unop_b2i, r010F);
                  body.emit(assign(r010C, expr(ir_unop_i2u, r0110), 0x01));


               body.instructions = f010D_parent_instructions;
               body.emit(f010D);

               /* END IF */

               body.emit(assign(r00FC, r010C, 0x01));

               body.emit(assign(r00FD, body.constant(0u), 0x01));


            body.instructions = f0109_parent_instructions;
            body.emit(f0109);

            /* END IF */


         body.instructions = f0107_parent_instructions;
         body.emit(f0107);

         /* END IF */

         body.emit(assign(r00FE, body.constant(0u), 0x01));


      body.instructions = f0103_parent_instructions;
      body.emit(f0103);

      /* END IF */

      ir_expression *const r0111 = nequal(r00F7, body.constant(0u));
      ir_expression *const r0112 = expr(ir_unop_b2i, r0111);
      ir_expression *const r0113 = expr(ir_unop_i2u, r0112);
      body.emit(assign(r00FC, bit_or(r00FC, r0113), 0x01));


   body.instructions = f0101_parent_instructions;
   body.emit(f0101);

   /* END IF */

   body.emit(assign(r00FB, r00FC, 0x01));

   body.emit(assign(r00FA, r00FD, 0x01));

   body.emit(assign(r00F9, r00FE, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shortShift64Left(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0114 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r0114);
   ir_variable *const r0115 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r0115);
   ir_variable *const r0116 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r0116);
   ir_variable *const r0117 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0117);
   ir_variable *const r0118 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0118);
   body.emit(assign(r0118, lshift(r0115, r0116), 0x01));

   ir_variable *const r0119 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
   /* IF CONDITION */
   ir_expression *const r011B = equal(r0116, body.constant(int(0)));
   ir_if *f011A = new(mem_ctx) ir_if(operand(r011B).val);
   exec_list *const f011A_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f011A->then_instructions;

      body.emit(assign(r0119, r0114, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f011A->else_instructions;

      ir_expression *const r011C = lshift(r0114, r0116);
      ir_expression *const r011D = neg(r0116);
      ir_expression *const r011E = bit_and(r011D, body.constant(int(31)));
      ir_expression *const r011F = rshift(r0115, r011E);
      body.emit(assign(r0119, bit_or(r011C, r011F), 0x01));


   body.instructions = f011A_parent_instructions;
   body.emit(f011A);

   /* END IF */

   body.emit(assign(r0117, r0119, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
packFloat64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0120 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r0120);
   ir_variable *const r0121 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r0121);
   ir_variable *const r0122 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_function_in);
   sig_parameters.push_tail(r0122);
   ir_variable *const r0123 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_function_in);
   sig_parameters.push_tail(r0123);
   ir_variable *const r0124 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
   body.emit(r0124);
   ir_expression *const r0125 = lshift(r0120, body.constant(int(31)));
   ir_expression *const r0126 = expr(ir_unop_i2u, r0121);
   ir_expression *const r0127 = lshift(r0126, body.constant(int(20)));
   ir_expression *const r0128 = add(r0125, r0127);
   body.emit(assign(r0124, add(r0128, r0122), 0x02));

   body.emit(assign(r0124, r0123, 0x01));

   body.emit(ret(r0124));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
roundAndPackFloat64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0129 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r0129);
   ir_variable *const r012A = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r012A);
   ir_variable *const r012B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_function_in);
   sig_parameters.push_tail(r012B);
   ir_variable *const r012C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_function_in);
   sig_parameters.push_tail(r012C);
   ir_variable *const r012D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_function_in);
   sig_parameters.push_tail(r012D);
   ir_variable *const r012E = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r012E, body.constant(true), 0x01));

   ir_variable *const r012F = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r0130 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
   body.emit(r0130);
   ir_expression *const r0131 = expr(ir_unop_u2i, r012D);
   body.emit(assign(r0130, less(r0131, body.constant(int(0))), 0x01));

   /* IF CONDITION */
   ir_expression *const r0133 = lequal(body.constant(int(2045)), r012A);
   ir_if *f0132 = new(mem_ctx) ir_if(operand(r0133).val);
   exec_list *const f0132_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0132->then_instructions;

      ir_variable *const r0134 = body.make_temp(glsl_type::bool_type, "or_tmp");
      /* IF CONDITION */
      ir_expression *const r0136 = less(body.constant(int(2045)), r012A);
      ir_if *f0135 = new(mem_ctx) ir_if(operand(r0136).val);
      exec_list *const f0135_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0135->then_instructions;

         body.emit(assign(r0134, body.constant(true), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0135->else_instructions;

         ir_variable *const r0137 = body.make_temp(glsl_type::bool_type, "and_tmp");
         /* IF CONDITION */
         ir_expression *const r0139 = equal(r012A, body.constant(int(2045)));
         ir_if *f0138 = new(mem_ctx) ir_if(operand(r0139).val);
         exec_list *const f0138_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0138->then_instructions;

            ir_expression *const r013A = equal(body.constant(2097151u), r012B);
            ir_expression *const r013B = equal(body.constant(4294967295u), r012C);
            body.emit(assign(r0137, logic_and(r013A, r013B), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0138->else_instructions;

            body.emit(assign(r0137, body.constant(false), 0x01));


         body.instructions = f0138_parent_instructions;
         body.emit(f0138);

         /* END IF */

         body.emit(assign(r0134, logic_and(r0137, r0130), 0x01));


      body.instructions = f0135_parent_instructions;
      body.emit(f0135);

      /* END IF */

      /* IF CONDITION */
      ir_if *f013C = new(mem_ctx) ir_if(operand(r0134).val);
      exec_list *const f013C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f013C->then_instructions;

         ir_variable *const r013D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r013D);
         ir_expression *const r013E = lshift(r0129, body.constant(int(31)));
         body.emit(assign(r013D, add(r013E, body.constant(2146435072u)), 0x02));

         body.emit(assign(r013D, body.constant(0u), 0x01));

         body.emit(assign(r012F, r013D, 0x03));

         body.emit(assign(r012E, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f013C->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0140 = less(r012A, body.constant(int(0)));
         ir_if *f013F = new(mem_ctx) ir_if(operand(r0140).val);
         exec_list *const f013F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f013F->then_instructions;

            ir_variable *const r0141 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r0141, r012D, 0x01));

            ir_variable *const r0142 = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r0142, neg(r012A), 0x01));

            ir_variable *const r0143 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r0143);
            ir_variable *const r0144 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r0144);
            ir_variable *const r0145 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r0145);
            ir_variable *const r0146 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r0147 = neg(r0142);
            body.emit(assign(r0146, bit_and(r0147, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0149 = equal(r0142, body.constant(int(0)));
            ir_if *f0148 = new(mem_ctx) ir_if(operand(r0149).val);
            exec_list *const f0148_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0148->then_instructions;

               body.emit(assign(r0143, r012D, 0x01));

               body.emit(assign(r0144, r012C, 0x01));

               body.emit(assign(r0145, r012B, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0148->else_instructions;

               /* IF CONDITION */
               ir_expression *const r014B = less(r0142, body.constant(int(32)));
               ir_if *f014A = new(mem_ctx) ir_if(operand(r014B).val);
               exec_list *const f014A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f014A->then_instructions;

                  body.emit(assign(r0143, lshift(r012C, r0146), 0x01));

                  ir_expression *const r014C = lshift(r012B, r0146);
                  ir_expression *const r014D = rshift(r012C, r0142);
                  body.emit(assign(r0144, bit_or(r014C, r014D), 0x01));

                  body.emit(assign(r0145, rshift(r012B, r0142), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f014A->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r014F = equal(r0142, body.constant(int(32)));
                  ir_if *f014E = new(mem_ctx) ir_if(operand(r014F).val);
                  exec_list *const f014E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f014E->then_instructions;

                     body.emit(assign(r0143, r012C, 0x01));

                     body.emit(assign(r0144, r012B, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f014E->else_instructions;

                     body.emit(assign(r0141, bit_or(r012D, r012C), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0151 = less(r0142, body.constant(int(64)));
                     ir_if *f0150 = new(mem_ctx) ir_if(operand(r0151).val);
                     exec_list *const f0150_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0150->then_instructions;

                        body.emit(assign(r0143, lshift(r012B, r0146), 0x01));

                        ir_expression *const r0152 = bit_and(r0142, body.constant(int(31)));
                        body.emit(assign(r0144, rshift(r012B, r0152), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0150->else_instructions;

                        ir_variable *const r0153 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0155 = equal(r0142, body.constant(int(64)));
                        ir_if *f0154 = new(mem_ctx) ir_if(operand(r0155).val);
                        exec_list *const f0154_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0154->then_instructions;

                           body.emit(assign(r0153, r012B, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0154->else_instructions;

                           ir_expression *const r0156 = nequal(r012B, body.constant(0u));
                           ir_expression *const r0157 = expr(ir_unop_b2i, r0156);
                           body.emit(assign(r0153, expr(ir_unop_i2u, r0157), 0x01));


                        body.instructions = f0154_parent_instructions;
                        body.emit(f0154);

                        /* END IF */

                        body.emit(assign(r0143, r0153, 0x01));

                        body.emit(assign(r0144, body.constant(0u), 0x01));


                     body.instructions = f0150_parent_instructions;
                     body.emit(f0150);

                     /* END IF */


                  body.instructions = f014E_parent_instructions;
                  body.emit(f014E);

                  /* END IF */

                  body.emit(assign(r0145, body.constant(0u), 0x01));


               body.instructions = f014A_parent_instructions;
               body.emit(f014A);

               /* END IF */

               ir_expression *const r0158 = nequal(r0141, body.constant(0u));
               ir_expression *const r0159 = expr(ir_unop_b2i, r0158);
               ir_expression *const r015A = expr(ir_unop_i2u, r0159);
               body.emit(assign(r0143, bit_or(r0143, r015A), 0x01));


            body.instructions = f0148_parent_instructions;
            body.emit(f0148);

            /* END IF */

            body.emit(assign(r012B, r0145, 0x01));

            body.emit(assign(r012C, r0144, 0x01));

            body.emit(assign(r012D, r0143, 0x01));

            body.emit(assign(r012A, body.constant(int(0)), 0x01));

            body.emit(assign(r0130, less(r0143, body.constant(0u)), 0x01));


         body.instructions = f013F_parent_instructions;
         body.emit(f013F);

         /* END IF */


      body.instructions = f013C_parent_instructions;
      body.emit(f013C);

      /* END IF */


   body.instructions = f0132_parent_instructions;
   body.emit(f0132);

   /* END IF */

   /* IF CONDITION */
   ir_if *f015B = new(mem_ctx) ir_if(operand(r012E).val);
   exec_list *const f015B_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f015B->then_instructions;

      /* IF CONDITION */
      ir_if *f015C = new(mem_ctx) ir_if(operand(r0130).val);
      exec_list *const f015C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f015C->then_instructions;

         ir_variable *const r015D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r015D, add(r012C, body.constant(1u)), 0x01));

         ir_expression *const r015E = less(r015D, r012C);
         ir_expression *const r015F = expr(ir_unop_b2i, r015E);
         ir_expression *const r0160 = expr(ir_unop_i2u, r015F);
         body.emit(assign(r012B, add(r012B, r0160), 0x01));

         ir_expression *const r0161 = equal(r012D, body.constant(0u));
         ir_expression *const r0162 = expr(ir_unop_b2i, r0161);
         ir_expression *const r0163 = expr(ir_unop_i2u, r0162);
         ir_expression *const r0164 = add(r012D, r0163);
         ir_expression *const r0165 = bit_and(r0164, body.constant(1u));
         ir_expression *const r0166 = expr(ir_unop_bit_not, r0165);
         body.emit(assign(r012C, bit_and(r015D, r0166), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f015C->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0168 = bit_or(r012B, r012C);
         ir_expression *const r0169 = equal(r0168, body.constant(0u));
         ir_if *f0167 = new(mem_ctx) ir_if(operand(r0169).val);
         exec_list *const f0167_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0167->then_instructions;

            body.emit(assign(r012A, body.constant(int(0)), 0x01));


         body.instructions = f0167_parent_instructions;
         body.emit(f0167);

         /* END IF */


      body.instructions = f015C_parent_instructions;
      body.emit(f015C);

      /* END IF */

      ir_variable *const r016A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r016A);
      ir_expression *const r016B = lshift(r0129, body.constant(int(31)));
      ir_expression *const r016C = expr(ir_unop_i2u, r012A);
      ir_expression *const r016D = lshift(r016C, body.constant(int(20)));
      ir_expression *const r016E = add(r016B, r016D);
      body.emit(assign(r016A, add(r016E, r012B), 0x02));

      body.emit(assign(r016A, r012C, 0x01));

      body.emit(assign(r012F, r016A, 0x03));

      body.emit(assign(r012E, body.constant(false), 0x01));


   body.instructions = f015B_parent_instructions;
   body.emit(f015B);

   /* END IF */

   body.emit(ret(r012F));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
countLeadingZeros32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::int_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r016F = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r016F);
   ir_variable *const r0170 = body.make_temp(glsl_type::int_type, "return_value");
   ir_variable *const r0171 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r0171);
   /* IF CONDITION */
   ir_expression *const r0173 = equal(r016F, body.constant(0u));
   ir_if *f0172 = new(mem_ctx) ir_if(operand(r0173).val);
   exec_list *const f0172_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0172->then_instructions;

      body.emit(assign(r0170, body.constant(int(32)), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0172->else_instructions;

      body.emit(assign(r0171, body.constant(int(0)), 0x01));

      /* IF CONDITION */
      ir_expression *const r0175 = bit_and(r016F, body.constant(4294901760u));
      ir_expression *const r0176 = equal(r0175, body.constant(0u));
      ir_if *f0174 = new(mem_ctx) ir_if(operand(r0176).val);
      exec_list *const f0174_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0174->then_instructions;

         body.emit(assign(r0171, body.constant(int(16)), 0x01));

         body.emit(assign(r016F, lshift(r016F, body.constant(int(16))), 0x01));


      body.instructions = f0174_parent_instructions;
      body.emit(f0174);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0178 = bit_and(r016F, body.constant(4278190080u));
      ir_expression *const r0179 = equal(r0178, body.constant(0u));
      ir_if *f0177 = new(mem_ctx) ir_if(operand(r0179).val);
      exec_list *const f0177_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0177->then_instructions;

         body.emit(assign(r0171, add(r0171, body.constant(int(8))), 0x01));

         body.emit(assign(r016F, lshift(r016F, body.constant(int(8))), 0x01));


      body.instructions = f0177_parent_instructions;
      body.emit(f0177);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r017B = bit_and(r016F, body.constant(4026531840u));
      ir_expression *const r017C = equal(r017B, body.constant(0u));
      ir_if *f017A = new(mem_ctx) ir_if(operand(r017C).val);
      exec_list *const f017A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f017A->then_instructions;

         body.emit(assign(r0171, add(r0171, body.constant(int(4))), 0x01));

         body.emit(assign(r016F, lshift(r016F, body.constant(int(4))), 0x01));


      body.instructions = f017A_parent_instructions;
      body.emit(f017A);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r017E = bit_and(r016F, body.constant(3221225472u));
      ir_expression *const r017F = equal(r017E, body.constant(0u));
      ir_if *f017D = new(mem_ctx) ir_if(operand(r017F).val);
      exec_list *const f017D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f017D->then_instructions;

         body.emit(assign(r0171, add(r0171, body.constant(int(2))), 0x01));

         body.emit(assign(r016F, lshift(r016F, body.constant(int(2))), 0x01));


      body.instructions = f017D_parent_instructions;
      body.emit(f017D);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0181 = bit_and(r016F, body.constant(2147483648u));
      ir_expression *const r0182 = equal(r0181, body.constant(0u));
      ir_if *f0180 = new(mem_ctx) ir_if(operand(r0182).val);
      exec_list *const f0180_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0180->then_instructions;

         body.emit(assign(r0171, add(r0171, body.constant(int(1))), 0x01));


      body.instructions = f0180_parent_instructions;
      body.emit(f0180);

      /* END IF */

      body.emit(assign(r0170, r0171, 0x01));


   body.instructions = f0172_parent_instructions;
   body.emit(f0172);

   /* END IF */

   body.emit(ret(r0170));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
normalizeRoundAndPackFloat64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0183 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r0183);
   ir_variable *const r0184 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r0184);
   ir_variable *const r0185 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_function_in);
   sig_parameters.push_tail(r0185);
   ir_variable *const r0186 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_function_in);
   sig_parameters.push_tail(r0186);
   ir_variable *const r0187 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
   body.emit(r0187);
   ir_variable *const r0188 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r0188);
   /* IF CONDITION */
   ir_expression *const r018A = equal(r0185, body.constant(0u));
   ir_if *f0189 = new(mem_ctx) ir_if(operand(r018A).val);
   exec_list *const f0189_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0189->then_instructions;

      body.emit(assign(r0185, r0186, 0x01));

      body.emit(assign(r0186, body.constant(0u), 0x01));

      body.emit(assign(r0184, add(r0184, body.constant(int(-32))), 0x01));


   body.instructions = f0189_parent_instructions;
   body.emit(f0189);

   /* END IF */

   ir_variable *const r018B = body.make_temp(glsl_type::uint_type, "a");
   body.emit(assign(r018B, r0185, 0x01));

   ir_variable *const r018C = body.make_temp(glsl_type::int_type, "return_value");
   ir_variable *const r018D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r018D);
   /* IF CONDITION */
   ir_expression *const r018F = equal(r0185, body.constant(0u));
   ir_if *f018E = new(mem_ctx) ir_if(operand(r018F).val);
   exec_list *const f018E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f018E->then_instructions;

      body.emit(assign(r018C, body.constant(int(32)), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f018E->else_instructions;

      body.emit(assign(r018D, body.constant(int(0)), 0x01));

      /* IF CONDITION */
      ir_expression *const r0191 = bit_and(r0185, body.constant(4294901760u));
      ir_expression *const r0192 = equal(r0191, body.constant(0u));
      ir_if *f0190 = new(mem_ctx) ir_if(operand(r0192).val);
      exec_list *const f0190_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0190->then_instructions;

         body.emit(assign(r018D, body.constant(int(16)), 0x01));

         body.emit(assign(r018B, lshift(r0185, body.constant(int(16))), 0x01));


      body.instructions = f0190_parent_instructions;
      body.emit(f0190);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0194 = bit_and(r018B, body.constant(4278190080u));
      ir_expression *const r0195 = equal(r0194, body.constant(0u));
      ir_if *f0193 = new(mem_ctx) ir_if(operand(r0195).val);
      exec_list *const f0193_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0193->then_instructions;

         body.emit(assign(r018D, add(r018D, body.constant(int(8))), 0x01));

         body.emit(assign(r018B, lshift(r018B, body.constant(int(8))), 0x01));


      body.instructions = f0193_parent_instructions;
      body.emit(f0193);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0197 = bit_and(r018B, body.constant(4026531840u));
      ir_expression *const r0198 = equal(r0197, body.constant(0u));
      ir_if *f0196 = new(mem_ctx) ir_if(operand(r0198).val);
      exec_list *const f0196_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0196->then_instructions;

         body.emit(assign(r018D, add(r018D, body.constant(int(4))), 0x01));

         body.emit(assign(r018B, lshift(r018B, body.constant(int(4))), 0x01));


      body.instructions = f0196_parent_instructions;
      body.emit(f0196);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r019A = bit_and(r018B, body.constant(3221225472u));
      ir_expression *const r019B = equal(r019A, body.constant(0u));
      ir_if *f0199 = new(mem_ctx) ir_if(operand(r019B).val);
      exec_list *const f0199_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0199->then_instructions;

         body.emit(assign(r018D, add(r018D, body.constant(int(2))), 0x01));

         body.emit(assign(r018B, lshift(r018B, body.constant(int(2))), 0x01));


      body.instructions = f0199_parent_instructions;
      body.emit(f0199);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r019D = bit_and(r018B, body.constant(2147483648u));
      ir_expression *const r019E = equal(r019D, body.constant(0u));
      ir_if *f019C = new(mem_ctx) ir_if(operand(r019E).val);
      exec_list *const f019C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f019C->then_instructions;

         body.emit(assign(r018D, add(r018D, body.constant(int(1))), 0x01));


      body.instructions = f019C_parent_instructions;
      body.emit(f019C);

      /* END IF */

      body.emit(assign(r018C, r018D, 0x01));


   body.instructions = f018E_parent_instructions;
   body.emit(f018E);

   /* END IF */

   body.emit(assign(r0188, add(r018C, body.constant(int(-11))), 0x01));

   /* IF CONDITION */
   ir_expression *const r01A0 = lequal(body.constant(int(0)), r0188);
   ir_if *f019F = new(mem_ctx) ir_if(operand(r01A0).val);
   exec_list *const f019F_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f019F->then_instructions;

      body.emit(assign(r0187, body.constant(0u), 0x01));

      ir_variable *const r01A1 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r01A1, lshift(r0186, r0188), 0x01));

      ir_variable *const r01A2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r01A4 = equal(r0188, body.constant(int(0)));
      ir_if *f01A3 = new(mem_ctx) ir_if(operand(r01A4).val);
      exec_list *const f01A3_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01A3->then_instructions;

         body.emit(assign(r01A2, r0185, 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01A3->else_instructions;

         ir_expression *const r01A5 = lshift(r0185, r0188);
         ir_expression *const r01A6 = neg(r0188);
         ir_expression *const r01A7 = bit_and(r01A6, body.constant(int(31)));
         ir_expression *const r01A8 = rshift(r0186, r01A7);
         body.emit(assign(r01A2, bit_or(r01A5, r01A8), 0x01));


      body.instructions = f01A3_parent_instructions;
      body.emit(f01A3);

      /* END IF */

      body.emit(assign(r0185, r01A2, 0x01));

      body.emit(assign(r0186, r01A1, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f019F->else_instructions;

      ir_variable *const r01A9 = body.make_temp(glsl_type::uint_type, "a2");
      body.emit(assign(r01A9, body.constant(0u), 0x01));

      ir_variable *const r01AA = body.make_temp(glsl_type::int_type, "count");
      body.emit(assign(r01AA, neg(r0188), 0x01));

      ir_variable *const r01AB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
      body.emit(r01AB);
      ir_variable *const r01AC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r01AC);
      ir_variable *const r01AD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r01AD);
      ir_variable *const r01AE = body.make_temp(glsl_type::int_type, "assignment_tmp");
      ir_expression *const r01AF = neg(r01AA);
      body.emit(assign(r01AE, bit_and(r01AF, body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r01B1 = equal(r01AA, body.constant(int(0)));
      ir_if *f01B0 = new(mem_ctx) ir_if(operand(r01B1).val);
      exec_list *const f01B0_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01B0->then_instructions;

         body.emit(assign(r01AB, r01A9, 0x01));

         body.emit(assign(r01AC, r0186, 0x01));

         body.emit(assign(r01AD, r0185, 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01B0->else_instructions;

         /* IF CONDITION */
         ir_expression *const r01B3 = less(r01AA, body.constant(int(32)));
         ir_if *f01B2 = new(mem_ctx) ir_if(operand(r01B3).val);
         exec_list *const f01B2_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f01B2->then_instructions;

            body.emit(assign(r01AB, lshift(r0186, r01AE), 0x01));

            ir_expression *const r01B4 = lshift(r0185, r01AE);
            ir_expression *const r01B5 = rshift(r0186, r01AA);
            body.emit(assign(r01AC, bit_or(r01B4, r01B5), 0x01));

            body.emit(assign(r01AD, rshift(r0185, r01AA), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f01B2->else_instructions;

            /* IF CONDITION */
            ir_expression *const r01B7 = equal(r01AA, body.constant(int(32)));
            ir_if *f01B6 = new(mem_ctx) ir_if(operand(r01B7).val);
            exec_list *const f01B6_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f01B6->then_instructions;

               body.emit(assign(r01AB, r0186, 0x01));

               body.emit(assign(r01AC, r0185, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f01B6->else_instructions;

               body.emit(assign(r01A9, bit_or(body.constant(0u), r0186), 0x01));

               /* IF CONDITION */
               ir_expression *const r01B9 = less(r01AA, body.constant(int(64)));
               ir_if *f01B8 = new(mem_ctx) ir_if(operand(r01B9).val);
               exec_list *const f01B8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f01B8->then_instructions;

                  body.emit(assign(r01AB, lshift(r0185, r01AE), 0x01));

                  ir_expression *const r01BA = bit_and(r01AA, body.constant(int(31)));
                  body.emit(assign(r01AC, rshift(r0185, r01BA), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f01B8->else_instructions;

                  ir_variable *const r01BB = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r01BD = equal(r01AA, body.constant(int(64)));
                  ir_if *f01BC = new(mem_ctx) ir_if(operand(r01BD).val);
                  exec_list *const f01BC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f01BC->then_instructions;

                     body.emit(assign(r01BB, r0185, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f01BC->else_instructions;

                     ir_expression *const r01BE = nequal(r0185, body.constant(0u));
                     ir_expression *const r01BF = expr(ir_unop_b2i, r01BE);
                     body.emit(assign(r01BB, expr(ir_unop_i2u, r01BF), 0x01));


                  body.instructions = f01BC_parent_instructions;
                  body.emit(f01BC);

                  /* END IF */

                  body.emit(assign(r01AB, r01BB, 0x01));

                  body.emit(assign(r01AC, body.constant(0u), 0x01));


               body.instructions = f01B8_parent_instructions;
               body.emit(f01B8);

               /* END IF */


            body.instructions = f01B6_parent_instructions;
            body.emit(f01B6);

            /* END IF */

            body.emit(assign(r01AD, body.constant(0u), 0x01));


         body.instructions = f01B2_parent_instructions;
         body.emit(f01B2);

         /* END IF */

         ir_expression *const r01C0 = nequal(r01A9, body.constant(0u));
         ir_expression *const r01C1 = expr(ir_unop_b2i, r01C0);
         ir_expression *const r01C2 = expr(ir_unop_i2u, r01C1);
         body.emit(assign(r01AB, bit_or(r01AB, r01C2), 0x01));


      body.instructions = f01B0_parent_instructions;
      body.emit(f01B0);

      /* END IF */

      body.emit(assign(r0185, r01AD, 0x01));

      body.emit(assign(r0186, r01AC, 0x01));

      body.emit(assign(r0187, r01AB, 0x01));


   body.instructions = f019F_parent_instructions;
   body.emit(f019F);

   /* END IF */

   body.emit(assign(r0184, sub(r0184, r0188), 0x01));

   ir_variable *const r01C3 = body.make_temp(glsl_type::int_type, "zExp");
   body.emit(assign(r01C3, r0184, 0x01));

   ir_variable *const r01C4 = body.make_temp(glsl_type::uint_type, "zFrac0");
   body.emit(assign(r01C4, r0185, 0x01));

   ir_variable *const r01C5 = body.make_temp(glsl_type::uint_type, "zFrac1");
   body.emit(assign(r01C5, r0186, 0x01));

   ir_variable *const r01C6 = body.make_temp(glsl_type::uint_type, "zFrac2");
   body.emit(assign(r01C6, r0187, 0x01));

   ir_variable *const r01C7 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r01C7, body.constant(true), 0x01));

   ir_variable *const r01C8 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r01C9 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
   body.emit(r01C9);
   ir_expression *const r01CA = expr(ir_unop_u2i, r0187);
   body.emit(assign(r01C9, less(r01CA, body.constant(int(0))), 0x01));

   /* IF CONDITION */
   ir_expression *const r01CC = lequal(body.constant(int(2045)), r0184);
   ir_if *f01CB = new(mem_ctx) ir_if(operand(r01CC).val);
   exec_list *const f01CB_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f01CB->then_instructions;

      ir_variable *const r01CD = body.make_temp(glsl_type::bool_type, "or_tmp");
      /* IF CONDITION */
      ir_expression *const r01CF = less(body.constant(int(2045)), r0184);
      ir_if *f01CE = new(mem_ctx) ir_if(operand(r01CF).val);
      exec_list *const f01CE_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01CE->then_instructions;

         body.emit(assign(r01CD, body.constant(true), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01CE->else_instructions;

         ir_variable *const r01D0 = body.make_temp(glsl_type::bool_type, "and_tmp");
         /* IF CONDITION */
         ir_expression *const r01D2 = equal(r0184, body.constant(int(2045)));
         ir_if *f01D1 = new(mem_ctx) ir_if(operand(r01D2).val);
         exec_list *const f01D1_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f01D1->then_instructions;

            ir_expression *const r01D3 = equal(body.constant(2097151u), r0185);
            ir_expression *const r01D4 = equal(body.constant(4294967295u), r0186);
            body.emit(assign(r01D0, logic_and(r01D3, r01D4), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f01D1->else_instructions;

            body.emit(assign(r01D0, body.constant(false), 0x01));


         body.instructions = f01D1_parent_instructions;
         body.emit(f01D1);

         /* END IF */

         body.emit(assign(r01CD, logic_and(r01D0, r01C9), 0x01));


      body.instructions = f01CE_parent_instructions;
      body.emit(f01CE);

      /* END IF */

      /* IF CONDITION */
      ir_if *f01D5 = new(mem_ctx) ir_if(operand(r01CD).val);
      exec_list *const f01D5_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01D5->then_instructions;

         ir_variable *const r01D6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r01D6);
         ir_expression *const r01D7 = lshift(r0183, body.constant(int(31)));
         body.emit(assign(r01D6, add(r01D7, body.constant(2146435072u)), 0x02));

         body.emit(assign(r01D6, body.constant(0u), 0x01));

         body.emit(assign(r01C8, r01D6, 0x03));

         body.emit(assign(r01C7, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01D5->else_instructions;

         /* IF CONDITION */
         ir_expression *const r01D9 = less(r0184, body.constant(int(0)));
         ir_if *f01D8 = new(mem_ctx) ir_if(operand(r01D9).val);
         exec_list *const f01D8_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f01D8->then_instructions;

            ir_variable *const r01DA = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r01DA, r0187, 0x01));

            ir_variable *const r01DB = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r01DB, neg(r0184), 0x01));

            ir_variable *const r01DC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r01DC);
            ir_variable *const r01DD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r01DD);
            ir_variable *const r01DE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r01DE);
            ir_variable *const r01DF = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r01E0 = neg(r01DB);
            body.emit(assign(r01DF, bit_and(r01E0, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r01E2 = equal(r01DB, body.constant(int(0)));
            ir_if *f01E1 = new(mem_ctx) ir_if(operand(r01E2).val);
            exec_list *const f01E1_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f01E1->then_instructions;

               body.emit(assign(r01DC, r0187, 0x01));

               body.emit(assign(r01DD, r0186, 0x01));

               body.emit(assign(r01DE, r0185, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f01E1->else_instructions;

               /* IF CONDITION */
               ir_expression *const r01E4 = less(r01DB, body.constant(int(32)));
               ir_if *f01E3 = new(mem_ctx) ir_if(operand(r01E4).val);
               exec_list *const f01E3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f01E3->then_instructions;

                  body.emit(assign(r01DC, lshift(r0186, r01DF), 0x01));

                  ir_expression *const r01E5 = lshift(r0185, r01DF);
                  ir_expression *const r01E6 = rshift(r0186, r01DB);
                  body.emit(assign(r01DD, bit_or(r01E5, r01E6), 0x01));

                  body.emit(assign(r01DE, rshift(r0185, r01DB), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f01E3->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r01E8 = equal(r01DB, body.constant(int(32)));
                  ir_if *f01E7 = new(mem_ctx) ir_if(operand(r01E8).val);
                  exec_list *const f01E7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f01E7->then_instructions;

                     body.emit(assign(r01DC, r0186, 0x01));

                     body.emit(assign(r01DD, r0185, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f01E7->else_instructions;

                     body.emit(assign(r01DA, bit_or(r0187, r0186), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r01EA = less(r01DB, body.constant(int(64)));
                     ir_if *f01E9 = new(mem_ctx) ir_if(operand(r01EA).val);
                     exec_list *const f01E9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f01E9->then_instructions;

                        body.emit(assign(r01DC, lshift(r0185, r01DF), 0x01));

                        ir_expression *const r01EB = bit_and(r01DB, body.constant(int(31)));
                        body.emit(assign(r01DD, rshift(r0185, r01EB), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f01E9->else_instructions;

                        ir_variable *const r01EC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r01EE = equal(r01DB, body.constant(int(64)));
                        ir_if *f01ED = new(mem_ctx) ir_if(operand(r01EE).val);
                        exec_list *const f01ED_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f01ED->then_instructions;

                           body.emit(assign(r01EC, r0185, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f01ED->else_instructions;

                           ir_expression *const r01EF = nequal(r0185, body.constant(0u));
                           ir_expression *const r01F0 = expr(ir_unop_b2i, r01EF);
                           body.emit(assign(r01EC, expr(ir_unop_i2u, r01F0), 0x01));


                        body.instructions = f01ED_parent_instructions;
                        body.emit(f01ED);

                        /* END IF */

                        body.emit(assign(r01DC, r01EC, 0x01));

                        body.emit(assign(r01DD, body.constant(0u), 0x01));


                     body.instructions = f01E9_parent_instructions;
                     body.emit(f01E9);

                     /* END IF */


                  body.instructions = f01E7_parent_instructions;
                  body.emit(f01E7);

                  /* END IF */

                  body.emit(assign(r01DE, body.constant(0u), 0x01));


               body.instructions = f01E3_parent_instructions;
               body.emit(f01E3);

               /* END IF */

               ir_expression *const r01F1 = nequal(r01DA, body.constant(0u));
               ir_expression *const r01F2 = expr(ir_unop_b2i, r01F1);
               ir_expression *const r01F3 = expr(ir_unop_i2u, r01F2);
               body.emit(assign(r01DC, bit_or(r01DC, r01F3), 0x01));


            body.instructions = f01E1_parent_instructions;
            body.emit(f01E1);

            /* END IF */

            body.emit(assign(r01C4, r01DE, 0x01));

            body.emit(assign(r01C5, r01DD, 0x01));

            body.emit(assign(r01C6, r01DC, 0x01));

            body.emit(assign(r01C3, body.constant(int(0)), 0x01));

            body.emit(assign(r01C9, less(r01DC, body.constant(0u)), 0x01));


         body.instructions = f01D8_parent_instructions;
         body.emit(f01D8);

         /* END IF */


      body.instructions = f01D5_parent_instructions;
      body.emit(f01D5);

      /* END IF */


   body.instructions = f01CB_parent_instructions;
   body.emit(f01CB);

   /* END IF */

   /* IF CONDITION */
   ir_if *f01F4 = new(mem_ctx) ir_if(operand(r01C7).val);
   exec_list *const f01F4_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f01F4->then_instructions;

      /* IF CONDITION */
      ir_if *f01F5 = new(mem_ctx) ir_if(operand(r01C9).val);
      exec_list *const f01F5_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01F5->then_instructions;

         ir_variable *const r01F6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r01F6, add(r01C5, body.constant(1u)), 0x01));

         ir_expression *const r01F7 = less(r01F6, r01C5);
         ir_expression *const r01F8 = expr(ir_unop_b2i, r01F7);
         ir_expression *const r01F9 = expr(ir_unop_i2u, r01F8);
         body.emit(assign(r01C4, add(r01C4, r01F9), 0x01));

         ir_expression *const r01FA = equal(r01C6, body.constant(0u));
         ir_expression *const r01FB = expr(ir_unop_b2i, r01FA);
         ir_expression *const r01FC = expr(ir_unop_i2u, r01FB);
         ir_expression *const r01FD = add(r01C6, r01FC);
         ir_expression *const r01FE = bit_and(r01FD, body.constant(1u));
         ir_expression *const r01FF = expr(ir_unop_bit_not, r01FE);
         body.emit(assign(r01C5, bit_and(r01F6, r01FF), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01F5->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0201 = bit_or(r01C4, r01C5);
         ir_expression *const r0202 = equal(r0201, body.constant(0u));
         ir_if *f0200 = new(mem_ctx) ir_if(operand(r0202).val);
         exec_list *const f0200_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0200->then_instructions;

            body.emit(assign(r01C3, body.constant(int(0)), 0x01));


         body.instructions = f0200_parent_instructions;
         body.emit(f0200);

         /* END IF */


      body.instructions = f01F5_parent_instructions;
      body.emit(f01F5);

      /* END IF */

      ir_variable *const r0203 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r0203);
      ir_expression *const r0204 = lshift(r0183, body.constant(int(31)));
      ir_expression *const r0205 = expr(ir_unop_i2u, r01C3);
      ir_expression *const r0206 = lshift(r0205, body.constant(int(20)));
      ir_expression *const r0207 = add(r0204, r0206);
      body.emit(assign(r0203, add(r0207, r01C4), 0x02));

      body.emit(assign(r0203, r01C5, 0x01));

      body.emit(assign(r01C8, r0203, 0x03));

      body.emit(assign(r01C7, body.constant(false), 0x01));


   body.instructions = f01F4_parent_instructions;
   body.emit(f01F4);

   /* END IF */

   body.emit(ret(r01C8));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
propagateFloat64NaN(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0208 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0208);
   ir_variable *const r0209 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0209);
   ir_variable *const r020A = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r020B = body.make_temp(glsl_type::bool_type, "is_nan_retval");
   ir_expression *const r020C = lshift(swizzle_y(r0208), body.constant(int(1)));
   ir_expression *const r020D = lequal(body.constant(4292870144u), r020C);
   ir_expression *const r020E = nequal(swizzle_x(r0208), body.constant(0u));
   ir_expression *const r020F = bit_and(swizzle_y(r0208), body.constant(1048575u));
   ir_expression *const r0210 = nequal(r020F, body.constant(0u));
   ir_expression *const r0211 = logic_or(r020E, r0210);
   body.emit(assign(r020B, logic_and(r020D, r0211), 0x01));

   ir_variable *const r0212 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
   ir_expression *const r0213 = rshift(swizzle_y(r0208), body.constant(int(19)));
   ir_expression *const r0214 = bit_and(r0213, body.constant(4095u));
   ir_expression *const r0215 = equal(r0214, body.constant(4094u));
   ir_expression *const r0216 = nequal(swizzle_x(r0208), body.constant(0u));
   ir_expression *const r0217 = bit_and(swizzle_y(r0208), body.constant(524287u));
   ir_expression *const r0218 = nequal(r0217, body.constant(0u));
   ir_expression *const r0219 = logic_or(r0216, r0218);
   body.emit(assign(r0212, logic_and(r0215, r0219), 0x01));

   ir_variable *const r021A = body.make_temp(glsl_type::bool_type, "is_nan_retval");
   ir_expression *const r021B = lshift(swizzle_y(r0209), body.constant(int(1)));
   ir_expression *const r021C = lequal(body.constant(4292870144u), r021B);
   ir_expression *const r021D = nequal(swizzle_x(r0209), body.constant(0u));
   ir_expression *const r021E = bit_and(swizzle_y(r0209), body.constant(1048575u));
   ir_expression *const r021F = nequal(r021E, body.constant(0u));
   ir_expression *const r0220 = logic_or(r021D, r021F);
   body.emit(assign(r021A, logic_and(r021C, r0220), 0x01));

   body.emit(assign(r0208, bit_or(swizzle_y(r0208), body.constant(524288u)), 0x02));

   body.emit(assign(r0209, bit_or(swizzle_y(r0209), body.constant(524288u)), 0x02));

   /* IF CONDITION */
   ir_if *f0221 = new(mem_ctx) ir_if(operand(r020B).val);
   exec_list *const f0221_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0221->then_instructions;

      ir_variable *const r0222 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r0224 = logic_and(r0212, r021A);
      ir_if *f0223 = new(mem_ctx) ir_if(operand(r0224).val);
      exec_list *const f0223_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0223->then_instructions;

         body.emit(assign(r0222, r0209, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0223->else_instructions;

         body.emit(assign(r0222, r0208, 0x03));


      body.instructions = f0223_parent_instructions;
      body.emit(f0223);

      /* END IF */

      body.emit(assign(r020A, r0222, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0221->else_instructions;

      body.emit(assign(r020A, r0209, 0x03));


   body.instructions = f0221_parent_instructions;
   body.emit(f0221);

   /* END IF */

   body.emit(ret(r020A));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
addFloat64Fracs(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0225 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0225);
   ir_variable *const r0226 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0226);
   ir_variable *const r0227 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r0227);
   ir_variable *const r0228 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r0228, body.constant(true), 0x01));

   ir_variable *const r0229 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r022A = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
   body.emit(r022A);
   ir_variable *const r022B = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
   body.emit(r022B);
   ir_variable *const r022C = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
   body.emit(r022C);
   ir_variable *const r022D = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r022D);
   ir_variable *const r022E = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
   body.emit(r022E);
   ir_variable *const r022F = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r022F);
   ir_variable *const r0230 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
   body.emit(r0230);
   ir_variable *const r0231 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r0231);
   body.emit(assign(r0231, body.constant(0u), 0x01));

   body.emit(assign(r0230, body.constant(0u), 0x01));

   ir_variable *const r0232 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r0232, swizzle_x(r0225), 0x01));

   body.emit(assign(r022E, r0232, 0x01));

   ir_variable *const r0233 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r0233, bit_and(swizzle_y(r0225), body.constant(1048575u)), 0x01));

   body.emit(assign(r022D, r0233, 0x01));

   ir_variable *const r0234 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r0234, swizzle_x(r0226), 0x01));

   body.emit(assign(r022C, r0234, 0x01));

   ir_variable *const r0235 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r0235, bit_and(swizzle_y(r0226), body.constant(1048575u)), 0x01));

   body.emit(assign(r022B, r0235, 0x01));

   ir_variable *const r0236 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r0237 = rshift(swizzle_y(r0225), body.constant(int(20)));
   ir_expression *const r0238 = bit_and(r0237, body.constant(2047u));
   body.emit(assign(r0236, expr(ir_unop_u2i, r0238), 0x01));

   ir_variable *const r0239 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r023A = rshift(swizzle_y(r0226), body.constant(int(20)));
   ir_expression *const r023B = bit_and(r023A, body.constant(2047u));
   body.emit(assign(r0239, expr(ir_unop_u2i, r023B), 0x01));

   ir_variable *const r023C = body.make_temp(glsl_type::int_type, "assignment_tmp");
   body.emit(assign(r023C, sub(r0236, r0239), 0x01));

   body.emit(assign(r022A, r023C, 0x01));

   /* IF CONDITION */
   ir_expression *const r023E = less(body.constant(int(0)), r023C);
   ir_if *f023D = new(mem_ctx) ir_if(operand(r023E).val);
   exec_list *const f023D_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f023D->then_instructions;

      /* IF CONDITION */
      ir_expression *const r0240 = equal(r0236, body.constant(int(2047)));
      ir_if *f023F = new(mem_ctx) ir_if(operand(r0240).val);
      exec_list *const f023F_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f023F->then_instructions;

         /* IF CONDITION */
         ir_expression *const r0242 = bit_or(r0233, swizzle_x(r0225));
         ir_expression *const r0243 = nequal(r0242, body.constant(0u));
         ir_if *f0241 = new(mem_ctx) ir_if(operand(r0243).val);
         exec_list *const f0241_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0241->then_instructions;

            ir_variable *const r0244 = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r0244, swizzle_x(r0225), 0x01));

            ir_variable *const r0245 = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r0245, swizzle_x(r0226), 0x01));

            ir_variable *const r0246 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0247 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r0248 = rshift(swizzle_y(r0225), body.constant(int(19)));
            ir_expression *const r0249 = bit_and(r0248, body.constant(4095u));
            ir_expression *const r024A = equal(r0249, body.constant(4094u));
            ir_expression *const r024B = nequal(swizzle_x(r0225), body.constant(0u));
            ir_expression *const r024C = bit_and(swizzle_y(r0225), body.constant(524287u));
            ir_expression *const r024D = nequal(r024C, body.constant(0u));
            ir_expression *const r024E = logic_or(r024B, r024D);
            body.emit(assign(r0247, logic_and(r024A, r024E), 0x01));

            ir_variable *const r024F = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r0250 = lshift(swizzle_y(r0226), body.constant(int(1)));
            ir_expression *const r0251 = lequal(body.constant(4292870144u), r0250);
            ir_expression *const r0252 = nequal(swizzle_x(r0226), body.constant(0u));
            ir_expression *const r0253 = bit_and(swizzle_y(r0226), body.constant(1048575u));
            ir_expression *const r0254 = nequal(r0253, body.constant(0u));
            ir_expression *const r0255 = logic_or(r0252, r0254);
            body.emit(assign(r024F, logic_and(r0251, r0255), 0x01));

            body.emit(assign(r0244, bit_or(swizzle_y(r0225), body.constant(524288u)), 0x02));

            body.emit(assign(r0245, bit_or(swizzle_y(r0226), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r0257 = lshift(swizzle_y(r0225), body.constant(int(1)));
            ir_expression *const r0258 = lequal(body.constant(4292870144u), r0257);
            ir_expression *const r0259 = nequal(swizzle_x(r0225), body.constant(0u));
            ir_expression *const r025A = bit_and(swizzle_y(r0225), body.constant(1048575u));
            ir_expression *const r025B = nequal(r025A, body.constant(0u));
            ir_expression *const r025C = logic_or(r0259, r025B);
            ir_expression *const r025D = logic_and(r0258, r025C);
            ir_if *f0256 = new(mem_ctx) ir_if(operand(r025D).val);
            exec_list *const f0256_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0256->then_instructions;

               ir_variable *const r025E = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r0260 = logic_and(r0247, r024F);
               ir_if *f025F = new(mem_ctx) ir_if(operand(r0260).val);
               exec_list *const f025F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f025F->then_instructions;

                  body.emit(assign(r025E, r0245, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f025F->else_instructions;

                  body.emit(assign(r025E, r0244, 0x03));


               body.instructions = f025F_parent_instructions;
               body.emit(f025F);

               /* END IF */

               body.emit(assign(r0246, r025E, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0256->else_instructions;

               body.emit(assign(r0246, r0245, 0x03));


            body.instructions = f0256_parent_instructions;
            body.emit(f0256);

            /* END IF */

            body.emit(assign(r0229, r0246, 0x03));

            body.emit(assign(r0228, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0241->else_instructions;

            body.emit(assign(r0229, r0225, 0x03));

            body.emit(assign(r0228, body.constant(false), 0x01));


         body.instructions = f0241_parent_instructions;
         body.emit(f0241);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f023F->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0262 = equal(r0239, body.constant(int(0)));
         ir_if *f0261 = new(mem_ctx) ir_if(operand(r0262).val);
         exec_list *const f0261_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0261->then_instructions;

            body.emit(assign(r022A, add(r023C, body.constant(int(-1))), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0261->else_instructions;

            body.emit(assign(r022B, bit_or(r0235, body.constant(1048576u)), 0x01));


         body.instructions = f0261_parent_instructions;
         body.emit(f0261);

         /* END IF */

         ir_variable *const r0263 = body.make_temp(glsl_type::uint_type, "a2");
         body.emit(assign(r0263, body.constant(0u), 0x01));

         ir_variable *const r0264 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
         body.emit(r0264);
         ir_variable *const r0265 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r0265);
         ir_variable *const r0266 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r0266);
         ir_variable *const r0267 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         ir_expression *const r0268 = neg(r022A);
         body.emit(assign(r0267, bit_and(r0268, body.constant(int(31))), 0x01));

         /* IF CONDITION */
         ir_expression *const r026A = equal(r022A, body.constant(int(0)));
         ir_if *f0269 = new(mem_ctx) ir_if(operand(r026A).val);
         exec_list *const f0269_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0269->then_instructions;

            body.emit(assign(r0264, r0263, 0x01));

            body.emit(assign(r0265, r0234, 0x01));

            body.emit(assign(r0266, r022B, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0269->else_instructions;

            /* IF CONDITION */
            ir_expression *const r026C = less(r022A, body.constant(int(32)));
            ir_if *f026B = new(mem_ctx) ir_if(operand(r026C).val);
            exec_list *const f026B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f026B->then_instructions;

               body.emit(assign(r0264, lshift(swizzle_x(r0226), r0267), 0x01));

               ir_expression *const r026D = lshift(r022B, r0267);
               ir_expression *const r026E = rshift(swizzle_x(r0226), r022A);
               body.emit(assign(r0265, bit_or(r026D, r026E), 0x01));

               body.emit(assign(r0266, rshift(r022B, r022A), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f026B->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0270 = equal(r022A, body.constant(int(32)));
               ir_if *f026F = new(mem_ctx) ir_if(operand(r0270).val);
               exec_list *const f026F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f026F->then_instructions;

                  body.emit(assign(r0264, r0234, 0x01));

                  body.emit(assign(r0265, r022B, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f026F->else_instructions;

                  body.emit(assign(r0263, bit_or(body.constant(0u), swizzle_x(r0226)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0272 = less(r022A, body.constant(int(64)));
                  ir_if *f0271 = new(mem_ctx) ir_if(operand(r0272).val);
                  exec_list *const f0271_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0271->then_instructions;

                     body.emit(assign(r0264, lshift(r022B, r0267), 0x01));

                     ir_expression *const r0273 = bit_and(r022A, body.constant(int(31)));
                     body.emit(assign(r0265, rshift(r022B, r0273), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0271->else_instructions;

                     ir_variable *const r0274 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0276 = equal(r022A, body.constant(int(64)));
                     ir_if *f0275 = new(mem_ctx) ir_if(operand(r0276).val);
                     exec_list *const f0275_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0275->then_instructions;

                        body.emit(assign(r0274, r022B, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0275->else_instructions;

                        ir_expression *const r0277 = nequal(r022B, body.constant(0u));
                        ir_expression *const r0278 = expr(ir_unop_b2i, r0277);
                        body.emit(assign(r0274, expr(ir_unop_i2u, r0278), 0x01));


                     body.instructions = f0275_parent_instructions;
                     body.emit(f0275);

                     /* END IF */

                     body.emit(assign(r0264, r0274, 0x01));

                     body.emit(assign(r0265, body.constant(0u), 0x01));


                  body.instructions = f0271_parent_instructions;
                  body.emit(f0271);

                  /* END IF */


               body.instructions = f026F_parent_instructions;
               body.emit(f026F);

               /* END IF */

               body.emit(assign(r0266, body.constant(0u), 0x01));


            body.instructions = f026B_parent_instructions;
            body.emit(f026B);

            /* END IF */

            ir_expression *const r0279 = nequal(r0263, body.constant(0u));
            ir_expression *const r027A = expr(ir_unop_b2i, r0279);
            ir_expression *const r027B = expr(ir_unop_i2u, r027A);
            body.emit(assign(r0264, bit_or(r0264, r027B), 0x01));


         body.instructions = f0269_parent_instructions;
         body.emit(f0269);

         /* END IF */

         body.emit(assign(r022B, r0266, 0x01));

         body.emit(assign(r022C, r0265, 0x01));

         body.emit(assign(r0230, r0264, 0x01));

         body.emit(assign(r022F, r0236, 0x01));


      body.instructions = f023F_parent_instructions;
      body.emit(f023F);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f023D->else_instructions;

      /* IF CONDITION */
      ir_expression *const r027D = less(r022A, body.constant(int(0)));
      ir_if *f027C = new(mem_ctx) ir_if(operand(r027D).val);
      exec_list *const f027C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f027C->then_instructions;

         /* IF CONDITION */
         ir_expression *const r027F = equal(r0239, body.constant(int(2047)));
         ir_if *f027E = new(mem_ctx) ir_if(operand(r027F).val);
         exec_list *const f027E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f027E->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0281 = bit_or(r022B, r022C);
            ir_expression *const r0282 = nequal(r0281, body.constant(0u));
            ir_if *f0280 = new(mem_ctx) ir_if(operand(r0282).val);
            exec_list *const f0280_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0280->then_instructions;

               ir_variable *const r0283 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r0283, swizzle_x(r0225), 0x01));

               ir_variable *const r0284 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r0284, swizzle_x(r0226), 0x01));

               ir_variable *const r0285 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0286 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r0287 = rshift(swizzle_y(r0225), body.constant(int(19)));
               ir_expression *const r0288 = bit_and(r0287, body.constant(4095u));
               ir_expression *const r0289 = equal(r0288, body.constant(4094u));
               ir_expression *const r028A = nequal(swizzle_x(r0225), body.constant(0u));
               ir_expression *const r028B = bit_and(swizzle_y(r0225), body.constant(524287u));
               ir_expression *const r028C = nequal(r028B, body.constant(0u));
               ir_expression *const r028D = logic_or(r028A, r028C);
               body.emit(assign(r0286, logic_and(r0289, r028D), 0x01));

               ir_variable *const r028E = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r028F = lshift(swizzle_y(r0226), body.constant(int(1)));
               ir_expression *const r0290 = lequal(body.constant(4292870144u), r028F);
               ir_expression *const r0291 = nequal(swizzle_x(r0226), body.constant(0u));
               ir_expression *const r0292 = bit_and(swizzle_y(r0226), body.constant(1048575u));
               ir_expression *const r0293 = nequal(r0292, body.constant(0u));
               ir_expression *const r0294 = logic_or(r0291, r0293);
               body.emit(assign(r028E, logic_and(r0290, r0294), 0x01));

               body.emit(assign(r0283, bit_or(swizzle_y(r0225), body.constant(524288u)), 0x02));

               body.emit(assign(r0284, bit_or(swizzle_y(r0226), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r0296 = lshift(swizzle_y(r0225), body.constant(int(1)));
               ir_expression *const r0297 = lequal(body.constant(4292870144u), r0296);
               ir_expression *const r0298 = nequal(swizzle_x(r0225), body.constant(0u));
               ir_expression *const r0299 = bit_and(swizzle_y(r0225), body.constant(1048575u));
               ir_expression *const r029A = nequal(r0299, body.constant(0u));
               ir_expression *const r029B = logic_or(r0298, r029A);
               ir_expression *const r029C = logic_and(r0297, r029B);
               ir_if *f0295 = new(mem_ctx) ir_if(operand(r029C).val);
               exec_list *const f0295_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0295->then_instructions;

                  ir_variable *const r029D = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r029F = logic_and(r0286, r028E);
                  ir_if *f029E = new(mem_ctx) ir_if(operand(r029F).val);
                  exec_list *const f029E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f029E->then_instructions;

                     body.emit(assign(r029D, r0284, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f029E->else_instructions;

                     body.emit(assign(r029D, r0283, 0x03));


                  body.instructions = f029E_parent_instructions;
                  body.emit(f029E);

                  /* END IF */

                  body.emit(assign(r0285, r029D, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0295->else_instructions;

                  body.emit(assign(r0285, r0284, 0x03));


               body.instructions = f0295_parent_instructions;
               body.emit(f0295);

               /* END IF */

               body.emit(assign(r0229, r0285, 0x03));

               body.emit(assign(r0228, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0280->else_instructions;

               ir_variable *const r02A0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r02A0);
               ir_expression *const r02A1 = lshift(r0227, body.constant(int(31)));
               body.emit(assign(r02A0, add(r02A1, body.constant(2146435072u)), 0x02));

               body.emit(assign(r02A0, body.constant(0u), 0x01));

               body.emit(assign(r0229, r02A0, 0x03));

               body.emit(assign(r0228, body.constant(false), 0x01));


            body.instructions = f0280_parent_instructions;
            body.emit(f0280);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f027E->else_instructions;

            /* IF CONDITION */
            ir_expression *const r02A3 = equal(r0236, body.constant(int(0)));
            ir_if *f02A2 = new(mem_ctx) ir_if(operand(r02A3).val);
            exec_list *const f02A2_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f02A2->then_instructions;

               body.emit(assign(r022A, add(r022A, body.constant(int(1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f02A2->else_instructions;

               body.emit(assign(r022D, bit_or(r0233, body.constant(1048576u)), 0x01));


            body.instructions = f02A2_parent_instructions;
            body.emit(f02A2);

            /* END IF */

            ir_variable *const r02A4 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r02A4, body.constant(0u), 0x01));

            ir_variable *const r02A5 = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r02A5, neg(r022A), 0x01));

            ir_variable *const r02A6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r02A6);
            ir_variable *const r02A7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r02A7);
            ir_variable *const r02A8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r02A8);
            ir_variable *const r02A9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r02AA = neg(r02A5);
            body.emit(assign(r02A9, bit_and(r02AA, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r02AC = equal(r02A5, body.constant(int(0)));
            ir_if *f02AB = new(mem_ctx) ir_if(operand(r02AC).val);
            exec_list *const f02AB_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f02AB->then_instructions;

               body.emit(assign(r02A6, r02A4, 0x01));

               body.emit(assign(r02A7, r0232, 0x01));

               body.emit(assign(r02A8, r022D, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f02AB->else_instructions;

               /* IF CONDITION */
               ir_expression *const r02AE = less(r02A5, body.constant(int(32)));
               ir_if *f02AD = new(mem_ctx) ir_if(operand(r02AE).val);
               exec_list *const f02AD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f02AD->then_instructions;

                  body.emit(assign(r02A6, lshift(swizzle_x(r0225), r02A9), 0x01));

                  ir_expression *const r02AF = lshift(r022D, r02A9);
                  ir_expression *const r02B0 = rshift(swizzle_x(r0225), r02A5);
                  body.emit(assign(r02A7, bit_or(r02AF, r02B0), 0x01));

                  body.emit(assign(r02A8, rshift(r022D, r02A5), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f02AD->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r02B2 = equal(r02A5, body.constant(int(32)));
                  ir_if *f02B1 = new(mem_ctx) ir_if(operand(r02B2).val);
                  exec_list *const f02B1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f02B1->then_instructions;

                     body.emit(assign(r02A6, r0232, 0x01));

                     body.emit(assign(r02A7, r022D, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f02B1->else_instructions;

                     body.emit(assign(r02A4, bit_or(body.constant(0u), swizzle_x(r0225)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r02B4 = less(r02A5, body.constant(int(64)));
                     ir_if *f02B3 = new(mem_ctx) ir_if(operand(r02B4).val);
                     exec_list *const f02B3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f02B3->then_instructions;

                        body.emit(assign(r02A6, lshift(r022D, r02A9), 0x01));

                        ir_expression *const r02B5 = bit_and(r02A5, body.constant(int(31)));
                        body.emit(assign(r02A7, rshift(r022D, r02B5), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f02B3->else_instructions;

                        ir_variable *const r02B6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r02B8 = equal(r02A5, body.constant(int(64)));
                        ir_if *f02B7 = new(mem_ctx) ir_if(operand(r02B8).val);
                        exec_list *const f02B7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f02B7->then_instructions;

                           body.emit(assign(r02B6, r022D, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f02B7->else_instructions;

                           ir_expression *const r02B9 = nequal(r022D, body.constant(0u));
                           ir_expression *const r02BA = expr(ir_unop_b2i, r02B9);
                           body.emit(assign(r02B6, expr(ir_unop_i2u, r02BA), 0x01));


                        body.instructions = f02B7_parent_instructions;
                        body.emit(f02B7);

                        /* END IF */

                        body.emit(assign(r02A6, r02B6, 0x01));

                        body.emit(assign(r02A7, body.constant(0u), 0x01));


                     body.instructions = f02B3_parent_instructions;
                     body.emit(f02B3);

                     /* END IF */


                  body.instructions = f02B1_parent_instructions;
                  body.emit(f02B1);

                  /* END IF */

                  body.emit(assign(r02A8, body.constant(0u), 0x01));


               body.instructions = f02AD_parent_instructions;
               body.emit(f02AD);

               /* END IF */

               ir_expression *const r02BB = nequal(r02A4, body.constant(0u));
               ir_expression *const r02BC = expr(ir_unop_b2i, r02BB);
               ir_expression *const r02BD = expr(ir_unop_i2u, r02BC);
               body.emit(assign(r02A6, bit_or(r02A6, r02BD), 0x01));


            body.instructions = f02AB_parent_instructions;
            body.emit(f02AB);

            /* END IF */

            body.emit(assign(r022D, r02A8, 0x01));

            body.emit(assign(r022E, r02A7, 0x01));

            body.emit(assign(r0230, r02A6, 0x01));

            body.emit(assign(r022F, r0239, 0x01));


         body.instructions = f027E_parent_instructions;
         body.emit(f027E);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f027C->else_instructions;

         /* IF CONDITION */
         ir_expression *const r02BF = equal(r0236, body.constant(int(2047)));
         ir_if *f02BE = new(mem_ctx) ir_if(operand(r02BF).val);
         exec_list *const f02BE_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f02BE->then_instructions;

            /* IF CONDITION */
            ir_expression *const r02C1 = bit_or(r022D, r022E);
            ir_expression *const r02C2 = bit_or(r022B, r022C);
            ir_expression *const r02C3 = bit_or(r02C1, r02C2);
            ir_expression *const r02C4 = nequal(r02C3, body.constant(0u));
            ir_if *f02C0 = new(mem_ctx) ir_if(operand(r02C4).val);
            exec_list *const f02C0_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f02C0->then_instructions;

               ir_variable *const r02C5 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r02C5, swizzle_x(r0225), 0x01));

               ir_variable *const r02C6 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r02C6, swizzle_x(r0226), 0x01));

               ir_variable *const r02C7 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r02C8 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r02C9 = rshift(swizzle_y(r0225), body.constant(int(19)));
               ir_expression *const r02CA = bit_and(r02C9, body.constant(4095u));
               ir_expression *const r02CB = equal(r02CA, body.constant(4094u));
               ir_expression *const r02CC = nequal(swizzle_x(r0225), body.constant(0u));
               ir_expression *const r02CD = bit_and(swizzle_y(r0225), body.constant(524287u));
               ir_expression *const r02CE = nequal(r02CD, body.constant(0u));
               ir_expression *const r02CF = logic_or(r02CC, r02CE);
               body.emit(assign(r02C8, logic_and(r02CB, r02CF), 0x01));

               ir_variable *const r02D0 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r02D1 = lshift(swizzle_y(r0226), body.constant(int(1)));
               ir_expression *const r02D2 = lequal(body.constant(4292870144u), r02D1);
               ir_expression *const r02D3 = nequal(swizzle_x(r0226), body.constant(0u));
               ir_expression *const r02D4 = bit_and(swizzle_y(r0226), body.constant(1048575u));
               ir_expression *const r02D5 = nequal(r02D4, body.constant(0u));
               ir_expression *const r02D6 = logic_or(r02D3, r02D5);
               body.emit(assign(r02D0, logic_and(r02D2, r02D6), 0x01));

               body.emit(assign(r02C5, bit_or(swizzle_y(r0225), body.constant(524288u)), 0x02));

               body.emit(assign(r02C6, bit_or(swizzle_y(r0226), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r02D8 = lshift(swizzle_y(r0225), body.constant(int(1)));
               ir_expression *const r02D9 = lequal(body.constant(4292870144u), r02D8);
               ir_expression *const r02DA = nequal(swizzle_x(r0225), body.constant(0u));
               ir_expression *const r02DB = bit_and(swizzle_y(r0225), body.constant(1048575u));
               ir_expression *const r02DC = nequal(r02DB, body.constant(0u));
               ir_expression *const r02DD = logic_or(r02DA, r02DC);
               ir_expression *const r02DE = logic_and(r02D9, r02DD);
               ir_if *f02D7 = new(mem_ctx) ir_if(operand(r02DE).val);
               exec_list *const f02D7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f02D7->then_instructions;

                  ir_variable *const r02DF = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r02E1 = logic_and(r02C8, r02D0);
                  ir_if *f02E0 = new(mem_ctx) ir_if(operand(r02E1).val);
                  exec_list *const f02E0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f02E0->then_instructions;

                     body.emit(assign(r02DF, r02C6, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f02E0->else_instructions;

                     body.emit(assign(r02DF, r02C5, 0x03));


                  body.instructions = f02E0_parent_instructions;
                  body.emit(f02E0);

                  /* END IF */

                  body.emit(assign(r02C7, r02DF, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f02D7->else_instructions;

                  body.emit(assign(r02C7, r02C6, 0x03));


               body.instructions = f02D7_parent_instructions;
               body.emit(f02D7);

               /* END IF */

               body.emit(assign(r0229, r02C7, 0x03));

               body.emit(assign(r0228, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f02C0->else_instructions;

               body.emit(assign(r0229, r0225, 0x03));

               body.emit(assign(r0228, body.constant(false), 0x01));


            body.instructions = f02C0_parent_instructions;
            body.emit(f02C0);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f02BE->else_instructions;

            ir_variable *const r02E2 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r02E3 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r02E3, add(r022E, r022C), 0x01));

            ir_expression *const r02E4 = add(r022D, r022B);
            ir_expression *const r02E5 = less(r02E3, r022E);
            ir_expression *const r02E6 = expr(ir_unop_b2i, r02E5);
            ir_expression *const r02E7 = expr(ir_unop_i2u, r02E6);
            body.emit(assign(r02E2, add(r02E4, r02E7), 0x01));

            body.emit(assign(r0231, r02E2, 0x01));

            /* IF CONDITION */
            ir_expression *const r02E9 = equal(r0236, body.constant(int(0)));
            ir_if *f02E8 = new(mem_ctx) ir_if(operand(r02E9).val);
            exec_list *const f02E8_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f02E8->then_instructions;

               ir_variable *const r02EA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r02EA);
               ir_expression *const r02EB = lshift(r0227, body.constant(int(31)));
               body.emit(assign(r02EA, add(r02EB, r02E2), 0x02));

               body.emit(assign(r02EA, r02E3, 0x01));

               body.emit(assign(r0229, r02EA, 0x03));

               body.emit(assign(r0228, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f02E8->else_instructions;

               body.emit(assign(r0231, bit_or(r02E2, body.constant(2097152u)), 0x01));

               body.emit(assign(r022F, r0236, 0x01));

               ir_variable *const r02EC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r02EC);
               ir_variable *const r02ED = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r02ED);
               ir_variable *const r02EE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r02EE);
               body.emit(assign(r02EC, lshift(r02E3, body.constant(int(31))), 0x01));

               ir_expression *const r02EF = lshift(r0231, body.constant(int(31)));
               ir_expression *const r02F0 = rshift(r02E3, body.constant(int(1)));
               body.emit(assign(r02ED, bit_or(r02EF, r02F0), 0x01));

               body.emit(assign(r02EE, rshift(r0231, body.constant(int(1))), 0x01));

               body.emit(assign(r02EC, bit_or(r02EC, body.constant(0u)), 0x01));

               body.emit(assign(r0231, r02EE, 0x01));

               body.emit(assign(r0230, r02EC, 0x01));

               ir_variable *const r02F1 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r02F1, r0236, 0x01));

               ir_variable *const r02F2 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r02F2, r02EE, 0x01));

               ir_variable *const r02F3 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r02F3, r02ED, 0x01));

               ir_variable *const r02F4 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r02F4, r02EC, 0x01));

               ir_variable *const r02F5 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r02F5, body.constant(true), 0x01));

               ir_variable *const r02F6 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r02F7 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r02F7);
               ir_expression *const r02F8 = expr(ir_unop_u2i, r02EC);
               body.emit(assign(r02F7, less(r02F8, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r02FA = lequal(body.constant(int(2045)), r0236);
               ir_if *f02F9 = new(mem_ctx) ir_if(operand(r02FA).val);
               exec_list *const f02F9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f02F9->then_instructions;

                  ir_variable *const r02FB = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r02FD = less(body.constant(int(2045)), r0236);
                  ir_if *f02FC = new(mem_ctx) ir_if(operand(r02FD).val);
                  exec_list *const f02FC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f02FC->then_instructions;

                     body.emit(assign(r02FB, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f02FC->else_instructions;

                     ir_variable *const r02FE = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0300 = equal(r0236, body.constant(int(2045)));
                     ir_if *f02FF = new(mem_ctx) ir_if(operand(r0300).val);
                     exec_list *const f02FF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f02FF->then_instructions;

                        ir_expression *const r0301 = equal(body.constant(2097151u), r02EE);
                        ir_expression *const r0302 = equal(body.constant(4294967295u), r02ED);
                        body.emit(assign(r02FE, logic_and(r0301, r0302), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f02FF->else_instructions;

                        body.emit(assign(r02FE, body.constant(false), 0x01));


                     body.instructions = f02FF_parent_instructions;
                     body.emit(f02FF);

                     /* END IF */

                     body.emit(assign(r02FB, logic_and(r02FE, r02F7), 0x01));


                  body.instructions = f02FC_parent_instructions;
                  body.emit(f02FC);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0303 = new(mem_ctx) ir_if(operand(r02FB).val);
                  exec_list *const f0303_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0303->then_instructions;

                     ir_variable *const r0304 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0304);
                     ir_expression *const r0305 = lshift(r0227, body.constant(int(31)));
                     body.emit(assign(r0304, add(r0305, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r0304, body.constant(0u), 0x01));

                     body.emit(assign(r02F6, r0304, 0x03));

                     body.emit(assign(r02F5, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0303->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0307 = less(r0236, body.constant(int(0)));
                     ir_if *f0306 = new(mem_ctx) ir_if(operand(r0307).val);
                     exec_list *const f0306_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0306->then_instructions;

                        ir_variable *const r0308 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0308, r02EC, 0x01));

                        ir_variable *const r0309 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0309, neg(r0236), 0x01));

                        ir_variable *const r030A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r030A);
                        ir_variable *const r030B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r030B);
                        ir_variable *const r030C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r030C);
                        ir_variable *const r030D = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r030E = neg(r0309);
                        body.emit(assign(r030D, bit_and(r030E, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0310 = equal(r0309, body.constant(int(0)));
                        ir_if *f030F = new(mem_ctx) ir_if(operand(r0310).val);
                        exec_list *const f030F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f030F->then_instructions;

                           body.emit(assign(r030A, r02EC, 0x01));

                           body.emit(assign(r030B, r02ED, 0x01));

                           body.emit(assign(r030C, r02EE, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f030F->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0312 = less(r0309, body.constant(int(32)));
                           ir_if *f0311 = new(mem_ctx) ir_if(operand(r0312).val);
                           exec_list *const f0311_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0311->then_instructions;

                              body.emit(assign(r030A, lshift(r02ED, r030D), 0x01));

                              ir_expression *const r0313 = lshift(r02EE, r030D);
                              ir_expression *const r0314 = rshift(r02ED, r0309);
                              body.emit(assign(r030B, bit_or(r0313, r0314), 0x01));

                              body.emit(assign(r030C, rshift(r02EE, r0309), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0311->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0316 = equal(r0309, body.constant(int(32)));
                              ir_if *f0315 = new(mem_ctx) ir_if(operand(r0316).val);
                              exec_list *const f0315_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0315->then_instructions;

                                 body.emit(assign(r030A, r02ED, 0x01));

                                 body.emit(assign(r030B, r02EE, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0315->else_instructions;

                                 body.emit(assign(r0308, bit_or(r02EC, r02ED), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0318 = less(r0309, body.constant(int(64)));
                                 ir_if *f0317 = new(mem_ctx) ir_if(operand(r0318).val);
                                 exec_list *const f0317_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0317->then_instructions;

                                    body.emit(assign(r030A, lshift(r02EE, r030D), 0x01));

                                    ir_expression *const r0319 = bit_and(r0309, body.constant(int(31)));
                                    body.emit(assign(r030B, rshift(r02EE, r0319), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0317->else_instructions;

                                    ir_variable *const r031A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r031C = equal(r0309, body.constant(int(64)));
                                    ir_if *f031B = new(mem_ctx) ir_if(operand(r031C).val);
                                    exec_list *const f031B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f031B->then_instructions;

                                       body.emit(assign(r031A, r02EE, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f031B->else_instructions;

                                       ir_expression *const r031D = nequal(r02EE, body.constant(0u));
                                       ir_expression *const r031E = expr(ir_unop_b2i, r031D);
                                       body.emit(assign(r031A, expr(ir_unop_i2u, r031E), 0x01));


                                    body.instructions = f031B_parent_instructions;
                                    body.emit(f031B);

                                    /* END IF */

                                    body.emit(assign(r030A, r031A, 0x01));

                                    body.emit(assign(r030B, body.constant(0u), 0x01));


                                 body.instructions = f0317_parent_instructions;
                                 body.emit(f0317);

                                 /* END IF */


                              body.instructions = f0315_parent_instructions;
                              body.emit(f0315);

                              /* END IF */

                              body.emit(assign(r030C, body.constant(0u), 0x01));


                           body.instructions = f0311_parent_instructions;
                           body.emit(f0311);

                           /* END IF */

                           ir_expression *const r031F = nequal(r0308, body.constant(0u));
                           ir_expression *const r0320 = expr(ir_unop_b2i, r031F);
                           ir_expression *const r0321 = expr(ir_unop_i2u, r0320);
                           body.emit(assign(r030A, bit_or(r030A, r0321), 0x01));


                        body.instructions = f030F_parent_instructions;
                        body.emit(f030F);

                        /* END IF */

                        body.emit(assign(r02F2, r030C, 0x01));

                        body.emit(assign(r02F3, r030B, 0x01));

                        body.emit(assign(r02F4, r030A, 0x01));

                        body.emit(assign(r02F1, body.constant(int(0)), 0x01));

                        body.emit(assign(r02F7, less(r030A, body.constant(0u)), 0x01));


                     body.instructions = f0306_parent_instructions;
                     body.emit(f0306);

                     /* END IF */


                  body.instructions = f0303_parent_instructions;
                  body.emit(f0303);

                  /* END IF */


               body.instructions = f02F9_parent_instructions;
               body.emit(f02F9);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0322 = new(mem_ctx) ir_if(operand(r02F5).val);
               exec_list *const f0322_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0322->then_instructions;

                  /* IF CONDITION */
                  ir_if *f0323 = new(mem_ctx) ir_if(operand(r02F7).val);
                  exec_list *const f0323_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0323->then_instructions;

                     ir_variable *const r0324 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r0324, add(r02F3, body.constant(1u)), 0x01));

                     ir_expression *const r0325 = less(r0324, r02F3);
                     ir_expression *const r0326 = expr(ir_unop_b2i, r0325);
                     ir_expression *const r0327 = expr(ir_unop_i2u, r0326);
                     body.emit(assign(r02F2, add(r02F2, r0327), 0x01));

                     ir_expression *const r0328 = equal(r02F4, body.constant(0u));
                     ir_expression *const r0329 = expr(ir_unop_b2i, r0328);
                     ir_expression *const r032A = expr(ir_unop_i2u, r0329);
                     ir_expression *const r032B = add(r02F4, r032A);
                     ir_expression *const r032C = bit_and(r032B, body.constant(1u));
                     ir_expression *const r032D = expr(ir_unop_bit_not, r032C);
                     body.emit(assign(r02F3, bit_and(r0324, r032D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0323->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r032F = bit_or(r02F2, r02F3);
                     ir_expression *const r0330 = equal(r032F, body.constant(0u));
                     ir_if *f032E = new(mem_ctx) ir_if(operand(r0330).val);
                     exec_list *const f032E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f032E->then_instructions;

                        body.emit(assign(r02F1, body.constant(int(0)), 0x01));


                     body.instructions = f032E_parent_instructions;
                     body.emit(f032E);

                     /* END IF */


                  body.instructions = f0323_parent_instructions;
                  body.emit(f0323);

                  /* END IF */

                  ir_variable *const r0331 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0331);
                  ir_expression *const r0332 = lshift(r0227, body.constant(int(31)));
                  ir_expression *const r0333 = expr(ir_unop_i2u, r02F1);
                  ir_expression *const r0334 = lshift(r0333, body.constant(int(20)));
                  ir_expression *const r0335 = add(r0332, r0334);
                  body.emit(assign(r0331, add(r0335, r02F2), 0x02));

                  body.emit(assign(r0331, r02F3, 0x01));

                  body.emit(assign(r02F6, r0331, 0x03));

                  body.emit(assign(r02F5, body.constant(false), 0x01));


               body.instructions = f0322_parent_instructions;
               body.emit(f0322);

               /* END IF */

               body.emit(assign(r0229, r02F6, 0x03));

               body.emit(assign(r0228, body.constant(false), 0x01));


            body.instructions = f02E8_parent_instructions;
            body.emit(f02E8);

            /* END IF */


         body.instructions = f02BE_parent_instructions;
         body.emit(f02BE);

         /* END IF */


      body.instructions = f027C_parent_instructions;
      body.emit(f027C);

      /* END IF */


   body.instructions = f023D_parent_instructions;
   body.emit(f023D);

   /* END IF */

   /* IF CONDITION */
   ir_if *f0336 = new(mem_ctx) ir_if(operand(r0228).val);
   exec_list *const f0336_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0336->then_instructions;

      body.emit(assign(r022D, bit_or(r022D, body.constant(1048576u)), 0x01));

      ir_variable *const r0337 = body.make_temp(glsl_type::uint_type, "z0Ptr");
      ir_variable *const r0338 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r0338, add(r022E, r022C), 0x01));

      ir_expression *const r0339 = add(r022D, r022B);
      ir_expression *const r033A = less(r0338, r022E);
      ir_expression *const r033B = expr(ir_unop_b2i, r033A);
      ir_expression *const r033C = expr(ir_unop_i2u, r033B);
      body.emit(assign(r0337, add(r0339, r033C), 0x01));

      body.emit(assign(r0231, r0337, 0x01));

      body.emit(assign(r022F, add(r022F, body.constant(int(-1))), 0x01));

      /* IF CONDITION */
      ir_expression *const r033E = less(r0337, body.constant(2097152u));
      ir_if *f033D = new(mem_ctx) ir_if(operand(r033E).val);
      exec_list *const f033D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f033D->then_instructions;

         ir_variable *const r033F = body.make_temp(glsl_type::int_type, "zExp");
         body.emit(assign(r033F, r022F, 0x01));

         ir_variable *const r0340 = body.make_temp(glsl_type::uint_type, "zFrac0");
         body.emit(assign(r0340, r0337, 0x01));

         ir_variable *const r0341 = body.make_temp(glsl_type::uint_type, "zFrac1");
         body.emit(assign(r0341, r0338, 0x01));

         ir_variable *const r0342 = body.make_temp(glsl_type::uint_type, "zFrac2");
         body.emit(assign(r0342, r0230, 0x01));

         ir_variable *const r0343 = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r0343, body.constant(true), 0x01));

         ir_variable *const r0344 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r0345 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
         body.emit(r0345);
         ir_expression *const r0346 = expr(ir_unop_u2i, r0230);
         body.emit(assign(r0345, less(r0346, body.constant(int(0))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0348 = lequal(body.constant(int(2045)), r022F);
         ir_if *f0347 = new(mem_ctx) ir_if(operand(r0348).val);
         exec_list *const f0347_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0347->then_instructions;

            ir_variable *const r0349 = body.make_temp(glsl_type::bool_type, "or_tmp");
            /* IF CONDITION */
            ir_expression *const r034B = less(body.constant(int(2045)), r022F);
            ir_if *f034A = new(mem_ctx) ir_if(operand(r034B).val);
            exec_list *const f034A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f034A->then_instructions;

               body.emit(assign(r0349, body.constant(true), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f034A->else_instructions;

               ir_variable *const r034C = body.make_temp(glsl_type::bool_type, "and_tmp");
               /* IF CONDITION */
               ir_expression *const r034E = equal(r022F, body.constant(int(2045)));
               ir_if *f034D = new(mem_ctx) ir_if(operand(r034E).val);
               exec_list *const f034D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f034D->then_instructions;

                  ir_expression *const r034F = equal(body.constant(2097151u), r0337);
                  ir_expression *const r0350 = equal(body.constant(4294967295u), r0338);
                  body.emit(assign(r034C, logic_and(r034F, r0350), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f034D->else_instructions;

                  body.emit(assign(r034C, body.constant(false), 0x01));


               body.instructions = f034D_parent_instructions;
               body.emit(f034D);

               /* END IF */

               body.emit(assign(r0349, logic_and(r034C, r0345), 0x01));


            body.instructions = f034A_parent_instructions;
            body.emit(f034A);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0351 = new(mem_ctx) ir_if(operand(r0349).val);
            exec_list *const f0351_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0351->then_instructions;

               ir_variable *const r0352 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0352);
               ir_expression *const r0353 = lshift(r0227, body.constant(int(31)));
               body.emit(assign(r0352, add(r0353, body.constant(2146435072u)), 0x02));

               body.emit(assign(r0352, body.constant(0u), 0x01));

               body.emit(assign(r0344, r0352, 0x03));

               body.emit(assign(r0343, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0351->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0355 = less(r022F, body.constant(int(0)));
               ir_if *f0354 = new(mem_ctx) ir_if(operand(r0355).val);
               exec_list *const f0354_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0354->then_instructions;

                  ir_variable *const r0356 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r0356, r0230, 0x01));

                  ir_variable *const r0357 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r0357, neg(r022F), 0x01));

                  ir_variable *const r0358 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r0358);
                  ir_variable *const r0359 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r0359);
                  ir_variable *const r035A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r035A);
                  ir_variable *const r035B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r035C = neg(r0357);
                  body.emit(assign(r035B, bit_and(r035C, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r035E = equal(r0357, body.constant(int(0)));
                  ir_if *f035D = new(mem_ctx) ir_if(operand(r035E).val);
                  exec_list *const f035D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f035D->then_instructions;

                     body.emit(assign(r0358, r0230, 0x01));

                     body.emit(assign(r0359, r0338, 0x01));

                     body.emit(assign(r035A, r0337, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f035D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0360 = less(r0357, body.constant(int(32)));
                     ir_if *f035F = new(mem_ctx) ir_if(operand(r0360).val);
                     exec_list *const f035F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f035F->then_instructions;

                        body.emit(assign(r0358, lshift(r0338, r035B), 0x01));

                        ir_expression *const r0361 = lshift(r0337, r035B);
                        ir_expression *const r0362 = rshift(r0338, r0357);
                        body.emit(assign(r0359, bit_or(r0361, r0362), 0x01));

                        body.emit(assign(r035A, rshift(r0337, r0357), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f035F->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0364 = equal(r0357, body.constant(int(32)));
                        ir_if *f0363 = new(mem_ctx) ir_if(operand(r0364).val);
                        exec_list *const f0363_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0363->then_instructions;

                           body.emit(assign(r0358, r0338, 0x01));

                           body.emit(assign(r0359, r0337, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0363->else_instructions;

                           body.emit(assign(r0356, bit_or(r0230, r0338), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0366 = less(r0357, body.constant(int(64)));
                           ir_if *f0365 = new(mem_ctx) ir_if(operand(r0366).val);
                           exec_list *const f0365_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0365->then_instructions;

                              body.emit(assign(r0358, lshift(r0337, r035B), 0x01));

                              ir_expression *const r0367 = bit_and(r0357, body.constant(int(31)));
                              body.emit(assign(r0359, rshift(r0337, r0367), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0365->else_instructions;

                              ir_variable *const r0368 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r036A = equal(r0357, body.constant(int(64)));
                              ir_if *f0369 = new(mem_ctx) ir_if(operand(r036A).val);
                              exec_list *const f0369_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0369->then_instructions;

                                 body.emit(assign(r0368, r0337, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0369->else_instructions;

                                 ir_expression *const r036B = nequal(r0337, body.constant(0u));
                                 ir_expression *const r036C = expr(ir_unop_b2i, r036B);
                                 body.emit(assign(r0368, expr(ir_unop_i2u, r036C), 0x01));


                              body.instructions = f0369_parent_instructions;
                              body.emit(f0369);

                              /* END IF */

                              body.emit(assign(r0358, r0368, 0x01));

                              body.emit(assign(r0359, body.constant(0u), 0x01));


                           body.instructions = f0365_parent_instructions;
                           body.emit(f0365);

                           /* END IF */


                        body.instructions = f0363_parent_instructions;
                        body.emit(f0363);

                        /* END IF */

                        body.emit(assign(r035A, body.constant(0u), 0x01));


                     body.instructions = f035F_parent_instructions;
                     body.emit(f035F);

                     /* END IF */

                     ir_expression *const r036D = nequal(r0356, body.constant(0u));
                     ir_expression *const r036E = expr(ir_unop_b2i, r036D);
                     ir_expression *const r036F = expr(ir_unop_i2u, r036E);
                     body.emit(assign(r0358, bit_or(r0358, r036F), 0x01));


                  body.instructions = f035D_parent_instructions;
                  body.emit(f035D);

                  /* END IF */

                  body.emit(assign(r0340, r035A, 0x01));

                  body.emit(assign(r0341, r0359, 0x01));

                  body.emit(assign(r0342, r0358, 0x01));

                  body.emit(assign(r033F, body.constant(int(0)), 0x01));

                  body.emit(assign(r0345, less(r0358, body.constant(0u)), 0x01));


               body.instructions = f0354_parent_instructions;
               body.emit(f0354);

               /* END IF */


            body.instructions = f0351_parent_instructions;
            body.emit(f0351);

            /* END IF */


         body.instructions = f0347_parent_instructions;
         body.emit(f0347);

         /* END IF */

         /* IF CONDITION */
         ir_if *f0370 = new(mem_ctx) ir_if(operand(r0343).val);
         exec_list *const f0370_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0370->then_instructions;

            /* IF CONDITION */
            ir_if *f0371 = new(mem_ctx) ir_if(operand(r0345).val);
            exec_list *const f0371_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0371->then_instructions;

               ir_variable *const r0372 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0372, add(r0341, body.constant(1u)), 0x01));

               ir_expression *const r0373 = less(r0372, r0341);
               ir_expression *const r0374 = expr(ir_unop_b2i, r0373);
               ir_expression *const r0375 = expr(ir_unop_i2u, r0374);
               body.emit(assign(r0340, add(r0340, r0375), 0x01));

               ir_expression *const r0376 = equal(r0342, body.constant(0u));
               ir_expression *const r0377 = expr(ir_unop_b2i, r0376);
               ir_expression *const r0378 = expr(ir_unop_i2u, r0377);
               ir_expression *const r0379 = add(r0342, r0378);
               ir_expression *const r037A = bit_and(r0379, body.constant(1u));
               ir_expression *const r037B = expr(ir_unop_bit_not, r037A);
               body.emit(assign(r0341, bit_and(r0372, r037B), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0371->else_instructions;

               /* IF CONDITION */
               ir_expression *const r037D = bit_or(r0340, r0341);
               ir_expression *const r037E = equal(r037D, body.constant(0u));
               ir_if *f037C = new(mem_ctx) ir_if(operand(r037E).val);
               exec_list *const f037C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f037C->then_instructions;

                  body.emit(assign(r033F, body.constant(int(0)), 0x01));


               body.instructions = f037C_parent_instructions;
               body.emit(f037C);

               /* END IF */


            body.instructions = f0371_parent_instructions;
            body.emit(f0371);

            /* END IF */

            ir_variable *const r037F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r037F);
            ir_expression *const r0380 = lshift(r0227, body.constant(int(31)));
            ir_expression *const r0381 = expr(ir_unop_i2u, r033F);
            ir_expression *const r0382 = lshift(r0381, body.constant(int(20)));
            ir_expression *const r0383 = add(r0380, r0382);
            body.emit(assign(r037F, add(r0383, r0340), 0x02));

            body.emit(assign(r037F, r0341, 0x01));

            body.emit(assign(r0344, r037F, 0x03));

            body.emit(assign(r0343, body.constant(false), 0x01));


         body.instructions = f0370_parent_instructions;
         body.emit(f0370);

         /* END IF */

         body.emit(assign(r0229, r0344, 0x03));

         body.emit(assign(r0228, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f033D->else_instructions;

         body.emit(assign(r022F, add(r022F, body.constant(int(1))), 0x01));

         ir_variable *const r0384 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
         body.emit(r0384);
         ir_variable *const r0385 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r0385);
         ir_variable *const r0386 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r0386);
         body.emit(assign(r0384, lshift(r0338, body.constant(int(31))), 0x01));

         ir_expression *const r0387 = lshift(r0337, body.constant(int(31)));
         ir_expression *const r0388 = rshift(r0338, body.constant(int(1)));
         body.emit(assign(r0385, bit_or(r0387, r0388), 0x01));

         body.emit(assign(r0386, rshift(r0337, body.constant(int(1))), 0x01));

         ir_expression *const r0389 = nequal(r0230, body.constant(0u));
         ir_expression *const r038A = expr(ir_unop_b2i, r0389);
         ir_expression *const r038B = expr(ir_unop_i2u, r038A);
         body.emit(assign(r0384, bit_or(r0384, r038B), 0x01));

         body.emit(assign(r0231, r0386, 0x01));

         body.emit(assign(r0230, r0384, 0x01));

         ir_variable *const r038C = body.make_temp(glsl_type::int_type, "zExp");
         body.emit(assign(r038C, r022F, 0x01));

         ir_variable *const r038D = body.make_temp(glsl_type::uint_type, "zFrac0");
         body.emit(assign(r038D, r0386, 0x01));

         ir_variable *const r038E = body.make_temp(glsl_type::uint_type, "zFrac1");
         body.emit(assign(r038E, r0385, 0x01));

         ir_variable *const r038F = body.make_temp(glsl_type::uint_type, "zFrac2");
         body.emit(assign(r038F, r0384, 0x01));

         ir_variable *const r0390 = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r0390, body.constant(true), 0x01));

         ir_variable *const r0391 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r0392 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
         body.emit(r0392);
         ir_expression *const r0393 = expr(ir_unop_u2i, r0384);
         body.emit(assign(r0392, less(r0393, body.constant(int(0))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0395 = lequal(body.constant(int(2045)), r022F);
         ir_if *f0394 = new(mem_ctx) ir_if(operand(r0395).val);
         exec_list *const f0394_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0394->then_instructions;

            ir_variable *const r0396 = body.make_temp(glsl_type::bool_type, "or_tmp");
            /* IF CONDITION */
            ir_expression *const r0398 = less(body.constant(int(2045)), r022F);
            ir_if *f0397 = new(mem_ctx) ir_if(operand(r0398).val);
            exec_list *const f0397_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0397->then_instructions;

               body.emit(assign(r0396, body.constant(true), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0397->else_instructions;

               ir_variable *const r0399 = body.make_temp(glsl_type::bool_type, "and_tmp");
               /* IF CONDITION */
               ir_expression *const r039B = equal(r022F, body.constant(int(2045)));
               ir_if *f039A = new(mem_ctx) ir_if(operand(r039B).val);
               exec_list *const f039A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f039A->then_instructions;

                  ir_expression *const r039C = equal(body.constant(2097151u), r0386);
                  ir_expression *const r039D = equal(body.constant(4294967295u), r0385);
                  body.emit(assign(r0399, logic_and(r039C, r039D), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f039A->else_instructions;

                  body.emit(assign(r0399, body.constant(false), 0x01));


               body.instructions = f039A_parent_instructions;
               body.emit(f039A);

               /* END IF */

               body.emit(assign(r0396, logic_and(r0399, r0392), 0x01));


            body.instructions = f0397_parent_instructions;
            body.emit(f0397);

            /* END IF */

            /* IF CONDITION */
            ir_if *f039E = new(mem_ctx) ir_if(operand(r0396).val);
            exec_list *const f039E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f039E->then_instructions;

               ir_variable *const r039F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r039F);
               ir_expression *const r03A0 = lshift(r0227, body.constant(int(31)));
               body.emit(assign(r039F, add(r03A0, body.constant(2146435072u)), 0x02));

               body.emit(assign(r039F, body.constant(0u), 0x01));

               body.emit(assign(r0391, r039F, 0x03));

               body.emit(assign(r0390, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f039E->else_instructions;

               /* IF CONDITION */
               ir_expression *const r03A2 = less(r022F, body.constant(int(0)));
               ir_if *f03A1 = new(mem_ctx) ir_if(operand(r03A2).val);
               exec_list *const f03A1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f03A1->then_instructions;

                  ir_variable *const r03A3 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r03A3, r0384, 0x01));

                  ir_variable *const r03A4 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r03A4, neg(r022F), 0x01));

                  ir_variable *const r03A5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r03A5);
                  ir_variable *const r03A6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r03A6);
                  ir_variable *const r03A7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r03A7);
                  ir_variable *const r03A8 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r03A9 = neg(r03A4);
                  body.emit(assign(r03A8, bit_and(r03A9, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r03AB = equal(r03A4, body.constant(int(0)));
                  ir_if *f03AA = new(mem_ctx) ir_if(operand(r03AB).val);
                  exec_list *const f03AA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f03AA->then_instructions;

                     body.emit(assign(r03A5, r0384, 0x01));

                     body.emit(assign(r03A6, r0385, 0x01));

                     body.emit(assign(r03A7, r0386, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f03AA->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r03AD = less(r03A4, body.constant(int(32)));
                     ir_if *f03AC = new(mem_ctx) ir_if(operand(r03AD).val);
                     exec_list *const f03AC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f03AC->then_instructions;

                        body.emit(assign(r03A5, lshift(r0385, r03A8), 0x01));

                        ir_expression *const r03AE = lshift(r0386, r03A8);
                        ir_expression *const r03AF = rshift(r0385, r03A4);
                        body.emit(assign(r03A6, bit_or(r03AE, r03AF), 0x01));

                        body.emit(assign(r03A7, rshift(r0386, r03A4), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f03AC->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r03B1 = equal(r03A4, body.constant(int(32)));
                        ir_if *f03B0 = new(mem_ctx) ir_if(operand(r03B1).val);
                        exec_list *const f03B0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f03B0->then_instructions;

                           body.emit(assign(r03A5, r0385, 0x01));

                           body.emit(assign(r03A6, r0386, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f03B0->else_instructions;

                           body.emit(assign(r03A3, bit_or(r0384, r0385), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r03B3 = less(r03A4, body.constant(int(64)));
                           ir_if *f03B2 = new(mem_ctx) ir_if(operand(r03B3).val);
                           exec_list *const f03B2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f03B2->then_instructions;

                              body.emit(assign(r03A5, lshift(r0386, r03A8), 0x01));

                              ir_expression *const r03B4 = bit_and(r03A4, body.constant(int(31)));
                              body.emit(assign(r03A6, rshift(r0386, r03B4), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f03B2->else_instructions;

                              ir_variable *const r03B5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r03B7 = equal(r03A4, body.constant(int(64)));
                              ir_if *f03B6 = new(mem_ctx) ir_if(operand(r03B7).val);
                              exec_list *const f03B6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f03B6->then_instructions;

                                 body.emit(assign(r03B5, r0386, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f03B6->else_instructions;

                                 ir_expression *const r03B8 = nequal(r0386, body.constant(0u));
                                 ir_expression *const r03B9 = expr(ir_unop_b2i, r03B8);
                                 body.emit(assign(r03B5, expr(ir_unop_i2u, r03B9), 0x01));


                              body.instructions = f03B6_parent_instructions;
                              body.emit(f03B6);

                              /* END IF */

                              body.emit(assign(r03A5, r03B5, 0x01));

                              body.emit(assign(r03A6, body.constant(0u), 0x01));


                           body.instructions = f03B2_parent_instructions;
                           body.emit(f03B2);

                           /* END IF */


                        body.instructions = f03B0_parent_instructions;
                        body.emit(f03B0);

                        /* END IF */

                        body.emit(assign(r03A7, body.constant(0u), 0x01));


                     body.instructions = f03AC_parent_instructions;
                     body.emit(f03AC);

                     /* END IF */

                     ir_expression *const r03BA = nequal(r03A3, body.constant(0u));
                     ir_expression *const r03BB = expr(ir_unop_b2i, r03BA);
                     ir_expression *const r03BC = expr(ir_unop_i2u, r03BB);
                     body.emit(assign(r03A5, bit_or(r03A5, r03BC), 0x01));


                  body.instructions = f03AA_parent_instructions;
                  body.emit(f03AA);

                  /* END IF */

                  body.emit(assign(r038D, r03A7, 0x01));

                  body.emit(assign(r038E, r03A6, 0x01));

                  body.emit(assign(r038F, r03A5, 0x01));

                  body.emit(assign(r038C, body.constant(int(0)), 0x01));

                  body.emit(assign(r0392, less(r03A5, body.constant(0u)), 0x01));


               body.instructions = f03A1_parent_instructions;
               body.emit(f03A1);

               /* END IF */


            body.instructions = f039E_parent_instructions;
            body.emit(f039E);

            /* END IF */


         body.instructions = f0394_parent_instructions;
         body.emit(f0394);

         /* END IF */

         /* IF CONDITION */
         ir_if *f03BD = new(mem_ctx) ir_if(operand(r0390).val);
         exec_list *const f03BD_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f03BD->then_instructions;

            /* IF CONDITION */
            ir_if *f03BE = new(mem_ctx) ir_if(operand(r0392).val);
            exec_list *const f03BE_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f03BE->then_instructions;

               ir_variable *const r03BF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r03BF, add(r038E, body.constant(1u)), 0x01));

               ir_expression *const r03C0 = less(r03BF, r038E);
               ir_expression *const r03C1 = expr(ir_unop_b2i, r03C0);
               ir_expression *const r03C2 = expr(ir_unop_i2u, r03C1);
               body.emit(assign(r038D, add(r038D, r03C2), 0x01));

               ir_expression *const r03C3 = equal(r038F, body.constant(0u));
               ir_expression *const r03C4 = expr(ir_unop_b2i, r03C3);
               ir_expression *const r03C5 = expr(ir_unop_i2u, r03C4);
               ir_expression *const r03C6 = add(r038F, r03C5);
               ir_expression *const r03C7 = bit_and(r03C6, body.constant(1u));
               ir_expression *const r03C8 = expr(ir_unop_bit_not, r03C7);
               body.emit(assign(r038E, bit_and(r03BF, r03C8), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f03BE->else_instructions;

               /* IF CONDITION */
               ir_expression *const r03CA = bit_or(r038D, r038E);
               ir_expression *const r03CB = equal(r03CA, body.constant(0u));
               ir_if *f03C9 = new(mem_ctx) ir_if(operand(r03CB).val);
               exec_list *const f03C9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f03C9->then_instructions;

                  body.emit(assign(r038C, body.constant(int(0)), 0x01));


               body.instructions = f03C9_parent_instructions;
               body.emit(f03C9);

               /* END IF */


            body.instructions = f03BE_parent_instructions;
            body.emit(f03BE);

            /* END IF */

            ir_variable *const r03CC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r03CC);
            ir_expression *const r03CD = lshift(r0227, body.constant(int(31)));
            ir_expression *const r03CE = expr(ir_unop_i2u, r038C);
            ir_expression *const r03CF = lshift(r03CE, body.constant(int(20)));
            ir_expression *const r03D0 = add(r03CD, r03CF);
            body.emit(assign(r03CC, add(r03D0, r038D), 0x02));

            body.emit(assign(r03CC, r038E, 0x01));

            body.emit(assign(r0391, r03CC, 0x03));

            body.emit(assign(r0390, body.constant(false), 0x01));


         body.instructions = f03BD_parent_instructions;
         body.emit(f03BD);

         /* END IF */

         body.emit(assign(r0229, r0391, 0x03));

         body.emit(assign(r0228, body.constant(false), 0x01));


      body.instructions = f033D_parent_instructions;
      body.emit(f033D);

      /* END IF */


   body.instructions = f0336_parent_instructions;
   body.emit(f0336);

   /* END IF */

   body.emit(ret(r0229));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
subFloat64Fracs(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r03D1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r03D1);
   ir_variable *const r03D2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r03D2);
   ir_variable *const r03D3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r03D3);
   ir_variable *const r03D4 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r03D5 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
   body.emit(r03D5);
   ir_variable *const r03D6 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
   body.emit(r03D6);
   ir_variable *const r03D7 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r03D7);
   ir_variable *const r03D8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
   body.emit(r03D8);
   ir_variable *const r03D9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
   body.emit(r03D9);
   ir_variable *const r03DA = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r03DA);
   ir_variable *const r03DB = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
   body.emit(r03DB);
   ir_variable *const r03DC = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r03DC);
   ir_variable *const r03DD = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r03DE = rshift(swizzle_y(r03D1), body.constant(int(20)));
   ir_expression *const r03DF = bit_and(r03DE, body.constant(2047u));
   body.emit(assign(r03DD, expr(ir_unop_u2i, r03DF), 0x01));

   body.emit(assign(r03D7, r03DD, 0x01));

   ir_variable *const r03E0 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r03E1 = rshift(swizzle_y(r03D2), body.constant(int(20)));
   ir_expression *const r03E2 = bit_and(r03E1, body.constant(2047u));
   body.emit(assign(r03E0, expr(ir_unop_u2i, r03E2), 0x01));

   body.emit(assign(r03D6, r03E0, 0x01));

   body.emit(assign(r03D5, sub(r03DD, r03E0), 0x01));

   ir_variable *const r03E3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
   body.emit(assign(r03E3, lshift(swizzle_x(r03D1), body.constant(int(10))), 0x01));

   ir_variable *const r03E4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
   ir_expression *const r03E5 = bit_and(swizzle_y(r03D1), body.constant(1048575u));
   ir_expression *const r03E6 = lshift(r03E5, body.constant(int(10)));
   ir_expression *const r03E7 = rshift(swizzle_x(r03D1), body.constant(int(22)));
   body.emit(assign(r03E4, bit_or(r03E6, r03E7), 0x01));

   body.emit(assign(r03DA, r03E4, 0x01));

   body.emit(assign(r03DB, r03E3, 0x01));

   ir_variable *const r03E8 = body.make_temp(glsl_type::uint_type, "z1Ptr");
   body.emit(assign(r03E8, lshift(swizzle_x(r03D2), body.constant(int(10))), 0x01));

   ir_variable *const r03E9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
   ir_expression *const r03EA = bit_and(swizzle_y(r03D2), body.constant(1048575u));
   ir_expression *const r03EB = lshift(r03EA, body.constant(int(10)));
   ir_expression *const r03EC = rshift(swizzle_x(r03D2), body.constant(int(22)));
   body.emit(assign(r03E9, bit_or(r03EB, r03EC), 0x01));

   body.emit(assign(r03D8, r03E9, 0x01));

   body.emit(assign(r03D9, r03E8, 0x01));

   /* IF CONDITION */
   ir_expression *const r03EE = less(body.constant(int(0)), r03D5);
   ir_if *f03ED = new(mem_ctx) ir_if(operand(r03EE).val);
   exec_list *const f03ED_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f03ED->then_instructions;

      /* IF CONDITION */
      ir_expression *const r03F0 = equal(r03DD, body.constant(int(2047)));
      ir_if *f03EF = new(mem_ctx) ir_if(operand(r03F0).val);
      exec_list *const f03EF_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f03EF->then_instructions;

         /* IF CONDITION */
         ir_expression *const r03F2 = bit_or(r03E4, r03E3);
         ir_expression *const r03F3 = nequal(r03F2, body.constant(0u));
         ir_if *f03F1 = new(mem_ctx) ir_if(operand(r03F3).val);
         exec_list *const f03F1_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f03F1->then_instructions;

            ir_variable *const r03F4 = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r03F4, swizzle_x(r03D1), 0x01));

            ir_variable *const r03F5 = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r03F5, swizzle_x(r03D2), 0x01));

            ir_variable *const r03F6 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r03F7 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r03F8 = rshift(swizzle_y(r03D1), body.constant(int(19)));
            ir_expression *const r03F9 = bit_and(r03F8, body.constant(4095u));
            ir_expression *const r03FA = equal(r03F9, body.constant(4094u));
            ir_expression *const r03FB = nequal(swizzle_x(r03D1), body.constant(0u));
            ir_expression *const r03FC = bit_and(swizzle_y(r03D1), body.constant(524287u));
            ir_expression *const r03FD = nequal(r03FC, body.constant(0u));
            ir_expression *const r03FE = logic_or(r03FB, r03FD);
            body.emit(assign(r03F7, logic_and(r03FA, r03FE), 0x01));

            ir_variable *const r03FF = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r0400 = lshift(swizzle_y(r03D2), body.constant(int(1)));
            ir_expression *const r0401 = lequal(body.constant(4292870144u), r0400);
            ir_expression *const r0402 = nequal(swizzle_x(r03D2), body.constant(0u));
            ir_expression *const r0403 = bit_and(swizzle_y(r03D2), body.constant(1048575u));
            ir_expression *const r0404 = nequal(r0403, body.constant(0u));
            ir_expression *const r0405 = logic_or(r0402, r0404);
            body.emit(assign(r03FF, logic_and(r0401, r0405), 0x01));

            body.emit(assign(r03F4, bit_or(swizzle_y(r03D1), body.constant(524288u)), 0x02));

            body.emit(assign(r03F5, bit_or(swizzle_y(r03D2), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r0407 = lshift(swizzle_y(r03D1), body.constant(int(1)));
            ir_expression *const r0408 = lequal(body.constant(4292870144u), r0407);
            ir_expression *const r0409 = nequal(swizzle_x(r03D1), body.constant(0u));
            ir_expression *const r040A = bit_and(swizzle_y(r03D1), body.constant(1048575u));
            ir_expression *const r040B = nequal(r040A, body.constant(0u));
            ir_expression *const r040C = logic_or(r0409, r040B);
            ir_expression *const r040D = logic_and(r0408, r040C);
            ir_if *f0406 = new(mem_ctx) ir_if(operand(r040D).val);
            exec_list *const f0406_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0406->then_instructions;

               ir_variable *const r040E = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r0410 = logic_and(r03F7, r03FF);
               ir_if *f040F = new(mem_ctx) ir_if(operand(r0410).val);
               exec_list *const f040F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f040F->then_instructions;

                  body.emit(assign(r040E, r03F5, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f040F->else_instructions;

                  body.emit(assign(r040E, r03F4, 0x03));


               body.instructions = f040F_parent_instructions;
               body.emit(f040F);

               /* END IF */

               body.emit(assign(r03F6, r040E, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0406->else_instructions;

               body.emit(assign(r03F6, r03F5, 0x03));


            body.instructions = f0406_parent_instructions;
            body.emit(f0406);

            /* END IF */

            body.emit(assign(r03D4, r03F6, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f03F1->else_instructions;

            body.emit(assign(r03D4, r03D1, 0x03));


         body.instructions = f03F1_parent_instructions;
         body.emit(f03F1);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f03EF->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0412 = equal(r03E0, body.constant(int(0)));
         ir_if *f0411 = new(mem_ctx) ir_if(operand(r0412).val);
         exec_list *const f0411_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0411->then_instructions;

            body.emit(assign(r03D5, add(r03D5, body.constant(int(-1))), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0411->else_instructions;

            body.emit(assign(r03D8, bit_or(r03E9, body.constant(1073741824u)), 0x01));


         body.instructions = f0411_parent_instructions;
         body.emit(f0411);

         /* END IF */

         ir_variable *const r0413 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r0413);
         ir_variable *const r0414 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r0414);
         ir_variable *const r0415 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         ir_expression *const r0416 = neg(r03D5);
         body.emit(assign(r0415, bit_and(r0416, body.constant(int(31))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0418 = equal(r03D5, body.constant(int(0)));
         ir_if *f0417 = new(mem_ctx) ir_if(operand(r0418).val);
         exec_list *const f0417_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0417->then_instructions;

            body.emit(assign(r0413, r03E8, 0x01));

            body.emit(assign(r0414, r03D8, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0417->else_instructions;

            /* IF CONDITION */
            ir_expression *const r041A = less(r03D5, body.constant(int(32)));
            ir_if *f0419 = new(mem_ctx) ir_if(operand(r041A).val);
            exec_list *const f0419_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0419->then_instructions;

               ir_expression *const r041B = lshift(r03D8, r0415);
               ir_expression *const r041C = rshift(r03E8, r03D5);
               ir_expression *const r041D = bit_or(r041B, r041C);
               ir_expression *const r041E = lshift(r03E8, r0415);
               ir_expression *const r041F = nequal(r041E, body.constant(0u));
               ir_expression *const r0420 = expr(ir_unop_b2i, r041F);
               ir_expression *const r0421 = expr(ir_unop_i2u, r0420);
               body.emit(assign(r0413, bit_or(r041D, r0421), 0x01));

               body.emit(assign(r0414, rshift(r03D8, r03D5), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0419->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0423 = equal(r03D5, body.constant(int(32)));
               ir_if *f0422 = new(mem_ctx) ir_if(operand(r0423).val);
               exec_list *const f0422_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0422->then_instructions;

                  ir_expression *const r0424 = nequal(r03E8, body.constant(0u));
                  ir_expression *const r0425 = expr(ir_unop_b2i, r0424);
                  ir_expression *const r0426 = expr(ir_unop_i2u, r0425);
                  body.emit(assign(r0413, bit_or(r03D8, r0426), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0422->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0428 = less(r03D5, body.constant(int(64)));
                  ir_if *f0427 = new(mem_ctx) ir_if(operand(r0428).val);
                  exec_list *const f0427_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0427->then_instructions;

                     ir_expression *const r0429 = bit_and(r03D5, body.constant(int(31)));
                     ir_expression *const r042A = rshift(r03D8, r0429);
                     ir_expression *const r042B = lshift(r03D8, r0415);
                     ir_expression *const r042C = bit_or(r042B, r03E8);
                     ir_expression *const r042D = nequal(r042C, body.constant(0u));
                     ir_expression *const r042E = expr(ir_unop_b2i, r042D);
                     ir_expression *const r042F = expr(ir_unop_i2u, r042E);
                     body.emit(assign(r0413, bit_or(r042A, r042F), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0427->else_instructions;

                     ir_expression *const r0430 = bit_or(r03D8, r03E8);
                     ir_expression *const r0431 = nequal(r0430, body.constant(0u));
                     ir_expression *const r0432 = expr(ir_unop_b2i, r0431);
                     body.emit(assign(r0413, expr(ir_unop_i2u, r0432), 0x01));


                  body.instructions = f0427_parent_instructions;
                  body.emit(f0427);

                  /* END IF */


               body.instructions = f0422_parent_instructions;
               body.emit(f0422);

               /* END IF */

               body.emit(assign(r0414, body.constant(0u), 0x01));


            body.instructions = f0419_parent_instructions;
            body.emit(f0419);

            /* END IF */


         body.instructions = f0417_parent_instructions;
         body.emit(f0417);

         /* END IF */

         body.emit(assign(r03D8, r0414, 0x01));

         body.emit(assign(r03D9, r0413, 0x01));

         body.emit(assign(r03DA, bit_or(r03E4, body.constant(1073741824u)), 0x01));

         ir_variable *const r0433 = body.make_temp(glsl_type::uint_type, "z0Ptr");
         ir_variable *const r0434 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r0434, sub(r03E3, r0413), 0x01));

         ir_expression *const r0435 = sub(r03DA, r0414);
         ir_expression *const r0436 = less(r03E3, r0413);
         ir_expression *const r0437 = expr(ir_unop_b2i, r0436);
         ir_expression *const r0438 = expr(ir_unop_i2u, r0437);
         body.emit(assign(r0433, sub(r0435, r0438), 0x01));

         body.emit(assign(r03DC, add(r03DD, body.constant(int(-1))), 0x01));

         ir_variable *const r0439 = body.make_temp(glsl_type::int_type, "zExp");
         body.emit(assign(r0439, add(r03DC, body.constant(int(-10))), 0x01));

         ir_variable *const r043A = body.make_temp(glsl_type::uint_type, "zFrac0");
         body.emit(assign(r043A, r0433, 0x01));

         ir_variable *const r043B = body.make_temp(glsl_type::uint_type, "zFrac1");
         body.emit(assign(r043B, r0434, 0x01));

         ir_variable *const r043C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
         body.emit(r043C);
         ir_variable *const r043D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
         body.emit(r043D);
         /* IF CONDITION */
         ir_expression *const r043F = equal(r0433, body.constant(0u));
         ir_if *f043E = new(mem_ctx) ir_if(operand(r043F).val);
         exec_list *const f043E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f043E->then_instructions;

            body.emit(assign(r043A, r0434, 0x01));

            body.emit(assign(r043B, body.constant(0u), 0x01));

            body.emit(assign(r0439, add(r0439, body.constant(int(-32))), 0x01));


         body.instructions = f043E_parent_instructions;
         body.emit(f043E);

         /* END IF */

         ir_variable *const r0440 = body.make_temp(glsl_type::uint_type, "a");
         body.emit(assign(r0440, r043A, 0x01));

         ir_variable *const r0441 = body.make_temp(glsl_type::int_type, "return_value");
         ir_variable *const r0442 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
         body.emit(r0442);
         /* IF CONDITION */
         ir_expression *const r0444 = equal(r043A, body.constant(0u));
         ir_if *f0443 = new(mem_ctx) ir_if(operand(r0444).val);
         exec_list *const f0443_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0443->then_instructions;

            body.emit(assign(r0441, body.constant(int(32)), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0443->else_instructions;

            body.emit(assign(r0442, body.constant(int(0)), 0x01));

            /* IF CONDITION */
            ir_expression *const r0446 = bit_and(r043A, body.constant(4294901760u));
            ir_expression *const r0447 = equal(r0446, body.constant(0u));
            ir_if *f0445 = new(mem_ctx) ir_if(operand(r0447).val);
            exec_list *const f0445_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0445->then_instructions;

               body.emit(assign(r0442, body.constant(int(16)), 0x01));

               body.emit(assign(r0440, lshift(r043A, body.constant(int(16))), 0x01));


            body.instructions = f0445_parent_instructions;
            body.emit(f0445);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r0449 = bit_and(r0440, body.constant(4278190080u));
            ir_expression *const r044A = equal(r0449, body.constant(0u));
            ir_if *f0448 = new(mem_ctx) ir_if(operand(r044A).val);
            exec_list *const f0448_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0448->then_instructions;

               body.emit(assign(r0442, add(r0442, body.constant(int(8))), 0x01));

               body.emit(assign(r0440, lshift(r0440, body.constant(int(8))), 0x01));


            body.instructions = f0448_parent_instructions;
            body.emit(f0448);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r044C = bit_and(r0440, body.constant(4026531840u));
            ir_expression *const r044D = equal(r044C, body.constant(0u));
            ir_if *f044B = new(mem_ctx) ir_if(operand(r044D).val);
            exec_list *const f044B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f044B->then_instructions;

               body.emit(assign(r0442, add(r0442, body.constant(int(4))), 0x01));

               body.emit(assign(r0440, lshift(r0440, body.constant(int(4))), 0x01));


            body.instructions = f044B_parent_instructions;
            body.emit(f044B);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r044F = bit_and(r0440, body.constant(3221225472u));
            ir_expression *const r0450 = equal(r044F, body.constant(0u));
            ir_if *f044E = new(mem_ctx) ir_if(operand(r0450).val);
            exec_list *const f044E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f044E->then_instructions;

               body.emit(assign(r0442, add(r0442, body.constant(int(2))), 0x01));

               body.emit(assign(r0440, lshift(r0440, body.constant(int(2))), 0x01));


            body.instructions = f044E_parent_instructions;
            body.emit(f044E);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r0452 = bit_and(r0440, body.constant(2147483648u));
            ir_expression *const r0453 = equal(r0452, body.constant(0u));
            ir_if *f0451 = new(mem_ctx) ir_if(operand(r0453).val);
            exec_list *const f0451_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0451->then_instructions;

               body.emit(assign(r0442, add(r0442, body.constant(int(1))), 0x01));


            body.instructions = f0451_parent_instructions;
            body.emit(f0451);

            /* END IF */

            body.emit(assign(r0441, r0442, 0x01));


         body.instructions = f0443_parent_instructions;
         body.emit(f0443);

         /* END IF */

         body.emit(assign(r043D, add(r0441, body.constant(int(-11))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0455 = lequal(body.constant(int(0)), r043D);
         ir_if *f0454 = new(mem_ctx) ir_if(operand(r0455).val);
         exec_list *const f0454_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0454->then_instructions;

            body.emit(assign(r043C, body.constant(0u), 0x01));

            ir_variable *const r0456 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r0456, lshift(r043B, r043D), 0x01));

            ir_variable *const r0457 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r0459 = equal(r043D, body.constant(int(0)));
            ir_if *f0458 = new(mem_ctx) ir_if(operand(r0459).val);
            exec_list *const f0458_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0458->then_instructions;

               body.emit(assign(r0457, r043A, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0458->else_instructions;

               ir_expression *const r045A = lshift(r043A, r043D);
               ir_expression *const r045B = neg(r043D);
               ir_expression *const r045C = bit_and(r045B, body.constant(int(31)));
               ir_expression *const r045D = rshift(r043B, r045C);
               body.emit(assign(r0457, bit_or(r045A, r045D), 0x01));


            body.instructions = f0458_parent_instructions;
            body.emit(f0458);

            /* END IF */

            body.emit(assign(r043A, r0457, 0x01));

            body.emit(assign(r043B, r0456, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0454->else_instructions;

            ir_variable *const r045E = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r045E, body.constant(0u), 0x01));

            ir_variable *const r045F = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r045F, neg(r043D), 0x01));

            ir_variable *const r0460 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r0460);
            ir_variable *const r0461 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r0461);
            ir_variable *const r0462 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r0462);
            ir_variable *const r0463 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r0464 = neg(r045F);
            body.emit(assign(r0463, bit_and(r0464, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0466 = equal(r045F, body.constant(int(0)));
            ir_if *f0465 = new(mem_ctx) ir_if(operand(r0466).val);
            exec_list *const f0465_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0465->then_instructions;

               body.emit(assign(r0460, r045E, 0x01));

               body.emit(assign(r0461, r043B, 0x01));

               body.emit(assign(r0462, r043A, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0465->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0468 = less(r045F, body.constant(int(32)));
               ir_if *f0467 = new(mem_ctx) ir_if(operand(r0468).val);
               exec_list *const f0467_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0467->then_instructions;

                  body.emit(assign(r0460, lshift(r043B, r0463), 0x01));

                  ir_expression *const r0469 = lshift(r043A, r0463);
                  ir_expression *const r046A = rshift(r043B, r045F);
                  body.emit(assign(r0461, bit_or(r0469, r046A), 0x01));

                  body.emit(assign(r0462, rshift(r043A, r045F), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0467->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r046C = equal(r045F, body.constant(int(32)));
                  ir_if *f046B = new(mem_ctx) ir_if(operand(r046C).val);
                  exec_list *const f046B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f046B->then_instructions;

                     body.emit(assign(r0460, r043B, 0x01));

                     body.emit(assign(r0461, r043A, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f046B->else_instructions;

                     body.emit(assign(r045E, bit_or(body.constant(0u), r043B), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r046E = less(r045F, body.constant(int(64)));
                     ir_if *f046D = new(mem_ctx) ir_if(operand(r046E).val);
                     exec_list *const f046D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f046D->then_instructions;

                        body.emit(assign(r0460, lshift(r043A, r0463), 0x01));

                        ir_expression *const r046F = bit_and(r045F, body.constant(int(31)));
                        body.emit(assign(r0461, rshift(r043A, r046F), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f046D->else_instructions;

                        ir_variable *const r0470 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0472 = equal(r045F, body.constant(int(64)));
                        ir_if *f0471 = new(mem_ctx) ir_if(operand(r0472).val);
                        exec_list *const f0471_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0471->then_instructions;

                           body.emit(assign(r0470, r043A, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0471->else_instructions;

                           ir_expression *const r0473 = nequal(r043A, body.constant(0u));
                           ir_expression *const r0474 = expr(ir_unop_b2i, r0473);
                           body.emit(assign(r0470, expr(ir_unop_i2u, r0474), 0x01));


                        body.instructions = f0471_parent_instructions;
                        body.emit(f0471);

                        /* END IF */

                        body.emit(assign(r0460, r0470, 0x01));

                        body.emit(assign(r0461, body.constant(0u), 0x01));


                     body.instructions = f046D_parent_instructions;
                     body.emit(f046D);

                     /* END IF */


                  body.instructions = f046B_parent_instructions;
                  body.emit(f046B);

                  /* END IF */

                  body.emit(assign(r0462, body.constant(0u), 0x01));


               body.instructions = f0467_parent_instructions;
               body.emit(f0467);

               /* END IF */

               ir_expression *const r0475 = nequal(r045E, body.constant(0u));
               ir_expression *const r0476 = expr(ir_unop_b2i, r0475);
               ir_expression *const r0477 = expr(ir_unop_i2u, r0476);
               body.emit(assign(r0460, bit_or(r0460, r0477), 0x01));


            body.instructions = f0465_parent_instructions;
            body.emit(f0465);

            /* END IF */

            body.emit(assign(r043A, r0462, 0x01));

            body.emit(assign(r043B, r0461, 0x01));

            body.emit(assign(r043C, r0460, 0x01));


         body.instructions = f0454_parent_instructions;
         body.emit(f0454);

         /* END IF */

         body.emit(assign(r0439, sub(r0439, r043D), 0x01));

         ir_variable *const r0478 = body.make_temp(glsl_type::int_type, "zExp");
         body.emit(assign(r0478, r0439, 0x01));

         ir_variable *const r0479 = body.make_temp(glsl_type::uint_type, "zFrac0");
         body.emit(assign(r0479, r043A, 0x01));

         ir_variable *const r047A = body.make_temp(glsl_type::uint_type, "zFrac1");
         body.emit(assign(r047A, r043B, 0x01));

         ir_variable *const r047B = body.make_temp(glsl_type::uint_type, "zFrac2");
         body.emit(assign(r047B, r043C, 0x01));

         ir_variable *const r047C = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r047C, body.constant(true), 0x01));

         ir_variable *const r047D = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r047E = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
         body.emit(r047E);
         ir_expression *const r047F = expr(ir_unop_u2i, r043C);
         body.emit(assign(r047E, less(r047F, body.constant(int(0))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0481 = lequal(body.constant(int(2045)), r0439);
         ir_if *f0480 = new(mem_ctx) ir_if(operand(r0481).val);
         exec_list *const f0480_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0480->then_instructions;

            ir_variable *const r0482 = body.make_temp(glsl_type::bool_type, "or_tmp");
            /* IF CONDITION */
            ir_expression *const r0484 = less(body.constant(int(2045)), r0439);
            ir_if *f0483 = new(mem_ctx) ir_if(operand(r0484).val);
            exec_list *const f0483_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0483->then_instructions;

               body.emit(assign(r0482, body.constant(true), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0483->else_instructions;

               ir_variable *const r0485 = body.make_temp(glsl_type::bool_type, "and_tmp");
               /* IF CONDITION */
               ir_expression *const r0487 = equal(r0439, body.constant(int(2045)));
               ir_if *f0486 = new(mem_ctx) ir_if(operand(r0487).val);
               exec_list *const f0486_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0486->then_instructions;

                  ir_expression *const r0488 = equal(body.constant(2097151u), r043A);
                  ir_expression *const r0489 = equal(body.constant(4294967295u), r043B);
                  body.emit(assign(r0485, logic_and(r0488, r0489), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0486->else_instructions;

                  body.emit(assign(r0485, body.constant(false), 0x01));


               body.instructions = f0486_parent_instructions;
               body.emit(f0486);

               /* END IF */

               body.emit(assign(r0482, logic_and(r0485, r047E), 0x01));


            body.instructions = f0483_parent_instructions;
            body.emit(f0483);

            /* END IF */

            /* IF CONDITION */
            ir_if *f048A = new(mem_ctx) ir_if(operand(r0482).val);
            exec_list *const f048A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f048A->then_instructions;

               ir_variable *const r048B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r048B);
               ir_expression *const r048C = lshift(r03D3, body.constant(int(31)));
               body.emit(assign(r048B, add(r048C, body.constant(2146435072u)), 0x02));

               body.emit(assign(r048B, body.constant(0u), 0x01));

               body.emit(assign(r047D, r048B, 0x03));

               body.emit(assign(r047C, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f048A->else_instructions;

               /* IF CONDITION */
               ir_expression *const r048E = less(r0439, body.constant(int(0)));
               ir_if *f048D = new(mem_ctx) ir_if(operand(r048E).val);
               exec_list *const f048D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f048D->then_instructions;

                  ir_variable *const r048F = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r048F, r043C, 0x01));

                  ir_variable *const r0490 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r0490, neg(r0439), 0x01));

                  ir_variable *const r0491 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r0491);
                  ir_variable *const r0492 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r0492);
                  ir_variable *const r0493 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r0493);
                  ir_variable *const r0494 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r0495 = neg(r0490);
                  body.emit(assign(r0494, bit_and(r0495, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0497 = equal(r0490, body.constant(int(0)));
                  ir_if *f0496 = new(mem_ctx) ir_if(operand(r0497).val);
                  exec_list *const f0496_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0496->then_instructions;

                     body.emit(assign(r0491, r043C, 0x01));

                     body.emit(assign(r0492, r043B, 0x01));

                     body.emit(assign(r0493, r043A, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0496->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0499 = less(r0490, body.constant(int(32)));
                     ir_if *f0498 = new(mem_ctx) ir_if(operand(r0499).val);
                     exec_list *const f0498_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0498->then_instructions;

                        body.emit(assign(r0491, lshift(r043B, r0494), 0x01));

                        ir_expression *const r049A = lshift(r043A, r0494);
                        ir_expression *const r049B = rshift(r043B, r0490);
                        body.emit(assign(r0492, bit_or(r049A, r049B), 0x01));

                        body.emit(assign(r0493, rshift(r043A, r0490), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0498->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r049D = equal(r0490, body.constant(int(32)));
                        ir_if *f049C = new(mem_ctx) ir_if(operand(r049D).val);
                        exec_list *const f049C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f049C->then_instructions;

                           body.emit(assign(r0491, r043B, 0x01));

                           body.emit(assign(r0492, r043A, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f049C->else_instructions;

                           body.emit(assign(r048F, bit_or(r043C, r043B), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r049F = less(r0490, body.constant(int(64)));
                           ir_if *f049E = new(mem_ctx) ir_if(operand(r049F).val);
                           exec_list *const f049E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f049E->then_instructions;

                              body.emit(assign(r0491, lshift(r043A, r0494), 0x01));

                              ir_expression *const r04A0 = bit_and(r0490, body.constant(int(31)));
                              body.emit(assign(r0492, rshift(r043A, r04A0), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f049E->else_instructions;

                              ir_variable *const r04A1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r04A3 = equal(r0490, body.constant(int(64)));
                              ir_if *f04A2 = new(mem_ctx) ir_if(operand(r04A3).val);
                              exec_list *const f04A2_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f04A2->then_instructions;

                                 body.emit(assign(r04A1, r043A, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f04A2->else_instructions;

                                 ir_expression *const r04A4 = nequal(r043A, body.constant(0u));
                                 ir_expression *const r04A5 = expr(ir_unop_b2i, r04A4);
                                 body.emit(assign(r04A1, expr(ir_unop_i2u, r04A5), 0x01));


                              body.instructions = f04A2_parent_instructions;
                              body.emit(f04A2);

                              /* END IF */

                              body.emit(assign(r0491, r04A1, 0x01));

                              body.emit(assign(r0492, body.constant(0u), 0x01));


                           body.instructions = f049E_parent_instructions;
                           body.emit(f049E);

                           /* END IF */


                        body.instructions = f049C_parent_instructions;
                        body.emit(f049C);

                        /* END IF */

                        body.emit(assign(r0493, body.constant(0u), 0x01));


                     body.instructions = f0498_parent_instructions;
                     body.emit(f0498);

                     /* END IF */

                     ir_expression *const r04A6 = nequal(r048F, body.constant(0u));
                     ir_expression *const r04A7 = expr(ir_unop_b2i, r04A6);
                     ir_expression *const r04A8 = expr(ir_unop_i2u, r04A7);
                     body.emit(assign(r0491, bit_or(r0491, r04A8), 0x01));


                  body.instructions = f0496_parent_instructions;
                  body.emit(f0496);

                  /* END IF */

                  body.emit(assign(r0479, r0493, 0x01));

                  body.emit(assign(r047A, r0492, 0x01));

                  body.emit(assign(r047B, r0491, 0x01));

                  body.emit(assign(r0478, body.constant(int(0)), 0x01));

                  body.emit(assign(r047E, less(r0491, body.constant(0u)), 0x01));


               body.instructions = f048D_parent_instructions;
               body.emit(f048D);

               /* END IF */


            body.instructions = f048A_parent_instructions;
            body.emit(f048A);

            /* END IF */


         body.instructions = f0480_parent_instructions;
         body.emit(f0480);

         /* END IF */

         /* IF CONDITION */
         ir_if *f04A9 = new(mem_ctx) ir_if(operand(r047C).val);
         exec_list *const f04A9_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f04A9->then_instructions;

            /* IF CONDITION */
            ir_if *f04AA = new(mem_ctx) ir_if(operand(r047E).val);
            exec_list *const f04AA_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f04AA->then_instructions;

               ir_variable *const r04AB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r04AB, add(r047A, body.constant(1u)), 0x01));

               ir_expression *const r04AC = less(r04AB, r047A);
               ir_expression *const r04AD = expr(ir_unop_b2i, r04AC);
               ir_expression *const r04AE = expr(ir_unop_i2u, r04AD);
               body.emit(assign(r0479, add(r0479, r04AE), 0x01));

               ir_expression *const r04AF = equal(r047B, body.constant(0u));
               ir_expression *const r04B0 = expr(ir_unop_b2i, r04AF);
               ir_expression *const r04B1 = expr(ir_unop_i2u, r04B0);
               ir_expression *const r04B2 = add(r047B, r04B1);
               ir_expression *const r04B3 = bit_and(r04B2, body.constant(1u));
               ir_expression *const r04B4 = expr(ir_unop_bit_not, r04B3);
               body.emit(assign(r047A, bit_and(r04AB, r04B4), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f04AA->else_instructions;

               /* IF CONDITION */
               ir_expression *const r04B6 = bit_or(r0479, r047A);
               ir_expression *const r04B7 = equal(r04B6, body.constant(0u));
               ir_if *f04B5 = new(mem_ctx) ir_if(operand(r04B7).val);
               exec_list *const f04B5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f04B5->then_instructions;

                  body.emit(assign(r0478, body.constant(int(0)), 0x01));


               body.instructions = f04B5_parent_instructions;
               body.emit(f04B5);

               /* END IF */


            body.instructions = f04AA_parent_instructions;
            body.emit(f04AA);

            /* END IF */

            ir_variable *const r04B8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r04B8);
            ir_expression *const r04B9 = lshift(r03D3, body.constant(int(31)));
            ir_expression *const r04BA = expr(ir_unop_i2u, r0478);
            ir_expression *const r04BB = lshift(r04BA, body.constant(int(20)));
            ir_expression *const r04BC = add(r04B9, r04BB);
            body.emit(assign(r04B8, add(r04BC, r0479), 0x02));

            body.emit(assign(r04B8, r047A, 0x01));

            body.emit(assign(r047D, r04B8, 0x03));

            body.emit(assign(r047C, body.constant(false), 0x01));


         body.instructions = f04A9_parent_instructions;
         body.emit(f04A9);

         /* END IF */

         body.emit(assign(r03D4, r047D, 0x03));


      body.instructions = f03EF_parent_instructions;
      body.emit(f03EF);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f03ED->else_instructions;

      /* IF CONDITION */
      ir_expression *const r04BE = less(r03D5, body.constant(int(0)));
      ir_if *f04BD = new(mem_ctx) ir_if(operand(r04BE).val);
      exec_list *const f04BD_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f04BD->then_instructions;

         /* IF CONDITION */
         ir_expression *const r04C0 = equal(r03E0, body.constant(int(2047)));
         ir_if *f04BF = new(mem_ctx) ir_if(operand(r04C0).val);
         exec_list *const f04BF_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f04BF->then_instructions;

            /* IF CONDITION */
            ir_expression *const r04C2 = bit_or(r03D8, r03D9);
            ir_expression *const r04C3 = nequal(r04C2, body.constant(0u));
            ir_if *f04C1 = new(mem_ctx) ir_if(operand(r04C3).val);
            exec_list *const f04C1_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f04C1->then_instructions;

               ir_variable *const r04C4 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r04C4, swizzle_x(r03D1), 0x01));

               ir_variable *const r04C5 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r04C5, swizzle_x(r03D2), 0x01));

               ir_variable *const r04C6 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r04C7 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r04C8 = rshift(swizzle_y(r03D1), body.constant(int(19)));
               ir_expression *const r04C9 = bit_and(r04C8, body.constant(4095u));
               ir_expression *const r04CA = equal(r04C9, body.constant(4094u));
               ir_expression *const r04CB = nequal(swizzle_x(r03D1), body.constant(0u));
               ir_expression *const r04CC = bit_and(swizzle_y(r03D1), body.constant(524287u));
               ir_expression *const r04CD = nequal(r04CC, body.constant(0u));
               ir_expression *const r04CE = logic_or(r04CB, r04CD);
               body.emit(assign(r04C7, logic_and(r04CA, r04CE), 0x01));

               ir_variable *const r04CF = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r04D0 = lshift(swizzle_y(r03D2), body.constant(int(1)));
               ir_expression *const r04D1 = lequal(body.constant(4292870144u), r04D0);
               ir_expression *const r04D2 = nequal(swizzle_x(r03D2), body.constant(0u));
               ir_expression *const r04D3 = bit_and(swizzle_y(r03D2), body.constant(1048575u));
               ir_expression *const r04D4 = nequal(r04D3, body.constant(0u));
               ir_expression *const r04D5 = logic_or(r04D2, r04D4);
               body.emit(assign(r04CF, logic_and(r04D1, r04D5), 0x01));

               body.emit(assign(r04C4, bit_or(swizzle_y(r03D1), body.constant(524288u)), 0x02));

               body.emit(assign(r04C5, bit_or(swizzle_y(r03D2), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r04D7 = lshift(swizzle_y(r03D1), body.constant(int(1)));
               ir_expression *const r04D8 = lequal(body.constant(4292870144u), r04D7);
               ir_expression *const r04D9 = nequal(swizzle_x(r03D1), body.constant(0u));
               ir_expression *const r04DA = bit_and(swizzle_y(r03D1), body.constant(1048575u));
               ir_expression *const r04DB = nequal(r04DA, body.constant(0u));
               ir_expression *const r04DC = logic_or(r04D9, r04DB);
               ir_expression *const r04DD = logic_and(r04D8, r04DC);
               ir_if *f04D6 = new(mem_ctx) ir_if(operand(r04DD).val);
               exec_list *const f04D6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f04D6->then_instructions;

                  ir_variable *const r04DE = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r04E0 = logic_and(r04C7, r04CF);
                  ir_if *f04DF = new(mem_ctx) ir_if(operand(r04E0).val);
                  exec_list *const f04DF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f04DF->then_instructions;

                     body.emit(assign(r04DE, r04C5, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f04DF->else_instructions;

                     body.emit(assign(r04DE, r04C4, 0x03));


                  body.instructions = f04DF_parent_instructions;
                  body.emit(f04DF);

                  /* END IF */

                  body.emit(assign(r04C6, r04DE, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f04D6->else_instructions;

                  body.emit(assign(r04C6, r04C5, 0x03));


               body.instructions = f04D6_parent_instructions;
               body.emit(f04D6);

               /* END IF */

               body.emit(assign(r03D4, r04C6, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f04C1->else_instructions;

               ir_variable *const r04E1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r04E1);
               ir_expression *const r04E2 = bit_xor(r03D3, body.constant(1u));
               ir_expression *const r04E3 = lshift(r04E2, body.constant(int(31)));
               body.emit(assign(r04E1, add(r04E3, body.constant(2146435072u)), 0x02));

               body.emit(assign(r04E1, body.constant(0u), 0x01));

               body.emit(assign(r03D4, r04E1, 0x03));


            body.instructions = f04C1_parent_instructions;
            body.emit(f04C1);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f04BF->else_instructions;

            /* IF CONDITION */
            ir_expression *const r04E5 = equal(r03DD, body.constant(int(0)));
            ir_if *f04E4 = new(mem_ctx) ir_if(operand(r04E5).val);
            exec_list *const f04E4_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f04E4->then_instructions;

               body.emit(assign(r03D5, add(r03D5, body.constant(int(1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f04E4->else_instructions;

               body.emit(assign(r03DA, bit_or(r03DA, body.constant(1073741824u)), 0x01));


            body.instructions = f04E4_parent_instructions;
            body.emit(f04E4);

            /* END IF */

            ir_variable *const r04E6 = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r04E6, neg(r03D5), 0x01));

            ir_variable *const r04E7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r04E7);
            ir_variable *const r04E8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r04E8);
            ir_variable *const r04E9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r04EA = neg(r04E6);
            body.emit(assign(r04E9, bit_and(r04EA, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r04EC = equal(r04E6, body.constant(int(0)));
            ir_if *f04EB = new(mem_ctx) ir_if(operand(r04EC).val);
            exec_list *const f04EB_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f04EB->then_instructions;

               body.emit(assign(r04E7, r03E3, 0x01));

               body.emit(assign(r04E8, r03DA, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f04EB->else_instructions;

               /* IF CONDITION */
               ir_expression *const r04EE = less(r04E6, body.constant(int(32)));
               ir_if *f04ED = new(mem_ctx) ir_if(operand(r04EE).val);
               exec_list *const f04ED_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f04ED->then_instructions;

                  ir_expression *const r04EF = lshift(r03DA, r04E9);
                  ir_expression *const r04F0 = rshift(r03E3, r04E6);
                  ir_expression *const r04F1 = bit_or(r04EF, r04F0);
                  ir_expression *const r04F2 = lshift(r03E3, r04E9);
                  ir_expression *const r04F3 = nequal(r04F2, body.constant(0u));
                  ir_expression *const r04F4 = expr(ir_unop_b2i, r04F3);
                  ir_expression *const r04F5 = expr(ir_unop_i2u, r04F4);
                  body.emit(assign(r04E7, bit_or(r04F1, r04F5), 0x01));

                  body.emit(assign(r04E8, rshift(r03DA, r04E6), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f04ED->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r04F7 = equal(r04E6, body.constant(int(32)));
                  ir_if *f04F6 = new(mem_ctx) ir_if(operand(r04F7).val);
                  exec_list *const f04F6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f04F6->then_instructions;

                     ir_expression *const r04F8 = nequal(r03E3, body.constant(0u));
                     ir_expression *const r04F9 = expr(ir_unop_b2i, r04F8);
                     ir_expression *const r04FA = expr(ir_unop_i2u, r04F9);
                     body.emit(assign(r04E7, bit_or(r03DA, r04FA), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f04F6->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r04FC = less(r04E6, body.constant(int(64)));
                     ir_if *f04FB = new(mem_ctx) ir_if(operand(r04FC).val);
                     exec_list *const f04FB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f04FB->then_instructions;

                        ir_expression *const r04FD = bit_and(r04E6, body.constant(int(31)));
                        ir_expression *const r04FE = rshift(r03DA, r04FD);
                        ir_expression *const r04FF = lshift(r03DA, r04E9);
                        ir_expression *const r0500 = bit_or(r04FF, r03E3);
                        ir_expression *const r0501 = nequal(r0500, body.constant(0u));
                        ir_expression *const r0502 = expr(ir_unop_b2i, r0501);
                        ir_expression *const r0503 = expr(ir_unop_i2u, r0502);
                        body.emit(assign(r04E7, bit_or(r04FE, r0503), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f04FB->else_instructions;

                        ir_expression *const r0504 = bit_or(r03DA, r03E3);
                        ir_expression *const r0505 = nequal(r0504, body.constant(0u));
                        ir_expression *const r0506 = expr(ir_unop_b2i, r0505);
                        body.emit(assign(r04E7, expr(ir_unop_i2u, r0506), 0x01));


                     body.instructions = f04FB_parent_instructions;
                     body.emit(f04FB);

                     /* END IF */


                  body.instructions = f04F6_parent_instructions;
                  body.emit(f04F6);

                  /* END IF */

                  body.emit(assign(r04E8, body.constant(0u), 0x01));


               body.instructions = f04ED_parent_instructions;
               body.emit(f04ED);

               /* END IF */


            body.instructions = f04EB_parent_instructions;
            body.emit(f04EB);

            /* END IF */

            body.emit(assign(r03DA, r04E8, 0x01));

            body.emit(assign(r03DB, r04E7, 0x01));

            body.emit(assign(r03D8, bit_or(r03D8, body.constant(1073741824u)), 0x01));

            ir_variable *const r0507 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r0508 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r0508, sub(r03D9, r04E7), 0x01));

            ir_expression *const r0509 = sub(r03D8, r04E8);
            ir_expression *const r050A = less(r03D9, r04E7);
            ir_expression *const r050B = expr(ir_unop_b2i, r050A);
            ir_expression *const r050C = expr(ir_unop_i2u, r050B);
            body.emit(assign(r0507, sub(r0509, r050C), 0x01));

            body.emit(assign(r03D3, bit_xor(r03D3, body.constant(1u)), 0x01));

            body.emit(assign(r03DC, add(r03E0, body.constant(int(-1))), 0x01));

            ir_variable *const r050D = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r050D, add(r03DC, body.constant(int(-10))), 0x01));

            ir_variable *const r050E = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r050E, r0507, 0x01));

            ir_variable *const r050F = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r050F, r0508, 0x01));

            ir_variable *const r0510 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
            body.emit(r0510);
            ir_variable *const r0511 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0511);
            /* IF CONDITION */
            ir_expression *const r0513 = equal(r0507, body.constant(0u));
            ir_if *f0512 = new(mem_ctx) ir_if(operand(r0513).val);
            exec_list *const f0512_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0512->then_instructions;

               body.emit(assign(r050E, r0508, 0x01));

               body.emit(assign(r050F, body.constant(0u), 0x01));

               body.emit(assign(r050D, add(r050D, body.constant(int(-32))), 0x01));


            body.instructions = f0512_parent_instructions;
            body.emit(f0512);

            /* END IF */

            ir_variable *const r0514 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r0514, r050E, 0x01));

            ir_variable *const r0515 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r0516 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0516);
            /* IF CONDITION */
            ir_expression *const r0518 = equal(r050E, body.constant(0u));
            ir_if *f0517 = new(mem_ctx) ir_if(operand(r0518).val);
            exec_list *const f0517_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0517->then_instructions;

               body.emit(assign(r0515, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0517->else_instructions;

               body.emit(assign(r0516, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r051A = bit_and(r050E, body.constant(4294901760u));
               ir_expression *const r051B = equal(r051A, body.constant(0u));
               ir_if *f0519 = new(mem_ctx) ir_if(operand(r051B).val);
               exec_list *const f0519_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0519->then_instructions;

                  body.emit(assign(r0516, body.constant(int(16)), 0x01));

                  body.emit(assign(r0514, lshift(r050E, body.constant(int(16))), 0x01));


               body.instructions = f0519_parent_instructions;
               body.emit(f0519);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r051D = bit_and(r0514, body.constant(4278190080u));
               ir_expression *const r051E = equal(r051D, body.constant(0u));
               ir_if *f051C = new(mem_ctx) ir_if(operand(r051E).val);
               exec_list *const f051C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f051C->then_instructions;

                  body.emit(assign(r0516, add(r0516, body.constant(int(8))), 0x01));

                  body.emit(assign(r0514, lshift(r0514, body.constant(int(8))), 0x01));


               body.instructions = f051C_parent_instructions;
               body.emit(f051C);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0520 = bit_and(r0514, body.constant(4026531840u));
               ir_expression *const r0521 = equal(r0520, body.constant(0u));
               ir_if *f051F = new(mem_ctx) ir_if(operand(r0521).val);
               exec_list *const f051F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f051F->then_instructions;

                  body.emit(assign(r0516, add(r0516, body.constant(int(4))), 0x01));

                  body.emit(assign(r0514, lshift(r0514, body.constant(int(4))), 0x01));


               body.instructions = f051F_parent_instructions;
               body.emit(f051F);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0523 = bit_and(r0514, body.constant(3221225472u));
               ir_expression *const r0524 = equal(r0523, body.constant(0u));
               ir_if *f0522 = new(mem_ctx) ir_if(operand(r0524).val);
               exec_list *const f0522_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0522->then_instructions;

                  body.emit(assign(r0516, add(r0516, body.constant(int(2))), 0x01));

                  body.emit(assign(r0514, lshift(r0514, body.constant(int(2))), 0x01));


               body.instructions = f0522_parent_instructions;
               body.emit(f0522);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0526 = bit_and(r0514, body.constant(2147483648u));
               ir_expression *const r0527 = equal(r0526, body.constant(0u));
               ir_if *f0525 = new(mem_ctx) ir_if(operand(r0527).val);
               exec_list *const f0525_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0525->then_instructions;

                  body.emit(assign(r0516, add(r0516, body.constant(int(1))), 0x01));


               body.instructions = f0525_parent_instructions;
               body.emit(f0525);

               /* END IF */

               body.emit(assign(r0515, r0516, 0x01));


            body.instructions = f0517_parent_instructions;
            body.emit(f0517);

            /* END IF */

            body.emit(assign(r0511, add(r0515, body.constant(int(-11))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0529 = lequal(body.constant(int(0)), r0511);
            ir_if *f0528 = new(mem_ctx) ir_if(operand(r0529).val);
            exec_list *const f0528_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0528->then_instructions;

               body.emit(assign(r0510, body.constant(0u), 0x01));

               ir_variable *const r052A = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r052A, lshift(r050F, r0511), 0x01));

               ir_variable *const r052B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r052D = equal(r0511, body.constant(int(0)));
               ir_if *f052C = new(mem_ctx) ir_if(operand(r052D).val);
               exec_list *const f052C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f052C->then_instructions;

                  body.emit(assign(r052B, r050E, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f052C->else_instructions;

                  ir_expression *const r052E = lshift(r050E, r0511);
                  ir_expression *const r052F = neg(r0511);
                  ir_expression *const r0530 = bit_and(r052F, body.constant(int(31)));
                  ir_expression *const r0531 = rshift(r050F, r0530);
                  body.emit(assign(r052B, bit_or(r052E, r0531), 0x01));


               body.instructions = f052C_parent_instructions;
               body.emit(f052C);

               /* END IF */

               body.emit(assign(r050E, r052B, 0x01));

               body.emit(assign(r050F, r052A, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0528->else_instructions;

               ir_variable *const r0532 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r0532, body.constant(0u), 0x01));

               ir_variable *const r0533 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0533, neg(r0511), 0x01));

               ir_variable *const r0534 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r0534);
               ir_variable *const r0535 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0535);
               ir_variable *const r0536 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0536);
               ir_variable *const r0537 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0538 = neg(r0533);
               body.emit(assign(r0537, bit_and(r0538, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r053A = equal(r0533, body.constant(int(0)));
               ir_if *f0539 = new(mem_ctx) ir_if(operand(r053A).val);
               exec_list *const f0539_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0539->then_instructions;

                  body.emit(assign(r0534, r0532, 0x01));

                  body.emit(assign(r0535, r050F, 0x01));

                  body.emit(assign(r0536, r050E, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0539->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r053C = less(r0533, body.constant(int(32)));
                  ir_if *f053B = new(mem_ctx) ir_if(operand(r053C).val);
                  exec_list *const f053B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f053B->then_instructions;

                     body.emit(assign(r0534, lshift(r050F, r0537), 0x01));

                     ir_expression *const r053D = lshift(r050E, r0537);
                     ir_expression *const r053E = rshift(r050F, r0533);
                     body.emit(assign(r0535, bit_or(r053D, r053E), 0x01));

                     body.emit(assign(r0536, rshift(r050E, r0533), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f053B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0540 = equal(r0533, body.constant(int(32)));
                     ir_if *f053F = new(mem_ctx) ir_if(operand(r0540).val);
                     exec_list *const f053F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f053F->then_instructions;

                        body.emit(assign(r0534, r050F, 0x01));

                        body.emit(assign(r0535, r050E, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f053F->else_instructions;

                        body.emit(assign(r0532, bit_or(body.constant(0u), r050F), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0542 = less(r0533, body.constant(int(64)));
                        ir_if *f0541 = new(mem_ctx) ir_if(operand(r0542).val);
                        exec_list *const f0541_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0541->then_instructions;

                           body.emit(assign(r0534, lshift(r050E, r0537), 0x01));

                           ir_expression *const r0543 = bit_and(r0533, body.constant(int(31)));
                           body.emit(assign(r0535, rshift(r050E, r0543), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0541->else_instructions;

                           ir_variable *const r0544 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0546 = equal(r0533, body.constant(int(64)));
                           ir_if *f0545 = new(mem_ctx) ir_if(operand(r0546).val);
                           exec_list *const f0545_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0545->then_instructions;

                              body.emit(assign(r0544, r050E, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0545->else_instructions;

                              ir_expression *const r0547 = nequal(r050E, body.constant(0u));
                              ir_expression *const r0548 = expr(ir_unop_b2i, r0547);
                              body.emit(assign(r0544, expr(ir_unop_i2u, r0548), 0x01));


                           body.instructions = f0545_parent_instructions;
                           body.emit(f0545);

                           /* END IF */

                           body.emit(assign(r0534, r0544, 0x01));

                           body.emit(assign(r0535, body.constant(0u), 0x01));


                        body.instructions = f0541_parent_instructions;
                        body.emit(f0541);

                        /* END IF */


                     body.instructions = f053F_parent_instructions;
                     body.emit(f053F);

                     /* END IF */

                     body.emit(assign(r0536, body.constant(0u), 0x01));


                  body.instructions = f053B_parent_instructions;
                  body.emit(f053B);

                  /* END IF */

                  ir_expression *const r0549 = nequal(r0532, body.constant(0u));
                  ir_expression *const r054A = expr(ir_unop_b2i, r0549);
                  ir_expression *const r054B = expr(ir_unop_i2u, r054A);
                  body.emit(assign(r0534, bit_or(r0534, r054B), 0x01));


               body.instructions = f0539_parent_instructions;
               body.emit(f0539);

               /* END IF */

               body.emit(assign(r050E, r0536, 0x01));

               body.emit(assign(r050F, r0535, 0x01));

               body.emit(assign(r0510, r0534, 0x01));


            body.instructions = f0528_parent_instructions;
            body.emit(f0528);

            /* END IF */

            body.emit(assign(r050D, sub(r050D, r0511), 0x01));

            ir_variable *const r054C = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r054C, r050D, 0x01));

            ir_variable *const r054D = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r054D, r050E, 0x01));

            ir_variable *const r054E = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r054E, r050F, 0x01));

            ir_variable *const r054F = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r054F, r0510, 0x01));

            ir_variable *const r0550 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r0550, body.constant(true), 0x01));

            ir_variable *const r0551 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0552 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r0552);
            ir_expression *const r0553 = expr(ir_unop_u2i, r0510);
            body.emit(assign(r0552, less(r0553, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0555 = lequal(body.constant(int(2045)), r050D);
            ir_if *f0554 = new(mem_ctx) ir_if(operand(r0555).val);
            exec_list *const f0554_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0554->then_instructions;

               ir_variable *const r0556 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0558 = less(body.constant(int(2045)), r050D);
               ir_if *f0557 = new(mem_ctx) ir_if(operand(r0558).val);
               exec_list *const f0557_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0557->then_instructions;

                  body.emit(assign(r0556, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0557->else_instructions;

                  ir_variable *const r0559 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r055B = equal(r050D, body.constant(int(2045)));
                  ir_if *f055A = new(mem_ctx) ir_if(operand(r055B).val);
                  exec_list *const f055A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f055A->then_instructions;

                     ir_expression *const r055C = equal(body.constant(2097151u), r050E);
                     ir_expression *const r055D = equal(body.constant(4294967295u), r050F);
                     body.emit(assign(r0559, logic_and(r055C, r055D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f055A->else_instructions;

                     body.emit(assign(r0559, body.constant(false), 0x01));


                  body.instructions = f055A_parent_instructions;
                  body.emit(f055A);

                  /* END IF */

                  body.emit(assign(r0556, logic_and(r0559, r0552), 0x01));


               body.instructions = f0557_parent_instructions;
               body.emit(f0557);

               /* END IF */

               /* IF CONDITION */
               ir_if *f055E = new(mem_ctx) ir_if(operand(r0556).val);
               exec_list *const f055E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f055E->then_instructions;

                  ir_variable *const r055F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r055F);
                  ir_expression *const r0560 = lshift(r03D3, body.constant(int(31)));
                  body.emit(assign(r055F, add(r0560, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r055F, body.constant(0u), 0x01));

                  body.emit(assign(r0551, r055F, 0x03));

                  body.emit(assign(r0550, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f055E->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0562 = less(r050D, body.constant(int(0)));
                  ir_if *f0561 = new(mem_ctx) ir_if(operand(r0562).val);
                  exec_list *const f0561_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0561->then_instructions;

                     ir_variable *const r0563 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0563, r0510, 0x01));

                     ir_variable *const r0564 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0564, neg(r050D), 0x01));

                     ir_variable *const r0565 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0565);
                     ir_variable *const r0566 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0566);
                     ir_variable *const r0567 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0567);
                     ir_variable *const r0568 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0569 = neg(r0564);
                     body.emit(assign(r0568, bit_and(r0569, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r056B = equal(r0564, body.constant(int(0)));
                     ir_if *f056A = new(mem_ctx) ir_if(operand(r056B).val);
                     exec_list *const f056A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f056A->then_instructions;

                        body.emit(assign(r0565, r0510, 0x01));

                        body.emit(assign(r0566, r050F, 0x01));

                        body.emit(assign(r0567, r050E, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f056A->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r056D = less(r0564, body.constant(int(32)));
                        ir_if *f056C = new(mem_ctx) ir_if(operand(r056D).val);
                        exec_list *const f056C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f056C->then_instructions;

                           body.emit(assign(r0565, lshift(r050F, r0568), 0x01));

                           ir_expression *const r056E = lshift(r050E, r0568);
                           ir_expression *const r056F = rshift(r050F, r0564);
                           body.emit(assign(r0566, bit_or(r056E, r056F), 0x01));

                           body.emit(assign(r0567, rshift(r050E, r0564), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f056C->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0571 = equal(r0564, body.constant(int(32)));
                           ir_if *f0570 = new(mem_ctx) ir_if(operand(r0571).val);
                           exec_list *const f0570_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0570->then_instructions;

                              body.emit(assign(r0565, r050F, 0x01));

                              body.emit(assign(r0566, r050E, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0570->else_instructions;

                              body.emit(assign(r0563, bit_or(r0510, r050F), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0573 = less(r0564, body.constant(int(64)));
                              ir_if *f0572 = new(mem_ctx) ir_if(operand(r0573).val);
                              exec_list *const f0572_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0572->then_instructions;

                                 body.emit(assign(r0565, lshift(r050E, r0568), 0x01));

                                 ir_expression *const r0574 = bit_and(r0564, body.constant(int(31)));
                                 body.emit(assign(r0566, rshift(r050E, r0574), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0572->else_instructions;

                                 ir_variable *const r0575 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0577 = equal(r0564, body.constant(int(64)));
                                 ir_if *f0576 = new(mem_ctx) ir_if(operand(r0577).val);
                                 exec_list *const f0576_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0576->then_instructions;

                                    body.emit(assign(r0575, r050E, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0576->else_instructions;

                                    ir_expression *const r0578 = nequal(r050E, body.constant(0u));
                                    ir_expression *const r0579 = expr(ir_unop_b2i, r0578);
                                    body.emit(assign(r0575, expr(ir_unop_i2u, r0579), 0x01));


                                 body.instructions = f0576_parent_instructions;
                                 body.emit(f0576);

                                 /* END IF */

                                 body.emit(assign(r0565, r0575, 0x01));

                                 body.emit(assign(r0566, body.constant(0u), 0x01));


                              body.instructions = f0572_parent_instructions;
                              body.emit(f0572);

                              /* END IF */


                           body.instructions = f0570_parent_instructions;
                           body.emit(f0570);

                           /* END IF */

                           body.emit(assign(r0567, body.constant(0u), 0x01));


                        body.instructions = f056C_parent_instructions;
                        body.emit(f056C);

                        /* END IF */

                        ir_expression *const r057A = nequal(r0563, body.constant(0u));
                        ir_expression *const r057B = expr(ir_unop_b2i, r057A);
                        ir_expression *const r057C = expr(ir_unop_i2u, r057B);
                        body.emit(assign(r0565, bit_or(r0565, r057C), 0x01));


                     body.instructions = f056A_parent_instructions;
                     body.emit(f056A);

                     /* END IF */

                     body.emit(assign(r054D, r0567, 0x01));

                     body.emit(assign(r054E, r0566, 0x01));

                     body.emit(assign(r054F, r0565, 0x01));

                     body.emit(assign(r054C, body.constant(int(0)), 0x01));

                     body.emit(assign(r0552, less(r0565, body.constant(0u)), 0x01));


                  body.instructions = f0561_parent_instructions;
                  body.emit(f0561);

                  /* END IF */


               body.instructions = f055E_parent_instructions;
               body.emit(f055E);

               /* END IF */


            body.instructions = f0554_parent_instructions;
            body.emit(f0554);

            /* END IF */

            /* IF CONDITION */
            ir_if *f057D = new(mem_ctx) ir_if(operand(r0550).val);
            exec_list *const f057D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f057D->then_instructions;

               /* IF CONDITION */
               ir_if *f057E = new(mem_ctx) ir_if(operand(r0552).val);
               exec_list *const f057E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f057E->then_instructions;

                  ir_variable *const r057F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r057F, add(r054E, body.constant(1u)), 0x01));

                  ir_expression *const r0580 = less(r057F, r054E);
                  ir_expression *const r0581 = expr(ir_unop_b2i, r0580);
                  ir_expression *const r0582 = expr(ir_unop_i2u, r0581);
                  body.emit(assign(r054D, add(r054D, r0582), 0x01));

                  ir_expression *const r0583 = equal(r054F, body.constant(0u));
                  ir_expression *const r0584 = expr(ir_unop_b2i, r0583);
                  ir_expression *const r0585 = expr(ir_unop_i2u, r0584);
                  ir_expression *const r0586 = add(r054F, r0585);
                  ir_expression *const r0587 = bit_and(r0586, body.constant(1u));
                  ir_expression *const r0588 = expr(ir_unop_bit_not, r0587);
                  body.emit(assign(r054E, bit_and(r057F, r0588), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f057E->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r058A = bit_or(r054D, r054E);
                  ir_expression *const r058B = equal(r058A, body.constant(0u));
                  ir_if *f0589 = new(mem_ctx) ir_if(operand(r058B).val);
                  exec_list *const f0589_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0589->then_instructions;

                     body.emit(assign(r054C, body.constant(int(0)), 0x01));


                  body.instructions = f0589_parent_instructions;
                  body.emit(f0589);

                  /* END IF */


               body.instructions = f057E_parent_instructions;
               body.emit(f057E);

               /* END IF */

               ir_variable *const r058C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r058C);
               ir_expression *const r058D = lshift(r03D3, body.constant(int(31)));
               ir_expression *const r058E = expr(ir_unop_i2u, r054C);
               ir_expression *const r058F = lshift(r058E, body.constant(int(20)));
               ir_expression *const r0590 = add(r058D, r058F);
               body.emit(assign(r058C, add(r0590, r054D), 0x02));

               body.emit(assign(r058C, r054E, 0x01));

               body.emit(assign(r0551, r058C, 0x03));

               body.emit(assign(r0550, body.constant(false), 0x01));


            body.instructions = f057D_parent_instructions;
            body.emit(f057D);

            /* END IF */

            body.emit(assign(r03D4, r0551, 0x03));


         body.instructions = f04BF_parent_instructions;
         body.emit(f04BF);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f04BD->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0592 = equal(r03DD, body.constant(int(2047)));
         ir_if *f0591 = new(mem_ctx) ir_if(operand(r0592).val);
         exec_list *const f0591_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0591->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0594 = bit_or(r03DA, r03DB);
            ir_expression *const r0595 = bit_or(r03D8, r03D9);
            ir_expression *const r0596 = bit_or(r0594, r0595);
            ir_expression *const r0597 = nequal(r0596, body.constant(0u));
            ir_if *f0593 = new(mem_ctx) ir_if(operand(r0597).val);
            exec_list *const f0593_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0593->then_instructions;

               ir_variable *const r0598 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r0598, swizzle_x(r03D1), 0x01));

               ir_variable *const r0599 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r0599, swizzle_x(r03D2), 0x01));

               ir_variable *const r059A = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r059B = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r059C = rshift(swizzle_y(r03D1), body.constant(int(19)));
               ir_expression *const r059D = bit_and(r059C, body.constant(4095u));
               ir_expression *const r059E = equal(r059D, body.constant(4094u));
               ir_expression *const r059F = nequal(swizzle_x(r03D1), body.constant(0u));
               ir_expression *const r05A0 = bit_and(swizzle_y(r03D1), body.constant(524287u));
               ir_expression *const r05A1 = nequal(r05A0, body.constant(0u));
               ir_expression *const r05A2 = logic_or(r059F, r05A1);
               body.emit(assign(r059B, logic_and(r059E, r05A2), 0x01));

               ir_variable *const r05A3 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r05A4 = lshift(swizzle_y(r03D2), body.constant(int(1)));
               ir_expression *const r05A5 = lequal(body.constant(4292870144u), r05A4);
               ir_expression *const r05A6 = nequal(swizzle_x(r03D2), body.constant(0u));
               ir_expression *const r05A7 = bit_and(swizzle_y(r03D2), body.constant(1048575u));
               ir_expression *const r05A8 = nequal(r05A7, body.constant(0u));
               ir_expression *const r05A9 = logic_or(r05A6, r05A8);
               body.emit(assign(r05A3, logic_and(r05A5, r05A9), 0x01));

               body.emit(assign(r0598, bit_or(swizzle_y(r03D1), body.constant(524288u)), 0x02));

               body.emit(assign(r0599, bit_or(swizzle_y(r03D2), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r05AB = lshift(swizzle_y(r03D1), body.constant(int(1)));
               ir_expression *const r05AC = lequal(body.constant(4292870144u), r05AB);
               ir_expression *const r05AD = nequal(swizzle_x(r03D1), body.constant(0u));
               ir_expression *const r05AE = bit_and(swizzle_y(r03D1), body.constant(1048575u));
               ir_expression *const r05AF = nequal(r05AE, body.constant(0u));
               ir_expression *const r05B0 = logic_or(r05AD, r05AF);
               ir_expression *const r05B1 = logic_and(r05AC, r05B0);
               ir_if *f05AA = new(mem_ctx) ir_if(operand(r05B1).val);
               exec_list *const f05AA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f05AA->then_instructions;

                  ir_variable *const r05B2 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r05B4 = logic_and(r059B, r05A3);
                  ir_if *f05B3 = new(mem_ctx) ir_if(operand(r05B4).val);
                  exec_list *const f05B3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05B3->then_instructions;

                     body.emit(assign(r05B2, r0599, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f05B3->else_instructions;

                     body.emit(assign(r05B2, r0598, 0x03));


                  body.instructions = f05B3_parent_instructions;
                  body.emit(f05B3);

                  /* END IF */

                  body.emit(assign(r059A, r05B2, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f05AA->else_instructions;

                  body.emit(assign(r059A, r0599, 0x03));


               body.instructions = f05AA_parent_instructions;
               body.emit(f05AA);

               /* END IF */

               body.emit(assign(r03D4, r059A, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0593->else_instructions;

               ir_constant_data r05B5_data;
               memset(&r05B5_data, 0, sizeof(ir_constant_data));
               r05B5_data.u[0] = 4294967295;
               r05B5_data.u[1] = 4294967295;
               ir_constant *const r05B5 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r05B5_data);
               body.emit(assign(r03D4, r05B5, 0x03));


            body.instructions = f0593_parent_instructions;
            body.emit(f0593);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0591->else_instructions;

            /* IF CONDITION */
            ir_expression *const r05B7 = equal(r03DD, body.constant(int(0)));
            ir_if *f05B6 = new(mem_ctx) ir_if(operand(r05B7).val);
            exec_list *const f05B6_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f05B6->then_instructions;

               body.emit(assign(r03D7, body.constant(int(1)), 0x01));

               body.emit(assign(r03D6, body.constant(int(1)), 0x01));


            body.instructions = f05B6_parent_instructions;
            body.emit(f05B6);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r05B9 = less(r03D8, r03DA);
            ir_if *f05B8 = new(mem_ctx) ir_if(operand(r05B9).val);
            exec_list *const f05B8_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f05B8->then_instructions;

               ir_variable *const r05BA = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r05BB = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r05BB, sub(r03DB, r03D9), 0x01));

               ir_expression *const r05BC = sub(r03DA, r03D8);
               ir_expression *const r05BD = less(r03DB, r03D9);
               ir_expression *const r05BE = expr(ir_unop_b2i, r05BD);
               ir_expression *const r05BF = expr(ir_unop_i2u, r05BE);
               body.emit(assign(r05BA, sub(r05BC, r05BF), 0x01));

               body.emit(assign(r03DC, add(r03D7, body.constant(int(-1))), 0x01));

               ir_variable *const r05C0 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r05C0, add(r03DC, body.constant(int(-10))), 0x01));

               ir_variable *const r05C1 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r05C1, r05BA, 0x01));

               ir_variable *const r05C2 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r05C2, r05BB, 0x01));

               ir_variable *const r05C3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r05C3);
               ir_variable *const r05C4 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r05C4);
               /* IF CONDITION */
               ir_expression *const r05C6 = equal(r05BA, body.constant(0u));
               ir_if *f05C5 = new(mem_ctx) ir_if(operand(r05C6).val);
               exec_list *const f05C5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f05C5->then_instructions;

                  body.emit(assign(r05C1, r05BB, 0x01));

                  body.emit(assign(r05C2, body.constant(0u), 0x01));

                  body.emit(assign(r05C0, add(r05C0, body.constant(int(-32))), 0x01));


               body.instructions = f05C5_parent_instructions;
               body.emit(f05C5);

               /* END IF */

               ir_variable *const r05C7 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r05C7, r05C1, 0x01));

               ir_variable *const r05C8 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r05C9 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r05C9);
               /* IF CONDITION */
               ir_expression *const r05CB = equal(r05C1, body.constant(0u));
               ir_if *f05CA = new(mem_ctx) ir_if(operand(r05CB).val);
               exec_list *const f05CA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f05CA->then_instructions;

                  body.emit(assign(r05C8, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f05CA->else_instructions;

                  body.emit(assign(r05C9, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r05CD = bit_and(r05C1, body.constant(4294901760u));
                  ir_expression *const r05CE = equal(r05CD, body.constant(0u));
                  ir_if *f05CC = new(mem_ctx) ir_if(operand(r05CE).val);
                  exec_list *const f05CC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05CC->then_instructions;

                     body.emit(assign(r05C9, body.constant(int(16)), 0x01));

                     body.emit(assign(r05C7, lshift(r05C1, body.constant(int(16))), 0x01));


                  body.instructions = f05CC_parent_instructions;
                  body.emit(f05CC);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r05D0 = bit_and(r05C7, body.constant(4278190080u));
                  ir_expression *const r05D1 = equal(r05D0, body.constant(0u));
                  ir_if *f05CF = new(mem_ctx) ir_if(operand(r05D1).val);
                  exec_list *const f05CF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05CF->then_instructions;

                     body.emit(assign(r05C9, add(r05C9, body.constant(int(8))), 0x01));

                     body.emit(assign(r05C7, lshift(r05C7, body.constant(int(8))), 0x01));


                  body.instructions = f05CF_parent_instructions;
                  body.emit(f05CF);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r05D3 = bit_and(r05C7, body.constant(4026531840u));
                  ir_expression *const r05D4 = equal(r05D3, body.constant(0u));
                  ir_if *f05D2 = new(mem_ctx) ir_if(operand(r05D4).val);
                  exec_list *const f05D2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05D2->then_instructions;

                     body.emit(assign(r05C9, add(r05C9, body.constant(int(4))), 0x01));

                     body.emit(assign(r05C7, lshift(r05C7, body.constant(int(4))), 0x01));


                  body.instructions = f05D2_parent_instructions;
                  body.emit(f05D2);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r05D6 = bit_and(r05C7, body.constant(3221225472u));
                  ir_expression *const r05D7 = equal(r05D6, body.constant(0u));
                  ir_if *f05D5 = new(mem_ctx) ir_if(operand(r05D7).val);
                  exec_list *const f05D5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05D5->then_instructions;

                     body.emit(assign(r05C9, add(r05C9, body.constant(int(2))), 0x01));

                     body.emit(assign(r05C7, lshift(r05C7, body.constant(int(2))), 0x01));


                  body.instructions = f05D5_parent_instructions;
                  body.emit(f05D5);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r05D9 = bit_and(r05C7, body.constant(2147483648u));
                  ir_expression *const r05DA = equal(r05D9, body.constant(0u));
                  ir_if *f05D8 = new(mem_ctx) ir_if(operand(r05DA).val);
                  exec_list *const f05D8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05D8->then_instructions;

                     body.emit(assign(r05C9, add(r05C9, body.constant(int(1))), 0x01));


                  body.instructions = f05D8_parent_instructions;
                  body.emit(f05D8);

                  /* END IF */

                  body.emit(assign(r05C8, r05C9, 0x01));


               body.instructions = f05CA_parent_instructions;
               body.emit(f05CA);

               /* END IF */

               body.emit(assign(r05C4, add(r05C8, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r05DC = lequal(body.constant(int(0)), r05C4);
               ir_if *f05DB = new(mem_ctx) ir_if(operand(r05DC).val);
               exec_list *const f05DB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f05DB->then_instructions;

                  body.emit(assign(r05C3, body.constant(0u), 0x01));

                  ir_variable *const r05DD = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r05DD, lshift(r05C2, r05C4), 0x01));

                  ir_variable *const r05DE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r05E0 = equal(r05C4, body.constant(int(0)));
                  ir_if *f05DF = new(mem_ctx) ir_if(operand(r05E0).val);
                  exec_list *const f05DF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05DF->then_instructions;

                     body.emit(assign(r05DE, r05C1, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f05DF->else_instructions;

                     ir_expression *const r05E1 = lshift(r05C1, r05C4);
                     ir_expression *const r05E2 = neg(r05C4);
                     ir_expression *const r05E3 = bit_and(r05E2, body.constant(int(31)));
                     ir_expression *const r05E4 = rshift(r05C2, r05E3);
                     body.emit(assign(r05DE, bit_or(r05E1, r05E4), 0x01));


                  body.instructions = f05DF_parent_instructions;
                  body.emit(f05DF);

                  /* END IF */

                  body.emit(assign(r05C1, r05DE, 0x01));

                  body.emit(assign(r05C2, r05DD, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f05DB->else_instructions;

                  ir_variable *const r05E5 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r05E5, body.constant(0u), 0x01));

                  ir_variable *const r05E6 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r05E6, neg(r05C4), 0x01));

                  ir_variable *const r05E7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r05E7);
                  ir_variable *const r05E8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r05E8);
                  ir_variable *const r05E9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r05E9);
                  ir_variable *const r05EA = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r05EB = neg(r05E6);
                  body.emit(assign(r05EA, bit_and(r05EB, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r05ED = equal(r05E6, body.constant(int(0)));
                  ir_if *f05EC = new(mem_ctx) ir_if(operand(r05ED).val);
                  exec_list *const f05EC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05EC->then_instructions;

                     body.emit(assign(r05E7, r05E5, 0x01));

                     body.emit(assign(r05E8, r05C2, 0x01));

                     body.emit(assign(r05E9, r05C1, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f05EC->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r05EF = less(r05E6, body.constant(int(32)));
                     ir_if *f05EE = new(mem_ctx) ir_if(operand(r05EF).val);
                     exec_list *const f05EE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f05EE->then_instructions;

                        body.emit(assign(r05E7, lshift(r05C2, r05EA), 0x01));

                        ir_expression *const r05F0 = lshift(r05C1, r05EA);
                        ir_expression *const r05F1 = rshift(r05C2, r05E6);
                        body.emit(assign(r05E8, bit_or(r05F0, r05F1), 0x01));

                        body.emit(assign(r05E9, rshift(r05C1, r05E6), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f05EE->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r05F3 = equal(r05E6, body.constant(int(32)));
                        ir_if *f05F2 = new(mem_ctx) ir_if(operand(r05F3).val);
                        exec_list *const f05F2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f05F2->then_instructions;

                           body.emit(assign(r05E7, r05C2, 0x01));

                           body.emit(assign(r05E8, r05C1, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f05F2->else_instructions;

                           body.emit(assign(r05E5, bit_or(body.constant(0u), r05C2), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r05F5 = less(r05E6, body.constant(int(64)));
                           ir_if *f05F4 = new(mem_ctx) ir_if(operand(r05F5).val);
                           exec_list *const f05F4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f05F4->then_instructions;

                              body.emit(assign(r05E7, lshift(r05C1, r05EA), 0x01));

                              ir_expression *const r05F6 = bit_and(r05E6, body.constant(int(31)));
                              body.emit(assign(r05E8, rshift(r05C1, r05F6), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f05F4->else_instructions;

                              ir_variable *const r05F7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r05F9 = equal(r05E6, body.constant(int(64)));
                              ir_if *f05F8 = new(mem_ctx) ir_if(operand(r05F9).val);
                              exec_list *const f05F8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f05F8->then_instructions;

                                 body.emit(assign(r05F7, r05C1, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f05F8->else_instructions;

                                 ir_expression *const r05FA = nequal(r05C1, body.constant(0u));
                                 ir_expression *const r05FB = expr(ir_unop_b2i, r05FA);
                                 body.emit(assign(r05F7, expr(ir_unop_i2u, r05FB), 0x01));


                              body.instructions = f05F8_parent_instructions;
                              body.emit(f05F8);

                              /* END IF */

                              body.emit(assign(r05E7, r05F7, 0x01));

                              body.emit(assign(r05E8, body.constant(0u), 0x01));


                           body.instructions = f05F4_parent_instructions;
                           body.emit(f05F4);

                           /* END IF */


                        body.instructions = f05F2_parent_instructions;
                        body.emit(f05F2);

                        /* END IF */

                        body.emit(assign(r05E9, body.constant(0u), 0x01));


                     body.instructions = f05EE_parent_instructions;
                     body.emit(f05EE);

                     /* END IF */

                     ir_expression *const r05FC = nequal(r05E5, body.constant(0u));
                     ir_expression *const r05FD = expr(ir_unop_b2i, r05FC);
                     ir_expression *const r05FE = expr(ir_unop_i2u, r05FD);
                     body.emit(assign(r05E7, bit_or(r05E7, r05FE), 0x01));


                  body.instructions = f05EC_parent_instructions;
                  body.emit(f05EC);

                  /* END IF */

                  body.emit(assign(r05C1, r05E9, 0x01));

                  body.emit(assign(r05C2, r05E8, 0x01));

                  body.emit(assign(r05C3, r05E7, 0x01));


               body.instructions = f05DB_parent_instructions;
               body.emit(f05DB);

               /* END IF */

               body.emit(assign(r05C0, sub(r05C0, r05C4), 0x01));

               ir_variable *const r05FF = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r05FF, r05C0, 0x01));

               ir_variable *const r0600 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0600, r05C1, 0x01));

               ir_variable *const r0601 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0601, r05C2, 0x01));

               ir_variable *const r0602 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r0602, r05C3, 0x01));

               ir_variable *const r0603 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r0603, body.constant(true), 0x01));

               ir_variable *const r0604 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0605 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r0605);
               ir_expression *const r0606 = expr(ir_unop_u2i, r05C3);
               body.emit(assign(r0605, less(r0606, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0608 = lequal(body.constant(int(2045)), r05C0);
               ir_if *f0607 = new(mem_ctx) ir_if(operand(r0608).val);
               exec_list *const f0607_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0607->then_instructions;

                  ir_variable *const r0609 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r060B = less(body.constant(int(2045)), r05C0);
                  ir_if *f060A = new(mem_ctx) ir_if(operand(r060B).val);
                  exec_list *const f060A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f060A->then_instructions;

                     body.emit(assign(r0609, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f060A->else_instructions;

                     ir_variable *const r060C = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r060E = equal(r05C0, body.constant(int(2045)));
                     ir_if *f060D = new(mem_ctx) ir_if(operand(r060E).val);
                     exec_list *const f060D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f060D->then_instructions;

                        ir_expression *const r060F = equal(body.constant(2097151u), r05C1);
                        ir_expression *const r0610 = equal(body.constant(4294967295u), r05C2);
                        body.emit(assign(r060C, logic_and(r060F, r0610), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f060D->else_instructions;

                        body.emit(assign(r060C, body.constant(false), 0x01));


                     body.instructions = f060D_parent_instructions;
                     body.emit(f060D);

                     /* END IF */

                     body.emit(assign(r0609, logic_and(r060C, r0605), 0x01));


                  body.instructions = f060A_parent_instructions;
                  body.emit(f060A);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0611 = new(mem_ctx) ir_if(operand(r0609).val);
                  exec_list *const f0611_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0611->then_instructions;

                     ir_variable *const r0612 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0612);
                     ir_expression *const r0613 = lshift(r03D3, body.constant(int(31)));
                     body.emit(assign(r0612, add(r0613, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r0612, body.constant(0u), 0x01));

                     body.emit(assign(r0604, r0612, 0x03));

                     body.emit(assign(r0603, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0611->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0615 = less(r05C0, body.constant(int(0)));
                     ir_if *f0614 = new(mem_ctx) ir_if(operand(r0615).val);
                     exec_list *const f0614_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0614->then_instructions;

                        ir_variable *const r0616 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0616, r05C3, 0x01));

                        ir_variable *const r0617 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0617, neg(r05C0), 0x01));

                        ir_variable *const r0618 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0618);
                        ir_variable *const r0619 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0619);
                        ir_variable *const r061A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r061A);
                        ir_variable *const r061B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r061C = neg(r0617);
                        body.emit(assign(r061B, bit_and(r061C, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r061E = equal(r0617, body.constant(int(0)));
                        ir_if *f061D = new(mem_ctx) ir_if(operand(r061E).val);
                        exec_list *const f061D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f061D->then_instructions;

                           body.emit(assign(r0618, r05C3, 0x01));

                           body.emit(assign(r0619, r05C2, 0x01));

                           body.emit(assign(r061A, r05C1, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f061D->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0620 = less(r0617, body.constant(int(32)));
                           ir_if *f061F = new(mem_ctx) ir_if(operand(r0620).val);
                           exec_list *const f061F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f061F->then_instructions;

                              body.emit(assign(r0618, lshift(r05C2, r061B), 0x01));

                              ir_expression *const r0621 = lshift(r05C1, r061B);
                              ir_expression *const r0622 = rshift(r05C2, r0617);
                              body.emit(assign(r0619, bit_or(r0621, r0622), 0x01));

                              body.emit(assign(r061A, rshift(r05C1, r0617), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f061F->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0624 = equal(r0617, body.constant(int(32)));
                              ir_if *f0623 = new(mem_ctx) ir_if(operand(r0624).val);
                              exec_list *const f0623_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0623->then_instructions;

                                 body.emit(assign(r0618, r05C2, 0x01));

                                 body.emit(assign(r0619, r05C1, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0623->else_instructions;

                                 body.emit(assign(r0616, bit_or(r05C3, r05C2), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0626 = less(r0617, body.constant(int(64)));
                                 ir_if *f0625 = new(mem_ctx) ir_if(operand(r0626).val);
                                 exec_list *const f0625_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0625->then_instructions;

                                    body.emit(assign(r0618, lshift(r05C1, r061B), 0x01));

                                    ir_expression *const r0627 = bit_and(r0617, body.constant(int(31)));
                                    body.emit(assign(r0619, rshift(r05C1, r0627), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0625->else_instructions;

                                    ir_variable *const r0628 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r062A = equal(r0617, body.constant(int(64)));
                                    ir_if *f0629 = new(mem_ctx) ir_if(operand(r062A).val);
                                    exec_list *const f0629_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0629->then_instructions;

                                       body.emit(assign(r0628, r05C1, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0629->else_instructions;

                                       ir_expression *const r062B = nequal(r05C1, body.constant(0u));
                                       ir_expression *const r062C = expr(ir_unop_b2i, r062B);
                                       body.emit(assign(r0628, expr(ir_unop_i2u, r062C), 0x01));


                                    body.instructions = f0629_parent_instructions;
                                    body.emit(f0629);

                                    /* END IF */

                                    body.emit(assign(r0618, r0628, 0x01));

                                    body.emit(assign(r0619, body.constant(0u), 0x01));


                                 body.instructions = f0625_parent_instructions;
                                 body.emit(f0625);

                                 /* END IF */


                              body.instructions = f0623_parent_instructions;
                              body.emit(f0623);

                              /* END IF */

                              body.emit(assign(r061A, body.constant(0u), 0x01));


                           body.instructions = f061F_parent_instructions;
                           body.emit(f061F);

                           /* END IF */

                           ir_expression *const r062D = nequal(r0616, body.constant(0u));
                           ir_expression *const r062E = expr(ir_unop_b2i, r062D);
                           ir_expression *const r062F = expr(ir_unop_i2u, r062E);
                           body.emit(assign(r0618, bit_or(r0618, r062F), 0x01));


                        body.instructions = f061D_parent_instructions;
                        body.emit(f061D);

                        /* END IF */

                        body.emit(assign(r0600, r061A, 0x01));

                        body.emit(assign(r0601, r0619, 0x01));

                        body.emit(assign(r0602, r0618, 0x01));

                        body.emit(assign(r05FF, body.constant(int(0)), 0x01));

                        body.emit(assign(r0605, less(r0618, body.constant(0u)), 0x01));


                     body.instructions = f0614_parent_instructions;
                     body.emit(f0614);

                     /* END IF */


                  body.instructions = f0611_parent_instructions;
                  body.emit(f0611);

                  /* END IF */


               body.instructions = f0607_parent_instructions;
               body.emit(f0607);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0630 = new(mem_ctx) ir_if(operand(r0603).val);
               exec_list *const f0630_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0630->then_instructions;

                  /* IF CONDITION */
                  ir_if *f0631 = new(mem_ctx) ir_if(operand(r0605).val);
                  exec_list *const f0631_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0631->then_instructions;

                     ir_variable *const r0632 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r0632, add(r0601, body.constant(1u)), 0x01));

                     ir_expression *const r0633 = less(r0632, r0601);
                     ir_expression *const r0634 = expr(ir_unop_b2i, r0633);
                     ir_expression *const r0635 = expr(ir_unop_i2u, r0634);
                     body.emit(assign(r0600, add(r0600, r0635), 0x01));

                     ir_expression *const r0636 = equal(r0602, body.constant(0u));
                     ir_expression *const r0637 = expr(ir_unop_b2i, r0636);
                     ir_expression *const r0638 = expr(ir_unop_i2u, r0637);
                     ir_expression *const r0639 = add(r0602, r0638);
                     ir_expression *const r063A = bit_and(r0639, body.constant(1u));
                     ir_expression *const r063B = expr(ir_unop_bit_not, r063A);
                     body.emit(assign(r0601, bit_and(r0632, r063B), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0631->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r063D = bit_or(r0600, r0601);
                     ir_expression *const r063E = equal(r063D, body.constant(0u));
                     ir_if *f063C = new(mem_ctx) ir_if(operand(r063E).val);
                     exec_list *const f063C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f063C->then_instructions;

                        body.emit(assign(r05FF, body.constant(int(0)), 0x01));


                     body.instructions = f063C_parent_instructions;
                     body.emit(f063C);

                     /* END IF */


                  body.instructions = f0631_parent_instructions;
                  body.emit(f0631);

                  /* END IF */

                  ir_variable *const r063F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r063F);
                  ir_expression *const r0640 = lshift(r03D3, body.constant(int(31)));
                  ir_expression *const r0641 = expr(ir_unop_i2u, r05FF);
                  ir_expression *const r0642 = lshift(r0641, body.constant(int(20)));
                  ir_expression *const r0643 = add(r0640, r0642);
                  body.emit(assign(r063F, add(r0643, r0600), 0x02));

                  body.emit(assign(r063F, r0601, 0x01));

                  body.emit(assign(r0604, r063F, 0x03));

                  body.emit(assign(r0603, body.constant(false), 0x01));


               body.instructions = f0630_parent_instructions;
               body.emit(f0630);

               /* END IF */

               body.emit(assign(r03D4, r0604, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f05B8->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0645 = less(r03DA, r03D8);
               ir_if *f0644 = new(mem_ctx) ir_if(operand(r0645).val);
               exec_list *const f0644_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0644->then_instructions;

                  ir_variable *const r0646 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r0647 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0647, sub(r03D9, r03DB), 0x01));

                  ir_expression *const r0648 = sub(r03D8, r03DA);
                  ir_expression *const r0649 = less(r03D9, r03DB);
                  ir_expression *const r064A = expr(ir_unop_b2i, r0649);
                  ir_expression *const r064B = expr(ir_unop_i2u, r064A);
                  body.emit(assign(r0646, sub(r0648, r064B), 0x01));

                  body.emit(assign(r03D3, bit_xor(r03D3, body.constant(1u)), 0x01));

                  body.emit(assign(r03DC, add(r03D6, body.constant(int(-1))), 0x01));

                  ir_variable *const r064C = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r064C, add(r03DC, body.constant(int(-10))), 0x01));

                  ir_variable *const r064D = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r064D, r0646, 0x01));

                  ir_variable *const r064E = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r064E, r0647, 0x01));

                  ir_variable *const r064F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r064F);
                  ir_variable *const r0650 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0650);
                  /* IF CONDITION */
                  ir_expression *const r0652 = equal(r0646, body.constant(0u));
                  ir_if *f0651 = new(mem_ctx) ir_if(operand(r0652).val);
                  exec_list *const f0651_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0651->then_instructions;

                     body.emit(assign(r064D, r0647, 0x01));

                     body.emit(assign(r064E, body.constant(0u), 0x01));

                     body.emit(assign(r064C, add(r064C, body.constant(int(-32))), 0x01));


                  body.instructions = f0651_parent_instructions;
                  body.emit(f0651);

                  /* END IF */

                  ir_variable *const r0653 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r0653, r064D, 0x01));

                  ir_variable *const r0654 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r0655 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0655);
                  /* IF CONDITION */
                  ir_expression *const r0657 = equal(r064D, body.constant(0u));
                  ir_if *f0656 = new(mem_ctx) ir_if(operand(r0657).val);
                  exec_list *const f0656_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0656->then_instructions;

                     body.emit(assign(r0654, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0656->else_instructions;

                     body.emit(assign(r0655, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0659 = bit_and(r064D, body.constant(4294901760u));
                     ir_expression *const r065A = equal(r0659, body.constant(0u));
                     ir_if *f0658 = new(mem_ctx) ir_if(operand(r065A).val);
                     exec_list *const f0658_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0658->then_instructions;

                        body.emit(assign(r0655, body.constant(int(16)), 0x01));

                        body.emit(assign(r0653, lshift(r064D, body.constant(int(16))), 0x01));


                     body.instructions = f0658_parent_instructions;
                     body.emit(f0658);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r065C = bit_and(r0653, body.constant(4278190080u));
                     ir_expression *const r065D = equal(r065C, body.constant(0u));
                     ir_if *f065B = new(mem_ctx) ir_if(operand(r065D).val);
                     exec_list *const f065B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f065B->then_instructions;

                        body.emit(assign(r0655, add(r0655, body.constant(int(8))), 0x01));

                        body.emit(assign(r0653, lshift(r0653, body.constant(int(8))), 0x01));


                     body.instructions = f065B_parent_instructions;
                     body.emit(f065B);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r065F = bit_and(r0653, body.constant(4026531840u));
                     ir_expression *const r0660 = equal(r065F, body.constant(0u));
                     ir_if *f065E = new(mem_ctx) ir_if(operand(r0660).val);
                     exec_list *const f065E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f065E->then_instructions;

                        body.emit(assign(r0655, add(r0655, body.constant(int(4))), 0x01));

                        body.emit(assign(r0653, lshift(r0653, body.constant(int(4))), 0x01));


                     body.instructions = f065E_parent_instructions;
                     body.emit(f065E);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0662 = bit_and(r0653, body.constant(3221225472u));
                     ir_expression *const r0663 = equal(r0662, body.constant(0u));
                     ir_if *f0661 = new(mem_ctx) ir_if(operand(r0663).val);
                     exec_list *const f0661_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0661->then_instructions;

                        body.emit(assign(r0655, add(r0655, body.constant(int(2))), 0x01));

                        body.emit(assign(r0653, lshift(r0653, body.constant(int(2))), 0x01));


                     body.instructions = f0661_parent_instructions;
                     body.emit(f0661);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0665 = bit_and(r0653, body.constant(2147483648u));
                     ir_expression *const r0666 = equal(r0665, body.constant(0u));
                     ir_if *f0664 = new(mem_ctx) ir_if(operand(r0666).val);
                     exec_list *const f0664_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0664->then_instructions;

                        body.emit(assign(r0655, add(r0655, body.constant(int(1))), 0x01));


                     body.instructions = f0664_parent_instructions;
                     body.emit(f0664);

                     /* END IF */

                     body.emit(assign(r0654, r0655, 0x01));


                  body.instructions = f0656_parent_instructions;
                  body.emit(f0656);

                  /* END IF */

                  body.emit(assign(r0650, add(r0654, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0668 = lequal(body.constant(int(0)), r0650);
                  ir_if *f0667 = new(mem_ctx) ir_if(operand(r0668).val);
                  exec_list *const f0667_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0667->then_instructions;

                     body.emit(assign(r064F, body.constant(0u), 0x01));

                     ir_variable *const r0669 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r0669, lshift(r064E, r0650), 0x01));

                     ir_variable *const r066A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r066C = equal(r0650, body.constant(int(0)));
                     ir_if *f066B = new(mem_ctx) ir_if(operand(r066C).val);
                     exec_list *const f066B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f066B->then_instructions;

                        body.emit(assign(r066A, r064D, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f066B->else_instructions;

                        ir_expression *const r066D = lshift(r064D, r0650);
                        ir_expression *const r066E = neg(r0650);
                        ir_expression *const r066F = bit_and(r066E, body.constant(int(31)));
                        ir_expression *const r0670 = rshift(r064E, r066F);
                        body.emit(assign(r066A, bit_or(r066D, r0670), 0x01));


                     body.instructions = f066B_parent_instructions;
                     body.emit(f066B);

                     /* END IF */

                     body.emit(assign(r064D, r066A, 0x01));

                     body.emit(assign(r064E, r0669, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0667->else_instructions;

                     ir_variable *const r0671 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0671, body.constant(0u), 0x01));

                     ir_variable *const r0672 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0672, neg(r0650), 0x01));

                     ir_variable *const r0673 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0673);
                     ir_variable *const r0674 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0674);
                     ir_variable *const r0675 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0675);
                     ir_variable *const r0676 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0677 = neg(r0672);
                     body.emit(assign(r0676, bit_and(r0677, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0679 = equal(r0672, body.constant(int(0)));
                     ir_if *f0678 = new(mem_ctx) ir_if(operand(r0679).val);
                     exec_list *const f0678_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0678->then_instructions;

                        body.emit(assign(r0673, r0671, 0x01));

                        body.emit(assign(r0674, r064E, 0x01));

                        body.emit(assign(r0675, r064D, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0678->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r067B = less(r0672, body.constant(int(32)));
                        ir_if *f067A = new(mem_ctx) ir_if(operand(r067B).val);
                        exec_list *const f067A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f067A->then_instructions;

                           body.emit(assign(r0673, lshift(r064E, r0676), 0x01));

                           ir_expression *const r067C = lshift(r064D, r0676);
                           ir_expression *const r067D = rshift(r064E, r0672);
                           body.emit(assign(r0674, bit_or(r067C, r067D), 0x01));

                           body.emit(assign(r0675, rshift(r064D, r0672), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f067A->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r067F = equal(r0672, body.constant(int(32)));
                           ir_if *f067E = new(mem_ctx) ir_if(operand(r067F).val);
                           exec_list *const f067E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f067E->then_instructions;

                              body.emit(assign(r0673, r064E, 0x01));

                              body.emit(assign(r0674, r064D, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f067E->else_instructions;

                              body.emit(assign(r0671, bit_or(body.constant(0u), r064E), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0681 = less(r0672, body.constant(int(64)));
                              ir_if *f0680 = new(mem_ctx) ir_if(operand(r0681).val);
                              exec_list *const f0680_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0680->then_instructions;

                                 body.emit(assign(r0673, lshift(r064D, r0676), 0x01));

                                 ir_expression *const r0682 = bit_and(r0672, body.constant(int(31)));
                                 body.emit(assign(r0674, rshift(r064D, r0682), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0680->else_instructions;

                                 ir_variable *const r0683 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0685 = equal(r0672, body.constant(int(64)));
                                 ir_if *f0684 = new(mem_ctx) ir_if(operand(r0685).val);
                                 exec_list *const f0684_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0684->then_instructions;

                                    body.emit(assign(r0683, r064D, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0684->else_instructions;

                                    ir_expression *const r0686 = nequal(r064D, body.constant(0u));
                                    ir_expression *const r0687 = expr(ir_unop_b2i, r0686);
                                    body.emit(assign(r0683, expr(ir_unop_i2u, r0687), 0x01));


                                 body.instructions = f0684_parent_instructions;
                                 body.emit(f0684);

                                 /* END IF */

                                 body.emit(assign(r0673, r0683, 0x01));

                                 body.emit(assign(r0674, body.constant(0u), 0x01));


                              body.instructions = f0680_parent_instructions;
                              body.emit(f0680);

                              /* END IF */


                           body.instructions = f067E_parent_instructions;
                           body.emit(f067E);

                           /* END IF */

                           body.emit(assign(r0675, body.constant(0u), 0x01));


                        body.instructions = f067A_parent_instructions;
                        body.emit(f067A);

                        /* END IF */

                        ir_expression *const r0688 = nequal(r0671, body.constant(0u));
                        ir_expression *const r0689 = expr(ir_unop_b2i, r0688);
                        ir_expression *const r068A = expr(ir_unop_i2u, r0689);
                        body.emit(assign(r0673, bit_or(r0673, r068A), 0x01));


                     body.instructions = f0678_parent_instructions;
                     body.emit(f0678);

                     /* END IF */

                     body.emit(assign(r064D, r0675, 0x01));

                     body.emit(assign(r064E, r0674, 0x01));

                     body.emit(assign(r064F, r0673, 0x01));


                  body.instructions = f0667_parent_instructions;
                  body.emit(f0667);

                  /* END IF */

                  body.emit(assign(r064C, sub(r064C, r0650), 0x01));

                  ir_variable *const r068B = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r068B, r064C, 0x01));

                  ir_variable *const r068C = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r068C, r064D, 0x01));

                  ir_variable *const r068D = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r068D, r064E, 0x01));

                  ir_variable *const r068E = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r068E, r064F, 0x01));

                  ir_variable *const r068F = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r068F, body.constant(true), 0x01));

                  ir_variable *const r0690 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0691 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r0691);
                  ir_expression *const r0692 = expr(ir_unop_u2i, r064F);
                  body.emit(assign(r0691, less(r0692, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0694 = lequal(body.constant(int(2045)), r064C);
                  ir_if *f0693 = new(mem_ctx) ir_if(operand(r0694).val);
                  exec_list *const f0693_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0693->then_instructions;

                     ir_variable *const r0695 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0697 = less(body.constant(int(2045)), r064C);
                     ir_if *f0696 = new(mem_ctx) ir_if(operand(r0697).val);
                     exec_list *const f0696_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0696->then_instructions;

                        body.emit(assign(r0695, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0696->else_instructions;

                        ir_variable *const r0698 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r069A = equal(r064C, body.constant(int(2045)));
                        ir_if *f0699 = new(mem_ctx) ir_if(operand(r069A).val);
                        exec_list *const f0699_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0699->then_instructions;

                           ir_expression *const r069B = equal(body.constant(2097151u), r064D);
                           ir_expression *const r069C = equal(body.constant(4294967295u), r064E);
                           body.emit(assign(r0698, logic_and(r069B, r069C), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0699->else_instructions;

                           body.emit(assign(r0698, body.constant(false), 0x01));


                        body.instructions = f0699_parent_instructions;
                        body.emit(f0699);

                        /* END IF */

                        body.emit(assign(r0695, logic_and(r0698, r0691), 0x01));


                     body.instructions = f0696_parent_instructions;
                     body.emit(f0696);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f069D = new(mem_ctx) ir_if(operand(r0695).val);
                     exec_list *const f069D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f069D->then_instructions;

                        ir_variable *const r069E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r069E);
                        ir_expression *const r069F = lshift(r03D3, body.constant(int(31)));
                        body.emit(assign(r069E, add(r069F, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r069E, body.constant(0u), 0x01));

                        body.emit(assign(r0690, r069E, 0x03));

                        body.emit(assign(r068F, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f069D->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r06A1 = less(r064C, body.constant(int(0)));
                        ir_if *f06A0 = new(mem_ctx) ir_if(operand(r06A1).val);
                        exec_list *const f06A0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06A0->then_instructions;

                           ir_variable *const r06A2 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r06A2, r064F, 0x01));

                           ir_variable *const r06A3 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r06A3, neg(r064C), 0x01));

                           ir_variable *const r06A4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r06A4);
                           ir_variable *const r06A5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r06A5);
                           ir_variable *const r06A6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r06A6);
                           ir_variable *const r06A7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r06A8 = neg(r06A3);
                           body.emit(assign(r06A7, bit_and(r06A8, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r06AA = equal(r06A3, body.constant(int(0)));
                           ir_if *f06A9 = new(mem_ctx) ir_if(operand(r06AA).val);
                           exec_list *const f06A9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f06A9->then_instructions;

                              body.emit(assign(r06A4, r064F, 0x01));

                              body.emit(assign(r06A5, r064E, 0x01));

                              body.emit(assign(r06A6, r064D, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f06A9->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r06AC = less(r06A3, body.constant(int(32)));
                              ir_if *f06AB = new(mem_ctx) ir_if(operand(r06AC).val);
                              exec_list *const f06AB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f06AB->then_instructions;

                                 body.emit(assign(r06A4, lshift(r064E, r06A7), 0x01));

                                 ir_expression *const r06AD = lshift(r064D, r06A7);
                                 ir_expression *const r06AE = rshift(r064E, r06A3);
                                 body.emit(assign(r06A5, bit_or(r06AD, r06AE), 0x01));

                                 body.emit(assign(r06A6, rshift(r064D, r06A3), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f06AB->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r06B0 = equal(r06A3, body.constant(int(32)));
                                 ir_if *f06AF = new(mem_ctx) ir_if(operand(r06B0).val);
                                 exec_list *const f06AF_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f06AF->then_instructions;

                                    body.emit(assign(r06A4, r064E, 0x01));

                                    body.emit(assign(r06A5, r064D, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f06AF->else_instructions;

                                    body.emit(assign(r06A2, bit_or(r064F, r064E), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r06B2 = less(r06A3, body.constant(int(64)));
                                    ir_if *f06B1 = new(mem_ctx) ir_if(operand(r06B2).val);
                                    exec_list *const f06B1_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f06B1->then_instructions;

                                       body.emit(assign(r06A4, lshift(r064D, r06A7), 0x01));

                                       ir_expression *const r06B3 = bit_and(r06A3, body.constant(int(31)));
                                       body.emit(assign(r06A5, rshift(r064D, r06B3), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f06B1->else_instructions;

                                       ir_variable *const r06B4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r06B6 = equal(r06A3, body.constant(int(64)));
                                       ir_if *f06B5 = new(mem_ctx) ir_if(operand(r06B6).val);
                                       exec_list *const f06B5_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f06B5->then_instructions;

                                          body.emit(assign(r06B4, r064D, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f06B5->else_instructions;

                                          ir_expression *const r06B7 = nequal(r064D, body.constant(0u));
                                          ir_expression *const r06B8 = expr(ir_unop_b2i, r06B7);
                                          body.emit(assign(r06B4, expr(ir_unop_i2u, r06B8), 0x01));


                                       body.instructions = f06B5_parent_instructions;
                                       body.emit(f06B5);

                                       /* END IF */

                                       body.emit(assign(r06A4, r06B4, 0x01));

                                       body.emit(assign(r06A5, body.constant(0u), 0x01));


                                    body.instructions = f06B1_parent_instructions;
                                    body.emit(f06B1);

                                    /* END IF */


                                 body.instructions = f06AF_parent_instructions;
                                 body.emit(f06AF);

                                 /* END IF */

                                 body.emit(assign(r06A6, body.constant(0u), 0x01));


                              body.instructions = f06AB_parent_instructions;
                              body.emit(f06AB);

                              /* END IF */

                              ir_expression *const r06B9 = nequal(r06A2, body.constant(0u));
                              ir_expression *const r06BA = expr(ir_unop_b2i, r06B9);
                              ir_expression *const r06BB = expr(ir_unop_i2u, r06BA);
                              body.emit(assign(r06A4, bit_or(r06A4, r06BB), 0x01));


                           body.instructions = f06A9_parent_instructions;
                           body.emit(f06A9);

                           /* END IF */

                           body.emit(assign(r068C, r06A6, 0x01));

                           body.emit(assign(r068D, r06A5, 0x01));

                           body.emit(assign(r068E, r06A4, 0x01));

                           body.emit(assign(r068B, body.constant(int(0)), 0x01));

                           body.emit(assign(r0691, less(r06A4, body.constant(0u)), 0x01));


                        body.instructions = f06A0_parent_instructions;
                        body.emit(f06A0);

                        /* END IF */


                     body.instructions = f069D_parent_instructions;
                     body.emit(f069D);

                     /* END IF */


                  body.instructions = f0693_parent_instructions;
                  body.emit(f0693);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f06BC = new(mem_ctx) ir_if(operand(r068F).val);
                  exec_list *const f06BC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f06BC->then_instructions;

                     /* IF CONDITION */
                     ir_if *f06BD = new(mem_ctx) ir_if(operand(r0691).val);
                     exec_list *const f06BD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f06BD->then_instructions;

                        ir_variable *const r06BE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r06BE, add(r068D, body.constant(1u)), 0x01));

                        ir_expression *const r06BF = less(r06BE, r068D);
                        ir_expression *const r06C0 = expr(ir_unop_b2i, r06BF);
                        ir_expression *const r06C1 = expr(ir_unop_i2u, r06C0);
                        body.emit(assign(r068C, add(r068C, r06C1), 0x01));

                        ir_expression *const r06C2 = equal(r068E, body.constant(0u));
                        ir_expression *const r06C3 = expr(ir_unop_b2i, r06C2);
                        ir_expression *const r06C4 = expr(ir_unop_i2u, r06C3);
                        ir_expression *const r06C5 = add(r068E, r06C4);
                        ir_expression *const r06C6 = bit_and(r06C5, body.constant(1u));
                        ir_expression *const r06C7 = expr(ir_unop_bit_not, r06C6);
                        body.emit(assign(r068D, bit_and(r06BE, r06C7), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f06BD->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r06C9 = bit_or(r068C, r068D);
                        ir_expression *const r06CA = equal(r06C9, body.constant(0u));
                        ir_if *f06C8 = new(mem_ctx) ir_if(operand(r06CA).val);
                        exec_list *const f06C8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06C8->then_instructions;

                           body.emit(assign(r068B, body.constant(int(0)), 0x01));


                        body.instructions = f06C8_parent_instructions;
                        body.emit(f06C8);

                        /* END IF */


                     body.instructions = f06BD_parent_instructions;
                     body.emit(f06BD);

                     /* END IF */

                     ir_variable *const r06CB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r06CB);
                     ir_expression *const r06CC = lshift(r03D3, body.constant(int(31)));
                     ir_expression *const r06CD = expr(ir_unop_i2u, r068B);
                     ir_expression *const r06CE = lshift(r06CD, body.constant(int(20)));
                     ir_expression *const r06CF = add(r06CC, r06CE);
                     body.emit(assign(r06CB, add(r06CF, r068C), 0x02));

                     body.emit(assign(r06CB, r068D, 0x01));

                     body.emit(assign(r0690, r06CB, 0x03));

                     body.emit(assign(r068F, body.constant(false), 0x01));


                  body.instructions = f06BC_parent_instructions;
                  body.emit(f06BC);

                  /* END IF */

                  body.emit(assign(r03D4, r0690, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0644->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r06D1 = less(r03D9, r03DB);
                  ir_if *f06D0 = new(mem_ctx) ir_if(operand(r06D1).val);
                  exec_list *const f06D0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f06D0->then_instructions;

                     ir_variable *const r06D2 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r06D3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r06D3, sub(r03DB, r03D9), 0x01));

                     ir_expression *const r06D4 = sub(r03DA, r03D8);
                     ir_expression *const r06D5 = less(r03DB, r03D9);
                     ir_expression *const r06D6 = expr(ir_unop_b2i, r06D5);
                     ir_expression *const r06D7 = expr(ir_unop_i2u, r06D6);
                     body.emit(assign(r06D2, sub(r06D4, r06D7), 0x01));

                     body.emit(assign(r03DC, add(r03D7, body.constant(int(-1))), 0x01));

                     ir_variable *const r06D8 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r06D8, add(r03DC, body.constant(int(-10))), 0x01));

                     ir_variable *const r06D9 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r06D9, r06D2, 0x01));

                     ir_variable *const r06DA = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r06DA, r06D3, 0x01));

                     ir_variable *const r06DB = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r06DB);
                     ir_variable *const r06DC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r06DC);
                     /* IF CONDITION */
                     ir_expression *const r06DE = equal(r06D2, body.constant(0u));
                     ir_if *f06DD = new(mem_ctx) ir_if(operand(r06DE).val);
                     exec_list *const f06DD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f06DD->then_instructions;

                        body.emit(assign(r06D9, r06D3, 0x01));

                        body.emit(assign(r06DA, body.constant(0u), 0x01));

                        body.emit(assign(r06D8, add(r06D8, body.constant(int(-32))), 0x01));


                     body.instructions = f06DD_parent_instructions;
                     body.emit(f06DD);

                     /* END IF */

                     ir_variable *const r06DF = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r06DF, r06D9, 0x01));

                     ir_variable *const r06E0 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r06E1 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r06E1);
                     /* IF CONDITION */
                     ir_expression *const r06E3 = equal(r06D9, body.constant(0u));
                     ir_if *f06E2 = new(mem_ctx) ir_if(operand(r06E3).val);
                     exec_list *const f06E2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f06E2->then_instructions;

                        body.emit(assign(r06E0, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f06E2->else_instructions;

                        body.emit(assign(r06E1, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r06E5 = bit_and(r06D9, body.constant(4294901760u));
                        ir_expression *const r06E6 = equal(r06E5, body.constant(0u));
                        ir_if *f06E4 = new(mem_ctx) ir_if(operand(r06E6).val);
                        exec_list *const f06E4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06E4->then_instructions;

                           body.emit(assign(r06E1, body.constant(int(16)), 0x01));

                           body.emit(assign(r06DF, lshift(r06D9, body.constant(int(16))), 0x01));


                        body.instructions = f06E4_parent_instructions;
                        body.emit(f06E4);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r06E8 = bit_and(r06DF, body.constant(4278190080u));
                        ir_expression *const r06E9 = equal(r06E8, body.constant(0u));
                        ir_if *f06E7 = new(mem_ctx) ir_if(operand(r06E9).val);
                        exec_list *const f06E7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06E7->then_instructions;

                           body.emit(assign(r06E1, add(r06E1, body.constant(int(8))), 0x01));

                           body.emit(assign(r06DF, lshift(r06DF, body.constant(int(8))), 0x01));


                        body.instructions = f06E7_parent_instructions;
                        body.emit(f06E7);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r06EB = bit_and(r06DF, body.constant(4026531840u));
                        ir_expression *const r06EC = equal(r06EB, body.constant(0u));
                        ir_if *f06EA = new(mem_ctx) ir_if(operand(r06EC).val);
                        exec_list *const f06EA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06EA->then_instructions;

                           body.emit(assign(r06E1, add(r06E1, body.constant(int(4))), 0x01));

                           body.emit(assign(r06DF, lshift(r06DF, body.constant(int(4))), 0x01));


                        body.instructions = f06EA_parent_instructions;
                        body.emit(f06EA);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r06EE = bit_and(r06DF, body.constant(3221225472u));
                        ir_expression *const r06EF = equal(r06EE, body.constant(0u));
                        ir_if *f06ED = new(mem_ctx) ir_if(operand(r06EF).val);
                        exec_list *const f06ED_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06ED->then_instructions;

                           body.emit(assign(r06E1, add(r06E1, body.constant(int(2))), 0x01));

                           body.emit(assign(r06DF, lshift(r06DF, body.constant(int(2))), 0x01));


                        body.instructions = f06ED_parent_instructions;
                        body.emit(f06ED);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r06F1 = bit_and(r06DF, body.constant(2147483648u));
                        ir_expression *const r06F2 = equal(r06F1, body.constant(0u));
                        ir_if *f06F0 = new(mem_ctx) ir_if(operand(r06F2).val);
                        exec_list *const f06F0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06F0->then_instructions;

                           body.emit(assign(r06E1, add(r06E1, body.constant(int(1))), 0x01));


                        body.instructions = f06F0_parent_instructions;
                        body.emit(f06F0);

                        /* END IF */

                        body.emit(assign(r06E0, r06E1, 0x01));


                     body.instructions = f06E2_parent_instructions;
                     body.emit(f06E2);

                     /* END IF */

                     body.emit(assign(r06DC, add(r06E0, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r06F4 = lequal(body.constant(int(0)), r06DC);
                     ir_if *f06F3 = new(mem_ctx) ir_if(operand(r06F4).val);
                     exec_list *const f06F3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f06F3->then_instructions;

                        body.emit(assign(r06DB, body.constant(0u), 0x01));

                        ir_variable *const r06F5 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r06F5, lshift(r06DA, r06DC), 0x01));

                        ir_variable *const r06F6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r06F8 = equal(r06DC, body.constant(int(0)));
                        ir_if *f06F7 = new(mem_ctx) ir_if(operand(r06F8).val);
                        exec_list *const f06F7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06F7->then_instructions;

                           body.emit(assign(r06F6, r06D9, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f06F7->else_instructions;

                           ir_expression *const r06F9 = lshift(r06D9, r06DC);
                           ir_expression *const r06FA = neg(r06DC);
                           ir_expression *const r06FB = bit_and(r06FA, body.constant(int(31)));
                           ir_expression *const r06FC = rshift(r06DA, r06FB);
                           body.emit(assign(r06F6, bit_or(r06F9, r06FC), 0x01));


                        body.instructions = f06F7_parent_instructions;
                        body.emit(f06F7);

                        /* END IF */

                        body.emit(assign(r06D9, r06F6, 0x01));

                        body.emit(assign(r06DA, r06F5, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f06F3->else_instructions;

                        ir_variable *const r06FD = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r06FD, body.constant(0u), 0x01));

                        ir_variable *const r06FE = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r06FE, neg(r06DC), 0x01));

                        ir_variable *const r06FF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r06FF);
                        ir_variable *const r0700 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0700);
                        ir_variable *const r0701 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0701);
                        ir_variable *const r0702 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r0703 = neg(r06FE);
                        body.emit(assign(r0702, bit_and(r0703, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0705 = equal(r06FE, body.constant(int(0)));
                        ir_if *f0704 = new(mem_ctx) ir_if(operand(r0705).val);
                        exec_list *const f0704_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0704->then_instructions;

                           body.emit(assign(r06FF, r06FD, 0x01));

                           body.emit(assign(r0700, r06DA, 0x01));

                           body.emit(assign(r0701, r06D9, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0704->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0707 = less(r06FE, body.constant(int(32)));
                           ir_if *f0706 = new(mem_ctx) ir_if(operand(r0707).val);
                           exec_list *const f0706_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0706->then_instructions;

                              body.emit(assign(r06FF, lshift(r06DA, r0702), 0x01));

                              ir_expression *const r0708 = lshift(r06D9, r0702);
                              ir_expression *const r0709 = rshift(r06DA, r06FE);
                              body.emit(assign(r0700, bit_or(r0708, r0709), 0x01));

                              body.emit(assign(r0701, rshift(r06D9, r06FE), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0706->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r070B = equal(r06FE, body.constant(int(32)));
                              ir_if *f070A = new(mem_ctx) ir_if(operand(r070B).val);
                              exec_list *const f070A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f070A->then_instructions;

                                 body.emit(assign(r06FF, r06DA, 0x01));

                                 body.emit(assign(r0700, r06D9, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f070A->else_instructions;

                                 body.emit(assign(r06FD, bit_or(body.constant(0u), r06DA), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r070D = less(r06FE, body.constant(int(64)));
                                 ir_if *f070C = new(mem_ctx) ir_if(operand(r070D).val);
                                 exec_list *const f070C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f070C->then_instructions;

                                    body.emit(assign(r06FF, lshift(r06D9, r0702), 0x01));

                                    ir_expression *const r070E = bit_and(r06FE, body.constant(int(31)));
                                    body.emit(assign(r0700, rshift(r06D9, r070E), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f070C->else_instructions;

                                    ir_variable *const r070F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r0711 = equal(r06FE, body.constant(int(64)));
                                    ir_if *f0710 = new(mem_ctx) ir_if(operand(r0711).val);
                                    exec_list *const f0710_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0710->then_instructions;

                                       body.emit(assign(r070F, r06D9, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0710->else_instructions;

                                       ir_expression *const r0712 = nequal(r06D9, body.constant(0u));
                                       ir_expression *const r0713 = expr(ir_unop_b2i, r0712);
                                       body.emit(assign(r070F, expr(ir_unop_i2u, r0713), 0x01));


                                    body.instructions = f0710_parent_instructions;
                                    body.emit(f0710);

                                    /* END IF */

                                    body.emit(assign(r06FF, r070F, 0x01));

                                    body.emit(assign(r0700, body.constant(0u), 0x01));


                                 body.instructions = f070C_parent_instructions;
                                 body.emit(f070C);

                                 /* END IF */


                              body.instructions = f070A_parent_instructions;
                              body.emit(f070A);

                              /* END IF */

                              body.emit(assign(r0701, body.constant(0u), 0x01));


                           body.instructions = f0706_parent_instructions;
                           body.emit(f0706);

                           /* END IF */

                           ir_expression *const r0714 = nequal(r06FD, body.constant(0u));
                           ir_expression *const r0715 = expr(ir_unop_b2i, r0714);
                           ir_expression *const r0716 = expr(ir_unop_i2u, r0715);
                           body.emit(assign(r06FF, bit_or(r06FF, r0716), 0x01));


                        body.instructions = f0704_parent_instructions;
                        body.emit(f0704);

                        /* END IF */

                        body.emit(assign(r06D9, r0701, 0x01));

                        body.emit(assign(r06DA, r0700, 0x01));

                        body.emit(assign(r06DB, r06FF, 0x01));


                     body.instructions = f06F3_parent_instructions;
                     body.emit(f06F3);

                     /* END IF */

                     body.emit(assign(r06D8, sub(r06D8, r06DC), 0x01));

                     ir_variable *const r0717 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r0717, r06D8, 0x01));

                     ir_variable *const r0718 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r0718, r06D9, 0x01));

                     ir_variable *const r0719 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r0719, r06DA, 0x01));

                     ir_variable *const r071A = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r071A, r06DB, 0x01));

                     ir_variable *const r071B = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r071B, body.constant(true), 0x01));

                     ir_variable *const r071C = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r071D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r071D);
                     ir_expression *const r071E = expr(ir_unop_u2i, r06DB);
                     body.emit(assign(r071D, less(r071E, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0720 = lequal(body.constant(int(2045)), r06D8);
                     ir_if *f071F = new(mem_ctx) ir_if(operand(r0720).val);
                     exec_list *const f071F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f071F->then_instructions;

                        ir_variable *const r0721 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0723 = less(body.constant(int(2045)), r06D8);
                        ir_if *f0722 = new(mem_ctx) ir_if(operand(r0723).val);
                        exec_list *const f0722_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0722->then_instructions;

                           body.emit(assign(r0721, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0722->else_instructions;

                           ir_variable *const r0724 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0726 = equal(r06D8, body.constant(int(2045)));
                           ir_if *f0725 = new(mem_ctx) ir_if(operand(r0726).val);
                           exec_list *const f0725_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0725->then_instructions;

                              ir_expression *const r0727 = equal(body.constant(2097151u), r06D9);
                              ir_expression *const r0728 = equal(body.constant(4294967295u), r06DA);
                              body.emit(assign(r0724, logic_and(r0727, r0728), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0725->else_instructions;

                              body.emit(assign(r0724, body.constant(false), 0x01));


                           body.instructions = f0725_parent_instructions;
                           body.emit(f0725);

                           /* END IF */

                           body.emit(assign(r0721, logic_and(r0724, r071D), 0x01));


                        body.instructions = f0722_parent_instructions;
                        body.emit(f0722);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f0729 = new(mem_ctx) ir_if(operand(r0721).val);
                        exec_list *const f0729_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0729->then_instructions;

                           ir_variable *const r072A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r072A);
                           ir_expression *const r072B = lshift(r03D3, body.constant(int(31)));
                           body.emit(assign(r072A, add(r072B, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r072A, body.constant(0u), 0x01));

                           body.emit(assign(r071C, r072A, 0x03));

                           body.emit(assign(r071B, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0729->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r072D = less(r06D8, body.constant(int(0)));
                           ir_if *f072C = new(mem_ctx) ir_if(operand(r072D).val);
                           exec_list *const f072C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f072C->then_instructions;

                              ir_variable *const r072E = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r072E, r06DB, 0x01));

                              ir_variable *const r072F = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r072F, neg(r06D8), 0x01));

                              ir_variable *const r0730 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r0730);
                              ir_variable *const r0731 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r0731);
                              ir_variable *const r0732 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r0732);
                              ir_variable *const r0733 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r0734 = neg(r072F);
                              body.emit(assign(r0733, bit_and(r0734, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0736 = equal(r072F, body.constant(int(0)));
                              ir_if *f0735 = new(mem_ctx) ir_if(operand(r0736).val);
                              exec_list *const f0735_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0735->then_instructions;

                                 body.emit(assign(r0730, r06DB, 0x01));

                                 body.emit(assign(r0731, r06DA, 0x01));

                                 body.emit(assign(r0732, r06D9, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0735->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0738 = less(r072F, body.constant(int(32)));
                                 ir_if *f0737 = new(mem_ctx) ir_if(operand(r0738).val);
                                 exec_list *const f0737_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0737->then_instructions;

                                    body.emit(assign(r0730, lshift(r06DA, r0733), 0x01));

                                    ir_expression *const r0739 = lshift(r06D9, r0733);
                                    ir_expression *const r073A = rshift(r06DA, r072F);
                                    body.emit(assign(r0731, bit_or(r0739, r073A), 0x01));

                                    body.emit(assign(r0732, rshift(r06D9, r072F), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0737->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r073C = equal(r072F, body.constant(int(32)));
                                    ir_if *f073B = new(mem_ctx) ir_if(operand(r073C).val);
                                    exec_list *const f073B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f073B->then_instructions;

                                       body.emit(assign(r0730, r06DA, 0x01));

                                       body.emit(assign(r0731, r06D9, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f073B->else_instructions;

                                       body.emit(assign(r072E, bit_or(r06DB, r06DA), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r073E = less(r072F, body.constant(int(64)));
                                       ir_if *f073D = new(mem_ctx) ir_if(operand(r073E).val);
                                       exec_list *const f073D_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f073D->then_instructions;

                                          body.emit(assign(r0730, lshift(r06D9, r0733), 0x01));

                                          ir_expression *const r073F = bit_and(r072F, body.constant(int(31)));
                                          body.emit(assign(r0731, rshift(r06D9, r073F), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f073D->else_instructions;

                                          ir_variable *const r0740 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r0742 = equal(r072F, body.constant(int(64)));
                                          ir_if *f0741 = new(mem_ctx) ir_if(operand(r0742).val);
                                          exec_list *const f0741_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0741->then_instructions;

                                             body.emit(assign(r0740, r06D9, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0741->else_instructions;

                                             ir_expression *const r0743 = nequal(r06D9, body.constant(0u));
                                             ir_expression *const r0744 = expr(ir_unop_b2i, r0743);
                                             body.emit(assign(r0740, expr(ir_unop_i2u, r0744), 0x01));


                                          body.instructions = f0741_parent_instructions;
                                          body.emit(f0741);

                                          /* END IF */

                                          body.emit(assign(r0730, r0740, 0x01));

                                          body.emit(assign(r0731, body.constant(0u), 0x01));


                                       body.instructions = f073D_parent_instructions;
                                       body.emit(f073D);

                                       /* END IF */


                                    body.instructions = f073B_parent_instructions;
                                    body.emit(f073B);

                                    /* END IF */

                                    body.emit(assign(r0732, body.constant(0u), 0x01));


                                 body.instructions = f0737_parent_instructions;
                                 body.emit(f0737);

                                 /* END IF */

                                 ir_expression *const r0745 = nequal(r072E, body.constant(0u));
                                 ir_expression *const r0746 = expr(ir_unop_b2i, r0745);
                                 ir_expression *const r0747 = expr(ir_unop_i2u, r0746);
                                 body.emit(assign(r0730, bit_or(r0730, r0747), 0x01));


                              body.instructions = f0735_parent_instructions;
                              body.emit(f0735);

                              /* END IF */

                              body.emit(assign(r0718, r0732, 0x01));

                              body.emit(assign(r0719, r0731, 0x01));

                              body.emit(assign(r071A, r0730, 0x01));

                              body.emit(assign(r0717, body.constant(int(0)), 0x01));

                              body.emit(assign(r071D, less(r0730, body.constant(0u)), 0x01));


                           body.instructions = f072C_parent_instructions;
                           body.emit(f072C);

                           /* END IF */


                        body.instructions = f0729_parent_instructions;
                        body.emit(f0729);

                        /* END IF */


                     body.instructions = f071F_parent_instructions;
                     body.emit(f071F);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f0748 = new(mem_ctx) ir_if(operand(r071B).val);
                     exec_list *const f0748_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0748->then_instructions;

                        /* IF CONDITION */
                        ir_if *f0749 = new(mem_ctx) ir_if(operand(r071D).val);
                        exec_list *const f0749_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0749->then_instructions;

                           ir_variable *const r074A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r074A, add(r0719, body.constant(1u)), 0x01));

                           ir_expression *const r074B = less(r074A, r0719);
                           ir_expression *const r074C = expr(ir_unop_b2i, r074B);
                           ir_expression *const r074D = expr(ir_unop_i2u, r074C);
                           body.emit(assign(r0718, add(r0718, r074D), 0x01));

                           ir_expression *const r074E = equal(r071A, body.constant(0u));
                           ir_expression *const r074F = expr(ir_unop_b2i, r074E);
                           ir_expression *const r0750 = expr(ir_unop_i2u, r074F);
                           ir_expression *const r0751 = add(r071A, r0750);
                           ir_expression *const r0752 = bit_and(r0751, body.constant(1u));
                           ir_expression *const r0753 = expr(ir_unop_bit_not, r0752);
                           body.emit(assign(r0719, bit_and(r074A, r0753), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0749->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0755 = bit_or(r0718, r0719);
                           ir_expression *const r0756 = equal(r0755, body.constant(0u));
                           ir_if *f0754 = new(mem_ctx) ir_if(operand(r0756).val);
                           exec_list *const f0754_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0754->then_instructions;

                              body.emit(assign(r0717, body.constant(int(0)), 0x01));


                           body.instructions = f0754_parent_instructions;
                           body.emit(f0754);

                           /* END IF */


                        body.instructions = f0749_parent_instructions;
                        body.emit(f0749);

                        /* END IF */

                        ir_variable *const r0757 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r0757);
                        ir_expression *const r0758 = lshift(r03D3, body.constant(int(31)));
                        ir_expression *const r0759 = expr(ir_unop_i2u, r0717);
                        ir_expression *const r075A = lshift(r0759, body.constant(int(20)));
                        ir_expression *const r075B = add(r0758, r075A);
                        body.emit(assign(r0757, add(r075B, r0718), 0x02));

                        body.emit(assign(r0757, r0719, 0x01));

                        body.emit(assign(r071C, r0757, 0x03));

                        body.emit(assign(r071B, body.constant(false), 0x01));


                     body.instructions = f0748_parent_instructions;
                     body.emit(f0748);

                     /* END IF */

                     body.emit(assign(r03D4, r071C, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f06D0->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r075D = less(r03DB, r03D9);
                     ir_if *f075C = new(mem_ctx) ir_if(operand(r075D).val);
                     exec_list *const f075C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f075C->then_instructions;

                        ir_variable *const r075E = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r075F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r075F, sub(r03D9, r03DB), 0x01));

                        ir_expression *const r0760 = sub(r03D8, r03DA);
                        ir_expression *const r0761 = less(r03D9, r03DB);
                        ir_expression *const r0762 = expr(ir_unop_b2i, r0761);
                        ir_expression *const r0763 = expr(ir_unop_i2u, r0762);
                        body.emit(assign(r075E, sub(r0760, r0763), 0x01));

                        body.emit(assign(r03D3, bit_xor(r03D3, body.constant(1u)), 0x01));

                        body.emit(assign(r03DC, add(r03D6, body.constant(int(-1))), 0x01));

                        ir_variable *const r0764 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r0764, add(r03DC, body.constant(int(-10))), 0x01));

                        ir_variable *const r0765 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r0765, r075E, 0x01));

                        ir_variable *const r0766 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r0766, r075F, 0x01));

                        ir_variable *const r0767 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r0767);
                        ir_variable *const r0768 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r0768);
                        /* IF CONDITION */
                        ir_expression *const r076A = equal(r075E, body.constant(0u));
                        ir_if *f0769 = new(mem_ctx) ir_if(operand(r076A).val);
                        exec_list *const f0769_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0769->then_instructions;

                           body.emit(assign(r0765, r075F, 0x01));

                           body.emit(assign(r0766, body.constant(0u), 0x01));

                           body.emit(assign(r0764, add(r0764, body.constant(int(-32))), 0x01));


                        body.instructions = f0769_parent_instructions;
                        body.emit(f0769);

                        /* END IF */

                        ir_variable *const r076B = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r076B, r0765, 0x01));

                        ir_variable *const r076C = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r076D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r076D);
                        /* IF CONDITION */
                        ir_expression *const r076F = equal(r0765, body.constant(0u));
                        ir_if *f076E = new(mem_ctx) ir_if(operand(r076F).val);
                        exec_list *const f076E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f076E->then_instructions;

                           body.emit(assign(r076C, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f076E->else_instructions;

                           body.emit(assign(r076D, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0771 = bit_and(r0765, body.constant(4294901760u));
                           ir_expression *const r0772 = equal(r0771, body.constant(0u));
                           ir_if *f0770 = new(mem_ctx) ir_if(operand(r0772).val);
                           exec_list *const f0770_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0770->then_instructions;

                              body.emit(assign(r076D, body.constant(int(16)), 0x01));

                              body.emit(assign(r076B, lshift(r0765, body.constant(int(16))), 0x01));


                           body.instructions = f0770_parent_instructions;
                           body.emit(f0770);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0774 = bit_and(r076B, body.constant(4278190080u));
                           ir_expression *const r0775 = equal(r0774, body.constant(0u));
                           ir_if *f0773 = new(mem_ctx) ir_if(operand(r0775).val);
                           exec_list *const f0773_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0773->then_instructions;

                              body.emit(assign(r076D, add(r076D, body.constant(int(8))), 0x01));

                              body.emit(assign(r076B, lshift(r076B, body.constant(int(8))), 0x01));


                           body.instructions = f0773_parent_instructions;
                           body.emit(f0773);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0777 = bit_and(r076B, body.constant(4026531840u));
                           ir_expression *const r0778 = equal(r0777, body.constant(0u));
                           ir_if *f0776 = new(mem_ctx) ir_if(operand(r0778).val);
                           exec_list *const f0776_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0776->then_instructions;

                              body.emit(assign(r076D, add(r076D, body.constant(int(4))), 0x01));

                              body.emit(assign(r076B, lshift(r076B, body.constant(int(4))), 0x01));


                           body.instructions = f0776_parent_instructions;
                           body.emit(f0776);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r077A = bit_and(r076B, body.constant(3221225472u));
                           ir_expression *const r077B = equal(r077A, body.constant(0u));
                           ir_if *f0779 = new(mem_ctx) ir_if(operand(r077B).val);
                           exec_list *const f0779_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0779->then_instructions;

                              body.emit(assign(r076D, add(r076D, body.constant(int(2))), 0x01));

                              body.emit(assign(r076B, lshift(r076B, body.constant(int(2))), 0x01));


                           body.instructions = f0779_parent_instructions;
                           body.emit(f0779);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r077D = bit_and(r076B, body.constant(2147483648u));
                           ir_expression *const r077E = equal(r077D, body.constant(0u));
                           ir_if *f077C = new(mem_ctx) ir_if(operand(r077E).val);
                           exec_list *const f077C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f077C->then_instructions;

                              body.emit(assign(r076D, add(r076D, body.constant(int(1))), 0x01));


                           body.instructions = f077C_parent_instructions;
                           body.emit(f077C);

                           /* END IF */

                           body.emit(assign(r076C, r076D, 0x01));


                        body.instructions = f076E_parent_instructions;
                        body.emit(f076E);

                        /* END IF */

                        body.emit(assign(r0768, add(r076C, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0780 = lequal(body.constant(int(0)), r0768);
                        ir_if *f077F = new(mem_ctx) ir_if(operand(r0780).val);
                        exec_list *const f077F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f077F->then_instructions;

                           body.emit(assign(r0767, body.constant(0u), 0x01));

                           ir_variable *const r0781 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r0781, lshift(r0766, r0768), 0x01));

                           ir_variable *const r0782 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0784 = equal(r0768, body.constant(int(0)));
                           ir_if *f0783 = new(mem_ctx) ir_if(operand(r0784).val);
                           exec_list *const f0783_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0783->then_instructions;

                              body.emit(assign(r0782, r0765, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0783->else_instructions;

                              ir_expression *const r0785 = lshift(r0765, r0768);
                              ir_expression *const r0786 = neg(r0768);
                              ir_expression *const r0787 = bit_and(r0786, body.constant(int(31)));
                              ir_expression *const r0788 = rshift(r0766, r0787);
                              body.emit(assign(r0782, bit_or(r0785, r0788), 0x01));


                           body.instructions = f0783_parent_instructions;
                           body.emit(f0783);

                           /* END IF */

                           body.emit(assign(r0765, r0782, 0x01));

                           body.emit(assign(r0766, r0781, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f077F->else_instructions;

                           ir_variable *const r0789 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r0789, body.constant(0u), 0x01));

                           ir_variable *const r078A = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r078A, neg(r0768), 0x01));

                           ir_variable *const r078B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r078B);
                           ir_variable *const r078C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r078C);
                           ir_variable *const r078D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r078D);
                           ir_variable *const r078E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r078F = neg(r078A);
                           body.emit(assign(r078E, bit_and(r078F, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0791 = equal(r078A, body.constant(int(0)));
                           ir_if *f0790 = new(mem_ctx) ir_if(operand(r0791).val);
                           exec_list *const f0790_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0790->then_instructions;

                              body.emit(assign(r078B, r0789, 0x01));

                              body.emit(assign(r078C, r0766, 0x01));

                              body.emit(assign(r078D, r0765, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0790->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0793 = less(r078A, body.constant(int(32)));
                              ir_if *f0792 = new(mem_ctx) ir_if(operand(r0793).val);
                              exec_list *const f0792_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0792->then_instructions;

                                 body.emit(assign(r078B, lshift(r0766, r078E), 0x01));

                                 ir_expression *const r0794 = lshift(r0765, r078E);
                                 ir_expression *const r0795 = rshift(r0766, r078A);
                                 body.emit(assign(r078C, bit_or(r0794, r0795), 0x01));

                                 body.emit(assign(r078D, rshift(r0765, r078A), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0792->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0797 = equal(r078A, body.constant(int(32)));
                                 ir_if *f0796 = new(mem_ctx) ir_if(operand(r0797).val);
                                 exec_list *const f0796_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0796->then_instructions;

                                    body.emit(assign(r078B, r0766, 0x01));

                                    body.emit(assign(r078C, r0765, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0796->else_instructions;

                                    body.emit(assign(r0789, bit_or(body.constant(0u), r0766), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r0799 = less(r078A, body.constant(int(64)));
                                    ir_if *f0798 = new(mem_ctx) ir_if(operand(r0799).val);
                                    exec_list *const f0798_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0798->then_instructions;

                                       body.emit(assign(r078B, lshift(r0765, r078E), 0x01));

                                       ir_expression *const r079A = bit_and(r078A, body.constant(int(31)));
                                       body.emit(assign(r078C, rshift(r0765, r079A), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0798->else_instructions;

                                       ir_variable *const r079B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r079D = equal(r078A, body.constant(int(64)));
                                       ir_if *f079C = new(mem_ctx) ir_if(operand(r079D).val);
                                       exec_list *const f079C_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f079C->then_instructions;

                                          body.emit(assign(r079B, r0765, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f079C->else_instructions;

                                          ir_expression *const r079E = nequal(r0765, body.constant(0u));
                                          ir_expression *const r079F = expr(ir_unop_b2i, r079E);
                                          body.emit(assign(r079B, expr(ir_unop_i2u, r079F), 0x01));


                                       body.instructions = f079C_parent_instructions;
                                       body.emit(f079C);

                                       /* END IF */

                                       body.emit(assign(r078B, r079B, 0x01));

                                       body.emit(assign(r078C, body.constant(0u), 0x01));


                                    body.instructions = f0798_parent_instructions;
                                    body.emit(f0798);

                                    /* END IF */


                                 body.instructions = f0796_parent_instructions;
                                 body.emit(f0796);

                                 /* END IF */

                                 body.emit(assign(r078D, body.constant(0u), 0x01));


                              body.instructions = f0792_parent_instructions;
                              body.emit(f0792);

                              /* END IF */

                              ir_expression *const r07A0 = nequal(r0789, body.constant(0u));
                              ir_expression *const r07A1 = expr(ir_unop_b2i, r07A0);
                              ir_expression *const r07A2 = expr(ir_unop_i2u, r07A1);
                              body.emit(assign(r078B, bit_or(r078B, r07A2), 0x01));


                           body.instructions = f0790_parent_instructions;
                           body.emit(f0790);

                           /* END IF */

                           body.emit(assign(r0765, r078D, 0x01));

                           body.emit(assign(r0766, r078C, 0x01));

                           body.emit(assign(r0767, r078B, 0x01));


                        body.instructions = f077F_parent_instructions;
                        body.emit(f077F);

                        /* END IF */

                        body.emit(assign(r0764, sub(r0764, r0768), 0x01));

                        ir_variable *const r07A3 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r07A3, r0764, 0x01));

                        ir_variable *const r07A4 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r07A4, r0765, 0x01));

                        ir_variable *const r07A5 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r07A5, r0766, 0x01));

                        ir_variable *const r07A6 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r07A6, r0767, 0x01));

                        ir_variable *const r07A7 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r07A7, body.constant(true), 0x01));

                        ir_variable *const r07A8 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r07A9 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r07A9);
                        ir_expression *const r07AA = expr(ir_unop_u2i, r0767);
                        body.emit(assign(r07A9, less(r07AA, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r07AC = lequal(body.constant(int(2045)), r0764);
                        ir_if *f07AB = new(mem_ctx) ir_if(operand(r07AC).val);
                        exec_list *const f07AB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f07AB->then_instructions;

                           ir_variable *const r07AD = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r07AF = less(body.constant(int(2045)), r0764);
                           ir_if *f07AE = new(mem_ctx) ir_if(operand(r07AF).val);
                           exec_list *const f07AE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f07AE->then_instructions;

                              body.emit(assign(r07AD, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f07AE->else_instructions;

                              ir_variable *const r07B0 = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r07B2 = equal(r0764, body.constant(int(2045)));
                              ir_if *f07B1 = new(mem_ctx) ir_if(operand(r07B2).val);
                              exec_list *const f07B1_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f07B1->then_instructions;

                                 ir_expression *const r07B3 = equal(body.constant(2097151u), r0765);
                                 ir_expression *const r07B4 = equal(body.constant(4294967295u), r0766);
                                 body.emit(assign(r07B0, logic_and(r07B3, r07B4), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f07B1->else_instructions;

                                 body.emit(assign(r07B0, body.constant(false), 0x01));


                              body.instructions = f07B1_parent_instructions;
                              body.emit(f07B1);

                              /* END IF */

                              body.emit(assign(r07AD, logic_and(r07B0, r07A9), 0x01));


                           body.instructions = f07AE_parent_instructions;
                           body.emit(f07AE);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f07B5 = new(mem_ctx) ir_if(operand(r07AD).val);
                           exec_list *const f07B5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f07B5->then_instructions;

                              ir_variable *const r07B6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r07B6);
                              ir_expression *const r07B7 = lshift(r03D3, body.constant(int(31)));
                              body.emit(assign(r07B6, add(r07B7, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r07B6, body.constant(0u), 0x01));

                              body.emit(assign(r07A8, r07B6, 0x03));

                              body.emit(assign(r07A7, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f07B5->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r07B9 = less(r0764, body.constant(int(0)));
                              ir_if *f07B8 = new(mem_ctx) ir_if(operand(r07B9).val);
                              exec_list *const f07B8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f07B8->then_instructions;

                                 ir_variable *const r07BA = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r07BA, r0767, 0x01));

                                 ir_variable *const r07BB = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r07BB, neg(r0764), 0x01));

                                 ir_variable *const r07BC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r07BC);
                                 ir_variable *const r07BD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r07BD);
                                 ir_variable *const r07BE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r07BE);
                                 ir_variable *const r07BF = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r07C0 = neg(r07BB);
                                 body.emit(assign(r07BF, bit_and(r07C0, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r07C2 = equal(r07BB, body.constant(int(0)));
                                 ir_if *f07C1 = new(mem_ctx) ir_if(operand(r07C2).val);
                                 exec_list *const f07C1_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f07C1->then_instructions;

                                    body.emit(assign(r07BC, r0767, 0x01));

                                    body.emit(assign(r07BD, r0766, 0x01));

                                    body.emit(assign(r07BE, r0765, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f07C1->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r07C4 = less(r07BB, body.constant(int(32)));
                                    ir_if *f07C3 = new(mem_ctx) ir_if(operand(r07C4).val);
                                    exec_list *const f07C3_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f07C3->then_instructions;

                                       body.emit(assign(r07BC, lshift(r0766, r07BF), 0x01));

                                       ir_expression *const r07C5 = lshift(r0765, r07BF);
                                       ir_expression *const r07C6 = rshift(r0766, r07BB);
                                       body.emit(assign(r07BD, bit_or(r07C5, r07C6), 0x01));

                                       body.emit(assign(r07BE, rshift(r0765, r07BB), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f07C3->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r07C8 = equal(r07BB, body.constant(int(32)));
                                       ir_if *f07C7 = new(mem_ctx) ir_if(operand(r07C8).val);
                                       exec_list *const f07C7_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f07C7->then_instructions;

                                          body.emit(assign(r07BC, r0766, 0x01));

                                          body.emit(assign(r07BD, r0765, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f07C7->else_instructions;

                                          body.emit(assign(r07BA, bit_or(r0767, r0766), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r07CA = less(r07BB, body.constant(int(64)));
                                          ir_if *f07C9 = new(mem_ctx) ir_if(operand(r07CA).val);
                                          exec_list *const f07C9_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f07C9->then_instructions;

                                             body.emit(assign(r07BC, lshift(r0765, r07BF), 0x01));

                                             ir_expression *const r07CB = bit_and(r07BB, body.constant(int(31)));
                                             body.emit(assign(r07BD, rshift(r0765, r07CB), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f07C9->else_instructions;

                                             ir_variable *const r07CC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r07CE = equal(r07BB, body.constant(int(64)));
                                             ir_if *f07CD = new(mem_ctx) ir_if(operand(r07CE).val);
                                             exec_list *const f07CD_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f07CD->then_instructions;

                                                body.emit(assign(r07CC, r0765, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f07CD->else_instructions;

                                                ir_expression *const r07CF = nequal(r0765, body.constant(0u));
                                                ir_expression *const r07D0 = expr(ir_unop_b2i, r07CF);
                                                body.emit(assign(r07CC, expr(ir_unop_i2u, r07D0), 0x01));


                                             body.instructions = f07CD_parent_instructions;
                                             body.emit(f07CD);

                                             /* END IF */

                                             body.emit(assign(r07BC, r07CC, 0x01));

                                             body.emit(assign(r07BD, body.constant(0u), 0x01));


                                          body.instructions = f07C9_parent_instructions;
                                          body.emit(f07C9);

                                          /* END IF */


                                       body.instructions = f07C7_parent_instructions;
                                       body.emit(f07C7);

                                       /* END IF */

                                       body.emit(assign(r07BE, body.constant(0u), 0x01));


                                    body.instructions = f07C3_parent_instructions;
                                    body.emit(f07C3);

                                    /* END IF */

                                    ir_expression *const r07D1 = nequal(r07BA, body.constant(0u));
                                    ir_expression *const r07D2 = expr(ir_unop_b2i, r07D1);
                                    ir_expression *const r07D3 = expr(ir_unop_i2u, r07D2);
                                    body.emit(assign(r07BC, bit_or(r07BC, r07D3), 0x01));


                                 body.instructions = f07C1_parent_instructions;
                                 body.emit(f07C1);

                                 /* END IF */

                                 body.emit(assign(r07A4, r07BE, 0x01));

                                 body.emit(assign(r07A5, r07BD, 0x01));

                                 body.emit(assign(r07A6, r07BC, 0x01));

                                 body.emit(assign(r07A3, body.constant(int(0)), 0x01));

                                 body.emit(assign(r07A9, less(r07BC, body.constant(0u)), 0x01));


                              body.instructions = f07B8_parent_instructions;
                              body.emit(f07B8);

                              /* END IF */


                           body.instructions = f07B5_parent_instructions;
                           body.emit(f07B5);

                           /* END IF */


                        body.instructions = f07AB_parent_instructions;
                        body.emit(f07AB);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f07D4 = new(mem_ctx) ir_if(operand(r07A7).val);
                        exec_list *const f07D4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f07D4->then_instructions;

                           /* IF CONDITION */
                           ir_if *f07D5 = new(mem_ctx) ir_if(operand(r07A9).val);
                           exec_list *const f07D5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f07D5->then_instructions;

                              ir_variable *const r07D6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r07D6, add(r07A5, body.constant(1u)), 0x01));

                              ir_expression *const r07D7 = less(r07D6, r07A5);
                              ir_expression *const r07D8 = expr(ir_unop_b2i, r07D7);
                              ir_expression *const r07D9 = expr(ir_unop_i2u, r07D8);
                              body.emit(assign(r07A4, add(r07A4, r07D9), 0x01));

                              ir_expression *const r07DA = equal(r07A6, body.constant(0u));
                              ir_expression *const r07DB = expr(ir_unop_b2i, r07DA);
                              ir_expression *const r07DC = expr(ir_unop_i2u, r07DB);
                              ir_expression *const r07DD = add(r07A6, r07DC);
                              ir_expression *const r07DE = bit_and(r07DD, body.constant(1u));
                              ir_expression *const r07DF = expr(ir_unop_bit_not, r07DE);
                              body.emit(assign(r07A5, bit_and(r07D6, r07DF), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f07D5->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r07E1 = bit_or(r07A4, r07A5);
                              ir_expression *const r07E2 = equal(r07E1, body.constant(0u));
                              ir_if *f07E0 = new(mem_ctx) ir_if(operand(r07E2).val);
                              exec_list *const f07E0_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f07E0->then_instructions;

                                 body.emit(assign(r07A3, body.constant(int(0)), 0x01));


                              body.instructions = f07E0_parent_instructions;
                              body.emit(f07E0);

                              /* END IF */


                           body.instructions = f07D5_parent_instructions;
                           body.emit(f07D5);

                           /* END IF */

                           ir_variable *const r07E3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r07E3);
                           ir_expression *const r07E4 = lshift(r03D3, body.constant(int(31)));
                           ir_expression *const r07E5 = expr(ir_unop_i2u, r07A3);
                           ir_expression *const r07E6 = lshift(r07E5, body.constant(int(20)));
                           ir_expression *const r07E7 = add(r07E4, r07E6);
                           body.emit(assign(r07E3, add(r07E7, r07A4), 0x02));

                           body.emit(assign(r07E3, r07A5, 0x01));

                           body.emit(assign(r07A8, r07E3, 0x03));

                           body.emit(assign(r07A7, body.constant(false), 0x01));


                        body.instructions = f07D4_parent_instructions;
                        body.emit(f07D4);

                        /* END IF */

                        body.emit(assign(r03D4, r07A8, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f075C->else_instructions;

                        ir_variable *const r07E8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r07E8);
                        body.emit(assign(r07E8, body.constant(0u), 0x02));

                        body.emit(assign(r07E8, body.constant(0u), 0x01));

                        body.emit(assign(r03D4, r07E8, 0x03));


                     body.instructions = f075C_parent_instructions;
                     body.emit(f075C);

                     /* END IF */


                  body.instructions = f06D0_parent_instructions;
                  body.emit(f06D0);

                  /* END IF */


               body.instructions = f0644_parent_instructions;
               body.emit(f0644);

               /* END IF */


            body.instructions = f05B8_parent_instructions;
            body.emit(f05B8);

            /* END IF */


         body.instructions = f0591_parent_instructions;
         body.emit(f0591);

         /* END IF */


      body.instructions = f04BD_parent_instructions;
      body.emit(f04BD);

      /* END IF */


   body.instructions = f03ED_parent_instructions;
   body.emit(f03ED);

   /* END IF */

   body.emit(ret(r03D4));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fadd64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r07E9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r07E9);
   ir_variable *const r07EA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r07EA);
   ir_variable *const r07EB = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r07EC = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r07EC, rshift(swizzle_y(r07E9), body.constant(int(31))), 0x01));

   ir_variable *const r07ED = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r07ED, rshift(swizzle_y(r07EA), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r07EF = equal(r07EC, r07ED);
   ir_if *f07EE = new(mem_ctx) ir_if(operand(r07EF).val);
   exec_list *const f07EE_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f07EE->then_instructions;

      ir_variable *const r07F0 = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r07F0, body.constant(true), 0x01));

      ir_variable *const r07F1 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r07F2 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r07F2);
      ir_variable *const r07F3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
      body.emit(r07F3);
      ir_variable *const r07F4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
      body.emit(r07F4);
      ir_variable *const r07F5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
      body.emit(r07F5);
      ir_variable *const r07F6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
      body.emit(r07F6);
      ir_variable *const r07F7 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r07F7);
      ir_variable *const r07F8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
      body.emit(r07F8);
      ir_variable *const r07F9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
      body.emit(r07F9);
      body.emit(assign(r07F9, body.constant(0u), 0x01));

      body.emit(assign(r07F8, body.constant(0u), 0x01));

      ir_variable *const r07FA = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
      body.emit(assign(r07FA, swizzle_x(r07E9), 0x01));

      body.emit(assign(r07F6, r07FA, 0x01));

      ir_variable *const r07FB = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
      body.emit(assign(r07FB, bit_and(swizzle_y(r07E9), body.constant(1048575u)), 0x01));

      body.emit(assign(r07F5, r07FB, 0x01));

      ir_variable *const r07FC = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
      body.emit(assign(r07FC, swizzle_x(r07EA), 0x01));

      body.emit(assign(r07F4, r07FC, 0x01));

      ir_variable *const r07FD = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
      body.emit(assign(r07FD, bit_and(swizzle_y(r07EA), body.constant(1048575u)), 0x01));

      body.emit(assign(r07F3, r07FD, 0x01));

      ir_variable *const r07FE = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r07FF = rshift(swizzle_y(r07E9), body.constant(int(20)));
      ir_expression *const r0800 = bit_and(r07FF, body.constant(2047u));
      body.emit(assign(r07FE, expr(ir_unop_u2i, r0800), 0x01));

      ir_variable *const r0801 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r0802 = rshift(swizzle_y(r07EA), body.constant(int(20)));
      ir_expression *const r0803 = bit_and(r0802, body.constant(2047u));
      body.emit(assign(r0801, expr(ir_unop_u2i, r0803), 0x01));

      ir_variable *const r0804 = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r0804, sub(r07FE, r0801), 0x01));

      body.emit(assign(r07F2, r0804, 0x01));

      /* IF CONDITION */
      ir_expression *const r0806 = less(body.constant(int(0)), r0804);
      ir_if *f0805 = new(mem_ctx) ir_if(operand(r0806).val);
      exec_list *const f0805_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0805->then_instructions;

         /* IF CONDITION */
         ir_expression *const r0808 = equal(r07FE, body.constant(int(2047)));
         ir_if *f0807 = new(mem_ctx) ir_if(operand(r0808).val);
         exec_list *const f0807_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0807->then_instructions;

            /* IF CONDITION */
            ir_expression *const r080A = bit_or(r07FB, swizzle_x(r07E9));
            ir_expression *const r080B = nequal(r080A, body.constant(0u));
            ir_if *f0809 = new(mem_ctx) ir_if(operand(r080B).val);
            exec_list *const f0809_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0809->then_instructions;

               ir_variable *const r080C = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r080C, swizzle_x(r07E9), 0x01));

               ir_variable *const r080D = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r080D, swizzle_x(r07EA), 0x01));

               ir_variable *const r080E = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r080F = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r0810 = rshift(swizzle_y(r07E9), body.constant(int(19)));
               ir_expression *const r0811 = bit_and(r0810, body.constant(4095u));
               ir_expression *const r0812 = equal(r0811, body.constant(4094u));
               ir_expression *const r0813 = nequal(swizzle_x(r07E9), body.constant(0u));
               ir_expression *const r0814 = bit_and(swizzle_y(r07E9), body.constant(524287u));
               ir_expression *const r0815 = nequal(r0814, body.constant(0u));
               ir_expression *const r0816 = logic_or(r0813, r0815);
               body.emit(assign(r080F, logic_and(r0812, r0816), 0x01));

               ir_variable *const r0817 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r0818 = lshift(swizzle_y(r07EA), body.constant(int(1)));
               ir_expression *const r0819 = lequal(body.constant(4292870144u), r0818);
               ir_expression *const r081A = nequal(swizzle_x(r07EA), body.constant(0u));
               ir_expression *const r081B = bit_and(swizzle_y(r07EA), body.constant(1048575u));
               ir_expression *const r081C = nequal(r081B, body.constant(0u));
               ir_expression *const r081D = logic_or(r081A, r081C);
               body.emit(assign(r0817, logic_and(r0819, r081D), 0x01));

               body.emit(assign(r080C, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

               body.emit(assign(r080D, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r081F = lshift(swizzle_y(r07E9), body.constant(int(1)));
               ir_expression *const r0820 = lequal(body.constant(4292870144u), r081F);
               ir_expression *const r0821 = nequal(swizzle_x(r07E9), body.constant(0u));
               ir_expression *const r0822 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
               ir_expression *const r0823 = nequal(r0822, body.constant(0u));
               ir_expression *const r0824 = logic_or(r0821, r0823);
               ir_expression *const r0825 = logic_and(r0820, r0824);
               ir_if *f081E = new(mem_ctx) ir_if(operand(r0825).val);
               exec_list *const f081E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f081E->then_instructions;

                  ir_variable *const r0826 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0828 = logic_and(r080F, r0817);
                  ir_if *f0827 = new(mem_ctx) ir_if(operand(r0828).val);
                  exec_list *const f0827_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0827->then_instructions;

                     body.emit(assign(r0826, r080D, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0827->else_instructions;

                     body.emit(assign(r0826, r080C, 0x03));


                  body.instructions = f0827_parent_instructions;
                  body.emit(f0827);

                  /* END IF */

                  body.emit(assign(r080E, r0826, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f081E->else_instructions;

                  body.emit(assign(r080E, r080D, 0x03));


               body.instructions = f081E_parent_instructions;
               body.emit(f081E);

               /* END IF */

               body.emit(assign(r07F1, r080E, 0x03));

               body.emit(assign(r07F0, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0809->else_instructions;

               body.emit(assign(r07F1, r07E9, 0x03));

               body.emit(assign(r07F0, body.constant(false), 0x01));


            body.instructions = f0809_parent_instructions;
            body.emit(f0809);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0807->else_instructions;

            /* IF CONDITION */
            ir_expression *const r082A = equal(r0801, body.constant(int(0)));
            ir_if *f0829 = new(mem_ctx) ir_if(operand(r082A).val);
            exec_list *const f0829_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0829->then_instructions;

               body.emit(assign(r07F2, add(r0804, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0829->else_instructions;

               body.emit(assign(r07F3, bit_or(r07FD, body.constant(1048576u)), 0x01));


            body.instructions = f0829_parent_instructions;
            body.emit(f0829);

            /* END IF */

            ir_variable *const r082B = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r082B, body.constant(0u), 0x01));

            ir_variable *const r082C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r082C);
            ir_variable *const r082D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r082D);
            ir_variable *const r082E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r082E);
            ir_variable *const r082F = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r0830 = neg(r07F2);
            body.emit(assign(r082F, bit_and(r0830, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0832 = equal(r07F2, body.constant(int(0)));
            ir_if *f0831 = new(mem_ctx) ir_if(operand(r0832).val);
            exec_list *const f0831_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0831->then_instructions;

               body.emit(assign(r082C, r082B, 0x01));

               body.emit(assign(r082D, r07FC, 0x01));

               body.emit(assign(r082E, r07F3, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0831->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0834 = less(r07F2, body.constant(int(32)));
               ir_if *f0833 = new(mem_ctx) ir_if(operand(r0834).val);
               exec_list *const f0833_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0833->then_instructions;

                  body.emit(assign(r082C, lshift(swizzle_x(r07EA), r082F), 0x01));

                  ir_expression *const r0835 = lshift(r07F3, r082F);
                  ir_expression *const r0836 = rshift(swizzle_x(r07EA), r07F2);
                  body.emit(assign(r082D, bit_or(r0835, r0836), 0x01));

                  body.emit(assign(r082E, rshift(r07F3, r07F2), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0833->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0838 = equal(r07F2, body.constant(int(32)));
                  ir_if *f0837 = new(mem_ctx) ir_if(operand(r0838).val);
                  exec_list *const f0837_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0837->then_instructions;

                     body.emit(assign(r082C, r07FC, 0x01));

                     body.emit(assign(r082D, r07F3, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0837->else_instructions;

                     body.emit(assign(r082B, bit_or(body.constant(0u), swizzle_x(r07EA)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r083A = less(r07F2, body.constant(int(64)));
                     ir_if *f0839 = new(mem_ctx) ir_if(operand(r083A).val);
                     exec_list *const f0839_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0839->then_instructions;

                        body.emit(assign(r082C, lshift(r07F3, r082F), 0x01));

                        ir_expression *const r083B = bit_and(r07F2, body.constant(int(31)));
                        body.emit(assign(r082D, rshift(r07F3, r083B), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0839->else_instructions;

                        ir_variable *const r083C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r083E = equal(r07F2, body.constant(int(64)));
                        ir_if *f083D = new(mem_ctx) ir_if(operand(r083E).val);
                        exec_list *const f083D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f083D->then_instructions;

                           body.emit(assign(r083C, r07F3, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f083D->else_instructions;

                           ir_expression *const r083F = nequal(r07F3, body.constant(0u));
                           ir_expression *const r0840 = expr(ir_unop_b2i, r083F);
                           body.emit(assign(r083C, expr(ir_unop_i2u, r0840), 0x01));


                        body.instructions = f083D_parent_instructions;
                        body.emit(f083D);

                        /* END IF */

                        body.emit(assign(r082C, r083C, 0x01));

                        body.emit(assign(r082D, body.constant(0u), 0x01));


                     body.instructions = f0839_parent_instructions;
                     body.emit(f0839);

                     /* END IF */


                  body.instructions = f0837_parent_instructions;
                  body.emit(f0837);

                  /* END IF */

                  body.emit(assign(r082E, body.constant(0u), 0x01));


               body.instructions = f0833_parent_instructions;
               body.emit(f0833);

               /* END IF */

               ir_expression *const r0841 = nequal(r082B, body.constant(0u));
               ir_expression *const r0842 = expr(ir_unop_b2i, r0841);
               ir_expression *const r0843 = expr(ir_unop_i2u, r0842);
               body.emit(assign(r082C, bit_or(r082C, r0843), 0x01));


            body.instructions = f0831_parent_instructions;
            body.emit(f0831);

            /* END IF */

            body.emit(assign(r07F3, r082E, 0x01));

            body.emit(assign(r07F4, r082D, 0x01));

            body.emit(assign(r07F8, r082C, 0x01));

            body.emit(assign(r07F7, r07FE, 0x01));


         body.instructions = f0807_parent_instructions;
         body.emit(f0807);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0805->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0845 = less(r07F2, body.constant(int(0)));
         ir_if *f0844 = new(mem_ctx) ir_if(operand(r0845).val);
         exec_list *const f0844_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0844->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0847 = equal(r0801, body.constant(int(2047)));
            ir_if *f0846 = new(mem_ctx) ir_if(operand(r0847).val);
            exec_list *const f0846_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0846->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0849 = bit_or(r07F3, r07F4);
               ir_expression *const r084A = nequal(r0849, body.constant(0u));
               ir_if *f0848 = new(mem_ctx) ir_if(operand(r084A).val);
               exec_list *const f0848_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0848->then_instructions;

                  ir_variable *const r084B = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r084B, swizzle_x(r07E9), 0x01));

                  ir_variable *const r084C = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r084C, swizzle_x(r07EA), 0x01));

                  ir_variable *const r084D = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r084E = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r084F = rshift(swizzle_y(r07E9), body.constant(int(19)));
                  ir_expression *const r0850 = bit_and(r084F, body.constant(4095u));
                  ir_expression *const r0851 = equal(r0850, body.constant(4094u));
                  ir_expression *const r0852 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0853 = bit_and(swizzle_y(r07E9), body.constant(524287u));
                  ir_expression *const r0854 = nequal(r0853, body.constant(0u));
                  ir_expression *const r0855 = logic_or(r0852, r0854);
                  body.emit(assign(r084E, logic_and(r0851, r0855), 0x01));

                  ir_variable *const r0856 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0857 = lshift(swizzle_y(r07EA), body.constant(int(1)));
                  ir_expression *const r0858 = lequal(body.constant(4292870144u), r0857);
                  ir_expression *const r0859 = nequal(swizzle_x(r07EA), body.constant(0u));
                  ir_expression *const r085A = bit_and(swizzle_y(r07EA), body.constant(1048575u));
                  ir_expression *const r085B = nequal(r085A, body.constant(0u));
                  ir_expression *const r085C = logic_or(r0859, r085B);
                  body.emit(assign(r0856, logic_and(r0858, r085C), 0x01));

                  body.emit(assign(r084B, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

                  body.emit(assign(r084C, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r085E = lshift(swizzle_y(r07E9), body.constant(int(1)));
                  ir_expression *const r085F = lequal(body.constant(4292870144u), r085E);
                  ir_expression *const r0860 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0861 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
                  ir_expression *const r0862 = nequal(r0861, body.constant(0u));
                  ir_expression *const r0863 = logic_or(r0860, r0862);
                  ir_expression *const r0864 = logic_and(r085F, r0863);
                  ir_if *f085D = new(mem_ctx) ir_if(operand(r0864).val);
                  exec_list *const f085D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f085D->then_instructions;

                     ir_variable *const r0865 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0867 = logic_and(r084E, r0856);
                     ir_if *f0866 = new(mem_ctx) ir_if(operand(r0867).val);
                     exec_list *const f0866_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0866->then_instructions;

                        body.emit(assign(r0865, r084C, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0866->else_instructions;

                        body.emit(assign(r0865, r084B, 0x03));


                     body.instructions = f0866_parent_instructions;
                     body.emit(f0866);

                     /* END IF */

                     body.emit(assign(r084D, r0865, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f085D->else_instructions;

                     body.emit(assign(r084D, r084C, 0x03));


                  body.instructions = f085D_parent_instructions;
                  body.emit(f085D);

                  /* END IF */

                  body.emit(assign(r07F1, r084D, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0848->else_instructions;

                  ir_variable *const r0868 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0868);
                  ir_expression *const r0869 = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r0868, add(r0869, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0868, body.constant(0u), 0x01));

                  body.emit(assign(r07F1, r0868, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


               body.instructions = f0848_parent_instructions;
               body.emit(f0848);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0846->else_instructions;

               /* IF CONDITION */
               ir_expression *const r086B = equal(r07FE, body.constant(int(0)));
               ir_if *f086A = new(mem_ctx) ir_if(operand(r086B).val);
               exec_list *const f086A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f086A->then_instructions;

                  body.emit(assign(r07F2, add(r07F2, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f086A->else_instructions;

                  body.emit(assign(r07F5, bit_or(r07FB, body.constant(1048576u)), 0x01));


               body.instructions = f086A_parent_instructions;
               body.emit(f086A);

               /* END IF */

               ir_variable *const r086C = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r086C, body.constant(0u), 0x01));

               ir_variable *const r086D = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r086D, neg(r07F2), 0x01));

               ir_variable *const r086E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r086E);
               ir_variable *const r086F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r086F);
               ir_variable *const r0870 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0870);
               ir_variable *const r0871 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0872 = neg(r086D);
               body.emit(assign(r0871, bit_and(r0872, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0874 = equal(r086D, body.constant(int(0)));
               ir_if *f0873 = new(mem_ctx) ir_if(operand(r0874).val);
               exec_list *const f0873_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0873->then_instructions;

                  body.emit(assign(r086E, r086C, 0x01));

                  body.emit(assign(r086F, r07FA, 0x01));

                  body.emit(assign(r0870, r07F5, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0873->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0876 = less(r086D, body.constant(int(32)));
                  ir_if *f0875 = new(mem_ctx) ir_if(operand(r0876).val);
                  exec_list *const f0875_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0875->then_instructions;

                     body.emit(assign(r086E, lshift(swizzle_x(r07E9), r0871), 0x01));

                     ir_expression *const r0877 = lshift(r07F5, r0871);
                     ir_expression *const r0878 = rshift(swizzle_x(r07E9), r086D);
                     body.emit(assign(r086F, bit_or(r0877, r0878), 0x01));

                     body.emit(assign(r0870, rshift(r07F5, r086D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0875->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r087A = equal(r086D, body.constant(int(32)));
                     ir_if *f0879 = new(mem_ctx) ir_if(operand(r087A).val);
                     exec_list *const f0879_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0879->then_instructions;

                        body.emit(assign(r086E, r07FA, 0x01));

                        body.emit(assign(r086F, r07F5, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0879->else_instructions;

                        body.emit(assign(r086C, bit_or(body.constant(0u), swizzle_x(r07E9)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r087C = less(r086D, body.constant(int(64)));
                        ir_if *f087B = new(mem_ctx) ir_if(operand(r087C).val);
                        exec_list *const f087B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f087B->then_instructions;

                           body.emit(assign(r086E, lshift(r07F5, r0871), 0x01));

                           ir_expression *const r087D = bit_and(r086D, body.constant(int(31)));
                           body.emit(assign(r086F, rshift(r07F5, r087D), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f087B->else_instructions;

                           ir_variable *const r087E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0880 = equal(r086D, body.constant(int(64)));
                           ir_if *f087F = new(mem_ctx) ir_if(operand(r0880).val);
                           exec_list *const f087F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f087F->then_instructions;

                              body.emit(assign(r087E, r07F5, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f087F->else_instructions;

                              ir_expression *const r0881 = nequal(r07F5, body.constant(0u));
                              ir_expression *const r0882 = expr(ir_unop_b2i, r0881);
                              body.emit(assign(r087E, expr(ir_unop_i2u, r0882), 0x01));


                           body.instructions = f087F_parent_instructions;
                           body.emit(f087F);

                           /* END IF */

                           body.emit(assign(r086E, r087E, 0x01));

                           body.emit(assign(r086F, body.constant(0u), 0x01));


                        body.instructions = f087B_parent_instructions;
                        body.emit(f087B);

                        /* END IF */


                     body.instructions = f0879_parent_instructions;
                     body.emit(f0879);

                     /* END IF */

                     body.emit(assign(r0870, body.constant(0u), 0x01));


                  body.instructions = f0875_parent_instructions;
                  body.emit(f0875);

                  /* END IF */

                  ir_expression *const r0883 = nequal(r086C, body.constant(0u));
                  ir_expression *const r0884 = expr(ir_unop_b2i, r0883);
                  ir_expression *const r0885 = expr(ir_unop_i2u, r0884);
                  body.emit(assign(r086E, bit_or(r086E, r0885), 0x01));


               body.instructions = f0873_parent_instructions;
               body.emit(f0873);

               /* END IF */

               body.emit(assign(r07F5, r0870, 0x01));

               body.emit(assign(r07F6, r086F, 0x01));

               body.emit(assign(r07F8, r086E, 0x01));

               body.emit(assign(r07F7, r0801, 0x01));


            body.instructions = f0846_parent_instructions;
            body.emit(f0846);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0844->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0887 = equal(r07FE, body.constant(int(2047)));
            ir_if *f0886 = new(mem_ctx) ir_if(operand(r0887).val);
            exec_list *const f0886_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0886->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0889 = bit_or(r07F5, r07F6);
               ir_expression *const r088A = bit_or(r07F3, r07F4);
               ir_expression *const r088B = bit_or(r0889, r088A);
               ir_expression *const r088C = nequal(r088B, body.constant(0u));
               ir_if *f0888 = new(mem_ctx) ir_if(operand(r088C).val);
               exec_list *const f0888_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0888->then_instructions;

                  ir_variable *const r088D = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r088D, swizzle_x(r07E9), 0x01));

                  ir_variable *const r088E = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r088E, swizzle_x(r07EA), 0x01));

                  ir_variable *const r088F = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0890 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0891 = rshift(swizzle_y(r07E9), body.constant(int(19)));
                  ir_expression *const r0892 = bit_and(r0891, body.constant(4095u));
                  ir_expression *const r0893 = equal(r0892, body.constant(4094u));
                  ir_expression *const r0894 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0895 = bit_and(swizzle_y(r07E9), body.constant(524287u));
                  ir_expression *const r0896 = nequal(r0895, body.constant(0u));
                  ir_expression *const r0897 = logic_or(r0894, r0896);
                  body.emit(assign(r0890, logic_and(r0893, r0897), 0x01));

                  ir_variable *const r0898 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0899 = lshift(swizzle_y(r07EA), body.constant(int(1)));
                  ir_expression *const r089A = lequal(body.constant(4292870144u), r0899);
                  ir_expression *const r089B = nequal(swizzle_x(r07EA), body.constant(0u));
                  ir_expression *const r089C = bit_and(swizzle_y(r07EA), body.constant(1048575u));
                  ir_expression *const r089D = nequal(r089C, body.constant(0u));
                  ir_expression *const r089E = logic_or(r089B, r089D);
                  body.emit(assign(r0898, logic_and(r089A, r089E), 0x01));

                  body.emit(assign(r088D, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

                  body.emit(assign(r088E, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r08A0 = lshift(swizzle_y(r07E9), body.constant(int(1)));
                  ir_expression *const r08A1 = lequal(body.constant(4292870144u), r08A0);
                  ir_expression *const r08A2 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r08A3 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
                  ir_expression *const r08A4 = nequal(r08A3, body.constant(0u));
                  ir_expression *const r08A5 = logic_or(r08A2, r08A4);
                  ir_expression *const r08A6 = logic_and(r08A1, r08A5);
                  ir_if *f089F = new(mem_ctx) ir_if(operand(r08A6).val);
                  exec_list *const f089F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f089F->then_instructions;

                     ir_variable *const r08A7 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r08A9 = logic_and(r0890, r0898);
                     ir_if *f08A8 = new(mem_ctx) ir_if(operand(r08A9).val);
                     exec_list *const f08A8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f08A8->then_instructions;

                        body.emit(assign(r08A7, r088E, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f08A8->else_instructions;

                        body.emit(assign(r08A7, r088D, 0x03));


                     body.instructions = f08A8_parent_instructions;
                     body.emit(f08A8);

                     /* END IF */

                     body.emit(assign(r088F, r08A7, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f089F->else_instructions;

                     body.emit(assign(r088F, r088E, 0x03));


                  body.instructions = f089F_parent_instructions;
                  body.emit(f089F);

                  /* END IF */

                  body.emit(assign(r07F1, r088F, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0888->else_instructions;

                  body.emit(assign(r07F1, r07E9, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


               body.instructions = f0888_parent_instructions;
               body.emit(f0888);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0886->else_instructions;

               ir_variable *const r08AA = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r08AB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r08AB, add(r07F6, r07F4), 0x01));

               ir_expression *const r08AC = add(r07F5, r07F3);
               ir_expression *const r08AD = less(r08AB, r07F6);
               ir_expression *const r08AE = expr(ir_unop_b2i, r08AD);
               ir_expression *const r08AF = expr(ir_unop_i2u, r08AE);
               body.emit(assign(r08AA, add(r08AC, r08AF), 0x01));

               body.emit(assign(r07F9, r08AA, 0x01));

               /* IF CONDITION */
               ir_expression *const r08B1 = equal(r07FE, body.constant(int(0)));
               ir_if *f08B0 = new(mem_ctx) ir_if(operand(r08B1).val);
               exec_list *const f08B0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f08B0->then_instructions;

                  ir_variable *const r08B2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r08B2);
                  ir_expression *const r08B3 = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r08B2, add(r08B3, r08AA), 0x02));

                  body.emit(assign(r08B2, r08AB, 0x01));

                  body.emit(assign(r07F1, r08B2, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f08B0->else_instructions;

                  body.emit(assign(r07F9, bit_or(r08AA, body.constant(2097152u)), 0x01));

                  body.emit(assign(r07F7, r07FE, 0x01));

                  ir_variable *const r08B4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r08B4);
                  ir_variable *const r08B5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r08B5);
                  ir_variable *const r08B6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r08B6);
                  body.emit(assign(r08B4, lshift(r08AB, body.constant(int(31))), 0x01));

                  ir_expression *const r08B7 = lshift(r07F9, body.constant(int(31)));
                  ir_expression *const r08B8 = rshift(r08AB, body.constant(int(1)));
                  body.emit(assign(r08B5, bit_or(r08B7, r08B8), 0x01));

                  body.emit(assign(r08B6, rshift(r07F9, body.constant(int(1))), 0x01));

                  body.emit(assign(r08B4, bit_or(r08B4, body.constant(0u)), 0x01));

                  body.emit(assign(r07F9, r08B6, 0x01));

                  body.emit(assign(r07F8, r08B4, 0x01));

                  ir_variable *const r08B9 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r08B9, r07FE, 0x01));

                  ir_variable *const r08BA = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r08BA, r08B6, 0x01));

                  ir_variable *const r08BB = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r08BB, r08B5, 0x01));

                  ir_variable *const r08BC = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r08BC, r08B4, 0x01));

                  ir_variable *const r08BD = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r08BD, body.constant(true), 0x01));

                  ir_variable *const r08BE = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r08BF = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r08BF);
                  ir_expression *const r08C0 = expr(ir_unop_u2i, r08B4);
                  body.emit(assign(r08BF, less(r08C0, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r08C2 = lequal(body.constant(int(2045)), r07FE);
                  ir_if *f08C1 = new(mem_ctx) ir_if(operand(r08C2).val);
                  exec_list *const f08C1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f08C1->then_instructions;

                     ir_variable *const r08C3 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r08C5 = less(body.constant(int(2045)), r07FE);
                     ir_if *f08C4 = new(mem_ctx) ir_if(operand(r08C5).val);
                     exec_list *const f08C4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f08C4->then_instructions;

                        body.emit(assign(r08C3, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f08C4->else_instructions;

                        ir_variable *const r08C6 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r08C8 = equal(r07FE, body.constant(int(2045)));
                        ir_if *f08C7 = new(mem_ctx) ir_if(operand(r08C8).val);
                        exec_list *const f08C7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f08C7->then_instructions;

                           ir_expression *const r08C9 = equal(body.constant(2097151u), r08B6);
                           ir_expression *const r08CA = equal(body.constant(4294967295u), r08B5);
                           body.emit(assign(r08C6, logic_and(r08C9, r08CA), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f08C7->else_instructions;

                           body.emit(assign(r08C6, body.constant(false), 0x01));


                        body.instructions = f08C7_parent_instructions;
                        body.emit(f08C7);

                        /* END IF */

                        body.emit(assign(r08C3, logic_and(r08C6, r08BF), 0x01));


                     body.instructions = f08C4_parent_instructions;
                     body.emit(f08C4);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f08CB = new(mem_ctx) ir_if(operand(r08C3).val);
                     exec_list *const f08CB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f08CB->then_instructions;

                        ir_variable *const r08CC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r08CC);
                        ir_expression *const r08CD = lshift(r07EC, body.constant(int(31)));
                        body.emit(assign(r08CC, add(r08CD, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r08CC, body.constant(0u), 0x01));

                        body.emit(assign(r08BE, r08CC, 0x03));

                        body.emit(assign(r08BD, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f08CB->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r08CF = less(r07FE, body.constant(int(0)));
                        ir_if *f08CE = new(mem_ctx) ir_if(operand(r08CF).val);
                        exec_list *const f08CE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f08CE->then_instructions;

                           ir_variable *const r08D0 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r08D0, r08B4, 0x01));

                           ir_variable *const r08D1 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r08D1, neg(r07FE), 0x01));

                           ir_variable *const r08D2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r08D2);
                           ir_variable *const r08D3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r08D3);
                           ir_variable *const r08D4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r08D4);
                           ir_variable *const r08D5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r08D6 = neg(r08D1);
                           body.emit(assign(r08D5, bit_and(r08D6, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r08D8 = equal(r08D1, body.constant(int(0)));
                           ir_if *f08D7 = new(mem_ctx) ir_if(operand(r08D8).val);
                           exec_list *const f08D7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f08D7->then_instructions;

                              body.emit(assign(r08D2, r08B4, 0x01));

                              body.emit(assign(r08D3, r08B5, 0x01));

                              body.emit(assign(r08D4, r08B6, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f08D7->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r08DA = less(r08D1, body.constant(int(32)));
                              ir_if *f08D9 = new(mem_ctx) ir_if(operand(r08DA).val);
                              exec_list *const f08D9_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f08D9->then_instructions;

                                 body.emit(assign(r08D2, lshift(r08B5, r08D5), 0x01));

                                 ir_expression *const r08DB = lshift(r08B6, r08D5);
                                 ir_expression *const r08DC = rshift(r08B5, r08D1);
                                 body.emit(assign(r08D3, bit_or(r08DB, r08DC), 0x01));

                                 body.emit(assign(r08D4, rshift(r08B6, r08D1), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f08D9->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r08DE = equal(r08D1, body.constant(int(32)));
                                 ir_if *f08DD = new(mem_ctx) ir_if(operand(r08DE).val);
                                 exec_list *const f08DD_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f08DD->then_instructions;

                                    body.emit(assign(r08D2, r08B5, 0x01));

                                    body.emit(assign(r08D3, r08B6, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f08DD->else_instructions;

                                    body.emit(assign(r08D0, bit_or(r08B4, r08B5), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r08E0 = less(r08D1, body.constant(int(64)));
                                    ir_if *f08DF = new(mem_ctx) ir_if(operand(r08E0).val);
                                    exec_list *const f08DF_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f08DF->then_instructions;

                                       body.emit(assign(r08D2, lshift(r08B6, r08D5), 0x01));

                                       ir_expression *const r08E1 = bit_and(r08D1, body.constant(int(31)));
                                       body.emit(assign(r08D3, rshift(r08B6, r08E1), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f08DF->else_instructions;

                                       ir_variable *const r08E2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r08E4 = equal(r08D1, body.constant(int(64)));
                                       ir_if *f08E3 = new(mem_ctx) ir_if(operand(r08E4).val);
                                       exec_list *const f08E3_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f08E3->then_instructions;

                                          body.emit(assign(r08E2, r08B6, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f08E3->else_instructions;

                                          ir_expression *const r08E5 = nequal(r08B6, body.constant(0u));
                                          ir_expression *const r08E6 = expr(ir_unop_b2i, r08E5);
                                          body.emit(assign(r08E2, expr(ir_unop_i2u, r08E6), 0x01));


                                       body.instructions = f08E3_parent_instructions;
                                       body.emit(f08E3);

                                       /* END IF */

                                       body.emit(assign(r08D2, r08E2, 0x01));

                                       body.emit(assign(r08D3, body.constant(0u), 0x01));


                                    body.instructions = f08DF_parent_instructions;
                                    body.emit(f08DF);

                                    /* END IF */


                                 body.instructions = f08DD_parent_instructions;
                                 body.emit(f08DD);

                                 /* END IF */

                                 body.emit(assign(r08D4, body.constant(0u), 0x01));


                              body.instructions = f08D9_parent_instructions;
                              body.emit(f08D9);

                              /* END IF */

                              ir_expression *const r08E7 = nequal(r08D0, body.constant(0u));
                              ir_expression *const r08E8 = expr(ir_unop_b2i, r08E7);
                              ir_expression *const r08E9 = expr(ir_unop_i2u, r08E8);
                              body.emit(assign(r08D2, bit_or(r08D2, r08E9), 0x01));


                           body.instructions = f08D7_parent_instructions;
                           body.emit(f08D7);

                           /* END IF */

                           body.emit(assign(r08BA, r08D4, 0x01));

                           body.emit(assign(r08BB, r08D3, 0x01));

                           body.emit(assign(r08BC, r08D2, 0x01));

                           body.emit(assign(r08B9, body.constant(int(0)), 0x01));

                           body.emit(assign(r08BF, less(r08D2, body.constant(0u)), 0x01));


                        body.instructions = f08CE_parent_instructions;
                        body.emit(f08CE);

                        /* END IF */


                     body.instructions = f08CB_parent_instructions;
                     body.emit(f08CB);

                     /* END IF */


                  body.instructions = f08C1_parent_instructions;
                  body.emit(f08C1);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f08EA = new(mem_ctx) ir_if(operand(r08BD).val);
                  exec_list *const f08EA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f08EA->then_instructions;

                     /* IF CONDITION */
                     ir_if *f08EB = new(mem_ctx) ir_if(operand(r08BF).val);
                     exec_list *const f08EB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f08EB->then_instructions;

                        ir_variable *const r08EC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r08EC, add(r08BB, body.constant(1u)), 0x01));

                        ir_expression *const r08ED = less(r08EC, r08BB);
                        ir_expression *const r08EE = expr(ir_unop_b2i, r08ED);
                        ir_expression *const r08EF = expr(ir_unop_i2u, r08EE);
                        body.emit(assign(r08BA, add(r08BA, r08EF), 0x01));

                        ir_expression *const r08F0 = equal(r08BC, body.constant(0u));
                        ir_expression *const r08F1 = expr(ir_unop_b2i, r08F0);
                        ir_expression *const r08F2 = expr(ir_unop_i2u, r08F1);
                        ir_expression *const r08F3 = add(r08BC, r08F2);
                        ir_expression *const r08F4 = bit_and(r08F3, body.constant(1u));
                        ir_expression *const r08F5 = expr(ir_unop_bit_not, r08F4);
                        body.emit(assign(r08BB, bit_and(r08EC, r08F5), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f08EB->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r08F7 = bit_or(r08BA, r08BB);
                        ir_expression *const r08F8 = equal(r08F7, body.constant(0u));
                        ir_if *f08F6 = new(mem_ctx) ir_if(operand(r08F8).val);
                        exec_list *const f08F6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f08F6->then_instructions;

                           body.emit(assign(r08B9, body.constant(int(0)), 0x01));


                        body.instructions = f08F6_parent_instructions;
                        body.emit(f08F6);

                        /* END IF */


                     body.instructions = f08EB_parent_instructions;
                     body.emit(f08EB);

                     /* END IF */

                     ir_variable *const r08F9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r08F9);
                     ir_expression *const r08FA = lshift(r07EC, body.constant(int(31)));
                     ir_expression *const r08FB = expr(ir_unop_i2u, r08B9);
                     ir_expression *const r08FC = lshift(r08FB, body.constant(int(20)));
                     ir_expression *const r08FD = add(r08FA, r08FC);
                     body.emit(assign(r08F9, add(r08FD, r08BA), 0x02));

                     body.emit(assign(r08F9, r08BB, 0x01));

                     body.emit(assign(r08BE, r08F9, 0x03));

                     body.emit(assign(r08BD, body.constant(false), 0x01));


                  body.instructions = f08EA_parent_instructions;
                  body.emit(f08EA);

                  /* END IF */

                  body.emit(assign(r07F1, r08BE, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


               body.instructions = f08B0_parent_instructions;
               body.emit(f08B0);

               /* END IF */


            body.instructions = f0886_parent_instructions;
            body.emit(f0886);

            /* END IF */


         body.instructions = f0844_parent_instructions;
         body.emit(f0844);

         /* END IF */


      body.instructions = f0805_parent_instructions;
      body.emit(f0805);

      /* END IF */

      /* IF CONDITION */
      ir_if *f08FE = new(mem_ctx) ir_if(operand(r07F0).val);
      exec_list *const f08FE_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f08FE->then_instructions;

         body.emit(assign(r07F5, bit_or(r07F5, body.constant(1048576u)), 0x01));

         ir_variable *const r08FF = body.make_temp(glsl_type::uint_type, "z0Ptr");
         ir_variable *const r0900 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r0900, add(r07F6, r07F4), 0x01));

         ir_expression *const r0901 = add(r07F5, r07F3);
         ir_expression *const r0902 = less(r0900, r07F6);
         ir_expression *const r0903 = expr(ir_unop_b2i, r0902);
         ir_expression *const r0904 = expr(ir_unop_i2u, r0903);
         body.emit(assign(r08FF, add(r0901, r0904), 0x01));

         body.emit(assign(r07F9, r08FF, 0x01));

         body.emit(assign(r07F7, add(r07F7, body.constant(int(-1))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0906 = less(r08FF, body.constant(2097152u));
         ir_if *f0905 = new(mem_ctx) ir_if(operand(r0906).val);
         exec_list *const f0905_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0905->then_instructions;

            ir_variable *const r0907 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0907, r07F7, 0x01));

            ir_variable *const r0908 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0908, r08FF, 0x01));

            ir_variable *const r0909 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0909, r0900, 0x01));

            ir_variable *const r090A = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r090A, r07F8, 0x01));

            ir_variable *const r090B = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r090B, body.constant(true), 0x01));

            ir_variable *const r090C = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r090D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r090D);
            ir_expression *const r090E = expr(ir_unop_u2i, r07F8);
            body.emit(assign(r090D, less(r090E, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0910 = lequal(body.constant(int(2045)), r07F7);
            ir_if *f090F = new(mem_ctx) ir_if(operand(r0910).val);
            exec_list *const f090F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f090F->then_instructions;

               ir_variable *const r0911 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0913 = less(body.constant(int(2045)), r07F7);
               ir_if *f0912 = new(mem_ctx) ir_if(operand(r0913).val);
               exec_list *const f0912_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0912->then_instructions;

                  body.emit(assign(r0911, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0912->else_instructions;

                  ir_variable *const r0914 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0916 = equal(r07F7, body.constant(int(2045)));
                  ir_if *f0915 = new(mem_ctx) ir_if(operand(r0916).val);
                  exec_list *const f0915_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0915->then_instructions;

                     ir_expression *const r0917 = equal(body.constant(2097151u), r08FF);
                     ir_expression *const r0918 = equal(body.constant(4294967295u), r0900);
                     body.emit(assign(r0914, logic_and(r0917, r0918), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0915->else_instructions;

                     body.emit(assign(r0914, body.constant(false), 0x01));


                  body.instructions = f0915_parent_instructions;
                  body.emit(f0915);

                  /* END IF */

                  body.emit(assign(r0911, logic_and(r0914, r090D), 0x01));


               body.instructions = f0912_parent_instructions;
               body.emit(f0912);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0919 = new(mem_ctx) ir_if(operand(r0911).val);
               exec_list *const f0919_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0919->then_instructions;

                  ir_variable *const r091A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r091A);
                  ir_expression *const r091B = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r091A, add(r091B, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r091A, body.constant(0u), 0x01));

                  body.emit(assign(r090C, r091A, 0x03));

                  body.emit(assign(r090B, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0919->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r091D = less(r07F7, body.constant(int(0)));
                  ir_if *f091C = new(mem_ctx) ir_if(operand(r091D).val);
                  exec_list *const f091C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f091C->then_instructions;

                     ir_variable *const r091E = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r091E, r07F8, 0x01));

                     ir_variable *const r091F = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r091F, neg(r07F7), 0x01));

                     ir_variable *const r0920 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0920);
                     ir_variable *const r0921 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0921);
                     ir_variable *const r0922 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0922);
                     ir_variable *const r0923 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0924 = neg(r091F);
                     body.emit(assign(r0923, bit_and(r0924, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0926 = equal(r091F, body.constant(int(0)));
                     ir_if *f0925 = new(mem_ctx) ir_if(operand(r0926).val);
                     exec_list *const f0925_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0925->then_instructions;

                        body.emit(assign(r0920, r07F8, 0x01));

                        body.emit(assign(r0921, r0900, 0x01));

                        body.emit(assign(r0922, r08FF, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0925->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0928 = less(r091F, body.constant(int(32)));
                        ir_if *f0927 = new(mem_ctx) ir_if(operand(r0928).val);
                        exec_list *const f0927_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0927->then_instructions;

                           body.emit(assign(r0920, lshift(r0900, r0923), 0x01));

                           ir_expression *const r0929 = lshift(r08FF, r0923);
                           ir_expression *const r092A = rshift(r0900, r091F);
                           body.emit(assign(r0921, bit_or(r0929, r092A), 0x01));

                           body.emit(assign(r0922, rshift(r08FF, r091F), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0927->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r092C = equal(r091F, body.constant(int(32)));
                           ir_if *f092B = new(mem_ctx) ir_if(operand(r092C).val);
                           exec_list *const f092B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f092B->then_instructions;

                              body.emit(assign(r0920, r0900, 0x01));

                              body.emit(assign(r0921, r08FF, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f092B->else_instructions;

                              body.emit(assign(r091E, bit_or(r07F8, r0900), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r092E = less(r091F, body.constant(int(64)));
                              ir_if *f092D = new(mem_ctx) ir_if(operand(r092E).val);
                              exec_list *const f092D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f092D->then_instructions;

                                 body.emit(assign(r0920, lshift(r08FF, r0923), 0x01));

                                 ir_expression *const r092F = bit_and(r091F, body.constant(int(31)));
                                 body.emit(assign(r0921, rshift(r08FF, r092F), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f092D->else_instructions;

                                 ir_variable *const r0930 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0932 = equal(r091F, body.constant(int(64)));
                                 ir_if *f0931 = new(mem_ctx) ir_if(operand(r0932).val);
                                 exec_list *const f0931_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0931->then_instructions;

                                    body.emit(assign(r0930, r08FF, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0931->else_instructions;

                                    ir_expression *const r0933 = nequal(r08FF, body.constant(0u));
                                    ir_expression *const r0934 = expr(ir_unop_b2i, r0933);
                                    body.emit(assign(r0930, expr(ir_unop_i2u, r0934), 0x01));


                                 body.instructions = f0931_parent_instructions;
                                 body.emit(f0931);

                                 /* END IF */

                                 body.emit(assign(r0920, r0930, 0x01));

                                 body.emit(assign(r0921, body.constant(0u), 0x01));


                              body.instructions = f092D_parent_instructions;
                              body.emit(f092D);

                              /* END IF */


                           body.instructions = f092B_parent_instructions;
                           body.emit(f092B);

                           /* END IF */

                           body.emit(assign(r0922, body.constant(0u), 0x01));


                        body.instructions = f0927_parent_instructions;
                        body.emit(f0927);

                        /* END IF */

                        ir_expression *const r0935 = nequal(r091E, body.constant(0u));
                        ir_expression *const r0936 = expr(ir_unop_b2i, r0935);
                        ir_expression *const r0937 = expr(ir_unop_i2u, r0936);
                        body.emit(assign(r0920, bit_or(r0920, r0937), 0x01));


                     body.instructions = f0925_parent_instructions;
                     body.emit(f0925);

                     /* END IF */

                     body.emit(assign(r0908, r0922, 0x01));

                     body.emit(assign(r0909, r0921, 0x01));

                     body.emit(assign(r090A, r0920, 0x01));

                     body.emit(assign(r0907, body.constant(int(0)), 0x01));

                     body.emit(assign(r090D, less(r0920, body.constant(0u)), 0x01));


                  body.instructions = f091C_parent_instructions;
                  body.emit(f091C);

                  /* END IF */


               body.instructions = f0919_parent_instructions;
               body.emit(f0919);

               /* END IF */


            body.instructions = f090F_parent_instructions;
            body.emit(f090F);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0938 = new(mem_ctx) ir_if(operand(r090B).val);
            exec_list *const f0938_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0938->then_instructions;

               /* IF CONDITION */
               ir_if *f0939 = new(mem_ctx) ir_if(operand(r090D).val);
               exec_list *const f0939_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0939->then_instructions;

                  ir_variable *const r093A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r093A, add(r0909, body.constant(1u)), 0x01));

                  ir_expression *const r093B = less(r093A, r0909);
                  ir_expression *const r093C = expr(ir_unop_b2i, r093B);
                  ir_expression *const r093D = expr(ir_unop_i2u, r093C);
                  body.emit(assign(r0908, add(r0908, r093D), 0x01));

                  ir_expression *const r093E = equal(r090A, body.constant(0u));
                  ir_expression *const r093F = expr(ir_unop_b2i, r093E);
                  ir_expression *const r0940 = expr(ir_unop_i2u, r093F);
                  ir_expression *const r0941 = add(r090A, r0940);
                  ir_expression *const r0942 = bit_and(r0941, body.constant(1u));
                  ir_expression *const r0943 = expr(ir_unop_bit_not, r0942);
                  body.emit(assign(r0909, bit_and(r093A, r0943), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0939->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0945 = bit_or(r0908, r0909);
                  ir_expression *const r0946 = equal(r0945, body.constant(0u));
                  ir_if *f0944 = new(mem_ctx) ir_if(operand(r0946).val);
                  exec_list *const f0944_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0944->then_instructions;

                     body.emit(assign(r0907, body.constant(int(0)), 0x01));


                  body.instructions = f0944_parent_instructions;
                  body.emit(f0944);

                  /* END IF */


               body.instructions = f0939_parent_instructions;
               body.emit(f0939);

               /* END IF */

               ir_variable *const r0947 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0947);
               ir_expression *const r0948 = lshift(r07EC, body.constant(int(31)));
               ir_expression *const r0949 = expr(ir_unop_i2u, r0907);
               ir_expression *const r094A = lshift(r0949, body.constant(int(20)));
               ir_expression *const r094B = add(r0948, r094A);
               body.emit(assign(r0947, add(r094B, r0908), 0x02));

               body.emit(assign(r0947, r0909, 0x01));

               body.emit(assign(r090C, r0947, 0x03));

               body.emit(assign(r090B, body.constant(false), 0x01));


            body.instructions = f0938_parent_instructions;
            body.emit(f0938);

            /* END IF */

            body.emit(assign(r07F1, r090C, 0x03));

            body.emit(assign(r07F0, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0905->else_instructions;

            body.emit(assign(r07F7, add(r07F7, body.constant(int(1))), 0x01));

            ir_variable *const r094C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r094C);
            ir_variable *const r094D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r094D);
            ir_variable *const r094E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r094E);
            body.emit(assign(r094C, lshift(r0900, body.constant(int(31))), 0x01));

            ir_expression *const r094F = lshift(r08FF, body.constant(int(31)));
            ir_expression *const r0950 = rshift(r0900, body.constant(int(1)));
            body.emit(assign(r094D, bit_or(r094F, r0950), 0x01));

            body.emit(assign(r094E, rshift(r08FF, body.constant(int(1))), 0x01));

            ir_expression *const r0951 = nequal(r07F8, body.constant(0u));
            ir_expression *const r0952 = expr(ir_unop_b2i, r0951);
            ir_expression *const r0953 = expr(ir_unop_i2u, r0952);
            body.emit(assign(r094C, bit_or(r094C, r0953), 0x01));

            body.emit(assign(r07F9, r094E, 0x01));

            body.emit(assign(r07F8, r094C, 0x01));

            ir_variable *const r0954 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0954, r07F7, 0x01));

            ir_variable *const r0955 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0955, r094E, 0x01));

            ir_variable *const r0956 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0956, r094D, 0x01));

            ir_variable *const r0957 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r0957, r094C, 0x01));

            ir_variable *const r0958 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r0958, body.constant(true), 0x01));

            ir_variable *const r0959 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r095A = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r095A);
            ir_expression *const r095B = expr(ir_unop_u2i, r094C);
            body.emit(assign(r095A, less(r095B, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r095D = lequal(body.constant(int(2045)), r07F7);
            ir_if *f095C = new(mem_ctx) ir_if(operand(r095D).val);
            exec_list *const f095C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f095C->then_instructions;

               ir_variable *const r095E = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0960 = less(body.constant(int(2045)), r07F7);
               ir_if *f095F = new(mem_ctx) ir_if(operand(r0960).val);
               exec_list *const f095F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f095F->then_instructions;

                  body.emit(assign(r095E, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f095F->else_instructions;

                  ir_variable *const r0961 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0963 = equal(r07F7, body.constant(int(2045)));
                  ir_if *f0962 = new(mem_ctx) ir_if(operand(r0963).val);
                  exec_list *const f0962_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0962->then_instructions;

                     ir_expression *const r0964 = equal(body.constant(2097151u), r094E);
                     ir_expression *const r0965 = equal(body.constant(4294967295u), r094D);
                     body.emit(assign(r0961, logic_and(r0964, r0965), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0962->else_instructions;

                     body.emit(assign(r0961, body.constant(false), 0x01));


                  body.instructions = f0962_parent_instructions;
                  body.emit(f0962);

                  /* END IF */

                  body.emit(assign(r095E, logic_and(r0961, r095A), 0x01));


               body.instructions = f095F_parent_instructions;
               body.emit(f095F);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0966 = new(mem_ctx) ir_if(operand(r095E).val);
               exec_list *const f0966_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0966->then_instructions;

                  ir_variable *const r0967 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0967);
                  ir_expression *const r0968 = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r0967, add(r0968, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0967, body.constant(0u), 0x01));

                  body.emit(assign(r0959, r0967, 0x03));

                  body.emit(assign(r0958, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0966->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r096A = less(r07F7, body.constant(int(0)));
                  ir_if *f0969 = new(mem_ctx) ir_if(operand(r096A).val);
                  exec_list *const f0969_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0969->then_instructions;

                     ir_variable *const r096B = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r096B, r094C, 0x01));

                     ir_variable *const r096C = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r096C, neg(r07F7), 0x01));

                     ir_variable *const r096D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r096D);
                     ir_variable *const r096E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r096E);
                     ir_variable *const r096F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r096F);
                     ir_variable *const r0970 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0971 = neg(r096C);
                     body.emit(assign(r0970, bit_and(r0971, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0973 = equal(r096C, body.constant(int(0)));
                     ir_if *f0972 = new(mem_ctx) ir_if(operand(r0973).val);
                     exec_list *const f0972_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0972->then_instructions;

                        body.emit(assign(r096D, r094C, 0x01));

                        body.emit(assign(r096E, r094D, 0x01));

                        body.emit(assign(r096F, r094E, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0972->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0975 = less(r096C, body.constant(int(32)));
                        ir_if *f0974 = new(mem_ctx) ir_if(operand(r0975).val);
                        exec_list *const f0974_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0974->then_instructions;

                           body.emit(assign(r096D, lshift(r094D, r0970), 0x01));

                           ir_expression *const r0976 = lshift(r094E, r0970);
                           ir_expression *const r0977 = rshift(r094D, r096C);
                           body.emit(assign(r096E, bit_or(r0976, r0977), 0x01));

                           body.emit(assign(r096F, rshift(r094E, r096C), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0974->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0979 = equal(r096C, body.constant(int(32)));
                           ir_if *f0978 = new(mem_ctx) ir_if(operand(r0979).val);
                           exec_list *const f0978_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0978->then_instructions;

                              body.emit(assign(r096D, r094D, 0x01));

                              body.emit(assign(r096E, r094E, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0978->else_instructions;

                              body.emit(assign(r096B, bit_or(r094C, r094D), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r097B = less(r096C, body.constant(int(64)));
                              ir_if *f097A = new(mem_ctx) ir_if(operand(r097B).val);
                              exec_list *const f097A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f097A->then_instructions;

                                 body.emit(assign(r096D, lshift(r094E, r0970), 0x01));

                                 ir_expression *const r097C = bit_and(r096C, body.constant(int(31)));
                                 body.emit(assign(r096E, rshift(r094E, r097C), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f097A->else_instructions;

                                 ir_variable *const r097D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r097F = equal(r096C, body.constant(int(64)));
                                 ir_if *f097E = new(mem_ctx) ir_if(operand(r097F).val);
                                 exec_list *const f097E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f097E->then_instructions;

                                    body.emit(assign(r097D, r094E, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f097E->else_instructions;

                                    ir_expression *const r0980 = nequal(r094E, body.constant(0u));
                                    ir_expression *const r0981 = expr(ir_unop_b2i, r0980);
                                    body.emit(assign(r097D, expr(ir_unop_i2u, r0981), 0x01));


                                 body.instructions = f097E_parent_instructions;
                                 body.emit(f097E);

                                 /* END IF */

                                 body.emit(assign(r096D, r097D, 0x01));

                                 body.emit(assign(r096E, body.constant(0u), 0x01));


                              body.instructions = f097A_parent_instructions;
                              body.emit(f097A);

                              /* END IF */


                           body.instructions = f0978_parent_instructions;
                           body.emit(f0978);

                           /* END IF */

                           body.emit(assign(r096F, body.constant(0u), 0x01));


                        body.instructions = f0974_parent_instructions;
                        body.emit(f0974);

                        /* END IF */

                        ir_expression *const r0982 = nequal(r096B, body.constant(0u));
                        ir_expression *const r0983 = expr(ir_unop_b2i, r0982);
                        ir_expression *const r0984 = expr(ir_unop_i2u, r0983);
                        body.emit(assign(r096D, bit_or(r096D, r0984), 0x01));


                     body.instructions = f0972_parent_instructions;
                     body.emit(f0972);

                     /* END IF */

                     body.emit(assign(r0955, r096F, 0x01));

                     body.emit(assign(r0956, r096E, 0x01));

                     body.emit(assign(r0957, r096D, 0x01));

                     body.emit(assign(r0954, body.constant(int(0)), 0x01));

                     body.emit(assign(r095A, less(r096D, body.constant(0u)), 0x01));


                  body.instructions = f0969_parent_instructions;
                  body.emit(f0969);

                  /* END IF */


               body.instructions = f0966_parent_instructions;
               body.emit(f0966);

               /* END IF */


            body.instructions = f095C_parent_instructions;
            body.emit(f095C);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0985 = new(mem_ctx) ir_if(operand(r0958).val);
            exec_list *const f0985_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0985->then_instructions;

               /* IF CONDITION */
               ir_if *f0986 = new(mem_ctx) ir_if(operand(r095A).val);
               exec_list *const f0986_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0986->then_instructions;

                  ir_variable *const r0987 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r0987, add(r0956, body.constant(1u)), 0x01));

                  ir_expression *const r0988 = less(r0987, r0956);
                  ir_expression *const r0989 = expr(ir_unop_b2i, r0988);
                  ir_expression *const r098A = expr(ir_unop_i2u, r0989);
                  body.emit(assign(r0955, add(r0955, r098A), 0x01));

                  ir_expression *const r098B = equal(r0957, body.constant(0u));
                  ir_expression *const r098C = expr(ir_unop_b2i, r098B);
                  ir_expression *const r098D = expr(ir_unop_i2u, r098C);
                  ir_expression *const r098E = add(r0957, r098D);
                  ir_expression *const r098F = bit_and(r098E, body.constant(1u));
                  ir_expression *const r0990 = expr(ir_unop_bit_not, r098F);
                  body.emit(assign(r0956, bit_and(r0987, r0990), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0986->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0992 = bit_or(r0955, r0956);
                  ir_expression *const r0993 = equal(r0992, body.constant(0u));
                  ir_if *f0991 = new(mem_ctx) ir_if(operand(r0993).val);
                  exec_list *const f0991_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0991->then_instructions;

                     body.emit(assign(r0954, body.constant(int(0)), 0x01));


                  body.instructions = f0991_parent_instructions;
                  body.emit(f0991);

                  /* END IF */


               body.instructions = f0986_parent_instructions;
               body.emit(f0986);

               /* END IF */

               ir_variable *const r0994 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0994);
               ir_expression *const r0995 = lshift(r07EC, body.constant(int(31)));
               ir_expression *const r0996 = expr(ir_unop_i2u, r0954);
               ir_expression *const r0997 = lshift(r0996, body.constant(int(20)));
               ir_expression *const r0998 = add(r0995, r0997);
               body.emit(assign(r0994, add(r0998, r0955), 0x02));

               body.emit(assign(r0994, r0956, 0x01));

               body.emit(assign(r0959, r0994, 0x03));

               body.emit(assign(r0958, body.constant(false), 0x01));


            body.instructions = f0985_parent_instructions;
            body.emit(f0985);

            /* END IF */

            body.emit(assign(r07F1, r0959, 0x03));

            body.emit(assign(r07F0, body.constant(false), 0x01));


         body.instructions = f0905_parent_instructions;
         body.emit(f0905);

         /* END IF */


      body.instructions = f08FE_parent_instructions;
      body.emit(f08FE);

      /* END IF */

      body.emit(assign(r07EB, r07F1, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f07EE->else_instructions;

      ir_variable *const r0999 = body.make_temp(glsl_type::uint_type, "zSign");
      body.emit(assign(r0999, r07EC, 0x01));

      ir_variable *const r099A = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r099B = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r099B);
      ir_variable *const r099C = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
      body.emit(r099C);
      ir_variable *const r099D = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
      body.emit(r099D);
      ir_variable *const r099E = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
      body.emit(r099E);
      ir_variable *const r099F = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
      body.emit(r099F);
      ir_variable *const r09A0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
      body.emit(r09A0);
      ir_variable *const r09A1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
      body.emit(r09A1);
      ir_variable *const r09A2 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r09A2);
      ir_variable *const r09A3 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r09A4 = rshift(swizzle_y(r07E9), body.constant(int(20)));
      ir_expression *const r09A5 = bit_and(r09A4, body.constant(2047u));
      body.emit(assign(r09A3, expr(ir_unop_u2i, r09A5), 0x01));

      body.emit(assign(r099D, r09A3, 0x01));

      ir_variable *const r09A6 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r09A7 = rshift(swizzle_y(r07EA), body.constant(int(20)));
      ir_expression *const r09A8 = bit_and(r09A7, body.constant(2047u));
      body.emit(assign(r09A6, expr(ir_unop_u2i, r09A8), 0x01));

      body.emit(assign(r099C, r09A6, 0x01));

      body.emit(assign(r099B, sub(r09A3, r09A6), 0x01));

      ir_variable *const r09A9 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r09A9, lshift(swizzle_x(r07E9), body.constant(int(10))), 0x01));

      ir_variable *const r09AA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r09AB = bit_and(swizzle_y(r07E9), body.constant(1048575u));
      ir_expression *const r09AC = lshift(r09AB, body.constant(int(10)));
      ir_expression *const r09AD = rshift(swizzle_x(r07E9), body.constant(int(22)));
      body.emit(assign(r09AA, bit_or(r09AC, r09AD), 0x01));

      body.emit(assign(r09A0, r09AA, 0x01));

      body.emit(assign(r09A1, r09A9, 0x01));

      ir_variable *const r09AE = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r09AE, lshift(swizzle_x(r07EA), body.constant(int(10))), 0x01));

      ir_variable *const r09AF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r09B0 = bit_and(swizzle_y(r07EA), body.constant(1048575u));
      ir_expression *const r09B1 = lshift(r09B0, body.constant(int(10)));
      ir_expression *const r09B2 = rshift(swizzle_x(r07EA), body.constant(int(22)));
      body.emit(assign(r09AF, bit_or(r09B1, r09B2), 0x01));

      body.emit(assign(r099E, r09AF, 0x01));

      body.emit(assign(r099F, r09AE, 0x01));

      /* IF CONDITION */
      ir_expression *const r09B4 = less(body.constant(int(0)), r099B);
      ir_if *f09B3 = new(mem_ctx) ir_if(operand(r09B4).val);
      exec_list *const f09B3_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f09B3->then_instructions;

         /* IF CONDITION */
         ir_expression *const r09B6 = equal(r09A3, body.constant(int(2047)));
         ir_if *f09B5 = new(mem_ctx) ir_if(operand(r09B6).val);
         exec_list *const f09B5_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f09B5->then_instructions;

            /* IF CONDITION */
            ir_expression *const r09B8 = bit_or(r09AA, r09A9);
            ir_expression *const r09B9 = nequal(r09B8, body.constant(0u));
            ir_if *f09B7 = new(mem_ctx) ir_if(operand(r09B9).val);
            exec_list *const f09B7_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f09B7->then_instructions;

               ir_variable *const r09BA = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r09BA, swizzle_x(r07E9), 0x01));

               ir_variable *const r09BB = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r09BB, swizzle_x(r07EA), 0x01));

               ir_variable *const r09BC = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r09BD = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r09BE = rshift(swizzle_y(r07E9), body.constant(int(19)));
               ir_expression *const r09BF = bit_and(r09BE, body.constant(4095u));
               ir_expression *const r09C0 = equal(r09BF, body.constant(4094u));
               ir_expression *const r09C1 = nequal(swizzle_x(r07E9), body.constant(0u));
               ir_expression *const r09C2 = bit_and(swizzle_y(r07E9), body.constant(524287u));
               ir_expression *const r09C3 = nequal(r09C2, body.constant(0u));
               ir_expression *const r09C4 = logic_or(r09C1, r09C3);
               body.emit(assign(r09BD, logic_and(r09C0, r09C4), 0x01));

               ir_variable *const r09C5 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r09C6 = lshift(swizzle_y(r07EA), body.constant(int(1)));
               ir_expression *const r09C7 = lequal(body.constant(4292870144u), r09C6);
               ir_expression *const r09C8 = nequal(swizzle_x(r07EA), body.constant(0u));
               ir_expression *const r09C9 = bit_and(swizzle_y(r07EA), body.constant(1048575u));
               ir_expression *const r09CA = nequal(r09C9, body.constant(0u));
               ir_expression *const r09CB = logic_or(r09C8, r09CA);
               body.emit(assign(r09C5, logic_and(r09C7, r09CB), 0x01));

               body.emit(assign(r09BA, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

               body.emit(assign(r09BB, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r09CD = lshift(swizzle_y(r07E9), body.constant(int(1)));
               ir_expression *const r09CE = lequal(body.constant(4292870144u), r09CD);
               ir_expression *const r09CF = nequal(swizzle_x(r07E9), body.constant(0u));
               ir_expression *const r09D0 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
               ir_expression *const r09D1 = nequal(r09D0, body.constant(0u));
               ir_expression *const r09D2 = logic_or(r09CF, r09D1);
               ir_expression *const r09D3 = logic_and(r09CE, r09D2);
               ir_if *f09CC = new(mem_ctx) ir_if(operand(r09D3).val);
               exec_list *const f09CC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f09CC->then_instructions;

                  ir_variable *const r09D4 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r09D6 = logic_and(r09BD, r09C5);
                  ir_if *f09D5 = new(mem_ctx) ir_if(operand(r09D6).val);
                  exec_list *const f09D5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f09D5->then_instructions;

                     body.emit(assign(r09D4, r09BB, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f09D5->else_instructions;

                     body.emit(assign(r09D4, r09BA, 0x03));


                  body.instructions = f09D5_parent_instructions;
                  body.emit(f09D5);

                  /* END IF */

                  body.emit(assign(r09BC, r09D4, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f09CC->else_instructions;

                  body.emit(assign(r09BC, r09BB, 0x03));


               body.instructions = f09CC_parent_instructions;
               body.emit(f09CC);

               /* END IF */

               body.emit(assign(r099A, r09BC, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f09B7->else_instructions;

               body.emit(assign(r099A, r07E9, 0x03));


            body.instructions = f09B7_parent_instructions;
            body.emit(f09B7);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f09B5->else_instructions;

            /* IF CONDITION */
            ir_expression *const r09D8 = equal(r09A6, body.constant(int(0)));
            ir_if *f09D7 = new(mem_ctx) ir_if(operand(r09D8).val);
            exec_list *const f09D7_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f09D7->then_instructions;

               body.emit(assign(r099B, add(r099B, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f09D7->else_instructions;

               body.emit(assign(r099E, bit_or(r09AF, body.constant(1073741824u)), 0x01));


            body.instructions = f09D7_parent_instructions;
            body.emit(f09D7);

            /* END IF */

            ir_variable *const r09D9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r09D9);
            ir_variable *const r09DA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r09DA);
            ir_variable *const r09DB = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r09DC = neg(r099B);
            body.emit(assign(r09DB, bit_and(r09DC, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r09DE = equal(r099B, body.constant(int(0)));
            ir_if *f09DD = new(mem_ctx) ir_if(operand(r09DE).val);
            exec_list *const f09DD_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f09DD->then_instructions;

               body.emit(assign(r09D9, r09AE, 0x01));

               body.emit(assign(r09DA, r099E, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f09DD->else_instructions;

               /* IF CONDITION */
               ir_expression *const r09E0 = less(r099B, body.constant(int(32)));
               ir_if *f09DF = new(mem_ctx) ir_if(operand(r09E0).val);
               exec_list *const f09DF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f09DF->then_instructions;

                  ir_expression *const r09E1 = lshift(r099E, r09DB);
                  ir_expression *const r09E2 = rshift(r09AE, r099B);
                  ir_expression *const r09E3 = bit_or(r09E1, r09E2);
                  ir_expression *const r09E4 = lshift(r09AE, r09DB);
                  ir_expression *const r09E5 = nequal(r09E4, body.constant(0u));
                  ir_expression *const r09E6 = expr(ir_unop_b2i, r09E5);
                  ir_expression *const r09E7 = expr(ir_unop_i2u, r09E6);
                  body.emit(assign(r09D9, bit_or(r09E3, r09E7), 0x01));

                  body.emit(assign(r09DA, rshift(r099E, r099B), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f09DF->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r09E9 = equal(r099B, body.constant(int(32)));
                  ir_if *f09E8 = new(mem_ctx) ir_if(operand(r09E9).val);
                  exec_list *const f09E8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f09E8->then_instructions;

                     ir_expression *const r09EA = nequal(r09AE, body.constant(0u));
                     ir_expression *const r09EB = expr(ir_unop_b2i, r09EA);
                     ir_expression *const r09EC = expr(ir_unop_i2u, r09EB);
                     body.emit(assign(r09D9, bit_or(r099E, r09EC), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f09E8->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r09EE = less(r099B, body.constant(int(64)));
                     ir_if *f09ED = new(mem_ctx) ir_if(operand(r09EE).val);
                     exec_list *const f09ED_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f09ED->then_instructions;

                        ir_expression *const r09EF = bit_and(r099B, body.constant(int(31)));
                        ir_expression *const r09F0 = rshift(r099E, r09EF);
                        ir_expression *const r09F1 = lshift(r099E, r09DB);
                        ir_expression *const r09F2 = bit_or(r09F1, r09AE);
                        ir_expression *const r09F3 = nequal(r09F2, body.constant(0u));
                        ir_expression *const r09F4 = expr(ir_unop_b2i, r09F3);
                        ir_expression *const r09F5 = expr(ir_unop_i2u, r09F4);
                        body.emit(assign(r09D9, bit_or(r09F0, r09F5), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f09ED->else_instructions;

                        ir_expression *const r09F6 = bit_or(r099E, r09AE);
                        ir_expression *const r09F7 = nequal(r09F6, body.constant(0u));
                        ir_expression *const r09F8 = expr(ir_unop_b2i, r09F7);
                        body.emit(assign(r09D9, expr(ir_unop_i2u, r09F8), 0x01));


                     body.instructions = f09ED_parent_instructions;
                     body.emit(f09ED);

                     /* END IF */


                  body.instructions = f09E8_parent_instructions;
                  body.emit(f09E8);

                  /* END IF */

                  body.emit(assign(r09DA, body.constant(0u), 0x01));


               body.instructions = f09DF_parent_instructions;
               body.emit(f09DF);

               /* END IF */


            body.instructions = f09DD_parent_instructions;
            body.emit(f09DD);

            /* END IF */

            body.emit(assign(r099E, r09DA, 0x01));

            body.emit(assign(r099F, r09D9, 0x01));

            body.emit(assign(r09A0, bit_or(r09AA, body.constant(1073741824u)), 0x01));

            ir_variable *const r09F9 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r09FA = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r09FA, sub(r09A9, r09D9), 0x01));

            ir_expression *const r09FB = sub(r09A0, r09DA);
            ir_expression *const r09FC = less(r09A9, r09D9);
            ir_expression *const r09FD = expr(ir_unop_b2i, r09FC);
            ir_expression *const r09FE = expr(ir_unop_i2u, r09FD);
            body.emit(assign(r09F9, sub(r09FB, r09FE), 0x01));

            body.emit(assign(r09A2, add(r09A3, body.constant(int(-1))), 0x01));

            ir_variable *const r09FF = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r09FF, add(r09A2, body.constant(int(-10))), 0x01));

            ir_variable *const r0A00 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0A00, r09F9, 0x01));

            ir_variable *const r0A01 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0A01, r09FA, 0x01));

            ir_variable *const r0A02 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
            body.emit(r0A02);
            ir_variable *const r0A03 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0A03);
            /* IF CONDITION */
            ir_expression *const r0A05 = equal(r09F9, body.constant(0u));
            ir_if *f0A04 = new(mem_ctx) ir_if(operand(r0A05).val);
            exec_list *const f0A04_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A04->then_instructions;

               body.emit(assign(r0A00, r09FA, 0x01));

               body.emit(assign(r0A01, body.constant(0u), 0x01));

               body.emit(assign(r09FF, add(r09FF, body.constant(int(-32))), 0x01));


            body.instructions = f0A04_parent_instructions;
            body.emit(f0A04);

            /* END IF */

            ir_variable *const r0A06 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r0A06, r0A00, 0x01));

            ir_variable *const r0A07 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r0A08 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0A08);
            /* IF CONDITION */
            ir_expression *const r0A0A = equal(r0A00, body.constant(0u));
            ir_if *f0A09 = new(mem_ctx) ir_if(operand(r0A0A).val);
            exec_list *const f0A09_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A09->then_instructions;

               body.emit(assign(r0A07, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0A09->else_instructions;

               body.emit(assign(r0A08, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r0A0C = bit_and(r0A00, body.constant(4294901760u));
               ir_expression *const r0A0D = equal(r0A0C, body.constant(0u));
               ir_if *f0A0B = new(mem_ctx) ir_if(operand(r0A0D).val);
               exec_list *const f0A0B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A0B->then_instructions;

                  body.emit(assign(r0A08, body.constant(int(16)), 0x01));

                  body.emit(assign(r0A06, lshift(r0A00, body.constant(int(16))), 0x01));


               body.instructions = f0A0B_parent_instructions;
               body.emit(f0A0B);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0A0F = bit_and(r0A06, body.constant(4278190080u));
               ir_expression *const r0A10 = equal(r0A0F, body.constant(0u));
               ir_if *f0A0E = new(mem_ctx) ir_if(operand(r0A10).val);
               exec_list *const f0A0E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A0E->then_instructions;

                  body.emit(assign(r0A08, add(r0A08, body.constant(int(8))), 0x01));

                  body.emit(assign(r0A06, lshift(r0A06, body.constant(int(8))), 0x01));


               body.instructions = f0A0E_parent_instructions;
               body.emit(f0A0E);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0A12 = bit_and(r0A06, body.constant(4026531840u));
               ir_expression *const r0A13 = equal(r0A12, body.constant(0u));
               ir_if *f0A11 = new(mem_ctx) ir_if(operand(r0A13).val);
               exec_list *const f0A11_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A11->then_instructions;

                  body.emit(assign(r0A08, add(r0A08, body.constant(int(4))), 0x01));

                  body.emit(assign(r0A06, lshift(r0A06, body.constant(int(4))), 0x01));


               body.instructions = f0A11_parent_instructions;
               body.emit(f0A11);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0A15 = bit_and(r0A06, body.constant(3221225472u));
               ir_expression *const r0A16 = equal(r0A15, body.constant(0u));
               ir_if *f0A14 = new(mem_ctx) ir_if(operand(r0A16).val);
               exec_list *const f0A14_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A14->then_instructions;

                  body.emit(assign(r0A08, add(r0A08, body.constant(int(2))), 0x01));

                  body.emit(assign(r0A06, lshift(r0A06, body.constant(int(2))), 0x01));


               body.instructions = f0A14_parent_instructions;
               body.emit(f0A14);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0A18 = bit_and(r0A06, body.constant(2147483648u));
               ir_expression *const r0A19 = equal(r0A18, body.constant(0u));
               ir_if *f0A17 = new(mem_ctx) ir_if(operand(r0A19).val);
               exec_list *const f0A17_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A17->then_instructions;

                  body.emit(assign(r0A08, add(r0A08, body.constant(int(1))), 0x01));


               body.instructions = f0A17_parent_instructions;
               body.emit(f0A17);

               /* END IF */

               body.emit(assign(r0A07, r0A08, 0x01));


            body.instructions = f0A09_parent_instructions;
            body.emit(f0A09);

            /* END IF */

            body.emit(assign(r0A03, add(r0A07, body.constant(int(-11))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0A1B = lequal(body.constant(int(0)), r0A03);
            ir_if *f0A1A = new(mem_ctx) ir_if(operand(r0A1B).val);
            exec_list *const f0A1A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A1A->then_instructions;

               body.emit(assign(r0A02, body.constant(0u), 0x01));

               ir_variable *const r0A1C = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r0A1C, lshift(r0A01, r0A03), 0x01));

               ir_variable *const r0A1D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r0A1F = equal(r0A03, body.constant(int(0)));
               ir_if *f0A1E = new(mem_ctx) ir_if(operand(r0A1F).val);
               exec_list *const f0A1E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A1E->then_instructions;

                  body.emit(assign(r0A1D, r0A00, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A1E->else_instructions;

                  ir_expression *const r0A20 = lshift(r0A00, r0A03);
                  ir_expression *const r0A21 = neg(r0A03);
                  ir_expression *const r0A22 = bit_and(r0A21, body.constant(int(31)));
                  ir_expression *const r0A23 = rshift(r0A01, r0A22);
                  body.emit(assign(r0A1D, bit_or(r0A20, r0A23), 0x01));


               body.instructions = f0A1E_parent_instructions;
               body.emit(f0A1E);

               /* END IF */

               body.emit(assign(r0A00, r0A1D, 0x01));

               body.emit(assign(r0A01, r0A1C, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0A1A->else_instructions;

               ir_variable *const r0A24 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r0A24, body.constant(0u), 0x01));

               ir_variable *const r0A25 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0A25, neg(r0A03), 0x01));

               ir_variable *const r0A26 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r0A26);
               ir_variable *const r0A27 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0A27);
               ir_variable *const r0A28 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0A28);
               ir_variable *const r0A29 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0A2A = neg(r0A25);
               body.emit(assign(r0A29, bit_and(r0A2A, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0A2C = equal(r0A25, body.constant(int(0)));
               ir_if *f0A2B = new(mem_ctx) ir_if(operand(r0A2C).val);
               exec_list *const f0A2B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A2B->then_instructions;

                  body.emit(assign(r0A26, r0A24, 0x01));

                  body.emit(assign(r0A27, r0A01, 0x01));

                  body.emit(assign(r0A28, r0A00, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A2B->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0A2E = less(r0A25, body.constant(int(32)));
                  ir_if *f0A2D = new(mem_ctx) ir_if(operand(r0A2E).val);
                  exec_list *const f0A2D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A2D->then_instructions;

                     body.emit(assign(r0A26, lshift(r0A01, r0A29), 0x01));

                     ir_expression *const r0A2F = lshift(r0A00, r0A29);
                     ir_expression *const r0A30 = rshift(r0A01, r0A25);
                     body.emit(assign(r0A27, bit_or(r0A2F, r0A30), 0x01));

                     body.emit(assign(r0A28, rshift(r0A00, r0A25), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0A2D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0A32 = equal(r0A25, body.constant(int(32)));
                     ir_if *f0A31 = new(mem_ctx) ir_if(operand(r0A32).val);
                     exec_list *const f0A31_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0A31->then_instructions;

                        body.emit(assign(r0A26, r0A01, 0x01));

                        body.emit(assign(r0A27, r0A00, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0A31->else_instructions;

                        body.emit(assign(r0A24, bit_or(body.constant(0u), r0A01), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0A34 = less(r0A25, body.constant(int(64)));
                        ir_if *f0A33 = new(mem_ctx) ir_if(operand(r0A34).val);
                        exec_list *const f0A33_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0A33->then_instructions;

                           body.emit(assign(r0A26, lshift(r0A00, r0A29), 0x01));

                           ir_expression *const r0A35 = bit_and(r0A25, body.constant(int(31)));
                           body.emit(assign(r0A27, rshift(r0A00, r0A35), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0A33->else_instructions;

                           ir_variable *const r0A36 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0A38 = equal(r0A25, body.constant(int(64)));
                           ir_if *f0A37 = new(mem_ctx) ir_if(operand(r0A38).val);
                           exec_list *const f0A37_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0A37->then_instructions;

                              body.emit(assign(r0A36, r0A00, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0A37->else_instructions;

                              ir_expression *const r0A39 = nequal(r0A00, body.constant(0u));
                              ir_expression *const r0A3A = expr(ir_unop_b2i, r0A39);
                              body.emit(assign(r0A36, expr(ir_unop_i2u, r0A3A), 0x01));


                           body.instructions = f0A37_parent_instructions;
                           body.emit(f0A37);

                           /* END IF */

                           body.emit(assign(r0A26, r0A36, 0x01));

                           body.emit(assign(r0A27, body.constant(0u), 0x01));


                        body.instructions = f0A33_parent_instructions;
                        body.emit(f0A33);

                        /* END IF */


                     body.instructions = f0A31_parent_instructions;
                     body.emit(f0A31);

                     /* END IF */

                     body.emit(assign(r0A28, body.constant(0u), 0x01));


                  body.instructions = f0A2D_parent_instructions;
                  body.emit(f0A2D);

                  /* END IF */

                  ir_expression *const r0A3B = nequal(r0A24, body.constant(0u));
                  ir_expression *const r0A3C = expr(ir_unop_b2i, r0A3B);
                  ir_expression *const r0A3D = expr(ir_unop_i2u, r0A3C);
                  body.emit(assign(r0A26, bit_or(r0A26, r0A3D), 0x01));


               body.instructions = f0A2B_parent_instructions;
               body.emit(f0A2B);

               /* END IF */

               body.emit(assign(r0A00, r0A28, 0x01));

               body.emit(assign(r0A01, r0A27, 0x01));

               body.emit(assign(r0A02, r0A26, 0x01));


            body.instructions = f0A1A_parent_instructions;
            body.emit(f0A1A);

            /* END IF */

            body.emit(assign(r09FF, sub(r09FF, r0A03), 0x01));

            ir_variable *const r0A3E = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0A3E, r09FF, 0x01));

            ir_variable *const r0A3F = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0A3F, r0A00, 0x01));

            ir_variable *const r0A40 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0A40, r0A01, 0x01));

            ir_variable *const r0A41 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r0A41, r0A02, 0x01));

            ir_variable *const r0A42 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r0A42, body.constant(true), 0x01));

            ir_variable *const r0A43 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0A44 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r0A44);
            ir_expression *const r0A45 = expr(ir_unop_u2i, r0A02);
            body.emit(assign(r0A44, less(r0A45, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0A47 = lequal(body.constant(int(2045)), r09FF);
            ir_if *f0A46 = new(mem_ctx) ir_if(operand(r0A47).val);
            exec_list *const f0A46_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A46->then_instructions;

               ir_variable *const r0A48 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0A4A = less(body.constant(int(2045)), r09FF);
               ir_if *f0A49 = new(mem_ctx) ir_if(operand(r0A4A).val);
               exec_list *const f0A49_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A49->then_instructions;

                  body.emit(assign(r0A48, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A49->else_instructions;

                  ir_variable *const r0A4B = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0A4D = equal(r09FF, body.constant(int(2045)));
                  ir_if *f0A4C = new(mem_ctx) ir_if(operand(r0A4D).val);
                  exec_list *const f0A4C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A4C->then_instructions;

                     ir_expression *const r0A4E = equal(body.constant(2097151u), r0A00);
                     ir_expression *const r0A4F = equal(body.constant(4294967295u), r0A01);
                     body.emit(assign(r0A4B, logic_and(r0A4E, r0A4F), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0A4C->else_instructions;

                     body.emit(assign(r0A4B, body.constant(false), 0x01));


                  body.instructions = f0A4C_parent_instructions;
                  body.emit(f0A4C);

                  /* END IF */

                  body.emit(assign(r0A48, logic_and(r0A4B, r0A44), 0x01));


               body.instructions = f0A49_parent_instructions;
               body.emit(f0A49);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0A50 = new(mem_ctx) ir_if(operand(r0A48).val);
               exec_list *const f0A50_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A50->then_instructions;

                  ir_variable *const r0A51 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0A51);
                  ir_expression *const r0A52 = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r0A51, add(r0A52, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0A51, body.constant(0u), 0x01));

                  body.emit(assign(r0A43, r0A51, 0x03));

                  body.emit(assign(r0A42, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A50->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0A54 = less(r09FF, body.constant(int(0)));
                  ir_if *f0A53 = new(mem_ctx) ir_if(operand(r0A54).val);
                  exec_list *const f0A53_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A53->then_instructions;

                     ir_variable *const r0A55 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0A55, r0A02, 0x01));

                     ir_variable *const r0A56 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0A56, neg(r09FF), 0x01));

                     ir_variable *const r0A57 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0A57);
                     ir_variable *const r0A58 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0A58);
                     ir_variable *const r0A59 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0A59);
                     ir_variable *const r0A5A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0A5B = neg(r0A56);
                     body.emit(assign(r0A5A, bit_and(r0A5B, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0A5D = equal(r0A56, body.constant(int(0)));
                     ir_if *f0A5C = new(mem_ctx) ir_if(operand(r0A5D).val);
                     exec_list *const f0A5C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0A5C->then_instructions;

                        body.emit(assign(r0A57, r0A02, 0x01));

                        body.emit(assign(r0A58, r0A01, 0x01));

                        body.emit(assign(r0A59, r0A00, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0A5C->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0A5F = less(r0A56, body.constant(int(32)));
                        ir_if *f0A5E = new(mem_ctx) ir_if(operand(r0A5F).val);
                        exec_list *const f0A5E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0A5E->then_instructions;

                           body.emit(assign(r0A57, lshift(r0A01, r0A5A), 0x01));

                           ir_expression *const r0A60 = lshift(r0A00, r0A5A);
                           ir_expression *const r0A61 = rshift(r0A01, r0A56);
                           body.emit(assign(r0A58, bit_or(r0A60, r0A61), 0x01));

                           body.emit(assign(r0A59, rshift(r0A00, r0A56), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0A5E->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0A63 = equal(r0A56, body.constant(int(32)));
                           ir_if *f0A62 = new(mem_ctx) ir_if(operand(r0A63).val);
                           exec_list *const f0A62_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0A62->then_instructions;

                              body.emit(assign(r0A57, r0A01, 0x01));

                              body.emit(assign(r0A58, r0A00, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0A62->else_instructions;

                              body.emit(assign(r0A55, bit_or(r0A02, r0A01), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0A65 = less(r0A56, body.constant(int(64)));
                              ir_if *f0A64 = new(mem_ctx) ir_if(operand(r0A65).val);
                              exec_list *const f0A64_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0A64->then_instructions;

                                 body.emit(assign(r0A57, lshift(r0A00, r0A5A), 0x01));

                                 ir_expression *const r0A66 = bit_and(r0A56, body.constant(int(31)));
                                 body.emit(assign(r0A58, rshift(r0A00, r0A66), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0A64->else_instructions;

                                 ir_variable *const r0A67 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0A69 = equal(r0A56, body.constant(int(64)));
                                 ir_if *f0A68 = new(mem_ctx) ir_if(operand(r0A69).val);
                                 exec_list *const f0A68_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0A68->then_instructions;

                                    body.emit(assign(r0A67, r0A00, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0A68->else_instructions;

                                    ir_expression *const r0A6A = nequal(r0A00, body.constant(0u));
                                    ir_expression *const r0A6B = expr(ir_unop_b2i, r0A6A);
                                    body.emit(assign(r0A67, expr(ir_unop_i2u, r0A6B), 0x01));


                                 body.instructions = f0A68_parent_instructions;
                                 body.emit(f0A68);

                                 /* END IF */

                                 body.emit(assign(r0A57, r0A67, 0x01));

                                 body.emit(assign(r0A58, body.constant(0u), 0x01));


                              body.instructions = f0A64_parent_instructions;
                              body.emit(f0A64);

                              /* END IF */


                           body.instructions = f0A62_parent_instructions;
                           body.emit(f0A62);

                           /* END IF */

                           body.emit(assign(r0A59, body.constant(0u), 0x01));


                        body.instructions = f0A5E_parent_instructions;
                        body.emit(f0A5E);

                        /* END IF */

                        ir_expression *const r0A6C = nequal(r0A55, body.constant(0u));
                        ir_expression *const r0A6D = expr(ir_unop_b2i, r0A6C);
                        ir_expression *const r0A6E = expr(ir_unop_i2u, r0A6D);
                        body.emit(assign(r0A57, bit_or(r0A57, r0A6E), 0x01));


                     body.instructions = f0A5C_parent_instructions;
                     body.emit(f0A5C);

                     /* END IF */

                     body.emit(assign(r0A3F, r0A59, 0x01));

                     body.emit(assign(r0A40, r0A58, 0x01));

                     body.emit(assign(r0A41, r0A57, 0x01));

                     body.emit(assign(r0A3E, body.constant(int(0)), 0x01));

                     body.emit(assign(r0A44, less(r0A57, body.constant(0u)), 0x01));


                  body.instructions = f0A53_parent_instructions;
                  body.emit(f0A53);

                  /* END IF */


               body.instructions = f0A50_parent_instructions;
               body.emit(f0A50);

               /* END IF */


            body.instructions = f0A46_parent_instructions;
            body.emit(f0A46);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0A6F = new(mem_ctx) ir_if(operand(r0A42).val);
            exec_list *const f0A6F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A6F->then_instructions;

               /* IF CONDITION */
               ir_if *f0A70 = new(mem_ctx) ir_if(operand(r0A44).val);
               exec_list *const f0A70_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A70->then_instructions;

                  ir_variable *const r0A71 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r0A71, add(r0A40, body.constant(1u)), 0x01));

                  ir_expression *const r0A72 = less(r0A71, r0A40);
                  ir_expression *const r0A73 = expr(ir_unop_b2i, r0A72);
                  ir_expression *const r0A74 = expr(ir_unop_i2u, r0A73);
                  body.emit(assign(r0A3F, add(r0A3F, r0A74), 0x01));

                  ir_expression *const r0A75 = equal(r0A41, body.constant(0u));
                  ir_expression *const r0A76 = expr(ir_unop_b2i, r0A75);
                  ir_expression *const r0A77 = expr(ir_unop_i2u, r0A76);
                  ir_expression *const r0A78 = add(r0A41, r0A77);
                  ir_expression *const r0A79 = bit_and(r0A78, body.constant(1u));
                  ir_expression *const r0A7A = expr(ir_unop_bit_not, r0A79);
                  body.emit(assign(r0A40, bit_and(r0A71, r0A7A), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A70->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0A7C = bit_or(r0A3F, r0A40);
                  ir_expression *const r0A7D = equal(r0A7C, body.constant(0u));
                  ir_if *f0A7B = new(mem_ctx) ir_if(operand(r0A7D).val);
                  exec_list *const f0A7B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A7B->then_instructions;

                     body.emit(assign(r0A3E, body.constant(int(0)), 0x01));


                  body.instructions = f0A7B_parent_instructions;
                  body.emit(f0A7B);

                  /* END IF */


               body.instructions = f0A70_parent_instructions;
               body.emit(f0A70);

               /* END IF */

               ir_variable *const r0A7E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0A7E);
               ir_expression *const r0A7F = lshift(r07EC, body.constant(int(31)));
               ir_expression *const r0A80 = expr(ir_unop_i2u, r0A3E);
               ir_expression *const r0A81 = lshift(r0A80, body.constant(int(20)));
               ir_expression *const r0A82 = add(r0A7F, r0A81);
               body.emit(assign(r0A7E, add(r0A82, r0A3F), 0x02));

               body.emit(assign(r0A7E, r0A40, 0x01));

               body.emit(assign(r0A43, r0A7E, 0x03));

               body.emit(assign(r0A42, body.constant(false), 0x01));


            body.instructions = f0A6F_parent_instructions;
            body.emit(f0A6F);

            /* END IF */

            body.emit(assign(r099A, r0A43, 0x03));


         body.instructions = f09B5_parent_instructions;
         body.emit(f09B5);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f09B3->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0A84 = less(r099B, body.constant(int(0)));
         ir_if *f0A83 = new(mem_ctx) ir_if(operand(r0A84).val);
         exec_list *const f0A83_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0A83->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0A86 = equal(r09A6, body.constant(int(2047)));
            ir_if *f0A85 = new(mem_ctx) ir_if(operand(r0A86).val);
            exec_list *const f0A85_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A85->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0A88 = bit_or(r099E, r099F);
               ir_expression *const r0A89 = nequal(r0A88, body.constant(0u));
               ir_if *f0A87 = new(mem_ctx) ir_if(operand(r0A89).val);
               exec_list *const f0A87_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A87->then_instructions;

                  ir_variable *const r0A8A = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r0A8A, swizzle_x(r07E9), 0x01));

                  ir_variable *const r0A8B = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r0A8B, swizzle_x(r07EA), 0x01));

                  ir_variable *const r0A8C = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0A8D = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0A8E = rshift(swizzle_y(r07E9), body.constant(int(19)));
                  ir_expression *const r0A8F = bit_and(r0A8E, body.constant(4095u));
                  ir_expression *const r0A90 = equal(r0A8F, body.constant(4094u));
                  ir_expression *const r0A91 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0A92 = bit_and(swizzle_y(r07E9), body.constant(524287u));
                  ir_expression *const r0A93 = nequal(r0A92, body.constant(0u));
                  ir_expression *const r0A94 = logic_or(r0A91, r0A93);
                  body.emit(assign(r0A8D, logic_and(r0A90, r0A94), 0x01));

                  ir_variable *const r0A95 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0A96 = lshift(swizzle_y(r07EA), body.constant(int(1)));
                  ir_expression *const r0A97 = lequal(body.constant(4292870144u), r0A96);
                  ir_expression *const r0A98 = nequal(swizzle_x(r07EA), body.constant(0u));
                  ir_expression *const r0A99 = bit_and(swizzle_y(r07EA), body.constant(1048575u));
                  ir_expression *const r0A9A = nequal(r0A99, body.constant(0u));
                  ir_expression *const r0A9B = logic_or(r0A98, r0A9A);
                  body.emit(assign(r0A95, logic_and(r0A97, r0A9B), 0x01));

                  body.emit(assign(r0A8A, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

                  body.emit(assign(r0A8B, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r0A9D = lshift(swizzle_y(r07E9), body.constant(int(1)));
                  ir_expression *const r0A9E = lequal(body.constant(4292870144u), r0A9D);
                  ir_expression *const r0A9F = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0AA0 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
                  ir_expression *const r0AA1 = nequal(r0AA0, body.constant(0u));
                  ir_expression *const r0AA2 = logic_or(r0A9F, r0AA1);
                  ir_expression *const r0AA3 = logic_and(r0A9E, r0AA2);
                  ir_if *f0A9C = new(mem_ctx) ir_if(operand(r0AA3).val);
                  exec_list *const f0A9C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A9C->then_instructions;

                     ir_variable *const r0AA4 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0AA6 = logic_and(r0A8D, r0A95);
                     ir_if *f0AA5 = new(mem_ctx) ir_if(operand(r0AA6).val);
                     exec_list *const f0AA5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0AA5->then_instructions;

                        body.emit(assign(r0AA4, r0A8B, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0AA5->else_instructions;

                        body.emit(assign(r0AA4, r0A8A, 0x03));


                     body.instructions = f0AA5_parent_instructions;
                     body.emit(f0AA5);

                     /* END IF */

                     body.emit(assign(r0A8C, r0AA4, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0A9C->else_instructions;

                     body.emit(assign(r0A8C, r0A8B, 0x03));


                  body.instructions = f0A9C_parent_instructions;
                  body.emit(f0A9C);

                  /* END IF */

                  body.emit(assign(r099A, r0A8C, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A87->else_instructions;

                  ir_variable *const r0AA7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0AA7);
                  ir_expression *const r0AA8 = bit_xor(r07EC, body.constant(1u));
                  ir_expression *const r0AA9 = lshift(r0AA8, body.constant(int(31)));
                  body.emit(assign(r0AA7, add(r0AA9, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0AA7, body.constant(0u), 0x01));

                  body.emit(assign(r099A, r0AA7, 0x03));


               body.instructions = f0A87_parent_instructions;
               body.emit(f0A87);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0A85->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0AAB = equal(r09A3, body.constant(int(0)));
               ir_if *f0AAA = new(mem_ctx) ir_if(operand(r0AAB).val);
               exec_list *const f0AAA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0AAA->then_instructions;

                  body.emit(assign(r099B, add(r099B, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0AAA->else_instructions;

                  body.emit(assign(r09A0, bit_or(r09A0, body.constant(1073741824u)), 0x01));


               body.instructions = f0AAA_parent_instructions;
               body.emit(f0AAA);

               /* END IF */

               ir_variable *const r0AAC = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0AAC, neg(r099B), 0x01));

               ir_variable *const r0AAD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0AAD);
               ir_variable *const r0AAE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0AAE);
               ir_variable *const r0AAF = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0AB0 = neg(r0AAC);
               body.emit(assign(r0AAF, bit_and(r0AB0, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0AB2 = equal(r0AAC, body.constant(int(0)));
               ir_if *f0AB1 = new(mem_ctx) ir_if(operand(r0AB2).val);
               exec_list *const f0AB1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0AB1->then_instructions;

                  body.emit(assign(r0AAD, r09A9, 0x01));

                  body.emit(assign(r0AAE, r09A0, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0AB1->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0AB4 = less(r0AAC, body.constant(int(32)));
                  ir_if *f0AB3 = new(mem_ctx) ir_if(operand(r0AB4).val);
                  exec_list *const f0AB3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AB3->then_instructions;

                     ir_expression *const r0AB5 = lshift(r09A0, r0AAF);
                     ir_expression *const r0AB6 = rshift(r09A9, r0AAC);
                     ir_expression *const r0AB7 = bit_or(r0AB5, r0AB6);
                     ir_expression *const r0AB8 = lshift(r09A9, r0AAF);
                     ir_expression *const r0AB9 = nequal(r0AB8, body.constant(0u));
                     ir_expression *const r0ABA = expr(ir_unop_b2i, r0AB9);
                     ir_expression *const r0ABB = expr(ir_unop_i2u, r0ABA);
                     body.emit(assign(r0AAD, bit_or(r0AB7, r0ABB), 0x01));

                     body.emit(assign(r0AAE, rshift(r09A0, r0AAC), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0AB3->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0ABD = equal(r0AAC, body.constant(int(32)));
                     ir_if *f0ABC = new(mem_ctx) ir_if(operand(r0ABD).val);
                     exec_list *const f0ABC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0ABC->then_instructions;

                        ir_expression *const r0ABE = nequal(r09A9, body.constant(0u));
                        ir_expression *const r0ABF = expr(ir_unop_b2i, r0ABE);
                        ir_expression *const r0AC0 = expr(ir_unop_i2u, r0ABF);
                        body.emit(assign(r0AAD, bit_or(r09A0, r0AC0), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0ABC->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0AC2 = less(r0AAC, body.constant(int(64)));
                        ir_if *f0AC1 = new(mem_ctx) ir_if(operand(r0AC2).val);
                        exec_list *const f0AC1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0AC1->then_instructions;

                           ir_expression *const r0AC3 = bit_and(r0AAC, body.constant(int(31)));
                           ir_expression *const r0AC4 = rshift(r09A0, r0AC3);
                           ir_expression *const r0AC5 = lshift(r09A0, r0AAF);
                           ir_expression *const r0AC6 = bit_or(r0AC5, r09A9);
                           ir_expression *const r0AC7 = nequal(r0AC6, body.constant(0u));
                           ir_expression *const r0AC8 = expr(ir_unop_b2i, r0AC7);
                           ir_expression *const r0AC9 = expr(ir_unop_i2u, r0AC8);
                           body.emit(assign(r0AAD, bit_or(r0AC4, r0AC9), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0AC1->else_instructions;

                           ir_expression *const r0ACA = bit_or(r09A0, r09A9);
                           ir_expression *const r0ACB = nequal(r0ACA, body.constant(0u));
                           ir_expression *const r0ACC = expr(ir_unop_b2i, r0ACB);
                           body.emit(assign(r0AAD, expr(ir_unop_i2u, r0ACC), 0x01));


                        body.instructions = f0AC1_parent_instructions;
                        body.emit(f0AC1);

                        /* END IF */


                     body.instructions = f0ABC_parent_instructions;
                     body.emit(f0ABC);

                     /* END IF */

                     body.emit(assign(r0AAE, body.constant(0u), 0x01));


                  body.instructions = f0AB3_parent_instructions;
                  body.emit(f0AB3);

                  /* END IF */


               body.instructions = f0AB1_parent_instructions;
               body.emit(f0AB1);

               /* END IF */

               body.emit(assign(r09A0, r0AAE, 0x01));

               body.emit(assign(r09A1, r0AAD, 0x01));

               body.emit(assign(r099E, bit_or(r099E, body.constant(1073741824u)), 0x01));

               ir_variable *const r0ACD = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r0ACE = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r0ACE, sub(r099F, r0AAD), 0x01));

               ir_expression *const r0ACF = sub(r099E, r0AAE);
               ir_expression *const r0AD0 = less(r099F, r0AAD);
               ir_expression *const r0AD1 = expr(ir_unop_b2i, r0AD0);
               ir_expression *const r0AD2 = expr(ir_unop_i2u, r0AD1);
               body.emit(assign(r0ACD, sub(r0ACF, r0AD2), 0x01));

               body.emit(assign(r0999, bit_xor(r07EC, body.constant(1u)), 0x01));

               body.emit(assign(r09A2, add(r09A6, body.constant(int(-1))), 0x01));

               ir_variable *const r0AD3 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r0AD3, add(r09A2, body.constant(int(-10))), 0x01));

               ir_variable *const r0AD4 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0AD4, r0ACD, 0x01));

               ir_variable *const r0AD5 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0AD5, r0ACE, 0x01));

               ir_variable *const r0AD6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r0AD6);
               ir_variable *const r0AD7 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r0AD7);
               /* IF CONDITION */
               ir_expression *const r0AD9 = equal(r0ACD, body.constant(0u));
               ir_if *f0AD8 = new(mem_ctx) ir_if(operand(r0AD9).val);
               exec_list *const f0AD8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0AD8->then_instructions;

                  body.emit(assign(r0AD4, r0ACE, 0x01));

                  body.emit(assign(r0AD5, body.constant(0u), 0x01));

                  body.emit(assign(r0AD3, add(r0AD3, body.constant(int(-32))), 0x01));


               body.instructions = f0AD8_parent_instructions;
               body.emit(f0AD8);

               /* END IF */

               ir_variable *const r0ADA = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r0ADA, r0AD4, 0x01));

               ir_variable *const r0ADB = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r0ADC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r0ADC);
               /* IF CONDITION */
               ir_expression *const r0ADE = equal(r0AD4, body.constant(0u));
               ir_if *f0ADD = new(mem_ctx) ir_if(operand(r0ADE).val);
               exec_list *const f0ADD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0ADD->then_instructions;

                  body.emit(assign(r0ADB, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0ADD->else_instructions;

                  body.emit(assign(r0ADC, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0AE0 = bit_and(r0AD4, body.constant(4294901760u));
                  ir_expression *const r0AE1 = equal(r0AE0, body.constant(0u));
                  ir_if *f0ADF = new(mem_ctx) ir_if(operand(r0AE1).val);
                  exec_list *const f0ADF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0ADF->then_instructions;

                     body.emit(assign(r0ADC, body.constant(int(16)), 0x01));

                     body.emit(assign(r0ADA, lshift(r0AD4, body.constant(int(16))), 0x01));


                  body.instructions = f0ADF_parent_instructions;
                  body.emit(f0ADF);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0AE3 = bit_and(r0ADA, body.constant(4278190080u));
                  ir_expression *const r0AE4 = equal(r0AE3, body.constant(0u));
                  ir_if *f0AE2 = new(mem_ctx) ir_if(operand(r0AE4).val);
                  exec_list *const f0AE2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AE2->then_instructions;

                     body.emit(assign(r0ADC, add(r0ADC, body.constant(int(8))), 0x01));

                     body.emit(assign(r0ADA, lshift(r0ADA, body.constant(int(8))), 0x01));


                  body.instructions = f0AE2_parent_instructions;
                  body.emit(f0AE2);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0AE6 = bit_and(r0ADA, body.constant(4026531840u));
                  ir_expression *const r0AE7 = equal(r0AE6, body.constant(0u));
                  ir_if *f0AE5 = new(mem_ctx) ir_if(operand(r0AE7).val);
                  exec_list *const f0AE5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AE5->then_instructions;

                     body.emit(assign(r0ADC, add(r0ADC, body.constant(int(4))), 0x01));

                     body.emit(assign(r0ADA, lshift(r0ADA, body.constant(int(4))), 0x01));


                  body.instructions = f0AE5_parent_instructions;
                  body.emit(f0AE5);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0AE9 = bit_and(r0ADA, body.constant(3221225472u));
                  ir_expression *const r0AEA = equal(r0AE9, body.constant(0u));
                  ir_if *f0AE8 = new(mem_ctx) ir_if(operand(r0AEA).val);
                  exec_list *const f0AE8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AE8->then_instructions;

                     body.emit(assign(r0ADC, add(r0ADC, body.constant(int(2))), 0x01));

                     body.emit(assign(r0ADA, lshift(r0ADA, body.constant(int(2))), 0x01));


                  body.instructions = f0AE8_parent_instructions;
                  body.emit(f0AE8);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0AEC = bit_and(r0ADA, body.constant(2147483648u));
                  ir_expression *const r0AED = equal(r0AEC, body.constant(0u));
                  ir_if *f0AEB = new(mem_ctx) ir_if(operand(r0AED).val);
                  exec_list *const f0AEB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AEB->then_instructions;

                     body.emit(assign(r0ADC, add(r0ADC, body.constant(int(1))), 0x01));


                  body.instructions = f0AEB_parent_instructions;
                  body.emit(f0AEB);

                  /* END IF */

                  body.emit(assign(r0ADB, r0ADC, 0x01));


               body.instructions = f0ADD_parent_instructions;
               body.emit(f0ADD);

               /* END IF */

               body.emit(assign(r0AD7, add(r0ADB, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0AEF = lequal(body.constant(int(0)), r0AD7);
               ir_if *f0AEE = new(mem_ctx) ir_if(operand(r0AEF).val);
               exec_list *const f0AEE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0AEE->then_instructions;

                  body.emit(assign(r0AD6, body.constant(0u), 0x01));

                  ir_variable *const r0AF0 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0AF0, lshift(r0AD5, r0AD7), 0x01));

                  ir_variable *const r0AF1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0AF3 = equal(r0AD7, body.constant(int(0)));
                  ir_if *f0AF2 = new(mem_ctx) ir_if(operand(r0AF3).val);
                  exec_list *const f0AF2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AF2->then_instructions;

                     body.emit(assign(r0AF1, r0AD4, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0AF2->else_instructions;

                     ir_expression *const r0AF4 = lshift(r0AD4, r0AD7);
                     ir_expression *const r0AF5 = neg(r0AD7);
                     ir_expression *const r0AF6 = bit_and(r0AF5, body.constant(int(31)));
                     ir_expression *const r0AF7 = rshift(r0AD5, r0AF6);
                     body.emit(assign(r0AF1, bit_or(r0AF4, r0AF7), 0x01));


                  body.instructions = f0AF2_parent_instructions;
                  body.emit(f0AF2);

                  /* END IF */

                  body.emit(assign(r0AD4, r0AF1, 0x01));

                  body.emit(assign(r0AD5, r0AF0, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0AEE->else_instructions;

                  ir_variable *const r0AF8 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r0AF8, body.constant(0u), 0x01));

                  ir_variable *const r0AF9 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r0AF9, neg(r0AD7), 0x01));

                  ir_variable *const r0AFA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r0AFA);
                  ir_variable *const r0AFB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r0AFB);
                  ir_variable *const r0AFC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r0AFC);
                  ir_variable *const r0AFD = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r0AFE = neg(r0AF9);
                  body.emit(assign(r0AFD, bit_and(r0AFE, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0B00 = equal(r0AF9, body.constant(int(0)));
                  ir_if *f0AFF = new(mem_ctx) ir_if(operand(r0B00).val);
                  exec_list *const f0AFF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AFF->then_instructions;

                     body.emit(assign(r0AFA, r0AF8, 0x01));

                     body.emit(assign(r0AFB, r0AD5, 0x01));

                     body.emit(assign(r0AFC, r0AD4, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0AFF->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0B02 = less(r0AF9, body.constant(int(32)));
                     ir_if *f0B01 = new(mem_ctx) ir_if(operand(r0B02).val);
                     exec_list *const f0B01_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B01->then_instructions;

                        body.emit(assign(r0AFA, lshift(r0AD5, r0AFD), 0x01));

                        ir_expression *const r0B03 = lshift(r0AD4, r0AFD);
                        ir_expression *const r0B04 = rshift(r0AD5, r0AF9);
                        body.emit(assign(r0AFB, bit_or(r0B03, r0B04), 0x01));

                        body.emit(assign(r0AFC, rshift(r0AD4, r0AF9), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0B01->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0B06 = equal(r0AF9, body.constant(int(32)));
                        ir_if *f0B05 = new(mem_ctx) ir_if(operand(r0B06).val);
                        exec_list *const f0B05_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0B05->then_instructions;

                           body.emit(assign(r0AFA, r0AD5, 0x01));

                           body.emit(assign(r0AFB, r0AD4, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0B05->else_instructions;

                           body.emit(assign(r0AF8, bit_or(body.constant(0u), r0AD5), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0B08 = less(r0AF9, body.constant(int(64)));
                           ir_if *f0B07 = new(mem_ctx) ir_if(operand(r0B08).val);
                           exec_list *const f0B07_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0B07->then_instructions;

                              body.emit(assign(r0AFA, lshift(r0AD4, r0AFD), 0x01));

                              ir_expression *const r0B09 = bit_and(r0AF9, body.constant(int(31)));
                              body.emit(assign(r0AFB, rshift(r0AD4, r0B09), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0B07->else_instructions;

                              ir_variable *const r0B0A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0B0C = equal(r0AF9, body.constant(int(64)));
                              ir_if *f0B0B = new(mem_ctx) ir_if(operand(r0B0C).val);
                              exec_list *const f0B0B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0B0B->then_instructions;

                                 body.emit(assign(r0B0A, r0AD4, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0B0B->else_instructions;

                                 ir_expression *const r0B0D = nequal(r0AD4, body.constant(0u));
                                 ir_expression *const r0B0E = expr(ir_unop_b2i, r0B0D);
                                 body.emit(assign(r0B0A, expr(ir_unop_i2u, r0B0E), 0x01));


                              body.instructions = f0B0B_parent_instructions;
                              body.emit(f0B0B);

                              /* END IF */

                              body.emit(assign(r0AFA, r0B0A, 0x01));

                              body.emit(assign(r0AFB, body.constant(0u), 0x01));


                           body.instructions = f0B07_parent_instructions;
                           body.emit(f0B07);

                           /* END IF */


                        body.instructions = f0B05_parent_instructions;
                        body.emit(f0B05);

                        /* END IF */

                        body.emit(assign(r0AFC, body.constant(0u), 0x01));


                     body.instructions = f0B01_parent_instructions;
                     body.emit(f0B01);

                     /* END IF */

                     ir_expression *const r0B0F = nequal(r0AF8, body.constant(0u));
                     ir_expression *const r0B10 = expr(ir_unop_b2i, r0B0F);
                     ir_expression *const r0B11 = expr(ir_unop_i2u, r0B10);
                     body.emit(assign(r0AFA, bit_or(r0AFA, r0B11), 0x01));


                  body.instructions = f0AFF_parent_instructions;
                  body.emit(f0AFF);

                  /* END IF */

                  body.emit(assign(r0AD4, r0AFC, 0x01));

                  body.emit(assign(r0AD5, r0AFB, 0x01));

                  body.emit(assign(r0AD6, r0AFA, 0x01));


               body.instructions = f0AEE_parent_instructions;
               body.emit(f0AEE);

               /* END IF */

               body.emit(assign(r0AD3, sub(r0AD3, r0AD7), 0x01));

               ir_variable *const r0B12 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r0B12, r0AD3, 0x01));

               ir_variable *const r0B13 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0B13, r0AD4, 0x01));

               ir_variable *const r0B14 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0B14, r0AD5, 0x01));

               ir_variable *const r0B15 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r0B15, r0AD6, 0x01));

               ir_variable *const r0B16 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r0B16, body.constant(true), 0x01));

               ir_variable *const r0B17 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0B18 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r0B18);
               ir_expression *const r0B19 = expr(ir_unop_u2i, r0AD6);
               body.emit(assign(r0B18, less(r0B19, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0B1B = lequal(body.constant(int(2045)), r0AD3);
               ir_if *f0B1A = new(mem_ctx) ir_if(operand(r0B1B).val);
               exec_list *const f0B1A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B1A->then_instructions;

                  ir_variable *const r0B1C = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0B1E = less(body.constant(int(2045)), r0AD3);
                  ir_if *f0B1D = new(mem_ctx) ir_if(operand(r0B1E).val);
                  exec_list *const f0B1D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B1D->then_instructions;

                     body.emit(assign(r0B1C, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B1D->else_instructions;

                     ir_variable *const r0B1F = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0B21 = equal(r0AD3, body.constant(int(2045)));
                     ir_if *f0B20 = new(mem_ctx) ir_if(operand(r0B21).val);
                     exec_list *const f0B20_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B20->then_instructions;

                        ir_expression *const r0B22 = equal(body.constant(2097151u), r0AD4);
                        ir_expression *const r0B23 = equal(body.constant(4294967295u), r0AD5);
                        body.emit(assign(r0B1F, logic_and(r0B22, r0B23), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0B20->else_instructions;

                        body.emit(assign(r0B1F, body.constant(false), 0x01));


                     body.instructions = f0B20_parent_instructions;
                     body.emit(f0B20);

                     /* END IF */

                     body.emit(assign(r0B1C, logic_and(r0B1F, r0B18), 0x01));


                  body.instructions = f0B1D_parent_instructions;
                  body.emit(f0B1D);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0B24 = new(mem_ctx) ir_if(operand(r0B1C).val);
                  exec_list *const f0B24_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B24->then_instructions;

                     ir_variable *const r0B25 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0B25);
                     ir_expression *const r0B26 = lshift(r0999, body.constant(int(31)));
                     body.emit(assign(r0B25, add(r0B26, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r0B25, body.constant(0u), 0x01));

                     body.emit(assign(r0B17, r0B25, 0x03));

                     body.emit(assign(r0B16, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B24->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0B28 = less(r0AD3, body.constant(int(0)));
                     ir_if *f0B27 = new(mem_ctx) ir_if(operand(r0B28).val);
                     exec_list *const f0B27_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B27->then_instructions;

                        ir_variable *const r0B29 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0B29, r0AD6, 0x01));

                        ir_variable *const r0B2A = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0B2A, neg(r0AD3), 0x01));

                        ir_variable *const r0B2B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0B2B);
                        ir_variable *const r0B2C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0B2C);
                        ir_variable *const r0B2D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0B2D);
                        ir_variable *const r0B2E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r0B2F = neg(r0B2A);
                        body.emit(assign(r0B2E, bit_and(r0B2F, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0B31 = equal(r0B2A, body.constant(int(0)));
                        ir_if *f0B30 = new(mem_ctx) ir_if(operand(r0B31).val);
                        exec_list *const f0B30_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0B30->then_instructions;

                           body.emit(assign(r0B2B, r0AD6, 0x01));

                           body.emit(assign(r0B2C, r0AD5, 0x01));

                           body.emit(assign(r0B2D, r0AD4, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0B30->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0B33 = less(r0B2A, body.constant(int(32)));
                           ir_if *f0B32 = new(mem_ctx) ir_if(operand(r0B33).val);
                           exec_list *const f0B32_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0B32->then_instructions;

                              body.emit(assign(r0B2B, lshift(r0AD5, r0B2E), 0x01));

                              ir_expression *const r0B34 = lshift(r0AD4, r0B2E);
                              ir_expression *const r0B35 = rshift(r0AD5, r0B2A);
                              body.emit(assign(r0B2C, bit_or(r0B34, r0B35), 0x01));

                              body.emit(assign(r0B2D, rshift(r0AD4, r0B2A), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0B32->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0B37 = equal(r0B2A, body.constant(int(32)));
                              ir_if *f0B36 = new(mem_ctx) ir_if(operand(r0B37).val);
                              exec_list *const f0B36_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0B36->then_instructions;

                                 body.emit(assign(r0B2B, r0AD5, 0x01));

                                 body.emit(assign(r0B2C, r0AD4, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0B36->else_instructions;

                                 body.emit(assign(r0B29, bit_or(r0AD6, r0AD5), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0B39 = less(r0B2A, body.constant(int(64)));
                                 ir_if *f0B38 = new(mem_ctx) ir_if(operand(r0B39).val);
                                 exec_list *const f0B38_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0B38->then_instructions;

                                    body.emit(assign(r0B2B, lshift(r0AD4, r0B2E), 0x01));

                                    ir_expression *const r0B3A = bit_and(r0B2A, body.constant(int(31)));
                                    body.emit(assign(r0B2C, rshift(r0AD4, r0B3A), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0B38->else_instructions;

                                    ir_variable *const r0B3B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r0B3D = equal(r0B2A, body.constant(int(64)));
                                    ir_if *f0B3C = new(mem_ctx) ir_if(operand(r0B3D).val);
                                    exec_list *const f0B3C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0B3C->then_instructions;

                                       body.emit(assign(r0B3B, r0AD4, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0B3C->else_instructions;

                                       ir_expression *const r0B3E = nequal(r0AD4, body.constant(0u));
                                       ir_expression *const r0B3F = expr(ir_unop_b2i, r0B3E);
                                       body.emit(assign(r0B3B, expr(ir_unop_i2u, r0B3F), 0x01));


                                    body.instructions = f0B3C_parent_instructions;
                                    body.emit(f0B3C);

                                    /* END IF */

                                    body.emit(assign(r0B2B, r0B3B, 0x01));

                                    body.emit(assign(r0B2C, body.constant(0u), 0x01));


                                 body.instructions = f0B38_parent_instructions;
                                 body.emit(f0B38);

                                 /* END IF */


                              body.instructions = f0B36_parent_instructions;
                              body.emit(f0B36);

                              /* END IF */

                              body.emit(assign(r0B2D, body.constant(0u), 0x01));


                           body.instructions = f0B32_parent_instructions;
                           body.emit(f0B32);

                           /* END IF */

                           ir_expression *const r0B40 = nequal(r0B29, body.constant(0u));
                           ir_expression *const r0B41 = expr(ir_unop_b2i, r0B40);
                           ir_expression *const r0B42 = expr(ir_unop_i2u, r0B41);
                           body.emit(assign(r0B2B, bit_or(r0B2B, r0B42), 0x01));


                        body.instructions = f0B30_parent_instructions;
                        body.emit(f0B30);

                        /* END IF */

                        body.emit(assign(r0B13, r0B2D, 0x01));

                        body.emit(assign(r0B14, r0B2C, 0x01));

                        body.emit(assign(r0B15, r0B2B, 0x01));

                        body.emit(assign(r0B12, body.constant(int(0)), 0x01));

                        body.emit(assign(r0B18, less(r0B2B, body.constant(0u)), 0x01));


                     body.instructions = f0B27_parent_instructions;
                     body.emit(f0B27);

                     /* END IF */


                  body.instructions = f0B24_parent_instructions;
                  body.emit(f0B24);

                  /* END IF */


               body.instructions = f0B1A_parent_instructions;
               body.emit(f0B1A);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0B43 = new(mem_ctx) ir_if(operand(r0B16).val);
               exec_list *const f0B43_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B43->then_instructions;

                  /* IF CONDITION */
                  ir_if *f0B44 = new(mem_ctx) ir_if(operand(r0B18).val);
                  exec_list *const f0B44_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B44->then_instructions;

                     ir_variable *const r0B45 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r0B45, add(r0B14, body.constant(1u)), 0x01));

                     ir_expression *const r0B46 = less(r0B45, r0B14);
                     ir_expression *const r0B47 = expr(ir_unop_b2i, r0B46);
                     ir_expression *const r0B48 = expr(ir_unop_i2u, r0B47);
                     body.emit(assign(r0B13, add(r0B13, r0B48), 0x01));

                     ir_expression *const r0B49 = equal(r0B15, body.constant(0u));
                     ir_expression *const r0B4A = expr(ir_unop_b2i, r0B49);
                     ir_expression *const r0B4B = expr(ir_unop_i2u, r0B4A);
                     ir_expression *const r0B4C = add(r0B15, r0B4B);
                     ir_expression *const r0B4D = bit_and(r0B4C, body.constant(1u));
                     ir_expression *const r0B4E = expr(ir_unop_bit_not, r0B4D);
                     body.emit(assign(r0B14, bit_and(r0B45, r0B4E), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B44->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0B50 = bit_or(r0B13, r0B14);
                     ir_expression *const r0B51 = equal(r0B50, body.constant(0u));
                     ir_if *f0B4F = new(mem_ctx) ir_if(operand(r0B51).val);
                     exec_list *const f0B4F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B4F->then_instructions;

                        body.emit(assign(r0B12, body.constant(int(0)), 0x01));


                     body.instructions = f0B4F_parent_instructions;
                     body.emit(f0B4F);

                     /* END IF */


                  body.instructions = f0B44_parent_instructions;
                  body.emit(f0B44);

                  /* END IF */

                  ir_variable *const r0B52 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0B52);
                  ir_expression *const r0B53 = lshift(r0999, body.constant(int(31)));
                  ir_expression *const r0B54 = expr(ir_unop_i2u, r0B12);
                  ir_expression *const r0B55 = lshift(r0B54, body.constant(int(20)));
                  ir_expression *const r0B56 = add(r0B53, r0B55);
                  body.emit(assign(r0B52, add(r0B56, r0B13), 0x02));

                  body.emit(assign(r0B52, r0B14, 0x01));

                  body.emit(assign(r0B17, r0B52, 0x03));

                  body.emit(assign(r0B16, body.constant(false), 0x01));


               body.instructions = f0B43_parent_instructions;
               body.emit(f0B43);

               /* END IF */

               body.emit(assign(r099A, r0B17, 0x03));


            body.instructions = f0A85_parent_instructions;
            body.emit(f0A85);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0A83->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0B58 = equal(r09A3, body.constant(int(2047)));
            ir_if *f0B57 = new(mem_ctx) ir_if(operand(r0B58).val);
            exec_list *const f0B57_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0B57->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0B5A = bit_or(r09A0, r09A1);
               ir_expression *const r0B5B = bit_or(r099E, r099F);
               ir_expression *const r0B5C = bit_or(r0B5A, r0B5B);
               ir_expression *const r0B5D = nequal(r0B5C, body.constant(0u));
               ir_if *f0B59 = new(mem_ctx) ir_if(operand(r0B5D).val);
               exec_list *const f0B59_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B59->then_instructions;

                  ir_variable *const r0B5E = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r0B5E, swizzle_x(r07E9), 0x01));

                  ir_variable *const r0B5F = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r0B5F, swizzle_x(r07EA), 0x01));

                  ir_variable *const r0B60 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0B61 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0B62 = rshift(swizzle_y(r07E9), body.constant(int(19)));
                  ir_expression *const r0B63 = bit_and(r0B62, body.constant(4095u));
                  ir_expression *const r0B64 = equal(r0B63, body.constant(4094u));
                  ir_expression *const r0B65 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0B66 = bit_and(swizzle_y(r07E9), body.constant(524287u));
                  ir_expression *const r0B67 = nequal(r0B66, body.constant(0u));
                  ir_expression *const r0B68 = logic_or(r0B65, r0B67);
                  body.emit(assign(r0B61, logic_and(r0B64, r0B68), 0x01));

                  ir_variable *const r0B69 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0B6A = lshift(swizzle_y(r07EA), body.constant(int(1)));
                  ir_expression *const r0B6B = lequal(body.constant(4292870144u), r0B6A);
                  ir_expression *const r0B6C = nequal(swizzle_x(r07EA), body.constant(0u));
                  ir_expression *const r0B6D = bit_and(swizzle_y(r07EA), body.constant(1048575u));
                  ir_expression *const r0B6E = nequal(r0B6D, body.constant(0u));
                  ir_expression *const r0B6F = logic_or(r0B6C, r0B6E);
                  body.emit(assign(r0B69, logic_and(r0B6B, r0B6F), 0x01));

                  body.emit(assign(r0B5E, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

                  body.emit(assign(r0B5F, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r0B71 = lshift(swizzle_y(r07E9), body.constant(int(1)));
                  ir_expression *const r0B72 = lequal(body.constant(4292870144u), r0B71);
                  ir_expression *const r0B73 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0B74 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
                  ir_expression *const r0B75 = nequal(r0B74, body.constant(0u));
                  ir_expression *const r0B76 = logic_or(r0B73, r0B75);
                  ir_expression *const r0B77 = logic_and(r0B72, r0B76);
                  ir_if *f0B70 = new(mem_ctx) ir_if(operand(r0B77).val);
                  exec_list *const f0B70_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B70->then_instructions;

                     ir_variable *const r0B78 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0B7A = logic_and(r0B61, r0B69);
                     ir_if *f0B79 = new(mem_ctx) ir_if(operand(r0B7A).val);
                     exec_list *const f0B79_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B79->then_instructions;

                        body.emit(assign(r0B78, r0B5F, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0B79->else_instructions;

                        body.emit(assign(r0B78, r0B5E, 0x03));


                     body.instructions = f0B79_parent_instructions;
                     body.emit(f0B79);

                     /* END IF */

                     body.emit(assign(r0B60, r0B78, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B70->else_instructions;

                     body.emit(assign(r0B60, r0B5F, 0x03));


                  body.instructions = f0B70_parent_instructions;
                  body.emit(f0B70);

                  /* END IF */

                  body.emit(assign(r099A, r0B60, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0B59->else_instructions;

                  ir_constant_data r0B7B_data;
                  memset(&r0B7B_data, 0, sizeof(ir_constant_data));
                  r0B7B_data.u[0] = 4294967295;
                  r0B7B_data.u[1] = 4294967295;
                  ir_constant *const r0B7B = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r0B7B_data);
                  body.emit(assign(r099A, r0B7B, 0x03));


               body.instructions = f0B59_parent_instructions;
               body.emit(f0B59);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0B57->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0B7D = equal(r09A3, body.constant(int(0)));
               ir_if *f0B7C = new(mem_ctx) ir_if(operand(r0B7D).val);
               exec_list *const f0B7C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B7C->then_instructions;

                  body.emit(assign(r099D, body.constant(int(1)), 0x01));

                  body.emit(assign(r099C, body.constant(int(1)), 0x01));


               body.instructions = f0B7C_parent_instructions;
               body.emit(f0B7C);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0B7F = less(r099E, r09A0);
               ir_if *f0B7E = new(mem_ctx) ir_if(operand(r0B7F).val);
               exec_list *const f0B7E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B7E->then_instructions;

                  ir_variable *const r0B80 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r0B81 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0B81, sub(r09A1, r099F), 0x01));

                  ir_expression *const r0B82 = sub(r09A0, r099E);
                  ir_expression *const r0B83 = less(r09A1, r099F);
                  ir_expression *const r0B84 = expr(ir_unop_b2i, r0B83);
                  ir_expression *const r0B85 = expr(ir_unop_i2u, r0B84);
                  body.emit(assign(r0B80, sub(r0B82, r0B85), 0x01));

                  body.emit(assign(r09A2, add(r099D, body.constant(int(-1))), 0x01));

                  ir_variable *const r0B86 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r0B86, add(r09A2, body.constant(int(-10))), 0x01));

                  ir_variable *const r0B87 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r0B87, r0B80, 0x01));

                  ir_variable *const r0B88 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r0B88, r0B81, 0x01));

                  ir_variable *const r0B89 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r0B89);
                  ir_variable *const r0B8A = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0B8A);
                  /* IF CONDITION */
                  ir_expression *const r0B8C = equal(r0B80, body.constant(0u));
                  ir_if *f0B8B = new(mem_ctx) ir_if(operand(r0B8C).val);
                  exec_list *const f0B8B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B8B->then_instructions;

                     body.emit(assign(r0B87, r0B81, 0x01));

                     body.emit(assign(r0B88, body.constant(0u), 0x01));

                     body.emit(assign(r0B86, add(r0B86, body.constant(int(-32))), 0x01));


                  body.instructions = f0B8B_parent_instructions;
                  body.emit(f0B8B);

                  /* END IF */

                  ir_variable *const r0B8D = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r0B8D, r0B87, 0x01));

                  ir_variable *const r0B8E = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r0B8F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0B8F);
                  /* IF CONDITION */
                  ir_expression *const r0B91 = equal(r0B87, body.constant(0u));
                  ir_if *f0B90 = new(mem_ctx) ir_if(operand(r0B91).val);
                  exec_list *const f0B90_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B90->then_instructions;

                     body.emit(assign(r0B8E, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B90->else_instructions;

                     body.emit(assign(r0B8F, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0B93 = bit_and(r0B87, body.constant(4294901760u));
                     ir_expression *const r0B94 = equal(r0B93, body.constant(0u));
                     ir_if *f0B92 = new(mem_ctx) ir_if(operand(r0B94).val);
                     exec_list *const f0B92_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B92->then_instructions;

                        body.emit(assign(r0B8F, body.constant(int(16)), 0x01));

                        body.emit(assign(r0B8D, lshift(r0B87, body.constant(int(16))), 0x01));


                     body.instructions = f0B92_parent_instructions;
                     body.emit(f0B92);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0B96 = bit_and(r0B8D, body.constant(4278190080u));
                     ir_expression *const r0B97 = equal(r0B96, body.constant(0u));
                     ir_if *f0B95 = new(mem_ctx) ir_if(operand(r0B97).val);
                     exec_list *const f0B95_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B95->then_instructions;

                        body.emit(assign(r0B8F, add(r0B8F, body.constant(int(8))), 0x01));

                        body.emit(assign(r0B8D, lshift(r0B8D, body.constant(int(8))), 0x01));


                     body.instructions = f0B95_parent_instructions;
                     body.emit(f0B95);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0B99 = bit_and(r0B8D, body.constant(4026531840u));
                     ir_expression *const r0B9A = equal(r0B99, body.constant(0u));
                     ir_if *f0B98 = new(mem_ctx) ir_if(operand(r0B9A).val);
                     exec_list *const f0B98_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B98->then_instructions;

                        body.emit(assign(r0B8F, add(r0B8F, body.constant(int(4))), 0x01));

                        body.emit(assign(r0B8D, lshift(r0B8D, body.constant(int(4))), 0x01));


                     body.instructions = f0B98_parent_instructions;
                     body.emit(f0B98);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0B9C = bit_and(r0B8D, body.constant(3221225472u));
                     ir_expression *const r0B9D = equal(r0B9C, body.constant(0u));
                     ir_if *f0B9B = new(mem_ctx) ir_if(operand(r0B9D).val);
                     exec_list *const f0B9B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B9B->then_instructions;

                        body.emit(assign(r0B8F, add(r0B8F, body.constant(int(2))), 0x01));

                        body.emit(assign(r0B8D, lshift(r0B8D, body.constant(int(2))), 0x01));


                     body.instructions = f0B9B_parent_instructions;
                     body.emit(f0B9B);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0B9F = bit_and(r0B8D, body.constant(2147483648u));
                     ir_expression *const r0BA0 = equal(r0B9F, body.constant(0u));
                     ir_if *f0B9E = new(mem_ctx) ir_if(operand(r0BA0).val);
                     exec_list *const f0B9E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B9E->then_instructions;

                        body.emit(assign(r0B8F, add(r0B8F, body.constant(int(1))), 0x01));


                     body.instructions = f0B9E_parent_instructions;
                     body.emit(f0B9E);

                     /* END IF */

                     body.emit(assign(r0B8E, r0B8F, 0x01));


                  body.instructions = f0B90_parent_instructions;
                  body.emit(f0B90);

                  /* END IF */

                  body.emit(assign(r0B8A, add(r0B8E, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0BA2 = lequal(body.constant(int(0)), r0B8A);
                  ir_if *f0BA1 = new(mem_ctx) ir_if(operand(r0BA2).val);
                  exec_list *const f0BA1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0BA1->then_instructions;

                     body.emit(assign(r0B89, body.constant(0u), 0x01));

                     ir_variable *const r0BA3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r0BA3, lshift(r0B88, r0B8A), 0x01));

                     ir_variable *const r0BA4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0BA6 = equal(r0B8A, body.constant(int(0)));
                     ir_if *f0BA5 = new(mem_ctx) ir_if(operand(r0BA6).val);
                     exec_list *const f0BA5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BA5->then_instructions;

                        body.emit(assign(r0BA4, r0B87, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BA5->else_instructions;

                        ir_expression *const r0BA7 = lshift(r0B87, r0B8A);
                        ir_expression *const r0BA8 = neg(r0B8A);
                        ir_expression *const r0BA9 = bit_and(r0BA8, body.constant(int(31)));
                        ir_expression *const r0BAA = rshift(r0B88, r0BA9);
                        body.emit(assign(r0BA4, bit_or(r0BA7, r0BAA), 0x01));


                     body.instructions = f0BA5_parent_instructions;
                     body.emit(f0BA5);

                     /* END IF */

                     body.emit(assign(r0B87, r0BA4, 0x01));

                     body.emit(assign(r0B88, r0BA3, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0BA1->else_instructions;

                     ir_variable *const r0BAB = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0BAB, body.constant(0u), 0x01));

                     ir_variable *const r0BAC = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0BAC, neg(r0B8A), 0x01));

                     ir_variable *const r0BAD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0BAD);
                     ir_variable *const r0BAE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0BAE);
                     ir_variable *const r0BAF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0BAF);
                     ir_variable *const r0BB0 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0BB1 = neg(r0BAC);
                     body.emit(assign(r0BB0, bit_and(r0BB1, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0BB3 = equal(r0BAC, body.constant(int(0)));
                     ir_if *f0BB2 = new(mem_ctx) ir_if(operand(r0BB3).val);
                     exec_list *const f0BB2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BB2->then_instructions;

                        body.emit(assign(r0BAD, r0BAB, 0x01));

                        body.emit(assign(r0BAE, r0B88, 0x01));

                        body.emit(assign(r0BAF, r0B87, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BB2->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0BB5 = less(r0BAC, body.constant(int(32)));
                        ir_if *f0BB4 = new(mem_ctx) ir_if(operand(r0BB5).val);
                        exec_list *const f0BB4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0BB4->then_instructions;

                           body.emit(assign(r0BAD, lshift(r0B88, r0BB0), 0x01));

                           ir_expression *const r0BB6 = lshift(r0B87, r0BB0);
                           ir_expression *const r0BB7 = rshift(r0B88, r0BAC);
                           body.emit(assign(r0BAE, bit_or(r0BB6, r0BB7), 0x01));

                           body.emit(assign(r0BAF, rshift(r0B87, r0BAC), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0BB4->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0BB9 = equal(r0BAC, body.constant(int(32)));
                           ir_if *f0BB8 = new(mem_ctx) ir_if(operand(r0BB9).val);
                           exec_list *const f0BB8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0BB8->then_instructions;

                              body.emit(assign(r0BAD, r0B88, 0x01));

                              body.emit(assign(r0BAE, r0B87, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0BB8->else_instructions;

                              body.emit(assign(r0BAB, bit_or(body.constant(0u), r0B88), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0BBB = less(r0BAC, body.constant(int(64)));
                              ir_if *f0BBA = new(mem_ctx) ir_if(operand(r0BBB).val);
                              exec_list *const f0BBA_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0BBA->then_instructions;

                                 body.emit(assign(r0BAD, lshift(r0B87, r0BB0), 0x01));

                                 ir_expression *const r0BBC = bit_and(r0BAC, body.constant(int(31)));
                                 body.emit(assign(r0BAE, rshift(r0B87, r0BBC), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0BBA->else_instructions;

                                 ir_variable *const r0BBD = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0BBF = equal(r0BAC, body.constant(int(64)));
                                 ir_if *f0BBE = new(mem_ctx) ir_if(operand(r0BBF).val);
                                 exec_list *const f0BBE_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0BBE->then_instructions;

                                    body.emit(assign(r0BBD, r0B87, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0BBE->else_instructions;

                                    ir_expression *const r0BC0 = nequal(r0B87, body.constant(0u));
                                    ir_expression *const r0BC1 = expr(ir_unop_b2i, r0BC0);
                                    body.emit(assign(r0BBD, expr(ir_unop_i2u, r0BC1), 0x01));


                                 body.instructions = f0BBE_parent_instructions;
                                 body.emit(f0BBE);

                                 /* END IF */

                                 body.emit(assign(r0BAD, r0BBD, 0x01));

                                 body.emit(assign(r0BAE, body.constant(0u), 0x01));


                              body.instructions = f0BBA_parent_instructions;
                              body.emit(f0BBA);

                              /* END IF */


                           body.instructions = f0BB8_parent_instructions;
                           body.emit(f0BB8);

                           /* END IF */

                           body.emit(assign(r0BAF, body.constant(0u), 0x01));


                        body.instructions = f0BB4_parent_instructions;
                        body.emit(f0BB4);

                        /* END IF */

                        ir_expression *const r0BC2 = nequal(r0BAB, body.constant(0u));
                        ir_expression *const r0BC3 = expr(ir_unop_b2i, r0BC2);
                        ir_expression *const r0BC4 = expr(ir_unop_i2u, r0BC3);
                        body.emit(assign(r0BAD, bit_or(r0BAD, r0BC4), 0x01));


                     body.instructions = f0BB2_parent_instructions;
                     body.emit(f0BB2);

                     /* END IF */

                     body.emit(assign(r0B87, r0BAF, 0x01));

                     body.emit(assign(r0B88, r0BAE, 0x01));

                     body.emit(assign(r0B89, r0BAD, 0x01));


                  body.instructions = f0BA1_parent_instructions;
                  body.emit(f0BA1);

                  /* END IF */

                  body.emit(assign(r0B86, sub(r0B86, r0B8A), 0x01));

                  ir_variable *const r0BC5 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r0BC5, r0B86, 0x01));

                  ir_variable *const r0BC6 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r0BC6, r0B87, 0x01));

                  ir_variable *const r0BC7 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r0BC7, r0B88, 0x01));

                  ir_variable *const r0BC8 = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r0BC8, r0B89, 0x01));

                  ir_variable *const r0BC9 = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r0BC9, body.constant(true), 0x01));

                  ir_variable *const r0BCA = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0BCB = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r0BCB);
                  ir_expression *const r0BCC = expr(ir_unop_u2i, r0B89);
                  body.emit(assign(r0BCB, less(r0BCC, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0BCE = lequal(body.constant(int(2045)), r0B86);
                  ir_if *f0BCD = new(mem_ctx) ir_if(operand(r0BCE).val);
                  exec_list *const f0BCD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0BCD->then_instructions;

                     ir_variable *const r0BCF = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0BD1 = less(body.constant(int(2045)), r0B86);
                     ir_if *f0BD0 = new(mem_ctx) ir_if(operand(r0BD1).val);
                     exec_list *const f0BD0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BD0->then_instructions;

                        body.emit(assign(r0BCF, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BD0->else_instructions;

                        ir_variable *const r0BD2 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0BD4 = equal(r0B86, body.constant(int(2045)));
                        ir_if *f0BD3 = new(mem_ctx) ir_if(operand(r0BD4).val);
                        exec_list *const f0BD3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0BD3->then_instructions;

                           ir_expression *const r0BD5 = equal(body.constant(2097151u), r0B87);
                           ir_expression *const r0BD6 = equal(body.constant(4294967295u), r0B88);
                           body.emit(assign(r0BD2, logic_and(r0BD5, r0BD6), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0BD3->else_instructions;

                           body.emit(assign(r0BD2, body.constant(false), 0x01));


                        body.instructions = f0BD3_parent_instructions;
                        body.emit(f0BD3);

                        /* END IF */

                        body.emit(assign(r0BCF, logic_and(r0BD2, r0BCB), 0x01));


                     body.instructions = f0BD0_parent_instructions;
                     body.emit(f0BD0);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f0BD7 = new(mem_ctx) ir_if(operand(r0BCF).val);
                     exec_list *const f0BD7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BD7->then_instructions;

                        ir_variable *const r0BD8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r0BD8);
                        ir_expression *const r0BD9 = lshift(r0999, body.constant(int(31)));
                        body.emit(assign(r0BD8, add(r0BD9, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r0BD8, body.constant(0u), 0x01));

                        body.emit(assign(r0BCA, r0BD8, 0x03));

                        body.emit(assign(r0BC9, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BD7->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0BDB = less(r0B86, body.constant(int(0)));
                        ir_if *f0BDA = new(mem_ctx) ir_if(operand(r0BDB).val);
                        exec_list *const f0BDA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0BDA->then_instructions;

                           ir_variable *const r0BDC = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r0BDC, r0B89, 0x01));

                           ir_variable *const r0BDD = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r0BDD, neg(r0B86), 0x01));

                           ir_variable *const r0BDE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r0BDE);
                           ir_variable *const r0BDF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r0BDF);
                           ir_variable *const r0BE0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r0BE0);
                           ir_variable *const r0BE1 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r0BE2 = neg(r0BDD);
                           body.emit(assign(r0BE1, bit_and(r0BE2, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0BE4 = equal(r0BDD, body.constant(int(0)));
                           ir_if *f0BE3 = new(mem_ctx) ir_if(operand(r0BE4).val);
                           exec_list *const f0BE3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0BE3->then_instructions;

                              body.emit(assign(r0BDE, r0B89, 0x01));

                              body.emit(assign(r0BDF, r0B88, 0x01));

                              body.emit(assign(r0BE0, r0B87, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0BE3->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0BE6 = less(r0BDD, body.constant(int(32)));
                              ir_if *f0BE5 = new(mem_ctx) ir_if(operand(r0BE6).val);
                              exec_list *const f0BE5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0BE5->then_instructions;

                                 body.emit(assign(r0BDE, lshift(r0B88, r0BE1), 0x01));

                                 ir_expression *const r0BE7 = lshift(r0B87, r0BE1);
                                 ir_expression *const r0BE8 = rshift(r0B88, r0BDD);
                                 body.emit(assign(r0BDF, bit_or(r0BE7, r0BE8), 0x01));

                                 body.emit(assign(r0BE0, rshift(r0B87, r0BDD), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0BE5->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0BEA = equal(r0BDD, body.constant(int(32)));
                                 ir_if *f0BE9 = new(mem_ctx) ir_if(operand(r0BEA).val);
                                 exec_list *const f0BE9_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0BE9->then_instructions;

                                    body.emit(assign(r0BDE, r0B88, 0x01));

                                    body.emit(assign(r0BDF, r0B87, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0BE9->else_instructions;

                                    body.emit(assign(r0BDC, bit_or(r0B89, r0B88), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r0BEC = less(r0BDD, body.constant(int(64)));
                                    ir_if *f0BEB = new(mem_ctx) ir_if(operand(r0BEC).val);
                                    exec_list *const f0BEB_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0BEB->then_instructions;

                                       body.emit(assign(r0BDE, lshift(r0B87, r0BE1), 0x01));

                                       ir_expression *const r0BED = bit_and(r0BDD, body.constant(int(31)));
                                       body.emit(assign(r0BDF, rshift(r0B87, r0BED), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0BEB->else_instructions;

                                       ir_variable *const r0BEE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r0BF0 = equal(r0BDD, body.constant(int(64)));
                                       ir_if *f0BEF = new(mem_ctx) ir_if(operand(r0BF0).val);
                                       exec_list *const f0BEF_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0BEF->then_instructions;

                                          body.emit(assign(r0BEE, r0B87, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0BEF->else_instructions;

                                          ir_expression *const r0BF1 = nequal(r0B87, body.constant(0u));
                                          ir_expression *const r0BF2 = expr(ir_unop_b2i, r0BF1);
                                          body.emit(assign(r0BEE, expr(ir_unop_i2u, r0BF2), 0x01));


                                       body.instructions = f0BEF_parent_instructions;
                                       body.emit(f0BEF);

                                       /* END IF */

                                       body.emit(assign(r0BDE, r0BEE, 0x01));

                                       body.emit(assign(r0BDF, body.constant(0u), 0x01));


                                    body.instructions = f0BEB_parent_instructions;
                                    body.emit(f0BEB);

                                    /* END IF */


                                 body.instructions = f0BE9_parent_instructions;
                                 body.emit(f0BE9);

                                 /* END IF */

                                 body.emit(assign(r0BE0, body.constant(0u), 0x01));


                              body.instructions = f0BE5_parent_instructions;
                              body.emit(f0BE5);

                              /* END IF */

                              ir_expression *const r0BF3 = nequal(r0BDC, body.constant(0u));
                              ir_expression *const r0BF4 = expr(ir_unop_b2i, r0BF3);
                              ir_expression *const r0BF5 = expr(ir_unop_i2u, r0BF4);
                              body.emit(assign(r0BDE, bit_or(r0BDE, r0BF5), 0x01));


                           body.instructions = f0BE3_parent_instructions;
                           body.emit(f0BE3);

                           /* END IF */

                           body.emit(assign(r0BC6, r0BE0, 0x01));

                           body.emit(assign(r0BC7, r0BDF, 0x01));

                           body.emit(assign(r0BC8, r0BDE, 0x01));

                           body.emit(assign(r0BC5, body.constant(int(0)), 0x01));

                           body.emit(assign(r0BCB, less(r0BDE, body.constant(0u)), 0x01));


                        body.instructions = f0BDA_parent_instructions;
                        body.emit(f0BDA);

                        /* END IF */


                     body.instructions = f0BD7_parent_instructions;
                     body.emit(f0BD7);

                     /* END IF */


                  body.instructions = f0BCD_parent_instructions;
                  body.emit(f0BCD);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0BF6 = new(mem_ctx) ir_if(operand(r0BC9).val);
                  exec_list *const f0BF6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0BF6->then_instructions;

                     /* IF CONDITION */
                     ir_if *f0BF7 = new(mem_ctx) ir_if(operand(r0BCB).val);
                     exec_list *const f0BF7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BF7->then_instructions;

                        ir_variable *const r0BF8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r0BF8, add(r0BC7, body.constant(1u)), 0x01));

                        ir_expression *const r0BF9 = less(r0BF8, r0BC7);
                        ir_expression *const r0BFA = expr(ir_unop_b2i, r0BF9);
                        ir_expression *const r0BFB = expr(ir_unop_i2u, r0BFA);
                        body.emit(assign(r0BC6, add(r0BC6, r0BFB), 0x01));

                        ir_expression *const r0BFC = equal(r0BC8, body.constant(0u));
                        ir_expression *const r0BFD = expr(ir_unop_b2i, r0BFC);
                        ir_expression *const r0BFE = expr(ir_unop_i2u, r0BFD);
                        ir_expression *const r0BFF = add(r0BC8, r0BFE);
                        ir_expression *const r0C00 = bit_and(r0BFF, body.constant(1u));
                        ir_expression *const r0C01 = expr(ir_unop_bit_not, r0C00);
                        body.emit(assign(r0BC7, bit_and(r0BF8, r0C01), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BF7->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0C03 = bit_or(r0BC6, r0BC7);
                        ir_expression *const r0C04 = equal(r0C03, body.constant(0u));
                        ir_if *f0C02 = new(mem_ctx) ir_if(operand(r0C04).val);
                        exec_list *const f0C02_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C02->then_instructions;

                           body.emit(assign(r0BC5, body.constant(int(0)), 0x01));


                        body.instructions = f0C02_parent_instructions;
                        body.emit(f0C02);

                        /* END IF */


                     body.instructions = f0BF7_parent_instructions;
                     body.emit(f0BF7);

                     /* END IF */

                     ir_variable *const r0C05 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0C05);
                     ir_expression *const r0C06 = lshift(r0999, body.constant(int(31)));
                     ir_expression *const r0C07 = expr(ir_unop_i2u, r0BC5);
                     ir_expression *const r0C08 = lshift(r0C07, body.constant(int(20)));
                     ir_expression *const r0C09 = add(r0C06, r0C08);
                     body.emit(assign(r0C05, add(r0C09, r0BC6), 0x02));

                     body.emit(assign(r0C05, r0BC7, 0x01));

                     body.emit(assign(r0BCA, r0C05, 0x03));

                     body.emit(assign(r0BC9, body.constant(false), 0x01));


                  body.instructions = f0BF6_parent_instructions;
                  body.emit(f0BF6);

                  /* END IF */

                  body.emit(assign(r099A, r0BCA, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0B7E->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0C0B = less(r09A0, r099E);
                  ir_if *f0C0A = new(mem_ctx) ir_if(operand(r0C0B).val);
                  exec_list *const f0C0A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0C0A->then_instructions;

                     ir_variable *const r0C0C = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r0C0D = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r0C0D, sub(r099F, r09A1), 0x01));

                     ir_expression *const r0C0E = sub(r099E, r09A0);
                     ir_expression *const r0C0F = less(r099F, r09A1);
                     ir_expression *const r0C10 = expr(ir_unop_b2i, r0C0F);
                     ir_expression *const r0C11 = expr(ir_unop_i2u, r0C10);
                     body.emit(assign(r0C0C, sub(r0C0E, r0C11), 0x01));

                     body.emit(assign(r0999, bit_xor(r0999, body.constant(1u)), 0x01));

                     body.emit(assign(r09A2, add(r099C, body.constant(int(-1))), 0x01));

                     ir_variable *const r0C12 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r0C12, add(r09A2, body.constant(int(-10))), 0x01));

                     ir_variable *const r0C13 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r0C13, r0C0C, 0x01));

                     ir_variable *const r0C14 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r0C14, r0C0D, 0x01));

                     ir_variable *const r0C15 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r0C15);
                     ir_variable *const r0C16 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r0C16);
                     /* IF CONDITION */
                     ir_expression *const r0C18 = equal(r0C0C, body.constant(0u));
                     ir_if *f0C17 = new(mem_ctx) ir_if(operand(r0C18).val);
                     exec_list *const f0C17_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C17->then_instructions;

                        body.emit(assign(r0C13, r0C0D, 0x01));

                        body.emit(assign(r0C14, body.constant(0u), 0x01));

                        body.emit(assign(r0C12, add(r0C12, body.constant(int(-32))), 0x01));


                     body.instructions = f0C17_parent_instructions;
                     body.emit(f0C17);

                     /* END IF */

                     ir_variable *const r0C19 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r0C19, r0C13, 0x01));

                     ir_variable *const r0C1A = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r0C1B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r0C1B);
                     /* IF CONDITION */
                     ir_expression *const r0C1D = equal(r0C13, body.constant(0u));
                     ir_if *f0C1C = new(mem_ctx) ir_if(operand(r0C1D).val);
                     exec_list *const f0C1C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C1C->then_instructions;

                        body.emit(assign(r0C1A, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0C1C->else_instructions;

                        body.emit(assign(r0C1B, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0C1F = bit_and(r0C13, body.constant(4294901760u));
                        ir_expression *const r0C20 = equal(r0C1F, body.constant(0u));
                        ir_if *f0C1E = new(mem_ctx) ir_if(operand(r0C20).val);
                        exec_list *const f0C1E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C1E->then_instructions;

                           body.emit(assign(r0C1B, body.constant(int(16)), 0x01));

                           body.emit(assign(r0C19, lshift(r0C13, body.constant(int(16))), 0x01));


                        body.instructions = f0C1E_parent_instructions;
                        body.emit(f0C1E);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0C22 = bit_and(r0C19, body.constant(4278190080u));
                        ir_expression *const r0C23 = equal(r0C22, body.constant(0u));
                        ir_if *f0C21 = new(mem_ctx) ir_if(operand(r0C23).val);
                        exec_list *const f0C21_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C21->then_instructions;

                           body.emit(assign(r0C1B, add(r0C1B, body.constant(int(8))), 0x01));

                           body.emit(assign(r0C19, lshift(r0C19, body.constant(int(8))), 0x01));


                        body.instructions = f0C21_parent_instructions;
                        body.emit(f0C21);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0C25 = bit_and(r0C19, body.constant(4026531840u));
                        ir_expression *const r0C26 = equal(r0C25, body.constant(0u));
                        ir_if *f0C24 = new(mem_ctx) ir_if(operand(r0C26).val);
                        exec_list *const f0C24_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C24->then_instructions;

                           body.emit(assign(r0C1B, add(r0C1B, body.constant(int(4))), 0x01));

                           body.emit(assign(r0C19, lshift(r0C19, body.constant(int(4))), 0x01));


                        body.instructions = f0C24_parent_instructions;
                        body.emit(f0C24);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0C28 = bit_and(r0C19, body.constant(3221225472u));
                        ir_expression *const r0C29 = equal(r0C28, body.constant(0u));
                        ir_if *f0C27 = new(mem_ctx) ir_if(operand(r0C29).val);
                        exec_list *const f0C27_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C27->then_instructions;

                           body.emit(assign(r0C1B, add(r0C1B, body.constant(int(2))), 0x01));

                           body.emit(assign(r0C19, lshift(r0C19, body.constant(int(2))), 0x01));


                        body.instructions = f0C27_parent_instructions;
                        body.emit(f0C27);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0C2B = bit_and(r0C19, body.constant(2147483648u));
                        ir_expression *const r0C2C = equal(r0C2B, body.constant(0u));
                        ir_if *f0C2A = new(mem_ctx) ir_if(operand(r0C2C).val);
                        exec_list *const f0C2A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C2A->then_instructions;

                           body.emit(assign(r0C1B, add(r0C1B, body.constant(int(1))), 0x01));


                        body.instructions = f0C2A_parent_instructions;
                        body.emit(f0C2A);

                        /* END IF */

                        body.emit(assign(r0C1A, r0C1B, 0x01));


                     body.instructions = f0C1C_parent_instructions;
                     body.emit(f0C1C);

                     /* END IF */

                     body.emit(assign(r0C16, add(r0C1A, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0C2E = lequal(body.constant(int(0)), r0C16);
                     ir_if *f0C2D = new(mem_ctx) ir_if(operand(r0C2E).val);
                     exec_list *const f0C2D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C2D->then_instructions;

                        body.emit(assign(r0C15, body.constant(0u), 0x01));

                        ir_variable *const r0C2F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r0C2F, lshift(r0C14, r0C16), 0x01));

                        ir_variable *const r0C30 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0C32 = equal(r0C16, body.constant(int(0)));
                        ir_if *f0C31 = new(mem_ctx) ir_if(operand(r0C32).val);
                        exec_list *const f0C31_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C31->then_instructions;

                           body.emit(assign(r0C30, r0C13, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C31->else_instructions;

                           ir_expression *const r0C33 = lshift(r0C13, r0C16);
                           ir_expression *const r0C34 = neg(r0C16);
                           ir_expression *const r0C35 = bit_and(r0C34, body.constant(int(31)));
                           ir_expression *const r0C36 = rshift(r0C14, r0C35);
                           body.emit(assign(r0C30, bit_or(r0C33, r0C36), 0x01));


                        body.instructions = f0C31_parent_instructions;
                        body.emit(f0C31);

                        /* END IF */

                        body.emit(assign(r0C13, r0C30, 0x01));

                        body.emit(assign(r0C14, r0C2F, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0C2D->else_instructions;

                        ir_variable *const r0C37 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0C37, body.constant(0u), 0x01));

                        ir_variable *const r0C38 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0C38, neg(r0C16), 0x01));

                        ir_variable *const r0C39 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0C39);
                        ir_variable *const r0C3A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0C3A);
                        ir_variable *const r0C3B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0C3B);
                        ir_variable *const r0C3C = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r0C3D = neg(r0C38);
                        body.emit(assign(r0C3C, bit_and(r0C3D, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0C3F = equal(r0C38, body.constant(int(0)));
                        ir_if *f0C3E = new(mem_ctx) ir_if(operand(r0C3F).val);
                        exec_list *const f0C3E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C3E->then_instructions;

                           body.emit(assign(r0C39, r0C37, 0x01));

                           body.emit(assign(r0C3A, r0C14, 0x01));

                           body.emit(assign(r0C3B, r0C13, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C3E->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0C41 = less(r0C38, body.constant(int(32)));
                           ir_if *f0C40 = new(mem_ctx) ir_if(operand(r0C41).val);
                           exec_list *const f0C40_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0C40->then_instructions;

                              body.emit(assign(r0C39, lshift(r0C14, r0C3C), 0x01));

                              ir_expression *const r0C42 = lshift(r0C13, r0C3C);
                              ir_expression *const r0C43 = rshift(r0C14, r0C38);
                              body.emit(assign(r0C3A, bit_or(r0C42, r0C43), 0x01));

                              body.emit(assign(r0C3B, rshift(r0C13, r0C38), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0C40->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0C45 = equal(r0C38, body.constant(int(32)));
                              ir_if *f0C44 = new(mem_ctx) ir_if(operand(r0C45).val);
                              exec_list *const f0C44_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0C44->then_instructions;

                                 body.emit(assign(r0C39, r0C14, 0x01));

                                 body.emit(assign(r0C3A, r0C13, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0C44->else_instructions;

                                 body.emit(assign(r0C37, bit_or(body.constant(0u), r0C14), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0C47 = less(r0C38, body.constant(int(64)));
                                 ir_if *f0C46 = new(mem_ctx) ir_if(operand(r0C47).val);
                                 exec_list *const f0C46_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0C46->then_instructions;

                                    body.emit(assign(r0C39, lshift(r0C13, r0C3C), 0x01));

                                    ir_expression *const r0C48 = bit_and(r0C38, body.constant(int(31)));
                                    body.emit(assign(r0C3A, rshift(r0C13, r0C48), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0C46->else_instructions;

                                    ir_variable *const r0C49 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r0C4B = equal(r0C38, body.constant(int(64)));
                                    ir_if *f0C4A = new(mem_ctx) ir_if(operand(r0C4B).val);
                                    exec_list *const f0C4A_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0C4A->then_instructions;

                                       body.emit(assign(r0C49, r0C13, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0C4A->else_instructions;

                                       ir_expression *const r0C4C = nequal(r0C13, body.constant(0u));
                                       ir_expression *const r0C4D = expr(ir_unop_b2i, r0C4C);
                                       body.emit(assign(r0C49, expr(ir_unop_i2u, r0C4D), 0x01));


                                    body.instructions = f0C4A_parent_instructions;
                                    body.emit(f0C4A);

                                    /* END IF */

                                    body.emit(assign(r0C39, r0C49, 0x01));

                                    body.emit(assign(r0C3A, body.constant(0u), 0x01));


                                 body.instructions = f0C46_parent_instructions;
                                 body.emit(f0C46);

                                 /* END IF */


                              body.instructions = f0C44_parent_instructions;
                              body.emit(f0C44);

                              /* END IF */

                              body.emit(assign(r0C3B, body.constant(0u), 0x01));


                           body.instructions = f0C40_parent_instructions;
                           body.emit(f0C40);

                           /* END IF */

                           ir_expression *const r0C4E = nequal(r0C37, body.constant(0u));
                           ir_expression *const r0C4F = expr(ir_unop_b2i, r0C4E);
                           ir_expression *const r0C50 = expr(ir_unop_i2u, r0C4F);
                           body.emit(assign(r0C39, bit_or(r0C39, r0C50), 0x01));


                        body.instructions = f0C3E_parent_instructions;
                        body.emit(f0C3E);

                        /* END IF */

                        body.emit(assign(r0C13, r0C3B, 0x01));

                        body.emit(assign(r0C14, r0C3A, 0x01));

                        body.emit(assign(r0C15, r0C39, 0x01));


                     body.instructions = f0C2D_parent_instructions;
                     body.emit(f0C2D);

                     /* END IF */

                     body.emit(assign(r0C12, sub(r0C12, r0C16), 0x01));

                     ir_variable *const r0C51 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r0C51, r0C12, 0x01));

                     ir_variable *const r0C52 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r0C52, r0C13, 0x01));

                     ir_variable *const r0C53 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r0C53, r0C14, 0x01));

                     ir_variable *const r0C54 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r0C54, r0C15, 0x01));

                     ir_variable *const r0C55 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r0C55, body.constant(true), 0x01));

                     ir_variable *const r0C56 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r0C57 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r0C57);
                     ir_expression *const r0C58 = expr(ir_unop_u2i, r0C15);
                     body.emit(assign(r0C57, less(r0C58, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0C5A = lequal(body.constant(int(2045)), r0C12);
                     ir_if *f0C59 = new(mem_ctx) ir_if(operand(r0C5A).val);
                     exec_list *const f0C59_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C59->then_instructions;

                        ir_variable *const r0C5B = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0C5D = less(body.constant(int(2045)), r0C12);
                        ir_if *f0C5C = new(mem_ctx) ir_if(operand(r0C5D).val);
                        exec_list *const f0C5C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C5C->then_instructions;

                           body.emit(assign(r0C5B, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C5C->else_instructions;

                           ir_variable *const r0C5E = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0C60 = equal(r0C12, body.constant(int(2045)));
                           ir_if *f0C5F = new(mem_ctx) ir_if(operand(r0C60).val);
                           exec_list *const f0C5F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0C5F->then_instructions;

                              ir_expression *const r0C61 = equal(body.constant(2097151u), r0C13);
                              ir_expression *const r0C62 = equal(body.constant(4294967295u), r0C14);
                              body.emit(assign(r0C5E, logic_and(r0C61, r0C62), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0C5F->else_instructions;

                              body.emit(assign(r0C5E, body.constant(false), 0x01));


                           body.instructions = f0C5F_parent_instructions;
                           body.emit(f0C5F);

                           /* END IF */

                           body.emit(assign(r0C5B, logic_and(r0C5E, r0C57), 0x01));


                        body.instructions = f0C5C_parent_instructions;
                        body.emit(f0C5C);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f0C63 = new(mem_ctx) ir_if(operand(r0C5B).val);
                        exec_list *const f0C63_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C63->then_instructions;

                           ir_variable *const r0C64 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r0C64);
                           ir_expression *const r0C65 = lshift(r0999, body.constant(int(31)));
                           body.emit(assign(r0C64, add(r0C65, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r0C64, body.constant(0u), 0x01));

                           body.emit(assign(r0C56, r0C64, 0x03));

                           body.emit(assign(r0C55, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C63->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0C67 = less(r0C12, body.constant(int(0)));
                           ir_if *f0C66 = new(mem_ctx) ir_if(operand(r0C67).val);
                           exec_list *const f0C66_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0C66->then_instructions;

                              ir_variable *const r0C68 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r0C68, r0C15, 0x01));

                              ir_variable *const r0C69 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r0C69, neg(r0C12), 0x01));

                              ir_variable *const r0C6A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r0C6A);
                              ir_variable *const r0C6B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r0C6B);
                              ir_variable *const r0C6C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r0C6C);
                              ir_variable *const r0C6D = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r0C6E = neg(r0C69);
                              body.emit(assign(r0C6D, bit_and(r0C6E, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0C70 = equal(r0C69, body.constant(int(0)));
                              ir_if *f0C6F = new(mem_ctx) ir_if(operand(r0C70).val);
                              exec_list *const f0C6F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0C6F->then_instructions;

                                 body.emit(assign(r0C6A, r0C15, 0x01));

                                 body.emit(assign(r0C6B, r0C14, 0x01));

                                 body.emit(assign(r0C6C, r0C13, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0C6F->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0C72 = less(r0C69, body.constant(int(32)));
                                 ir_if *f0C71 = new(mem_ctx) ir_if(operand(r0C72).val);
                                 exec_list *const f0C71_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0C71->then_instructions;

                                    body.emit(assign(r0C6A, lshift(r0C14, r0C6D), 0x01));

                                    ir_expression *const r0C73 = lshift(r0C13, r0C6D);
                                    ir_expression *const r0C74 = rshift(r0C14, r0C69);
                                    body.emit(assign(r0C6B, bit_or(r0C73, r0C74), 0x01));

                                    body.emit(assign(r0C6C, rshift(r0C13, r0C69), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0C71->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r0C76 = equal(r0C69, body.constant(int(32)));
                                    ir_if *f0C75 = new(mem_ctx) ir_if(operand(r0C76).val);
                                    exec_list *const f0C75_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0C75->then_instructions;

                                       body.emit(assign(r0C6A, r0C14, 0x01));

                                       body.emit(assign(r0C6B, r0C13, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0C75->else_instructions;

                                       body.emit(assign(r0C68, bit_or(r0C15, r0C14), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r0C78 = less(r0C69, body.constant(int(64)));
                                       ir_if *f0C77 = new(mem_ctx) ir_if(operand(r0C78).val);
                                       exec_list *const f0C77_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0C77->then_instructions;

                                          body.emit(assign(r0C6A, lshift(r0C13, r0C6D), 0x01));

                                          ir_expression *const r0C79 = bit_and(r0C69, body.constant(int(31)));
                                          body.emit(assign(r0C6B, rshift(r0C13, r0C79), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0C77->else_instructions;

                                          ir_variable *const r0C7A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r0C7C = equal(r0C69, body.constant(int(64)));
                                          ir_if *f0C7B = new(mem_ctx) ir_if(operand(r0C7C).val);
                                          exec_list *const f0C7B_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0C7B->then_instructions;

                                             body.emit(assign(r0C7A, r0C13, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0C7B->else_instructions;

                                             ir_expression *const r0C7D = nequal(r0C13, body.constant(0u));
                                             ir_expression *const r0C7E = expr(ir_unop_b2i, r0C7D);
                                             body.emit(assign(r0C7A, expr(ir_unop_i2u, r0C7E), 0x01));


                                          body.instructions = f0C7B_parent_instructions;
                                          body.emit(f0C7B);

                                          /* END IF */

                                          body.emit(assign(r0C6A, r0C7A, 0x01));

                                          body.emit(assign(r0C6B, body.constant(0u), 0x01));


                                       body.instructions = f0C77_parent_instructions;
                                       body.emit(f0C77);

                                       /* END IF */


                                    body.instructions = f0C75_parent_instructions;
                                    body.emit(f0C75);

                                    /* END IF */

                                    body.emit(assign(r0C6C, body.constant(0u), 0x01));


                                 body.instructions = f0C71_parent_instructions;
                                 body.emit(f0C71);

                                 /* END IF */

                                 ir_expression *const r0C7F = nequal(r0C68, body.constant(0u));
                                 ir_expression *const r0C80 = expr(ir_unop_b2i, r0C7F);
                                 ir_expression *const r0C81 = expr(ir_unop_i2u, r0C80);
                                 body.emit(assign(r0C6A, bit_or(r0C6A, r0C81), 0x01));


                              body.instructions = f0C6F_parent_instructions;
                              body.emit(f0C6F);

                              /* END IF */

                              body.emit(assign(r0C52, r0C6C, 0x01));

                              body.emit(assign(r0C53, r0C6B, 0x01));

                              body.emit(assign(r0C54, r0C6A, 0x01));

                              body.emit(assign(r0C51, body.constant(int(0)), 0x01));

                              body.emit(assign(r0C57, less(r0C6A, body.constant(0u)), 0x01));


                           body.instructions = f0C66_parent_instructions;
                           body.emit(f0C66);

                           /* END IF */


                        body.instructions = f0C63_parent_instructions;
                        body.emit(f0C63);

                        /* END IF */


                     body.instructions = f0C59_parent_instructions;
                     body.emit(f0C59);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f0C82 = new(mem_ctx) ir_if(operand(r0C55).val);
                     exec_list *const f0C82_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C82->then_instructions;

                        /* IF CONDITION */
                        ir_if *f0C83 = new(mem_ctx) ir_if(operand(r0C57).val);
                        exec_list *const f0C83_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C83->then_instructions;

                           ir_variable *const r0C84 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r0C84, add(r0C53, body.constant(1u)), 0x01));

                           ir_expression *const r0C85 = less(r0C84, r0C53);
                           ir_expression *const r0C86 = expr(ir_unop_b2i, r0C85);
                           ir_expression *const r0C87 = expr(ir_unop_i2u, r0C86);
                           body.emit(assign(r0C52, add(r0C52, r0C87), 0x01));

                           ir_expression *const r0C88 = equal(r0C54, body.constant(0u));
                           ir_expression *const r0C89 = expr(ir_unop_b2i, r0C88);
                           ir_expression *const r0C8A = expr(ir_unop_i2u, r0C89);
                           ir_expression *const r0C8B = add(r0C54, r0C8A);
                           ir_expression *const r0C8C = bit_and(r0C8B, body.constant(1u));
                           ir_expression *const r0C8D = expr(ir_unop_bit_not, r0C8C);
                           body.emit(assign(r0C53, bit_and(r0C84, r0C8D), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C83->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0C8F = bit_or(r0C52, r0C53);
                           ir_expression *const r0C90 = equal(r0C8F, body.constant(0u));
                           ir_if *f0C8E = new(mem_ctx) ir_if(operand(r0C90).val);
                           exec_list *const f0C8E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0C8E->then_instructions;

                              body.emit(assign(r0C51, body.constant(int(0)), 0x01));


                           body.instructions = f0C8E_parent_instructions;
                           body.emit(f0C8E);

                           /* END IF */


                        body.instructions = f0C83_parent_instructions;
                        body.emit(f0C83);

                        /* END IF */

                        ir_variable *const r0C91 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r0C91);
                        ir_expression *const r0C92 = lshift(r0999, body.constant(int(31)));
                        ir_expression *const r0C93 = expr(ir_unop_i2u, r0C51);
                        ir_expression *const r0C94 = lshift(r0C93, body.constant(int(20)));
                        ir_expression *const r0C95 = add(r0C92, r0C94);
                        body.emit(assign(r0C91, add(r0C95, r0C52), 0x02));

                        body.emit(assign(r0C91, r0C53, 0x01));

                        body.emit(assign(r0C56, r0C91, 0x03));

                        body.emit(assign(r0C55, body.constant(false), 0x01));


                     body.instructions = f0C82_parent_instructions;
                     body.emit(f0C82);

                     /* END IF */

                     body.emit(assign(r099A, r0C56, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0C0A->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0C97 = less(r099F, r09A1);
                     ir_if *f0C96 = new(mem_ctx) ir_if(operand(r0C97).val);
                     exec_list *const f0C96_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C96->then_instructions;

                        ir_variable *const r0C98 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r0C99 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r0C99, sub(r09A1, r099F), 0x01));

                        ir_expression *const r0C9A = sub(r09A0, r099E);
                        ir_expression *const r0C9B = less(r09A1, r099F);
                        ir_expression *const r0C9C = expr(ir_unop_b2i, r0C9B);
                        ir_expression *const r0C9D = expr(ir_unop_i2u, r0C9C);
                        body.emit(assign(r0C98, sub(r0C9A, r0C9D), 0x01));

                        body.emit(assign(r09A2, add(r099D, body.constant(int(-1))), 0x01));

                        ir_variable *const r0C9E = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r0C9E, add(r09A2, body.constant(int(-10))), 0x01));

                        ir_variable *const r0C9F = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r0C9F, r0C98, 0x01));

                        ir_variable *const r0CA0 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r0CA0, r0C99, 0x01));

                        ir_variable *const r0CA1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r0CA1);
                        ir_variable *const r0CA2 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r0CA2);
                        /* IF CONDITION */
                        ir_expression *const r0CA4 = equal(r0C98, body.constant(0u));
                        ir_if *f0CA3 = new(mem_ctx) ir_if(operand(r0CA4).val);
                        exec_list *const f0CA3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0CA3->then_instructions;

                           body.emit(assign(r0C9F, r0C99, 0x01));

                           body.emit(assign(r0CA0, body.constant(0u), 0x01));

                           body.emit(assign(r0C9E, add(r0C9E, body.constant(int(-32))), 0x01));


                        body.instructions = f0CA3_parent_instructions;
                        body.emit(f0CA3);

                        /* END IF */

                        ir_variable *const r0CA5 = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r0CA5, r0C9F, 0x01));

                        ir_variable *const r0CA6 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r0CA7 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r0CA7);
                        /* IF CONDITION */
                        ir_expression *const r0CA9 = equal(r0C9F, body.constant(0u));
                        ir_if *f0CA8 = new(mem_ctx) ir_if(operand(r0CA9).val);
                        exec_list *const f0CA8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0CA8->then_instructions;

                           body.emit(assign(r0CA6, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0CA8->else_instructions;

                           body.emit(assign(r0CA7, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0CAB = bit_and(r0C9F, body.constant(4294901760u));
                           ir_expression *const r0CAC = equal(r0CAB, body.constant(0u));
                           ir_if *f0CAA = new(mem_ctx) ir_if(operand(r0CAC).val);
                           exec_list *const f0CAA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CAA->then_instructions;

                              body.emit(assign(r0CA7, body.constant(int(16)), 0x01));

                              body.emit(assign(r0CA5, lshift(r0C9F, body.constant(int(16))), 0x01));


                           body.instructions = f0CAA_parent_instructions;
                           body.emit(f0CAA);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0CAE = bit_and(r0CA5, body.constant(4278190080u));
                           ir_expression *const r0CAF = equal(r0CAE, body.constant(0u));
                           ir_if *f0CAD = new(mem_ctx) ir_if(operand(r0CAF).val);
                           exec_list *const f0CAD_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CAD->then_instructions;

                              body.emit(assign(r0CA7, add(r0CA7, body.constant(int(8))), 0x01));

                              body.emit(assign(r0CA5, lshift(r0CA5, body.constant(int(8))), 0x01));


                           body.instructions = f0CAD_parent_instructions;
                           body.emit(f0CAD);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0CB1 = bit_and(r0CA5, body.constant(4026531840u));
                           ir_expression *const r0CB2 = equal(r0CB1, body.constant(0u));
                           ir_if *f0CB0 = new(mem_ctx) ir_if(operand(r0CB2).val);
                           exec_list *const f0CB0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CB0->then_instructions;

                              body.emit(assign(r0CA7, add(r0CA7, body.constant(int(4))), 0x01));

                              body.emit(assign(r0CA5, lshift(r0CA5, body.constant(int(4))), 0x01));


                           body.instructions = f0CB0_parent_instructions;
                           body.emit(f0CB0);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0CB4 = bit_and(r0CA5, body.constant(3221225472u));
                           ir_expression *const r0CB5 = equal(r0CB4, body.constant(0u));
                           ir_if *f0CB3 = new(mem_ctx) ir_if(operand(r0CB5).val);
                           exec_list *const f0CB3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CB3->then_instructions;

                              body.emit(assign(r0CA7, add(r0CA7, body.constant(int(2))), 0x01));

                              body.emit(assign(r0CA5, lshift(r0CA5, body.constant(int(2))), 0x01));


                           body.instructions = f0CB3_parent_instructions;
                           body.emit(f0CB3);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0CB7 = bit_and(r0CA5, body.constant(2147483648u));
                           ir_expression *const r0CB8 = equal(r0CB7, body.constant(0u));
                           ir_if *f0CB6 = new(mem_ctx) ir_if(operand(r0CB8).val);
                           exec_list *const f0CB6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CB6->then_instructions;

                              body.emit(assign(r0CA7, add(r0CA7, body.constant(int(1))), 0x01));


                           body.instructions = f0CB6_parent_instructions;
                           body.emit(f0CB6);

                           /* END IF */

                           body.emit(assign(r0CA6, r0CA7, 0x01));


                        body.instructions = f0CA8_parent_instructions;
                        body.emit(f0CA8);

                        /* END IF */

                        body.emit(assign(r0CA2, add(r0CA6, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0CBA = lequal(body.constant(int(0)), r0CA2);
                        ir_if *f0CB9 = new(mem_ctx) ir_if(operand(r0CBA).val);
                        exec_list *const f0CB9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0CB9->then_instructions;

                           body.emit(assign(r0CA1, body.constant(0u), 0x01));

                           ir_variable *const r0CBB = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r0CBB, lshift(r0CA0, r0CA2), 0x01));

                           ir_variable *const r0CBC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0CBE = equal(r0CA2, body.constant(int(0)));
                           ir_if *f0CBD = new(mem_ctx) ir_if(operand(r0CBE).val);
                           exec_list *const f0CBD_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CBD->then_instructions;

                              body.emit(assign(r0CBC, r0C9F, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0CBD->else_instructions;

                              ir_expression *const r0CBF = lshift(r0C9F, r0CA2);
                              ir_expression *const r0CC0 = neg(r0CA2);
                              ir_expression *const r0CC1 = bit_and(r0CC0, body.constant(int(31)));
                              ir_expression *const r0CC2 = rshift(r0CA0, r0CC1);
                              body.emit(assign(r0CBC, bit_or(r0CBF, r0CC2), 0x01));


                           body.instructions = f0CBD_parent_instructions;
                           body.emit(f0CBD);

                           /* END IF */

                           body.emit(assign(r0C9F, r0CBC, 0x01));

                           body.emit(assign(r0CA0, r0CBB, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0CB9->else_instructions;

                           ir_variable *const r0CC3 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r0CC3, body.constant(0u), 0x01));

                           ir_variable *const r0CC4 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r0CC4, neg(r0CA2), 0x01));

                           ir_variable *const r0CC5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r0CC5);
                           ir_variable *const r0CC6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r0CC6);
                           ir_variable *const r0CC7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r0CC7);
                           ir_variable *const r0CC8 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r0CC9 = neg(r0CC4);
                           body.emit(assign(r0CC8, bit_and(r0CC9, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0CCB = equal(r0CC4, body.constant(int(0)));
                           ir_if *f0CCA = new(mem_ctx) ir_if(operand(r0CCB).val);
                           exec_list *const f0CCA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CCA->then_instructions;

                              body.emit(assign(r0CC5, r0CC3, 0x01));

                              body.emit(assign(r0CC6, r0CA0, 0x01));

                              body.emit(assign(r0CC7, r0C9F, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0CCA->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0CCD = less(r0CC4, body.constant(int(32)));
                              ir_if *f0CCC = new(mem_ctx) ir_if(operand(r0CCD).val);
                              exec_list *const f0CCC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0CCC->then_instructions;

                                 body.emit(assign(r0CC5, lshift(r0CA0, r0CC8), 0x01));

                                 ir_expression *const r0CCE = lshift(r0C9F, r0CC8);
                                 ir_expression *const r0CCF = rshift(r0CA0, r0CC4);
                                 body.emit(assign(r0CC6, bit_or(r0CCE, r0CCF), 0x01));

                                 body.emit(assign(r0CC7, rshift(r0C9F, r0CC4), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0CCC->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0CD1 = equal(r0CC4, body.constant(int(32)));
                                 ir_if *f0CD0 = new(mem_ctx) ir_if(operand(r0CD1).val);
                                 exec_list *const f0CD0_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0CD0->then_instructions;

                                    body.emit(assign(r0CC5, r0CA0, 0x01));

                                    body.emit(assign(r0CC6, r0C9F, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0CD0->else_instructions;

                                    body.emit(assign(r0CC3, bit_or(body.constant(0u), r0CA0), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r0CD3 = less(r0CC4, body.constant(int(64)));
                                    ir_if *f0CD2 = new(mem_ctx) ir_if(operand(r0CD3).val);
                                    exec_list *const f0CD2_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0CD2->then_instructions;

                                       body.emit(assign(r0CC5, lshift(r0C9F, r0CC8), 0x01));

                                       ir_expression *const r0CD4 = bit_and(r0CC4, body.constant(int(31)));
                                       body.emit(assign(r0CC6, rshift(r0C9F, r0CD4), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0CD2->else_instructions;

                                       ir_variable *const r0CD5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r0CD7 = equal(r0CC4, body.constant(int(64)));
                                       ir_if *f0CD6 = new(mem_ctx) ir_if(operand(r0CD7).val);
                                       exec_list *const f0CD6_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0CD6->then_instructions;

                                          body.emit(assign(r0CD5, r0C9F, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0CD6->else_instructions;

                                          ir_expression *const r0CD8 = nequal(r0C9F, body.constant(0u));
                                          ir_expression *const r0CD9 = expr(ir_unop_b2i, r0CD8);
                                          body.emit(assign(r0CD5, expr(ir_unop_i2u, r0CD9), 0x01));


                                       body.instructions = f0CD6_parent_instructions;
                                       body.emit(f0CD6);

                                       /* END IF */

                                       body.emit(assign(r0CC5, r0CD5, 0x01));

                                       body.emit(assign(r0CC6, body.constant(0u), 0x01));


                                    body.instructions = f0CD2_parent_instructions;
                                    body.emit(f0CD2);

                                    /* END IF */


                                 body.instructions = f0CD0_parent_instructions;
                                 body.emit(f0CD0);

                                 /* END IF */

                                 body.emit(assign(r0CC7, body.constant(0u), 0x01));


                              body.instructions = f0CCC_parent_instructions;
                              body.emit(f0CCC);

                              /* END IF */

                              ir_expression *const r0CDA = nequal(r0CC3, body.constant(0u));
                              ir_expression *const r0CDB = expr(ir_unop_b2i, r0CDA);
                              ir_expression *const r0CDC = expr(ir_unop_i2u, r0CDB);
                              body.emit(assign(r0CC5, bit_or(r0CC5, r0CDC), 0x01));


                           body.instructions = f0CCA_parent_instructions;
                           body.emit(f0CCA);

                           /* END IF */

                           body.emit(assign(r0C9F, r0CC7, 0x01));

                           body.emit(assign(r0CA0, r0CC6, 0x01));

                           body.emit(assign(r0CA1, r0CC5, 0x01));


                        body.instructions = f0CB9_parent_instructions;
                        body.emit(f0CB9);

                        /* END IF */

                        body.emit(assign(r0C9E, sub(r0C9E, r0CA2), 0x01));

                        ir_variable *const r0CDD = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r0CDD, r0C9E, 0x01));

                        ir_variable *const r0CDE = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r0CDE, r0C9F, 0x01));

                        ir_variable *const r0CDF = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r0CDF, r0CA0, 0x01));

                        ir_variable *const r0CE0 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r0CE0, r0CA1, 0x01));

                        ir_variable *const r0CE1 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r0CE1, body.constant(true), 0x01));

                        ir_variable *const r0CE2 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r0CE3 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r0CE3);
                        ir_expression *const r0CE4 = expr(ir_unop_u2i, r0CA1);
                        body.emit(assign(r0CE3, less(r0CE4, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0CE6 = lequal(body.constant(int(2045)), r0C9E);
                        ir_if *f0CE5 = new(mem_ctx) ir_if(operand(r0CE6).val);
                        exec_list *const f0CE5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0CE5->then_instructions;

                           ir_variable *const r0CE7 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0CE9 = less(body.constant(int(2045)), r0C9E);
                           ir_if *f0CE8 = new(mem_ctx) ir_if(operand(r0CE9).val);
                           exec_list *const f0CE8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CE8->then_instructions;

                              body.emit(assign(r0CE7, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0CE8->else_instructions;

                              ir_variable *const r0CEA = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0CEC = equal(r0C9E, body.constant(int(2045)));
                              ir_if *f0CEB = new(mem_ctx) ir_if(operand(r0CEC).val);
                              exec_list *const f0CEB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0CEB->then_instructions;

                                 ir_expression *const r0CED = equal(body.constant(2097151u), r0C9F);
                                 ir_expression *const r0CEE = equal(body.constant(4294967295u), r0CA0);
                                 body.emit(assign(r0CEA, logic_and(r0CED, r0CEE), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0CEB->else_instructions;

                                 body.emit(assign(r0CEA, body.constant(false), 0x01));


                              body.instructions = f0CEB_parent_instructions;
                              body.emit(f0CEB);

                              /* END IF */

                              body.emit(assign(r0CE7, logic_and(r0CEA, r0CE3), 0x01));


                           body.instructions = f0CE8_parent_instructions;
                           body.emit(f0CE8);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f0CEF = new(mem_ctx) ir_if(operand(r0CE7).val);
                           exec_list *const f0CEF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CEF->then_instructions;

                              ir_variable *const r0CF0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r0CF0);
                              ir_expression *const r0CF1 = lshift(r0999, body.constant(int(31)));
                              body.emit(assign(r0CF0, add(r0CF1, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r0CF0, body.constant(0u), 0x01));

                              body.emit(assign(r0CE2, r0CF0, 0x03));

                              body.emit(assign(r0CE1, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0CEF->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0CF3 = less(r0C9E, body.constant(int(0)));
                              ir_if *f0CF2 = new(mem_ctx) ir_if(operand(r0CF3).val);
                              exec_list *const f0CF2_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0CF2->then_instructions;

                                 ir_variable *const r0CF4 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r0CF4, r0CA1, 0x01));

                                 ir_variable *const r0CF5 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r0CF5, neg(r0C9E), 0x01));

                                 ir_variable *const r0CF6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r0CF6);
                                 ir_variable *const r0CF7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r0CF7);
                                 ir_variable *const r0CF8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r0CF8);
                                 ir_variable *const r0CF9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r0CFA = neg(r0CF5);
                                 body.emit(assign(r0CF9, bit_and(r0CFA, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0CFC = equal(r0CF5, body.constant(int(0)));
                                 ir_if *f0CFB = new(mem_ctx) ir_if(operand(r0CFC).val);
                                 exec_list *const f0CFB_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0CFB->then_instructions;

                                    body.emit(assign(r0CF6, r0CA1, 0x01));

                                    body.emit(assign(r0CF7, r0CA0, 0x01));

                                    body.emit(assign(r0CF8, r0C9F, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0CFB->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r0CFE = less(r0CF5, body.constant(int(32)));
                                    ir_if *f0CFD = new(mem_ctx) ir_if(operand(r0CFE).val);
                                    exec_list *const f0CFD_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0CFD->then_instructions;

                                       body.emit(assign(r0CF6, lshift(r0CA0, r0CF9), 0x01));

                                       ir_expression *const r0CFF = lshift(r0C9F, r0CF9);
                                       ir_expression *const r0D00 = rshift(r0CA0, r0CF5);
                                       body.emit(assign(r0CF7, bit_or(r0CFF, r0D00), 0x01));

                                       body.emit(assign(r0CF8, rshift(r0C9F, r0CF5), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0CFD->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r0D02 = equal(r0CF5, body.constant(int(32)));
                                       ir_if *f0D01 = new(mem_ctx) ir_if(operand(r0D02).val);
                                       exec_list *const f0D01_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0D01->then_instructions;

                                          body.emit(assign(r0CF6, r0CA0, 0x01));

                                          body.emit(assign(r0CF7, r0C9F, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0D01->else_instructions;

                                          body.emit(assign(r0CF4, bit_or(r0CA1, r0CA0), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r0D04 = less(r0CF5, body.constant(int(64)));
                                          ir_if *f0D03 = new(mem_ctx) ir_if(operand(r0D04).val);
                                          exec_list *const f0D03_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0D03->then_instructions;

                                             body.emit(assign(r0CF6, lshift(r0C9F, r0CF9), 0x01));

                                             ir_expression *const r0D05 = bit_and(r0CF5, body.constant(int(31)));
                                             body.emit(assign(r0CF7, rshift(r0C9F, r0D05), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0D03->else_instructions;

                                             ir_variable *const r0D06 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r0D08 = equal(r0CF5, body.constant(int(64)));
                                             ir_if *f0D07 = new(mem_ctx) ir_if(operand(r0D08).val);
                                             exec_list *const f0D07_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f0D07->then_instructions;

                                                body.emit(assign(r0D06, r0C9F, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f0D07->else_instructions;

                                                ir_expression *const r0D09 = nequal(r0C9F, body.constant(0u));
                                                ir_expression *const r0D0A = expr(ir_unop_b2i, r0D09);
                                                body.emit(assign(r0D06, expr(ir_unop_i2u, r0D0A), 0x01));


                                             body.instructions = f0D07_parent_instructions;
                                             body.emit(f0D07);

                                             /* END IF */

                                             body.emit(assign(r0CF6, r0D06, 0x01));

                                             body.emit(assign(r0CF7, body.constant(0u), 0x01));


                                          body.instructions = f0D03_parent_instructions;
                                          body.emit(f0D03);

                                          /* END IF */


                                       body.instructions = f0D01_parent_instructions;
                                       body.emit(f0D01);

                                       /* END IF */

                                       body.emit(assign(r0CF8, body.constant(0u), 0x01));


                                    body.instructions = f0CFD_parent_instructions;
                                    body.emit(f0CFD);

                                    /* END IF */

                                    ir_expression *const r0D0B = nequal(r0CF4, body.constant(0u));
                                    ir_expression *const r0D0C = expr(ir_unop_b2i, r0D0B);
                                    ir_expression *const r0D0D = expr(ir_unop_i2u, r0D0C);
                                    body.emit(assign(r0CF6, bit_or(r0CF6, r0D0D), 0x01));


                                 body.instructions = f0CFB_parent_instructions;
                                 body.emit(f0CFB);

                                 /* END IF */

                                 body.emit(assign(r0CDE, r0CF8, 0x01));

                                 body.emit(assign(r0CDF, r0CF7, 0x01));

                                 body.emit(assign(r0CE0, r0CF6, 0x01));

                                 body.emit(assign(r0CDD, body.constant(int(0)), 0x01));

                                 body.emit(assign(r0CE3, less(r0CF6, body.constant(0u)), 0x01));


                              body.instructions = f0CF2_parent_instructions;
                              body.emit(f0CF2);

                              /* END IF */


                           body.instructions = f0CEF_parent_instructions;
                           body.emit(f0CEF);

                           /* END IF */


                        body.instructions = f0CE5_parent_instructions;
                        body.emit(f0CE5);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f0D0E = new(mem_ctx) ir_if(operand(r0CE1).val);
                        exec_list *const f0D0E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0D0E->then_instructions;

                           /* IF CONDITION */
                           ir_if *f0D0F = new(mem_ctx) ir_if(operand(r0CE3).val);
                           exec_list *const f0D0F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D0F->then_instructions;

                              ir_variable *const r0D10 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r0D10, add(r0CDF, body.constant(1u)), 0x01));

                              ir_expression *const r0D11 = less(r0D10, r0CDF);
                              ir_expression *const r0D12 = expr(ir_unop_b2i, r0D11);
                              ir_expression *const r0D13 = expr(ir_unop_i2u, r0D12);
                              body.emit(assign(r0CDE, add(r0CDE, r0D13), 0x01));

                              ir_expression *const r0D14 = equal(r0CE0, body.constant(0u));
                              ir_expression *const r0D15 = expr(ir_unop_b2i, r0D14);
                              ir_expression *const r0D16 = expr(ir_unop_i2u, r0D15);
                              ir_expression *const r0D17 = add(r0CE0, r0D16);
                              ir_expression *const r0D18 = bit_and(r0D17, body.constant(1u));
                              ir_expression *const r0D19 = expr(ir_unop_bit_not, r0D18);
                              body.emit(assign(r0CDF, bit_and(r0D10, r0D19), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0D0F->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0D1B = bit_or(r0CDE, r0CDF);
                              ir_expression *const r0D1C = equal(r0D1B, body.constant(0u));
                              ir_if *f0D1A = new(mem_ctx) ir_if(operand(r0D1C).val);
                              exec_list *const f0D1A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D1A->then_instructions;

                                 body.emit(assign(r0CDD, body.constant(int(0)), 0x01));


                              body.instructions = f0D1A_parent_instructions;
                              body.emit(f0D1A);

                              /* END IF */


                           body.instructions = f0D0F_parent_instructions;
                           body.emit(f0D0F);

                           /* END IF */

                           ir_variable *const r0D1D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r0D1D);
                           ir_expression *const r0D1E = lshift(r0999, body.constant(int(31)));
                           ir_expression *const r0D1F = expr(ir_unop_i2u, r0CDD);
                           ir_expression *const r0D20 = lshift(r0D1F, body.constant(int(20)));
                           ir_expression *const r0D21 = add(r0D1E, r0D20);
                           body.emit(assign(r0D1D, add(r0D21, r0CDE), 0x02));

                           body.emit(assign(r0D1D, r0CDF, 0x01));

                           body.emit(assign(r0CE2, r0D1D, 0x03));

                           body.emit(assign(r0CE1, body.constant(false), 0x01));


                        body.instructions = f0D0E_parent_instructions;
                        body.emit(f0D0E);

                        /* END IF */

                        body.emit(assign(r099A, r0CE2, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0C96->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0D23 = less(r09A1, r099F);
                        ir_if *f0D22 = new(mem_ctx) ir_if(operand(r0D23).val);
                        exec_list *const f0D22_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0D22->then_instructions;

                           ir_variable *const r0D24 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r0D25 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r0D25, sub(r099F, r09A1), 0x01));

                           ir_expression *const r0D26 = sub(r099E, r09A0);
                           ir_expression *const r0D27 = less(r099F, r09A1);
                           ir_expression *const r0D28 = expr(ir_unop_b2i, r0D27);
                           ir_expression *const r0D29 = expr(ir_unop_i2u, r0D28);
                           body.emit(assign(r0D24, sub(r0D26, r0D29), 0x01));

                           body.emit(assign(r0999, bit_xor(r0999, body.constant(1u)), 0x01));

                           body.emit(assign(r09A2, add(r099C, body.constant(int(-1))), 0x01));

                           ir_variable *const r0D2A = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r0D2A, add(r09A2, body.constant(int(-10))), 0x01));

                           ir_variable *const r0D2B = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r0D2B, r0D24, 0x01));

                           ir_variable *const r0D2C = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r0D2C, r0D25, 0x01));

                           ir_variable *const r0D2D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r0D2D);
                           ir_variable *const r0D2E = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r0D2E);
                           /* IF CONDITION */
                           ir_expression *const r0D30 = equal(r0D24, body.constant(0u));
                           ir_if *f0D2F = new(mem_ctx) ir_if(operand(r0D30).val);
                           exec_list *const f0D2F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D2F->then_instructions;

                              body.emit(assign(r0D2B, r0D25, 0x01));

                              body.emit(assign(r0D2C, body.constant(0u), 0x01));

                              body.emit(assign(r0D2A, add(r0D2A, body.constant(int(-32))), 0x01));


                           body.instructions = f0D2F_parent_instructions;
                           body.emit(f0D2F);

                           /* END IF */

                           ir_variable *const r0D31 = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r0D31, r0D2B, 0x01));

                           ir_variable *const r0D32 = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r0D33 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r0D33);
                           /* IF CONDITION */
                           ir_expression *const r0D35 = equal(r0D2B, body.constant(0u));
                           ir_if *f0D34 = new(mem_ctx) ir_if(operand(r0D35).val);
                           exec_list *const f0D34_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D34->then_instructions;

                              body.emit(assign(r0D32, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0D34->else_instructions;

                              body.emit(assign(r0D33, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0D37 = bit_and(r0D2B, body.constant(4294901760u));
                              ir_expression *const r0D38 = equal(r0D37, body.constant(0u));
                              ir_if *f0D36 = new(mem_ctx) ir_if(operand(r0D38).val);
                              exec_list *const f0D36_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D36->then_instructions;

                                 body.emit(assign(r0D33, body.constant(int(16)), 0x01));

                                 body.emit(assign(r0D31, lshift(r0D2B, body.constant(int(16))), 0x01));


                              body.instructions = f0D36_parent_instructions;
                              body.emit(f0D36);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r0D3A = bit_and(r0D31, body.constant(4278190080u));
                              ir_expression *const r0D3B = equal(r0D3A, body.constant(0u));
                              ir_if *f0D39 = new(mem_ctx) ir_if(operand(r0D3B).val);
                              exec_list *const f0D39_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D39->then_instructions;

                                 body.emit(assign(r0D33, add(r0D33, body.constant(int(8))), 0x01));

                                 body.emit(assign(r0D31, lshift(r0D31, body.constant(int(8))), 0x01));


                              body.instructions = f0D39_parent_instructions;
                              body.emit(f0D39);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r0D3D = bit_and(r0D31, body.constant(4026531840u));
                              ir_expression *const r0D3E = equal(r0D3D, body.constant(0u));
                              ir_if *f0D3C = new(mem_ctx) ir_if(operand(r0D3E).val);
                              exec_list *const f0D3C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D3C->then_instructions;

                                 body.emit(assign(r0D33, add(r0D33, body.constant(int(4))), 0x01));

                                 body.emit(assign(r0D31, lshift(r0D31, body.constant(int(4))), 0x01));


                              body.instructions = f0D3C_parent_instructions;
                              body.emit(f0D3C);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r0D40 = bit_and(r0D31, body.constant(3221225472u));
                              ir_expression *const r0D41 = equal(r0D40, body.constant(0u));
                              ir_if *f0D3F = new(mem_ctx) ir_if(operand(r0D41).val);
                              exec_list *const f0D3F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D3F->then_instructions;

                                 body.emit(assign(r0D33, add(r0D33, body.constant(int(2))), 0x01));

                                 body.emit(assign(r0D31, lshift(r0D31, body.constant(int(2))), 0x01));


                              body.instructions = f0D3F_parent_instructions;
                              body.emit(f0D3F);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r0D43 = bit_and(r0D31, body.constant(2147483648u));
                              ir_expression *const r0D44 = equal(r0D43, body.constant(0u));
                              ir_if *f0D42 = new(mem_ctx) ir_if(operand(r0D44).val);
                              exec_list *const f0D42_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D42->then_instructions;

                                 body.emit(assign(r0D33, add(r0D33, body.constant(int(1))), 0x01));


                              body.instructions = f0D42_parent_instructions;
                              body.emit(f0D42);

                              /* END IF */

                              body.emit(assign(r0D32, r0D33, 0x01));


                           body.instructions = f0D34_parent_instructions;
                           body.emit(f0D34);

                           /* END IF */

                           body.emit(assign(r0D2E, add(r0D32, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0D46 = lequal(body.constant(int(0)), r0D2E);
                           ir_if *f0D45 = new(mem_ctx) ir_if(operand(r0D46).val);
                           exec_list *const f0D45_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D45->then_instructions;

                              body.emit(assign(r0D2D, body.constant(0u), 0x01));

                              ir_variable *const r0D47 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r0D47, lshift(r0D2C, r0D2E), 0x01));

                              ir_variable *const r0D48 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0D4A = equal(r0D2E, body.constant(int(0)));
                              ir_if *f0D49 = new(mem_ctx) ir_if(operand(r0D4A).val);
                              exec_list *const f0D49_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D49->then_instructions;

                                 body.emit(assign(r0D48, r0D2B, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D49->else_instructions;

                                 ir_expression *const r0D4B = lshift(r0D2B, r0D2E);
                                 ir_expression *const r0D4C = neg(r0D2E);
                                 ir_expression *const r0D4D = bit_and(r0D4C, body.constant(int(31)));
                                 ir_expression *const r0D4E = rshift(r0D2C, r0D4D);
                                 body.emit(assign(r0D48, bit_or(r0D4B, r0D4E), 0x01));


                              body.instructions = f0D49_parent_instructions;
                              body.emit(f0D49);

                              /* END IF */

                              body.emit(assign(r0D2B, r0D48, 0x01));

                              body.emit(assign(r0D2C, r0D47, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0D45->else_instructions;

                              ir_variable *const r0D4F = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r0D4F, body.constant(0u), 0x01));

                              ir_variable *const r0D50 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r0D50, neg(r0D2E), 0x01));

                              ir_variable *const r0D51 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r0D51);
                              ir_variable *const r0D52 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r0D52);
                              ir_variable *const r0D53 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r0D53);
                              ir_variable *const r0D54 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r0D55 = neg(r0D50);
                              body.emit(assign(r0D54, bit_and(r0D55, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0D57 = equal(r0D50, body.constant(int(0)));
                              ir_if *f0D56 = new(mem_ctx) ir_if(operand(r0D57).val);
                              exec_list *const f0D56_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D56->then_instructions;

                                 body.emit(assign(r0D51, r0D4F, 0x01));

                                 body.emit(assign(r0D52, r0D2C, 0x01));

                                 body.emit(assign(r0D53, r0D2B, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D56->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0D59 = less(r0D50, body.constant(int(32)));
                                 ir_if *f0D58 = new(mem_ctx) ir_if(operand(r0D59).val);
                                 exec_list *const f0D58_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0D58->then_instructions;

                                    body.emit(assign(r0D51, lshift(r0D2C, r0D54), 0x01));

                                    ir_expression *const r0D5A = lshift(r0D2B, r0D54);
                                    ir_expression *const r0D5B = rshift(r0D2C, r0D50);
                                    body.emit(assign(r0D52, bit_or(r0D5A, r0D5B), 0x01));

                                    body.emit(assign(r0D53, rshift(r0D2B, r0D50), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0D58->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r0D5D = equal(r0D50, body.constant(int(32)));
                                    ir_if *f0D5C = new(mem_ctx) ir_if(operand(r0D5D).val);
                                    exec_list *const f0D5C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0D5C->then_instructions;

                                       body.emit(assign(r0D51, r0D2C, 0x01));

                                       body.emit(assign(r0D52, r0D2B, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0D5C->else_instructions;

                                       body.emit(assign(r0D4F, bit_or(body.constant(0u), r0D2C), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r0D5F = less(r0D50, body.constant(int(64)));
                                       ir_if *f0D5E = new(mem_ctx) ir_if(operand(r0D5F).val);
                                       exec_list *const f0D5E_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0D5E->then_instructions;

                                          body.emit(assign(r0D51, lshift(r0D2B, r0D54), 0x01));

                                          ir_expression *const r0D60 = bit_and(r0D50, body.constant(int(31)));
                                          body.emit(assign(r0D52, rshift(r0D2B, r0D60), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0D5E->else_instructions;

                                          ir_variable *const r0D61 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r0D63 = equal(r0D50, body.constant(int(64)));
                                          ir_if *f0D62 = new(mem_ctx) ir_if(operand(r0D63).val);
                                          exec_list *const f0D62_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0D62->then_instructions;

                                             body.emit(assign(r0D61, r0D2B, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0D62->else_instructions;

                                             ir_expression *const r0D64 = nequal(r0D2B, body.constant(0u));
                                             ir_expression *const r0D65 = expr(ir_unop_b2i, r0D64);
                                             body.emit(assign(r0D61, expr(ir_unop_i2u, r0D65), 0x01));


                                          body.instructions = f0D62_parent_instructions;
                                          body.emit(f0D62);

                                          /* END IF */

                                          body.emit(assign(r0D51, r0D61, 0x01));

                                          body.emit(assign(r0D52, body.constant(0u), 0x01));


                                       body.instructions = f0D5E_parent_instructions;
                                       body.emit(f0D5E);

                                       /* END IF */


                                    body.instructions = f0D5C_parent_instructions;
                                    body.emit(f0D5C);

                                    /* END IF */

                                    body.emit(assign(r0D53, body.constant(0u), 0x01));


                                 body.instructions = f0D58_parent_instructions;
                                 body.emit(f0D58);

                                 /* END IF */

                                 ir_expression *const r0D66 = nequal(r0D4F, body.constant(0u));
                                 ir_expression *const r0D67 = expr(ir_unop_b2i, r0D66);
                                 ir_expression *const r0D68 = expr(ir_unop_i2u, r0D67);
                                 body.emit(assign(r0D51, bit_or(r0D51, r0D68), 0x01));


                              body.instructions = f0D56_parent_instructions;
                              body.emit(f0D56);

                              /* END IF */

                              body.emit(assign(r0D2B, r0D53, 0x01));

                              body.emit(assign(r0D2C, r0D52, 0x01));

                              body.emit(assign(r0D2D, r0D51, 0x01));


                           body.instructions = f0D45_parent_instructions;
                           body.emit(f0D45);

                           /* END IF */

                           body.emit(assign(r0D2A, sub(r0D2A, r0D2E), 0x01));

                           ir_variable *const r0D69 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r0D69, r0D2A, 0x01));

                           ir_variable *const r0D6A = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r0D6A, r0D2B, 0x01));

                           ir_variable *const r0D6B = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r0D6B, r0D2C, 0x01));

                           ir_variable *const r0D6C = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r0D6C, r0D2D, 0x01));

                           ir_variable *const r0D6D = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r0D6D, body.constant(true), 0x01));

                           ir_variable *const r0D6E = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r0D6F = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r0D6F);
                           ir_expression *const r0D70 = expr(ir_unop_u2i, r0D2D);
                           body.emit(assign(r0D6F, less(r0D70, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0D72 = lequal(body.constant(int(2045)), r0D2A);
                           ir_if *f0D71 = new(mem_ctx) ir_if(operand(r0D72).val);
                           exec_list *const f0D71_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D71->then_instructions;

                              ir_variable *const r0D73 = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0D75 = less(body.constant(int(2045)), r0D2A);
                              ir_if *f0D74 = new(mem_ctx) ir_if(operand(r0D75).val);
                              exec_list *const f0D74_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D74->then_instructions;

                                 body.emit(assign(r0D73, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D74->else_instructions;

                                 ir_variable *const r0D76 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0D78 = equal(r0D2A, body.constant(int(2045)));
                                 ir_if *f0D77 = new(mem_ctx) ir_if(operand(r0D78).val);
                                 exec_list *const f0D77_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0D77->then_instructions;

                                    ir_expression *const r0D79 = equal(body.constant(2097151u), r0D2B);
                                    ir_expression *const r0D7A = equal(body.constant(4294967295u), r0D2C);
                                    body.emit(assign(r0D76, logic_and(r0D79, r0D7A), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0D77->else_instructions;

                                    body.emit(assign(r0D76, body.constant(false), 0x01));


                                 body.instructions = f0D77_parent_instructions;
                                 body.emit(f0D77);

                                 /* END IF */

                                 body.emit(assign(r0D73, logic_and(r0D76, r0D6F), 0x01));


                              body.instructions = f0D74_parent_instructions;
                              body.emit(f0D74);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f0D7B = new(mem_ctx) ir_if(operand(r0D73).val);
                              exec_list *const f0D7B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D7B->then_instructions;

                                 ir_variable *const r0D7C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r0D7C);
                                 ir_expression *const r0D7D = lshift(r0999, body.constant(int(31)));
                                 body.emit(assign(r0D7C, add(r0D7D, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r0D7C, body.constant(0u), 0x01));

                                 body.emit(assign(r0D6E, r0D7C, 0x03));

                                 body.emit(assign(r0D6D, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D7B->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0D7F = less(r0D2A, body.constant(int(0)));
                                 ir_if *f0D7E = new(mem_ctx) ir_if(operand(r0D7F).val);
                                 exec_list *const f0D7E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0D7E->then_instructions;

                                    ir_variable *const r0D80 = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r0D80, r0D2D, 0x01));

                                    ir_variable *const r0D81 = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r0D81, neg(r0D2A), 0x01));

                                    ir_variable *const r0D82 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r0D82);
                                    ir_variable *const r0D83 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r0D83);
                                    ir_variable *const r0D84 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r0D84);
                                    ir_variable *const r0D85 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r0D86 = neg(r0D81);
                                    body.emit(assign(r0D85, bit_and(r0D86, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r0D88 = equal(r0D81, body.constant(int(0)));
                                    ir_if *f0D87 = new(mem_ctx) ir_if(operand(r0D88).val);
                                    exec_list *const f0D87_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0D87->then_instructions;

                                       body.emit(assign(r0D82, r0D2D, 0x01));

                                       body.emit(assign(r0D83, r0D2C, 0x01));

                                       body.emit(assign(r0D84, r0D2B, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0D87->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r0D8A = less(r0D81, body.constant(int(32)));
                                       ir_if *f0D89 = new(mem_ctx) ir_if(operand(r0D8A).val);
                                       exec_list *const f0D89_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0D89->then_instructions;

                                          body.emit(assign(r0D82, lshift(r0D2C, r0D85), 0x01));

                                          ir_expression *const r0D8B = lshift(r0D2B, r0D85);
                                          ir_expression *const r0D8C = rshift(r0D2C, r0D81);
                                          body.emit(assign(r0D83, bit_or(r0D8B, r0D8C), 0x01));

                                          body.emit(assign(r0D84, rshift(r0D2B, r0D81), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0D89->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r0D8E = equal(r0D81, body.constant(int(32)));
                                          ir_if *f0D8D = new(mem_ctx) ir_if(operand(r0D8E).val);
                                          exec_list *const f0D8D_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0D8D->then_instructions;

                                             body.emit(assign(r0D82, r0D2C, 0x01));

                                             body.emit(assign(r0D83, r0D2B, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0D8D->else_instructions;

                                             body.emit(assign(r0D80, bit_or(r0D2D, r0D2C), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r0D90 = less(r0D81, body.constant(int(64)));
                                             ir_if *f0D8F = new(mem_ctx) ir_if(operand(r0D90).val);
                                             exec_list *const f0D8F_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f0D8F->then_instructions;

                                                body.emit(assign(r0D82, lshift(r0D2B, r0D85), 0x01));

                                                ir_expression *const r0D91 = bit_and(r0D81, body.constant(int(31)));
                                                body.emit(assign(r0D83, rshift(r0D2B, r0D91), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f0D8F->else_instructions;

                                                ir_variable *const r0D92 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r0D94 = equal(r0D81, body.constant(int(64)));
                                                ir_if *f0D93 = new(mem_ctx) ir_if(operand(r0D94).val);
                                                exec_list *const f0D93_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f0D93->then_instructions;

                                                   body.emit(assign(r0D92, r0D2B, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f0D93->else_instructions;

                                                   ir_expression *const r0D95 = nequal(r0D2B, body.constant(0u));
                                                   ir_expression *const r0D96 = expr(ir_unop_b2i, r0D95);
                                                   body.emit(assign(r0D92, expr(ir_unop_i2u, r0D96), 0x01));


                                                body.instructions = f0D93_parent_instructions;
                                                body.emit(f0D93);

                                                /* END IF */

                                                body.emit(assign(r0D82, r0D92, 0x01));

                                                body.emit(assign(r0D83, body.constant(0u), 0x01));


                                             body.instructions = f0D8F_parent_instructions;
                                             body.emit(f0D8F);

                                             /* END IF */


                                          body.instructions = f0D8D_parent_instructions;
                                          body.emit(f0D8D);

                                          /* END IF */

                                          body.emit(assign(r0D84, body.constant(0u), 0x01));


                                       body.instructions = f0D89_parent_instructions;
                                       body.emit(f0D89);

                                       /* END IF */

                                       ir_expression *const r0D97 = nequal(r0D80, body.constant(0u));
                                       ir_expression *const r0D98 = expr(ir_unop_b2i, r0D97);
                                       ir_expression *const r0D99 = expr(ir_unop_i2u, r0D98);
                                       body.emit(assign(r0D82, bit_or(r0D82, r0D99), 0x01));


                                    body.instructions = f0D87_parent_instructions;
                                    body.emit(f0D87);

                                    /* END IF */

                                    body.emit(assign(r0D6A, r0D84, 0x01));

                                    body.emit(assign(r0D6B, r0D83, 0x01));

                                    body.emit(assign(r0D6C, r0D82, 0x01));

                                    body.emit(assign(r0D69, body.constant(int(0)), 0x01));

                                    body.emit(assign(r0D6F, less(r0D82, body.constant(0u)), 0x01));


                                 body.instructions = f0D7E_parent_instructions;
                                 body.emit(f0D7E);

                                 /* END IF */


                              body.instructions = f0D7B_parent_instructions;
                              body.emit(f0D7B);

                              /* END IF */


                           body.instructions = f0D71_parent_instructions;
                           body.emit(f0D71);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f0D9A = new(mem_ctx) ir_if(operand(r0D6D).val);
                           exec_list *const f0D9A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D9A->then_instructions;

                              /* IF CONDITION */
                              ir_if *f0D9B = new(mem_ctx) ir_if(operand(r0D6F).val);
                              exec_list *const f0D9B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D9B->then_instructions;

                                 ir_variable *const r0D9C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r0D9C, add(r0D6B, body.constant(1u)), 0x01));

                                 ir_expression *const r0D9D = less(r0D9C, r0D6B);
                                 ir_expression *const r0D9E = expr(ir_unop_b2i, r0D9D);
                                 ir_expression *const r0D9F = expr(ir_unop_i2u, r0D9E);
                                 body.emit(assign(r0D6A, add(r0D6A, r0D9F), 0x01));

                                 ir_expression *const r0DA0 = equal(r0D6C, body.constant(0u));
                                 ir_expression *const r0DA1 = expr(ir_unop_b2i, r0DA0);
                                 ir_expression *const r0DA2 = expr(ir_unop_i2u, r0DA1);
                                 ir_expression *const r0DA3 = add(r0D6C, r0DA2);
                                 ir_expression *const r0DA4 = bit_and(r0DA3, body.constant(1u));
                                 ir_expression *const r0DA5 = expr(ir_unop_bit_not, r0DA4);
                                 body.emit(assign(r0D6B, bit_and(r0D9C, r0DA5), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D9B->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0DA7 = bit_or(r0D6A, r0D6B);
                                 ir_expression *const r0DA8 = equal(r0DA7, body.constant(0u));
                                 ir_if *f0DA6 = new(mem_ctx) ir_if(operand(r0DA8).val);
                                 exec_list *const f0DA6_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0DA6->then_instructions;

                                    body.emit(assign(r0D69, body.constant(int(0)), 0x01));


                                 body.instructions = f0DA6_parent_instructions;
                                 body.emit(f0DA6);

                                 /* END IF */


                              body.instructions = f0D9B_parent_instructions;
                              body.emit(f0D9B);

                              /* END IF */

                              ir_variable *const r0DA9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r0DA9);
                              ir_expression *const r0DAA = lshift(r0999, body.constant(int(31)));
                              ir_expression *const r0DAB = expr(ir_unop_i2u, r0D69);
                              ir_expression *const r0DAC = lshift(r0DAB, body.constant(int(20)));
                              ir_expression *const r0DAD = add(r0DAA, r0DAC);
                              body.emit(assign(r0DA9, add(r0DAD, r0D6A), 0x02));

                              body.emit(assign(r0DA9, r0D6B, 0x01));

                              body.emit(assign(r0D6E, r0DA9, 0x03));

                              body.emit(assign(r0D6D, body.constant(false), 0x01));


                           body.instructions = f0D9A_parent_instructions;
                           body.emit(f0D9A);

                           /* END IF */

                           body.emit(assign(r099A, r0D6E, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0D22->else_instructions;

                           ir_variable *const r0DAE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r0DAE);
                           body.emit(assign(r0DAE, body.constant(0u), 0x02));

                           body.emit(assign(r0DAE, body.constant(0u), 0x01));

                           body.emit(assign(r099A, r0DAE, 0x03));


                        body.instructions = f0D22_parent_instructions;
                        body.emit(f0D22);

                        /* END IF */


                     body.instructions = f0C96_parent_instructions;
                     body.emit(f0C96);

                     /* END IF */


                  body.instructions = f0C0A_parent_instructions;
                  body.emit(f0C0A);

                  /* END IF */


               body.instructions = f0B7E_parent_instructions;
               body.emit(f0B7E);

               /* END IF */


            body.instructions = f0B57_parent_instructions;
            body.emit(f0B57);

            /* END IF */


         body.instructions = f0A83_parent_instructions;
         body.emit(f0A83);

         /* END IF */


      body.instructions = f09B3_parent_instructions;
      body.emit(f09B3);

      /* END IF */

      body.emit(assign(r07EB, r099A, 0x03));


   body.instructions = f07EE_parent_instructions;
   body.emit(f07EE);

   /* END IF */

   body.emit(ret(r07EB));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fsub64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0DAF = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0DAF);
   ir_variable *const r0DB0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0DB0);
   ir_variable *const r0DB1 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r0DB2 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r0DB2, rshift(swizzle_y(r0DAF), body.constant(int(31))), 0x01));

   ir_variable *const r0DB3 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r0DB3, rshift(swizzle_y(r0DB0), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r0DB5 = equal(r0DB2, r0DB3);
   ir_if *f0DB4 = new(mem_ctx) ir_if(operand(r0DB5).val);
   exec_list *const f0DB4_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0DB4->then_instructions;

      ir_variable *const r0DB6 = body.make_temp(glsl_type::uint_type, "zSign");
      body.emit(assign(r0DB6, r0DB2, 0x01));

      ir_variable *const r0DB7 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r0DB8 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r0DB8);
      ir_variable *const r0DB9 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
      body.emit(r0DB9);
      ir_variable *const r0DBA = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
      body.emit(r0DBA);
      ir_variable *const r0DBB = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
      body.emit(r0DBB);
      ir_variable *const r0DBC = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
      body.emit(r0DBC);
      ir_variable *const r0DBD = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
      body.emit(r0DBD);
      ir_variable *const r0DBE = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
      body.emit(r0DBE);
      ir_variable *const r0DBF = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r0DBF);
      ir_variable *const r0DC0 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r0DC1 = rshift(swizzle_y(r0DAF), body.constant(int(20)));
      ir_expression *const r0DC2 = bit_and(r0DC1, body.constant(2047u));
      body.emit(assign(r0DC0, expr(ir_unop_u2i, r0DC2), 0x01));

      body.emit(assign(r0DBA, r0DC0, 0x01));

      ir_variable *const r0DC3 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r0DC4 = rshift(swizzle_y(r0DB0), body.constant(int(20)));
      ir_expression *const r0DC5 = bit_and(r0DC4, body.constant(2047u));
      body.emit(assign(r0DC3, expr(ir_unop_u2i, r0DC5), 0x01));

      body.emit(assign(r0DB9, r0DC3, 0x01));

      body.emit(assign(r0DB8, sub(r0DC0, r0DC3), 0x01));

      ir_variable *const r0DC6 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r0DC6, lshift(swizzle_x(r0DAF), body.constant(int(10))), 0x01));

      ir_variable *const r0DC7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r0DC8 = bit_and(swizzle_y(r0DAF), body.constant(1048575u));
      ir_expression *const r0DC9 = lshift(r0DC8, body.constant(int(10)));
      ir_expression *const r0DCA = rshift(swizzle_x(r0DAF), body.constant(int(22)));
      body.emit(assign(r0DC7, bit_or(r0DC9, r0DCA), 0x01));

      body.emit(assign(r0DBD, r0DC7, 0x01));

      body.emit(assign(r0DBE, r0DC6, 0x01));

      ir_variable *const r0DCB = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r0DCB, lshift(swizzle_x(r0DB0), body.constant(int(10))), 0x01));

      ir_variable *const r0DCC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r0DCD = bit_and(swizzle_y(r0DB0), body.constant(1048575u));
      ir_expression *const r0DCE = lshift(r0DCD, body.constant(int(10)));
      ir_expression *const r0DCF = rshift(swizzle_x(r0DB0), body.constant(int(22)));
      body.emit(assign(r0DCC, bit_or(r0DCE, r0DCF), 0x01));

      body.emit(assign(r0DBB, r0DCC, 0x01));

      body.emit(assign(r0DBC, r0DCB, 0x01));

      /* IF CONDITION */
      ir_expression *const r0DD1 = less(body.constant(int(0)), r0DB8);
      ir_if *f0DD0 = new(mem_ctx) ir_if(operand(r0DD1).val);
      exec_list *const f0DD0_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0DD0->then_instructions;

         /* IF CONDITION */
         ir_expression *const r0DD3 = equal(r0DC0, body.constant(int(2047)));
         ir_if *f0DD2 = new(mem_ctx) ir_if(operand(r0DD3).val);
         exec_list *const f0DD2_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0DD2->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0DD5 = bit_or(r0DC7, r0DC6);
            ir_expression *const r0DD6 = nequal(r0DD5, body.constant(0u));
            ir_if *f0DD4 = new(mem_ctx) ir_if(operand(r0DD6).val);
            exec_list *const f0DD4_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0DD4->then_instructions;

               ir_variable *const r0DD7 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r0DD7, swizzle_x(r0DAF), 0x01));

               ir_variable *const r0DD8 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r0DD8, swizzle_x(r0DB0), 0x01));

               ir_variable *const r0DD9 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0DDA = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r0DDB = rshift(swizzle_y(r0DAF), body.constant(int(19)));
               ir_expression *const r0DDC = bit_and(r0DDB, body.constant(4095u));
               ir_expression *const r0DDD = equal(r0DDC, body.constant(4094u));
               ir_expression *const r0DDE = nequal(swizzle_x(r0DAF), body.constant(0u));
               ir_expression *const r0DDF = bit_and(swizzle_y(r0DAF), body.constant(524287u));
               ir_expression *const r0DE0 = nequal(r0DDF, body.constant(0u));
               ir_expression *const r0DE1 = logic_or(r0DDE, r0DE0);
               body.emit(assign(r0DDA, logic_and(r0DDD, r0DE1), 0x01));

               ir_variable *const r0DE2 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r0DE3 = lshift(swizzle_y(r0DB0), body.constant(int(1)));
               ir_expression *const r0DE4 = lequal(body.constant(4292870144u), r0DE3);
               ir_expression *const r0DE5 = nequal(swizzle_x(r0DB0), body.constant(0u));
               ir_expression *const r0DE6 = bit_and(swizzle_y(r0DB0), body.constant(1048575u));
               ir_expression *const r0DE7 = nequal(r0DE6, body.constant(0u));
               ir_expression *const r0DE8 = logic_or(r0DE5, r0DE7);
               body.emit(assign(r0DE2, logic_and(r0DE4, r0DE8), 0x01));

               body.emit(assign(r0DD7, bit_or(swizzle_y(r0DAF), body.constant(524288u)), 0x02));

               body.emit(assign(r0DD8, bit_or(swizzle_y(r0DB0), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r0DEA = lshift(swizzle_y(r0DAF), body.constant(int(1)));
               ir_expression *const r0DEB = lequal(body.constant(4292870144u), r0DEA);
               ir_expression *const r0DEC = nequal(swizzle_x(r0DAF), body.constant(0u));
               ir_expression *const r0DED = bit_and(swizzle_y(r0DAF), body.constant(1048575u));
               ir_expression *const r0DEE = nequal(r0DED, body.constant(0u));
               ir_expression *const r0DEF = logic_or(r0DEC, r0DEE);
               ir_expression *const r0DF0 = logic_and(r0DEB, r0DEF);
               ir_if *f0DE9 = new(mem_ctx) ir_if(operand(r0DF0).val);
               exec_list *const f0DE9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0DE9->then_instructions;

                  ir_variable *const r0DF1 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0DF3 = logic_and(r0DDA, r0DE2);
                  ir_if *f0DF2 = new(mem_ctx) ir_if(operand(r0DF3).val);
                  exec_list *const f0DF2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0DF2->then_instructions;

                     body.emit(assign(r0DF1, r0DD8, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0DF2->else_instructions;

                     body.emit(assign(r0DF1, r0DD7, 0x03));


                  body.instructions = f0DF2_parent_instructions;
                  body.emit(f0DF2);

                  /* END IF */

                  body.emit(assign(r0DD9, r0DF1, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0DE9->else_instructions;

                  body.emit(assign(r0DD9, r0DD8, 0x03));


               body.instructions = f0DE9_parent_instructions;
               body.emit(f0DE9);

               /* END IF */

               body.emit(assign(r0DB7, r0DD9, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0DD4->else_instructions;

               body.emit(assign(r0DB7, r0DAF, 0x03));


            body.instructions = f0DD4_parent_instructions;
            body.emit(f0DD4);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0DD2->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0DF5 = equal(r0DC3, body.constant(int(0)));
            ir_if *f0DF4 = new(mem_ctx) ir_if(operand(r0DF5).val);
            exec_list *const f0DF4_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0DF4->then_instructions;

               body.emit(assign(r0DB8, add(r0DB8, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0DF4->else_instructions;

               body.emit(assign(r0DBB, bit_or(r0DCC, body.constant(1073741824u)), 0x01));


            body.instructions = f0DF4_parent_instructions;
            body.emit(f0DF4);

            /* END IF */

            ir_variable *const r0DF6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r0DF6);
            ir_variable *const r0DF7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r0DF7);
            ir_variable *const r0DF8 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r0DF9 = neg(r0DB8);
            body.emit(assign(r0DF8, bit_and(r0DF9, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0DFB = equal(r0DB8, body.constant(int(0)));
            ir_if *f0DFA = new(mem_ctx) ir_if(operand(r0DFB).val);
            exec_list *const f0DFA_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0DFA->then_instructions;

               body.emit(assign(r0DF6, r0DCB, 0x01));

               body.emit(assign(r0DF7, r0DBB, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0DFA->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0DFD = less(r0DB8, body.constant(int(32)));
               ir_if *f0DFC = new(mem_ctx) ir_if(operand(r0DFD).val);
               exec_list *const f0DFC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0DFC->then_instructions;

                  ir_expression *const r0DFE = lshift(r0DBB, r0DF8);
                  ir_expression *const r0DFF = rshift(r0DCB, r0DB8);
                  ir_expression *const r0E00 = bit_or(r0DFE, r0DFF);
                  ir_expression *const r0E01 = lshift(r0DCB, r0DF8);
                  ir_expression *const r0E02 = nequal(r0E01, body.constant(0u));
                  ir_expression *const r0E03 = expr(ir_unop_b2i, r0E02);
                  ir_expression *const r0E04 = expr(ir_unop_i2u, r0E03);
                  body.emit(assign(r0DF6, bit_or(r0E00, r0E04), 0x01));

                  body.emit(assign(r0DF7, rshift(r0DBB, r0DB8), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0DFC->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0E06 = equal(r0DB8, body.constant(int(32)));
                  ir_if *f0E05 = new(mem_ctx) ir_if(operand(r0E06).val);
                  exec_list *const f0E05_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0E05->then_instructions;

                     ir_expression *const r0E07 = nequal(r0DCB, body.constant(0u));
                     ir_expression *const r0E08 = expr(ir_unop_b2i, r0E07);
                     ir_expression *const r0E09 = expr(ir_unop_i2u, r0E08);
                     body.emit(assign(r0DF6, bit_or(r0DBB, r0E09), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0E05->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0E0B = less(r0DB8, body.constant(int(64)));
                     ir_if *f0E0A = new(mem_ctx) ir_if(operand(r0E0B).val);
                     exec_list *const f0E0A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0E0A->then_instructions;

                        ir_expression *const r0E0C = bit_and(r0DB8, body.constant(int(31)));
                        ir_expression *const r0E0D = rshift(r0DBB, r0E0C);
                        ir_expression *const r0E0E = lshift(r0DBB, r0DF8);
                        ir_expression *const r0E0F = bit_or(r0E0E, r0DCB);
                        ir_expression *const r0E10 = nequal(r0E0F, body.constant(0u));
                        ir_expression *const r0E11 = expr(ir_unop_b2i, r0E10);
                        ir_expression *const r0E12 = expr(ir_unop_i2u, r0E11);
                        body.emit(assign(r0DF6, bit_or(r0E0D, r0E12), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0E0A->else_instructions;

                        ir_expression *const r0E13 = bit_or(r0DBB, r0DCB);
                        ir_expression *const r0E14 = nequal(r0E13, body.constant(0u));
                        ir_expression *const r0E15 = expr(ir_unop_b2i, r0E14);
                        body.emit(assign(r0DF6, expr(ir_unop_i2u, r0E15), 0x01));


                     body.instructions = f0E0A_parent_instructions;
                     body.emit(f0E0A);

                     /* END IF */


                  body.instructions = f0E05_parent_instructions;
                  body.emit(f0E05);

                  /* END IF */

                  body.emit(assign(r0DF7, body.constant(0u), 0x01));


               body.instructions = f0DFC_parent_instructions;
               body.emit(f0DFC);

               /* END IF */


            body.instructions = f0DFA_parent_instructions;
            body.emit(f0DFA);

            /* END IF */

            body.emit(assign(r0DBB, r0DF7, 0x01));

            body.emit(assign(r0DBC, r0DF6, 0x01));

            body.emit(assign(r0DBD, bit_or(r0DC7, body.constant(1073741824u)), 0x01));

            ir_variable *const r0E16 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r0E17 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r0E17, sub(r0DC6, r0DF6), 0x01));

            ir_expression *const r0E18 = sub(r0DBD, r0DF7);
            ir_expression *const r0E19 = less(r0DC6, r0DF6);
            ir_expression *const r0E1A = expr(ir_unop_b2i, r0E19);
            ir_expression *const r0E1B = expr(ir_unop_i2u, r0E1A);
            body.emit(assign(r0E16, sub(r0E18, r0E1B), 0x01));

            body.emit(assign(r0DBF, add(r0DC0, body.constant(int(-1))), 0x01));

            ir_variable *const r0E1C = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0E1C, add(r0DBF, body.constant(int(-10))), 0x01));

            ir_variable *const r0E1D = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0E1D, r0E16, 0x01));

            ir_variable *const r0E1E = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0E1E, r0E17, 0x01));

            ir_variable *const r0E1F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
            body.emit(r0E1F);
            ir_variable *const r0E20 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0E20);
            /* IF CONDITION */
            ir_expression *const r0E22 = equal(r0E16, body.constant(0u));
            ir_if *f0E21 = new(mem_ctx) ir_if(operand(r0E22).val);
            exec_list *const f0E21_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0E21->then_instructions;

               body.emit(assign(r0E1D, r0E17, 0x01));

               body.emit(assign(r0E1E, body.constant(0u), 0x01));

               body.emit(assign(r0E1C, add(r0E1C, body.constant(int(-32))), 0x01));


            body.instructions = f0E21_parent_instructions;
            body.emit(f0E21);

            /* END IF */

            ir_variable *const r0E23 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r0E23, r0E1D, 0x01));

            ir_variable *const r0E24 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r0E25 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0E25);
            /* IF CONDITION */
            ir_expression *const r0E27 = equal(r0E1D, body.constant(0u));
            ir_if *f0E26 = new(mem_ctx) ir_if(operand(r0E27).val);
            exec_list *const f0E26_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0E26->then_instructions;

               body.emit(assign(r0E24, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0E26->else_instructions;

               body.emit(assign(r0E25, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r0E29 = bit_and(r0E1D, body.constant(4294901760u));
               ir_expression *const r0E2A = equal(r0E29, body.constant(0u));
               ir_if *f0E28 = new(mem_ctx) ir_if(operand(r0E2A).val);
               exec_list *const f0E28_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E28->then_instructions;

                  body.emit(assign(r0E25, body.constant(int(16)), 0x01));

                  body.emit(assign(r0E23, lshift(r0E1D, body.constant(int(16))), 0x01));


               body.instructions = f0E28_parent_instructions;
               body.emit(f0E28);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0E2C = bit_and(r0E23, body.constant(4278190080u));
               ir_expression *const r0E2D = equal(r0E2C, body.constant(0u));
               ir_if *f0E2B = new(mem_ctx) ir_if(operand(r0E2D).val);
               exec_list *const f0E2B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E2B->then_instructions;

                  body.emit(assign(r0E25, add(r0E25, body.constant(int(8))), 0x01));

                  body.emit(assign(r0E23, lshift(r0E23, body.constant(int(8))), 0x01));


               body.instructions = f0E2B_parent_instructions;
               body.emit(f0E2B);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0E2F = bit_and(r0E23, body.constant(4026531840u));
               ir_expression *const r0E30 = equal(r0E2F, body.constant(0u));
               ir_if *f0E2E = new(mem_ctx) ir_if(operand(r0E30).val);
               exec_list *const f0E2E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E2E->then_instructions;

                  body.emit(assign(r0E25, add(r0E25, body.constant(int(4))), 0x01));

                  body.emit(assign(r0E23, lshift(r0E23, body.constant(int(4))), 0x01));


               body.instructions = f0E2E_parent_instructions;
               body.emit(f0E2E);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0E32 = bit_and(r0E23, body.constant(3221225472u));
               ir_expression *const r0E33 = equal(r0E32, body.constant(0u));
               ir_if *f0E31 = new(mem_ctx) ir_if(operand(r0E33).val);
               exec_list *const f0E31_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E31->then_instructions;

                  body.emit(assign(r0E25, add(r0E25, body.constant(int(2))), 0x01));

                  body.emit(assign(r0E23, lshift(r0E23, body.constant(int(2))), 0x01));


               body.instructions = f0E31_parent_instructions;
               body.emit(f0E31);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0E35 = bit_and(r0E23, body.constant(2147483648u));
               ir_expression *const r0E36 = equal(r0E35, body.constant(0u));
               ir_if *f0E34 = new(mem_ctx) ir_if(operand(r0E36).val);
               exec_list *const f0E34_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E34->then_instructions;

                  body.emit(assign(r0E25, add(r0E25, body.constant(int(1))), 0x01));


               body.instructions = f0E34_parent_instructions;
               body.emit(f0E34);

               /* END IF */

               body.emit(assign(r0E24, r0E25, 0x01));


            body.instructions = f0E26_parent_instructions;
            body.emit(f0E26);

            /* END IF */

            body.emit(assign(r0E20, add(r0E24, body.constant(int(-11))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0E38 = lequal(body.constant(int(0)), r0E20);
            ir_if *f0E37 = new(mem_ctx) ir_if(operand(r0E38).val);
            exec_list *const f0E37_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0E37->then_instructions;

               body.emit(assign(r0E1F, body.constant(0u), 0x01));

               ir_variable *const r0E39 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r0E39, lshift(r0E1E, r0E20), 0x01));

               ir_variable *const r0E3A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r0E3C = equal(r0E20, body.constant(int(0)));
               ir_if *f0E3B = new(mem_ctx) ir_if(operand(r0E3C).val);
               exec_list *const f0E3B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E3B->then_instructions;

                  body.emit(assign(r0E3A, r0E1D, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0E3B->else_instructions;

                  ir_expression *const r0E3D = lshift(r0E1D, r0E20);
                  ir_expression *const r0E3E = neg(r0E20);
                  ir_expression *const r0E3F = bit_and(r0E3E, body.constant(int(31)));
                  ir_expression *const r0E40 = rshift(r0E1E, r0E3F);
                  body.emit(assign(r0E3A, bit_or(r0E3D, r0E40), 0x01));


               body.instructions = f0E3B_parent_instructions;
               body.emit(f0E3B);

               /* END IF */

               body.emit(assign(r0E1D, r0E3A, 0x01));

               body.emit(assign(r0E1E, r0E39, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0E37->else_instructions;

               ir_variable *const r0E41 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r0E41, body.constant(0u), 0x01));

               ir_variable *const r0E42 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0E42, neg(r0E20), 0x01));

               ir_variable *const r0E43 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r0E43);
               ir_variable *const r0E44 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0E44);
               ir_variable *const r0E45 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0E45);
               ir_variable *const r0E46 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0E47 = neg(r0E42);
               body.emit(assign(r0E46, bit_and(r0E47, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0E49 = equal(r0E42, body.constant(int(0)));
               ir_if *f0E48 = new(mem_ctx) ir_if(operand(r0E49).val);
               exec_list *const f0E48_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E48->then_instructions;

                  body.emit(assign(r0E43, r0E41, 0x01));

                  body.emit(assign(r0E44, r0E1E, 0x01));

                  body.emit(assign(r0E45, r0E1D, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0E48->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0E4B = less(r0E42, body.constant(int(32)));
                  ir_if *f0E4A = new(mem_ctx) ir_if(operand(r0E4B).val);
                  exec_list *const f0E4A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0E4A->then_instructions;

                     body.emit(assign(r0E43, lshift(r0E1E, r0E46), 0x01));

                     ir_expression *const r0E4C = lshift(r0E1D, r0E46);
                     ir_expression *const r0E4D = rshift(r0E1E, r0E42);
                     body.emit(assign(r0E44, bit_or(r0E4C, r0E4D), 0x01));

                     body.emit(assign(r0E45, rshift(r0E1D, r0E42), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0E4A->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0E4F = equal(r0E42, body.constant(int(32)));
                     ir_if *f0E4E = new(mem_ctx) ir_if(operand(r0E4F).val);
                     exec_list *const f0E4E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0E4E->then_instructions;

                        body.emit(assign(r0E43, r0E1E, 0x01));

                        body.emit(assign(r0E44, r0E1D, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0E4E->else_instructions;

                        body.emit(assign(r0E41, bit_or(body.constant(0u), r0E1E), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0E51 = less(r0E42, body.constant(int(64)));
                        ir_if *f0E50 = new(mem_ctx) ir_if(operand(r0E51).val);
                        exec_list *const f0E50_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0E50->then_instructions;

                           body.emit(assign(r0E43, lshift(r0E1D, r0E46), 0x01));

                           ir_expression *const r0E52 = bit_and(r0E42, body.constant(int(31)));
                           body.emit(assign(r0E44, rshift(r0E1D, r0E52), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0E50->else_instructions;

                           ir_variable *const r0E53 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0E55 = equal(r0E42, body.constant(int(64)));
                           ir_if *f0E54 = new(mem_ctx) ir_if(operand(r0E55).val);
                           exec_list *const f0E54_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0E54->then_instructions;

                              body.emit(assign(r0E53, r0E1D, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0E54->else_instructions;

                              ir_expression *const r0E56 = nequal(r0E1D, body.constant(0u));
                              ir_expression *const r0E57 = expr(ir_unop_b2i, r0E56);
                              body.emit(assign(r0E53, expr(ir_unop_i2u, r0E57), 0x01));


                           body.instructions = f0E54_parent_instructions;
                           body.emit(f0E54);

                           /* END IF */

                           body.emit(assign(r0E43, r0E53, 0x01));

                           body.emit(assign(r0E44, body.constant(0u), 0x01));


                        body.instructions = f0E50_parent_instructions;
                        body.emit(f0E50);

                        /* END IF */


                     body.instructions = f0E4E_parent_instructions;
                     body.emit(f0E4E);

                     /* END IF */

                     body.emit(assign(r0E45, body.constant(0u), 0x01));


                  body.instructions = f0E4A_parent_instructions;
                  body.emit(f0E4A);

                  /* END IF */

                  ir_expression *const r0E58 = nequal(r0E41, body.constant(0u));
                  ir_expression *const r0E59 = expr(ir_unop_b2i, r0E58);
                  ir_expression *const r0E5A = expr(ir_unop_i2u, r0E59);
                  body.emit(assign(r0E43, bit_or(r0E43, r0E5A), 0x01));


               body.instructions = f0E48_parent_instructions;
               body.emit(f0E48);

               /* END IF */

               body.emit(assign(r0E1D, r0E45, 0x01));

               body.emit(assign(r0E1E, r0E44, 0x01));

               body.emit(assign(r0E1F, r0E43, 0x01));


            body.instructions = f0E37_parent_instructions;
            body.emit(f0E37);

            /* END IF */

            body.emit(assign(r0E1C, sub(r0E1C, r0E20), 0x01));

            ir_variable *const r0E5B = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0E5B, r0E1C, 0x01));

            ir_variable *const r0E5C = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0E5C, r0E1D, 0x01));

            ir_variable *const r0E5D = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0E5D, r0E1E, 0x01));

            ir_variable *const r0E5E = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r0E5E, r0E1F, 0x01));

            ir_variable *const r0E5F = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r0E5F, body.constant(true), 0x01));

            ir_variable *const r0E60 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0E61 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r0E61);
            ir_expression *const r0E62 = expr(ir_unop_u2i, r0E1F);
            body.emit(assign(r0E61, less(r0E62, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0E64 = lequal(body.constant(int(2045)), r0E1C);
            ir_if *f0E63 = new(mem_ctx) ir_if(operand(r0E64).val);
            exec_list *const f0E63_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0E63->then_instructions;

               ir_variable *const r0E65 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0E67 = less(body.constant(int(2045)), r0E1C);
               ir_if *f0E66 = new(mem_ctx) ir_if(operand(r0E67).val);
               exec_list *const f0E66_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E66->then_instructions;

                  body.emit(assign(r0E65, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0E66->else_instructions;

                  ir_variable *const r0E68 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0E6A = equal(r0E1C, body.constant(int(2045)));
                  ir_if *f0E69 = new(mem_ctx) ir_if(operand(r0E6A).val);
                  exec_list *const f0E69_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0E69->then_instructions;

                     ir_expression *const r0E6B = equal(body.constant(2097151u), r0E1D);
                     ir_expression *const r0E6C = equal(body.constant(4294967295u), r0E1E);
                     body.emit(assign(r0E68, logic_and(r0E6B, r0E6C), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0E69->else_instructions;

                     body.emit(assign(r0E68, body.constant(false), 0x01));


                  body.instructions = f0E69_parent_instructions;
                  body.emit(f0E69);

                  /* END IF */

                  body.emit(assign(r0E65, logic_and(r0E68, r0E61), 0x01));


               body.instructions = f0E66_parent_instructions;
               body.emit(f0E66);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0E6D = new(mem_ctx) ir_if(operand(r0E65).val);
               exec_list *const f0E6D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E6D->then_instructions;

                  ir_variable *const r0E6E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0E6E);
                  ir_expression *const r0E6F = lshift(r0DB2, body.constant(int(31)));
                  body.emit(assign(r0E6E, add(r0E6F, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0E6E, body.constant(0u), 0x01));

                  body.emit(assign(r0E60, r0E6E, 0x03));

                  body.emit(assign(r0E5F, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0E6D->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0E71 = less(r0E1C, body.constant(int(0)));
                  ir_if *f0E70 = new(mem_ctx) ir_if(operand(r0E71).val);
                  exec_list *const f0E70_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0E70->then_instructions;

                     ir_variable *const r0E72 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0E72, r0E1F, 0x01));

                     ir_variable *const r0E73 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0E73, neg(r0E1C), 0x01));

                     ir_variable *const r0E74 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0E74);
                     ir_variable *const r0E75 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0E75);
                     ir_variable *const r0E76 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0E76);
                     ir_variable *const r0E77 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0E78 = neg(r0E73);
                     body.emit(assign(r0E77, bit_and(r0E78, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0E7A = equal(r0E73, body.constant(int(0)));
                     ir_if *f0E79 = new(mem_ctx) ir_if(operand(r0E7A).val);
                     exec_list *const f0E79_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0E79->then_instructions;

                        body.emit(assign(r0E74, r0E1F, 0x01));

                        body.emit(assign(r0E75, r0E1E, 0x01));

                        body.emit(assign(r0E76, r0E1D, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0E79->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0E7C = less(r0E73, body.constant(int(32)));
                        ir_if *f0E7B = new(mem_ctx) ir_if(operand(r0E7C).val);
                        exec_list *const f0E7B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0E7B->then_instructions;

                           body.emit(assign(r0E74, lshift(r0E1E, r0E77), 0x01));

                           ir_expression *const r0E7D = lshift(r0E1D, r0E77);
                           ir_expression *const r0E7E = rshift(r0E1E, r0E73);
                           body.emit(assign(r0E75, bit_or(r0E7D, r0E7E), 0x01));

                           body.emit(assign(r0E76, rshift(r0E1D, r0E73), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0E7B->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0E80 = equal(r0E73, body.constant(int(32)));
                           ir_if *f0E7F = new(mem_ctx) ir_if(operand(r0E80).val);
                           exec_list *const f0E7F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0E7F->then_instructions;

                              body.emit(assign(r0E74, r0E1E, 0x01));

                              body.emit(assign(r0E75, r0E1D, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0E7F->else_instructions;

                              body.emit(assign(r0E72, bit_or(r0E1F, r0E1E), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0E82 = less(r0E73, body.constant(int(64)));
                              ir_if *f0E81 = new(mem_ctx) ir_if(operand(r0E82).val);
                              exec_list *const f0E81_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0E81->then_instructions;

                                 body.emit(assign(r0E74, lshift(r0E1D, r0E77), 0x01));

                                 ir_expression *const r0E83 = bit_and(r0E73, body.constant(int(31)));
                                 body.emit(assign(r0E75, rshift(r0E1D, r0E83), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0E81->else_instructions;

                                 ir_variable *const r0E84 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0E86 = equal(r0E73, body.constant(int(64)));
                                 ir_if *f0E85 = new(mem_ctx) ir_if(operand(r0E86).val);
                                 exec_list *const f0E85_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0E85->then_instructions;

                                    body.emit(assign(r0E84, r0E1D, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0E85->else_instructions;

                                    ir_expression *const r0E87 = nequal(r0E1D, body.constant(0u));
                                    ir_expression *const r0E88 = expr(ir_unop_b2i, r0E87);
                                    body.emit(assign(r0E84, expr(ir_unop_i2u, r0E88), 0x01));


                                 body.instructions = f0E85_parent_instructions;
                                 body.emit(f0E85);

                                 /* END IF */

                                 body.emit(assign(r0E74, r0E84, 0x01));

                                 body.emit(assign(r0E75, body.constant(0u), 0x01));


                              body.instructions = f0E81_parent_instructions;
                              body.emit(f0E81);

                              /* END IF */


                           body.instructions = f0E7F_parent_instructions;
                           body.emit(f0E7F);

                           /* END IF */

                           body.emit(assign(r0E76, body.constant(0u), 0x01));


                        body.instructions = f0E7B_parent_instructions;
                        body.emit(f0E7B);

                        /* END IF */

                        ir_expression *const r0E89 = nequal(r0E72, body.constant(0u));
                        ir_expression *const r0E8A = expr(ir_unop_b2i, r0E89);
                        ir_expression *const r0E8B = expr(ir_unop_i2u, r0E8A);
                        body.emit(assign(r0E74, bit_or(r0E74, r0E8B), 0x01));


                     body.instructions = f0E79_parent_instructions;
                     body.emit(f0E79);

                     /* END IF */

                     body.emit(assign(r0E5C, r0E76, 0x01));

                     body.emit(assign(r0E5D, r0E75, 0x01));

                     body.emit(assign(r0E5E, r0E74, 0x01));

                     body.emit(assign(r0E5B, body.constant(int(0)), 0x01));

                     body.emit(assign(r0E61, less(r0E74, body.constant(0u)), 0x01));


                  body.instructions = f0E70_parent_instructions;
                  body.emit(f0E70);

                  /* END IF */


               body.instructions = f0E6D_parent_instructions;
               body.emit(f0E6D);

               /* END IF */


            body.instructions = f0E63_parent_instructions;
            body.emit(f0E63);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0E8C = new(mem_ctx) ir_if(operand(r0E5F).val);
            exec_list *const f0E8C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0E8C->then_instructions;

               /* IF CONDITION */
               ir_if *f0E8D = new(mem_ctx) ir_if(operand(r0E61).val);
               exec_list *const f0E8D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E8D->then_instructions;

                  ir_variable *const r0E8E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r0E8E, add(r0E5D, body.constant(1u)), 0x01));

                  ir_expression *const r0E8F = less(r0E8E, r0E5D);
                  ir_expression *const r0E90 = expr(ir_unop_b2i, r0E8F);
                  ir_expression *const r0E91 = expr(ir_unop_i2u, r0E90);
                  body.emit(assign(r0E5C, add(r0E5C, r0E91), 0x01));

                  ir_expression *const r0E92 = equal(r0E5E, body.constant(0u));
                  ir_expression *const r0E93 = expr(ir_unop_b2i, r0E92);
                  ir_expression *const r0E94 = expr(ir_unop_i2u, r0E93);
                  ir_expression *const r0E95 = add(r0E5E, r0E94);
                  ir_expression *const r0E96 = bit_and(r0E95, body.constant(1u));
                  ir_expression *const r0E97 = expr(ir_unop_bit_not, r0E96);
                  body.emit(assign(r0E5D, bit_and(r0E8E, r0E97), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0E8D->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0E99 = bit_or(r0E5C, r0E5D);
                  ir_expression *const r0E9A = equal(r0E99, body.constant(0u));
                  ir_if *f0E98 = new(mem_ctx) ir_if(operand(r0E9A).val);
                  exec_list *const f0E98_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0E98->then_instructions;

                     body.emit(assign(r0E5B, body.constant(int(0)), 0x01));


                  body.instructions = f0E98_parent_instructions;
                  body.emit(f0E98);

                  /* END IF */


               body.instructions = f0E8D_parent_instructions;
               body.emit(f0E8D);

               /* END IF */

               ir_variable *const r0E9B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0E9B);
               ir_expression *const r0E9C = lshift(r0DB2, body.constant(int(31)));
               ir_expression *const r0E9D = expr(ir_unop_i2u, r0E5B);
               ir_expression *const r0E9E = lshift(r0E9D, body.constant(int(20)));
               ir_expression *const r0E9F = add(r0E9C, r0E9E);
               body.emit(assign(r0E9B, add(r0E9F, r0E5C), 0x02));

               body.emit(assign(r0E9B, r0E5D, 0x01));

               body.emit(assign(r0E60, r0E9B, 0x03));

               body.emit(assign(r0E5F, body.constant(false), 0x01));


            body.instructions = f0E8C_parent_instructions;
            body.emit(f0E8C);

            /* END IF */

            body.emit(assign(r0DB7, r0E60, 0x03));


         body.instructions = f0DD2_parent_instructions;
         body.emit(f0DD2);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0DD0->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0EA1 = less(r0DB8, body.constant(int(0)));
         ir_if *f0EA0 = new(mem_ctx) ir_if(operand(r0EA1).val);
         exec_list *const f0EA0_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0EA0->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0EA3 = equal(r0DC3, body.constant(int(2047)));
            ir_if *f0EA2 = new(mem_ctx) ir_if(operand(r0EA3).val);
            exec_list *const f0EA2_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0EA2->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0EA5 = bit_or(r0DBB, r0DBC);
               ir_expression *const r0EA6 = nequal(r0EA5, body.constant(0u));
               ir_if *f0EA4 = new(mem_ctx) ir_if(operand(r0EA6).val);
               exec_list *const f0EA4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0EA4->then_instructions;

                  ir_variable *const r0EA7 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r0EA7, swizzle_x(r0DAF), 0x01));

                  ir_variable *const r0EA8 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r0EA8, swizzle_x(r0DB0), 0x01));

                  ir_variable *const r0EA9 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0EAA = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0EAB = rshift(swizzle_y(r0DAF), body.constant(int(19)));
                  ir_expression *const r0EAC = bit_and(r0EAB, body.constant(4095u));
                  ir_expression *const r0EAD = equal(r0EAC, body.constant(4094u));
                  ir_expression *const r0EAE = nequal(swizzle_x(r0DAF), body.constant(0u));
                  ir_expression *const r0EAF = bit_and(swizzle_y(r0DAF), body.constant(524287u));
                  ir_expression *const r0EB0 = nequal(r0EAF, body.constant(0u));
                  ir_expression *const r0EB1 = logic_or(r0EAE, r0EB0);
                  body.emit(assign(r0EAA, logic_and(r0EAD, r0EB1), 0x01));

                  ir_variable *const r0EB2 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0EB3 = lshift(swizzle_y(r0DB0), body.constant(int(1)));
                  ir_expression *const r0EB4 = lequal(body.constant(4292870144u), r0EB3);
                  ir_expression *const r0EB5 = nequal(swizzle_x(r0DB0), body.constant(0u));
                  ir_expression *const r0EB6 = bit_and(swizzle_y(r0DB0), body.constant(1048575u));
                  ir_expression *const r0EB7 = nequal(r0EB6, body.constant(0u));
                  ir_expression *const r0EB8 = logic_or(r0EB5, r0EB7);
                  body.emit(assign(r0EB2, logic_and(r0EB4, r0EB8), 0x01));

                  body.emit(assign(r0EA7, bit_or(swizzle_y(r0DAF), body.constant(524288u)), 0x02));

                  body.emit(assign(r0EA8, bit_or(swizzle_y(r0DB0), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r0EBA = lshift(swizzle_y(r0DAF), body.constant(int(1)));
                  ir_expression *const r0EBB = lequal(body.constant(4292870144u), r0EBA);
                  ir_expression *const r0EBC = nequal(swizzle_x(r0DAF), body.constant(0u));
                  ir_expression *const r0EBD = bit_and(swizzle_y(r0DAF), body.constant(1048575u));
                  ir_expression *const r0EBE = nequal(r0EBD, body.constant(0u));
                  ir_expression *const r0EBF = logic_or(r0EBC, r0EBE);
                  ir_expression *const r0EC0 = logic_and(r0EBB, r0EBF);
                  ir_if *f0EB9 = new(mem_ctx) ir_if(operand(r0EC0).val);
                  exec_list *const f0EB9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0EB9->then_instructions;

                     ir_variable *const r0EC1 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0EC3 = logic_and(r0EAA, r0EB2);
                     ir_if *f0EC2 = new(mem_ctx) ir_if(operand(r0EC3).val);
                     exec_list *const f0EC2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0EC2->then_instructions;

                        body.emit(assign(r0EC1, r0EA8, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0EC2->else_instructions;

                        body.emit(assign(r0EC1, r0EA7, 0x03));


                     body.instructions = f0EC2_parent_instructions;
                     body.emit(f0EC2);

                     /* END IF */

                     body.emit(assign(r0EA9, r0EC1, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0EB9->else_instructions;

                     body.emit(assign(r0EA9, r0EA8, 0x03));


                  body.instructions = f0EB9_parent_instructions;
                  body.emit(f0EB9);

                  /* END IF */

                  body.emit(assign(r0DB7, r0EA9, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0EA4->else_instructions;

                  ir_variable *const r0EC4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0EC4);
                  ir_expression *const r0EC5 = bit_xor(r0DB2, body.constant(1u));
                  ir_expression *const r0EC6 = lshift(r0EC5, body.constant(int(31)));
                  body.emit(assign(r0EC4, add(r0EC6, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0EC4, body.constant(0u), 0x01));

                  body.emit(assign(r0DB7, r0EC4, 0x03));


               body.instructions = f0EA4_parent_instructions;
               body.emit(f0EA4);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0EA2->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0EC8 = equal(r0DC0, body.constant(int(0)));
               ir_if *f0EC7 = new(mem_ctx) ir_if(operand(r0EC8).val);
               exec_list *const f0EC7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0EC7->then_instructions;

                  body.emit(assign(r0DB8, add(r0DB8, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0EC7->else_instructions;

                  body.emit(assign(r0DBD, bit_or(r0DBD, body.constant(1073741824u)), 0x01));


               body.instructions = f0EC7_parent_instructions;
               body.emit(f0EC7);

               /* END IF */

               ir_variable *const r0EC9 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0EC9, neg(r0DB8), 0x01));

               ir_variable *const r0ECA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0ECA);
               ir_variable *const r0ECB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0ECB);
               ir_variable *const r0ECC = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0ECD = neg(r0EC9);
               body.emit(assign(r0ECC, bit_and(r0ECD, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0ECF = equal(r0EC9, body.constant(int(0)));
               ir_if *f0ECE = new(mem_ctx) ir_if(operand(r0ECF).val);
               exec_list *const f0ECE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0ECE->then_instructions;

                  body.emit(assign(r0ECA, r0DC6, 0x01));

                  body.emit(assign(r0ECB, r0DBD, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0ECE->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0ED1 = less(r0EC9, body.constant(int(32)));
                  ir_if *f0ED0 = new(mem_ctx) ir_if(operand(r0ED1).val);
                  exec_list *const f0ED0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0ED0->then_instructions;

                     ir_expression *const r0ED2 = lshift(r0DBD, r0ECC);
                     ir_expression *const r0ED3 = rshift(r0DC6, r0EC9);
                     ir_expression *const r0ED4 = bit_or(r0ED2, r0ED3);
                     ir_expression *const r0ED5 = lshift(r0DC6, r0ECC);
                     ir_expression *const r0ED6 = nequal(r0ED5, body.constant(0u));
                     ir_expression *const r0ED7 = expr(ir_unop_b2i, r0ED6);
                     ir_expression *const r0ED8 = expr(ir_unop_i2u, r0ED7);
                     body.emit(assign(r0ECA, bit_or(r0ED4, r0ED8), 0x01));

                     body.emit(assign(r0ECB, rshift(r0DBD, r0EC9), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0ED0->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0EDA = equal(r0EC9, body.constant(int(32)));
                     ir_if *f0ED9 = new(mem_ctx) ir_if(operand(r0EDA).val);
                     exec_list *const f0ED9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0ED9->then_instructions;

                        ir_expression *const r0EDB = nequal(r0DC6, body.constant(0u));
                        ir_expression *const r0EDC = expr(ir_unop_b2i, r0EDB);
                        ir_expression *const r0EDD = expr(ir_unop_i2u, r0EDC);
                        body.emit(assign(r0ECA, bit_or(r0DBD, r0EDD), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0ED9->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0EDF = less(r0EC9, body.constant(int(64)));
                        ir_if *f0EDE = new(mem_ctx) ir_if(operand(r0EDF).val);
                        exec_list *const f0EDE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0EDE->then_instructions;

                           ir_expression *const r0EE0 = bit_and(r0EC9, body.constant(int(31)));
                           ir_expression *const r0EE1 = rshift(r0DBD, r0EE0);
                           ir_expression *const r0EE2 = lshift(r0DBD, r0ECC);
                           ir_expression *const r0EE3 = bit_or(r0EE2, r0DC6);
                           ir_expression *const r0EE4 = nequal(r0EE3, body.constant(0u));
                           ir_expression *const r0EE5 = expr(ir_unop_b2i, r0EE4);
                           ir_expression *const r0EE6 = expr(ir_unop_i2u, r0EE5);
                           body.emit(assign(r0ECA, bit_or(r0EE1, r0EE6), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0EDE->else_instructions;

                           ir_expression *const r0EE7 = bit_or(r0DBD, r0DC6);
                           ir_expression *const r0EE8 = nequal(r0EE7, body.constant(0u));
                           ir_expression *const r0EE9 = expr(ir_unop_b2i, r0EE8);
                           body.emit(assign(r0ECA, expr(ir_unop_i2u, r0EE9), 0x01));


                        body.instructions = f0EDE_parent_instructions;
                        body.emit(f0EDE);

                        /* END IF */


                     body.instructions = f0ED9_parent_instructions;
                     body.emit(f0ED9);

                     /* END IF */

                     body.emit(assign(r0ECB, body.constant(0u), 0x01));


                  body.instructions = f0ED0_parent_instructions;
                  body.emit(f0ED0);

                  /* END IF */


               body.instructions = f0ECE_parent_instructions;
               body.emit(f0ECE);

               /* END IF */

               body.emit(assign(r0DBD, r0ECB, 0x01));

               body.emit(assign(r0DBE, r0ECA, 0x01));

               body.emit(assign(r0DBB, bit_or(r0DBB, body.constant(1073741824u)), 0x01));

               ir_variable *const r0EEA = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r0EEB = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r0EEB, sub(r0DBC, r0ECA), 0x01));

               ir_expression *const r0EEC = sub(r0DBB, r0ECB);
               ir_expression *const r0EED = less(r0DBC, r0ECA);
               ir_expression *const r0EEE = expr(ir_unop_b2i, r0EED);
               ir_expression *const r0EEF = expr(ir_unop_i2u, r0EEE);
               body.emit(assign(r0EEA, sub(r0EEC, r0EEF), 0x01));

               body.emit(assign(r0DB6, bit_xor(r0DB2, body.constant(1u)), 0x01));

               body.emit(assign(r0DBF, add(r0DC3, body.constant(int(-1))), 0x01));

               ir_variable *const r0EF0 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r0EF0, add(r0DBF, body.constant(int(-10))), 0x01));

               ir_variable *const r0EF1 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0EF1, r0EEA, 0x01));

               ir_variable *const r0EF2 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0EF2, r0EEB, 0x01));

               ir_variable *const r0EF3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r0EF3);
               ir_variable *const r0EF4 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r0EF4);
               /* IF CONDITION */
               ir_expression *const r0EF6 = equal(r0EEA, body.constant(0u));
               ir_if *f0EF5 = new(mem_ctx) ir_if(operand(r0EF6).val);
               exec_list *const f0EF5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0EF5->then_instructions;

                  body.emit(assign(r0EF1, r0EEB, 0x01));

                  body.emit(assign(r0EF2, body.constant(0u), 0x01));

                  body.emit(assign(r0EF0, add(r0EF0, body.constant(int(-32))), 0x01));


               body.instructions = f0EF5_parent_instructions;
               body.emit(f0EF5);

               /* END IF */

               ir_variable *const r0EF7 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r0EF7, r0EF1, 0x01));

               ir_variable *const r0EF8 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r0EF9 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r0EF9);
               /* IF CONDITION */
               ir_expression *const r0EFB = equal(r0EF1, body.constant(0u));
               ir_if *f0EFA = new(mem_ctx) ir_if(operand(r0EFB).val);
               exec_list *const f0EFA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0EFA->then_instructions;

                  body.emit(assign(r0EF8, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0EFA->else_instructions;

                  body.emit(assign(r0EF9, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0EFD = bit_and(r0EF1, body.constant(4294901760u));
                  ir_expression *const r0EFE = equal(r0EFD, body.constant(0u));
                  ir_if *f0EFC = new(mem_ctx) ir_if(operand(r0EFE).val);
                  exec_list *const f0EFC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0EFC->then_instructions;

                     body.emit(assign(r0EF9, body.constant(int(16)), 0x01));

                     body.emit(assign(r0EF7, lshift(r0EF1, body.constant(int(16))), 0x01));


                  body.instructions = f0EFC_parent_instructions;
                  body.emit(f0EFC);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0F00 = bit_and(r0EF7, body.constant(4278190080u));
                  ir_expression *const r0F01 = equal(r0F00, body.constant(0u));
                  ir_if *f0EFF = new(mem_ctx) ir_if(operand(r0F01).val);
                  exec_list *const f0EFF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0EFF->then_instructions;

                     body.emit(assign(r0EF9, add(r0EF9, body.constant(int(8))), 0x01));

                     body.emit(assign(r0EF7, lshift(r0EF7, body.constant(int(8))), 0x01));


                  body.instructions = f0EFF_parent_instructions;
                  body.emit(f0EFF);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0F03 = bit_and(r0EF7, body.constant(4026531840u));
                  ir_expression *const r0F04 = equal(r0F03, body.constant(0u));
                  ir_if *f0F02 = new(mem_ctx) ir_if(operand(r0F04).val);
                  exec_list *const f0F02_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F02->then_instructions;

                     body.emit(assign(r0EF9, add(r0EF9, body.constant(int(4))), 0x01));

                     body.emit(assign(r0EF7, lshift(r0EF7, body.constant(int(4))), 0x01));


                  body.instructions = f0F02_parent_instructions;
                  body.emit(f0F02);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0F06 = bit_and(r0EF7, body.constant(3221225472u));
                  ir_expression *const r0F07 = equal(r0F06, body.constant(0u));
                  ir_if *f0F05 = new(mem_ctx) ir_if(operand(r0F07).val);
                  exec_list *const f0F05_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F05->then_instructions;

                     body.emit(assign(r0EF9, add(r0EF9, body.constant(int(2))), 0x01));

                     body.emit(assign(r0EF7, lshift(r0EF7, body.constant(int(2))), 0x01));


                  body.instructions = f0F05_parent_instructions;
                  body.emit(f0F05);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0F09 = bit_and(r0EF7, body.constant(2147483648u));
                  ir_expression *const r0F0A = equal(r0F09, body.constant(0u));
                  ir_if *f0F08 = new(mem_ctx) ir_if(operand(r0F0A).val);
                  exec_list *const f0F08_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F08->then_instructions;

                     body.emit(assign(r0EF9, add(r0EF9, body.constant(int(1))), 0x01));


                  body.instructions = f0F08_parent_instructions;
                  body.emit(f0F08);

                  /* END IF */

                  body.emit(assign(r0EF8, r0EF9, 0x01));


               body.instructions = f0EFA_parent_instructions;
               body.emit(f0EFA);

               /* END IF */

               body.emit(assign(r0EF4, add(r0EF8, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0F0C = lequal(body.constant(int(0)), r0EF4);
               ir_if *f0F0B = new(mem_ctx) ir_if(operand(r0F0C).val);
               exec_list *const f0F0B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F0B->then_instructions;

                  body.emit(assign(r0EF3, body.constant(0u), 0x01));

                  ir_variable *const r0F0D = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0F0D, lshift(r0EF2, r0EF4), 0x01));

                  ir_variable *const r0F0E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0F10 = equal(r0EF4, body.constant(int(0)));
                  ir_if *f0F0F = new(mem_ctx) ir_if(operand(r0F10).val);
                  exec_list *const f0F0F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F0F->then_instructions;

                     body.emit(assign(r0F0E, r0EF1, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F0F->else_instructions;

                     ir_expression *const r0F11 = lshift(r0EF1, r0EF4);
                     ir_expression *const r0F12 = neg(r0EF4);
                     ir_expression *const r0F13 = bit_and(r0F12, body.constant(int(31)));
                     ir_expression *const r0F14 = rshift(r0EF2, r0F13);
                     body.emit(assign(r0F0E, bit_or(r0F11, r0F14), 0x01));


                  body.instructions = f0F0F_parent_instructions;
                  body.emit(f0F0F);

                  /* END IF */

                  body.emit(assign(r0EF1, r0F0E, 0x01));

                  body.emit(assign(r0EF2, r0F0D, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0F0B->else_instructions;

                  ir_variable *const r0F15 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r0F15, body.constant(0u), 0x01));

                  ir_variable *const r0F16 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r0F16, neg(r0EF4), 0x01));

                  ir_variable *const r0F17 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r0F17);
                  ir_variable *const r0F18 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r0F18);
                  ir_variable *const r0F19 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r0F19);
                  ir_variable *const r0F1A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r0F1B = neg(r0F16);
                  body.emit(assign(r0F1A, bit_and(r0F1B, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0F1D = equal(r0F16, body.constant(int(0)));
                  ir_if *f0F1C = new(mem_ctx) ir_if(operand(r0F1D).val);
                  exec_list *const f0F1C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F1C->then_instructions;

                     body.emit(assign(r0F17, r0F15, 0x01));

                     body.emit(assign(r0F18, r0EF2, 0x01));

                     body.emit(assign(r0F19, r0EF1, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F1C->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0F1F = less(r0F16, body.constant(int(32)));
                     ir_if *f0F1E = new(mem_ctx) ir_if(operand(r0F1F).val);
                     exec_list *const f0F1E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F1E->then_instructions;

                        body.emit(assign(r0F17, lshift(r0EF2, r0F1A), 0x01));

                        ir_expression *const r0F20 = lshift(r0EF1, r0F1A);
                        ir_expression *const r0F21 = rshift(r0EF2, r0F16);
                        body.emit(assign(r0F18, bit_or(r0F20, r0F21), 0x01));

                        body.emit(assign(r0F19, rshift(r0EF1, r0F16), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0F1E->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0F23 = equal(r0F16, body.constant(int(32)));
                        ir_if *f0F22 = new(mem_ctx) ir_if(operand(r0F23).val);
                        exec_list *const f0F22_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F22->then_instructions;

                           body.emit(assign(r0F17, r0EF2, 0x01));

                           body.emit(assign(r0F18, r0EF1, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0F22->else_instructions;

                           body.emit(assign(r0F15, bit_or(body.constant(0u), r0EF2), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0F25 = less(r0F16, body.constant(int(64)));
                           ir_if *f0F24 = new(mem_ctx) ir_if(operand(r0F25).val);
                           exec_list *const f0F24_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0F24->then_instructions;

                              body.emit(assign(r0F17, lshift(r0EF1, r0F1A), 0x01));

                              ir_expression *const r0F26 = bit_and(r0F16, body.constant(int(31)));
                              body.emit(assign(r0F18, rshift(r0EF1, r0F26), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0F24->else_instructions;

                              ir_variable *const r0F27 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0F29 = equal(r0F16, body.constant(int(64)));
                              ir_if *f0F28 = new(mem_ctx) ir_if(operand(r0F29).val);
                              exec_list *const f0F28_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0F28->then_instructions;

                                 body.emit(assign(r0F27, r0EF1, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0F28->else_instructions;

                                 ir_expression *const r0F2A = nequal(r0EF1, body.constant(0u));
                                 ir_expression *const r0F2B = expr(ir_unop_b2i, r0F2A);
                                 body.emit(assign(r0F27, expr(ir_unop_i2u, r0F2B), 0x01));


                              body.instructions = f0F28_parent_instructions;
                              body.emit(f0F28);

                              /* END IF */

                              body.emit(assign(r0F17, r0F27, 0x01));

                              body.emit(assign(r0F18, body.constant(0u), 0x01));


                           body.instructions = f0F24_parent_instructions;
                           body.emit(f0F24);

                           /* END IF */


                        body.instructions = f0F22_parent_instructions;
                        body.emit(f0F22);

                        /* END IF */

                        body.emit(assign(r0F19, body.constant(0u), 0x01));


                     body.instructions = f0F1E_parent_instructions;
                     body.emit(f0F1E);

                     /* END IF */

                     ir_expression *const r0F2C = nequal(r0F15, body.constant(0u));
                     ir_expression *const r0F2D = expr(ir_unop_b2i, r0F2C);
                     ir_expression *const r0F2E = expr(ir_unop_i2u, r0F2D);
                     body.emit(assign(r0F17, bit_or(r0F17, r0F2E), 0x01));


                  body.instructions = f0F1C_parent_instructions;
                  body.emit(f0F1C);

                  /* END IF */

                  body.emit(assign(r0EF1, r0F19, 0x01));

                  body.emit(assign(r0EF2, r0F18, 0x01));

                  body.emit(assign(r0EF3, r0F17, 0x01));


               body.instructions = f0F0B_parent_instructions;
               body.emit(f0F0B);

               /* END IF */

               body.emit(assign(r0EF0, sub(r0EF0, r0EF4), 0x01));

               ir_variable *const r0F2F = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r0F2F, r0EF0, 0x01));

               ir_variable *const r0F30 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0F30, r0EF1, 0x01));

               ir_variable *const r0F31 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0F31, r0EF2, 0x01));

               ir_variable *const r0F32 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r0F32, r0EF3, 0x01));

               ir_variable *const r0F33 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r0F33, body.constant(true), 0x01));

               ir_variable *const r0F34 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0F35 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r0F35);
               ir_expression *const r0F36 = expr(ir_unop_u2i, r0EF3);
               body.emit(assign(r0F35, less(r0F36, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0F38 = lequal(body.constant(int(2045)), r0EF0);
               ir_if *f0F37 = new(mem_ctx) ir_if(operand(r0F38).val);
               exec_list *const f0F37_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F37->then_instructions;

                  ir_variable *const r0F39 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0F3B = less(body.constant(int(2045)), r0EF0);
                  ir_if *f0F3A = new(mem_ctx) ir_if(operand(r0F3B).val);
                  exec_list *const f0F3A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F3A->then_instructions;

                     body.emit(assign(r0F39, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F3A->else_instructions;

                     ir_variable *const r0F3C = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0F3E = equal(r0EF0, body.constant(int(2045)));
                     ir_if *f0F3D = new(mem_ctx) ir_if(operand(r0F3E).val);
                     exec_list *const f0F3D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F3D->then_instructions;

                        ir_expression *const r0F3F = equal(body.constant(2097151u), r0EF1);
                        ir_expression *const r0F40 = equal(body.constant(4294967295u), r0EF2);
                        body.emit(assign(r0F3C, logic_and(r0F3F, r0F40), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0F3D->else_instructions;

                        body.emit(assign(r0F3C, body.constant(false), 0x01));


                     body.instructions = f0F3D_parent_instructions;
                     body.emit(f0F3D);

                     /* END IF */

                     body.emit(assign(r0F39, logic_and(r0F3C, r0F35), 0x01));


                  body.instructions = f0F3A_parent_instructions;
                  body.emit(f0F3A);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0F41 = new(mem_ctx) ir_if(operand(r0F39).val);
                  exec_list *const f0F41_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F41->then_instructions;

                     ir_variable *const r0F42 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0F42);
                     ir_expression *const r0F43 = lshift(r0DB6, body.constant(int(31)));
                     body.emit(assign(r0F42, add(r0F43, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r0F42, body.constant(0u), 0x01));

                     body.emit(assign(r0F34, r0F42, 0x03));

                     body.emit(assign(r0F33, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F41->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0F45 = less(r0EF0, body.constant(int(0)));
                     ir_if *f0F44 = new(mem_ctx) ir_if(operand(r0F45).val);
                     exec_list *const f0F44_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F44->then_instructions;

                        ir_variable *const r0F46 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0F46, r0EF3, 0x01));

                        ir_variable *const r0F47 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0F47, neg(r0EF0), 0x01));

                        ir_variable *const r0F48 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0F48);
                        ir_variable *const r0F49 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0F49);
                        ir_variable *const r0F4A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0F4A);
                        ir_variable *const r0F4B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r0F4C = neg(r0F47);
                        body.emit(assign(r0F4B, bit_and(r0F4C, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0F4E = equal(r0F47, body.constant(int(0)));
                        ir_if *f0F4D = new(mem_ctx) ir_if(operand(r0F4E).val);
                        exec_list *const f0F4D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F4D->then_instructions;

                           body.emit(assign(r0F48, r0EF3, 0x01));

                           body.emit(assign(r0F49, r0EF2, 0x01));

                           body.emit(assign(r0F4A, r0EF1, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0F4D->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0F50 = less(r0F47, body.constant(int(32)));
                           ir_if *f0F4F = new(mem_ctx) ir_if(operand(r0F50).val);
                           exec_list *const f0F4F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0F4F->then_instructions;

                              body.emit(assign(r0F48, lshift(r0EF2, r0F4B), 0x01));

                              ir_expression *const r0F51 = lshift(r0EF1, r0F4B);
                              ir_expression *const r0F52 = rshift(r0EF2, r0F47);
                              body.emit(assign(r0F49, bit_or(r0F51, r0F52), 0x01));

                              body.emit(assign(r0F4A, rshift(r0EF1, r0F47), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0F4F->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0F54 = equal(r0F47, body.constant(int(32)));
                              ir_if *f0F53 = new(mem_ctx) ir_if(operand(r0F54).val);
                              exec_list *const f0F53_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0F53->then_instructions;

                                 body.emit(assign(r0F48, r0EF2, 0x01));

                                 body.emit(assign(r0F49, r0EF1, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0F53->else_instructions;

                                 body.emit(assign(r0F46, bit_or(r0EF3, r0EF2), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0F56 = less(r0F47, body.constant(int(64)));
                                 ir_if *f0F55 = new(mem_ctx) ir_if(operand(r0F56).val);
                                 exec_list *const f0F55_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0F55->then_instructions;

                                    body.emit(assign(r0F48, lshift(r0EF1, r0F4B), 0x01));

                                    ir_expression *const r0F57 = bit_and(r0F47, body.constant(int(31)));
                                    body.emit(assign(r0F49, rshift(r0EF1, r0F57), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0F55->else_instructions;

                                    ir_variable *const r0F58 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r0F5A = equal(r0F47, body.constant(int(64)));
                                    ir_if *f0F59 = new(mem_ctx) ir_if(operand(r0F5A).val);
                                    exec_list *const f0F59_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0F59->then_instructions;

                                       body.emit(assign(r0F58, r0EF1, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0F59->else_instructions;

                                       ir_expression *const r0F5B = nequal(r0EF1, body.constant(0u));
                                       ir_expression *const r0F5C = expr(ir_unop_b2i, r0F5B);
                                       body.emit(assign(r0F58, expr(ir_unop_i2u, r0F5C), 0x01));


                                    body.instructions = f0F59_parent_instructions;
                                    body.emit(f0F59);

                                    /* END IF */

                                    body.emit(assign(r0F48, r0F58, 0x01));

                                    body.emit(assign(r0F49, body.constant(0u), 0x01));


                                 body.instructions = f0F55_parent_instructions;
                                 body.emit(f0F55);

                                 /* END IF */


                              body.instructions = f0F53_parent_instructions;
                              body.emit(f0F53);

                              /* END IF */

                              body.emit(assign(r0F4A, body.constant(0u), 0x01));


                           body.instructions = f0F4F_parent_instructions;
                           body.emit(f0F4F);

                           /* END IF */

                           ir_expression *const r0F5D = nequal(r0F46, body.constant(0u));
                           ir_expression *const r0F5E = expr(ir_unop_b2i, r0F5D);
                           ir_expression *const r0F5F = expr(ir_unop_i2u, r0F5E);
                           body.emit(assign(r0F48, bit_or(r0F48, r0F5F), 0x01));


                        body.instructions = f0F4D_parent_instructions;
                        body.emit(f0F4D);

                        /* END IF */

                        body.emit(assign(r0F30, r0F4A, 0x01));

                        body.emit(assign(r0F31, r0F49, 0x01));

                        body.emit(assign(r0F32, r0F48, 0x01));

                        body.emit(assign(r0F2F, body.constant(int(0)), 0x01));

                        body.emit(assign(r0F35, less(r0F48, body.constant(0u)), 0x01));


                     body.instructions = f0F44_parent_instructions;
                     body.emit(f0F44);

                     /* END IF */


                  body.instructions = f0F41_parent_instructions;
                  body.emit(f0F41);

                  /* END IF */


               body.instructions = f0F37_parent_instructions;
               body.emit(f0F37);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0F60 = new(mem_ctx) ir_if(operand(r0F33).val);
               exec_list *const f0F60_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F60->then_instructions;

                  /* IF CONDITION */
                  ir_if *f0F61 = new(mem_ctx) ir_if(operand(r0F35).val);
                  exec_list *const f0F61_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F61->then_instructions;

                     ir_variable *const r0F62 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r0F62, add(r0F31, body.constant(1u)), 0x01));

                     ir_expression *const r0F63 = less(r0F62, r0F31);
                     ir_expression *const r0F64 = expr(ir_unop_b2i, r0F63);
                     ir_expression *const r0F65 = expr(ir_unop_i2u, r0F64);
                     body.emit(assign(r0F30, add(r0F30, r0F65), 0x01));

                     ir_expression *const r0F66 = equal(r0F32, body.constant(0u));
                     ir_expression *const r0F67 = expr(ir_unop_b2i, r0F66);
                     ir_expression *const r0F68 = expr(ir_unop_i2u, r0F67);
                     ir_expression *const r0F69 = add(r0F32, r0F68);
                     ir_expression *const r0F6A = bit_and(r0F69, body.constant(1u));
                     ir_expression *const r0F6B = expr(ir_unop_bit_not, r0F6A);
                     body.emit(assign(r0F31, bit_and(r0F62, r0F6B), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F61->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0F6D = bit_or(r0F30, r0F31);
                     ir_expression *const r0F6E = equal(r0F6D, body.constant(0u));
                     ir_if *f0F6C = new(mem_ctx) ir_if(operand(r0F6E).val);
                     exec_list *const f0F6C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F6C->then_instructions;

                        body.emit(assign(r0F2F, body.constant(int(0)), 0x01));


                     body.instructions = f0F6C_parent_instructions;
                     body.emit(f0F6C);

                     /* END IF */


                  body.instructions = f0F61_parent_instructions;
                  body.emit(f0F61);

                  /* END IF */

                  ir_variable *const r0F6F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0F6F);
                  ir_expression *const r0F70 = lshift(r0DB6, body.constant(int(31)));
                  ir_expression *const r0F71 = expr(ir_unop_i2u, r0F2F);
                  ir_expression *const r0F72 = lshift(r0F71, body.constant(int(20)));
                  ir_expression *const r0F73 = add(r0F70, r0F72);
                  body.emit(assign(r0F6F, add(r0F73, r0F30), 0x02));

                  body.emit(assign(r0F6F, r0F31, 0x01));

                  body.emit(assign(r0F34, r0F6F, 0x03));

                  body.emit(assign(r0F33, body.constant(false), 0x01));


               body.instructions = f0F60_parent_instructions;
               body.emit(f0F60);

               /* END IF */

               body.emit(assign(r0DB7, r0F34, 0x03));


            body.instructions = f0EA2_parent_instructions;
            body.emit(f0EA2);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0EA0->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0F75 = equal(r0DC0, body.constant(int(2047)));
            ir_if *f0F74 = new(mem_ctx) ir_if(operand(r0F75).val);
            exec_list *const f0F74_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0F74->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0F77 = bit_or(r0DBD, r0DBE);
               ir_expression *const r0F78 = bit_or(r0DBB, r0DBC);
               ir_expression *const r0F79 = bit_or(r0F77, r0F78);
               ir_expression *const r0F7A = nequal(r0F79, body.constant(0u));
               ir_if *f0F76 = new(mem_ctx) ir_if(operand(r0F7A).val);
               exec_list *const f0F76_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F76->then_instructions;

                  ir_variable *const r0F7B = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r0F7B, swizzle_x(r0DAF), 0x01));

                  ir_variable *const r0F7C = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r0F7C, swizzle_x(r0DB0), 0x01));

                  ir_variable *const r0F7D = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0F7E = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0F7F = rshift(swizzle_y(r0DAF), body.constant(int(19)));
                  ir_expression *const r0F80 = bit_and(r0F7F, body.constant(4095u));
                  ir_expression *const r0F81 = equal(r0F80, body.constant(4094u));
                  ir_expression *const r0F82 = nequal(swizzle_x(r0DAF), body.constant(0u));
                  ir_expression *const r0F83 = bit_and(swizzle_y(r0DAF), body.constant(524287u));
                  ir_expression *const r0F84 = nequal(r0F83, body.constant(0u));
                  ir_expression *const r0F85 = logic_or(r0F82, r0F84);
                  body.emit(assign(r0F7E, logic_and(r0F81, r0F85), 0x01));

                  ir_variable *const r0F86 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0F87 = lshift(swizzle_y(r0DB0), body.constant(int(1)));
                  ir_expression *const r0F88 = lequal(body.constant(4292870144u), r0F87);
                  ir_expression *const r0F89 = nequal(swizzle_x(r0DB0), body.constant(0u));
                  ir_expression *const r0F8A = bit_and(swizzle_y(r0DB0), body.constant(1048575u));
                  ir_expression *const r0F8B = nequal(r0F8A, body.constant(0u));
                  ir_expression *const r0F8C = logic_or(r0F89, r0F8B);
                  body.emit(assign(r0F86, logic_and(r0F88, r0F8C), 0x01));

                  body.emit(assign(r0F7B, bit_or(swizzle_y(r0DAF), body.constant(524288u)), 0x02));

                  body.emit(assign(r0F7C, bit_or(swizzle_y(r0DB0), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r0F8E = lshift(swizzle_y(r0DAF), body.constant(int(1)));
                  ir_expression *const r0F8F = lequal(body.constant(4292870144u), r0F8E);
                  ir_expression *const r0F90 = nequal(swizzle_x(r0DAF), body.constant(0u));
                  ir_expression *const r0F91 = bit_and(swizzle_y(r0DAF), body.constant(1048575u));
                  ir_expression *const r0F92 = nequal(r0F91, body.constant(0u));
                  ir_expression *const r0F93 = logic_or(r0F90, r0F92);
                  ir_expression *const r0F94 = logic_and(r0F8F, r0F93);
                  ir_if *f0F8D = new(mem_ctx) ir_if(operand(r0F94).val);
                  exec_list *const f0F8D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F8D->then_instructions;

                     ir_variable *const r0F95 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0F97 = logic_and(r0F7E, r0F86);
                     ir_if *f0F96 = new(mem_ctx) ir_if(operand(r0F97).val);
                     exec_list *const f0F96_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F96->then_instructions;

                        body.emit(assign(r0F95, r0F7C, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0F96->else_instructions;

                        body.emit(assign(r0F95, r0F7B, 0x03));


                     body.instructions = f0F96_parent_instructions;
                     body.emit(f0F96);

                     /* END IF */

                     body.emit(assign(r0F7D, r0F95, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F8D->else_instructions;

                     body.emit(assign(r0F7D, r0F7C, 0x03));


                  body.instructions = f0F8D_parent_instructions;
                  body.emit(f0F8D);

                  /* END IF */

                  body.emit(assign(r0DB7, r0F7D, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0F76->else_instructions;

                  ir_constant_data r0F98_data;
                  memset(&r0F98_data, 0, sizeof(ir_constant_data));
                  r0F98_data.u[0] = 4294967295;
                  r0F98_data.u[1] = 4294967295;
                  ir_constant *const r0F98 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r0F98_data);
                  body.emit(assign(r0DB7, r0F98, 0x03));


               body.instructions = f0F76_parent_instructions;
               body.emit(f0F76);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0F74->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0F9A = equal(r0DC0, body.constant(int(0)));
               ir_if *f0F99 = new(mem_ctx) ir_if(operand(r0F9A).val);
               exec_list *const f0F99_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F99->then_instructions;

                  body.emit(assign(r0DBA, body.constant(int(1)), 0x01));

                  body.emit(assign(r0DB9, body.constant(int(1)), 0x01));


               body.instructions = f0F99_parent_instructions;
               body.emit(f0F99);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0F9C = less(r0DBB, r0DBD);
               ir_if *f0F9B = new(mem_ctx) ir_if(operand(r0F9C).val);
               exec_list *const f0F9B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F9B->then_instructions;

                  ir_variable *const r0F9D = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r0F9E = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0F9E, sub(r0DBE, r0DBC), 0x01));

                  ir_expression *const r0F9F = sub(r0DBD, r0DBB);
                  ir_expression *const r0FA0 = less(r0DBE, r0DBC);
                  ir_expression *const r0FA1 = expr(ir_unop_b2i, r0FA0);
                  ir_expression *const r0FA2 = expr(ir_unop_i2u, r0FA1);
                  body.emit(assign(r0F9D, sub(r0F9F, r0FA2), 0x01));

                  body.emit(assign(r0DBF, add(r0DBA, body.constant(int(-1))), 0x01));

                  ir_variable *const r0FA3 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r0FA3, add(r0DBF, body.constant(int(-10))), 0x01));

                  ir_variable *const r0FA4 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r0FA4, r0F9D, 0x01));

                  ir_variable *const r0FA5 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r0FA5, r0F9E, 0x01));

                  ir_variable *const r0FA6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r0FA6);
                  ir_variable *const r0FA7 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0FA7);
                  /* IF CONDITION */
                  ir_expression *const r0FA9 = equal(r0F9D, body.constant(0u));
                  ir_if *f0FA8 = new(mem_ctx) ir_if(operand(r0FA9).val);
                  exec_list *const f0FA8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0FA8->then_instructions;

                     body.emit(assign(r0FA4, r0F9E, 0x01));

                     body.emit(assign(r0FA5, body.constant(0u), 0x01));

                     body.emit(assign(r0FA3, add(r0FA3, body.constant(int(-32))), 0x01));


                  body.instructions = f0FA8_parent_instructions;
                  body.emit(f0FA8);

                  /* END IF */

                  ir_variable *const r0FAA = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r0FAA, r0FA4, 0x01));

                  ir_variable *const r0FAB = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r0FAC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0FAC);
                  /* IF CONDITION */
                  ir_expression *const r0FAE = equal(r0FA4, body.constant(0u));
                  ir_if *f0FAD = new(mem_ctx) ir_if(operand(r0FAE).val);
                  exec_list *const f0FAD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0FAD->then_instructions;

                     body.emit(assign(r0FAB, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0FAD->else_instructions;

                     body.emit(assign(r0FAC, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0FB0 = bit_and(r0FA4, body.constant(4294901760u));
                     ir_expression *const r0FB1 = equal(r0FB0, body.constant(0u));
                     ir_if *f0FAF = new(mem_ctx) ir_if(operand(r0FB1).val);
                     exec_list *const f0FAF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FAF->then_instructions;

                        body.emit(assign(r0FAC, body.constant(int(16)), 0x01));

                        body.emit(assign(r0FAA, lshift(r0FA4, body.constant(int(16))), 0x01));


                     body.instructions = f0FAF_parent_instructions;
                     body.emit(f0FAF);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0FB3 = bit_and(r0FAA, body.constant(4278190080u));
                     ir_expression *const r0FB4 = equal(r0FB3, body.constant(0u));
                     ir_if *f0FB2 = new(mem_ctx) ir_if(operand(r0FB4).val);
                     exec_list *const f0FB2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FB2->then_instructions;

                        body.emit(assign(r0FAC, add(r0FAC, body.constant(int(8))), 0x01));

                        body.emit(assign(r0FAA, lshift(r0FAA, body.constant(int(8))), 0x01));


                     body.instructions = f0FB2_parent_instructions;
                     body.emit(f0FB2);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0FB6 = bit_and(r0FAA, body.constant(4026531840u));
                     ir_expression *const r0FB7 = equal(r0FB6, body.constant(0u));
                     ir_if *f0FB5 = new(mem_ctx) ir_if(operand(r0FB7).val);
                     exec_list *const f0FB5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FB5->then_instructions;

                        body.emit(assign(r0FAC, add(r0FAC, body.constant(int(4))), 0x01));

                        body.emit(assign(r0FAA, lshift(r0FAA, body.constant(int(4))), 0x01));


                     body.instructions = f0FB5_parent_instructions;
                     body.emit(f0FB5);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0FB9 = bit_and(r0FAA, body.constant(3221225472u));
                     ir_expression *const r0FBA = equal(r0FB9, body.constant(0u));
                     ir_if *f0FB8 = new(mem_ctx) ir_if(operand(r0FBA).val);
                     exec_list *const f0FB8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FB8->then_instructions;

                        body.emit(assign(r0FAC, add(r0FAC, body.constant(int(2))), 0x01));

                        body.emit(assign(r0FAA, lshift(r0FAA, body.constant(int(2))), 0x01));


                     body.instructions = f0FB8_parent_instructions;
                     body.emit(f0FB8);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0FBC = bit_and(r0FAA, body.constant(2147483648u));
                     ir_expression *const r0FBD = equal(r0FBC, body.constant(0u));
                     ir_if *f0FBB = new(mem_ctx) ir_if(operand(r0FBD).val);
                     exec_list *const f0FBB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FBB->then_instructions;

                        body.emit(assign(r0FAC, add(r0FAC, body.constant(int(1))), 0x01));


                     body.instructions = f0FBB_parent_instructions;
                     body.emit(f0FBB);

                     /* END IF */

                     body.emit(assign(r0FAB, r0FAC, 0x01));


                  body.instructions = f0FAD_parent_instructions;
                  body.emit(f0FAD);

                  /* END IF */

                  body.emit(assign(r0FA7, add(r0FAB, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0FBF = lequal(body.constant(int(0)), r0FA7);
                  ir_if *f0FBE = new(mem_ctx) ir_if(operand(r0FBF).val);
                  exec_list *const f0FBE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0FBE->then_instructions;

                     body.emit(assign(r0FA6, body.constant(0u), 0x01));

                     ir_variable *const r0FC0 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r0FC0, lshift(r0FA5, r0FA7), 0x01));

                     ir_variable *const r0FC1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0FC3 = equal(r0FA7, body.constant(int(0)));
                     ir_if *f0FC2 = new(mem_ctx) ir_if(operand(r0FC3).val);
                     exec_list *const f0FC2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FC2->then_instructions;

                        body.emit(assign(r0FC1, r0FA4, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0FC2->else_instructions;

                        ir_expression *const r0FC4 = lshift(r0FA4, r0FA7);
                        ir_expression *const r0FC5 = neg(r0FA7);
                        ir_expression *const r0FC6 = bit_and(r0FC5, body.constant(int(31)));
                        ir_expression *const r0FC7 = rshift(r0FA5, r0FC6);
                        body.emit(assign(r0FC1, bit_or(r0FC4, r0FC7), 0x01));


                     body.instructions = f0FC2_parent_instructions;
                     body.emit(f0FC2);

                     /* END IF */

                     body.emit(assign(r0FA4, r0FC1, 0x01));

                     body.emit(assign(r0FA5, r0FC0, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0FBE->else_instructions;

                     ir_variable *const r0FC8 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0FC8, body.constant(0u), 0x01));

                     ir_variable *const r0FC9 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0FC9, neg(r0FA7), 0x01));

                     ir_variable *const r0FCA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0FCA);
                     ir_variable *const r0FCB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0FCB);
                     ir_variable *const r0FCC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0FCC);
                     ir_variable *const r0FCD = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0FCE = neg(r0FC9);
                     body.emit(assign(r0FCD, bit_and(r0FCE, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0FD0 = equal(r0FC9, body.constant(int(0)));
                     ir_if *f0FCF = new(mem_ctx) ir_if(operand(r0FD0).val);
                     exec_list *const f0FCF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FCF->then_instructions;

                        body.emit(assign(r0FCA, r0FC8, 0x01));

                        body.emit(assign(r0FCB, r0FA5, 0x01));

                        body.emit(assign(r0FCC, r0FA4, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0FCF->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0FD2 = less(r0FC9, body.constant(int(32)));
                        ir_if *f0FD1 = new(mem_ctx) ir_if(operand(r0FD2).val);
                        exec_list *const f0FD1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0FD1->then_instructions;

                           body.emit(assign(r0FCA, lshift(r0FA5, r0FCD), 0x01));

                           ir_expression *const r0FD3 = lshift(r0FA4, r0FCD);
                           ir_expression *const r0FD4 = rshift(r0FA5, r0FC9);
                           body.emit(assign(r0FCB, bit_or(r0FD3, r0FD4), 0x01));

                           body.emit(assign(r0FCC, rshift(r0FA4, r0FC9), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0FD1->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0FD6 = equal(r0FC9, body.constant(int(32)));
                           ir_if *f0FD5 = new(mem_ctx) ir_if(operand(r0FD6).val);
                           exec_list *const f0FD5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0FD5->then_instructions;

                              body.emit(assign(r0FCA, r0FA5, 0x01));

                              body.emit(assign(r0FCB, r0FA4, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0FD5->else_instructions;

                              body.emit(assign(r0FC8, bit_or(body.constant(0u), r0FA5), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0FD8 = less(r0FC9, body.constant(int(64)));
                              ir_if *f0FD7 = new(mem_ctx) ir_if(operand(r0FD8).val);
                              exec_list *const f0FD7_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0FD7->then_instructions;

                                 body.emit(assign(r0FCA, lshift(r0FA4, r0FCD), 0x01));

                                 ir_expression *const r0FD9 = bit_and(r0FC9, body.constant(int(31)));
                                 body.emit(assign(r0FCB, rshift(r0FA4, r0FD9), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0FD7->else_instructions;

                                 ir_variable *const r0FDA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0FDC = equal(r0FC9, body.constant(int(64)));
                                 ir_if *f0FDB = new(mem_ctx) ir_if(operand(r0FDC).val);
                                 exec_list *const f0FDB_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0FDB->then_instructions;

                                    body.emit(assign(r0FDA, r0FA4, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0FDB->else_instructions;

                                    ir_expression *const r0FDD = nequal(r0FA4, body.constant(0u));
                                    ir_expression *const r0FDE = expr(ir_unop_b2i, r0FDD);
                                    body.emit(assign(r0FDA, expr(ir_unop_i2u, r0FDE), 0x01));


                                 body.instructions = f0FDB_parent_instructions;
                                 body.emit(f0FDB);

                                 /* END IF */

                                 body.emit(assign(r0FCA, r0FDA, 0x01));

                                 body.emit(assign(r0FCB, body.constant(0u), 0x01));


                              body.instructions = f0FD7_parent_instructions;
                              body.emit(f0FD7);

                              /* END IF */


                           body.instructions = f0FD5_parent_instructions;
                           body.emit(f0FD5);

                           /* END IF */

                           body.emit(assign(r0FCC, body.constant(0u), 0x01));


                        body.instructions = f0FD1_parent_instructions;
                        body.emit(f0FD1);

                        /* END IF */

                        ir_expression *const r0FDF = nequal(r0FC8, body.constant(0u));
                        ir_expression *const r0FE0 = expr(ir_unop_b2i, r0FDF);
                        ir_expression *const r0FE1 = expr(ir_unop_i2u, r0FE0);
                        body.emit(assign(r0FCA, bit_or(r0FCA, r0FE1), 0x01));


                     body.instructions = f0FCF_parent_instructions;
                     body.emit(f0FCF);

                     /* END IF */

                     body.emit(assign(r0FA4, r0FCC, 0x01));

                     body.emit(assign(r0FA5, r0FCB, 0x01));

                     body.emit(assign(r0FA6, r0FCA, 0x01));


                  body.instructions = f0FBE_parent_instructions;
                  body.emit(f0FBE);

                  /* END IF */

                  body.emit(assign(r0FA3, sub(r0FA3, r0FA7), 0x01));

                  ir_variable *const r0FE2 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r0FE2, r0FA3, 0x01));

                  ir_variable *const r0FE3 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r0FE3, r0FA4, 0x01));

                  ir_variable *const r0FE4 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r0FE4, r0FA5, 0x01));

                  ir_variable *const r0FE5 = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r0FE5, r0FA6, 0x01));

                  ir_variable *const r0FE6 = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r0FE6, body.constant(true), 0x01));

                  ir_variable *const r0FE7 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0FE8 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r0FE8);
                  ir_expression *const r0FE9 = expr(ir_unop_u2i, r0FA6);
                  body.emit(assign(r0FE8, less(r0FE9, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0FEB = lequal(body.constant(int(2045)), r0FA3);
                  ir_if *f0FEA = new(mem_ctx) ir_if(operand(r0FEB).val);
                  exec_list *const f0FEA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0FEA->then_instructions;

                     ir_variable *const r0FEC = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0FEE = less(body.constant(int(2045)), r0FA3);
                     ir_if *f0FED = new(mem_ctx) ir_if(operand(r0FEE).val);
                     exec_list *const f0FED_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FED->then_instructions;

                        body.emit(assign(r0FEC, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0FED->else_instructions;

                        ir_variable *const r0FEF = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0FF1 = equal(r0FA3, body.constant(int(2045)));
                        ir_if *f0FF0 = new(mem_ctx) ir_if(operand(r0FF1).val);
                        exec_list *const f0FF0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0FF0->then_instructions;

                           ir_expression *const r0FF2 = equal(body.constant(2097151u), r0FA4);
                           ir_expression *const r0FF3 = equal(body.constant(4294967295u), r0FA5);
                           body.emit(assign(r0FEF, logic_and(r0FF2, r0FF3), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0FF0->else_instructions;

                           body.emit(assign(r0FEF, body.constant(false), 0x01));


                        body.instructions = f0FF0_parent_instructions;
                        body.emit(f0FF0);

                        /* END IF */

                        body.emit(assign(r0FEC, logic_and(r0FEF, r0FE8), 0x01));


                     body.instructions = f0FED_parent_instructions;
                     body.emit(f0FED);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f0FF4 = new(mem_ctx) ir_if(operand(r0FEC).val);
                     exec_list *const f0FF4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FF4->then_instructions;

                        ir_variable *const r0FF5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r0FF5);
                        ir_expression *const r0FF6 = lshift(r0DB6, body.constant(int(31)));
                        body.emit(assign(r0FF5, add(r0FF6, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r0FF5, body.constant(0u), 0x01));

                        body.emit(assign(r0FE7, r0FF5, 0x03));

                        body.emit(assign(r0FE6, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0FF4->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0FF8 = less(r0FA3, body.constant(int(0)));
                        ir_if *f0FF7 = new(mem_ctx) ir_if(operand(r0FF8).val);
                        exec_list *const f0FF7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0FF7->then_instructions;

                           ir_variable *const r0FF9 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r0FF9, r0FA6, 0x01));

                           ir_variable *const r0FFA = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r0FFA, neg(r0FA3), 0x01));

                           ir_variable *const r0FFB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r0FFB);
                           ir_variable *const r0FFC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r0FFC);
                           ir_variable *const r0FFD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r0FFD);
                           ir_variable *const r0FFE = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r0FFF = neg(r0FFA);
                           body.emit(assign(r0FFE, bit_and(r0FFF, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1001 = equal(r0FFA, body.constant(int(0)));
                           ir_if *f1000 = new(mem_ctx) ir_if(operand(r1001).val);
                           exec_list *const f1000_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1000->then_instructions;

                              body.emit(assign(r0FFB, r0FA6, 0x01));

                              body.emit(assign(r0FFC, r0FA5, 0x01));

                              body.emit(assign(r0FFD, r0FA4, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1000->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1003 = less(r0FFA, body.constant(int(32)));
                              ir_if *f1002 = new(mem_ctx) ir_if(operand(r1003).val);
                              exec_list *const f1002_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1002->then_instructions;

                                 body.emit(assign(r0FFB, lshift(r0FA5, r0FFE), 0x01));

                                 ir_expression *const r1004 = lshift(r0FA4, r0FFE);
                                 ir_expression *const r1005 = rshift(r0FA5, r0FFA);
                                 body.emit(assign(r0FFC, bit_or(r1004, r1005), 0x01));

                                 body.emit(assign(r0FFD, rshift(r0FA4, r0FFA), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1002->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1007 = equal(r0FFA, body.constant(int(32)));
                                 ir_if *f1006 = new(mem_ctx) ir_if(operand(r1007).val);
                                 exec_list *const f1006_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1006->then_instructions;

                                    body.emit(assign(r0FFB, r0FA5, 0x01));

                                    body.emit(assign(r0FFC, r0FA4, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1006->else_instructions;

                                    body.emit(assign(r0FF9, bit_or(r0FA6, r0FA5), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r1009 = less(r0FFA, body.constant(int(64)));
                                    ir_if *f1008 = new(mem_ctx) ir_if(operand(r1009).val);
                                    exec_list *const f1008_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1008->then_instructions;

                                       body.emit(assign(r0FFB, lshift(r0FA4, r0FFE), 0x01));

                                       ir_expression *const r100A = bit_and(r0FFA, body.constant(int(31)));
                                       body.emit(assign(r0FFC, rshift(r0FA4, r100A), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1008->else_instructions;

                                       ir_variable *const r100B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r100D = equal(r0FFA, body.constant(int(64)));
                                       ir_if *f100C = new(mem_ctx) ir_if(operand(r100D).val);
                                       exec_list *const f100C_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f100C->then_instructions;

                                          body.emit(assign(r100B, r0FA4, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f100C->else_instructions;

                                          ir_expression *const r100E = nequal(r0FA4, body.constant(0u));
                                          ir_expression *const r100F = expr(ir_unop_b2i, r100E);
                                          body.emit(assign(r100B, expr(ir_unop_i2u, r100F), 0x01));


                                       body.instructions = f100C_parent_instructions;
                                       body.emit(f100C);

                                       /* END IF */

                                       body.emit(assign(r0FFB, r100B, 0x01));

                                       body.emit(assign(r0FFC, body.constant(0u), 0x01));


                                    body.instructions = f1008_parent_instructions;
                                    body.emit(f1008);

                                    /* END IF */


                                 body.instructions = f1006_parent_instructions;
                                 body.emit(f1006);

                                 /* END IF */

                                 body.emit(assign(r0FFD, body.constant(0u), 0x01));


                              body.instructions = f1002_parent_instructions;
                              body.emit(f1002);

                              /* END IF */

                              ir_expression *const r1010 = nequal(r0FF9, body.constant(0u));
                              ir_expression *const r1011 = expr(ir_unop_b2i, r1010);
                              ir_expression *const r1012 = expr(ir_unop_i2u, r1011);
                              body.emit(assign(r0FFB, bit_or(r0FFB, r1012), 0x01));


                           body.instructions = f1000_parent_instructions;
                           body.emit(f1000);

                           /* END IF */

                           body.emit(assign(r0FE3, r0FFD, 0x01));

                           body.emit(assign(r0FE4, r0FFC, 0x01));

                           body.emit(assign(r0FE5, r0FFB, 0x01));

                           body.emit(assign(r0FE2, body.constant(int(0)), 0x01));

                           body.emit(assign(r0FE8, less(r0FFB, body.constant(0u)), 0x01));


                        body.instructions = f0FF7_parent_instructions;
                        body.emit(f0FF7);

                        /* END IF */


                     body.instructions = f0FF4_parent_instructions;
                     body.emit(f0FF4);

                     /* END IF */


                  body.instructions = f0FEA_parent_instructions;
                  body.emit(f0FEA);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f1013 = new(mem_ctx) ir_if(operand(r0FE6).val);
                  exec_list *const f1013_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1013->then_instructions;

                     /* IF CONDITION */
                     ir_if *f1014 = new(mem_ctx) ir_if(operand(r0FE8).val);
                     exec_list *const f1014_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1014->then_instructions;

                        ir_variable *const r1015 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r1015, add(r0FE4, body.constant(1u)), 0x01));

                        ir_expression *const r1016 = less(r1015, r0FE4);
                        ir_expression *const r1017 = expr(ir_unop_b2i, r1016);
                        ir_expression *const r1018 = expr(ir_unop_i2u, r1017);
                        body.emit(assign(r0FE3, add(r0FE3, r1018), 0x01));

                        ir_expression *const r1019 = equal(r0FE5, body.constant(0u));
                        ir_expression *const r101A = expr(ir_unop_b2i, r1019);
                        ir_expression *const r101B = expr(ir_unop_i2u, r101A);
                        ir_expression *const r101C = add(r0FE5, r101B);
                        ir_expression *const r101D = bit_and(r101C, body.constant(1u));
                        ir_expression *const r101E = expr(ir_unop_bit_not, r101D);
                        body.emit(assign(r0FE4, bit_and(r1015, r101E), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1014->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1020 = bit_or(r0FE3, r0FE4);
                        ir_expression *const r1021 = equal(r1020, body.constant(0u));
                        ir_if *f101F = new(mem_ctx) ir_if(operand(r1021).val);
                        exec_list *const f101F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f101F->then_instructions;

                           body.emit(assign(r0FE2, body.constant(int(0)), 0x01));


                        body.instructions = f101F_parent_instructions;
                        body.emit(f101F);

                        /* END IF */


                     body.instructions = f1014_parent_instructions;
                     body.emit(f1014);

                     /* END IF */

                     ir_variable *const r1022 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r1022);
                     ir_expression *const r1023 = lshift(r0DB6, body.constant(int(31)));
                     ir_expression *const r1024 = expr(ir_unop_i2u, r0FE2);
                     ir_expression *const r1025 = lshift(r1024, body.constant(int(20)));
                     ir_expression *const r1026 = add(r1023, r1025);
                     body.emit(assign(r1022, add(r1026, r0FE3), 0x02));

                     body.emit(assign(r1022, r0FE4, 0x01));

                     body.emit(assign(r0FE7, r1022, 0x03));

                     body.emit(assign(r0FE6, body.constant(false), 0x01));


                  body.instructions = f1013_parent_instructions;
                  body.emit(f1013);

                  /* END IF */

                  body.emit(assign(r0DB7, r0FE7, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0F9B->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1028 = less(r0DBD, r0DBB);
                  ir_if *f1027 = new(mem_ctx) ir_if(operand(r1028).val);
                  exec_list *const f1027_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1027->then_instructions;

                     ir_variable *const r1029 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r102A = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r102A, sub(r0DBC, r0DBE), 0x01));

                     ir_expression *const r102B = sub(r0DBB, r0DBD);
                     ir_expression *const r102C = less(r0DBC, r0DBE);
                     ir_expression *const r102D = expr(ir_unop_b2i, r102C);
                     ir_expression *const r102E = expr(ir_unop_i2u, r102D);
                     body.emit(assign(r1029, sub(r102B, r102E), 0x01));

                     body.emit(assign(r0DB6, bit_xor(r0DB6, body.constant(1u)), 0x01));

                     body.emit(assign(r0DBF, add(r0DB9, body.constant(int(-1))), 0x01));

                     ir_variable *const r102F = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r102F, add(r0DBF, body.constant(int(-10))), 0x01));

                     ir_variable *const r1030 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r1030, r1029, 0x01));

                     ir_variable *const r1031 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r1031, r102A, 0x01));

                     ir_variable *const r1032 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r1032);
                     ir_variable *const r1033 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r1033);
                     /* IF CONDITION */
                     ir_expression *const r1035 = equal(r1029, body.constant(0u));
                     ir_if *f1034 = new(mem_ctx) ir_if(operand(r1035).val);
                     exec_list *const f1034_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1034->then_instructions;

                        body.emit(assign(r1030, r102A, 0x01));

                        body.emit(assign(r1031, body.constant(0u), 0x01));

                        body.emit(assign(r102F, add(r102F, body.constant(int(-32))), 0x01));


                     body.instructions = f1034_parent_instructions;
                     body.emit(f1034);

                     /* END IF */

                     ir_variable *const r1036 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r1036, r1030, 0x01));

                     ir_variable *const r1037 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r1038 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r1038);
                     /* IF CONDITION */
                     ir_expression *const r103A = equal(r1030, body.constant(0u));
                     ir_if *f1039 = new(mem_ctx) ir_if(operand(r103A).val);
                     exec_list *const f1039_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1039->then_instructions;

                        body.emit(assign(r1037, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1039->else_instructions;

                        body.emit(assign(r1038, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r103C = bit_and(r1030, body.constant(4294901760u));
                        ir_expression *const r103D = equal(r103C, body.constant(0u));
                        ir_if *f103B = new(mem_ctx) ir_if(operand(r103D).val);
                        exec_list *const f103B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f103B->then_instructions;

                           body.emit(assign(r1038, body.constant(int(16)), 0x01));

                           body.emit(assign(r1036, lshift(r1030, body.constant(int(16))), 0x01));


                        body.instructions = f103B_parent_instructions;
                        body.emit(f103B);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r103F = bit_and(r1036, body.constant(4278190080u));
                        ir_expression *const r1040 = equal(r103F, body.constant(0u));
                        ir_if *f103E = new(mem_ctx) ir_if(operand(r1040).val);
                        exec_list *const f103E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f103E->then_instructions;

                           body.emit(assign(r1038, add(r1038, body.constant(int(8))), 0x01));

                           body.emit(assign(r1036, lshift(r1036, body.constant(int(8))), 0x01));


                        body.instructions = f103E_parent_instructions;
                        body.emit(f103E);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1042 = bit_and(r1036, body.constant(4026531840u));
                        ir_expression *const r1043 = equal(r1042, body.constant(0u));
                        ir_if *f1041 = new(mem_ctx) ir_if(operand(r1043).val);
                        exec_list *const f1041_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1041->then_instructions;

                           body.emit(assign(r1038, add(r1038, body.constant(int(4))), 0x01));

                           body.emit(assign(r1036, lshift(r1036, body.constant(int(4))), 0x01));


                        body.instructions = f1041_parent_instructions;
                        body.emit(f1041);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1045 = bit_and(r1036, body.constant(3221225472u));
                        ir_expression *const r1046 = equal(r1045, body.constant(0u));
                        ir_if *f1044 = new(mem_ctx) ir_if(operand(r1046).val);
                        exec_list *const f1044_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1044->then_instructions;

                           body.emit(assign(r1038, add(r1038, body.constant(int(2))), 0x01));

                           body.emit(assign(r1036, lshift(r1036, body.constant(int(2))), 0x01));


                        body.instructions = f1044_parent_instructions;
                        body.emit(f1044);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1048 = bit_and(r1036, body.constant(2147483648u));
                        ir_expression *const r1049 = equal(r1048, body.constant(0u));
                        ir_if *f1047 = new(mem_ctx) ir_if(operand(r1049).val);
                        exec_list *const f1047_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1047->then_instructions;

                           body.emit(assign(r1038, add(r1038, body.constant(int(1))), 0x01));


                        body.instructions = f1047_parent_instructions;
                        body.emit(f1047);

                        /* END IF */

                        body.emit(assign(r1037, r1038, 0x01));


                     body.instructions = f1039_parent_instructions;
                     body.emit(f1039);

                     /* END IF */

                     body.emit(assign(r1033, add(r1037, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r104B = lequal(body.constant(int(0)), r1033);
                     ir_if *f104A = new(mem_ctx) ir_if(operand(r104B).val);
                     exec_list *const f104A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f104A->then_instructions;

                        body.emit(assign(r1032, body.constant(0u), 0x01));

                        ir_variable *const r104C = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r104C, lshift(r1031, r1033), 0x01));

                        ir_variable *const r104D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r104F = equal(r1033, body.constant(int(0)));
                        ir_if *f104E = new(mem_ctx) ir_if(operand(r104F).val);
                        exec_list *const f104E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f104E->then_instructions;

                           body.emit(assign(r104D, r1030, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f104E->else_instructions;

                           ir_expression *const r1050 = lshift(r1030, r1033);
                           ir_expression *const r1051 = neg(r1033);
                           ir_expression *const r1052 = bit_and(r1051, body.constant(int(31)));
                           ir_expression *const r1053 = rshift(r1031, r1052);
                           body.emit(assign(r104D, bit_or(r1050, r1053), 0x01));


                        body.instructions = f104E_parent_instructions;
                        body.emit(f104E);

                        /* END IF */

                        body.emit(assign(r1030, r104D, 0x01));

                        body.emit(assign(r1031, r104C, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f104A->else_instructions;

                        ir_variable *const r1054 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r1054, body.constant(0u), 0x01));

                        ir_variable *const r1055 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r1055, neg(r1033), 0x01));

                        ir_variable *const r1056 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r1056);
                        ir_variable *const r1057 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r1057);
                        ir_variable *const r1058 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r1058);
                        ir_variable *const r1059 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r105A = neg(r1055);
                        body.emit(assign(r1059, bit_and(r105A, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r105C = equal(r1055, body.constant(int(0)));
                        ir_if *f105B = new(mem_ctx) ir_if(operand(r105C).val);
                        exec_list *const f105B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f105B->then_instructions;

                           body.emit(assign(r1056, r1054, 0x01));

                           body.emit(assign(r1057, r1031, 0x01));

                           body.emit(assign(r1058, r1030, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f105B->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r105E = less(r1055, body.constant(int(32)));
                           ir_if *f105D = new(mem_ctx) ir_if(operand(r105E).val);
                           exec_list *const f105D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f105D->then_instructions;

                              body.emit(assign(r1056, lshift(r1031, r1059), 0x01));

                              ir_expression *const r105F = lshift(r1030, r1059);
                              ir_expression *const r1060 = rshift(r1031, r1055);
                              body.emit(assign(r1057, bit_or(r105F, r1060), 0x01));

                              body.emit(assign(r1058, rshift(r1030, r1055), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f105D->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1062 = equal(r1055, body.constant(int(32)));
                              ir_if *f1061 = new(mem_ctx) ir_if(operand(r1062).val);
                              exec_list *const f1061_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1061->then_instructions;

                                 body.emit(assign(r1056, r1031, 0x01));

                                 body.emit(assign(r1057, r1030, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1061->else_instructions;

                                 body.emit(assign(r1054, bit_or(body.constant(0u), r1031), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1064 = less(r1055, body.constant(int(64)));
                                 ir_if *f1063 = new(mem_ctx) ir_if(operand(r1064).val);
                                 exec_list *const f1063_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1063->then_instructions;

                                    body.emit(assign(r1056, lshift(r1030, r1059), 0x01));

                                    ir_expression *const r1065 = bit_and(r1055, body.constant(int(31)));
                                    body.emit(assign(r1057, rshift(r1030, r1065), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1063->else_instructions;

                                    ir_variable *const r1066 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r1068 = equal(r1055, body.constant(int(64)));
                                    ir_if *f1067 = new(mem_ctx) ir_if(operand(r1068).val);
                                    exec_list *const f1067_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1067->then_instructions;

                                       body.emit(assign(r1066, r1030, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1067->else_instructions;

                                       ir_expression *const r1069 = nequal(r1030, body.constant(0u));
                                       ir_expression *const r106A = expr(ir_unop_b2i, r1069);
                                       body.emit(assign(r1066, expr(ir_unop_i2u, r106A), 0x01));


                                    body.instructions = f1067_parent_instructions;
                                    body.emit(f1067);

                                    /* END IF */

                                    body.emit(assign(r1056, r1066, 0x01));

                                    body.emit(assign(r1057, body.constant(0u), 0x01));


                                 body.instructions = f1063_parent_instructions;
                                 body.emit(f1063);

                                 /* END IF */


                              body.instructions = f1061_parent_instructions;
                              body.emit(f1061);

                              /* END IF */

                              body.emit(assign(r1058, body.constant(0u), 0x01));


                           body.instructions = f105D_parent_instructions;
                           body.emit(f105D);

                           /* END IF */

                           ir_expression *const r106B = nequal(r1054, body.constant(0u));
                           ir_expression *const r106C = expr(ir_unop_b2i, r106B);
                           ir_expression *const r106D = expr(ir_unop_i2u, r106C);
                           body.emit(assign(r1056, bit_or(r1056, r106D), 0x01));


                        body.instructions = f105B_parent_instructions;
                        body.emit(f105B);

                        /* END IF */

                        body.emit(assign(r1030, r1058, 0x01));

                        body.emit(assign(r1031, r1057, 0x01));

                        body.emit(assign(r1032, r1056, 0x01));


                     body.instructions = f104A_parent_instructions;
                     body.emit(f104A);

                     /* END IF */

                     body.emit(assign(r102F, sub(r102F, r1033), 0x01));

                     ir_variable *const r106E = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r106E, r102F, 0x01));

                     ir_variable *const r106F = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r106F, r1030, 0x01));

                     ir_variable *const r1070 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r1070, r1031, 0x01));

                     ir_variable *const r1071 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r1071, r1032, 0x01));

                     ir_variable *const r1072 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r1072, body.constant(true), 0x01));

                     ir_variable *const r1073 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r1074 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r1074);
                     ir_expression *const r1075 = expr(ir_unop_u2i, r1032);
                     body.emit(assign(r1074, less(r1075, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1077 = lequal(body.constant(int(2045)), r102F);
                     ir_if *f1076 = new(mem_ctx) ir_if(operand(r1077).val);
                     exec_list *const f1076_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1076->then_instructions;

                        ir_variable *const r1078 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r107A = less(body.constant(int(2045)), r102F);
                        ir_if *f1079 = new(mem_ctx) ir_if(operand(r107A).val);
                        exec_list *const f1079_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1079->then_instructions;

                           body.emit(assign(r1078, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1079->else_instructions;

                           ir_variable *const r107B = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r107D = equal(r102F, body.constant(int(2045)));
                           ir_if *f107C = new(mem_ctx) ir_if(operand(r107D).val);
                           exec_list *const f107C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f107C->then_instructions;

                              ir_expression *const r107E = equal(body.constant(2097151u), r1030);
                              ir_expression *const r107F = equal(body.constant(4294967295u), r1031);
                              body.emit(assign(r107B, logic_and(r107E, r107F), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f107C->else_instructions;

                              body.emit(assign(r107B, body.constant(false), 0x01));


                           body.instructions = f107C_parent_instructions;
                           body.emit(f107C);

                           /* END IF */

                           body.emit(assign(r1078, logic_and(r107B, r1074), 0x01));


                        body.instructions = f1079_parent_instructions;
                        body.emit(f1079);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f1080 = new(mem_ctx) ir_if(operand(r1078).val);
                        exec_list *const f1080_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1080->then_instructions;

                           ir_variable *const r1081 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r1081);
                           ir_expression *const r1082 = lshift(r0DB6, body.constant(int(31)));
                           body.emit(assign(r1081, add(r1082, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r1081, body.constant(0u), 0x01));

                           body.emit(assign(r1073, r1081, 0x03));

                           body.emit(assign(r1072, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1080->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1084 = less(r102F, body.constant(int(0)));
                           ir_if *f1083 = new(mem_ctx) ir_if(operand(r1084).val);
                           exec_list *const f1083_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1083->then_instructions;

                              ir_variable *const r1085 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r1085, r1032, 0x01));

                              ir_variable *const r1086 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r1086, neg(r102F), 0x01));

                              ir_variable *const r1087 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r1087);
                              ir_variable *const r1088 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r1088);
                              ir_variable *const r1089 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r1089);
                              ir_variable *const r108A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r108B = neg(r1086);
                              body.emit(assign(r108A, bit_and(r108B, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r108D = equal(r1086, body.constant(int(0)));
                              ir_if *f108C = new(mem_ctx) ir_if(operand(r108D).val);
                              exec_list *const f108C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f108C->then_instructions;

                                 body.emit(assign(r1087, r1032, 0x01));

                                 body.emit(assign(r1088, r1031, 0x01));

                                 body.emit(assign(r1089, r1030, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f108C->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r108F = less(r1086, body.constant(int(32)));
                                 ir_if *f108E = new(mem_ctx) ir_if(operand(r108F).val);
                                 exec_list *const f108E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f108E->then_instructions;

                                    body.emit(assign(r1087, lshift(r1031, r108A), 0x01));

                                    ir_expression *const r1090 = lshift(r1030, r108A);
                                    ir_expression *const r1091 = rshift(r1031, r1086);
                                    body.emit(assign(r1088, bit_or(r1090, r1091), 0x01));

                                    body.emit(assign(r1089, rshift(r1030, r1086), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f108E->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r1093 = equal(r1086, body.constant(int(32)));
                                    ir_if *f1092 = new(mem_ctx) ir_if(operand(r1093).val);
                                    exec_list *const f1092_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1092->then_instructions;

                                       body.emit(assign(r1087, r1031, 0x01));

                                       body.emit(assign(r1088, r1030, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1092->else_instructions;

                                       body.emit(assign(r1085, bit_or(r1032, r1031), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r1095 = less(r1086, body.constant(int(64)));
                                       ir_if *f1094 = new(mem_ctx) ir_if(operand(r1095).val);
                                       exec_list *const f1094_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1094->then_instructions;

                                          body.emit(assign(r1087, lshift(r1030, r108A), 0x01));

                                          ir_expression *const r1096 = bit_and(r1086, body.constant(int(31)));
                                          body.emit(assign(r1088, rshift(r1030, r1096), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1094->else_instructions;

                                          ir_variable *const r1097 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r1099 = equal(r1086, body.constant(int(64)));
                                          ir_if *f1098 = new(mem_ctx) ir_if(operand(r1099).val);
                                          exec_list *const f1098_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1098->then_instructions;

                                             body.emit(assign(r1097, r1030, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1098->else_instructions;

                                             ir_expression *const r109A = nequal(r1030, body.constant(0u));
                                             ir_expression *const r109B = expr(ir_unop_b2i, r109A);
                                             body.emit(assign(r1097, expr(ir_unop_i2u, r109B), 0x01));


                                          body.instructions = f1098_parent_instructions;
                                          body.emit(f1098);

                                          /* END IF */

                                          body.emit(assign(r1087, r1097, 0x01));

                                          body.emit(assign(r1088, body.constant(0u), 0x01));


                                       body.instructions = f1094_parent_instructions;
                                       body.emit(f1094);

                                       /* END IF */


                                    body.instructions = f1092_parent_instructions;
                                    body.emit(f1092);

                                    /* END IF */

                                    body.emit(assign(r1089, body.constant(0u), 0x01));


                                 body.instructions = f108E_parent_instructions;
                                 body.emit(f108E);

                                 /* END IF */

                                 ir_expression *const r109C = nequal(r1085, body.constant(0u));
                                 ir_expression *const r109D = expr(ir_unop_b2i, r109C);
                                 ir_expression *const r109E = expr(ir_unop_i2u, r109D);
                                 body.emit(assign(r1087, bit_or(r1087, r109E), 0x01));


                              body.instructions = f108C_parent_instructions;
                              body.emit(f108C);

                              /* END IF */

                              body.emit(assign(r106F, r1089, 0x01));

                              body.emit(assign(r1070, r1088, 0x01));

                              body.emit(assign(r1071, r1087, 0x01));

                              body.emit(assign(r106E, body.constant(int(0)), 0x01));

                              body.emit(assign(r1074, less(r1087, body.constant(0u)), 0x01));


                           body.instructions = f1083_parent_instructions;
                           body.emit(f1083);

                           /* END IF */


                        body.instructions = f1080_parent_instructions;
                        body.emit(f1080);

                        /* END IF */


                     body.instructions = f1076_parent_instructions;
                     body.emit(f1076);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f109F = new(mem_ctx) ir_if(operand(r1072).val);
                     exec_list *const f109F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f109F->then_instructions;

                        /* IF CONDITION */
                        ir_if *f10A0 = new(mem_ctx) ir_if(operand(r1074).val);
                        exec_list *const f10A0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f10A0->then_instructions;

                           ir_variable *const r10A1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r10A1, add(r1070, body.constant(1u)), 0x01));

                           ir_expression *const r10A2 = less(r10A1, r1070);
                           ir_expression *const r10A3 = expr(ir_unop_b2i, r10A2);
                           ir_expression *const r10A4 = expr(ir_unop_i2u, r10A3);
                           body.emit(assign(r106F, add(r106F, r10A4), 0x01));

                           ir_expression *const r10A5 = equal(r1071, body.constant(0u));
                           ir_expression *const r10A6 = expr(ir_unop_b2i, r10A5);
                           ir_expression *const r10A7 = expr(ir_unop_i2u, r10A6);
                           ir_expression *const r10A8 = add(r1071, r10A7);
                           ir_expression *const r10A9 = bit_and(r10A8, body.constant(1u));
                           ir_expression *const r10AA = expr(ir_unop_bit_not, r10A9);
                           body.emit(assign(r1070, bit_and(r10A1, r10AA), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f10A0->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r10AC = bit_or(r106F, r1070);
                           ir_expression *const r10AD = equal(r10AC, body.constant(0u));
                           ir_if *f10AB = new(mem_ctx) ir_if(operand(r10AD).val);
                           exec_list *const f10AB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10AB->then_instructions;

                              body.emit(assign(r106E, body.constant(int(0)), 0x01));


                           body.instructions = f10AB_parent_instructions;
                           body.emit(f10AB);

                           /* END IF */


                        body.instructions = f10A0_parent_instructions;
                        body.emit(f10A0);

                        /* END IF */

                        ir_variable *const r10AE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r10AE);
                        ir_expression *const r10AF = lshift(r0DB6, body.constant(int(31)));
                        ir_expression *const r10B0 = expr(ir_unop_i2u, r106E);
                        ir_expression *const r10B1 = lshift(r10B0, body.constant(int(20)));
                        ir_expression *const r10B2 = add(r10AF, r10B1);
                        body.emit(assign(r10AE, add(r10B2, r106F), 0x02));

                        body.emit(assign(r10AE, r1070, 0x01));

                        body.emit(assign(r1073, r10AE, 0x03));

                        body.emit(assign(r1072, body.constant(false), 0x01));


                     body.instructions = f109F_parent_instructions;
                     body.emit(f109F);

                     /* END IF */

                     body.emit(assign(r0DB7, r1073, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1027->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r10B4 = less(r0DBC, r0DBE);
                     ir_if *f10B3 = new(mem_ctx) ir_if(operand(r10B4).val);
                     exec_list *const f10B3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f10B3->then_instructions;

                        ir_variable *const r10B5 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r10B6 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r10B6, sub(r0DBE, r0DBC), 0x01));

                        ir_expression *const r10B7 = sub(r0DBD, r0DBB);
                        ir_expression *const r10B8 = less(r0DBE, r0DBC);
                        ir_expression *const r10B9 = expr(ir_unop_b2i, r10B8);
                        ir_expression *const r10BA = expr(ir_unop_i2u, r10B9);
                        body.emit(assign(r10B5, sub(r10B7, r10BA), 0x01));

                        body.emit(assign(r0DBF, add(r0DBA, body.constant(int(-1))), 0x01));

                        ir_variable *const r10BB = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r10BB, add(r0DBF, body.constant(int(-10))), 0x01));

                        ir_variable *const r10BC = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r10BC, r10B5, 0x01));

                        ir_variable *const r10BD = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r10BD, r10B6, 0x01));

                        ir_variable *const r10BE = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r10BE);
                        ir_variable *const r10BF = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r10BF);
                        /* IF CONDITION */
                        ir_expression *const r10C1 = equal(r10B5, body.constant(0u));
                        ir_if *f10C0 = new(mem_ctx) ir_if(operand(r10C1).val);
                        exec_list *const f10C0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f10C0->then_instructions;

                           body.emit(assign(r10BC, r10B6, 0x01));

                           body.emit(assign(r10BD, body.constant(0u), 0x01));

                           body.emit(assign(r10BB, add(r10BB, body.constant(int(-32))), 0x01));


                        body.instructions = f10C0_parent_instructions;
                        body.emit(f10C0);

                        /* END IF */

                        ir_variable *const r10C2 = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r10C2, r10BC, 0x01));

                        ir_variable *const r10C3 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r10C4 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r10C4);
                        /* IF CONDITION */
                        ir_expression *const r10C6 = equal(r10BC, body.constant(0u));
                        ir_if *f10C5 = new(mem_ctx) ir_if(operand(r10C6).val);
                        exec_list *const f10C5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f10C5->then_instructions;

                           body.emit(assign(r10C3, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f10C5->else_instructions;

                           body.emit(assign(r10C4, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r10C8 = bit_and(r10BC, body.constant(4294901760u));
                           ir_expression *const r10C9 = equal(r10C8, body.constant(0u));
                           ir_if *f10C7 = new(mem_ctx) ir_if(operand(r10C9).val);
                           exec_list *const f10C7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10C7->then_instructions;

                              body.emit(assign(r10C4, body.constant(int(16)), 0x01));

                              body.emit(assign(r10C2, lshift(r10BC, body.constant(int(16))), 0x01));


                           body.instructions = f10C7_parent_instructions;
                           body.emit(f10C7);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r10CB = bit_and(r10C2, body.constant(4278190080u));
                           ir_expression *const r10CC = equal(r10CB, body.constant(0u));
                           ir_if *f10CA = new(mem_ctx) ir_if(operand(r10CC).val);
                           exec_list *const f10CA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10CA->then_instructions;

                              body.emit(assign(r10C4, add(r10C4, body.constant(int(8))), 0x01));

                              body.emit(assign(r10C2, lshift(r10C2, body.constant(int(8))), 0x01));


                           body.instructions = f10CA_parent_instructions;
                           body.emit(f10CA);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r10CE = bit_and(r10C2, body.constant(4026531840u));
                           ir_expression *const r10CF = equal(r10CE, body.constant(0u));
                           ir_if *f10CD = new(mem_ctx) ir_if(operand(r10CF).val);
                           exec_list *const f10CD_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10CD->then_instructions;

                              body.emit(assign(r10C4, add(r10C4, body.constant(int(4))), 0x01));

                              body.emit(assign(r10C2, lshift(r10C2, body.constant(int(4))), 0x01));


                           body.instructions = f10CD_parent_instructions;
                           body.emit(f10CD);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r10D1 = bit_and(r10C2, body.constant(3221225472u));
                           ir_expression *const r10D2 = equal(r10D1, body.constant(0u));
                           ir_if *f10D0 = new(mem_ctx) ir_if(operand(r10D2).val);
                           exec_list *const f10D0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10D0->then_instructions;

                              body.emit(assign(r10C4, add(r10C4, body.constant(int(2))), 0x01));

                              body.emit(assign(r10C2, lshift(r10C2, body.constant(int(2))), 0x01));


                           body.instructions = f10D0_parent_instructions;
                           body.emit(f10D0);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r10D4 = bit_and(r10C2, body.constant(2147483648u));
                           ir_expression *const r10D5 = equal(r10D4, body.constant(0u));
                           ir_if *f10D3 = new(mem_ctx) ir_if(operand(r10D5).val);
                           exec_list *const f10D3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10D3->then_instructions;

                              body.emit(assign(r10C4, add(r10C4, body.constant(int(1))), 0x01));


                           body.instructions = f10D3_parent_instructions;
                           body.emit(f10D3);

                           /* END IF */

                           body.emit(assign(r10C3, r10C4, 0x01));


                        body.instructions = f10C5_parent_instructions;
                        body.emit(f10C5);

                        /* END IF */

                        body.emit(assign(r10BF, add(r10C3, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r10D7 = lequal(body.constant(int(0)), r10BF);
                        ir_if *f10D6 = new(mem_ctx) ir_if(operand(r10D7).val);
                        exec_list *const f10D6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f10D6->then_instructions;

                           body.emit(assign(r10BE, body.constant(0u), 0x01));

                           ir_variable *const r10D8 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r10D8, lshift(r10BD, r10BF), 0x01));

                           ir_variable *const r10D9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r10DB = equal(r10BF, body.constant(int(0)));
                           ir_if *f10DA = new(mem_ctx) ir_if(operand(r10DB).val);
                           exec_list *const f10DA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10DA->then_instructions;

                              body.emit(assign(r10D9, r10BC, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f10DA->else_instructions;

                              ir_expression *const r10DC = lshift(r10BC, r10BF);
                              ir_expression *const r10DD = neg(r10BF);
                              ir_expression *const r10DE = bit_and(r10DD, body.constant(int(31)));
                              ir_expression *const r10DF = rshift(r10BD, r10DE);
                              body.emit(assign(r10D9, bit_or(r10DC, r10DF), 0x01));


                           body.instructions = f10DA_parent_instructions;
                           body.emit(f10DA);

                           /* END IF */

                           body.emit(assign(r10BC, r10D9, 0x01));

                           body.emit(assign(r10BD, r10D8, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f10D6->else_instructions;

                           ir_variable *const r10E0 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r10E0, body.constant(0u), 0x01));

                           ir_variable *const r10E1 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r10E1, neg(r10BF), 0x01));

                           ir_variable *const r10E2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r10E2);
                           ir_variable *const r10E3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r10E3);
                           ir_variable *const r10E4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r10E4);
                           ir_variable *const r10E5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r10E6 = neg(r10E1);
                           body.emit(assign(r10E5, bit_and(r10E6, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r10E8 = equal(r10E1, body.constant(int(0)));
                           ir_if *f10E7 = new(mem_ctx) ir_if(operand(r10E8).val);
                           exec_list *const f10E7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10E7->then_instructions;

                              body.emit(assign(r10E2, r10E0, 0x01));

                              body.emit(assign(r10E3, r10BD, 0x01));

                              body.emit(assign(r10E4, r10BC, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f10E7->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r10EA = less(r10E1, body.constant(int(32)));
                              ir_if *f10E9 = new(mem_ctx) ir_if(operand(r10EA).val);
                              exec_list *const f10E9_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f10E9->then_instructions;

                                 body.emit(assign(r10E2, lshift(r10BD, r10E5), 0x01));

                                 ir_expression *const r10EB = lshift(r10BC, r10E5);
                                 ir_expression *const r10EC = rshift(r10BD, r10E1);
                                 body.emit(assign(r10E3, bit_or(r10EB, r10EC), 0x01));

                                 body.emit(assign(r10E4, rshift(r10BC, r10E1), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f10E9->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r10EE = equal(r10E1, body.constant(int(32)));
                                 ir_if *f10ED = new(mem_ctx) ir_if(operand(r10EE).val);
                                 exec_list *const f10ED_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f10ED->then_instructions;

                                    body.emit(assign(r10E2, r10BD, 0x01));

                                    body.emit(assign(r10E3, r10BC, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f10ED->else_instructions;

                                    body.emit(assign(r10E0, bit_or(body.constant(0u), r10BD), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r10F0 = less(r10E1, body.constant(int(64)));
                                    ir_if *f10EF = new(mem_ctx) ir_if(operand(r10F0).val);
                                    exec_list *const f10EF_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f10EF->then_instructions;

                                       body.emit(assign(r10E2, lshift(r10BC, r10E5), 0x01));

                                       ir_expression *const r10F1 = bit_and(r10E1, body.constant(int(31)));
                                       body.emit(assign(r10E3, rshift(r10BC, r10F1), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f10EF->else_instructions;

                                       ir_variable *const r10F2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r10F4 = equal(r10E1, body.constant(int(64)));
                                       ir_if *f10F3 = new(mem_ctx) ir_if(operand(r10F4).val);
                                       exec_list *const f10F3_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f10F3->then_instructions;

                                          body.emit(assign(r10F2, r10BC, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f10F3->else_instructions;

                                          ir_expression *const r10F5 = nequal(r10BC, body.constant(0u));
                                          ir_expression *const r10F6 = expr(ir_unop_b2i, r10F5);
                                          body.emit(assign(r10F2, expr(ir_unop_i2u, r10F6), 0x01));


                                       body.instructions = f10F3_parent_instructions;
                                       body.emit(f10F3);

                                       /* END IF */

                                       body.emit(assign(r10E2, r10F2, 0x01));

                                       body.emit(assign(r10E3, body.constant(0u), 0x01));


                                    body.instructions = f10EF_parent_instructions;
                                    body.emit(f10EF);

                                    /* END IF */


                                 body.instructions = f10ED_parent_instructions;
                                 body.emit(f10ED);

                                 /* END IF */

                                 body.emit(assign(r10E4, body.constant(0u), 0x01));


                              body.instructions = f10E9_parent_instructions;
                              body.emit(f10E9);

                              /* END IF */

                              ir_expression *const r10F7 = nequal(r10E0, body.constant(0u));
                              ir_expression *const r10F8 = expr(ir_unop_b2i, r10F7);
                              ir_expression *const r10F9 = expr(ir_unop_i2u, r10F8);
                              body.emit(assign(r10E2, bit_or(r10E2, r10F9), 0x01));


                           body.instructions = f10E7_parent_instructions;
                           body.emit(f10E7);

                           /* END IF */

                           body.emit(assign(r10BC, r10E4, 0x01));

                           body.emit(assign(r10BD, r10E3, 0x01));

                           body.emit(assign(r10BE, r10E2, 0x01));


                        body.instructions = f10D6_parent_instructions;
                        body.emit(f10D6);

                        /* END IF */

                        body.emit(assign(r10BB, sub(r10BB, r10BF), 0x01));

                        ir_variable *const r10FA = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r10FA, r10BB, 0x01));

                        ir_variable *const r10FB = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r10FB, r10BC, 0x01));

                        ir_variable *const r10FC = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r10FC, r10BD, 0x01));

                        ir_variable *const r10FD = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r10FD, r10BE, 0x01));

                        ir_variable *const r10FE = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r10FE, body.constant(true), 0x01));

                        ir_variable *const r10FF = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r1100 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r1100);
                        ir_expression *const r1101 = expr(ir_unop_u2i, r10BE);
                        body.emit(assign(r1100, less(r1101, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1103 = lequal(body.constant(int(2045)), r10BB);
                        ir_if *f1102 = new(mem_ctx) ir_if(operand(r1103).val);
                        exec_list *const f1102_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1102->then_instructions;

                           ir_variable *const r1104 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r1106 = less(body.constant(int(2045)), r10BB);
                           ir_if *f1105 = new(mem_ctx) ir_if(operand(r1106).val);
                           exec_list *const f1105_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1105->then_instructions;

                              body.emit(assign(r1104, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1105->else_instructions;

                              ir_variable *const r1107 = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1109 = equal(r10BB, body.constant(int(2045)));
                              ir_if *f1108 = new(mem_ctx) ir_if(operand(r1109).val);
                              exec_list *const f1108_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1108->then_instructions;

                                 ir_expression *const r110A = equal(body.constant(2097151u), r10BC);
                                 ir_expression *const r110B = equal(body.constant(4294967295u), r10BD);
                                 body.emit(assign(r1107, logic_and(r110A, r110B), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1108->else_instructions;

                                 body.emit(assign(r1107, body.constant(false), 0x01));


                              body.instructions = f1108_parent_instructions;
                              body.emit(f1108);

                              /* END IF */

                              body.emit(assign(r1104, logic_and(r1107, r1100), 0x01));


                           body.instructions = f1105_parent_instructions;
                           body.emit(f1105);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f110C = new(mem_ctx) ir_if(operand(r1104).val);
                           exec_list *const f110C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f110C->then_instructions;

                              ir_variable *const r110D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r110D);
                              ir_expression *const r110E = lshift(r0DB6, body.constant(int(31)));
                              body.emit(assign(r110D, add(r110E, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r110D, body.constant(0u), 0x01));

                              body.emit(assign(r10FF, r110D, 0x03));

                              body.emit(assign(r10FE, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f110C->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1110 = less(r10BB, body.constant(int(0)));
                              ir_if *f110F = new(mem_ctx) ir_if(operand(r1110).val);
                              exec_list *const f110F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f110F->then_instructions;

                                 ir_variable *const r1111 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r1111, r10BE, 0x01));

                                 ir_variable *const r1112 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r1112, neg(r10BB), 0x01));

                                 ir_variable *const r1113 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r1113);
                                 ir_variable *const r1114 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r1114);
                                 ir_variable *const r1115 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r1115);
                                 ir_variable *const r1116 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r1117 = neg(r1112);
                                 body.emit(assign(r1116, bit_and(r1117, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1119 = equal(r1112, body.constant(int(0)));
                                 ir_if *f1118 = new(mem_ctx) ir_if(operand(r1119).val);
                                 exec_list *const f1118_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1118->then_instructions;

                                    body.emit(assign(r1113, r10BE, 0x01));

                                    body.emit(assign(r1114, r10BD, 0x01));

                                    body.emit(assign(r1115, r10BC, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1118->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r111B = less(r1112, body.constant(int(32)));
                                    ir_if *f111A = new(mem_ctx) ir_if(operand(r111B).val);
                                    exec_list *const f111A_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f111A->then_instructions;

                                       body.emit(assign(r1113, lshift(r10BD, r1116), 0x01));

                                       ir_expression *const r111C = lshift(r10BC, r1116);
                                       ir_expression *const r111D = rshift(r10BD, r1112);
                                       body.emit(assign(r1114, bit_or(r111C, r111D), 0x01));

                                       body.emit(assign(r1115, rshift(r10BC, r1112), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f111A->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r111F = equal(r1112, body.constant(int(32)));
                                       ir_if *f111E = new(mem_ctx) ir_if(operand(r111F).val);
                                       exec_list *const f111E_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f111E->then_instructions;

                                          body.emit(assign(r1113, r10BD, 0x01));

                                          body.emit(assign(r1114, r10BC, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f111E->else_instructions;

                                          body.emit(assign(r1111, bit_or(r10BE, r10BD), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r1121 = less(r1112, body.constant(int(64)));
                                          ir_if *f1120 = new(mem_ctx) ir_if(operand(r1121).val);
                                          exec_list *const f1120_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1120->then_instructions;

                                             body.emit(assign(r1113, lshift(r10BC, r1116), 0x01));

                                             ir_expression *const r1122 = bit_and(r1112, body.constant(int(31)));
                                             body.emit(assign(r1114, rshift(r10BC, r1122), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1120->else_instructions;

                                             ir_variable *const r1123 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r1125 = equal(r1112, body.constant(int(64)));
                                             ir_if *f1124 = new(mem_ctx) ir_if(operand(r1125).val);
                                             exec_list *const f1124_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f1124->then_instructions;

                                                body.emit(assign(r1123, r10BC, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f1124->else_instructions;

                                                ir_expression *const r1126 = nequal(r10BC, body.constant(0u));
                                                ir_expression *const r1127 = expr(ir_unop_b2i, r1126);
                                                body.emit(assign(r1123, expr(ir_unop_i2u, r1127), 0x01));


                                             body.instructions = f1124_parent_instructions;
                                             body.emit(f1124);

                                             /* END IF */

                                             body.emit(assign(r1113, r1123, 0x01));

                                             body.emit(assign(r1114, body.constant(0u), 0x01));


                                          body.instructions = f1120_parent_instructions;
                                          body.emit(f1120);

                                          /* END IF */


                                       body.instructions = f111E_parent_instructions;
                                       body.emit(f111E);

                                       /* END IF */

                                       body.emit(assign(r1115, body.constant(0u), 0x01));


                                    body.instructions = f111A_parent_instructions;
                                    body.emit(f111A);

                                    /* END IF */

                                    ir_expression *const r1128 = nequal(r1111, body.constant(0u));
                                    ir_expression *const r1129 = expr(ir_unop_b2i, r1128);
                                    ir_expression *const r112A = expr(ir_unop_i2u, r1129);
                                    body.emit(assign(r1113, bit_or(r1113, r112A), 0x01));


                                 body.instructions = f1118_parent_instructions;
                                 body.emit(f1118);

                                 /* END IF */

                                 body.emit(assign(r10FB, r1115, 0x01));

                                 body.emit(assign(r10FC, r1114, 0x01));

                                 body.emit(assign(r10FD, r1113, 0x01));

                                 body.emit(assign(r10FA, body.constant(int(0)), 0x01));

                                 body.emit(assign(r1100, less(r1113, body.constant(0u)), 0x01));


                              body.instructions = f110F_parent_instructions;
                              body.emit(f110F);

                              /* END IF */


                           body.instructions = f110C_parent_instructions;
                           body.emit(f110C);

                           /* END IF */


                        body.instructions = f1102_parent_instructions;
                        body.emit(f1102);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f112B = new(mem_ctx) ir_if(operand(r10FE).val);
                        exec_list *const f112B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f112B->then_instructions;

                           /* IF CONDITION */
                           ir_if *f112C = new(mem_ctx) ir_if(operand(r1100).val);
                           exec_list *const f112C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f112C->then_instructions;

                              ir_variable *const r112D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r112D, add(r10FC, body.constant(1u)), 0x01));

                              ir_expression *const r112E = less(r112D, r10FC);
                              ir_expression *const r112F = expr(ir_unop_b2i, r112E);
                              ir_expression *const r1130 = expr(ir_unop_i2u, r112F);
                              body.emit(assign(r10FB, add(r10FB, r1130), 0x01));

                              ir_expression *const r1131 = equal(r10FD, body.constant(0u));
                              ir_expression *const r1132 = expr(ir_unop_b2i, r1131);
                              ir_expression *const r1133 = expr(ir_unop_i2u, r1132);
                              ir_expression *const r1134 = add(r10FD, r1133);
                              ir_expression *const r1135 = bit_and(r1134, body.constant(1u));
                              ir_expression *const r1136 = expr(ir_unop_bit_not, r1135);
                              body.emit(assign(r10FC, bit_and(r112D, r1136), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f112C->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1138 = bit_or(r10FB, r10FC);
                              ir_expression *const r1139 = equal(r1138, body.constant(0u));
                              ir_if *f1137 = new(mem_ctx) ir_if(operand(r1139).val);
                              exec_list *const f1137_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1137->then_instructions;

                                 body.emit(assign(r10FA, body.constant(int(0)), 0x01));


                              body.instructions = f1137_parent_instructions;
                              body.emit(f1137);

                              /* END IF */


                           body.instructions = f112C_parent_instructions;
                           body.emit(f112C);

                           /* END IF */

                           ir_variable *const r113A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r113A);
                           ir_expression *const r113B = lshift(r0DB6, body.constant(int(31)));
                           ir_expression *const r113C = expr(ir_unop_i2u, r10FA);
                           ir_expression *const r113D = lshift(r113C, body.constant(int(20)));
                           ir_expression *const r113E = add(r113B, r113D);
                           body.emit(assign(r113A, add(r113E, r10FB), 0x02));

                           body.emit(assign(r113A, r10FC, 0x01));

                           body.emit(assign(r10FF, r113A, 0x03));

                           body.emit(assign(r10FE, body.constant(false), 0x01));


                        body.instructions = f112B_parent_instructions;
                        body.emit(f112B);

                        /* END IF */

                        body.emit(assign(r0DB7, r10FF, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f10B3->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1140 = less(r0DBE, r0DBC);
                        ir_if *f113F = new(mem_ctx) ir_if(operand(r1140).val);
                        exec_list *const f113F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f113F->then_instructions;

                           ir_variable *const r1141 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r1142 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r1142, sub(r0DBC, r0DBE), 0x01));

                           ir_expression *const r1143 = sub(r0DBB, r0DBD);
                           ir_expression *const r1144 = less(r0DBC, r0DBE);
                           ir_expression *const r1145 = expr(ir_unop_b2i, r1144);
                           ir_expression *const r1146 = expr(ir_unop_i2u, r1145);
                           body.emit(assign(r1141, sub(r1143, r1146), 0x01));

                           body.emit(assign(r0DB6, bit_xor(r0DB6, body.constant(1u)), 0x01));

                           body.emit(assign(r0DBF, add(r0DB9, body.constant(int(-1))), 0x01));

                           ir_variable *const r1147 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r1147, add(r0DBF, body.constant(int(-10))), 0x01));

                           ir_variable *const r1148 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r1148, r1141, 0x01));

                           ir_variable *const r1149 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r1149, r1142, 0x01));

                           ir_variable *const r114A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r114A);
                           ir_variable *const r114B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r114B);
                           /* IF CONDITION */
                           ir_expression *const r114D = equal(r1141, body.constant(0u));
                           ir_if *f114C = new(mem_ctx) ir_if(operand(r114D).val);
                           exec_list *const f114C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f114C->then_instructions;

                              body.emit(assign(r1148, r1142, 0x01));

                              body.emit(assign(r1149, body.constant(0u), 0x01));

                              body.emit(assign(r1147, add(r1147, body.constant(int(-32))), 0x01));


                           body.instructions = f114C_parent_instructions;
                           body.emit(f114C);

                           /* END IF */

                           ir_variable *const r114E = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r114E, r1148, 0x01));

                           ir_variable *const r114F = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r1150 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r1150);
                           /* IF CONDITION */
                           ir_expression *const r1152 = equal(r1148, body.constant(0u));
                           ir_if *f1151 = new(mem_ctx) ir_if(operand(r1152).val);
                           exec_list *const f1151_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1151->then_instructions;

                              body.emit(assign(r114F, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1151->else_instructions;

                              body.emit(assign(r1150, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1154 = bit_and(r1148, body.constant(4294901760u));
                              ir_expression *const r1155 = equal(r1154, body.constant(0u));
                              ir_if *f1153 = new(mem_ctx) ir_if(operand(r1155).val);
                              exec_list *const f1153_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1153->then_instructions;

                                 body.emit(assign(r1150, body.constant(int(16)), 0x01));

                                 body.emit(assign(r114E, lshift(r1148, body.constant(int(16))), 0x01));


                              body.instructions = f1153_parent_instructions;
                              body.emit(f1153);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r1157 = bit_and(r114E, body.constant(4278190080u));
                              ir_expression *const r1158 = equal(r1157, body.constant(0u));
                              ir_if *f1156 = new(mem_ctx) ir_if(operand(r1158).val);
                              exec_list *const f1156_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1156->then_instructions;

                                 body.emit(assign(r1150, add(r1150, body.constant(int(8))), 0x01));

                                 body.emit(assign(r114E, lshift(r114E, body.constant(int(8))), 0x01));


                              body.instructions = f1156_parent_instructions;
                              body.emit(f1156);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r115A = bit_and(r114E, body.constant(4026531840u));
                              ir_expression *const r115B = equal(r115A, body.constant(0u));
                              ir_if *f1159 = new(mem_ctx) ir_if(operand(r115B).val);
                              exec_list *const f1159_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1159->then_instructions;

                                 body.emit(assign(r1150, add(r1150, body.constant(int(4))), 0x01));

                                 body.emit(assign(r114E, lshift(r114E, body.constant(int(4))), 0x01));


                              body.instructions = f1159_parent_instructions;
                              body.emit(f1159);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r115D = bit_and(r114E, body.constant(3221225472u));
                              ir_expression *const r115E = equal(r115D, body.constant(0u));
                              ir_if *f115C = new(mem_ctx) ir_if(operand(r115E).val);
                              exec_list *const f115C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f115C->then_instructions;

                                 body.emit(assign(r1150, add(r1150, body.constant(int(2))), 0x01));

                                 body.emit(assign(r114E, lshift(r114E, body.constant(int(2))), 0x01));


                              body.instructions = f115C_parent_instructions;
                              body.emit(f115C);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r1160 = bit_and(r114E, body.constant(2147483648u));
                              ir_expression *const r1161 = equal(r1160, body.constant(0u));
                              ir_if *f115F = new(mem_ctx) ir_if(operand(r1161).val);
                              exec_list *const f115F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f115F->then_instructions;

                                 body.emit(assign(r1150, add(r1150, body.constant(int(1))), 0x01));


                              body.instructions = f115F_parent_instructions;
                              body.emit(f115F);

                              /* END IF */

                              body.emit(assign(r114F, r1150, 0x01));


                           body.instructions = f1151_parent_instructions;
                           body.emit(f1151);

                           /* END IF */

                           body.emit(assign(r114B, add(r114F, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1163 = lequal(body.constant(int(0)), r114B);
                           ir_if *f1162 = new(mem_ctx) ir_if(operand(r1163).val);
                           exec_list *const f1162_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1162->then_instructions;

                              body.emit(assign(r114A, body.constant(0u), 0x01));

                              ir_variable *const r1164 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r1164, lshift(r1149, r114B), 0x01));

                              ir_variable *const r1165 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1167 = equal(r114B, body.constant(int(0)));
                              ir_if *f1166 = new(mem_ctx) ir_if(operand(r1167).val);
                              exec_list *const f1166_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1166->then_instructions;

                                 body.emit(assign(r1165, r1148, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1166->else_instructions;

                                 ir_expression *const r1168 = lshift(r1148, r114B);
                                 ir_expression *const r1169 = neg(r114B);
                                 ir_expression *const r116A = bit_and(r1169, body.constant(int(31)));
                                 ir_expression *const r116B = rshift(r1149, r116A);
                                 body.emit(assign(r1165, bit_or(r1168, r116B), 0x01));


                              body.instructions = f1166_parent_instructions;
                              body.emit(f1166);

                              /* END IF */

                              body.emit(assign(r1148, r1165, 0x01));

                              body.emit(assign(r1149, r1164, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1162->else_instructions;

                              ir_variable *const r116C = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r116C, body.constant(0u), 0x01));

                              ir_variable *const r116D = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r116D, neg(r114B), 0x01));

                              ir_variable *const r116E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r116E);
                              ir_variable *const r116F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r116F);
                              ir_variable *const r1170 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r1170);
                              ir_variable *const r1171 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r1172 = neg(r116D);
                              body.emit(assign(r1171, bit_and(r1172, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1174 = equal(r116D, body.constant(int(0)));
                              ir_if *f1173 = new(mem_ctx) ir_if(operand(r1174).val);
                              exec_list *const f1173_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1173->then_instructions;

                                 body.emit(assign(r116E, r116C, 0x01));

                                 body.emit(assign(r116F, r1149, 0x01));

                                 body.emit(assign(r1170, r1148, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1173->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1176 = less(r116D, body.constant(int(32)));
                                 ir_if *f1175 = new(mem_ctx) ir_if(operand(r1176).val);
                                 exec_list *const f1175_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1175->then_instructions;

                                    body.emit(assign(r116E, lshift(r1149, r1171), 0x01));

                                    ir_expression *const r1177 = lshift(r1148, r1171);
                                    ir_expression *const r1178 = rshift(r1149, r116D);
                                    body.emit(assign(r116F, bit_or(r1177, r1178), 0x01));

                                    body.emit(assign(r1170, rshift(r1148, r116D), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1175->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r117A = equal(r116D, body.constant(int(32)));
                                    ir_if *f1179 = new(mem_ctx) ir_if(operand(r117A).val);
                                    exec_list *const f1179_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1179->then_instructions;

                                       body.emit(assign(r116E, r1149, 0x01));

                                       body.emit(assign(r116F, r1148, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1179->else_instructions;

                                       body.emit(assign(r116C, bit_or(body.constant(0u), r1149), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r117C = less(r116D, body.constant(int(64)));
                                       ir_if *f117B = new(mem_ctx) ir_if(operand(r117C).val);
                                       exec_list *const f117B_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f117B->then_instructions;

                                          body.emit(assign(r116E, lshift(r1148, r1171), 0x01));

                                          ir_expression *const r117D = bit_and(r116D, body.constant(int(31)));
                                          body.emit(assign(r116F, rshift(r1148, r117D), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f117B->else_instructions;

                                          ir_variable *const r117E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r1180 = equal(r116D, body.constant(int(64)));
                                          ir_if *f117F = new(mem_ctx) ir_if(operand(r1180).val);
                                          exec_list *const f117F_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f117F->then_instructions;

                                             body.emit(assign(r117E, r1148, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f117F->else_instructions;

                                             ir_expression *const r1181 = nequal(r1148, body.constant(0u));
                                             ir_expression *const r1182 = expr(ir_unop_b2i, r1181);
                                             body.emit(assign(r117E, expr(ir_unop_i2u, r1182), 0x01));


                                          body.instructions = f117F_parent_instructions;
                                          body.emit(f117F);

                                          /* END IF */

                                          body.emit(assign(r116E, r117E, 0x01));

                                          body.emit(assign(r116F, body.constant(0u), 0x01));


                                       body.instructions = f117B_parent_instructions;
                                       body.emit(f117B);

                                       /* END IF */


                                    body.instructions = f1179_parent_instructions;
                                    body.emit(f1179);

                                    /* END IF */

                                    body.emit(assign(r1170, body.constant(0u), 0x01));


                                 body.instructions = f1175_parent_instructions;
                                 body.emit(f1175);

                                 /* END IF */

                                 ir_expression *const r1183 = nequal(r116C, body.constant(0u));
                                 ir_expression *const r1184 = expr(ir_unop_b2i, r1183);
                                 ir_expression *const r1185 = expr(ir_unop_i2u, r1184);
                                 body.emit(assign(r116E, bit_or(r116E, r1185), 0x01));


                              body.instructions = f1173_parent_instructions;
                              body.emit(f1173);

                              /* END IF */

                              body.emit(assign(r1148, r1170, 0x01));

                              body.emit(assign(r1149, r116F, 0x01));

                              body.emit(assign(r114A, r116E, 0x01));


                           body.instructions = f1162_parent_instructions;
                           body.emit(f1162);

                           /* END IF */

                           body.emit(assign(r1147, sub(r1147, r114B), 0x01));

                           ir_variable *const r1186 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r1186, r1147, 0x01));

                           ir_variable *const r1187 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r1187, r1148, 0x01));

                           ir_variable *const r1188 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r1188, r1149, 0x01));

                           ir_variable *const r1189 = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r1189, r114A, 0x01));

                           ir_variable *const r118A = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r118A, body.constant(true), 0x01));

                           ir_variable *const r118B = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r118C = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r118C);
                           ir_expression *const r118D = expr(ir_unop_u2i, r114A);
                           body.emit(assign(r118C, less(r118D, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r118F = lequal(body.constant(int(2045)), r1147);
                           ir_if *f118E = new(mem_ctx) ir_if(operand(r118F).val);
                           exec_list *const f118E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f118E->then_instructions;

                              ir_variable *const r1190 = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1192 = less(body.constant(int(2045)), r1147);
                              ir_if *f1191 = new(mem_ctx) ir_if(operand(r1192).val);
                              exec_list *const f1191_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1191->then_instructions;

                                 body.emit(assign(r1190, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1191->else_instructions;

                                 ir_variable *const r1193 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r1195 = equal(r1147, body.constant(int(2045)));
                                 ir_if *f1194 = new(mem_ctx) ir_if(operand(r1195).val);
                                 exec_list *const f1194_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1194->then_instructions;

                                    ir_expression *const r1196 = equal(body.constant(2097151u), r1148);
                                    ir_expression *const r1197 = equal(body.constant(4294967295u), r1149);
                                    body.emit(assign(r1193, logic_and(r1196, r1197), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1194->else_instructions;

                                    body.emit(assign(r1193, body.constant(false), 0x01));


                                 body.instructions = f1194_parent_instructions;
                                 body.emit(f1194);

                                 /* END IF */

                                 body.emit(assign(r1190, logic_and(r1193, r118C), 0x01));


                              body.instructions = f1191_parent_instructions;
                              body.emit(f1191);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f1198 = new(mem_ctx) ir_if(operand(r1190).val);
                              exec_list *const f1198_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1198->then_instructions;

                                 ir_variable *const r1199 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r1199);
                                 ir_expression *const r119A = lshift(r0DB6, body.constant(int(31)));
                                 body.emit(assign(r1199, add(r119A, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r1199, body.constant(0u), 0x01));

                                 body.emit(assign(r118B, r1199, 0x03));

                                 body.emit(assign(r118A, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1198->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r119C = less(r1147, body.constant(int(0)));
                                 ir_if *f119B = new(mem_ctx) ir_if(operand(r119C).val);
                                 exec_list *const f119B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f119B->then_instructions;

                                    ir_variable *const r119D = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r119D, r114A, 0x01));

                                    ir_variable *const r119E = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r119E, neg(r1147), 0x01));

                                    ir_variable *const r119F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r119F);
                                    ir_variable *const r11A0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r11A0);
                                    ir_variable *const r11A1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r11A1);
                                    ir_variable *const r11A2 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r11A3 = neg(r119E);
                                    body.emit(assign(r11A2, bit_and(r11A3, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r11A5 = equal(r119E, body.constant(int(0)));
                                    ir_if *f11A4 = new(mem_ctx) ir_if(operand(r11A5).val);
                                    exec_list *const f11A4_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f11A4->then_instructions;

                                       body.emit(assign(r119F, r114A, 0x01));

                                       body.emit(assign(r11A0, r1149, 0x01));

                                       body.emit(assign(r11A1, r1148, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f11A4->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r11A7 = less(r119E, body.constant(int(32)));
                                       ir_if *f11A6 = new(mem_ctx) ir_if(operand(r11A7).val);
                                       exec_list *const f11A6_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f11A6->then_instructions;

                                          body.emit(assign(r119F, lshift(r1149, r11A2), 0x01));

                                          ir_expression *const r11A8 = lshift(r1148, r11A2);
                                          ir_expression *const r11A9 = rshift(r1149, r119E);
                                          body.emit(assign(r11A0, bit_or(r11A8, r11A9), 0x01));

                                          body.emit(assign(r11A1, rshift(r1148, r119E), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f11A6->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r11AB = equal(r119E, body.constant(int(32)));
                                          ir_if *f11AA = new(mem_ctx) ir_if(operand(r11AB).val);
                                          exec_list *const f11AA_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f11AA->then_instructions;

                                             body.emit(assign(r119F, r1149, 0x01));

                                             body.emit(assign(r11A0, r1148, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f11AA->else_instructions;

                                             body.emit(assign(r119D, bit_or(r114A, r1149), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r11AD = less(r119E, body.constant(int(64)));
                                             ir_if *f11AC = new(mem_ctx) ir_if(operand(r11AD).val);
                                             exec_list *const f11AC_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f11AC->then_instructions;

                                                body.emit(assign(r119F, lshift(r1148, r11A2), 0x01));

                                                ir_expression *const r11AE = bit_and(r119E, body.constant(int(31)));
                                                body.emit(assign(r11A0, rshift(r1148, r11AE), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f11AC->else_instructions;

                                                ir_variable *const r11AF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r11B1 = equal(r119E, body.constant(int(64)));
                                                ir_if *f11B0 = new(mem_ctx) ir_if(operand(r11B1).val);
                                                exec_list *const f11B0_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f11B0->then_instructions;

                                                   body.emit(assign(r11AF, r1148, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f11B0->else_instructions;

                                                   ir_expression *const r11B2 = nequal(r1148, body.constant(0u));
                                                   ir_expression *const r11B3 = expr(ir_unop_b2i, r11B2);
                                                   body.emit(assign(r11AF, expr(ir_unop_i2u, r11B3), 0x01));


                                                body.instructions = f11B0_parent_instructions;
                                                body.emit(f11B0);

                                                /* END IF */

                                                body.emit(assign(r119F, r11AF, 0x01));

                                                body.emit(assign(r11A0, body.constant(0u), 0x01));


                                             body.instructions = f11AC_parent_instructions;
                                             body.emit(f11AC);

                                             /* END IF */


                                          body.instructions = f11AA_parent_instructions;
                                          body.emit(f11AA);

                                          /* END IF */

                                          body.emit(assign(r11A1, body.constant(0u), 0x01));


                                       body.instructions = f11A6_parent_instructions;
                                       body.emit(f11A6);

                                       /* END IF */

                                       ir_expression *const r11B4 = nequal(r119D, body.constant(0u));
                                       ir_expression *const r11B5 = expr(ir_unop_b2i, r11B4);
                                       ir_expression *const r11B6 = expr(ir_unop_i2u, r11B5);
                                       body.emit(assign(r119F, bit_or(r119F, r11B6), 0x01));


                                    body.instructions = f11A4_parent_instructions;
                                    body.emit(f11A4);

                                    /* END IF */

                                    body.emit(assign(r1187, r11A1, 0x01));

                                    body.emit(assign(r1188, r11A0, 0x01));

                                    body.emit(assign(r1189, r119F, 0x01));

                                    body.emit(assign(r1186, body.constant(int(0)), 0x01));

                                    body.emit(assign(r118C, less(r119F, body.constant(0u)), 0x01));


                                 body.instructions = f119B_parent_instructions;
                                 body.emit(f119B);

                                 /* END IF */


                              body.instructions = f1198_parent_instructions;
                              body.emit(f1198);

                              /* END IF */


                           body.instructions = f118E_parent_instructions;
                           body.emit(f118E);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f11B7 = new(mem_ctx) ir_if(operand(r118A).val);
                           exec_list *const f11B7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f11B7->then_instructions;

                              /* IF CONDITION */
                              ir_if *f11B8 = new(mem_ctx) ir_if(operand(r118C).val);
                              exec_list *const f11B8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f11B8->then_instructions;

                                 ir_variable *const r11B9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r11B9, add(r1188, body.constant(1u)), 0x01));

                                 ir_expression *const r11BA = less(r11B9, r1188);
                                 ir_expression *const r11BB = expr(ir_unop_b2i, r11BA);
                                 ir_expression *const r11BC = expr(ir_unop_i2u, r11BB);
                                 body.emit(assign(r1187, add(r1187, r11BC), 0x01));

                                 ir_expression *const r11BD = equal(r1189, body.constant(0u));
                                 ir_expression *const r11BE = expr(ir_unop_b2i, r11BD);
                                 ir_expression *const r11BF = expr(ir_unop_i2u, r11BE);
                                 ir_expression *const r11C0 = add(r1189, r11BF);
                                 ir_expression *const r11C1 = bit_and(r11C0, body.constant(1u));
                                 ir_expression *const r11C2 = expr(ir_unop_bit_not, r11C1);
                                 body.emit(assign(r1188, bit_and(r11B9, r11C2), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f11B8->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r11C4 = bit_or(r1187, r1188);
                                 ir_expression *const r11C5 = equal(r11C4, body.constant(0u));
                                 ir_if *f11C3 = new(mem_ctx) ir_if(operand(r11C5).val);
                                 exec_list *const f11C3_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f11C3->then_instructions;

                                    body.emit(assign(r1186, body.constant(int(0)), 0x01));


                                 body.instructions = f11C3_parent_instructions;
                                 body.emit(f11C3);

                                 /* END IF */


                              body.instructions = f11B8_parent_instructions;
                              body.emit(f11B8);

                              /* END IF */

                              ir_variable *const r11C6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r11C6);
                              ir_expression *const r11C7 = lshift(r0DB6, body.constant(int(31)));
                              ir_expression *const r11C8 = expr(ir_unop_i2u, r1186);
                              ir_expression *const r11C9 = lshift(r11C8, body.constant(int(20)));
                              ir_expression *const r11CA = add(r11C7, r11C9);
                              body.emit(assign(r11C6, add(r11CA, r1187), 0x02));

                              body.emit(assign(r11C6, r1188, 0x01));

                              body.emit(assign(r118B, r11C6, 0x03));

                              body.emit(assign(r118A, body.constant(false), 0x01));


                           body.instructions = f11B7_parent_instructions;
                           body.emit(f11B7);

                           /* END IF */

                           body.emit(assign(r0DB7, r118B, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f113F->else_instructions;

                           ir_variable *const r11CB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r11CB);
                           body.emit(assign(r11CB, body.constant(0u), 0x02));

                           body.emit(assign(r11CB, body.constant(0u), 0x01));

                           body.emit(assign(r0DB7, r11CB, 0x03));


                        body.instructions = f113F_parent_instructions;
                        body.emit(f113F);

                        /* END IF */


                     body.instructions = f10B3_parent_instructions;
                     body.emit(f10B3);

                     /* END IF */


                  body.instructions = f1027_parent_instructions;
                  body.emit(f1027);

                  /* END IF */


               body.instructions = f0F9B_parent_instructions;
               body.emit(f0F9B);

               /* END IF */


            body.instructions = f0F74_parent_instructions;
            body.emit(f0F74);

            /* END IF */


         body.instructions = f0EA0_parent_instructions;
         body.emit(f0EA0);

         /* END IF */


      body.instructions = f0DD0_parent_instructions;
      body.emit(f0DD0);

      /* END IF */

      body.emit(assign(r0DB1, r0DB7, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0DB4->else_instructions;

      ir_variable *const r11CC = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r11CC, body.constant(true), 0x01));

      ir_variable *const r11CD = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r11CE = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r11CE);
      ir_variable *const r11CF = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
      body.emit(r11CF);
      ir_variable *const r11D0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
      body.emit(r11D0);
      ir_variable *const r11D1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
      body.emit(r11D1);
      ir_variable *const r11D2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
      body.emit(r11D2);
      ir_variable *const r11D3 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r11D3);
      ir_variable *const r11D4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
      body.emit(r11D4);
      ir_variable *const r11D5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
      body.emit(r11D5);
      body.emit(assign(r11D5, body.constant(0u), 0x01));

      body.emit(assign(r11D4, body.constant(0u), 0x01));

      ir_variable *const r11D6 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
      body.emit(assign(r11D6, swizzle_x(r0DAF), 0x01));

      body.emit(assign(r11D2, r11D6, 0x01));

      ir_variable *const r11D7 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
      body.emit(assign(r11D7, bit_and(swizzle_y(r0DAF), body.constant(1048575u)), 0x01));

      body.emit(assign(r11D1, r11D7, 0x01));

      ir_variable *const r11D8 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
      body.emit(assign(r11D8, swizzle_x(r0DB0), 0x01));

      body.emit(assign(r11D0, r11D8, 0x01));

      ir_variable *const r11D9 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
      body.emit(assign(r11D9, bit_and(swizzle_y(r0DB0), body.constant(1048575u)), 0x01));

      body.emit(assign(r11CF, r11D9, 0x01));

      ir_variable *const r11DA = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r11DB = rshift(swizzle_y(r0DAF), body.constant(int(20)));
      ir_expression *const r11DC = bit_and(r11DB, body.constant(2047u));
      body.emit(assign(r11DA, expr(ir_unop_u2i, r11DC), 0x01));

      ir_variable *const r11DD = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r11DE = rshift(swizzle_y(r0DB0), body.constant(int(20)));
      ir_expression *const r11DF = bit_and(r11DE, body.constant(2047u));
      body.emit(assign(r11DD, expr(ir_unop_u2i, r11DF), 0x01));

      ir_variable *const r11E0 = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r11E0, sub(r11DA, r11DD), 0x01));

      body.emit(assign(r11CE, r11E0, 0x01));

      /* IF CONDITION */
      ir_expression *const r11E2 = less(body.constant(int(0)), r11E0);
      ir_if *f11E1 = new(mem_ctx) ir_if(operand(r11E2).val);
      exec_list *const f11E1_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f11E1->then_instructions;

         /* IF CONDITION */
         ir_expression *const r11E4 = equal(r11DA, body.constant(int(2047)));
         ir_if *f11E3 = new(mem_ctx) ir_if(operand(r11E4).val);
         exec_list *const f11E3_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f11E3->then_instructions;

            /* IF CONDITION */
            ir_expression *const r11E6 = bit_or(r11D7, swizzle_x(r0DAF));
            ir_expression *const r11E7 = nequal(r11E6, body.constant(0u));
            ir_if *f11E5 = new(mem_ctx) ir_if(operand(r11E7).val);
            exec_list *const f11E5_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f11E5->then_instructions;

               ir_variable *const r11E8 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r11E8, swizzle_x(r0DAF), 0x01));

               ir_variable *const r11E9 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r11E9, swizzle_x(r0DB0), 0x01));

               ir_variable *const r11EA = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r11EB = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r11EC = rshift(swizzle_y(r0DAF), body.constant(int(19)));
               ir_expression *const r11ED = bit_and(r11EC, body.constant(4095u));
               ir_expression *const r11EE = equal(r11ED, body.constant(4094u));
               ir_expression *const r11EF = nequal(swizzle_x(r0DAF), body.constant(0u));
               ir_expression *const r11F0 = bit_and(swizzle_y(r0DAF), body.constant(524287u));
               ir_expression *const r11F1 = nequal(r11F0, body.constant(0u));
               ir_expression *const r11F2 = logic_or(r11EF, r11F1);
               body.emit(assign(r11EB, logic_and(r11EE, r11F2), 0x01));

               ir_variable *const r11F3 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r11F4 = lshift(swizzle_y(r0DB0), body.constant(int(1)));
               ir_expression *const r11F5 = lequal(body.constant(4292870144u), r11F4);
               ir_expression *const r11F6 = nequal(swizzle_x(r0DB0), body.constant(0u));
               ir_expression *const r11F7 = bit_and(swizzle_y(r0DB0), body.constant(1048575u));
               ir_expression *const r11F8 = nequal(r11F7, body.constant(0u));
               ir_expression *const r11F9 = logic_or(r11F6, r11F8);
               body.emit(assign(r11F3, logic_and(r11F5, r11F9), 0x01));

               body.emit(assign(r11E8, bit_or(swizzle_y(r0DAF), body.constant(524288u)), 0x02));

               body.emit(assign(r11E9, bit_or(swizzle_y(r0DB0), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r11FB = lshift(swizzle_y(r0DAF), body.constant(int(1)));
               ir_expression *const r11FC = lequal(body.constant(4292870144u), r11FB);
               ir_expression *const r11FD = nequal(swizzle_x(r0DAF), body.constant(0u));
               ir_expression *const r11FE = bit_and(swizzle_y(r0DAF), body.constant(1048575u));
               ir_expression *const r11FF = nequal(r11FE, body.constant(0u));
               ir_expression *const r1200 = logic_or(r11FD, r11FF);
               ir_expression *const r1201 = logic_and(r11FC, r1200);
               ir_if *f11FA = new(mem_ctx) ir_if(operand(r1201).val);
               exec_list *const f11FA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f11FA->then_instructions;

                  ir_variable *const r1202 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1204 = logic_and(r11EB, r11F3);
                  ir_if *f1203 = new(mem_ctx) ir_if(operand(r1204).val);
                  exec_list *const f1203_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1203->then_instructions;

                     body.emit(assign(r1202, r11E9, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1203->else_instructions;

                     body.emit(assign(r1202, r11E8, 0x03));


                  body.instructions = f1203_parent_instructions;
                  body.emit(f1203);

                  /* END IF */

                  body.emit(assign(r11EA, r1202, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f11FA->else_instructions;

                  body.emit(assign(r11EA, r11E9, 0x03));


               body.instructions = f11FA_parent_instructions;
               body.emit(f11FA);

               /* END IF */

               body.emit(assign(r11CD, r11EA, 0x03));

               body.emit(assign(r11CC, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f11E5->else_instructions;

               body.emit(assign(r11CD, r0DAF, 0x03));

               body.emit(assign(r11CC, body.constant(false), 0x01));


            body.instructions = f11E5_parent_instructions;
            body.emit(f11E5);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f11E3->else_instructions;

            /* IF CONDITION */
            ir_expression *const r1206 = equal(r11DD, body.constant(int(0)));
            ir_if *f1205 = new(mem_ctx) ir_if(operand(r1206).val);
            exec_list *const f1205_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1205->then_instructions;

               body.emit(assign(r11CE, add(r11E0, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1205->else_instructions;

               body.emit(assign(r11CF, bit_or(r11D9, body.constant(1048576u)), 0x01));


            body.instructions = f1205_parent_instructions;
            body.emit(f1205);

            /* END IF */

            ir_variable *const r1207 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r1207, body.constant(0u), 0x01));

            ir_variable *const r1208 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r1208);
            ir_variable *const r1209 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r1209);
            ir_variable *const r120A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r120A);
            ir_variable *const r120B = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r120C = neg(r11CE);
            body.emit(assign(r120B, bit_and(r120C, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r120E = equal(r11CE, body.constant(int(0)));
            ir_if *f120D = new(mem_ctx) ir_if(operand(r120E).val);
            exec_list *const f120D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f120D->then_instructions;

               body.emit(assign(r1208, r1207, 0x01));

               body.emit(assign(r1209, r11D8, 0x01));

               body.emit(assign(r120A, r11CF, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f120D->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1210 = less(r11CE, body.constant(int(32)));
               ir_if *f120F = new(mem_ctx) ir_if(operand(r1210).val);
               exec_list *const f120F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f120F->then_instructions;

                  body.emit(assign(r1208, lshift(swizzle_x(r0DB0), r120B), 0x01));

                  ir_expression *const r1211 = lshift(r11CF, r120B);
                  ir_expression *const r1212 = rshift(swizzle_x(r0DB0), r11CE);
                  body.emit(assign(r1209, bit_or(r1211, r1212), 0x01));

                  body.emit(assign(r120A, rshift(r11CF, r11CE), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f120F->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1214 = equal(r11CE, body.constant(int(32)));
                  ir_if *f1213 = new(mem_ctx) ir_if(operand(r1214).val);
                  exec_list *const f1213_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1213->then_instructions;

                     body.emit(assign(r1208, r11D8, 0x01));

                     body.emit(assign(r1209, r11CF, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1213->else_instructions;

                     body.emit(assign(r1207, bit_or(body.constant(0u), swizzle_x(r0DB0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1216 = less(r11CE, body.constant(int(64)));
                     ir_if *f1215 = new(mem_ctx) ir_if(operand(r1216).val);
                     exec_list *const f1215_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1215->then_instructions;

                        body.emit(assign(r1208, lshift(r11CF, r120B), 0x01));

                        ir_expression *const r1217 = bit_and(r11CE, body.constant(int(31)));
                        body.emit(assign(r1209, rshift(r11CF, r1217), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1215->else_instructions;

                        ir_variable *const r1218 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r121A = equal(r11CE, body.constant(int(64)));
                        ir_if *f1219 = new(mem_ctx) ir_if(operand(r121A).val);
                        exec_list *const f1219_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1219->then_instructions;

                           body.emit(assign(r1218, r11CF, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1219->else_instructions;

                           ir_expression *const r121B = nequal(r11CF, body.constant(0u));
                           ir_expression *const r121C = expr(ir_unop_b2i, r121B);
                           body.emit(assign(r1218, expr(ir_unop_i2u, r121C), 0x01));


                        body.instructions = f1219_parent_instructions;
                        body.emit(f1219);

                        /* END IF */

                        body.emit(assign(r1208, r1218, 0x01));

                        body.emit(assign(r1209, body.constant(0u), 0x01));


                     body.instructions = f1215_parent_instructions;
                     body.emit(f1215);

                     /* END IF */


                  body.instructions = f1213_parent_instructions;
                  body.emit(f1213);

                  /* END IF */

                  body.emit(assign(r120A, body.constant(0u), 0x01));


               body.instructions = f120F_parent_instructions;
               body.emit(f120F);

               /* END IF */

               ir_expression *const r121D = nequal(r1207, body.constant(0u));
               ir_expression *const r121E = expr(ir_unop_b2i, r121D);
               ir_expression *const r121F = expr(ir_unop_i2u, r121E);
               body.emit(assign(r1208, bit_or(r1208, r121F), 0x01));


            body.instructions = f120D_parent_instructions;
            body.emit(f120D);

            /* END IF */

            body.emit(assign(r11CF, r120A, 0x01));

            body.emit(assign(r11D0, r1209, 0x01));

            body.emit(assign(r11D4, r1208, 0x01));

            body.emit(assign(r11D3, r11DA, 0x01));


         body.instructions = f11E3_parent_instructions;
         body.emit(f11E3);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f11E1->else_instructions;

         /* IF CONDITION */
         ir_expression *const r1221 = less(r11CE, body.constant(int(0)));
         ir_if *f1220 = new(mem_ctx) ir_if(operand(r1221).val);
         exec_list *const f1220_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1220->then_instructions;

            /* IF CONDITION */
            ir_expression *const r1223 = equal(r11DD, body.constant(int(2047)));
            ir_if *f1222 = new(mem_ctx) ir_if(operand(r1223).val);
            exec_list *const f1222_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1222->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1225 = bit_or(r11CF, r11D0);
               ir_expression *const r1226 = nequal(r1225, body.constant(0u));
               ir_if *f1224 = new(mem_ctx) ir_if(operand(r1226).val);
               exec_list *const f1224_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1224->then_instructions;

                  ir_variable *const r1227 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r1227, swizzle_x(r0DAF), 0x01));

                  ir_variable *const r1228 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r1228, swizzle_x(r0DB0), 0x01));

                  ir_variable *const r1229 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r122A = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r122B = rshift(swizzle_y(r0DAF), body.constant(int(19)));
                  ir_expression *const r122C = bit_and(r122B, body.constant(4095u));
                  ir_expression *const r122D = equal(r122C, body.constant(4094u));
                  ir_expression *const r122E = nequal(swizzle_x(r0DAF), body.constant(0u));
                  ir_expression *const r122F = bit_and(swizzle_y(r0DAF), body.constant(524287u));
                  ir_expression *const r1230 = nequal(r122F, body.constant(0u));
                  ir_expression *const r1231 = logic_or(r122E, r1230);
                  body.emit(assign(r122A, logic_and(r122D, r1231), 0x01));

                  ir_variable *const r1232 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r1233 = lshift(swizzle_y(r0DB0), body.constant(int(1)));
                  ir_expression *const r1234 = lequal(body.constant(4292870144u), r1233);
                  ir_expression *const r1235 = nequal(swizzle_x(r0DB0), body.constant(0u));
                  ir_expression *const r1236 = bit_and(swizzle_y(r0DB0), body.constant(1048575u));
                  ir_expression *const r1237 = nequal(r1236, body.constant(0u));
                  ir_expression *const r1238 = logic_or(r1235, r1237);
                  body.emit(assign(r1232, logic_and(r1234, r1238), 0x01));

                  body.emit(assign(r1227, bit_or(swizzle_y(r0DAF), body.constant(524288u)), 0x02));

                  body.emit(assign(r1228, bit_or(swizzle_y(r0DB0), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r123A = lshift(swizzle_y(r0DAF), body.constant(int(1)));
                  ir_expression *const r123B = lequal(body.constant(4292870144u), r123A);
                  ir_expression *const r123C = nequal(swizzle_x(r0DAF), body.constant(0u));
                  ir_expression *const r123D = bit_and(swizzle_y(r0DAF), body.constant(1048575u));
                  ir_expression *const r123E = nequal(r123D, body.constant(0u));
                  ir_expression *const r123F = logic_or(r123C, r123E);
                  ir_expression *const r1240 = logic_and(r123B, r123F);
                  ir_if *f1239 = new(mem_ctx) ir_if(operand(r1240).val);
                  exec_list *const f1239_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1239->then_instructions;

                     ir_variable *const r1241 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1243 = logic_and(r122A, r1232);
                     ir_if *f1242 = new(mem_ctx) ir_if(operand(r1243).val);
                     exec_list *const f1242_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1242->then_instructions;

                        body.emit(assign(r1241, r1228, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1242->else_instructions;

                        body.emit(assign(r1241, r1227, 0x03));


                     body.instructions = f1242_parent_instructions;
                     body.emit(f1242);

                     /* END IF */

                     body.emit(assign(r1229, r1241, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1239->else_instructions;

                     body.emit(assign(r1229, r1228, 0x03));


                  body.instructions = f1239_parent_instructions;
                  body.emit(f1239);

                  /* END IF */

                  body.emit(assign(r11CD, r1229, 0x03));

                  body.emit(assign(r11CC, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1224->else_instructions;

                  ir_variable *const r1244 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1244);
                  ir_expression *const r1245 = lshift(r0DB2, body.constant(int(31)));
                  body.emit(assign(r1244, add(r1245, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r1244, body.constant(0u), 0x01));

                  body.emit(assign(r11CD, r1244, 0x03));

                  body.emit(assign(r11CC, body.constant(false), 0x01));


               body.instructions = f1224_parent_instructions;
               body.emit(f1224);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1222->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1247 = equal(r11DA, body.constant(int(0)));
               ir_if *f1246 = new(mem_ctx) ir_if(operand(r1247).val);
               exec_list *const f1246_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1246->then_instructions;

                  body.emit(assign(r11CE, add(r11CE, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1246->else_instructions;

                  body.emit(assign(r11D1, bit_or(r11D7, body.constant(1048576u)), 0x01));


               body.instructions = f1246_parent_instructions;
               body.emit(f1246);

               /* END IF */

               ir_variable *const r1248 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r1248, body.constant(0u), 0x01));

               ir_variable *const r1249 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r1249, neg(r11CE), 0x01));

               ir_variable *const r124A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r124A);
               ir_variable *const r124B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r124B);
               ir_variable *const r124C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r124C);
               ir_variable *const r124D = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r124E = neg(r1249);
               body.emit(assign(r124D, bit_and(r124E, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1250 = equal(r1249, body.constant(int(0)));
               ir_if *f124F = new(mem_ctx) ir_if(operand(r1250).val);
               exec_list *const f124F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f124F->then_instructions;

                  body.emit(assign(r124A, r1248, 0x01));

                  body.emit(assign(r124B, r11D6, 0x01));

                  body.emit(assign(r124C, r11D1, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f124F->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1252 = less(r1249, body.constant(int(32)));
                  ir_if *f1251 = new(mem_ctx) ir_if(operand(r1252).val);
                  exec_list *const f1251_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1251->then_instructions;

                     body.emit(assign(r124A, lshift(swizzle_x(r0DAF), r124D), 0x01));

                     ir_expression *const r1253 = lshift(r11D1, r124D);
                     ir_expression *const r1254 = rshift(swizzle_x(r0DAF), r1249);
                     body.emit(assign(r124B, bit_or(r1253, r1254), 0x01));

                     body.emit(assign(r124C, rshift(r11D1, r1249), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1251->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1256 = equal(r1249, body.constant(int(32)));
                     ir_if *f1255 = new(mem_ctx) ir_if(operand(r1256).val);
                     exec_list *const f1255_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1255->then_instructions;

                        body.emit(assign(r124A, r11D6, 0x01));

                        body.emit(assign(r124B, r11D1, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1255->else_instructions;

                        body.emit(assign(r1248, bit_or(body.constant(0u), swizzle_x(r0DAF)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1258 = less(r1249, body.constant(int(64)));
                        ir_if *f1257 = new(mem_ctx) ir_if(operand(r1258).val);
                        exec_list *const f1257_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1257->then_instructions;

                           body.emit(assign(r124A, lshift(r11D1, r124D), 0x01));

                           ir_expression *const r1259 = bit_and(r1249, body.constant(int(31)));
                           body.emit(assign(r124B, rshift(r11D1, r1259), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1257->else_instructions;

                           ir_variable *const r125A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r125C = equal(r1249, body.constant(int(64)));
                           ir_if *f125B = new(mem_ctx) ir_if(operand(r125C).val);
                           exec_list *const f125B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f125B->then_instructions;

                              body.emit(assign(r125A, r11D1, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f125B->else_instructions;

                              ir_expression *const r125D = nequal(r11D1, body.constant(0u));
                              ir_expression *const r125E = expr(ir_unop_b2i, r125D);
                              body.emit(assign(r125A, expr(ir_unop_i2u, r125E), 0x01));


                           body.instructions = f125B_parent_instructions;
                           body.emit(f125B);

                           /* END IF */

                           body.emit(assign(r124A, r125A, 0x01));

                           body.emit(assign(r124B, body.constant(0u), 0x01));


                        body.instructions = f1257_parent_instructions;
                        body.emit(f1257);

                        /* END IF */


                     body.instructions = f1255_parent_instructions;
                     body.emit(f1255);

                     /* END IF */

                     body.emit(assign(r124C, body.constant(0u), 0x01));


                  body.instructions = f1251_parent_instructions;
                  body.emit(f1251);

                  /* END IF */

                  ir_expression *const r125F = nequal(r1248, body.constant(0u));
                  ir_expression *const r1260 = expr(ir_unop_b2i, r125F);
                  ir_expression *const r1261 = expr(ir_unop_i2u, r1260);
                  body.emit(assign(r124A, bit_or(r124A, r1261), 0x01));


               body.instructions = f124F_parent_instructions;
               body.emit(f124F);

               /* END IF */

               body.emit(assign(r11D1, r124C, 0x01));

               body.emit(assign(r11D2, r124B, 0x01));

               body.emit(assign(r11D4, r124A, 0x01));

               body.emit(assign(r11D3, r11DD, 0x01));


            body.instructions = f1222_parent_instructions;
            body.emit(f1222);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1220->else_instructions;

            /* IF CONDITION */
            ir_expression *const r1263 = equal(r11DA, body.constant(int(2047)));
            ir_if *f1262 = new(mem_ctx) ir_if(operand(r1263).val);
            exec_list *const f1262_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1262->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1265 = bit_or(r11D1, r11D2);
               ir_expression *const r1266 = bit_or(r11CF, r11D0);
               ir_expression *const r1267 = bit_or(r1265, r1266);
               ir_expression *const r1268 = nequal(r1267, body.constant(0u));
               ir_if *f1264 = new(mem_ctx) ir_if(operand(r1268).val);
               exec_list *const f1264_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1264->then_instructions;

                  ir_variable *const r1269 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r1269, swizzle_x(r0DAF), 0x01));

                  ir_variable *const r126A = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r126A, swizzle_x(r0DB0), 0x01));

                  ir_variable *const r126B = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r126C = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r126D = rshift(swizzle_y(r0DAF), body.constant(int(19)));
                  ir_expression *const r126E = bit_and(r126D, body.constant(4095u));
                  ir_expression *const r126F = equal(r126E, body.constant(4094u));
                  ir_expression *const r1270 = nequal(swizzle_x(r0DAF), body.constant(0u));
                  ir_expression *const r1271 = bit_and(swizzle_y(r0DAF), body.constant(524287u));
                  ir_expression *const r1272 = nequal(r1271, body.constant(0u));
                  ir_expression *const r1273 = logic_or(r1270, r1272);
                  body.emit(assign(r126C, logic_and(r126F, r1273), 0x01));

                  ir_variable *const r1274 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r1275 = lshift(swizzle_y(r0DB0), body.constant(int(1)));
                  ir_expression *const r1276 = lequal(body.constant(4292870144u), r1275);
                  ir_expression *const r1277 = nequal(swizzle_x(r0DB0), body.constant(0u));
                  ir_expression *const r1278 = bit_and(swizzle_y(r0DB0), body.constant(1048575u));
                  ir_expression *const r1279 = nequal(r1278, body.constant(0u));
                  ir_expression *const r127A = logic_or(r1277, r1279);
                  body.emit(assign(r1274, logic_and(r1276, r127A), 0x01));

                  body.emit(assign(r1269, bit_or(swizzle_y(r0DAF), body.constant(524288u)), 0x02));

                  body.emit(assign(r126A, bit_or(swizzle_y(r0DB0), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r127C = lshift(swizzle_y(r0DAF), body.constant(int(1)));
                  ir_expression *const r127D = lequal(body.constant(4292870144u), r127C);
                  ir_expression *const r127E = nequal(swizzle_x(r0DAF), body.constant(0u));
                  ir_expression *const r127F = bit_and(swizzle_y(r0DAF), body.constant(1048575u));
                  ir_expression *const r1280 = nequal(r127F, body.constant(0u));
                  ir_expression *const r1281 = logic_or(r127E, r1280);
                  ir_expression *const r1282 = logic_and(r127D, r1281);
                  ir_if *f127B = new(mem_ctx) ir_if(operand(r1282).val);
                  exec_list *const f127B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f127B->then_instructions;

                     ir_variable *const r1283 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1285 = logic_and(r126C, r1274);
                     ir_if *f1284 = new(mem_ctx) ir_if(operand(r1285).val);
                     exec_list *const f1284_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1284->then_instructions;

                        body.emit(assign(r1283, r126A, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1284->else_instructions;

                        body.emit(assign(r1283, r1269, 0x03));


                     body.instructions = f1284_parent_instructions;
                     body.emit(f1284);

                     /* END IF */

                     body.emit(assign(r126B, r1283, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f127B->else_instructions;

                     body.emit(assign(r126B, r126A, 0x03));


                  body.instructions = f127B_parent_instructions;
                  body.emit(f127B);

                  /* END IF */

                  body.emit(assign(r11CD, r126B, 0x03));

                  body.emit(assign(r11CC, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1264->else_instructions;

                  body.emit(assign(r11CD, r0DAF, 0x03));

                  body.emit(assign(r11CC, body.constant(false), 0x01));


               body.instructions = f1264_parent_instructions;
               body.emit(f1264);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1262->else_instructions;

               ir_variable *const r1286 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r1287 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1287, add(r11D2, r11D0), 0x01));

               ir_expression *const r1288 = add(r11D1, r11CF);
               ir_expression *const r1289 = less(r1287, r11D2);
               ir_expression *const r128A = expr(ir_unop_b2i, r1289);
               ir_expression *const r128B = expr(ir_unop_i2u, r128A);
               body.emit(assign(r1286, add(r1288, r128B), 0x01));

               body.emit(assign(r11D5, r1286, 0x01));

               /* IF CONDITION */
               ir_expression *const r128D = equal(r11DA, body.constant(int(0)));
               ir_if *f128C = new(mem_ctx) ir_if(operand(r128D).val);
               exec_list *const f128C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f128C->then_instructions;

                  ir_variable *const r128E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r128E);
                  ir_expression *const r128F = lshift(r0DB2, body.constant(int(31)));
                  body.emit(assign(r128E, add(r128F, r1286), 0x02));

                  body.emit(assign(r128E, r1287, 0x01));

                  body.emit(assign(r11CD, r128E, 0x03));

                  body.emit(assign(r11CC, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f128C->else_instructions;

                  body.emit(assign(r11D5, bit_or(r1286, body.constant(2097152u)), 0x01));

                  body.emit(assign(r11D3, r11DA, 0x01));

                  ir_variable *const r1290 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r1290);
                  ir_variable *const r1291 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1291);
                  ir_variable *const r1292 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1292);
                  body.emit(assign(r1290, lshift(r1287, body.constant(int(31))), 0x01));

                  ir_expression *const r1293 = lshift(r11D5, body.constant(int(31)));
                  ir_expression *const r1294 = rshift(r1287, body.constant(int(1)));
                  body.emit(assign(r1291, bit_or(r1293, r1294), 0x01));

                  body.emit(assign(r1292, rshift(r11D5, body.constant(int(1))), 0x01));

                  body.emit(assign(r1290, bit_or(r1290, body.constant(0u)), 0x01));

                  body.emit(assign(r11D5, r1292, 0x01));

                  body.emit(assign(r11D4, r1290, 0x01));

                  ir_variable *const r1295 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r1295, r11DA, 0x01));

                  ir_variable *const r1296 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r1296, r1292, 0x01));

                  ir_variable *const r1297 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r1297, r1291, 0x01));

                  ir_variable *const r1298 = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r1298, r1290, 0x01));

                  ir_variable *const r1299 = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r1299, body.constant(true), 0x01));

                  ir_variable *const r129A = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r129B = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r129B);
                  ir_expression *const r129C = expr(ir_unop_u2i, r1290);
                  body.emit(assign(r129B, less(r129C, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r129E = lequal(body.constant(int(2045)), r11DA);
                  ir_if *f129D = new(mem_ctx) ir_if(operand(r129E).val);
                  exec_list *const f129D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f129D->then_instructions;

                     ir_variable *const r129F = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r12A1 = less(body.constant(int(2045)), r11DA);
                     ir_if *f12A0 = new(mem_ctx) ir_if(operand(r12A1).val);
                     exec_list *const f12A0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f12A0->then_instructions;

                        body.emit(assign(r129F, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f12A0->else_instructions;

                        ir_variable *const r12A2 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r12A4 = equal(r11DA, body.constant(int(2045)));
                        ir_if *f12A3 = new(mem_ctx) ir_if(operand(r12A4).val);
                        exec_list *const f12A3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f12A3->then_instructions;

                           ir_expression *const r12A5 = equal(body.constant(2097151u), r1292);
                           ir_expression *const r12A6 = equal(body.constant(4294967295u), r1291);
                           body.emit(assign(r12A2, logic_and(r12A5, r12A6), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f12A3->else_instructions;

                           body.emit(assign(r12A2, body.constant(false), 0x01));


                        body.instructions = f12A3_parent_instructions;
                        body.emit(f12A3);

                        /* END IF */

                        body.emit(assign(r129F, logic_and(r12A2, r129B), 0x01));


                     body.instructions = f12A0_parent_instructions;
                     body.emit(f12A0);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f12A7 = new(mem_ctx) ir_if(operand(r129F).val);
                     exec_list *const f12A7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f12A7->then_instructions;

                        ir_variable *const r12A8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r12A8);
                        ir_expression *const r12A9 = lshift(r0DB2, body.constant(int(31)));
                        body.emit(assign(r12A8, add(r12A9, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r12A8, body.constant(0u), 0x01));

                        body.emit(assign(r129A, r12A8, 0x03));

                        body.emit(assign(r1299, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f12A7->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r12AB = less(r11DA, body.constant(int(0)));
                        ir_if *f12AA = new(mem_ctx) ir_if(operand(r12AB).val);
                        exec_list *const f12AA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f12AA->then_instructions;

                           ir_variable *const r12AC = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r12AC, r1290, 0x01));

                           ir_variable *const r12AD = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r12AD, neg(r11DA), 0x01));

                           ir_variable *const r12AE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r12AE);
                           ir_variable *const r12AF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r12AF);
                           ir_variable *const r12B0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r12B0);
                           ir_variable *const r12B1 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r12B2 = neg(r12AD);
                           body.emit(assign(r12B1, bit_and(r12B2, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r12B4 = equal(r12AD, body.constant(int(0)));
                           ir_if *f12B3 = new(mem_ctx) ir_if(operand(r12B4).val);
                           exec_list *const f12B3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f12B3->then_instructions;

                              body.emit(assign(r12AE, r1290, 0x01));

                              body.emit(assign(r12AF, r1291, 0x01));

                              body.emit(assign(r12B0, r1292, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f12B3->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r12B6 = less(r12AD, body.constant(int(32)));
                              ir_if *f12B5 = new(mem_ctx) ir_if(operand(r12B6).val);
                              exec_list *const f12B5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f12B5->then_instructions;

                                 body.emit(assign(r12AE, lshift(r1291, r12B1), 0x01));

                                 ir_expression *const r12B7 = lshift(r1292, r12B1);
                                 ir_expression *const r12B8 = rshift(r1291, r12AD);
                                 body.emit(assign(r12AF, bit_or(r12B7, r12B8), 0x01));

                                 body.emit(assign(r12B0, rshift(r1292, r12AD), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f12B5->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r12BA = equal(r12AD, body.constant(int(32)));
                                 ir_if *f12B9 = new(mem_ctx) ir_if(operand(r12BA).val);
                                 exec_list *const f12B9_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f12B9->then_instructions;

                                    body.emit(assign(r12AE, r1291, 0x01));

                                    body.emit(assign(r12AF, r1292, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f12B9->else_instructions;

                                    body.emit(assign(r12AC, bit_or(r1290, r1291), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r12BC = less(r12AD, body.constant(int(64)));
                                    ir_if *f12BB = new(mem_ctx) ir_if(operand(r12BC).val);
                                    exec_list *const f12BB_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f12BB->then_instructions;

                                       body.emit(assign(r12AE, lshift(r1292, r12B1), 0x01));

                                       ir_expression *const r12BD = bit_and(r12AD, body.constant(int(31)));
                                       body.emit(assign(r12AF, rshift(r1292, r12BD), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f12BB->else_instructions;

                                       ir_variable *const r12BE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r12C0 = equal(r12AD, body.constant(int(64)));
                                       ir_if *f12BF = new(mem_ctx) ir_if(operand(r12C0).val);
                                       exec_list *const f12BF_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f12BF->then_instructions;

                                          body.emit(assign(r12BE, r1292, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f12BF->else_instructions;

                                          ir_expression *const r12C1 = nequal(r1292, body.constant(0u));
                                          ir_expression *const r12C2 = expr(ir_unop_b2i, r12C1);
                                          body.emit(assign(r12BE, expr(ir_unop_i2u, r12C2), 0x01));


                                       body.instructions = f12BF_parent_instructions;
                                       body.emit(f12BF);

                                       /* END IF */

                                       body.emit(assign(r12AE, r12BE, 0x01));

                                       body.emit(assign(r12AF, body.constant(0u), 0x01));


                                    body.instructions = f12BB_parent_instructions;
                                    body.emit(f12BB);

                                    /* END IF */


                                 body.instructions = f12B9_parent_instructions;
                                 body.emit(f12B9);

                                 /* END IF */

                                 body.emit(assign(r12B0, body.constant(0u), 0x01));


                              body.instructions = f12B5_parent_instructions;
                              body.emit(f12B5);

                              /* END IF */

                              ir_expression *const r12C3 = nequal(r12AC, body.constant(0u));
                              ir_expression *const r12C4 = expr(ir_unop_b2i, r12C3);
                              ir_expression *const r12C5 = expr(ir_unop_i2u, r12C4);
                              body.emit(assign(r12AE, bit_or(r12AE, r12C5), 0x01));


                           body.instructions = f12B3_parent_instructions;
                           body.emit(f12B3);

                           /* END IF */

                           body.emit(assign(r1296, r12B0, 0x01));

                           body.emit(assign(r1297, r12AF, 0x01));

                           body.emit(assign(r1298, r12AE, 0x01));

                           body.emit(assign(r1295, body.constant(int(0)), 0x01));

                           body.emit(assign(r129B, less(r12AE, body.constant(0u)), 0x01));


                        body.instructions = f12AA_parent_instructions;
                        body.emit(f12AA);

                        /* END IF */


                     body.instructions = f12A7_parent_instructions;
                     body.emit(f12A7);

                     /* END IF */


                  body.instructions = f129D_parent_instructions;
                  body.emit(f129D);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f12C6 = new(mem_ctx) ir_if(operand(r1299).val);
                  exec_list *const f12C6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f12C6->then_instructions;

                     /* IF CONDITION */
                     ir_if *f12C7 = new(mem_ctx) ir_if(operand(r129B).val);
                     exec_list *const f12C7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f12C7->then_instructions;

                        ir_variable *const r12C8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r12C8, add(r1297, body.constant(1u)), 0x01));

                        ir_expression *const r12C9 = less(r12C8, r1297);
                        ir_expression *const r12CA = expr(ir_unop_b2i, r12C9);
                        ir_expression *const r12CB = expr(ir_unop_i2u, r12CA);
                        body.emit(assign(r1296, add(r1296, r12CB), 0x01));

                        ir_expression *const r12CC = equal(r1298, body.constant(0u));
                        ir_expression *const r12CD = expr(ir_unop_b2i, r12CC);
                        ir_expression *const r12CE = expr(ir_unop_i2u, r12CD);
                        ir_expression *const r12CF = add(r1298, r12CE);
                        ir_expression *const r12D0 = bit_and(r12CF, body.constant(1u));
                        ir_expression *const r12D1 = expr(ir_unop_bit_not, r12D0);
                        body.emit(assign(r1297, bit_and(r12C8, r12D1), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f12C7->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r12D3 = bit_or(r1296, r1297);
                        ir_expression *const r12D4 = equal(r12D3, body.constant(0u));
                        ir_if *f12D2 = new(mem_ctx) ir_if(operand(r12D4).val);
                        exec_list *const f12D2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f12D2->then_instructions;

                           body.emit(assign(r1295, body.constant(int(0)), 0x01));


                        body.instructions = f12D2_parent_instructions;
                        body.emit(f12D2);

                        /* END IF */


                     body.instructions = f12C7_parent_instructions;
                     body.emit(f12C7);

                     /* END IF */

                     ir_variable *const r12D5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r12D5);
                     ir_expression *const r12D6 = lshift(r0DB2, body.constant(int(31)));
                     ir_expression *const r12D7 = expr(ir_unop_i2u, r1295);
                     ir_expression *const r12D8 = lshift(r12D7, body.constant(int(20)));
                     ir_expression *const r12D9 = add(r12D6, r12D8);
                     body.emit(assign(r12D5, add(r12D9, r1296), 0x02));

                     body.emit(assign(r12D5, r1297, 0x01));

                     body.emit(assign(r129A, r12D5, 0x03));

                     body.emit(assign(r1299, body.constant(false), 0x01));


                  body.instructions = f12C6_parent_instructions;
                  body.emit(f12C6);

                  /* END IF */

                  body.emit(assign(r11CD, r129A, 0x03));

                  body.emit(assign(r11CC, body.constant(false), 0x01));


               body.instructions = f128C_parent_instructions;
               body.emit(f128C);

               /* END IF */


            body.instructions = f1262_parent_instructions;
            body.emit(f1262);

            /* END IF */


         body.instructions = f1220_parent_instructions;
         body.emit(f1220);

         /* END IF */


      body.instructions = f11E1_parent_instructions;
      body.emit(f11E1);

      /* END IF */

      /* IF CONDITION */
      ir_if *f12DA = new(mem_ctx) ir_if(operand(r11CC).val);
      exec_list *const f12DA_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f12DA->then_instructions;

         body.emit(assign(r11D1, bit_or(r11D1, body.constant(1048576u)), 0x01));

         ir_variable *const r12DB = body.make_temp(glsl_type::uint_type, "z0Ptr");
         ir_variable *const r12DC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r12DC, add(r11D2, r11D0), 0x01));

         ir_expression *const r12DD = add(r11D1, r11CF);
         ir_expression *const r12DE = less(r12DC, r11D2);
         ir_expression *const r12DF = expr(ir_unop_b2i, r12DE);
         ir_expression *const r12E0 = expr(ir_unop_i2u, r12DF);
         body.emit(assign(r12DB, add(r12DD, r12E0), 0x01));

         body.emit(assign(r11D5, r12DB, 0x01));

         body.emit(assign(r11D3, add(r11D3, body.constant(int(-1))), 0x01));

         /* IF CONDITION */
         ir_expression *const r12E2 = less(r12DB, body.constant(2097152u));
         ir_if *f12E1 = new(mem_ctx) ir_if(operand(r12E2).val);
         exec_list *const f12E1_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f12E1->then_instructions;

            ir_variable *const r12E3 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r12E3, r11D3, 0x01));

            ir_variable *const r12E4 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r12E4, r12DB, 0x01));

            ir_variable *const r12E5 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r12E5, r12DC, 0x01));

            ir_variable *const r12E6 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r12E6, r11D4, 0x01));

            ir_variable *const r12E7 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r12E7, body.constant(true), 0x01));

            ir_variable *const r12E8 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r12E9 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r12E9);
            ir_expression *const r12EA = expr(ir_unop_u2i, r11D4);
            body.emit(assign(r12E9, less(r12EA, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r12EC = lequal(body.constant(int(2045)), r11D3);
            ir_if *f12EB = new(mem_ctx) ir_if(operand(r12EC).val);
            exec_list *const f12EB_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f12EB->then_instructions;

               ir_variable *const r12ED = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r12EF = less(body.constant(int(2045)), r11D3);
               ir_if *f12EE = new(mem_ctx) ir_if(operand(r12EF).val);
               exec_list *const f12EE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f12EE->then_instructions;

                  body.emit(assign(r12ED, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f12EE->else_instructions;

                  ir_variable *const r12F0 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r12F2 = equal(r11D3, body.constant(int(2045)));
                  ir_if *f12F1 = new(mem_ctx) ir_if(operand(r12F2).val);
                  exec_list *const f12F1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f12F1->then_instructions;

                     ir_expression *const r12F3 = equal(body.constant(2097151u), r12DB);
                     ir_expression *const r12F4 = equal(body.constant(4294967295u), r12DC);
                     body.emit(assign(r12F0, logic_and(r12F3, r12F4), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f12F1->else_instructions;

                     body.emit(assign(r12F0, body.constant(false), 0x01));


                  body.instructions = f12F1_parent_instructions;
                  body.emit(f12F1);

                  /* END IF */

                  body.emit(assign(r12ED, logic_and(r12F0, r12E9), 0x01));


               body.instructions = f12EE_parent_instructions;
               body.emit(f12EE);

               /* END IF */

               /* IF CONDITION */
               ir_if *f12F5 = new(mem_ctx) ir_if(operand(r12ED).val);
               exec_list *const f12F5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f12F5->then_instructions;

                  ir_variable *const r12F6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r12F6);
                  ir_expression *const r12F7 = lshift(r0DB2, body.constant(int(31)));
                  body.emit(assign(r12F6, add(r12F7, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r12F6, body.constant(0u), 0x01));

                  body.emit(assign(r12E8, r12F6, 0x03));

                  body.emit(assign(r12E7, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f12F5->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r12F9 = less(r11D3, body.constant(int(0)));
                  ir_if *f12F8 = new(mem_ctx) ir_if(operand(r12F9).val);
                  exec_list *const f12F8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f12F8->then_instructions;

                     ir_variable *const r12FA = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r12FA, r11D4, 0x01));

                     ir_variable *const r12FB = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r12FB, neg(r11D3), 0x01));

                     ir_variable *const r12FC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r12FC);
                     ir_variable *const r12FD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r12FD);
                     ir_variable *const r12FE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r12FE);
                     ir_variable *const r12FF = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r1300 = neg(r12FB);
                     body.emit(assign(r12FF, bit_and(r1300, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1302 = equal(r12FB, body.constant(int(0)));
                     ir_if *f1301 = new(mem_ctx) ir_if(operand(r1302).val);
                     exec_list *const f1301_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1301->then_instructions;

                        body.emit(assign(r12FC, r11D4, 0x01));

                        body.emit(assign(r12FD, r12DC, 0x01));

                        body.emit(assign(r12FE, r12DB, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1301->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1304 = less(r12FB, body.constant(int(32)));
                        ir_if *f1303 = new(mem_ctx) ir_if(operand(r1304).val);
                        exec_list *const f1303_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1303->then_instructions;

                           body.emit(assign(r12FC, lshift(r12DC, r12FF), 0x01));

                           ir_expression *const r1305 = lshift(r12DB, r12FF);
                           ir_expression *const r1306 = rshift(r12DC, r12FB);
                           body.emit(assign(r12FD, bit_or(r1305, r1306), 0x01));

                           body.emit(assign(r12FE, rshift(r12DB, r12FB), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1303->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1308 = equal(r12FB, body.constant(int(32)));
                           ir_if *f1307 = new(mem_ctx) ir_if(operand(r1308).val);
                           exec_list *const f1307_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1307->then_instructions;

                              body.emit(assign(r12FC, r12DC, 0x01));

                              body.emit(assign(r12FD, r12DB, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1307->else_instructions;

                              body.emit(assign(r12FA, bit_or(r11D4, r12DC), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r130A = less(r12FB, body.constant(int(64)));
                              ir_if *f1309 = new(mem_ctx) ir_if(operand(r130A).val);
                              exec_list *const f1309_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1309->then_instructions;

                                 body.emit(assign(r12FC, lshift(r12DB, r12FF), 0x01));

                                 ir_expression *const r130B = bit_and(r12FB, body.constant(int(31)));
                                 body.emit(assign(r12FD, rshift(r12DB, r130B), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1309->else_instructions;

                                 ir_variable *const r130C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r130E = equal(r12FB, body.constant(int(64)));
                                 ir_if *f130D = new(mem_ctx) ir_if(operand(r130E).val);
                                 exec_list *const f130D_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f130D->then_instructions;

                                    body.emit(assign(r130C, r12DB, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f130D->else_instructions;

                                    ir_expression *const r130F = nequal(r12DB, body.constant(0u));
                                    ir_expression *const r1310 = expr(ir_unop_b2i, r130F);
                                    body.emit(assign(r130C, expr(ir_unop_i2u, r1310), 0x01));


                                 body.instructions = f130D_parent_instructions;
                                 body.emit(f130D);

                                 /* END IF */

                                 body.emit(assign(r12FC, r130C, 0x01));

                                 body.emit(assign(r12FD, body.constant(0u), 0x01));


                              body.instructions = f1309_parent_instructions;
                              body.emit(f1309);

                              /* END IF */


                           body.instructions = f1307_parent_instructions;
                           body.emit(f1307);

                           /* END IF */

                           body.emit(assign(r12FE, body.constant(0u), 0x01));


                        body.instructions = f1303_parent_instructions;
                        body.emit(f1303);

                        /* END IF */

                        ir_expression *const r1311 = nequal(r12FA, body.constant(0u));
                        ir_expression *const r1312 = expr(ir_unop_b2i, r1311);
                        ir_expression *const r1313 = expr(ir_unop_i2u, r1312);
                        body.emit(assign(r12FC, bit_or(r12FC, r1313), 0x01));


                     body.instructions = f1301_parent_instructions;
                     body.emit(f1301);

                     /* END IF */

                     body.emit(assign(r12E4, r12FE, 0x01));

                     body.emit(assign(r12E5, r12FD, 0x01));

                     body.emit(assign(r12E6, r12FC, 0x01));

                     body.emit(assign(r12E3, body.constant(int(0)), 0x01));

                     body.emit(assign(r12E9, less(r12FC, body.constant(0u)), 0x01));


                  body.instructions = f12F8_parent_instructions;
                  body.emit(f12F8);

                  /* END IF */


               body.instructions = f12F5_parent_instructions;
               body.emit(f12F5);

               /* END IF */


            body.instructions = f12EB_parent_instructions;
            body.emit(f12EB);

            /* END IF */

            /* IF CONDITION */
            ir_if *f1314 = new(mem_ctx) ir_if(operand(r12E7).val);
            exec_list *const f1314_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1314->then_instructions;

               /* IF CONDITION */
               ir_if *f1315 = new(mem_ctx) ir_if(operand(r12E9).val);
               exec_list *const f1315_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1315->then_instructions;

                  ir_variable *const r1316 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1316, add(r12E5, body.constant(1u)), 0x01));

                  ir_expression *const r1317 = less(r1316, r12E5);
                  ir_expression *const r1318 = expr(ir_unop_b2i, r1317);
                  ir_expression *const r1319 = expr(ir_unop_i2u, r1318);
                  body.emit(assign(r12E4, add(r12E4, r1319), 0x01));

                  ir_expression *const r131A = equal(r12E6, body.constant(0u));
                  ir_expression *const r131B = expr(ir_unop_b2i, r131A);
                  ir_expression *const r131C = expr(ir_unop_i2u, r131B);
                  ir_expression *const r131D = add(r12E6, r131C);
                  ir_expression *const r131E = bit_and(r131D, body.constant(1u));
                  ir_expression *const r131F = expr(ir_unop_bit_not, r131E);
                  body.emit(assign(r12E5, bit_and(r1316, r131F), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1315->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1321 = bit_or(r12E4, r12E5);
                  ir_expression *const r1322 = equal(r1321, body.constant(0u));
                  ir_if *f1320 = new(mem_ctx) ir_if(operand(r1322).val);
                  exec_list *const f1320_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1320->then_instructions;

                     body.emit(assign(r12E3, body.constant(int(0)), 0x01));


                  body.instructions = f1320_parent_instructions;
                  body.emit(f1320);

                  /* END IF */


               body.instructions = f1315_parent_instructions;
               body.emit(f1315);

               /* END IF */

               ir_variable *const r1323 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r1323);
               ir_expression *const r1324 = lshift(r0DB2, body.constant(int(31)));
               ir_expression *const r1325 = expr(ir_unop_i2u, r12E3);
               ir_expression *const r1326 = lshift(r1325, body.constant(int(20)));
               ir_expression *const r1327 = add(r1324, r1326);
               body.emit(assign(r1323, add(r1327, r12E4), 0x02));

               body.emit(assign(r1323, r12E5, 0x01));

               body.emit(assign(r12E8, r1323, 0x03));

               body.emit(assign(r12E7, body.constant(false), 0x01));


            body.instructions = f1314_parent_instructions;
            body.emit(f1314);

            /* END IF */

            body.emit(assign(r11CD, r12E8, 0x03));

            body.emit(assign(r11CC, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f12E1->else_instructions;

            body.emit(assign(r11D3, add(r11D3, body.constant(int(1))), 0x01));

            ir_variable *const r1328 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r1328);
            ir_variable *const r1329 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r1329);
            ir_variable *const r132A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r132A);
            body.emit(assign(r1328, lshift(r12DC, body.constant(int(31))), 0x01));

            ir_expression *const r132B = lshift(r12DB, body.constant(int(31)));
            ir_expression *const r132C = rshift(r12DC, body.constant(int(1)));
            body.emit(assign(r1329, bit_or(r132B, r132C), 0x01));

            body.emit(assign(r132A, rshift(r12DB, body.constant(int(1))), 0x01));

            ir_expression *const r132D = nequal(r11D4, body.constant(0u));
            ir_expression *const r132E = expr(ir_unop_b2i, r132D);
            ir_expression *const r132F = expr(ir_unop_i2u, r132E);
            body.emit(assign(r1328, bit_or(r1328, r132F), 0x01));

            body.emit(assign(r11D5, r132A, 0x01));

            body.emit(assign(r11D4, r1328, 0x01));

            ir_variable *const r1330 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r1330, r11D3, 0x01));

            ir_variable *const r1331 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r1331, r132A, 0x01));

            ir_variable *const r1332 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r1332, r1329, 0x01));

            ir_variable *const r1333 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r1333, r1328, 0x01));

            ir_variable *const r1334 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r1334, body.constant(true), 0x01));

            ir_variable *const r1335 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r1336 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r1336);
            ir_expression *const r1337 = expr(ir_unop_u2i, r1328);
            body.emit(assign(r1336, less(r1337, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r1339 = lequal(body.constant(int(2045)), r11D3);
            ir_if *f1338 = new(mem_ctx) ir_if(operand(r1339).val);
            exec_list *const f1338_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1338->then_instructions;

               ir_variable *const r133A = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r133C = less(body.constant(int(2045)), r11D3);
               ir_if *f133B = new(mem_ctx) ir_if(operand(r133C).val);
               exec_list *const f133B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f133B->then_instructions;

                  body.emit(assign(r133A, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f133B->else_instructions;

                  ir_variable *const r133D = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r133F = equal(r11D3, body.constant(int(2045)));
                  ir_if *f133E = new(mem_ctx) ir_if(operand(r133F).val);
                  exec_list *const f133E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f133E->then_instructions;

                     ir_expression *const r1340 = equal(body.constant(2097151u), r132A);
                     ir_expression *const r1341 = equal(body.constant(4294967295u), r1329);
                     body.emit(assign(r133D, logic_and(r1340, r1341), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f133E->else_instructions;

                     body.emit(assign(r133D, body.constant(false), 0x01));


                  body.instructions = f133E_parent_instructions;
                  body.emit(f133E);

                  /* END IF */

                  body.emit(assign(r133A, logic_and(r133D, r1336), 0x01));


               body.instructions = f133B_parent_instructions;
               body.emit(f133B);

               /* END IF */

               /* IF CONDITION */
               ir_if *f1342 = new(mem_ctx) ir_if(operand(r133A).val);
               exec_list *const f1342_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1342->then_instructions;

                  ir_variable *const r1343 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1343);
                  ir_expression *const r1344 = lshift(r0DB2, body.constant(int(31)));
                  body.emit(assign(r1343, add(r1344, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r1343, body.constant(0u), 0x01));

                  body.emit(assign(r1335, r1343, 0x03));

                  body.emit(assign(r1334, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1342->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1346 = less(r11D3, body.constant(int(0)));
                  ir_if *f1345 = new(mem_ctx) ir_if(operand(r1346).val);
                  exec_list *const f1345_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1345->then_instructions;

                     ir_variable *const r1347 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r1347, r1328, 0x01));

                     ir_variable *const r1348 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r1348, neg(r11D3), 0x01));

                     ir_variable *const r1349 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r1349);
                     ir_variable *const r134A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r134A);
                     ir_variable *const r134B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r134B);
                     ir_variable *const r134C = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r134D = neg(r1348);
                     body.emit(assign(r134C, bit_and(r134D, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r134F = equal(r1348, body.constant(int(0)));
                     ir_if *f134E = new(mem_ctx) ir_if(operand(r134F).val);
                     exec_list *const f134E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f134E->then_instructions;

                        body.emit(assign(r1349, r1328, 0x01));

                        body.emit(assign(r134A, r1329, 0x01));

                        body.emit(assign(r134B, r132A, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f134E->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1351 = less(r1348, body.constant(int(32)));
                        ir_if *f1350 = new(mem_ctx) ir_if(operand(r1351).val);
                        exec_list *const f1350_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1350->then_instructions;

                           body.emit(assign(r1349, lshift(r1329, r134C), 0x01));

                           ir_expression *const r1352 = lshift(r132A, r134C);
                           ir_expression *const r1353 = rshift(r1329, r1348);
                           body.emit(assign(r134A, bit_or(r1352, r1353), 0x01));

                           body.emit(assign(r134B, rshift(r132A, r1348), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1350->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1355 = equal(r1348, body.constant(int(32)));
                           ir_if *f1354 = new(mem_ctx) ir_if(operand(r1355).val);
                           exec_list *const f1354_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1354->then_instructions;

                              body.emit(assign(r1349, r1329, 0x01));

                              body.emit(assign(r134A, r132A, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1354->else_instructions;

                              body.emit(assign(r1347, bit_or(r1328, r1329), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1357 = less(r1348, body.constant(int(64)));
                              ir_if *f1356 = new(mem_ctx) ir_if(operand(r1357).val);
                              exec_list *const f1356_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1356->then_instructions;

                                 body.emit(assign(r1349, lshift(r132A, r134C), 0x01));

                                 ir_expression *const r1358 = bit_and(r1348, body.constant(int(31)));
                                 body.emit(assign(r134A, rshift(r132A, r1358), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1356->else_instructions;

                                 ir_variable *const r1359 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r135B = equal(r1348, body.constant(int(64)));
                                 ir_if *f135A = new(mem_ctx) ir_if(operand(r135B).val);
                                 exec_list *const f135A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f135A->then_instructions;

                                    body.emit(assign(r1359, r132A, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f135A->else_instructions;

                                    ir_expression *const r135C = nequal(r132A, body.constant(0u));
                                    ir_expression *const r135D = expr(ir_unop_b2i, r135C);
                                    body.emit(assign(r1359, expr(ir_unop_i2u, r135D), 0x01));


                                 body.instructions = f135A_parent_instructions;
                                 body.emit(f135A);

                                 /* END IF */

                                 body.emit(assign(r1349, r1359, 0x01));

                                 body.emit(assign(r134A, body.constant(0u), 0x01));


                              body.instructions = f1356_parent_instructions;
                              body.emit(f1356);

                              /* END IF */


                           body.instructions = f1354_parent_instructions;
                           body.emit(f1354);

                           /* END IF */

                           body.emit(assign(r134B, body.constant(0u), 0x01));


                        body.instructions = f1350_parent_instructions;
                        body.emit(f1350);

                        /* END IF */

                        ir_expression *const r135E = nequal(r1347, body.constant(0u));
                        ir_expression *const r135F = expr(ir_unop_b2i, r135E);
                        ir_expression *const r1360 = expr(ir_unop_i2u, r135F);
                        body.emit(assign(r1349, bit_or(r1349, r1360), 0x01));


                     body.instructions = f134E_parent_instructions;
                     body.emit(f134E);

                     /* END IF */

                     body.emit(assign(r1331, r134B, 0x01));

                     body.emit(assign(r1332, r134A, 0x01));

                     body.emit(assign(r1333, r1349, 0x01));

                     body.emit(assign(r1330, body.constant(int(0)), 0x01));

                     body.emit(assign(r1336, less(r1349, body.constant(0u)), 0x01));


                  body.instructions = f1345_parent_instructions;
                  body.emit(f1345);

                  /* END IF */


               body.instructions = f1342_parent_instructions;
               body.emit(f1342);

               /* END IF */


            body.instructions = f1338_parent_instructions;
            body.emit(f1338);

            /* END IF */

            /* IF CONDITION */
            ir_if *f1361 = new(mem_ctx) ir_if(operand(r1334).val);
            exec_list *const f1361_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1361->then_instructions;

               /* IF CONDITION */
               ir_if *f1362 = new(mem_ctx) ir_if(operand(r1336).val);
               exec_list *const f1362_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1362->then_instructions;

                  ir_variable *const r1363 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1363, add(r1332, body.constant(1u)), 0x01));

                  ir_expression *const r1364 = less(r1363, r1332);
                  ir_expression *const r1365 = expr(ir_unop_b2i, r1364);
                  ir_expression *const r1366 = expr(ir_unop_i2u, r1365);
                  body.emit(assign(r1331, add(r1331, r1366), 0x01));

                  ir_expression *const r1367 = equal(r1333, body.constant(0u));
                  ir_expression *const r1368 = expr(ir_unop_b2i, r1367);
                  ir_expression *const r1369 = expr(ir_unop_i2u, r1368);
                  ir_expression *const r136A = add(r1333, r1369);
                  ir_expression *const r136B = bit_and(r136A, body.constant(1u));
                  ir_expression *const r136C = expr(ir_unop_bit_not, r136B);
                  body.emit(assign(r1332, bit_and(r1363, r136C), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1362->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r136E = bit_or(r1331, r1332);
                  ir_expression *const r136F = equal(r136E, body.constant(0u));
                  ir_if *f136D = new(mem_ctx) ir_if(operand(r136F).val);
                  exec_list *const f136D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f136D->then_instructions;

                     body.emit(assign(r1330, body.constant(int(0)), 0x01));


                  body.instructions = f136D_parent_instructions;
                  body.emit(f136D);

                  /* END IF */


               body.instructions = f1362_parent_instructions;
               body.emit(f1362);

               /* END IF */

               ir_variable *const r1370 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r1370);
               ir_expression *const r1371 = lshift(r0DB2, body.constant(int(31)));
               ir_expression *const r1372 = expr(ir_unop_i2u, r1330);
               ir_expression *const r1373 = lshift(r1372, body.constant(int(20)));
               ir_expression *const r1374 = add(r1371, r1373);
               body.emit(assign(r1370, add(r1374, r1331), 0x02));

               body.emit(assign(r1370, r1332, 0x01));

               body.emit(assign(r1335, r1370, 0x03));

               body.emit(assign(r1334, body.constant(false), 0x01));


            body.instructions = f1361_parent_instructions;
            body.emit(f1361);

            /* END IF */

            body.emit(assign(r11CD, r1335, 0x03));

            body.emit(assign(r11CC, body.constant(false), 0x01));


         body.instructions = f12E1_parent_instructions;
         body.emit(f12E1);

         /* END IF */


      body.instructions = f12DA_parent_instructions;
      body.emit(f12DA);

      /* END IF */

      body.emit(assign(r0DB1, r11CD, 0x03));


   body.instructions = f0DB4_parent_instructions;
   body.emit(f0DB4);

   /* END IF */

   body.emit(ret(r0DB1));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
mul32To64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1375 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1375);
   ir_variable *const r1376 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r1376);
   ir_variable *const r1377 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1377);
   ir_variable *const r1378 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1378);
   ir_variable *const r1379 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r1379);
   ir_variable *const r137A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r137A);
   ir_variable *const r137B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r137B);
   ir_variable *const r137C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r137C, bit_and(r1375, body.constant(65535u)), 0x01));

   ir_variable *const r137D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r137D, rshift(r1375, body.constant(int(16))), 0x01));

   ir_variable *const r137E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r137E, bit_and(r1376, body.constant(65535u)), 0x01));

   ir_variable *const r137F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r137F, rshift(r1376, body.constant(int(16))), 0x01));

   ir_variable *const r1380 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1380, mul(r137D, r137E), 0x01));

   ir_expression *const r1381 = mul(r137C, r137F);
   body.emit(assign(r137A, add(r1381, r1380), 0x01));

   ir_expression *const r1382 = mul(r137D, r137F);
   ir_expression *const r1383 = less(r137A, r1380);
   ir_expression *const r1384 = expr(ir_unop_b2i, r1383);
   ir_expression *const r1385 = expr(ir_unop_i2u, r1384);
   ir_expression *const r1386 = lshift(r1385, body.constant(int(16)));
   ir_expression *const r1387 = rshift(r137A, body.constant(int(16)));
   ir_expression *const r1388 = add(r1386, r1387);
   body.emit(assign(r1379, add(r1382, r1388), 0x01));

   body.emit(assign(r137A, lshift(r137A, body.constant(int(16))), 0x01));

   ir_expression *const r1389 = mul(r137C, r137E);
   body.emit(assign(r137B, add(r1389, r137A), 0x01));

   ir_expression *const r138A = less(r137B, r137A);
   ir_expression *const r138B = expr(ir_unop_b2i, r138A);
   ir_expression *const r138C = expr(ir_unop_i2u, r138B);
   body.emit(assign(r1379, add(r1379, r138C), 0x01));

   body.emit(assign(r1378, r137B, 0x01));

   body.emit(assign(r1377, r1379, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
mul64To128(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r138D = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r138D);
   ir_variable *const r138E = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r138E);
   ir_variable *const r138F = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r138F);
   ir_variable *const r1390 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r1390);
   ir_variable *const r1391 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1391);
   ir_variable *const r1392 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1392);
   ir_variable *const r1393 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1393);
   ir_variable *const r1394 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z3Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1394);
   ir_variable *const r1395 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r1395);
   ir_variable *const r1396 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r1396);
   ir_variable *const r1397 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r1397);
   ir_variable *const r1398 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1398, bit_and(r138E, body.constant(65535u)), 0x01));

   ir_variable *const r1399 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1399, rshift(r138E, body.constant(int(16))), 0x01));

   ir_variable *const r139A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r139A, bit_and(r1390, body.constant(65535u)), 0x01));

   ir_variable *const r139B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r139B, rshift(r1390, body.constant(int(16))), 0x01));

   ir_variable *const r139C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r139C, mul(r1399, r139A), 0x01));

   ir_expression *const r139D = mul(r1398, r139B);
   body.emit(assign(r1396, add(r139D, r139C), 0x01));

   ir_expression *const r139E = mul(r1399, r139B);
   ir_expression *const r139F = less(r1396, r139C);
   ir_expression *const r13A0 = expr(ir_unop_b2i, r139F);
   ir_expression *const r13A1 = expr(ir_unop_i2u, r13A0);
   ir_expression *const r13A2 = lshift(r13A1, body.constant(int(16)));
   ir_expression *const r13A3 = rshift(r1396, body.constant(int(16)));
   ir_expression *const r13A4 = add(r13A2, r13A3);
   body.emit(assign(r1395, add(r139E, r13A4), 0x01));

   body.emit(assign(r1396, lshift(r1396, body.constant(int(16))), 0x01));

   ir_expression *const r13A5 = mul(r1398, r139A);
   body.emit(assign(r1397, add(r13A5, r1396), 0x01));

   ir_expression *const r13A6 = less(r1397, r1396);
   ir_expression *const r13A7 = expr(ir_unop_b2i, r13A6);
   ir_expression *const r13A8 = expr(ir_unop_i2u, r13A7);
   body.emit(assign(r1395, add(r1395, r13A8), 0x01));

   ir_variable *const r13A9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r13A9);
   ir_variable *const r13AA = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r13AA);
   ir_variable *const r13AB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r13AB);
   ir_variable *const r13AC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13AC, bit_and(r138E, body.constant(65535u)), 0x01));

   ir_variable *const r13AD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13AD, rshift(r138E, body.constant(int(16))), 0x01));

   ir_variable *const r13AE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13AE, bit_and(r138F, body.constant(65535u)), 0x01));

   ir_variable *const r13AF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13AF, rshift(r138F, body.constant(int(16))), 0x01));

   ir_variable *const r13B0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13B0, mul(r13AD, r13AE), 0x01));

   ir_expression *const r13B1 = mul(r13AC, r13AF);
   body.emit(assign(r13AA, add(r13B1, r13B0), 0x01));

   ir_expression *const r13B2 = mul(r13AD, r13AF);
   ir_expression *const r13B3 = less(r13AA, r13B0);
   ir_expression *const r13B4 = expr(ir_unop_b2i, r13B3);
   ir_expression *const r13B5 = expr(ir_unop_i2u, r13B4);
   ir_expression *const r13B6 = lshift(r13B5, body.constant(int(16)));
   ir_expression *const r13B7 = rshift(r13AA, body.constant(int(16)));
   ir_expression *const r13B8 = add(r13B6, r13B7);
   body.emit(assign(r13A9, add(r13B2, r13B8), 0x01));

   body.emit(assign(r13AA, lshift(r13AA, body.constant(int(16))), 0x01));

   ir_expression *const r13B9 = mul(r13AC, r13AE);
   body.emit(assign(r13AB, add(r13B9, r13AA), 0x01));

   ir_expression *const r13BA = less(r13AB, r13AA);
   ir_expression *const r13BB = expr(ir_unop_b2i, r13BA);
   ir_expression *const r13BC = expr(ir_unop_i2u, r13BB);
   body.emit(assign(r13A9, add(r13A9, r13BC), 0x01));

   ir_variable *const r13BD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13BD, add(r13AB, r1395), 0x01));

   ir_variable *const r13BE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r13BE);
   ir_variable *const r13BF = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r13BF);
   ir_variable *const r13C0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r13C0);
   ir_variable *const r13C1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13C1, bit_and(r138D, body.constant(65535u)), 0x01));

   ir_variable *const r13C2 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13C2, rshift(r138D, body.constant(int(16))), 0x01));

   ir_variable *const r13C3 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13C3, bit_and(r138F, body.constant(65535u)), 0x01));

   ir_variable *const r13C4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13C4, rshift(r138F, body.constant(int(16))), 0x01));

   ir_variable *const r13C5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13C5, mul(r13C2, r13C3), 0x01));

   ir_expression *const r13C6 = mul(r13C1, r13C4);
   body.emit(assign(r13BF, add(r13C6, r13C5), 0x01));

   ir_expression *const r13C7 = mul(r13C2, r13C4);
   ir_expression *const r13C8 = less(r13BF, r13C5);
   ir_expression *const r13C9 = expr(ir_unop_b2i, r13C8);
   ir_expression *const r13CA = expr(ir_unop_i2u, r13C9);
   ir_expression *const r13CB = lshift(r13CA, body.constant(int(16)));
   ir_expression *const r13CC = rshift(r13BF, body.constant(int(16)));
   ir_expression *const r13CD = add(r13CB, r13CC);
   body.emit(assign(r13BE, add(r13C7, r13CD), 0x01));

   body.emit(assign(r13BF, lshift(r13BF, body.constant(int(16))), 0x01));

   ir_expression *const r13CE = mul(r13C1, r13C3);
   body.emit(assign(r13C0, add(r13CE, r13BF), 0x01));

   ir_expression *const r13CF = less(r13C0, r13BF);
   ir_expression *const r13D0 = expr(ir_unop_b2i, r13CF);
   ir_expression *const r13D1 = expr(ir_unop_i2u, r13D0);
   body.emit(assign(r13BE, add(r13BE, r13D1), 0x01));

   ir_variable *const r13D2 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   ir_expression *const r13D3 = less(r13BD, r13AB);
   ir_expression *const r13D4 = expr(ir_unop_b2i, r13D3);
   ir_expression *const r13D5 = expr(ir_unop_i2u, r13D4);
   ir_expression *const r13D6 = add(r13A9, r13D5);
   body.emit(assign(r13D2, add(r13C0, r13D6), 0x01));

   ir_variable *const r13D7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r13D7);
   ir_variable *const r13D8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r13D8);
   ir_variable *const r13D9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r13D9);
   ir_variable *const r13DA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13DA, bit_and(r138D, body.constant(65535u)), 0x01));

   ir_variable *const r13DB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13DB, rshift(r138D, body.constant(int(16))), 0x01));

   ir_variable *const r13DC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13DC, bit_and(r1390, body.constant(65535u)), 0x01));

   ir_variable *const r13DD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13DD, rshift(r1390, body.constant(int(16))), 0x01));

   ir_variable *const r13DE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13DE, mul(r13DB, r13DC), 0x01));

   ir_expression *const r13DF = mul(r13DA, r13DD);
   body.emit(assign(r13D8, add(r13DF, r13DE), 0x01));

   ir_expression *const r13E0 = mul(r13DB, r13DD);
   ir_expression *const r13E1 = less(r13D8, r13DE);
   ir_expression *const r13E2 = expr(ir_unop_b2i, r13E1);
   ir_expression *const r13E3 = expr(ir_unop_i2u, r13E2);
   ir_expression *const r13E4 = lshift(r13E3, body.constant(int(16)));
   ir_expression *const r13E5 = rshift(r13D8, body.constant(int(16)));
   ir_expression *const r13E6 = add(r13E4, r13E5);
   body.emit(assign(r13D7, add(r13E0, r13E6), 0x01));

   body.emit(assign(r13D8, lshift(r13D8, body.constant(int(16))), 0x01));

   ir_expression *const r13E7 = mul(r13DA, r13DC);
   body.emit(assign(r13D9, add(r13E7, r13D8), 0x01));

   ir_expression *const r13E8 = less(r13D9, r13D8);
   ir_expression *const r13E9 = expr(ir_unop_b2i, r13E8);
   ir_expression *const r13EA = expr(ir_unop_i2u, r13E9);
   body.emit(assign(r13D7, add(r13D7, r13EA), 0x01));

   ir_variable *const r13EB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13EB, add(r13D9, r13BD), 0x01));

   ir_variable *const r13EC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   ir_expression *const r13ED = less(r13EB, r13D9);
   ir_expression *const r13EE = expr(ir_unop_b2i, r13ED);
   ir_expression *const r13EF = expr(ir_unop_i2u, r13EE);
   ir_expression *const r13F0 = add(r13D7, r13EF);
   body.emit(assign(r13EC, add(r13D2, r13F0), 0x01));

   body.emit(assign(r1394, r1397, 0x01));

   body.emit(assign(r1393, r13EB, 0x01));

   body.emit(assign(r1392, r13EC, 0x01));

   ir_expression *const r13F1 = less(r13D2, r13C0);
   ir_expression *const r13F2 = expr(ir_unop_b2i, r13F1);
   ir_expression *const r13F3 = expr(ir_unop_i2u, r13F2);
   ir_expression *const r13F4 = add(r13BE, r13F3);
   ir_expression *const r13F5 = less(r13EC, r13D2);
   ir_expression *const r13F6 = expr(ir_unop_b2i, r13F5);
   ir_expression *const r13F7 = expr(ir_unop_i2u, r13F6);
   body.emit(assign(r1391, add(r13F4, r13F7), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
normalizeFloat64Subnormal(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r13F8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac0", ir_var_function_in);
   sig_parameters.push_tail(r13F8);
   ir_variable *const r13F9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac1", ir_var_function_in);
   sig_parameters.push_tail(r13F9);
   ir_variable *const r13FA = new(mem_ctx) ir_variable(glsl_type::int_type, "zExpPtr", ir_var_function_inout);
   sig_parameters.push_tail(r13FA);
   ir_variable *const r13FB = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r13FB);
   ir_variable *const r13FC = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r13FC);
   ir_variable *const r13FD = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r13FD);
   /* IF CONDITION */
   ir_expression *const r13FF = equal(r13F8, body.constant(0u));
   ir_if *f13FE = new(mem_ctx) ir_if(operand(r13FF).val);
   exec_list *const f13FE_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f13FE->then_instructions;

      ir_variable *const r1400 = body.make_temp(glsl_type::uint_type, "a");
      body.emit(assign(r1400, r13F9, 0x01));

      ir_variable *const r1401 = body.make_temp(glsl_type::int_type, "return_value");
      ir_variable *const r1402 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
      body.emit(r1402);
      /* IF CONDITION */
      ir_expression *const r1404 = equal(r13F9, body.constant(0u));
      ir_if *f1403 = new(mem_ctx) ir_if(operand(r1404).val);
      exec_list *const f1403_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1403->then_instructions;

         body.emit(assign(r1401, body.constant(int(32)), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1403->else_instructions;

         body.emit(assign(r1402, body.constant(int(0)), 0x01));

         /* IF CONDITION */
         ir_expression *const r1406 = bit_and(r13F9, body.constant(4294901760u));
         ir_expression *const r1407 = equal(r1406, body.constant(0u));
         ir_if *f1405 = new(mem_ctx) ir_if(operand(r1407).val);
         exec_list *const f1405_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1405->then_instructions;

            body.emit(assign(r1402, body.constant(int(16)), 0x01));

            body.emit(assign(r1400, lshift(r13F9, body.constant(int(16))), 0x01));


         body.instructions = f1405_parent_instructions;
         body.emit(f1405);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1409 = bit_and(r1400, body.constant(4278190080u));
         ir_expression *const r140A = equal(r1409, body.constant(0u));
         ir_if *f1408 = new(mem_ctx) ir_if(operand(r140A).val);
         exec_list *const f1408_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1408->then_instructions;

            body.emit(assign(r1402, add(r1402, body.constant(int(8))), 0x01));

            body.emit(assign(r1400, lshift(r1400, body.constant(int(8))), 0x01));


         body.instructions = f1408_parent_instructions;
         body.emit(f1408);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r140C = bit_and(r1400, body.constant(4026531840u));
         ir_expression *const r140D = equal(r140C, body.constant(0u));
         ir_if *f140B = new(mem_ctx) ir_if(operand(r140D).val);
         exec_list *const f140B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f140B->then_instructions;

            body.emit(assign(r1402, add(r1402, body.constant(int(4))), 0x01));

            body.emit(assign(r1400, lshift(r1400, body.constant(int(4))), 0x01));


         body.instructions = f140B_parent_instructions;
         body.emit(f140B);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r140F = bit_and(r1400, body.constant(3221225472u));
         ir_expression *const r1410 = equal(r140F, body.constant(0u));
         ir_if *f140E = new(mem_ctx) ir_if(operand(r1410).val);
         exec_list *const f140E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f140E->then_instructions;

            body.emit(assign(r1402, add(r1402, body.constant(int(2))), 0x01));

            body.emit(assign(r1400, lshift(r1400, body.constant(int(2))), 0x01));


         body.instructions = f140E_parent_instructions;
         body.emit(f140E);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1412 = bit_and(r1400, body.constant(2147483648u));
         ir_expression *const r1413 = equal(r1412, body.constant(0u));
         ir_if *f1411 = new(mem_ctx) ir_if(operand(r1413).val);
         exec_list *const f1411_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1411->then_instructions;

            body.emit(assign(r1402, add(r1402, body.constant(int(1))), 0x01));


         body.instructions = f1411_parent_instructions;
         body.emit(f1411);

         /* END IF */

         body.emit(assign(r1401, r1402, 0x01));


      body.instructions = f1403_parent_instructions;
      body.emit(f1403);

      /* END IF */

      body.emit(assign(r13FD, add(r1401, body.constant(int(-11))), 0x01));

      /* IF CONDITION */
      ir_expression *const r1415 = less(r13FD, body.constant(int(0)));
      ir_if *f1414 = new(mem_ctx) ir_if(operand(r1415).val);
      exec_list *const f1414_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1414->then_instructions;

         ir_expression *const r1416 = neg(r13FD);
         body.emit(assign(r13FB, rshift(r13F9, r1416), 0x01));

         ir_expression *const r1417 = bit_and(r13FD, body.constant(int(31)));
         body.emit(assign(r13FC, lshift(r13F9, r1417), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1414->else_instructions;

         body.emit(assign(r13FB, lshift(r13F9, r13FD), 0x01));

         body.emit(assign(r13FC, body.constant(0u), 0x01));


      body.instructions = f1414_parent_instructions;
      body.emit(f1414);

      /* END IF */

      body.emit(assign(r13FA, sub(body.constant(int(-31)), r13FD), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f13FE->else_instructions;

      ir_variable *const r1418 = body.make_temp(glsl_type::uint_type, "a");
      body.emit(assign(r1418, r13F8, 0x01));

      ir_variable *const r1419 = body.make_temp(glsl_type::int_type, "return_value");
      ir_variable *const r141A = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
      body.emit(r141A);
      /* IF CONDITION */
      ir_expression *const r141C = equal(r13F8, body.constant(0u));
      ir_if *f141B = new(mem_ctx) ir_if(operand(r141C).val);
      exec_list *const f141B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f141B->then_instructions;

         body.emit(assign(r1419, body.constant(int(32)), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f141B->else_instructions;

         body.emit(assign(r141A, body.constant(int(0)), 0x01));

         /* IF CONDITION */
         ir_expression *const r141E = bit_and(r13F8, body.constant(4294901760u));
         ir_expression *const r141F = equal(r141E, body.constant(0u));
         ir_if *f141D = new(mem_ctx) ir_if(operand(r141F).val);
         exec_list *const f141D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f141D->then_instructions;

            body.emit(assign(r141A, body.constant(int(16)), 0x01));

            body.emit(assign(r1418, lshift(r13F8, body.constant(int(16))), 0x01));


         body.instructions = f141D_parent_instructions;
         body.emit(f141D);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1421 = bit_and(r1418, body.constant(4278190080u));
         ir_expression *const r1422 = equal(r1421, body.constant(0u));
         ir_if *f1420 = new(mem_ctx) ir_if(operand(r1422).val);
         exec_list *const f1420_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1420->then_instructions;

            body.emit(assign(r141A, add(r141A, body.constant(int(8))), 0x01));

            body.emit(assign(r1418, lshift(r1418, body.constant(int(8))), 0x01));


         body.instructions = f1420_parent_instructions;
         body.emit(f1420);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1424 = bit_and(r1418, body.constant(4026531840u));
         ir_expression *const r1425 = equal(r1424, body.constant(0u));
         ir_if *f1423 = new(mem_ctx) ir_if(operand(r1425).val);
         exec_list *const f1423_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1423->then_instructions;

            body.emit(assign(r141A, add(r141A, body.constant(int(4))), 0x01));

            body.emit(assign(r1418, lshift(r1418, body.constant(int(4))), 0x01));


         body.instructions = f1423_parent_instructions;
         body.emit(f1423);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1427 = bit_and(r1418, body.constant(3221225472u));
         ir_expression *const r1428 = equal(r1427, body.constant(0u));
         ir_if *f1426 = new(mem_ctx) ir_if(operand(r1428).val);
         exec_list *const f1426_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1426->then_instructions;

            body.emit(assign(r141A, add(r141A, body.constant(int(2))), 0x01));

            body.emit(assign(r1418, lshift(r1418, body.constant(int(2))), 0x01));


         body.instructions = f1426_parent_instructions;
         body.emit(f1426);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r142A = bit_and(r1418, body.constant(2147483648u));
         ir_expression *const r142B = equal(r142A, body.constant(0u));
         ir_if *f1429 = new(mem_ctx) ir_if(operand(r142B).val);
         exec_list *const f1429_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1429->then_instructions;

            body.emit(assign(r141A, add(r141A, body.constant(int(1))), 0x01));


         body.instructions = f1429_parent_instructions;
         body.emit(f1429);

         /* END IF */

         body.emit(assign(r1419, r141A, 0x01));


      body.instructions = f141B_parent_instructions;
      body.emit(f141B);

      /* END IF */

      body.emit(assign(r13FD, add(r1419, body.constant(int(-11))), 0x01));

      ir_variable *const r142C = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r142C, lshift(r13F9, r13FD), 0x01));

      ir_variable *const r142D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r142F = equal(r13FD, body.constant(int(0)));
      ir_if *f142E = new(mem_ctx) ir_if(operand(r142F).val);
      exec_list *const f142E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f142E->then_instructions;

         body.emit(assign(r142D, r13F8, 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f142E->else_instructions;

         ir_expression *const r1430 = lshift(r13F8, r13FD);
         ir_expression *const r1431 = neg(r13FD);
         ir_expression *const r1432 = bit_and(r1431, body.constant(int(31)));
         ir_expression *const r1433 = rshift(r13F9, r1432);
         body.emit(assign(r142D, bit_or(r1430, r1433), 0x01));


      body.instructions = f142E_parent_instructions;
      body.emit(f142E);

      /* END IF */

      body.emit(assign(r13FB, r142D, 0x01));

      body.emit(assign(r13FC, r142C, 0x01));

      body.emit(assign(r13FA, sub(body.constant(int(1)), r13FD), 0x01));


   body.instructions = f13FE_parent_instructions;
   body.emit(f13FE);

   /* END IF */

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fmul64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1434 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1434);
   ir_variable *const r1435 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r1435);
   ir_variable *const r1436 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r1436, body.constant(true), 0x01));

   ir_variable *const r1437 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1438 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_auto);
   body.emit(r1438);
   ir_variable *const r1439 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
   body.emit(r1439);
   ir_variable *const r143A = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r143A);
   ir_variable *const r143B = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
   body.emit(r143B);
   ir_variable *const r143C = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
   body.emit(r143C);
   ir_variable *const r143D = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r143D);
   ir_variable *const r143E = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
   body.emit(r143E);
   ir_variable *const r143F = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r143F);
   ir_variable *const r1440 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
   body.emit(r1440);
   ir_variable *const r1441 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r1441);
   ir_variable *const r1442 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r1442);
   body.emit(assign(r1442, body.constant(0u), 0x01));

   body.emit(assign(r1441, body.constant(0u), 0x01));

   body.emit(assign(r1440, body.constant(0u), 0x01));

   ir_variable *const r1443 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r1443, swizzle_x(r1434), 0x01));

   body.emit(assign(r143E, r1443, 0x01));

   ir_variable *const r1444 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r1444, bit_and(swizzle_y(r1434), body.constant(1048575u)), 0x01));

   body.emit(assign(r143D, r1444, 0x01));

   ir_variable *const r1445 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r1445, swizzle_x(r1435), 0x01));

   body.emit(assign(r143C, r1445, 0x01));

   ir_variable *const r1446 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r1446, bit_and(swizzle_y(r1435), body.constant(1048575u)), 0x01));

   body.emit(assign(r143B, r1446, 0x01));

   ir_variable *const r1447 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r1448 = rshift(swizzle_y(r1434), body.constant(int(20)));
   ir_expression *const r1449 = bit_and(r1448, body.constant(2047u));
   body.emit(assign(r1447, expr(ir_unop_u2i, r1449), 0x01));

   body.emit(assign(r143A, r1447, 0x01));

   ir_variable *const r144A = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r144B = rshift(swizzle_y(r1435), body.constant(int(20)));
   ir_expression *const r144C = bit_and(r144B, body.constant(2047u));
   body.emit(assign(r144A, expr(ir_unop_u2i, r144C), 0x01));

   body.emit(assign(r1439, r144A, 0x01));

   ir_expression *const r144D = rshift(swizzle_y(r1434), body.constant(int(31)));
   ir_expression *const r144E = rshift(swizzle_y(r1435), body.constant(int(31)));
   body.emit(assign(r1438, bit_xor(r144D, r144E), 0x01));

   /* IF CONDITION */
   ir_expression *const r1450 = equal(r1447, body.constant(int(2047)));
   ir_if *f144F = new(mem_ctx) ir_if(operand(r1450).val);
   exec_list *const f144F_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f144F->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1452 = bit_or(r1444, swizzle_x(r1434));
      ir_expression *const r1453 = nequal(r1452, body.constant(0u));
      ir_expression *const r1454 = equal(r144A, body.constant(int(2047)));
      ir_expression *const r1455 = bit_or(r1446, swizzle_x(r1435));
      ir_expression *const r1456 = nequal(r1455, body.constant(0u));
      ir_expression *const r1457 = logic_and(r1454, r1456);
      ir_expression *const r1458 = logic_or(r1453, r1457);
      ir_if *f1451 = new(mem_ctx) ir_if(operand(r1458).val);
      exec_list *const f1451_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1451->then_instructions;

         ir_variable *const r1459 = body.make_temp(glsl_type::uvec2_type, "a");
         body.emit(assign(r1459, swizzle_x(r1434), 0x01));

         ir_variable *const r145A = body.make_temp(glsl_type::uvec2_type, "b");
         body.emit(assign(r145A, swizzle_x(r1435), 0x01));

         ir_variable *const r145B = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r145C = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
         ir_expression *const r145D = rshift(swizzle_y(r1434), body.constant(int(19)));
         ir_expression *const r145E = bit_and(r145D, body.constant(4095u));
         ir_expression *const r145F = equal(r145E, body.constant(4094u));
         ir_expression *const r1460 = nequal(swizzle_x(r1434), body.constant(0u));
         ir_expression *const r1461 = bit_and(swizzle_y(r1434), body.constant(524287u));
         ir_expression *const r1462 = nequal(r1461, body.constant(0u));
         ir_expression *const r1463 = logic_or(r1460, r1462);
         body.emit(assign(r145C, logic_and(r145F, r1463), 0x01));

         ir_variable *const r1464 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
         ir_expression *const r1465 = lshift(swizzle_y(r1435), body.constant(int(1)));
         ir_expression *const r1466 = lequal(body.constant(4292870144u), r1465);
         ir_expression *const r1467 = nequal(swizzle_x(r1435), body.constant(0u));
         ir_expression *const r1468 = bit_and(swizzle_y(r1435), body.constant(1048575u));
         ir_expression *const r1469 = nequal(r1468, body.constant(0u));
         ir_expression *const r146A = logic_or(r1467, r1469);
         body.emit(assign(r1464, logic_and(r1466, r146A), 0x01));

         body.emit(assign(r1459, bit_or(swizzle_y(r1434), body.constant(524288u)), 0x02));

         body.emit(assign(r145A, bit_or(swizzle_y(r1435), body.constant(524288u)), 0x02));

         /* IF CONDITION */
         ir_expression *const r146C = lshift(swizzle_y(r1434), body.constant(int(1)));
         ir_expression *const r146D = lequal(body.constant(4292870144u), r146C);
         ir_expression *const r146E = nequal(swizzle_x(r1434), body.constant(0u));
         ir_expression *const r146F = bit_and(swizzle_y(r1434), body.constant(1048575u));
         ir_expression *const r1470 = nequal(r146F, body.constant(0u));
         ir_expression *const r1471 = logic_or(r146E, r1470);
         ir_expression *const r1472 = logic_and(r146D, r1471);
         ir_if *f146B = new(mem_ctx) ir_if(operand(r1472).val);
         exec_list *const f146B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f146B->then_instructions;

            ir_variable *const r1473 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r1475 = logic_and(r145C, r1464);
            ir_if *f1474 = new(mem_ctx) ir_if(operand(r1475).val);
            exec_list *const f1474_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1474->then_instructions;

               body.emit(assign(r1473, r145A, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1474->else_instructions;

               body.emit(assign(r1473, r1459, 0x03));


            body.instructions = f1474_parent_instructions;
            body.emit(f1474);

            /* END IF */

            body.emit(assign(r145B, r1473, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f146B->else_instructions;

            body.emit(assign(r145B, r145A, 0x03));


         body.instructions = f146B_parent_instructions;
         body.emit(f146B);

         /* END IF */

         body.emit(assign(r1437, r145B, 0x03));

         body.emit(assign(r1436, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1451->else_instructions;

         /* IF CONDITION */
         ir_expression *const r1477 = expr(ir_unop_i2u, r144A);
         ir_expression *const r1478 = bit_or(r1477, r1446);
         ir_expression *const r1479 = bit_or(r1478, swizzle_x(r1435));
         ir_expression *const r147A = equal(r1479, body.constant(0u));
         ir_if *f1476 = new(mem_ctx) ir_if(operand(r147A).val);
         exec_list *const f1476_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1476->then_instructions;

            ir_constant_data r147B_data;
            memset(&r147B_data, 0, sizeof(ir_constant_data));
            r147B_data.u[0] = 4294967295;
            r147B_data.u[1] = 4294967295;
            ir_constant *const r147B = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r147B_data);
            body.emit(assign(r1437, r147B, 0x03));

            body.emit(assign(r1436, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1476->else_instructions;

            ir_variable *const r147C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r147C);
            ir_expression *const r147D = lshift(r1438, body.constant(int(31)));
            body.emit(assign(r147C, add(r147D, body.constant(2146435072u)), 0x02));

            body.emit(assign(r147C, body.constant(0u), 0x01));

            body.emit(assign(r1437, r147C, 0x03));

            body.emit(assign(r1436, body.constant(false), 0x01));


         body.instructions = f1476_parent_instructions;
         body.emit(f1476);

         /* END IF */


      body.instructions = f1451_parent_instructions;
      body.emit(f1451);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f144F->else_instructions;

      /* IF CONDITION */
      ir_expression *const r147F = equal(r144A, body.constant(int(2047)));
      ir_if *f147E = new(mem_ctx) ir_if(operand(r147F).val);
      exec_list *const f147E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f147E->then_instructions;

         /* IF CONDITION */
         ir_expression *const r1481 = bit_or(r1446, swizzle_x(r1435));
         ir_expression *const r1482 = nequal(r1481, body.constant(0u));
         ir_if *f1480 = new(mem_ctx) ir_if(operand(r1482).val);
         exec_list *const f1480_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1480->then_instructions;

            ir_variable *const r1483 = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r1483, swizzle_x(r1434), 0x01));

            ir_variable *const r1484 = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r1484, swizzle_x(r1435), 0x01));

            ir_variable *const r1485 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r1486 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r1487 = rshift(swizzle_y(r1434), body.constant(int(19)));
            ir_expression *const r1488 = bit_and(r1487, body.constant(4095u));
            ir_expression *const r1489 = equal(r1488, body.constant(4094u));
            ir_expression *const r148A = nequal(swizzle_x(r1434), body.constant(0u));
            ir_expression *const r148B = bit_and(swizzle_y(r1434), body.constant(524287u));
            ir_expression *const r148C = nequal(r148B, body.constant(0u));
            ir_expression *const r148D = logic_or(r148A, r148C);
            body.emit(assign(r1486, logic_and(r1489, r148D), 0x01));

            ir_variable *const r148E = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r148F = lshift(swizzle_y(r1435), body.constant(int(1)));
            ir_expression *const r1490 = lequal(body.constant(4292870144u), r148F);
            ir_expression *const r1491 = nequal(swizzle_x(r1435), body.constant(0u));
            ir_expression *const r1492 = bit_and(swizzle_y(r1435), body.constant(1048575u));
            ir_expression *const r1493 = nequal(r1492, body.constant(0u));
            ir_expression *const r1494 = logic_or(r1491, r1493);
            body.emit(assign(r148E, logic_and(r1490, r1494), 0x01));

            body.emit(assign(r1483, bit_or(swizzle_y(r1434), body.constant(524288u)), 0x02));

            body.emit(assign(r1484, bit_or(swizzle_y(r1435), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r1496 = lshift(swizzle_y(r1434), body.constant(int(1)));
            ir_expression *const r1497 = lequal(body.constant(4292870144u), r1496);
            ir_expression *const r1498 = nequal(swizzle_x(r1434), body.constant(0u));
            ir_expression *const r1499 = bit_and(swizzle_y(r1434), body.constant(1048575u));
            ir_expression *const r149A = nequal(r1499, body.constant(0u));
            ir_expression *const r149B = logic_or(r1498, r149A);
            ir_expression *const r149C = logic_and(r1497, r149B);
            ir_if *f1495 = new(mem_ctx) ir_if(operand(r149C).val);
            exec_list *const f1495_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1495->then_instructions;

               ir_variable *const r149D = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r149F = logic_and(r1486, r148E);
               ir_if *f149E = new(mem_ctx) ir_if(operand(r149F).val);
               exec_list *const f149E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f149E->then_instructions;

                  body.emit(assign(r149D, r1484, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f149E->else_instructions;

                  body.emit(assign(r149D, r1483, 0x03));


               body.instructions = f149E_parent_instructions;
               body.emit(f149E);

               /* END IF */

               body.emit(assign(r1485, r149D, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1495->else_instructions;

               body.emit(assign(r1485, r1484, 0x03));


            body.instructions = f1495_parent_instructions;
            body.emit(f1495);

            /* END IF */

            body.emit(assign(r1437, r1485, 0x03));

            body.emit(assign(r1436, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1480->else_instructions;

            /* IF CONDITION */
            ir_expression *const r14A1 = expr(ir_unop_i2u, r1447);
            ir_expression *const r14A2 = bit_or(r14A1, r1444);
            ir_expression *const r14A3 = bit_or(r14A2, swizzle_x(r1434));
            ir_expression *const r14A4 = equal(r14A3, body.constant(0u));
            ir_if *f14A0 = new(mem_ctx) ir_if(operand(r14A4).val);
            exec_list *const f14A0_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f14A0->then_instructions;

               ir_constant_data r14A5_data;
               memset(&r14A5_data, 0, sizeof(ir_constant_data));
               r14A5_data.u[0] = 4294967295;
               r14A5_data.u[1] = 4294967295;
               ir_constant *const r14A5 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r14A5_data);
               body.emit(assign(r1437, r14A5, 0x03));

               body.emit(assign(r1436, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f14A0->else_instructions;

               ir_variable *const r14A6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r14A6);
               ir_expression *const r14A7 = lshift(r1438, body.constant(int(31)));
               body.emit(assign(r14A6, add(r14A7, body.constant(2146435072u)), 0x02));

               body.emit(assign(r14A6, body.constant(0u), 0x01));

               body.emit(assign(r1437, r14A6, 0x03));

               body.emit(assign(r1436, body.constant(false), 0x01));


            body.instructions = f14A0_parent_instructions;
            body.emit(f14A0);

            /* END IF */


         body.instructions = f1480_parent_instructions;
         body.emit(f1480);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f147E->else_instructions;

         /* IF CONDITION */
         ir_expression *const r14A9 = equal(r1447, body.constant(int(0)));
         ir_if *f14A8 = new(mem_ctx) ir_if(operand(r14A9).val);
         exec_list *const f14A8_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f14A8->then_instructions;

            /* IF CONDITION */
            ir_expression *const r14AB = bit_or(r1444, swizzle_x(r1434));
            ir_expression *const r14AC = equal(r14AB, body.constant(0u));
            ir_if *f14AA = new(mem_ctx) ir_if(operand(r14AC).val);
            exec_list *const f14AA_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f14AA->then_instructions;

               ir_variable *const r14AD = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r14AD);
               body.emit(assign(r14AD, lshift(r1438, body.constant(int(31))), 0x02));

               body.emit(assign(r14AD, body.constant(0u), 0x01));

               body.emit(assign(r1437, r14AD, 0x03));

               body.emit(assign(r1436, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f14AA->else_instructions;

               ir_variable *const r14AE = body.make_temp(glsl_type::int_type, "zExpPtr");
               body.emit(assign(r14AE, r1447, 0x01));

               ir_variable *const r14AF = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
               body.emit(assign(r14AF, r1444, 0x01));

               ir_variable *const r14B0 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
               body.emit(assign(r14B0, r1443, 0x01));

               ir_variable *const r14B1 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r14B1);
               /* IF CONDITION */
               ir_expression *const r14B3 = equal(r1444, body.constant(0u));
               ir_if *f14B2 = new(mem_ctx) ir_if(operand(r14B3).val);
               exec_list *const f14B2_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f14B2->then_instructions;

                  ir_variable *const r14B4 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r14B4, r1443, 0x01));

                  ir_variable *const r14B5 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r14B6 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r14B6);
                  /* IF CONDITION */
                  ir_expression *const r14B8 = equal(swizzle_x(r1434), body.constant(0u));
                  ir_if *f14B7 = new(mem_ctx) ir_if(operand(r14B8).val);
                  exec_list *const f14B7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f14B7->then_instructions;

                     body.emit(assign(r14B5, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f14B7->else_instructions;

                     body.emit(assign(r14B6, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r14BA = bit_and(swizzle_x(r1434), body.constant(4294901760u));
                     ir_expression *const r14BB = equal(r14BA, body.constant(0u));
                     ir_if *f14B9 = new(mem_ctx) ir_if(operand(r14BB).val);
                     exec_list *const f14B9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14B9->then_instructions;

                        body.emit(assign(r14B6, body.constant(int(16)), 0x01));

                        body.emit(assign(r14B4, lshift(swizzle_x(r1434), body.constant(int(16))), 0x01));


                     body.instructions = f14B9_parent_instructions;
                     body.emit(f14B9);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14BD = bit_and(r14B4, body.constant(4278190080u));
                     ir_expression *const r14BE = equal(r14BD, body.constant(0u));
                     ir_if *f14BC = new(mem_ctx) ir_if(operand(r14BE).val);
                     exec_list *const f14BC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14BC->then_instructions;

                        body.emit(assign(r14B6, add(r14B6, body.constant(int(8))), 0x01));

                        body.emit(assign(r14B4, lshift(r14B4, body.constant(int(8))), 0x01));


                     body.instructions = f14BC_parent_instructions;
                     body.emit(f14BC);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14C0 = bit_and(r14B4, body.constant(4026531840u));
                     ir_expression *const r14C1 = equal(r14C0, body.constant(0u));
                     ir_if *f14BF = new(mem_ctx) ir_if(operand(r14C1).val);
                     exec_list *const f14BF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14BF->then_instructions;

                        body.emit(assign(r14B6, add(r14B6, body.constant(int(4))), 0x01));

                        body.emit(assign(r14B4, lshift(r14B4, body.constant(int(4))), 0x01));


                     body.instructions = f14BF_parent_instructions;
                     body.emit(f14BF);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14C3 = bit_and(r14B4, body.constant(3221225472u));
                     ir_expression *const r14C4 = equal(r14C3, body.constant(0u));
                     ir_if *f14C2 = new(mem_ctx) ir_if(operand(r14C4).val);
                     exec_list *const f14C2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14C2->then_instructions;

                        body.emit(assign(r14B6, add(r14B6, body.constant(int(2))), 0x01));

                        body.emit(assign(r14B4, lshift(r14B4, body.constant(int(2))), 0x01));


                     body.instructions = f14C2_parent_instructions;
                     body.emit(f14C2);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14C6 = bit_and(r14B4, body.constant(2147483648u));
                     ir_expression *const r14C7 = equal(r14C6, body.constant(0u));
                     ir_if *f14C5 = new(mem_ctx) ir_if(operand(r14C7).val);
                     exec_list *const f14C5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14C5->then_instructions;

                        body.emit(assign(r14B6, add(r14B6, body.constant(int(1))), 0x01));


                     body.instructions = f14C5_parent_instructions;
                     body.emit(f14C5);

                     /* END IF */

                     body.emit(assign(r14B5, r14B6, 0x01));


                  body.instructions = f14B7_parent_instructions;
                  body.emit(f14B7);

                  /* END IF */

                  body.emit(assign(r14B1, add(r14B5, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r14C9 = less(r14B1, body.constant(int(0)));
                  ir_if *f14C8 = new(mem_ctx) ir_if(operand(r14C9).val);
                  exec_list *const f14C8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f14C8->then_instructions;

                     ir_expression *const r14CA = neg(r14B1);
                     body.emit(assign(r14AF, rshift(swizzle_x(r1434), r14CA), 0x01));

                     ir_expression *const r14CB = bit_and(r14B1, body.constant(int(31)));
                     body.emit(assign(r14B0, lshift(swizzle_x(r1434), r14CB), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f14C8->else_instructions;

                     body.emit(assign(r14AF, lshift(swizzle_x(r1434), r14B1), 0x01));

                     body.emit(assign(r14B0, body.constant(0u), 0x01));


                  body.instructions = f14C8_parent_instructions;
                  body.emit(f14C8);

                  /* END IF */

                  body.emit(assign(r14AE, sub(body.constant(int(-31)), r14B1), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f14B2->else_instructions;

                  ir_variable *const r14CC = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r14CC, r1444, 0x01));

                  ir_variable *const r14CD = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r14CE = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r14CE);
                  /* IF CONDITION */
                  ir_expression *const r14D0 = equal(r1444, body.constant(0u));
                  ir_if *f14CF = new(mem_ctx) ir_if(operand(r14D0).val);
                  exec_list *const f14CF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f14CF->then_instructions;

                     body.emit(assign(r14CD, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f14CF->else_instructions;

                     body.emit(assign(r14CE, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r14D2 = bit_and(r1444, body.constant(4294901760u));
                     ir_expression *const r14D3 = equal(r14D2, body.constant(0u));
                     ir_if *f14D1 = new(mem_ctx) ir_if(operand(r14D3).val);
                     exec_list *const f14D1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14D1->then_instructions;

                        body.emit(assign(r14CE, body.constant(int(16)), 0x01));

                        body.emit(assign(r14CC, lshift(r1444, body.constant(int(16))), 0x01));


                     body.instructions = f14D1_parent_instructions;
                     body.emit(f14D1);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14D5 = bit_and(r14CC, body.constant(4278190080u));
                     ir_expression *const r14D6 = equal(r14D5, body.constant(0u));
                     ir_if *f14D4 = new(mem_ctx) ir_if(operand(r14D6).val);
                     exec_list *const f14D4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14D4->then_instructions;

                        body.emit(assign(r14CE, add(r14CE, body.constant(int(8))), 0x01));

                        body.emit(assign(r14CC, lshift(r14CC, body.constant(int(8))), 0x01));


                     body.instructions = f14D4_parent_instructions;
                     body.emit(f14D4);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14D8 = bit_and(r14CC, body.constant(4026531840u));
                     ir_expression *const r14D9 = equal(r14D8, body.constant(0u));
                     ir_if *f14D7 = new(mem_ctx) ir_if(operand(r14D9).val);
                     exec_list *const f14D7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14D7->then_instructions;

                        body.emit(assign(r14CE, add(r14CE, body.constant(int(4))), 0x01));

                        body.emit(assign(r14CC, lshift(r14CC, body.constant(int(4))), 0x01));


                     body.instructions = f14D7_parent_instructions;
                     body.emit(f14D7);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14DB = bit_and(r14CC, body.constant(3221225472u));
                     ir_expression *const r14DC = equal(r14DB, body.constant(0u));
                     ir_if *f14DA = new(mem_ctx) ir_if(operand(r14DC).val);
                     exec_list *const f14DA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14DA->then_instructions;

                        body.emit(assign(r14CE, add(r14CE, body.constant(int(2))), 0x01));

                        body.emit(assign(r14CC, lshift(r14CC, body.constant(int(2))), 0x01));


                     body.instructions = f14DA_parent_instructions;
                     body.emit(f14DA);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14DE = bit_and(r14CC, body.constant(2147483648u));
                     ir_expression *const r14DF = equal(r14DE, body.constant(0u));
                     ir_if *f14DD = new(mem_ctx) ir_if(operand(r14DF).val);
                     exec_list *const f14DD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14DD->then_instructions;

                        body.emit(assign(r14CE, add(r14CE, body.constant(int(1))), 0x01));


                     body.instructions = f14DD_parent_instructions;
                     body.emit(f14DD);

                     /* END IF */

                     body.emit(assign(r14CD, r14CE, 0x01));


                  body.instructions = f14CF_parent_instructions;
                  body.emit(f14CF);

                  /* END IF */

                  body.emit(assign(r14B1, add(r14CD, body.constant(int(-11))), 0x01));

                  ir_variable *const r14E0 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r14E0, lshift(swizzle_x(r1434), r14B1), 0x01));

                  ir_variable *const r14E1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r14E3 = equal(r14B1, body.constant(int(0)));
                  ir_if *f14E2 = new(mem_ctx) ir_if(operand(r14E3).val);
                  exec_list *const f14E2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f14E2->then_instructions;

                     body.emit(assign(r14E1, r1444, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f14E2->else_instructions;

                     ir_expression *const r14E4 = lshift(r1444, r14B1);
                     ir_expression *const r14E5 = neg(r14B1);
                     ir_expression *const r14E6 = bit_and(r14E5, body.constant(int(31)));
                     ir_expression *const r14E7 = rshift(swizzle_x(r1434), r14E6);
                     body.emit(assign(r14E1, bit_or(r14E4, r14E7), 0x01));


                  body.instructions = f14E2_parent_instructions;
                  body.emit(f14E2);

                  /* END IF */

                  body.emit(assign(r14AF, r14E1, 0x01));

                  body.emit(assign(r14B0, r14E0, 0x01));

                  body.emit(assign(r14AE, sub(body.constant(int(1)), r14B1), 0x01));


               body.instructions = f14B2_parent_instructions;
               body.emit(f14B2);

               /* END IF */

               body.emit(assign(r143A, r14AE, 0x01));

               body.emit(assign(r143D, r14AF, 0x01));

               body.emit(assign(r143E, r14B0, 0x01));


            body.instructions = f14AA_parent_instructions;
            body.emit(f14AA);

            /* END IF */


         body.instructions = f14A8_parent_instructions;
         body.emit(f14A8);

         /* END IF */

         /* IF CONDITION */
         ir_if *f14E8 = new(mem_ctx) ir_if(operand(r1436).val);
         exec_list *const f14E8_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f14E8->then_instructions;

            /* IF CONDITION */
            ir_expression *const r14EA = equal(r144A, body.constant(int(0)));
            ir_if *f14E9 = new(mem_ctx) ir_if(operand(r14EA).val);
            exec_list *const f14E9_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f14E9->then_instructions;

               /* IF CONDITION */
               ir_expression *const r14EC = bit_or(r1446, swizzle_x(r1435));
               ir_expression *const r14ED = equal(r14EC, body.constant(0u));
               ir_if *f14EB = new(mem_ctx) ir_if(operand(r14ED).val);
               exec_list *const f14EB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f14EB->then_instructions;

                  ir_variable *const r14EE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r14EE);
                  body.emit(assign(r14EE, lshift(r1438, body.constant(int(31))), 0x02));

                  body.emit(assign(r14EE, body.constant(0u), 0x01));

                  body.emit(assign(r1437, r14EE, 0x03));

                  body.emit(assign(r1436, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f14EB->else_instructions;

                  ir_variable *const r14EF = body.make_temp(glsl_type::int_type, "zExpPtr");
                  body.emit(assign(r14EF, r144A, 0x01));

                  ir_variable *const r14F0 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
                  body.emit(assign(r14F0, r1446, 0x01));

                  ir_variable *const r14F1 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
                  body.emit(assign(r14F1, r1445, 0x01));

                  ir_variable *const r14F2 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r14F2);
                  /* IF CONDITION */
                  ir_expression *const r14F4 = equal(r1446, body.constant(0u));
                  ir_if *f14F3 = new(mem_ctx) ir_if(operand(r14F4).val);
                  exec_list *const f14F3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f14F3->then_instructions;

                     ir_variable *const r14F5 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r14F5, r1445, 0x01));

                     ir_variable *const r14F6 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r14F7 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r14F7);
                     /* IF CONDITION */
                     ir_expression *const r14F9 = equal(swizzle_x(r1435), body.constant(0u));
                     ir_if *f14F8 = new(mem_ctx) ir_if(operand(r14F9).val);
                     exec_list *const f14F8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14F8->then_instructions;

                        body.emit(assign(r14F6, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f14F8->else_instructions;

                        body.emit(assign(r14F7, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r14FB = bit_and(swizzle_x(r1435), body.constant(4294901760u));
                        ir_expression *const r14FC = equal(r14FB, body.constant(0u));
                        ir_if *f14FA = new(mem_ctx) ir_if(operand(r14FC).val);
                        exec_list *const f14FA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f14FA->then_instructions;

                           body.emit(assign(r14F7, body.constant(int(16)), 0x01));

                           body.emit(assign(r14F5, lshift(swizzle_x(r1435), body.constant(int(16))), 0x01));


                        body.instructions = f14FA_parent_instructions;
                        body.emit(f14FA);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r14FE = bit_and(r14F5, body.constant(4278190080u));
                        ir_expression *const r14FF = equal(r14FE, body.constant(0u));
                        ir_if *f14FD = new(mem_ctx) ir_if(operand(r14FF).val);
                        exec_list *const f14FD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f14FD->then_instructions;

                           body.emit(assign(r14F7, add(r14F7, body.constant(int(8))), 0x01));

                           body.emit(assign(r14F5, lshift(r14F5, body.constant(int(8))), 0x01));


                        body.instructions = f14FD_parent_instructions;
                        body.emit(f14FD);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1501 = bit_and(r14F5, body.constant(4026531840u));
                        ir_expression *const r1502 = equal(r1501, body.constant(0u));
                        ir_if *f1500 = new(mem_ctx) ir_if(operand(r1502).val);
                        exec_list *const f1500_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1500->then_instructions;

                           body.emit(assign(r14F7, add(r14F7, body.constant(int(4))), 0x01));

                           body.emit(assign(r14F5, lshift(r14F5, body.constant(int(4))), 0x01));


                        body.instructions = f1500_parent_instructions;
                        body.emit(f1500);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1504 = bit_and(r14F5, body.constant(3221225472u));
                        ir_expression *const r1505 = equal(r1504, body.constant(0u));
                        ir_if *f1503 = new(mem_ctx) ir_if(operand(r1505).val);
                        exec_list *const f1503_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1503->then_instructions;

                           body.emit(assign(r14F7, add(r14F7, body.constant(int(2))), 0x01));

                           body.emit(assign(r14F5, lshift(r14F5, body.constant(int(2))), 0x01));


                        body.instructions = f1503_parent_instructions;
                        body.emit(f1503);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1507 = bit_and(r14F5, body.constant(2147483648u));
                        ir_expression *const r1508 = equal(r1507, body.constant(0u));
                        ir_if *f1506 = new(mem_ctx) ir_if(operand(r1508).val);
                        exec_list *const f1506_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1506->then_instructions;

                           body.emit(assign(r14F7, add(r14F7, body.constant(int(1))), 0x01));


                        body.instructions = f1506_parent_instructions;
                        body.emit(f1506);

                        /* END IF */

                        body.emit(assign(r14F6, r14F7, 0x01));


                     body.instructions = f14F8_parent_instructions;
                     body.emit(f14F8);

                     /* END IF */

                     body.emit(assign(r14F2, add(r14F6, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r150A = less(r14F2, body.constant(int(0)));
                     ir_if *f1509 = new(mem_ctx) ir_if(operand(r150A).val);
                     exec_list *const f1509_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1509->then_instructions;

                        ir_expression *const r150B = neg(r14F2);
                        body.emit(assign(r14F0, rshift(swizzle_x(r1435), r150B), 0x01));

                        ir_expression *const r150C = bit_and(r14F2, body.constant(int(31)));
                        body.emit(assign(r14F1, lshift(swizzle_x(r1435), r150C), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1509->else_instructions;

                        body.emit(assign(r14F0, lshift(swizzle_x(r1435), r14F2), 0x01));

                        body.emit(assign(r14F1, body.constant(0u), 0x01));


                     body.instructions = f1509_parent_instructions;
                     body.emit(f1509);

                     /* END IF */

                     body.emit(assign(r14EF, sub(body.constant(int(-31)), r14F2), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f14F3->else_instructions;

                     ir_variable *const r150D = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r150D, r1446, 0x01));

                     ir_variable *const r150E = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r150F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r150F);
                     /* IF CONDITION */
                     ir_expression *const r1511 = equal(r1446, body.constant(0u));
                     ir_if *f1510 = new(mem_ctx) ir_if(operand(r1511).val);
                     exec_list *const f1510_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1510->then_instructions;

                        body.emit(assign(r150E, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1510->else_instructions;

                        body.emit(assign(r150F, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1513 = bit_and(r1446, body.constant(4294901760u));
                        ir_expression *const r1514 = equal(r1513, body.constant(0u));
                        ir_if *f1512 = new(mem_ctx) ir_if(operand(r1514).val);
                        exec_list *const f1512_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1512->then_instructions;

                           body.emit(assign(r150F, body.constant(int(16)), 0x01));

                           body.emit(assign(r150D, lshift(r1446, body.constant(int(16))), 0x01));


                        body.instructions = f1512_parent_instructions;
                        body.emit(f1512);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1516 = bit_and(r150D, body.constant(4278190080u));
                        ir_expression *const r1517 = equal(r1516, body.constant(0u));
                        ir_if *f1515 = new(mem_ctx) ir_if(operand(r1517).val);
                        exec_list *const f1515_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1515->then_instructions;

                           body.emit(assign(r150F, add(r150F, body.constant(int(8))), 0x01));

                           body.emit(assign(r150D, lshift(r150D, body.constant(int(8))), 0x01));


                        body.instructions = f1515_parent_instructions;
                        body.emit(f1515);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1519 = bit_and(r150D, body.constant(4026531840u));
                        ir_expression *const r151A = equal(r1519, body.constant(0u));
                        ir_if *f1518 = new(mem_ctx) ir_if(operand(r151A).val);
                        exec_list *const f1518_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1518->then_instructions;

                           body.emit(assign(r150F, add(r150F, body.constant(int(4))), 0x01));

                           body.emit(assign(r150D, lshift(r150D, body.constant(int(4))), 0x01));


                        body.instructions = f1518_parent_instructions;
                        body.emit(f1518);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r151C = bit_and(r150D, body.constant(3221225472u));
                        ir_expression *const r151D = equal(r151C, body.constant(0u));
                        ir_if *f151B = new(mem_ctx) ir_if(operand(r151D).val);
                        exec_list *const f151B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f151B->then_instructions;

                           body.emit(assign(r150F, add(r150F, body.constant(int(2))), 0x01));

                           body.emit(assign(r150D, lshift(r150D, body.constant(int(2))), 0x01));


                        body.instructions = f151B_parent_instructions;
                        body.emit(f151B);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r151F = bit_and(r150D, body.constant(2147483648u));
                        ir_expression *const r1520 = equal(r151F, body.constant(0u));
                        ir_if *f151E = new(mem_ctx) ir_if(operand(r1520).val);
                        exec_list *const f151E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f151E->then_instructions;

                           body.emit(assign(r150F, add(r150F, body.constant(int(1))), 0x01));


                        body.instructions = f151E_parent_instructions;
                        body.emit(f151E);

                        /* END IF */

                        body.emit(assign(r150E, r150F, 0x01));


                     body.instructions = f1510_parent_instructions;
                     body.emit(f1510);

                     /* END IF */

                     body.emit(assign(r14F2, add(r150E, body.constant(int(-11))), 0x01));

                     ir_variable *const r1521 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r1521, lshift(swizzle_x(r1435), r14F2), 0x01));

                     ir_variable *const r1522 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1524 = equal(r14F2, body.constant(int(0)));
                     ir_if *f1523 = new(mem_ctx) ir_if(operand(r1524).val);
                     exec_list *const f1523_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1523->then_instructions;

                        body.emit(assign(r1522, r1446, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1523->else_instructions;

                        ir_expression *const r1525 = lshift(r1446, r14F2);
                        ir_expression *const r1526 = neg(r14F2);
                        ir_expression *const r1527 = bit_and(r1526, body.constant(int(31)));
                        ir_expression *const r1528 = rshift(swizzle_x(r1435), r1527);
                        body.emit(assign(r1522, bit_or(r1525, r1528), 0x01));


                     body.instructions = f1523_parent_instructions;
                     body.emit(f1523);

                     /* END IF */

                     body.emit(assign(r14F0, r1522, 0x01));

                     body.emit(assign(r14F1, r1521, 0x01));

                     body.emit(assign(r14EF, sub(body.constant(int(1)), r14F2), 0x01));


                  body.instructions = f14F3_parent_instructions;
                  body.emit(f14F3);

                  /* END IF */

                  body.emit(assign(r1439, r14EF, 0x01));

                  body.emit(assign(r143B, r14F0, 0x01));

                  body.emit(assign(r143C, r14F1, 0x01));


               body.instructions = f14EB_parent_instructions;
               body.emit(f14EB);

               /* END IF */


            body.instructions = f14E9_parent_instructions;
            body.emit(f14E9);

            /* END IF */

            /* IF CONDITION */
            ir_if *f1529 = new(mem_ctx) ir_if(operand(r1436).val);
            exec_list *const f1529_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1529->then_instructions;

               ir_expression *const r152A = add(r143A, r1439);
               body.emit(assign(r143F, add(r152A, body.constant(int(-1024))), 0x01));

               body.emit(assign(r143D, bit_or(r143D, body.constant(1048576u)), 0x01));

               ir_variable *const r152B = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r152B, lshift(r143C, body.constant(int(12))), 0x01));

               ir_variable *const r152C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r152D = lshift(r143B, body.constant(int(12)));
               ir_expression *const r152E = rshift(r143C, body.constant(int(20)));
               body.emit(assign(r152C, bit_or(r152D, r152E), 0x01));

               body.emit(assign(r143B, r152C, 0x01));

               body.emit(assign(r143C, r152B, 0x01));

               ir_variable *const r152F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r152F);
               ir_variable *const r1530 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r1530);
               ir_variable *const r1531 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1531);
               ir_variable *const r1532 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1532, bit_and(r143E, body.constant(65535u)), 0x01));

               ir_variable *const r1533 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1533, rshift(r143E, body.constant(int(16))), 0x01));

               ir_variable *const r1534 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1534, bit_and(r152B, body.constant(65535u)), 0x01));

               ir_variable *const r1535 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1535, rshift(r152B, body.constant(int(16))), 0x01));

               ir_variable *const r1536 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1536, mul(r1533, r1534), 0x01));

               ir_expression *const r1537 = mul(r1532, r1535);
               body.emit(assign(r1530, add(r1537, r1536), 0x01));

               ir_expression *const r1538 = mul(r1533, r1535);
               ir_expression *const r1539 = less(r1530, r1536);
               ir_expression *const r153A = expr(ir_unop_b2i, r1539);
               ir_expression *const r153B = expr(ir_unop_i2u, r153A);
               ir_expression *const r153C = lshift(r153B, body.constant(int(16)));
               ir_expression *const r153D = rshift(r1530, body.constant(int(16)));
               ir_expression *const r153E = add(r153C, r153D);
               body.emit(assign(r152F, add(r1538, r153E), 0x01));

               body.emit(assign(r1530, lshift(r1530, body.constant(int(16))), 0x01));

               ir_expression *const r153F = mul(r1532, r1534);
               body.emit(assign(r1531, add(r153F, r1530), 0x01));

               ir_expression *const r1540 = less(r1531, r1530);
               ir_expression *const r1541 = expr(ir_unop_b2i, r1540);
               ir_expression *const r1542 = expr(ir_unop_i2u, r1541);
               body.emit(assign(r152F, add(r152F, r1542), 0x01));

               ir_variable *const r1543 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1543);
               ir_variable *const r1544 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r1544);
               ir_variable *const r1545 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1545);
               ir_variable *const r1546 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1546, bit_and(r143E, body.constant(65535u)), 0x01));

               ir_variable *const r1547 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1547, rshift(r143E, body.constant(int(16))), 0x01));

               ir_variable *const r1548 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1548, bit_and(r152C, body.constant(65535u)), 0x01));

               ir_variable *const r1549 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1549, rshift(r152C, body.constant(int(16))), 0x01));

               ir_variable *const r154A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r154A, mul(r1547, r1548), 0x01));

               ir_expression *const r154B = mul(r1546, r1549);
               body.emit(assign(r1544, add(r154B, r154A), 0x01));

               ir_expression *const r154C = mul(r1547, r1549);
               ir_expression *const r154D = less(r1544, r154A);
               ir_expression *const r154E = expr(ir_unop_b2i, r154D);
               ir_expression *const r154F = expr(ir_unop_i2u, r154E);
               ir_expression *const r1550 = lshift(r154F, body.constant(int(16)));
               ir_expression *const r1551 = rshift(r1544, body.constant(int(16)));
               ir_expression *const r1552 = add(r1550, r1551);
               body.emit(assign(r1543, add(r154C, r1552), 0x01));

               body.emit(assign(r1544, lshift(r1544, body.constant(int(16))), 0x01));

               ir_expression *const r1553 = mul(r1546, r1548);
               body.emit(assign(r1545, add(r1553, r1544), 0x01));

               ir_expression *const r1554 = less(r1545, r1544);
               ir_expression *const r1555 = expr(ir_unop_b2i, r1554);
               ir_expression *const r1556 = expr(ir_unop_i2u, r1555);
               body.emit(assign(r1543, add(r1543, r1556), 0x01));

               ir_variable *const r1557 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1557, add(r1545, r152F), 0x01));

               ir_variable *const r1558 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1558);
               ir_variable *const r1559 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r1559);
               ir_variable *const r155A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r155A);
               ir_variable *const r155B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r155B, bit_and(r143D, body.constant(65535u)), 0x01));

               ir_variable *const r155C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r155C, rshift(r143D, body.constant(int(16))), 0x01));

               ir_variable *const r155D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r155D, bit_and(r152C, body.constant(65535u)), 0x01));

               ir_variable *const r155E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r155E, rshift(r152C, body.constant(int(16))), 0x01));

               ir_variable *const r155F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r155F, mul(r155C, r155D), 0x01));

               ir_expression *const r1560 = mul(r155B, r155E);
               body.emit(assign(r1559, add(r1560, r155F), 0x01));

               ir_expression *const r1561 = mul(r155C, r155E);
               ir_expression *const r1562 = less(r1559, r155F);
               ir_expression *const r1563 = expr(ir_unop_b2i, r1562);
               ir_expression *const r1564 = expr(ir_unop_i2u, r1563);
               ir_expression *const r1565 = lshift(r1564, body.constant(int(16)));
               ir_expression *const r1566 = rshift(r1559, body.constant(int(16)));
               ir_expression *const r1567 = add(r1565, r1566);
               body.emit(assign(r1558, add(r1561, r1567), 0x01));

               body.emit(assign(r1559, lshift(r1559, body.constant(int(16))), 0x01));

               ir_expression *const r1568 = mul(r155B, r155D);
               body.emit(assign(r155A, add(r1568, r1559), 0x01));

               ir_expression *const r1569 = less(r155A, r1559);
               ir_expression *const r156A = expr(ir_unop_b2i, r1569);
               ir_expression *const r156B = expr(ir_unop_i2u, r156A);
               body.emit(assign(r1558, add(r1558, r156B), 0x01));

               ir_variable *const r156C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r156D = less(r1557, r1545);
               ir_expression *const r156E = expr(ir_unop_b2i, r156D);
               ir_expression *const r156F = expr(ir_unop_i2u, r156E);
               ir_expression *const r1570 = add(r1543, r156F);
               body.emit(assign(r156C, add(r155A, r1570), 0x01));

               ir_variable *const r1571 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1571);
               ir_variable *const r1572 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r1572);
               ir_variable *const r1573 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1573);
               ir_variable *const r1574 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1574, bit_and(r143D, body.constant(65535u)), 0x01));

               ir_variable *const r1575 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1575, rshift(r143D, body.constant(int(16))), 0x01));

               ir_variable *const r1576 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1576, bit_and(r152B, body.constant(65535u)), 0x01));

               ir_variable *const r1577 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1577, rshift(r152B, body.constant(int(16))), 0x01));

               ir_variable *const r1578 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1578, mul(r1575, r1576), 0x01));

               ir_expression *const r1579 = mul(r1574, r1577);
               body.emit(assign(r1572, add(r1579, r1578), 0x01));

               ir_expression *const r157A = mul(r1575, r1577);
               ir_expression *const r157B = less(r1572, r1578);
               ir_expression *const r157C = expr(ir_unop_b2i, r157B);
               ir_expression *const r157D = expr(ir_unop_i2u, r157C);
               ir_expression *const r157E = lshift(r157D, body.constant(int(16)));
               ir_expression *const r157F = rshift(r1572, body.constant(int(16)));
               ir_expression *const r1580 = add(r157E, r157F);
               body.emit(assign(r1571, add(r157A, r1580), 0x01));

               body.emit(assign(r1572, lshift(r1572, body.constant(int(16))), 0x01));

               ir_expression *const r1581 = mul(r1574, r1576);
               body.emit(assign(r1573, add(r1581, r1572), 0x01));

               ir_expression *const r1582 = less(r1573, r1572);
               ir_expression *const r1583 = expr(ir_unop_b2i, r1582);
               ir_expression *const r1584 = expr(ir_unop_i2u, r1583);
               body.emit(assign(r1571, add(r1571, r1584), 0x01));

               ir_variable *const r1585 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1585, add(r1573, r1557), 0x01));

               ir_variable *const r1586 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r1587 = less(r1585, r1573);
               ir_expression *const r1588 = expr(ir_unop_b2i, r1587);
               ir_expression *const r1589 = expr(ir_unop_i2u, r1588);
               ir_expression *const r158A = add(r1571, r1589);
               body.emit(assign(r1586, add(r156C, r158A), 0x01));

               ir_variable *const r158B = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r158C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r158C, add(r1586, r143E), 0x01));

               ir_expression *const r158D = less(r156C, r155A);
               ir_expression *const r158E = expr(ir_unop_b2i, r158D);
               ir_expression *const r158F = expr(ir_unop_i2u, r158E);
               ir_expression *const r1590 = add(r1558, r158F);
               ir_expression *const r1591 = less(r1586, r156C);
               ir_expression *const r1592 = expr(ir_unop_b2i, r1591);
               ir_expression *const r1593 = expr(ir_unop_i2u, r1592);
               ir_expression *const r1594 = add(r1590, r1593);
               ir_expression *const r1595 = add(r1594, r143D);
               ir_expression *const r1596 = less(r158C, r1586);
               ir_expression *const r1597 = expr(ir_unop_b2i, r1596);
               ir_expression *const r1598 = expr(ir_unop_i2u, r1597);
               body.emit(assign(r158B, add(r1595, r1598), 0x01));

               body.emit(assign(r1442, r158B, 0x01));

               body.emit(assign(r1441, r158C, 0x01));

               ir_expression *const r1599 = nequal(r1531, body.constant(0u));
               ir_expression *const r159A = expr(ir_unop_b2i, r1599);
               ir_expression *const r159B = expr(ir_unop_i2u, r159A);
               body.emit(assign(r1440, bit_or(r1585, r159B), 0x01));

               /* IF CONDITION */
               ir_expression *const r159D = lequal(body.constant(2097152u), r158B);
               ir_if *f159C = new(mem_ctx) ir_if(operand(r159D).val);
               exec_list *const f159C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f159C->then_instructions;

                  ir_variable *const r159E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r159E);
                  body.emit(assign(r159E, lshift(r158C, body.constant(int(31))), 0x01));

                  ir_expression *const r159F = nequal(r1440, body.constant(0u));
                  ir_expression *const r15A0 = expr(ir_unop_b2i, r159F);
                  ir_expression *const r15A1 = expr(ir_unop_i2u, r15A0);
                  body.emit(assign(r159E, bit_or(r159E, r15A1), 0x01));

                  body.emit(assign(r1442, rshift(r158B, body.constant(int(1))), 0x01));

                  ir_expression *const r15A2 = lshift(r158B, body.constant(int(31)));
                  ir_expression *const r15A3 = rshift(r158C, body.constant(int(1)));
                  body.emit(assign(r1441, bit_or(r15A2, r15A3), 0x01));

                  body.emit(assign(r1440, r159E, 0x01));

                  body.emit(assign(r143F, add(r143F, body.constant(int(1))), 0x01));


               body.instructions = f159C_parent_instructions;
               body.emit(f159C);

               /* END IF */

               ir_variable *const r15A4 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r15A4, r143F, 0x01));

               ir_variable *const r15A5 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r15A5, r1442, 0x01));

               ir_variable *const r15A6 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r15A6, r1441, 0x01));

               ir_variable *const r15A7 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r15A7, r1440, 0x01));

               ir_variable *const r15A8 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r15A8, body.constant(true), 0x01));

               ir_variable *const r15A9 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r15AA = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r15AA);
               ir_expression *const r15AB = expr(ir_unop_u2i, r1440);
               body.emit(assign(r15AA, less(r15AB, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r15AD = lequal(body.constant(int(2045)), r143F);
               ir_if *f15AC = new(mem_ctx) ir_if(operand(r15AD).val);
               exec_list *const f15AC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f15AC->then_instructions;

                  ir_variable *const r15AE = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r15B0 = less(body.constant(int(2045)), r143F);
                  ir_if *f15AF = new(mem_ctx) ir_if(operand(r15B0).val);
                  exec_list *const f15AF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f15AF->then_instructions;

                     body.emit(assign(r15AE, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f15AF->else_instructions;

                     ir_variable *const r15B1 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r15B3 = equal(r143F, body.constant(int(2045)));
                     ir_if *f15B2 = new(mem_ctx) ir_if(operand(r15B3).val);
                     exec_list *const f15B2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f15B2->then_instructions;

                        ir_expression *const r15B4 = equal(body.constant(2097151u), r1442);
                        ir_expression *const r15B5 = equal(body.constant(4294967295u), r1441);
                        body.emit(assign(r15B1, logic_and(r15B4, r15B5), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f15B2->else_instructions;

                        body.emit(assign(r15B1, body.constant(false), 0x01));


                     body.instructions = f15B2_parent_instructions;
                     body.emit(f15B2);

                     /* END IF */

                     body.emit(assign(r15AE, logic_and(r15B1, r15AA), 0x01));


                  body.instructions = f15AF_parent_instructions;
                  body.emit(f15AF);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f15B6 = new(mem_ctx) ir_if(operand(r15AE).val);
                  exec_list *const f15B6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f15B6->then_instructions;

                     ir_variable *const r15B7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r15B7);
                     ir_expression *const r15B8 = lshift(r1438, body.constant(int(31)));
                     body.emit(assign(r15B7, add(r15B8, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r15B7, body.constant(0u), 0x01));

                     body.emit(assign(r15A9, r15B7, 0x03));

                     body.emit(assign(r15A8, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f15B6->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r15BA = less(r143F, body.constant(int(0)));
                     ir_if *f15B9 = new(mem_ctx) ir_if(operand(r15BA).val);
                     exec_list *const f15B9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f15B9->then_instructions;

                        ir_variable *const r15BB = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r15BB, r1440, 0x01));

                        ir_variable *const r15BC = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r15BC, neg(r143F), 0x01));

                        ir_variable *const r15BD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r15BD);
                        ir_variable *const r15BE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r15BE);
                        ir_variable *const r15BF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r15BF);
                        ir_variable *const r15C0 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r15C1 = neg(r15BC);
                        body.emit(assign(r15C0, bit_and(r15C1, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r15C3 = equal(r15BC, body.constant(int(0)));
                        ir_if *f15C2 = new(mem_ctx) ir_if(operand(r15C3).val);
                        exec_list *const f15C2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f15C2->then_instructions;

                           body.emit(assign(r15BD, r1440, 0x01));

                           body.emit(assign(r15BE, r1441, 0x01));

                           body.emit(assign(r15BF, r1442, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f15C2->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r15C5 = less(r15BC, body.constant(int(32)));
                           ir_if *f15C4 = new(mem_ctx) ir_if(operand(r15C5).val);
                           exec_list *const f15C4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f15C4->then_instructions;

                              body.emit(assign(r15BD, lshift(r1441, r15C0), 0x01));

                              ir_expression *const r15C6 = lshift(r1442, r15C0);
                              ir_expression *const r15C7 = rshift(r1441, r15BC);
                              body.emit(assign(r15BE, bit_or(r15C6, r15C7), 0x01));

                              body.emit(assign(r15BF, rshift(r1442, r15BC), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f15C4->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r15C9 = equal(r15BC, body.constant(int(32)));
                              ir_if *f15C8 = new(mem_ctx) ir_if(operand(r15C9).val);
                              exec_list *const f15C8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f15C8->then_instructions;

                                 body.emit(assign(r15BD, r1441, 0x01));

                                 body.emit(assign(r15BE, r1442, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f15C8->else_instructions;

                                 body.emit(assign(r15BB, bit_or(r1440, r1441), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r15CB = less(r15BC, body.constant(int(64)));
                                 ir_if *f15CA = new(mem_ctx) ir_if(operand(r15CB).val);
                                 exec_list *const f15CA_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f15CA->then_instructions;

                                    body.emit(assign(r15BD, lshift(r1442, r15C0), 0x01));

                                    ir_expression *const r15CC = bit_and(r15BC, body.constant(int(31)));
                                    body.emit(assign(r15BE, rshift(r1442, r15CC), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f15CA->else_instructions;

                                    ir_variable *const r15CD = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r15CF = equal(r15BC, body.constant(int(64)));
                                    ir_if *f15CE = new(mem_ctx) ir_if(operand(r15CF).val);
                                    exec_list *const f15CE_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f15CE->then_instructions;

                                       body.emit(assign(r15CD, r1442, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f15CE->else_instructions;

                                       ir_expression *const r15D0 = nequal(r1442, body.constant(0u));
                                       ir_expression *const r15D1 = expr(ir_unop_b2i, r15D0);
                                       body.emit(assign(r15CD, expr(ir_unop_i2u, r15D1), 0x01));


                                    body.instructions = f15CE_parent_instructions;
                                    body.emit(f15CE);

                                    /* END IF */

                                    body.emit(assign(r15BD, r15CD, 0x01));

                                    body.emit(assign(r15BE, body.constant(0u), 0x01));


                                 body.instructions = f15CA_parent_instructions;
                                 body.emit(f15CA);

                                 /* END IF */


                              body.instructions = f15C8_parent_instructions;
                              body.emit(f15C8);

                              /* END IF */

                              body.emit(assign(r15BF, body.constant(0u), 0x01));


                           body.instructions = f15C4_parent_instructions;
                           body.emit(f15C4);

                           /* END IF */

                           ir_expression *const r15D2 = nequal(r15BB, body.constant(0u));
                           ir_expression *const r15D3 = expr(ir_unop_b2i, r15D2);
                           ir_expression *const r15D4 = expr(ir_unop_i2u, r15D3);
                           body.emit(assign(r15BD, bit_or(r15BD, r15D4), 0x01));


                        body.instructions = f15C2_parent_instructions;
                        body.emit(f15C2);

                        /* END IF */

                        body.emit(assign(r15A5, r15BF, 0x01));

                        body.emit(assign(r15A6, r15BE, 0x01));

                        body.emit(assign(r15A7, r15BD, 0x01));

                        body.emit(assign(r15A4, body.constant(int(0)), 0x01));

                        body.emit(assign(r15AA, less(r15BD, body.constant(0u)), 0x01));


                     body.instructions = f15B9_parent_instructions;
                     body.emit(f15B9);

                     /* END IF */


                  body.instructions = f15B6_parent_instructions;
                  body.emit(f15B6);

                  /* END IF */


               body.instructions = f15AC_parent_instructions;
               body.emit(f15AC);

               /* END IF */

               /* IF CONDITION */
               ir_if *f15D5 = new(mem_ctx) ir_if(operand(r15A8).val);
               exec_list *const f15D5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f15D5->then_instructions;

                  /* IF CONDITION */
                  ir_if *f15D6 = new(mem_ctx) ir_if(operand(r15AA).val);
                  exec_list *const f15D6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f15D6->then_instructions;

                     ir_variable *const r15D7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r15D7, add(r15A6, body.constant(1u)), 0x01));

                     ir_expression *const r15D8 = less(r15D7, r15A6);
                     ir_expression *const r15D9 = expr(ir_unop_b2i, r15D8);
                     ir_expression *const r15DA = expr(ir_unop_i2u, r15D9);
                     body.emit(assign(r15A5, add(r15A5, r15DA), 0x01));

                     ir_expression *const r15DB = equal(r15A7, body.constant(0u));
                     ir_expression *const r15DC = expr(ir_unop_b2i, r15DB);
                     ir_expression *const r15DD = expr(ir_unop_i2u, r15DC);
                     ir_expression *const r15DE = add(r15A7, r15DD);
                     ir_expression *const r15DF = bit_and(r15DE, body.constant(1u));
                     ir_expression *const r15E0 = expr(ir_unop_bit_not, r15DF);
                     body.emit(assign(r15A6, bit_and(r15D7, r15E0), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f15D6->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r15E2 = bit_or(r15A5, r15A6);
                     ir_expression *const r15E3 = equal(r15E2, body.constant(0u));
                     ir_if *f15E1 = new(mem_ctx) ir_if(operand(r15E3).val);
                     exec_list *const f15E1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f15E1->then_instructions;

                        body.emit(assign(r15A4, body.constant(int(0)), 0x01));


                     body.instructions = f15E1_parent_instructions;
                     body.emit(f15E1);

                     /* END IF */


                  body.instructions = f15D6_parent_instructions;
                  body.emit(f15D6);

                  /* END IF */

                  ir_variable *const r15E4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r15E4);
                  ir_expression *const r15E5 = lshift(r1438, body.constant(int(31)));
                  ir_expression *const r15E6 = expr(ir_unop_i2u, r15A4);
                  ir_expression *const r15E7 = lshift(r15E6, body.constant(int(20)));
                  ir_expression *const r15E8 = add(r15E5, r15E7);
                  body.emit(assign(r15E4, add(r15E8, r15A5), 0x02));

                  body.emit(assign(r15E4, r15A6, 0x01));

                  body.emit(assign(r15A9, r15E4, 0x03));

                  body.emit(assign(r15A8, body.constant(false), 0x01));


               body.instructions = f15D5_parent_instructions;
               body.emit(f15D5);

               /* END IF */

               body.emit(assign(r1437, r15A9, 0x03));

               body.emit(assign(r1436, body.constant(false), 0x01));


            body.instructions = f1529_parent_instructions;
            body.emit(f1529);

            /* END IF */


         body.instructions = f14E8_parent_instructions;
         body.emit(f14E8);

         /* END IF */


      body.instructions = f147E_parent_instructions;
      body.emit(f147E);

      /* END IF */


   body.instructions = f144F_parent_instructions;
   body.emit(f144F);

   /* END IF */

   body.emit(ret(r1437));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
add96(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r15E9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r15E9);
   ir_variable *const r15EA = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r15EA);
   ir_variable *const r15EB = new(mem_ctx) ir_variable(glsl_type::uint_type, "a2", ir_var_function_in);
   sig_parameters.push_tail(r15EB);
   ir_variable *const r15EC = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r15EC);
   ir_variable *const r15ED = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r15ED);
   ir_variable *const r15EE = new(mem_ctx) ir_variable(glsl_type::uint_type, "b2", ir_var_function_in);
   sig_parameters.push_tail(r15EE);
   ir_variable *const r15EF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r15EF);
   ir_variable *const r15F0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r15F0);
   ir_variable *const r15F1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r15F1);
   ir_variable *const r15F2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r15F2);
   ir_variable *const r15F3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r15F3);
   ir_variable *const r15F4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r15F4, add(r15EB, r15EE), 0x01));

   ir_variable *const r15F5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   ir_expression *const r15F6 = less(r15F4, r15EB);
   ir_expression *const r15F7 = expr(ir_unop_b2i, r15F6);
   body.emit(assign(r15F5, expr(ir_unop_i2u, r15F7), 0x01));

   ir_variable *const r15F8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r15F8, add(r15EA, r15ED), 0x01));

   body.emit(assign(r15F3, add(r15F8, r15F5), 0x01));

   ir_expression *const r15F9 = add(r15E9, r15EC);
   ir_expression *const r15FA = less(r15F3, r15F5);
   ir_expression *const r15FB = expr(ir_unop_b2i, r15FA);
   ir_expression *const r15FC = expr(ir_unop_i2u, r15FB);
   body.emit(assign(r15F2, add(r15F9, r15FC), 0x01));

   ir_expression *const r15FD = less(r15F8, r15EA);
   ir_expression *const r15FE = expr(ir_unop_b2i, r15FD);
   ir_expression *const r15FF = expr(ir_unop_i2u, r15FE);
   body.emit(assign(r15F2, add(r15F2, r15FF), 0x01));

   body.emit(assign(r15F1, r15F4, 0x01));

   body.emit(assign(r15F0, r15F3, 0x01));

   body.emit(assign(r15EF, r15F2, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
sub96(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1600 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r1600);
   ir_variable *const r1601 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r1601);
   ir_variable *const r1602 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a2", ir_var_function_in);
   sig_parameters.push_tail(r1602);
   ir_variable *const r1603 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r1603);
   ir_variable *const r1604 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r1604);
   ir_variable *const r1605 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b2", ir_var_function_in);
   sig_parameters.push_tail(r1605);
   ir_variable *const r1606 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1606);
   ir_variable *const r1607 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1607);
   ir_variable *const r1608 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1608);
   ir_variable *const r1609 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r1609);
   ir_variable *const r160A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   ir_expression *const r160B = less(r1602, r1605);
   ir_expression *const r160C = expr(ir_unop_b2i, r160B);
   body.emit(assign(r160A, expr(ir_unop_i2u, r160C), 0x01));

   ir_variable *const r160D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r160D, sub(r1601, r1604), 0x01));

   ir_expression *const r160E = sub(r1600, r1603);
   ir_expression *const r160F = less(r160D, r160A);
   ir_expression *const r1610 = expr(ir_unop_b2i, r160F);
   ir_expression *const r1611 = expr(ir_unop_i2u, r1610);
   body.emit(assign(r1609, sub(r160E, r1611), 0x01));

   ir_expression *const r1612 = less(r1601, r1604);
   ir_expression *const r1613 = expr(ir_unop_b2i, r1612);
   ir_expression *const r1614 = expr(ir_unop_i2u, r1613);
   body.emit(assign(r1609, sub(r1609, r1614), 0x01));

   body.emit(assign(r1608, sub(r1602, r1605), 0x01));

   body.emit(assign(r1607, sub(r160D, r160A), 0x01));

   body.emit(assign(r1606, r1609, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift64Right(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1615 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r1615);
   ir_variable *const r1616 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r1616);
   ir_variable *const r1617 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r1617);
   ir_variable *const r1618 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1618);
   ir_variable *const r1619 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1619);
   ir_variable *const r161A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r161A);
   ir_variable *const r161B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r161B);
   ir_variable *const r161C = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r161D = neg(r1617);
   body.emit(assign(r161C, bit_and(r161D, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r161F = equal(r1617, body.constant(int(0)));
   ir_if *f161E = new(mem_ctx) ir_if(operand(r161F).val);
   exec_list *const f161E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f161E->then_instructions;

      body.emit(assign(r161A, r1616, 0x01));

      body.emit(assign(r161B, r1615, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f161E->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1621 = less(r1617, body.constant(int(32)));
      ir_if *f1620 = new(mem_ctx) ir_if(operand(r1621).val);
      exec_list *const f1620_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1620->then_instructions;

         ir_expression *const r1622 = lshift(r1615, r161C);
         ir_expression *const r1623 = rshift(r1616, r1617);
         body.emit(assign(r161A, bit_or(r1622, r1623), 0x01));

         body.emit(assign(r161B, rshift(r1615, r1617), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1620->else_instructions;

         ir_variable *const r1624 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1626 = less(r1617, body.constant(int(64)));
         ir_if *f1625 = new(mem_ctx) ir_if(operand(r1626).val);
         exec_list *const f1625_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1625->then_instructions;

            ir_expression *const r1627 = bit_and(r1617, body.constant(int(31)));
            body.emit(assign(r1624, rshift(r1615, r1627), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1625->else_instructions;

            body.emit(assign(r1624, body.constant(0u), 0x01));


         body.instructions = f1625_parent_instructions;
         body.emit(f1625);

         /* END IF */

         body.emit(assign(r161A, r1624, 0x01));

         body.emit(assign(r161B, body.constant(0u), 0x01));


      body.instructions = f1620_parent_instructions;
      body.emit(f1620);

      /* END IF */


   body.instructions = f161E_parent_instructions;
   body.emit(f161E);

   /* END IF */

   body.emit(assign(r1619, r161A, 0x01));

   body.emit(assign(r1618, r161B, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
estimateDiv64To32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1628 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r1628);
   ir_variable *const r1629 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r1629);
   ir_variable *const r162A = new(mem_ctx) ir_variable(glsl_type::uint_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r162A);
   ir_variable *const r162B = body.make_temp(glsl_type::uint_type, "return_value");
   ir_variable *const r162C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
   body.emit(r162C);
   ir_variable *const r162D = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
   body.emit(r162D);
   ir_variable *const r162E = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
   body.emit(r162E);
   ir_variable *const r162F = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
   body.emit(r162F);
   body.emit(assign(r162E, body.constant(0u), 0x01));

   body.emit(assign(r162D, body.constant(0u), 0x01));

   /* IF CONDITION */
   ir_expression *const r1631 = lequal(r162A, r1628);
   ir_if *f1630 = new(mem_ctx) ir_if(operand(r1631).val);
   exec_list *const f1630_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1630->then_instructions;

      body.emit(assign(r162B, body.constant(4294967295u), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1630->else_instructions;

      body.emit(assign(r162F, rshift(r162A, body.constant(int(16))), 0x01));

      ir_variable *const r1632 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r1634 = lshift(r162F, body.constant(int(16)));
      ir_expression *const r1635 = lequal(r1634, r1628);
      ir_if *f1633 = new(mem_ctx) ir_if(operand(r1635).val);
      exec_list *const f1633_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1633->then_instructions;

         body.emit(assign(r1632, body.constant(4294901760u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1633->else_instructions;

         ir_expression *const r1636 = expr(ir_binop_div, r1628, r162F);
         body.emit(assign(r1632, lshift(r1636, body.constant(int(16))), 0x01));


      body.instructions = f1633_parent_instructions;
      body.emit(f1633);

      /* END IF */

      body.emit(assign(r162C, r1632, 0x01));

      ir_variable *const r1637 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r1637);
      ir_variable *const r1638 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
      body.emit(r1638);
      ir_variable *const r1639 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r1639);
      ir_variable *const r163A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r163A, bit_and(r162A, body.constant(65535u)), 0x01));

      ir_variable *const r163B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r163B, rshift(r162A, body.constant(int(16))), 0x01));

      ir_variable *const r163C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r163C, bit_and(r1632, body.constant(65535u)), 0x01));

      ir_variable *const r163D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r163D, rshift(r1632, body.constant(int(16))), 0x01));

      ir_variable *const r163E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r163E, mul(r163B, r163C), 0x01));

      ir_expression *const r163F = mul(r163A, r163D);
      body.emit(assign(r1638, add(r163F, r163E), 0x01));

      ir_expression *const r1640 = mul(r163B, r163D);
      ir_expression *const r1641 = less(r1638, r163E);
      ir_expression *const r1642 = expr(ir_unop_b2i, r1641);
      ir_expression *const r1643 = expr(ir_unop_i2u, r1642);
      ir_expression *const r1644 = lshift(r1643, body.constant(int(16)));
      ir_expression *const r1645 = rshift(r1638, body.constant(int(16)));
      ir_expression *const r1646 = add(r1644, r1645);
      body.emit(assign(r1637, add(r1640, r1646), 0x01));

      body.emit(assign(r1638, lshift(r1638, body.constant(int(16))), 0x01));

      ir_expression *const r1647 = mul(r163A, r163C);
      body.emit(assign(r1639, add(r1647, r1638), 0x01));

      ir_expression *const r1648 = less(r1639, r1638);
      ir_expression *const r1649 = expr(ir_unop_b2i, r1648);
      ir_expression *const r164A = expr(ir_unop_i2u, r1649);
      body.emit(assign(r1637, add(r1637, r164A), 0x01));

      ir_expression *const r164B = sub(r1628, r1637);
      ir_expression *const r164C = less(r1629, r1639);
      ir_expression *const r164D = expr(ir_unop_b2i, r164C);
      ir_expression *const r164E = expr(ir_unop_i2u, r164D);
      body.emit(assign(r162E, sub(r164B, r164E), 0x01));

      body.emit(assign(r162D, sub(r1629, r1639), 0x01));

      /* LOOP BEGIN */
      ir_loop *f164F = new(mem_ctx) ir_loop();
      exec_list *const f164F_parent_instructions = body.instructions;

         body.instructions = &f164F->body_instructions;

         /* IF CONDITION */
         ir_expression *const r1651 = expr(ir_unop_u2i, r162E);
         ir_expression *const r1652 = gequal(r1651, body.constant(int(0)));
         ir_if *f1650 = new(mem_ctx) ir_if(operand(r1652).val);
         exec_list *const f1650_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1650->then_instructions;

            body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


         body.instructions = f1650_parent_instructions;
         body.emit(f1650);

         /* END IF */

         body.emit(assign(r162C, add(r162C, body.constant(4294901760u)), 0x01));

         ir_variable *const r1653 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         ir_expression *const r1654 = lshift(r162A, body.constant(int(16)));
         body.emit(assign(r1653, add(r162D, r1654), 0x01));

         ir_expression *const r1655 = add(r162E, r162F);
         ir_expression *const r1656 = less(r1653, r162D);
         ir_expression *const r1657 = expr(ir_unop_b2i, r1656);
         ir_expression *const r1658 = expr(ir_unop_i2u, r1657);
         body.emit(assign(r162E, add(r1655, r1658), 0x01));

         body.emit(assign(r162D, r1653, 0x01));

      /* LOOP END */

      body.instructions = f164F_parent_instructions;
      body.emit(f164F);

      ir_expression *const r1659 = lshift(r162E, body.constant(int(16)));
      ir_expression *const r165A = rshift(r162D, body.constant(int(16)));
      body.emit(assign(r162E, bit_or(r1659, r165A), 0x01));

      ir_variable *const r165B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r165D = lshift(r162F, body.constant(int(16)));
      ir_expression *const r165E = lequal(r165D, r162E);
      ir_if *f165C = new(mem_ctx) ir_if(operand(r165E).val);
      exec_list *const f165C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f165C->then_instructions;

         body.emit(assign(r165B, body.constant(65535u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f165C->else_instructions;

         body.emit(assign(r165B, expr(ir_binop_div, r162E, r162F), 0x01));


      body.instructions = f165C_parent_instructions;
      body.emit(f165C);

      /* END IF */

      body.emit(assign(r162C, bit_or(r162C, r165B), 0x01));

      body.emit(assign(r162B, r162C, 0x01));


   body.instructions = f1630_parent_instructions;
   body.emit(f1630);

   /* END IF */

   body.emit(ret(r162B));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
mul64By32To96(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r165F = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r165F);
   ir_variable *const r1660 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r1660);
   ir_variable *const r1661 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r1661);
   ir_variable *const r1662 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1662);
   ir_variable *const r1663 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1663);
   ir_variable *const r1664 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1664);
   ir_variable *const r1665 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r1665);
   ir_variable *const r1666 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r1666);
   ir_variable *const r1667 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r1667);
   ir_variable *const r1668 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1668, bit_and(r1660, body.constant(65535u)), 0x01));

   ir_variable *const r1669 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1669, rshift(r1660, body.constant(int(16))), 0x01));

   ir_variable *const r166A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r166A, bit_and(r1661, body.constant(65535u)), 0x01));

   ir_variable *const r166B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r166B, rshift(r1661, body.constant(int(16))), 0x01));

   ir_variable *const r166C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r166C, mul(r1669, r166A), 0x01));

   ir_expression *const r166D = mul(r1668, r166B);
   body.emit(assign(r1666, add(r166D, r166C), 0x01));

   ir_expression *const r166E = mul(r1669, r166B);
   ir_expression *const r166F = less(r1666, r166C);
   ir_expression *const r1670 = expr(ir_unop_b2i, r166F);
   ir_expression *const r1671 = expr(ir_unop_i2u, r1670);
   ir_expression *const r1672 = lshift(r1671, body.constant(int(16)));
   ir_expression *const r1673 = rshift(r1666, body.constant(int(16)));
   ir_expression *const r1674 = add(r1672, r1673);
   body.emit(assign(r1665, add(r166E, r1674), 0x01));

   body.emit(assign(r1666, lshift(r1666, body.constant(int(16))), 0x01));

   ir_expression *const r1675 = mul(r1668, r166A);
   body.emit(assign(r1667, add(r1675, r1666), 0x01));

   ir_expression *const r1676 = less(r1667, r1666);
   ir_expression *const r1677 = expr(ir_unop_b2i, r1676);
   ir_expression *const r1678 = expr(ir_unop_i2u, r1677);
   body.emit(assign(r1665, add(r1665, r1678), 0x01));

   ir_variable *const r1679 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r1679);
   ir_variable *const r167A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r167A);
   ir_variable *const r167B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r167B);
   ir_variable *const r167C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r167C, bit_and(r165F, body.constant(65535u)), 0x01));

   ir_variable *const r167D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r167D, rshift(r165F, body.constant(int(16))), 0x01));

   ir_variable *const r167E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r167E, bit_and(r1661, body.constant(65535u)), 0x01));

   ir_variable *const r167F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r167F, rshift(r1661, body.constant(int(16))), 0x01));

   ir_variable *const r1680 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1680, mul(r167D, r167E), 0x01));

   ir_expression *const r1681 = mul(r167C, r167F);
   body.emit(assign(r167A, add(r1681, r1680), 0x01));

   ir_expression *const r1682 = mul(r167D, r167F);
   ir_expression *const r1683 = less(r167A, r1680);
   ir_expression *const r1684 = expr(ir_unop_b2i, r1683);
   ir_expression *const r1685 = expr(ir_unop_i2u, r1684);
   ir_expression *const r1686 = lshift(r1685, body.constant(int(16)));
   ir_expression *const r1687 = rshift(r167A, body.constant(int(16)));
   ir_expression *const r1688 = add(r1686, r1687);
   body.emit(assign(r1679, add(r1682, r1688), 0x01));

   body.emit(assign(r167A, lshift(r167A, body.constant(int(16))), 0x01));

   ir_expression *const r1689 = mul(r167C, r167E);
   body.emit(assign(r167B, add(r1689, r167A), 0x01));

   ir_expression *const r168A = less(r167B, r167A);
   ir_expression *const r168B = expr(ir_unop_b2i, r168A);
   ir_expression *const r168C = expr(ir_unop_i2u, r168B);
   body.emit(assign(r1679, add(r1679, r168C), 0x01));

   ir_variable *const r168D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r168D, add(r167B, r1665), 0x01));

   body.emit(assign(r1664, r1667, 0x01));

   body.emit(assign(r1663, r168D, 0x01));

   ir_expression *const r168E = less(r168D, r167B);
   ir_expression *const r168F = expr(ir_unop_b2i, r168E);
   ir_expression *const r1690 = expr(ir_unop_i2u, r168F);
   body.emit(assign(r1662, add(r1679, r1690), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fdiv64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1691 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1691);
   ir_variable *const r1692 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r1692);
   ir_variable *const r1693 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r1693, body.constant(true), 0x01));

   ir_variable *const r1694 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1695 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_auto);
   body.emit(r1695);
   ir_variable *const r1696 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
   body.emit(r1696);
   ir_variable *const r1697 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r1697);
   ir_variable *const r1698 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
   body.emit(r1698);
   ir_variable *const r1699 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
   body.emit(r1699);
   ir_variable *const r169A = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r169A);
   ir_variable *const r169B = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
   body.emit(r169B);
   ir_variable *const r169C = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem3", ir_var_auto);
   body.emit(r169C);
   ir_variable *const r169D = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem2", ir_var_auto);
   body.emit(r169D);
   ir_variable *const r169E = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
   body.emit(r169E);
   ir_variable *const r169F = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
   body.emit(r169F);
   ir_variable *const r16A0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r16A0);
   ir_variable *const r16A1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r16A1);
   ir_variable *const r16A2 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r16A2);
   body.emit(assign(r16A1, body.constant(0u), 0x01));

   body.emit(assign(r16A0, body.constant(0u), 0x01));

   body.emit(assign(r169F, body.constant(0u), 0x01));

   body.emit(assign(r169E, body.constant(0u), 0x01));

   body.emit(assign(r169D, body.constant(0u), 0x01));

   body.emit(assign(r169C, body.constant(0u), 0x01));

   ir_variable *const r16A3 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r16A3, swizzle_x(r1691), 0x01));

   body.emit(assign(r169B, r16A3, 0x01));

   ir_variable *const r16A4 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r16A4, bit_and(swizzle_y(r1691), body.constant(1048575u)), 0x01));

   body.emit(assign(r169A, r16A4, 0x01));

   ir_variable *const r16A5 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r16A5, swizzle_x(r1692), 0x01));

   body.emit(assign(r1699, r16A5, 0x01));

   ir_variable *const r16A6 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r16A6, bit_and(swizzle_y(r1692), body.constant(1048575u)), 0x01));

   body.emit(assign(r1698, r16A6, 0x01));

   ir_variable *const r16A7 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r16A8 = rshift(swizzle_y(r1691), body.constant(int(20)));
   ir_expression *const r16A9 = bit_and(r16A8, body.constant(2047u));
   body.emit(assign(r16A7, expr(ir_unop_u2i, r16A9), 0x01));

   body.emit(assign(r1697, r16A7, 0x01));

   ir_variable *const r16AA = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r16AB = rshift(swizzle_y(r1692), body.constant(int(20)));
   ir_expression *const r16AC = bit_and(r16AB, body.constant(2047u));
   body.emit(assign(r16AA, expr(ir_unop_u2i, r16AC), 0x01));

   body.emit(assign(r1696, r16AA, 0x01));

   ir_expression *const r16AD = rshift(swizzle_y(r1691), body.constant(int(31)));
   ir_expression *const r16AE = rshift(swizzle_y(r1692), body.constant(int(31)));
   body.emit(assign(r1695, bit_xor(r16AD, r16AE), 0x01));

   /* IF CONDITION */
   ir_expression *const r16B0 = equal(r16A7, body.constant(int(2047)));
   ir_if *f16AF = new(mem_ctx) ir_if(operand(r16B0).val);
   exec_list *const f16AF_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f16AF->then_instructions;

      /* IF CONDITION */
      ir_expression *const r16B2 = bit_or(r16A4, swizzle_x(r1691));
      ir_expression *const r16B3 = nequal(r16B2, body.constant(0u));
      ir_if *f16B1 = new(mem_ctx) ir_if(operand(r16B3).val);
      exec_list *const f16B1_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f16B1->then_instructions;

         ir_variable *const r16B4 = body.make_temp(glsl_type::uvec2_type, "a");
         body.emit(assign(r16B4, swizzle_x(r1691), 0x01));

         ir_variable *const r16B5 = body.make_temp(glsl_type::uvec2_type, "b");
         body.emit(assign(r16B5, swizzle_x(r1692), 0x01));

         ir_variable *const r16B6 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r16B7 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
         ir_expression *const r16B8 = rshift(swizzle_y(r1691), body.constant(int(19)));
         ir_expression *const r16B9 = bit_and(r16B8, body.constant(4095u));
         ir_expression *const r16BA = equal(r16B9, body.constant(4094u));
         ir_expression *const r16BB = nequal(swizzle_x(r1691), body.constant(0u));
         ir_expression *const r16BC = bit_and(swizzle_y(r1691), body.constant(524287u));
         ir_expression *const r16BD = nequal(r16BC, body.constant(0u));
         ir_expression *const r16BE = logic_or(r16BB, r16BD);
         body.emit(assign(r16B7, logic_and(r16BA, r16BE), 0x01));

         ir_variable *const r16BF = body.make_temp(glsl_type::bool_type, "is_nan_retval");
         ir_expression *const r16C0 = lshift(swizzle_y(r1692), body.constant(int(1)));
         ir_expression *const r16C1 = lequal(body.constant(4292870144u), r16C0);
         ir_expression *const r16C2 = nequal(swizzle_x(r1692), body.constant(0u));
         ir_expression *const r16C3 = bit_and(swizzle_y(r1692), body.constant(1048575u));
         ir_expression *const r16C4 = nequal(r16C3, body.constant(0u));
         ir_expression *const r16C5 = logic_or(r16C2, r16C4);
         body.emit(assign(r16BF, logic_and(r16C1, r16C5), 0x01));

         body.emit(assign(r16B4, bit_or(swizzle_y(r1691), body.constant(524288u)), 0x02));

         body.emit(assign(r16B5, bit_or(swizzle_y(r1692), body.constant(524288u)), 0x02));

         /* IF CONDITION */
         ir_expression *const r16C7 = lshift(swizzle_y(r1691), body.constant(int(1)));
         ir_expression *const r16C8 = lequal(body.constant(4292870144u), r16C7);
         ir_expression *const r16C9 = nequal(swizzle_x(r1691), body.constant(0u));
         ir_expression *const r16CA = bit_and(swizzle_y(r1691), body.constant(1048575u));
         ir_expression *const r16CB = nequal(r16CA, body.constant(0u));
         ir_expression *const r16CC = logic_or(r16C9, r16CB);
         ir_expression *const r16CD = logic_and(r16C8, r16CC);
         ir_if *f16C6 = new(mem_ctx) ir_if(operand(r16CD).val);
         exec_list *const f16C6_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f16C6->then_instructions;

            ir_variable *const r16CE = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r16D0 = logic_and(r16B7, r16BF);
            ir_if *f16CF = new(mem_ctx) ir_if(operand(r16D0).val);
            exec_list *const f16CF_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f16CF->then_instructions;

               body.emit(assign(r16CE, r16B5, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f16CF->else_instructions;

               body.emit(assign(r16CE, r16B4, 0x03));


            body.instructions = f16CF_parent_instructions;
            body.emit(f16CF);

            /* END IF */

            body.emit(assign(r16B6, r16CE, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f16C6->else_instructions;

            body.emit(assign(r16B6, r16B5, 0x03));


         body.instructions = f16C6_parent_instructions;
         body.emit(f16C6);

         /* END IF */

         body.emit(assign(r1694, r16B6, 0x03));

         body.emit(assign(r1693, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f16B1->else_instructions;

         /* IF CONDITION */
         ir_expression *const r16D2 = equal(r16AA, body.constant(int(2047)));
         ir_if *f16D1 = new(mem_ctx) ir_if(operand(r16D2).val);
         exec_list *const f16D1_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f16D1->then_instructions;

            /* IF CONDITION */
            ir_expression *const r16D4 = bit_or(r16A6, swizzle_x(r1692));
            ir_expression *const r16D5 = nequal(r16D4, body.constant(0u));
            ir_if *f16D3 = new(mem_ctx) ir_if(operand(r16D5).val);
            exec_list *const f16D3_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f16D3->then_instructions;

               ir_variable *const r16D6 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r16D6, swizzle_x(r1691), 0x01));

               ir_variable *const r16D7 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r16D7, swizzle_x(r1692), 0x01));

               ir_variable *const r16D8 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r16D9 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r16DA = rshift(swizzle_y(r1691), body.constant(int(19)));
               ir_expression *const r16DB = bit_and(r16DA, body.constant(4095u));
               ir_expression *const r16DC = equal(r16DB, body.constant(4094u));
               ir_expression *const r16DD = nequal(swizzle_x(r1691), body.constant(0u));
               ir_expression *const r16DE = bit_and(swizzle_y(r1691), body.constant(524287u));
               ir_expression *const r16DF = nequal(r16DE, body.constant(0u));
               ir_expression *const r16E0 = logic_or(r16DD, r16DF);
               body.emit(assign(r16D9, logic_and(r16DC, r16E0), 0x01));

               ir_variable *const r16E1 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r16E2 = lshift(swizzle_y(r1692), body.constant(int(1)));
               ir_expression *const r16E3 = lequal(body.constant(4292870144u), r16E2);
               ir_expression *const r16E4 = nequal(swizzle_x(r1692), body.constant(0u));
               ir_expression *const r16E5 = bit_and(swizzle_y(r1692), body.constant(1048575u));
               ir_expression *const r16E6 = nequal(r16E5, body.constant(0u));
               ir_expression *const r16E7 = logic_or(r16E4, r16E6);
               body.emit(assign(r16E1, logic_and(r16E3, r16E7), 0x01));

               body.emit(assign(r16D6, bit_or(swizzle_y(r1691), body.constant(524288u)), 0x02));

               body.emit(assign(r16D7, bit_or(swizzle_y(r1692), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r16E9 = lshift(swizzle_y(r1691), body.constant(int(1)));
               ir_expression *const r16EA = lequal(body.constant(4292870144u), r16E9);
               ir_expression *const r16EB = nequal(swizzle_x(r1691), body.constant(0u));
               ir_expression *const r16EC = bit_and(swizzle_y(r1691), body.constant(1048575u));
               ir_expression *const r16ED = nequal(r16EC, body.constant(0u));
               ir_expression *const r16EE = logic_or(r16EB, r16ED);
               ir_expression *const r16EF = logic_and(r16EA, r16EE);
               ir_if *f16E8 = new(mem_ctx) ir_if(operand(r16EF).val);
               exec_list *const f16E8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f16E8->then_instructions;

                  ir_variable *const r16F0 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r16F2 = logic_and(r16D9, r16E1);
                  ir_if *f16F1 = new(mem_ctx) ir_if(operand(r16F2).val);
                  exec_list *const f16F1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f16F1->then_instructions;

                     body.emit(assign(r16F0, r16D7, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f16F1->else_instructions;

                     body.emit(assign(r16F0, r16D6, 0x03));


                  body.instructions = f16F1_parent_instructions;
                  body.emit(f16F1);

                  /* END IF */

                  body.emit(assign(r16D8, r16F0, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f16E8->else_instructions;

                  body.emit(assign(r16D8, r16D7, 0x03));


               body.instructions = f16E8_parent_instructions;
               body.emit(f16E8);

               /* END IF */

               body.emit(assign(r1694, r16D8, 0x03));

               body.emit(assign(r1693, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f16D3->else_instructions;

               ir_constant_data r16F3_data;
               memset(&r16F3_data, 0, sizeof(ir_constant_data));
               r16F3_data.u[0] = 4294967295;
               r16F3_data.u[1] = 4294967295;
               ir_constant *const r16F3 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r16F3_data);
               body.emit(assign(r1694, r16F3, 0x03));

               body.emit(assign(r1693, body.constant(false), 0x01));


            body.instructions = f16D3_parent_instructions;
            body.emit(f16D3);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f16D1->else_instructions;

            ir_variable *const r16F4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r16F4);
            ir_expression *const r16F5 = lshift(r1695, body.constant(int(31)));
            body.emit(assign(r16F4, add(r16F5, body.constant(2146435072u)), 0x02));

            body.emit(assign(r16F4, body.constant(0u), 0x01));

            body.emit(assign(r1694, r16F4, 0x03));

            body.emit(assign(r1693, body.constant(false), 0x01));


         body.instructions = f16D1_parent_instructions;
         body.emit(f16D1);

         /* END IF */


      body.instructions = f16B1_parent_instructions;
      body.emit(f16B1);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f16AF->else_instructions;

      /* IF CONDITION */
      ir_expression *const r16F7 = equal(r16AA, body.constant(int(2047)));
      ir_if *f16F6 = new(mem_ctx) ir_if(operand(r16F7).val);
      exec_list *const f16F6_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f16F6->then_instructions;

         /* IF CONDITION */
         ir_expression *const r16F9 = bit_or(r16A6, swizzle_x(r1692));
         ir_expression *const r16FA = nequal(r16F9, body.constant(0u));
         ir_if *f16F8 = new(mem_ctx) ir_if(operand(r16FA).val);
         exec_list *const f16F8_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f16F8->then_instructions;

            ir_variable *const r16FB = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r16FB, swizzle_x(r1691), 0x01));

            ir_variable *const r16FC = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r16FC, swizzle_x(r1692), 0x01));

            ir_variable *const r16FD = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r16FE = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r16FF = rshift(swizzle_y(r1691), body.constant(int(19)));
            ir_expression *const r1700 = bit_and(r16FF, body.constant(4095u));
            ir_expression *const r1701 = equal(r1700, body.constant(4094u));
            ir_expression *const r1702 = nequal(swizzle_x(r1691), body.constant(0u));
            ir_expression *const r1703 = bit_and(swizzle_y(r1691), body.constant(524287u));
            ir_expression *const r1704 = nequal(r1703, body.constant(0u));
            ir_expression *const r1705 = logic_or(r1702, r1704);
            body.emit(assign(r16FE, logic_and(r1701, r1705), 0x01));

            ir_variable *const r1706 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r1707 = lshift(swizzle_y(r1692), body.constant(int(1)));
            ir_expression *const r1708 = lequal(body.constant(4292870144u), r1707);
            ir_expression *const r1709 = nequal(swizzle_x(r1692), body.constant(0u));
            ir_expression *const r170A = bit_and(swizzle_y(r1692), body.constant(1048575u));
            ir_expression *const r170B = nequal(r170A, body.constant(0u));
            ir_expression *const r170C = logic_or(r1709, r170B);
            body.emit(assign(r1706, logic_and(r1708, r170C), 0x01));

            body.emit(assign(r16FB, bit_or(swizzle_y(r1691), body.constant(524288u)), 0x02));

            body.emit(assign(r16FC, bit_or(swizzle_y(r1692), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r170E = lshift(swizzle_y(r1691), body.constant(int(1)));
            ir_expression *const r170F = lequal(body.constant(4292870144u), r170E);
            ir_expression *const r1710 = nequal(swizzle_x(r1691), body.constant(0u));
            ir_expression *const r1711 = bit_and(swizzle_y(r1691), body.constant(1048575u));
            ir_expression *const r1712 = nequal(r1711, body.constant(0u));
            ir_expression *const r1713 = logic_or(r1710, r1712);
            ir_expression *const r1714 = logic_and(r170F, r1713);
            ir_if *f170D = new(mem_ctx) ir_if(operand(r1714).val);
            exec_list *const f170D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f170D->then_instructions;

               ir_variable *const r1715 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r1717 = logic_and(r16FE, r1706);
               ir_if *f1716 = new(mem_ctx) ir_if(operand(r1717).val);
               exec_list *const f1716_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1716->then_instructions;

                  body.emit(assign(r1715, r16FC, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1716->else_instructions;

                  body.emit(assign(r1715, r16FB, 0x03));


               body.instructions = f1716_parent_instructions;
               body.emit(f1716);

               /* END IF */

               body.emit(assign(r16FD, r1715, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f170D->else_instructions;

               body.emit(assign(r16FD, r16FC, 0x03));


            body.instructions = f170D_parent_instructions;
            body.emit(f170D);

            /* END IF */

            body.emit(assign(r1694, r16FD, 0x03));

            body.emit(assign(r1693, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f16F8->else_instructions;

            ir_variable *const r1718 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r1718);
            body.emit(assign(r1718, lshift(r1695, body.constant(int(31))), 0x02));

            body.emit(assign(r1718, body.constant(0u), 0x01));

            body.emit(assign(r1694, r1718, 0x03));

            body.emit(assign(r1693, body.constant(false), 0x01));


         body.instructions = f16F8_parent_instructions;
         body.emit(f16F8);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f16F6->else_instructions;

         /* IF CONDITION */
         ir_expression *const r171A = equal(r16AA, body.constant(int(0)));
         ir_if *f1719 = new(mem_ctx) ir_if(operand(r171A).val);
         exec_list *const f1719_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1719->then_instructions;

            /* IF CONDITION */
            ir_expression *const r171C = bit_or(r16A6, swizzle_x(r1692));
            ir_expression *const r171D = equal(r171C, body.constant(0u));
            ir_if *f171B = new(mem_ctx) ir_if(operand(r171D).val);
            exec_list *const f171B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f171B->then_instructions;

               /* IF CONDITION */
               ir_expression *const r171F = expr(ir_unop_i2u, r16A7);
               ir_expression *const r1720 = bit_or(r171F, r16A4);
               ir_expression *const r1721 = bit_or(r1720, swizzle_x(r1691));
               ir_expression *const r1722 = equal(r1721, body.constant(0u));
               ir_if *f171E = new(mem_ctx) ir_if(operand(r1722).val);
               exec_list *const f171E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f171E->then_instructions;

                  ir_constant_data r1723_data;
                  memset(&r1723_data, 0, sizeof(ir_constant_data));
                  r1723_data.u[0] = 4294967295;
                  r1723_data.u[1] = 4294967295;
                  ir_constant *const r1723 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r1723_data);
                  body.emit(assign(r1694, r1723, 0x03));

                  body.emit(assign(r1693, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f171E->else_instructions;

                  ir_variable *const r1724 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1724);
                  ir_expression *const r1725 = lshift(r1695, body.constant(int(31)));
                  body.emit(assign(r1724, add(r1725, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r1724, body.constant(0u), 0x01));

                  body.emit(assign(r1694, r1724, 0x03));

                  body.emit(assign(r1693, body.constant(false), 0x01));


               body.instructions = f171E_parent_instructions;
               body.emit(f171E);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f171B->else_instructions;

               ir_variable *const r1726 = body.make_temp(glsl_type::int_type, "zExpPtr");
               body.emit(assign(r1726, r16AA, 0x01));

               ir_variable *const r1727 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
               body.emit(assign(r1727, r16A6, 0x01));

               ir_variable *const r1728 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
               body.emit(assign(r1728, r16A5, 0x01));

               ir_variable *const r1729 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1729);
               /* IF CONDITION */
               ir_expression *const r172B = equal(r16A6, body.constant(0u));
               ir_if *f172A = new(mem_ctx) ir_if(operand(r172B).val);
               exec_list *const f172A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f172A->then_instructions;

                  ir_variable *const r172C = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r172C, r16A5, 0x01));

                  ir_variable *const r172D = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r172E = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r172E);
                  /* IF CONDITION */
                  ir_expression *const r1730 = equal(swizzle_x(r1692), body.constant(0u));
                  ir_if *f172F = new(mem_ctx) ir_if(operand(r1730).val);
                  exec_list *const f172F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f172F->then_instructions;

                     body.emit(assign(r172D, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f172F->else_instructions;

                     body.emit(assign(r172E, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1732 = bit_and(swizzle_x(r1692), body.constant(4294901760u));
                     ir_expression *const r1733 = equal(r1732, body.constant(0u));
                     ir_if *f1731 = new(mem_ctx) ir_if(operand(r1733).val);
                     exec_list *const f1731_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1731->then_instructions;

                        body.emit(assign(r172E, body.constant(int(16)), 0x01));

                        body.emit(assign(r172C, lshift(swizzle_x(r1692), body.constant(int(16))), 0x01));


                     body.instructions = f1731_parent_instructions;
                     body.emit(f1731);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1735 = bit_and(r172C, body.constant(4278190080u));
                     ir_expression *const r1736 = equal(r1735, body.constant(0u));
                     ir_if *f1734 = new(mem_ctx) ir_if(operand(r1736).val);
                     exec_list *const f1734_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1734->then_instructions;

                        body.emit(assign(r172E, add(r172E, body.constant(int(8))), 0x01));

                        body.emit(assign(r172C, lshift(r172C, body.constant(int(8))), 0x01));


                     body.instructions = f1734_parent_instructions;
                     body.emit(f1734);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1738 = bit_and(r172C, body.constant(4026531840u));
                     ir_expression *const r1739 = equal(r1738, body.constant(0u));
                     ir_if *f1737 = new(mem_ctx) ir_if(operand(r1739).val);
                     exec_list *const f1737_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1737->then_instructions;

                        body.emit(assign(r172E, add(r172E, body.constant(int(4))), 0x01));

                        body.emit(assign(r172C, lshift(r172C, body.constant(int(4))), 0x01));


                     body.instructions = f1737_parent_instructions;
                     body.emit(f1737);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r173B = bit_and(r172C, body.constant(3221225472u));
                     ir_expression *const r173C = equal(r173B, body.constant(0u));
                     ir_if *f173A = new(mem_ctx) ir_if(operand(r173C).val);
                     exec_list *const f173A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f173A->then_instructions;

                        body.emit(assign(r172E, add(r172E, body.constant(int(2))), 0x01));

                        body.emit(assign(r172C, lshift(r172C, body.constant(int(2))), 0x01));


                     body.instructions = f173A_parent_instructions;
                     body.emit(f173A);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r173E = bit_and(r172C, body.constant(2147483648u));
                     ir_expression *const r173F = equal(r173E, body.constant(0u));
                     ir_if *f173D = new(mem_ctx) ir_if(operand(r173F).val);
                     exec_list *const f173D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f173D->then_instructions;

                        body.emit(assign(r172E, add(r172E, body.constant(int(1))), 0x01));


                     body.instructions = f173D_parent_instructions;
                     body.emit(f173D);

                     /* END IF */

                     body.emit(assign(r172D, r172E, 0x01));


                  body.instructions = f172F_parent_instructions;
                  body.emit(f172F);

                  /* END IF */

                  body.emit(assign(r1729, add(r172D, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1741 = less(r1729, body.constant(int(0)));
                  ir_if *f1740 = new(mem_ctx) ir_if(operand(r1741).val);
                  exec_list *const f1740_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1740->then_instructions;

                     ir_expression *const r1742 = neg(r1729);
                     body.emit(assign(r1727, rshift(swizzle_x(r1692), r1742), 0x01));

                     ir_expression *const r1743 = bit_and(r1729, body.constant(int(31)));
                     body.emit(assign(r1728, lshift(swizzle_x(r1692), r1743), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1740->else_instructions;

                     body.emit(assign(r1727, lshift(swizzle_x(r1692), r1729), 0x01));

                     body.emit(assign(r1728, body.constant(0u), 0x01));


                  body.instructions = f1740_parent_instructions;
                  body.emit(f1740);

                  /* END IF */

                  body.emit(assign(r1726, sub(body.constant(int(-31)), r1729), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f172A->else_instructions;

                  ir_variable *const r1744 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r1744, r16A6, 0x01));

                  ir_variable *const r1745 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r1746 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r1746);
                  /* IF CONDITION */
                  ir_expression *const r1748 = equal(r16A6, body.constant(0u));
                  ir_if *f1747 = new(mem_ctx) ir_if(operand(r1748).val);
                  exec_list *const f1747_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1747->then_instructions;

                     body.emit(assign(r1745, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1747->else_instructions;

                     body.emit(assign(r1746, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r174A = bit_and(r16A6, body.constant(4294901760u));
                     ir_expression *const r174B = equal(r174A, body.constant(0u));
                     ir_if *f1749 = new(mem_ctx) ir_if(operand(r174B).val);
                     exec_list *const f1749_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1749->then_instructions;

                        body.emit(assign(r1746, body.constant(int(16)), 0x01));

                        body.emit(assign(r1744, lshift(r16A6, body.constant(int(16))), 0x01));


                     body.instructions = f1749_parent_instructions;
                     body.emit(f1749);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r174D = bit_and(r1744, body.constant(4278190080u));
                     ir_expression *const r174E = equal(r174D, body.constant(0u));
                     ir_if *f174C = new(mem_ctx) ir_if(operand(r174E).val);
                     exec_list *const f174C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f174C->then_instructions;

                        body.emit(assign(r1746, add(r1746, body.constant(int(8))), 0x01));

                        body.emit(assign(r1744, lshift(r1744, body.constant(int(8))), 0x01));


                     body.instructions = f174C_parent_instructions;
                     body.emit(f174C);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1750 = bit_and(r1744, body.constant(4026531840u));
                     ir_expression *const r1751 = equal(r1750, body.constant(0u));
                     ir_if *f174F = new(mem_ctx) ir_if(operand(r1751).val);
                     exec_list *const f174F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f174F->then_instructions;

                        body.emit(assign(r1746, add(r1746, body.constant(int(4))), 0x01));

                        body.emit(assign(r1744, lshift(r1744, body.constant(int(4))), 0x01));


                     body.instructions = f174F_parent_instructions;
                     body.emit(f174F);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1753 = bit_and(r1744, body.constant(3221225472u));
                     ir_expression *const r1754 = equal(r1753, body.constant(0u));
                     ir_if *f1752 = new(mem_ctx) ir_if(operand(r1754).val);
                     exec_list *const f1752_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1752->then_instructions;

                        body.emit(assign(r1746, add(r1746, body.constant(int(2))), 0x01));

                        body.emit(assign(r1744, lshift(r1744, body.constant(int(2))), 0x01));


                     body.instructions = f1752_parent_instructions;
                     body.emit(f1752);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1756 = bit_and(r1744, body.constant(2147483648u));
                     ir_expression *const r1757 = equal(r1756, body.constant(0u));
                     ir_if *f1755 = new(mem_ctx) ir_if(operand(r1757).val);
                     exec_list *const f1755_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1755->then_instructions;

                        body.emit(assign(r1746, add(r1746, body.constant(int(1))), 0x01));


                     body.instructions = f1755_parent_instructions;
                     body.emit(f1755);

                     /* END IF */

                     body.emit(assign(r1745, r1746, 0x01));


                  body.instructions = f1747_parent_instructions;
                  body.emit(f1747);

                  /* END IF */

                  body.emit(assign(r1729, add(r1745, body.constant(int(-11))), 0x01));

                  ir_variable *const r1758 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r1758, lshift(swizzle_x(r1692), r1729), 0x01));

                  ir_variable *const r1759 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r175B = equal(r1729, body.constant(int(0)));
                  ir_if *f175A = new(mem_ctx) ir_if(operand(r175B).val);
                  exec_list *const f175A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f175A->then_instructions;

                     body.emit(assign(r1759, r16A6, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f175A->else_instructions;

                     ir_expression *const r175C = lshift(r16A6, r1729);
                     ir_expression *const r175D = neg(r1729);
                     ir_expression *const r175E = bit_and(r175D, body.constant(int(31)));
                     ir_expression *const r175F = rshift(swizzle_x(r1692), r175E);
                     body.emit(assign(r1759, bit_or(r175C, r175F), 0x01));


                  body.instructions = f175A_parent_instructions;
                  body.emit(f175A);

                  /* END IF */

                  body.emit(assign(r1727, r1759, 0x01));

                  body.emit(assign(r1728, r1758, 0x01));

                  body.emit(assign(r1726, sub(body.constant(int(1)), r1729), 0x01));


               body.instructions = f172A_parent_instructions;
               body.emit(f172A);

               /* END IF */

               body.emit(assign(r1696, r1726, 0x01));

               body.emit(assign(r1698, r1727, 0x01));

               body.emit(assign(r1699, r1728, 0x01));


            body.instructions = f171B_parent_instructions;
            body.emit(f171B);

            /* END IF */


         body.instructions = f1719_parent_instructions;
         body.emit(f1719);

         /* END IF */

         /* IF CONDITION */
         ir_if *f1760 = new(mem_ctx) ir_if(operand(r1693).val);
         exec_list *const f1760_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1760->then_instructions;

            /* IF CONDITION */
            ir_expression *const r1762 = equal(r16A7, body.constant(int(0)));
            ir_if *f1761 = new(mem_ctx) ir_if(operand(r1762).val);
            exec_list *const f1761_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1761->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1764 = bit_or(r16A4, swizzle_x(r1691));
               ir_expression *const r1765 = equal(r1764, body.constant(0u));
               ir_if *f1763 = new(mem_ctx) ir_if(operand(r1765).val);
               exec_list *const f1763_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1763->then_instructions;

                  ir_variable *const r1766 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1766);
                  body.emit(assign(r1766, lshift(r1695, body.constant(int(31))), 0x02));

                  body.emit(assign(r1766, body.constant(0u), 0x01));

                  body.emit(assign(r1694, r1766, 0x03));

                  body.emit(assign(r1693, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1763->else_instructions;

                  ir_variable *const r1767 = body.make_temp(glsl_type::int_type, "zExpPtr");
                  body.emit(assign(r1767, r16A7, 0x01));

                  ir_variable *const r1768 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
                  body.emit(assign(r1768, r16A4, 0x01));

                  ir_variable *const r1769 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
                  body.emit(assign(r1769, r16A3, 0x01));

                  ir_variable *const r176A = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r176A);
                  /* IF CONDITION */
                  ir_expression *const r176C = equal(r16A4, body.constant(0u));
                  ir_if *f176B = new(mem_ctx) ir_if(operand(r176C).val);
                  exec_list *const f176B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f176B->then_instructions;

                     ir_variable *const r176D = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r176D, r16A3, 0x01));

                     ir_variable *const r176E = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r176F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r176F);
                     /* IF CONDITION */
                     ir_expression *const r1771 = equal(swizzle_x(r1691), body.constant(0u));
                     ir_if *f1770 = new(mem_ctx) ir_if(operand(r1771).val);
                     exec_list *const f1770_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1770->then_instructions;

                        body.emit(assign(r176E, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1770->else_instructions;

                        body.emit(assign(r176F, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1773 = bit_and(swizzle_x(r1691), body.constant(4294901760u));
                        ir_expression *const r1774 = equal(r1773, body.constant(0u));
                        ir_if *f1772 = new(mem_ctx) ir_if(operand(r1774).val);
                        exec_list *const f1772_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1772->then_instructions;

                           body.emit(assign(r176F, body.constant(int(16)), 0x01));

                           body.emit(assign(r176D, lshift(swizzle_x(r1691), body.constant(int(16))), 0x01));


                        body.instructions = f1772_parent_instructions;
                        body.emit(f1772);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1776 = bit_and(r176D, body.constant(4278190080u));
                        ir_expression *const r1777 = equal(r1776, body.constant(0u));
                        ir_if *f1775 = new(mem_ctx) ir_if(operand(r1777).val);
                        exec_list *const f1775_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1775->then_instructions;

                           body.emit(assign(r176F, add(r176F, body.constant(int(8))), 0x01));

                           body.emit(assign(r176D, lshift(r176D, body.constant(int(8))), 0x01));


                        body.instructions = f1775_parent_instructions;
                        body.emit(f1775);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1779 = bit_and(r176D, body.constant(4026531840u));
                        ir_expression *const r177A = equal(r1779, body.constant(0u));
                        ir_if *f1778 = new(mem_ctx) ir_if(operand(r177A).val);
                        exec_list *const f1778_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1778->then_instructions;

                           body.emit(assign(r176F, add(r176F, body.constant(int(4))), 0x01));

                           body.emit(assign(r176D, lshift(r176D, body.constant(int(4))), 0x01));


                        body.instructions = f1778_parent_instructions;
                        body.emit(f1778);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r177C = bit_and(r176D, body.constant(3221225472u));
                        ir_expression *const r177D = equal(r177C, body.constant(0u));
                        ir_if *f177B = new(mem_ctx) ir_if(operand(r177D).val);
                        exec_list *const f177B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f177B->then_instructions;

                           body.emit(assign(r176F, add(r176F, body.constant(int(2))), 0x01));

                           body.emit(assign(r176D, lshift(r176D, body.constant(int(2))), 0x01));


                        body.instructions = f177B_parent_instructions;
                        body.emit(f177B);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r177F = bit_and(r176D, body.constant(2147483648u));
                        ir_expression *const r1780 = equal(r177F, body.constant(0u));
                        ir_if *f177E = new(mem_ctx) ir_if(operand(r1780).val);
                        exec_list *const f177E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f177E->then_instructions;

                           body.emit(assign(r176F, add(r176F, body.constant(int(1))), 0x01));


                        body.instructions = f177E_parent_instructions;
                        body.emit(f177E);

                        /* END IF */

                        body.emit(assign(r176E, r176F, 0x01));


                     body.instructions = f1770_parent_instructions;
                     body.emit(f1770);

                     /* END IF */

                     body.emit(assign(r176A, add(r176E, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1782 = less(r176A, body.constant(int(0)));
                     ir_if *f1781 = new(mem_ctx) ir_if(operand(r1782).val);
                     exec_list *const f1781_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1781->then_instructions;

                        ir_expression *const r1783 = neg(r176A);
                        body.emit(assign(r1768, rshift(swizzle_x(r1691), r1783), 0x01));

                        ir_expression *const r1784 = bit_and(r176A, body.constant(int(31)));
                        body.emit(assign(r1769, lshift(swizzle_x(r1691), r1784), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1781->else_instructions;

                        body.emit(assign(r1768, lshift(swizzle_x(r1691), r176A), 0x01));

                        body.emit(assign(r1769, body.constant(0u), 0x01));


                     body.instructions = f1781_parent_instructions;
                     body.emit(f1781);

                     /* END IF */

                     body.emit(assign(r1767, sub(body.constant(int(-31)), r176A), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f176B->else_instructions;

                     ir_variable *const r1785 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r1785, r16A4, 0x01));

                     ir_variable *const r1786 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r1787 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r1787);
                     /* IF CONDITION */
                     ir_expression *const r1789 = equal(r16A4, body.constant(0u));
                     ir_if *f1788 = new(mem_ctx) ir_if(operand(r1789).val);
                     exec_list *const f1788_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1788->then_instructions;

                        body.emit(assign(r1786, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1788->else_instructions;

                        body.emit(assign(r1787, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r178B = bit_and(r16A4, body.constant(4294901760u));
                        ir_expression *const r178C = equal(r178B, body.constant(0u));
                        ir_if *f178A = new(mem_ctx) ir_if(operand(r178C).val);
                        exec_list *const f178A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f178A->then_instructions;

                           body.emit(assign(r1787, body.constant(int(16)), 0x01));

                           body.emit(assign(r1785, lshift(r16A4, body.constant(int(16))), 0x01));


                        body.instructions = f178A_parent_instructions;
                        body.emit(f178A);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r178E = bit_and(r1785, body.constant(4278190080u));
                        ir_expression *const r178F = equal(r178E, body.constant(0u));
                        ir_if *f178D = new(mem_ctx) ir_if(operand(r178F).val);
                        exec_list *const f178D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f178D->then_instructions;

                           body.emit(assign(r1787, add(r1787, body.constant(int(8))), 0x01));

                           body.emit(assign(r1785, lshift(r1785, body.constant(int(8))), 0x01));


                        body.instructions = f178D_parent_instructions;
                        body.emit(f178D);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1791 = bit_and(r1785, body.constant(4026531840u));
                        ir_expression *const r1792 = equal(r1791, body.constant(0u));
                        ir_if *f1790 = new(mem_ctx) ir_if(operand(r1792).val);
                        exec_list *const f1790_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1790->then_instructions;

                           body.emit(assign(r1787, add(r1787, body.constant(int(4))), 0x01));

                           body.emit(assign(r1785, lshift(r1785, body.constant(int(4))), 0x01));


                        body.instructions = f1790_parent_instructions;
                        body.emit(f1790);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1794 = bit_and(r1785, body.constant(3221225472u));
                        ir_expression *const r1795 = equal(r1794, body.constant(0u));
                        ir_if *f1793 = new(mem_ctx) ir_if(operand(r1795).val);
                        exec_list *const f1793_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1793->then_instructions;

                           body.emit(assign(r1787, add(r1787, body.constant(int(2))), 0x01));

                           body.emit(assign(r1785, lshift(r1785, body.constant(int(2))), 0x01));


                        body.instructions = f1793_parent_instructions;
                        body.emit(f1793);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1797 = bit_and(r1785, body.constant(2147483648u));
                        ir_expression *const r1798 = equal(r1797, body.constant(0u));
                        ir_if *f1796 = new(mem_ctx) ir_if(operand(r1798).val);
                        exec_list *const f1796_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1796->then_instructions;

                           body.emit(assign(r1787, add(r1787, body.constant(int(1))), 0x01));


                        body.instructions = f1796_parent_instructions;
                        body.emit(f1796);

                        /* END IF */

                        body.emit(assign(r1786, r1787, 0x01));


                     body.instructions = f1788_parent_instructions;
                     body.emit(f1788);

                     /* END IF */

                     body.emit(assign(r176A, add(r1786, body.constant(int(-11))), 0x01));

                     ir_variable *const r1799 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r1799, lshift(swizzle_x(r1691), r176A), 0x01));

                     ir_variable *const r179A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r179C = equal(r176A, body.constant(int(0)));
                     ir_if *f179B = new(mem_ctx) ir_if(operand(r179C).val);
                     exec_list *const f179B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f179B->then_instructions;

                        body.emit(assign(r179A, r16A4, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f179B->else_instructions;

                        ir_expression *const r179D = lshift(r16A4, r176A);
                        ir_expression *const r179E = neg(r176A);
                        ir_expression *const r179F = bit_and(r179E, body.constant(int(31)));
                        ir_expression *const r17A0 = rshift(swizzle_x(r1691), r179F);
                        body.emit(assign(r179A, bit_or(r179D, r17A0), 0x01));


                     body.instructions = f179B_parent_instructions;
                     body.emit(f179B);

                     /* END IF */

                     body.emit(assign(r1768, r179A, 0x01));

                     body.emit(assign(r1769, r1799, 0x01));

                     body.emit(assign(r1767, sub(body.constant(int(1)), r176A), 0x01));


                  body.instructions = f176B_parent_instructions;
                  body.emit(f176B);

                  /* END IF */

                  body.emit(assign(r1697, r1767, 0x01));

                  body.emit(assign(r169A, r1768, 0x01));

                  body.emit(assign(r169B, r1769, 0x01));


               body.instructions = f1763_parent_instructions;
               body.emit(f1763);

               /* END IF */


            body.instructions = f1761_parent_instructions;
            body.emit(f1761);

            /* END IF */

            /* IF CONDITION */
            ir_if *f17A1 = new(mem_ctx) ir_if(operand(r1693).val);
            exec_list *const f17A1_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f17A1->then_instructions;

               ir_expression *const r17A2 = sub(r1697, r1696);
               body.emit(assign(r16A2, add(r17A2, body.constant(int(1021))), 0x01));

               ir_variable *const r17A3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r17A3, lshift(r169B, body.constant(int(11))), 0x01));

               ir_variable *const r17A4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r17A5 = bit_or(r169A, body.constant(1048576u));
               ir_expression *const r17A6 = lshift(r17A5, body.constant(int(11)));
               ir_expression *const r17A7 = rshift(r169B, body.constant(int(21)));
               body.emit(assign(r17A4, bit_or(r17A6, r17A7), 0x01));

               body.emit(assign(r169A, r17A4, 0x01));

               body.emit(assign(r169B, r17A3, 0x01));

               ir_variable *const r17A8 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r17A8, lshift(r1699, body.constant(int(11))), 0x01));

               ir_variable *const r17A9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r17AA = bit_or(r1698, body.constant(1048576u));
               ir_expression *const r17AB = lshift(r17AA, body.constant(int(11)));
               ir_expression *const r17AC = rshift(r1699, body.constant(int(21)));
               body.emit(assign(r17A9, bit_or(r17AB, r17AC), 0x01));

               body.emit(assign(r1698, r17A9, 0x01));

               body.emit(assign(r1699, r17A8, 0x01));

               /* IF CONDITION */
               ir_expression *const r17AE = less(r17A9, r17A4);
               ir_expression *const r17AF = equal(r17A9, r17A4);
               ir_expression *const r17B0 = lequal(r17A8, r17A3);
               ir_expression *const r17B1 = logic_and(r17AF, r17B0);
               ir_expression *const r17B2 = logic_or(r17AE, r17B1);
               ir_if *f17AD = new(mem_ctx) ir_if(operand(r17B2).val);
               exec_list *const f17AD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f17AD->then_instructions;

                  body.emit(assign(r169A, rshift(r17A4, body.constant(int(1))), 0x01));

                  ir_expression *const r17B3 = lshift(r17A4, body.constant(int(31)));
                  ir_expression *const r17B4 = rshift(r17A3, body.constant(int(1)));
                  body.emit(assign(r169B, bit_or(r17B3, r17B4), 0x01));

                  body.emit(assign(r16A2, add(r16A2, body.constant(int(1))), 0x01));


               body.instructions = f17AD_parent_instructions;
               body.emit(f17AD);

               /* END IF */

               ir_variable *const r17B5 = body.make_temp(glsl_type::uint_type, "return_value");
               ir_variable *const r17B6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r17B6);
               ir_variable *const r17B7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
               body.emit(r17B7);
               ir_variable *const r17B8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
               body.emit(r17B8);
               ir_variable *const r17B9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
               body.emit(r17B9);
               body.emit(assign(r17B8, body.constant(0u), 0x01));

               body.emit(assign(r17B7, body.constant(0u), 0x01));

               /* IF CONDITION */
               ir_expression *const r17BB = lequal(r17A9, r169A);
               ir_if *f17BA = new(mem_ctx) ir_if(operand(r17BB).val);
               exec_list *const f17BA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f17BA->then_instructions;

                  body.emit(assign(r17B5, body.constant(4294967295u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f17BA->else_instructions;

                  body.emit(assign(r17B9, rshift(r17A9, body.constant(int(16))), 0x01));

                  ir_variable *const r17BC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r17BE = lshift(r17B9, body.constant(int(16)));
                  ir_expression *const r17BF = lequal(r17BE, r169A);
                  ir_if *f17BD = new(mem_ctx) ir_if(operand(r17BF).val);
                  exec_list *const f17BD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f17BD->then_instructions;

                     body.emit(assign(r17BC, body.constant(4294901760u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f17BD->else_instructions;

                     ir_expression *const r17C0 = expr(ir_binop_div, r169A, r17B9);
                     body.emit(assign(r17BC, lshift(r17C0, body.constant(int(16))), 0x01));


                  body.instructions = f17BD_parent_instructions;
                  body.emit(f17BD);

                  /* END IF */

                  body.emit(assign(r17B6, r17BC, 0x01));

                  ir_variable *const r17C1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r17C1);
                  ir_variable *const r17C2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r17C2);
                  ir_variable *const r17C3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r17C3);
                  ir_variable *const r17C4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r17C4, bit_and(r17A9, body.constant(65535u)), 0x01));

                  ir_variable *const r17C5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r17C5, rshift(r17A9, body.constant(int(16))), 0x01));

                  ir_variable *const r17C6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r17C6, bit_and(r17BC, body.constant(65535u)), 0x01));

                  ir_variable *const r17C7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r17C7, rshift(r17BC, body.constant(int(16))), 0x01));

                  ir_variable *const r17C8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r17C8, mul(r17C5, r17C6), 0x01));

                  ir_expression *const r17C9 = mul(r17C4, r17C7);
                  body.emit(assign(r17C2, add(r17C9, r17C8), 0x01));

                  ir_expression *const r17CA = mul(r17C5, r17C7);
                  ir_expression *const r17CB = less(r17C2, r17C8);
                  ir_expression *const r17CC = expr(ir_unop_b2i, r17CB);
                  ir_expression *const r17CD = expr(ir_unop_i2u, r17CC);
                  ir_expression *const r17CE = lshift(r17CD, body.constant(int(16)));
                  ir_expression *const r17CF = rshift(r17C2, body.constant(int(16)));
                  ir_expression *const r17D0 = add(r17CE, r17CF);
                  body.emit(assign(r17C1, add(r17CA, r17D0), 0x01));

                  body.emit(assign(r17C2, lshift(r17C2, body.constant(int(16))), 0x01));

                  ir_expression *const r17D1 = mul(r17C4, r17C6);
                  body.emit(assign(r17C3, add(r17D1, r17C2), 0x01));

                  ir_expression *const r17D2 = less(r17C3, r17C2);
                  ir_expression *const r17D3 = expr(ir_unop_b2i, r17D2);
                  ir_expression *const r17D4 = expr(ir_unop_i2u, r17D3);
                  body.emit(assign(r17C1, add(r17C1, r17D4), 0x01));

                  ir_expression *const r17D5 = sub(r169A, r17C1);
                  ir_expression *const r17D6 = less(r169B, r17C3);
                  ir_expression *const r17D7 = expr(ir_unop_b2i, r17D6);
                  ir_expression *const r17D8 = expr(ir_unop_i2u, r17D7);
                  body.emit(assign(r17B8, sub(r17D5, r17D8), 0x01));

                  body.emit(assign(r17B7, sub(r169B, r17C3), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f17D9 = new(mem_ctx) ir_loop();
                  exec_list *const f17D9_parent_instructions = body.instructions;

                     body.instructions = &f17D9->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r17DB = expr(ir_unop_u2i, r17B8);
                     ir_expression *const r17DC = gequal(r17DB, body.constant(int(0)));
                     ir_if *f17DA = new(mem_ctx) ir_if(operand(r17DC).val);
                     exec_list *const f17DA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f17DA->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f17DA_parent_instructions;
                     body.emit(f17DA);

                     /* END IF */

                     body.emit(assign(r17B6, add(r17B6, body.constant(4294901760u)), 0x01));

                     ir_variable *const r17DD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r17DE = lshift(r17A9, body.constant(int(16)));
                     body.emit(assign(r17DD, add(r17B7, r17DE), 0x01));

                     ir_expression *const r17DF = add(r17B8, r17B9);
                     ir_expression *const r17E0 = less(r17DD, r17B7);
                     ir_expression *const r17E1 = expr(ir_unop_b2i, r17E0);
                     ir_expression *const r17E2 = expr(ir_unop_i2u, r17E1);
                     body.emit(assign(r17B8, add(r17DF, r17E2), 0x01));

                     body.emit(assign(r17B7, r17DD, 0x01));

                  /* LOOP END */

                  body.instructions = f17D9_parent_instructions;
                  body.emit(f17D9);

                  ir_expression *const r17E3 = lshift(r17B8, body.constant(int(16)));
                  ir_expression *const r17E4 = rshift(r17B7, body.constant(int(16)));
                  body.emit(assign(r17B8, bit_or(r17E3, r17E4), 0x01));

                  ir_variable *const r17E5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r17E7 = lshift(r17B9, body.constant(int(16)));
                  ir_expression *const r17E8 = lequal(r17E7, r17B8);
                  ir_if *f17E6 = new(mem_ctx) ir_if(operand(r17E8).val);
                  exec_list *const f17E6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f17E6->then_instructions;

                     body.emit(assign(r17E5, body.constant(65535u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f17E6->else_instructions;

                     body.emit(assign(r17E5, expr(ir_binop_div, r17B8, r17B9), 0x01));


                  body.instructions = f17E6_parent_instructions;
                  body.emit(f17E6);

                  /* END IF */

                  body.emit(assign(r17B6, bit_or(r17B6, r17E5), 0x01));

                  body.emit(assign(r17B5, r17B6, 0x01));


               body.instructions = f17BA_parent_instructions;
               body.emit(f17BA);

               /* END IF */

               body.emit(assign(r16A1, r17B5, 0x01));

               ir_variable *const r17E9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r17E9);
               ir_variable *const r17EA = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r17EA);
               ir_variable *const r17EB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r17EB);
               ir_variable *const r17EC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r17EC, bit_and(r17A8, body.constant(65535u)), 0x01));

               ir_variable *const r17ED = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r17ED, rshift(r17A8, body.constant(int(16))), 0x01));

               ir_variable *const r17EE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r17EE, bit_and(r17B5, body.constant(65535u)), 0x01));

               ir_variable *const r17EF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r17EF, rshift(r17B5, body.constant(int(16))), 0x01));

               ir_variable *const r17F0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r17F0, mul(r17ED, r17EE), 0x01));

               ir_expression *const r17F1 = mul(r17EC, r17EF);
               body.emit(assign(r17EA, add(r17F1, r17F0), 0x01));

               ir_expression *const r17F2 = mul(r17ED, r17EF);
               ir_expression *const r17F3 = less(r17EA, r17F0);
               ir_expression *const r17F4 = expr(ir_unop_b2i, r17F3);
               ir_expression *const r17F5 = expr(ir_unop_i2u, r17F4);
               ir_expression *const r17F6 = lshift(r17F5, body.constant(int(16)));
               ir_expression *const r17F7 = rshift(r17EA, body.constant(int(16)));
               ir_expression *const r17F8 = add(r17F6, r17F7);
               body.emit(assign(r17E9, add(r17F2, r17F8), 0x01));

               body.emit(assign(r17EA, lshift(r17EA, body.constant(int(16))), 0x01));

               ir_expression *const r17F9 = mul(r17EC, r17EE);
               body.emit(assign(r17EB, add(r17F9, r17EA), 0x01));

               ir_expression *const r17FA = less(r17EB, r17EA);
               ir_expression *const r17FB = expr(ir_unop_b2i, r17FA);
               ir_expression *const r17FC = expr(ir_unop_i2u, r17FB);
               body.emit(assign(r17E9, add(r17E9, r17FC), 0x01));

               ir_variable *const r17FD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r17FD);
               ir_variable *const r17FE = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r17FE);
               ir_variable *const r17FF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r17FF);
               ir_variable *const r1800 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1800, bit_and(r17A9, body.constant(65535u)), 0x01));

               ir_variable *const r1801 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1801, rshift(r17A9, body.constant(int(16))), 0x01));

               ir_variable *const r1802 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1802, bit_and(r17B5, body.constant(65535u)), 0x01));

               ir_variable *const r1803 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1803, rshift(r17B5, body.constant(int(16))), 0x01));

               ir_variable *const r1804 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1804, mul(r1801, r1802), 0x01));

               ir_expression *const r1805 = mul(r1800, r1803);
               body.emit(assign(r17FE, add(r1805, r1804), 0x01));

               ir_expression *const r1806 = mul(r1801, r1803);
               ir_expression *const r1807 = less(r17FE, r1804);
               ir_expression *const r1808 = expr(ir_unop_b2i, r1807);
               ir_expression *const r1809 = expr(ir_unop_i2u, r1808);
               ir_expression *const r180A = lshift(r1809, body.constant(int(16)));
               ir_expression *const r180B = rshift(r17FE, body.constant(int(16)));
               ir_expression *const r180C = add(r180A, r180B);
               body.emit(assign(r17FD, add(r1806, r180C), 0x01));

               body.emit(assign(r17FE, lshift(r17FE, body.constant(int(16))), 0x01));

               ir_expression *const r180D = mul(r1800, r1802);
               body.emit(assign(r17FF, add(r180D, r17FE), 0x01));

               ir_expression *const r180E = less(r17FF, r17FE);
               ir_expression *const r180F = expr(ir_unop_b2i, r180E);
               ir_expression *const r1810 = expr(ir_unop_i2u, r180F);
               body.emit(assign(r17FD, add(r17FD, r1810), 0x01));

               ir_variable *const r1811 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1811, add(r17FF, r17E9), 0x01));

               ir_variable *const r1812 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1812);
               ir_variable *const r1813 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r1814 = less(body.constant(0u), r17EB);
               ir_expression *const r1815 = expr(ir_unop_b2i, r1814);
               body.emit(assign(r1813, expr(ir_unop_i2u, r1815), 0x01));

               ir_variable *const r1816 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1816, sub(r169B, r1811), 0x01));

               ir_expression *const r1817 = less(r1811, r17FF);
               ir_expression *const r1818 = expr(ir_unop_b2i, r1817);
               ir_expression *const r1819 = expr(ir_unop_i2u, r1818);
               ir_expression *const r181A = add(r17FD, r1819);
               ir_expression *const r181B = sub(r169A, r181A);
               ir_expression *const r181C = less(r1816, r1813);
               ir_expression *const r181D = expr(ir_unop_b2i, r181C);
               ir_expression *const r181E = expr(ir_unop_i2u, r181D);
               body.emit(assign(r1812, sub(r181B, r181E), 0x01));

               ir_expression *const r181F = less(r169B, r1811);
               ir_expression *const r1820 = expr(ir_unop_b2i, r181F);
               ir_expression *const r1821 = expr(ir_unop_i2u, r1820);
               body.emit(assign(r1812, sub(r1812, r1821), 0x01));

               body.emit(assign(r169F, r1812, 0x01));

               body.emit(assign(r169E, sub(r1816, r1813), 0x01));

               body.emit(assign(r169D, neg(r17EB), 0x01));

               /* LOOP BEGIN */
               ir_loop *f1822 = new(mem_ctx) ir_loop();
               exec_list *const f1822_parent_instructions = body.instructions;

                  body.instructions = &f1822->body_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1824 = expr(ir_unop_u2i, r169F);
                  ir_expression *const r1825 = gequal(r1824, body.constant(int(0)));
                  ir_if *f1823 = new(mem_ctx) ir_if(operand(r1825).val);
                  exec_list *const f1823_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1823->then_instructions;

                     body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                  body.instructions = f1823_parent_instructions;
                  body.emit(f1823);

                  /* END IF */

                  body.emit(assign(r16A1, add(r16A1, body.constant(4294967295u)), 0x01));

                  ir_variable *const r1826 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1826);
                  ir_variable *const r1827 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1827);
                  ir_variable *const r1828 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1828, add(r169D, r17A8), 0x01));

                  ir_variable *const r1829 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  ir_expression *const r182A = less(r1828, r169D);
                  ir_expression *const r182B = expr(ir_unop_b2i, r182A);
                  body.emit(assign(r1829, expr(ir_unop_i2u, r182B), 0x01));

                  ir_variable *const r182C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r182C, add(r169E, r17A9), 0x01));

                  body.emit(assign(r1827, add(r182C, r1829), 0x01));

                  ir_expression *const r182D = less(r1827, r1829);
                  ir_expression *const r182E = expr(ir_unop_b2i, r182D);
                  ir_expression *const r182F = expr(ir_unop_i2u, r182E);
                  body.emit(assign(r1826, add(r169F, r182F), 0x01));

                  ir_expression *const r1830 = less(r182C, r169E);
                  ir_expression *const r1831 = expr(ir_unop_b2i, r1830);
                  ir_expression *const r1832 = expr(ir_unop_i2u, r1831);
                  body.emit(assign(r1826, add(r1826, r1832), 0x01));

                  body.emit(assign(r169F, r1826, 0x01));

                  body.emit(assign(r169E, r1827, 0x01));

                  body.emit(assign(r169D, r1828, 0x01));

               /* LOOP END */

               body.instructions = f1822_parent_instructions;
               body.emit(f1822);

               ir_variable *const r1833 = body.make_temp(glsl_type::uint_type, "return_value");
               ir_variable *const r1834 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r1834);
               ir_variable *const r1835 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
               body.emit(r1835);
               ir_variable *const r1836 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
               body.emit(r1836);
               ir_variable *const r1837 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
               body.emit(r1837);
               body.emit(assign(r1836, body.constant(0u), 0x01));

               body.emit(assign(r1835, body.constant(0u), 0x01));

               /* IF CONDITION */
               ir_expression *const r1839 = lequal(r17A9, r169E);
               ir_if *f1838 = new(mem_ctx) ir_if(operand(r1839).val);
               exec_list *const f1838_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1838->then_instructions;

                  body.emit(assign(r1833, body.constant(4294967295u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1838->else_instructions;

                  body.emit(assign(r1837, rshift(r17A9, body.constant(int(16))), 0x01));

                  ir_variable *const r183A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r183C = lshift(r1837, body.constant(int(16)));
                  ir_expression *const r183D = lequal(r183C, r169E);
                  ir_if *f183B = new(mem_ctx) ir_if(operand(r183D).val);
                  exec_list *const f183B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f183B->then_instructions;

                     body.emit(assign(r183A, body.constant(4294901760u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f183B->else_instructions;

                     ir_expression *const r183E = expr(ir_binop_div, r169E, r1837);
                     body.emit(assign(r183A, lshift(r183E, body.constant(int(16))), 0x01));


                  body.instructions = f183B_parent_instructions;
                  body.emit(f183B);

                  /* END IF */

                  body.emit(assign(r1834, r183A, 0x01));

                  ir_variable *const r183F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r183F);
                  ir_variable *const r1840 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r1840);
                  ir_variable *const r1841 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1841);
                  ir_variable *const r1842 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1842, bit_and(r17A9, body.constant(65535u)), 0x01));

                  ir_variable *const r1843 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1843, rshift(r17A9, body.constant(int(16))), 0x01));

                  ir_variable *const r1844 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1844, bit_and(r183A, body.constant(65535u)), 0x01));

                  ir_variable *const r1845 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1845, rshift(r183A, body.constant(int(16))), 0x01));

                  ir_variable *const r1846 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1846, mul(r1843, r1844), 0x01));

                  ir_expression *const r1847 = mul(r1842, r1845);
                  body.emit(assign(r1840, add(r1847, r1846), 0x01));

                  ir_expression *const r1848 = mul(r1843, r1845);
                  ir_expression *const r1849 = less(r1840, r1846);
                  ir_expression *const r184A = expr(ir_unop_b2i, r1849);
                  ir_expression *const r184B = expr(ir_unop_i2u, r184A);
                  ir_expression *const r184C = lshift(r184B, body.constant(int(16)));
                  ir_expression *const r184D = rshift(r1840, body.constant(int(16)));
                  ir_expression *const r184E = add(r184C, r184D);
                  body.emit(assign(r183F, add(r1848, r184E), 0x01));

                  body.emit(assign(r1840, lshift(r1840, body.constant(int(16))), 0x01));

                  ir_expression *const r184F = mul(r1842, r1844);
                  body.emit(assign(r1841, add(r184F, r1840), 0x01));

                  ir_expression *const r1850 = less(r1841, r1840);
                  ir_expression *const r1851 = expr(ir_unop_b2i, r1850);
                  ir_expression *const r1852 = expr(ir_unop_i2u, r1851);
                  body.emit(assign(r183F, add(r183F, r1852), 0x01));

                  ir_expression *const r1853 = sub(r169E, r183F);
                  ir_expression *const r1854 = less(r169D, r1841);
                  ir_expression *const r1855 = expr(ir_unop_b2i, r1854);
                  ir_expression *const r1856 = expr(ir_unop_i2u, r1855);
                  body.emit(assign(r1836, sub(r1853, r1856), 0x01));

                  body.emit(assign(r1835, sub(r169D, r1841), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f1857 = new(mem_ctx) ir_loop();
                  exec_list *const f1857_parent_instructions = body.instructions;

                     body.instructions = &f1857->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1859 = expr(ir_unop_u2i, r1836);
                     ir_expression *const r185A = gequal(r1859, body.constant(int(0)));
                     ir_if *f1858 = new(mem_ctx) ir_if(operand(r185A).val);
                     exec_list *const f1858_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1858->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f1858_parent_instructions;
                     body.emit(f1858);

                     /* END IF */

                     body.emit(assign(r1834, add(r1834, body.constant(4294901760u)), 0x01));

                     ir_variable *const r185B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r185C = lshift(r17A9, body.constant(int(16)));
                     body.emit(assign(r185B, add(r1835, r185C), 0x01));

                     ir_expression *const r185D = add(r1836, r1837);
                     ir_expression *const r185E = less(r185B, r1835);
                     ir_expression *const r185F = expr(ir_unop_b2i, r185E);
                     ir_expression *const r1860 = expr(ir_unop_i2u, r185F);
                     body.emit(assign(r1836, add(r185D, r1860), 0x01));

                     body.emit(assign(r1835, r185B, 0x01));

                  /* LOOP END */

                  body.instructions = f1857_parent_instructions;
                  body.emit(f1857);

                  ir_expression *const r1861 = lshift(r1836, body.constant(int(16)));
                  ir_expression *const r1862 = rshift(r1835, body.constant(int(16)));
                  body.emit(assign(r1836, bit_or(r1861, r1862), 0x01));

                  ir_variable *const r1863 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1865 = lshift(r1837, body.constant(int(16)));
                  ir_expression *const r1866 = lequal(r1865, r1836);
                  ir_if *f1864 = new(mem_ctx) ir_if(operand(r1866).val);
                  exec_list *const f1864_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1864->then_instructions;

                     body.emit(assign(r1863, body.constant(65535u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1864->else_instructions;

                     body.emit(assign(r1863, expr(ir_binop_div, r1836, r1837), 0x01));


                  body.instructions = f1864_parent_instructions;
                  body.emit(f1864);

                  /* END IF */

                  body.emit(assign(r1834, bit_or(r1834, r1863), 0x01));

                  body.emit(assign(r1833, r1834, 0x01));


               body.instructions = f1838_parent_instructions;
               body.emit(f1838);

               /* END IF */

               body.emit(assign(r16A0, r1833, 0x01));

               /* IF CONDITION */
               ir_expression *const r1868 = bit_and(r1833, body.constant(1023u));
               ir_expression *const r1869 = lequal(r1868, body.constant(4u));
               ir_if *f1867 = new(mem_ctx) ir_if(operand(r1869).val);
               exec_list *const f1867_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1867->then_instructions;

                  ir_variable *const r186A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r186A);
                  ir_variable *const r186B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r186B);
                  ir_variable *const r186C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r186C);
                  ir_variable *const r186D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r186D, bit_and(r17A8, body.constant(65535u)), 0x01));

                  ir_variable *const r186E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r186E, rshift(r17A8, body.constant(int(16))), 0x01));

                  ir_variable *const r186F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r186F, bit_and(r1833, body.constant(65535u)), 0x01));

                  ir_variable *const r1870 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1870, rshift(r1833, body.constant(int(16))), 0x01));

                  ir_variable *const r1871 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1871, mul(r186E, r186F), 0x01));

                  ir_expression *const r1872 = mul(r186D, r1870);
                  body.emit(assign(r186B, add(r1872, r1871), 0x01));

                  ir_expression *const r1873 = mul(r186E, r1870);
                  ir_expression *const r1874 = less(r186B, r1871);
                  ir_expression *const r1875 = expr(ir_unop_b2i, r1874);
                  ir_expression *const r1876 = expr(ir_unop_i2u, r1875);
                  ir_expression *const r1877 = lshift(r1876, body.constant(int(16)));
                  ir_expression *const r1878 = rshift(r186B, body.constant(int(16)));
                  ir_expression *const r1879 = add(r1877, r1878);
                  body.emit(assign(r186A, add(r1873, r1879), 0x01));

                  body.emit(assign(r186B, lshift(r186B, body.constant(int(16))), 0x01));

                  ir_expression *const r187A = mul(r186D, r186F);
                  body.emit(assign(r186C, add(r187A, r186B), 0x01));

                  ir_expression *const r187B = less(r186C, r186B);
                  ir_expression *const r187C = expr(ir_unop_b2i, r187B);
                  ir_expression *const r187D = expr(ir_unop_i2u, r187C);
                  body.emit(assign(r186A, add(r186A, r187D), 0x01));

                  ir_variable *const r187E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r187E);
                  ir_variable *const r187F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r187F);
                  ir_variable *const r1880 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1880);
                  ir_variable *const r1881 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1881, bit_and(r17A9, body.constant(65535u)), 0x01));

                  ir_variable *const r1882 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1882, rshift(r17A9, body.constant(int(16))), 0x01));

                  ir_variable *const r1883 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1883, bit_and(r1833, body.constant(65535u)), 0x01));

                  ir_variable *const r1884 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1884, rshift(r1833, body.constant(int(16))), 0x01));

                  ir_variable *const r1885 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1885, mul(r1882, r1883), 0x01));

                  ir_expression *const r1886 = mul(r1881, r1884);
                  body.emit(assign(r187F, add(r1886, r1885), 0x01));

                  ir_expression *const r1887 = mul(r1882, r1884);
                  ir_expression *const r1888 = less(r187F, r1885);
                  ir_expression *const r1889 = expr(ir_unop_b2i, r1888);
                  ir_expression *const r188A = expr(ir_unop_i2u, r1889);
                  ir_expression *const r188B = lshift(r188A, body.constant(int(16)));
                  ir_expression *const r188C = rshift(r187F, body.constant(int(16)));
                  ir_expression *const r188D = add(r188B, r188C);
                  body.emit(assign(r187E, add(r1887, r188D), 0x01));

                  body.emit(assign(r187F, lshift(r187F, body.constant(int(16))), 0x01));

                  ir_expression *const r188E = mul(r1881, r1883);
                  body.emit(assign(r1880, add(r188E, r187F), 0x01));

                  ir_expression *const r188F = less(r1880, r187F);
                  ir_expression *const r1890 = expr(ir_unop_b2i, r188F);
                  ir_expression *const r1891 = expr(ir_unop_i2u, r1890);
                  body.emit(assign(r187E, add(r187E, r1891), 0x01));

                  ir_variable *const r1892 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1892, add(r1880, r186A), 0x01));

                  ir_variable *const r1893 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1893);
                  ir_variable *const r1894 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  ir_expression *const r1895 = less(body.constant(0u), r186C);
                  ir_expression *const r1896 = expr(ir_unop_b2i, r1895);
                  body.emit(assign(r1894, expr(ir_unop_i2u, r1896), 0x01));

                  ir_variable *const r1897 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1897, sub(r169D, r1892), 0x01));

                  ir_expression *const r1898 = less(r1892, r1880);
                  ir_expression *const r1899 = expr(ir_unop_b2i, r1898);
                  ir_expression *const r189A = expr(ir_unop_i2u, r1899);
                  ir_expression *const r189B = add(r187E, r189A);
                  ir_expression *const r189C = sub(r169E, r189B);
                  ir_expression *const r189D = less(r1897, r1894);
                  ir_expression *const r189E = expr(ir_unop_b2i, r189D);
                  ir_expression *const r189F = expr(ir_unop_i2u, r189E);
                  body.emit(assign(r1893, sub(r189C, r189F), 0x01));

                  ir_expression *const r18A0 = less(r169D, r1892);
                  ir_expression *const r18A1 = expr(ir_unop_b2i, r18A0);
                  ir_expression *const r18A2 = expr(ir_unop_i2u, r18A1);
                  body.emit(assign(r1893, sub(r1893, r18A2), 0x01));

                  body.emit(assign(r169E, r1893, 0x01));

                  body.emit(assign(r169D, sub(r1897, r1894), 0x01));

                  body.emit(assign(r169C, neg(r186C), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f18A3 = new(mem_ctx) ir_loop();
                  exec_list *const f18A3_parent_instructions = body.instructions;

                     body.instructions = &f18A3->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r18A5 = expr(ir_unop_u2i, r169E);
                     ir_expression *const r18A6 = gequal(r18A5, body.constant(int(0)));
                     ir_if *f18A4 = new(mem_ctx) ir_if(operand(r18A6).val);
                     exec_list *const f18A4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f18A4->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f18A4_parent_instructions;
                     body.emit(f18A4);

                     /* END IF */

                     body.emit(assign(r16A0, add(r16A0, body.constant(4294967295u)), 0x01));

                     ir_variable *const r18A7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r18A7);
                     ir_variable *const r18A8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r18A8);
                     ir_variable *const r18A9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r18A9, add(r169C, r17A8), 0x01));

                     ir_variable *const r18AA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r18AB = less(r18A9, r169C);
                     ir_expression *const r18AC = expr(ir_unop_b2i, r18AB);
                     body.emit(assign(r18AA, expr(ir_unop_i2u, r18AC), 0x01));

                     ir_variable *const r18AD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r18AD, add(r169D, r17A9), 0x01));

                     body.emit(assign(r18A8, add(r18AD, r18AA), 0x01));

                     ir_expression *const r18AE = less(r18A8, r18AA);
                     ir_expression *const r18AF = expr(ir_unop_b2i, r18AE);
                     ir_expression *const r18B0 = expr(ir_unop_i2u, r18AF);
                     body.emit(assign(r18A7, add(r169E, r18B0), 0x01));

                     ir_expression *const r18B1 = less(r18AD, r169D);
                     ir_expression *const r18B2 = expr(ir_unop_b2i, r18B1);
                     ir_expression *const r18B3 = expr(ir_unop_i2u, r18B2);
                     body.emit(assign(r18A7, add(r18A7, r18B3), 0x01));

                     body.emit(assign(r169E, r18A7, 0x01));

                     body.emit(assign(r169D, r18A8, 0x01));

                     body.emit(assign(r169C, r18A9, 0x01));

                  /* LOOP END */

                  body.instructions = f18A3_parent_instructions;
                  body.emit(f18A3);

                  ir_expression *const r18B4 = bit_or(r169E, r169D);
                  ir_expression *const r18B5 = bit_or(r18B4, r169C);
                  ir_expression *const r18B6 = nequal(r18B5, body.constant(0u));
                  ir_expression *const r18B7 = expr(ir_unop_b2i, r18B6);
                  ir_expression *const r18B8 = expr(ir_unop_i2u, r18B7);
                  body.emit(assign(r16A0, bit_or(r16A0, r18B8), 0x01));


               body.instructions = f1867_parent_instructions;
               body.emit(f1867);

               /* END IF */

               ir_variable *const r18B9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r18B9);
               ir_variable *const r18BA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r18BA);
               ir_variable *const r18BB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r18BB);
               body.emit(assign(r18B9, lshift(r16A0, body.constant(int(21))), 0x01));

               ir_expression *const r18BC = lshift(r16A1, body.constant(int(21)));
               ir_expression *const r18BD = rshift(r16A0, body.constant(int(11)));
               body.emit(assign(r18BA, bit_or(r18BC, r18BD), 0x01));

               body.emit(assign(r18BB, rshift(r16A1, body.constant(int(11))), 0x01));

               body.emit(assign(r18B9, bit_or(r18B9, body.constant(0u)), 0x01));

               body.emit(assign(r16A1, r18BB, 0x01));

               body.emit(assign(r16A0, r18BA, 0x01));

               ir_variable *const r18BE = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r18BE, r16A2, 0x01));

               ir_variable *const r18BF = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r18BF, r18BB, 0x01));

               ir_variable *const r18C0 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r18C0, r18BA, 0x01));

               ir_variable *const r18C1 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r18C1, r18B9, 0x01));

               ir_variable *const r18C2 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r18C2, body.constant(true), 0x01));

               ir_variable *const r18C3 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r18C4 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r18C4);
               ir_expression *const r18C5 = expr(ir_unop_u2i, r18B9);
               body.emit(assign(r18C4, less(r18C5, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r18C7 = lequal(body.constant(int(2045)), r16A2);
               ir_if *f18C6 = new(mem_ctx) ir_if(operand(r18C7).val);
               exec_list *const f18C6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f18C6->then_instructions;

                  ir_variable *const r18C8 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r18CA = less(body.constant(int(2045)), r16A2);
                  ir_if *f18C9 = new(mem_ctx) ir_if(operand(r18CA).val);
                  exec_list *const f18C9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f18C9->then_instructions;

                     body.emit(assign(r18C8, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f18C9->else_instructions;

                     ir_variable *const r18CB = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r18CD = equal(r16A2, body.constant(int(2045)));
                     ir_if *f18CC = new(mem_ctx) ir_if(operand(r18CD).val);
                     exec_list *const f18CC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f18CC->then_instructions;

                        ir_expression *const r18CE = equal(body.constant(2097151u), r18BB);
                        ir_expression *const r18CF = equal(body.constant(4294967295u), r18BA);
                        body.emit(assign(r18CB, logic_and(r18CE, r18CF), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f18CC->else_instructions;

                        body.emit(assign(r18CB, body.constant(false), 0x01));


                     body.instructions = f18CC_parent_instructions;
                     body.emit(f18CC);

                     /* END IF */

                     body.emit(assign(r18C8, logic_and(r18CB, r18C4), 0x01));


                  body.instructions = f18C9_parent_instructions;
                  body.emit(f18C9);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f18D0 = new(mem_ctx) ir_if(operand(r18C8).val);
                  exec_list *const f18D0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f18D0->then_instructions;

                     ir_variable *const r18D1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r18D1);
                     ir_expression *const r18D2 = lshift(r1695, body.constant(int(31)));
                     body.emit(assign(r18D1, add(r18D2, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r18D1, body.constant(0u), 0x01));

                     body.emit(assign(r18C3, r18D1, 0x03));

                     body.emit(assign(r18C2, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f18D0->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r18D4 = less(r16A2, body.constant(int(0)));
                     ir_if *f18D3 = new(mem_ctx) ir_if(operand(r18D4).val);
                     exec_list *const f18D3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f18D3->then_instructions;

                        ir_variable *const r18D5 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r18D5, r18B9, 0x01));

                        ir_variable *const r18D6 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r18D6, neg(r16A2), 0x01));

                        ir_variable *const r18D7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r18D7);
                        ir_variable *const r18D8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r18D8);
                        ir_variable *const r18D9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r18D9);
                        ir_variable *const r18DA = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r18DB = neg(r18D6);
                        body.emit(assign(r18DA, bit_and(r18DB, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r18DD = equal(r18D6, body.constant(int(0)));
                        ir_if *f18DC = new(mem_ctx) ir_if(operand(r18DD).val);
                        exec_list *const f18DC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f18DC->then_instructions;

                           body.emit(assign(r18D7, r18B9, 0x01));

                           body.emit(assign(r18D8, r18BA, 0x01));

                           body.emit(assign(r18D9, r18BB, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f18DC->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r18DF = less(r18D6, body.constant(int(32)));
                           ir_if *f18DE = new(mem_ctx) ir_if(operand(r18DF).val);
                           exec_list *const f18DE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f18DE->then_instructions;

                              body.emit(assign(r18D7, lshift(r18BA, r18DA), 0x01));

                              ir_expression *const r18E0 = lshift(r18BB, r18DA);
                              ir_expression *const r18E1 = rshift(r18BA, r18D6);
                              body.emit(assign(r18D8, bit_or(r18E0, r18E1), 0x01));

                              body.emit(assign(r18D9, rshift(r18BB, r18D6), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f18DE->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r18E3 = equal(r18D6, body.constant(int(32)));
                              ir_if *f18E2 = new(mem_ctx) ir_if(operand(r18E3).val);
                              exec_list *const f18E2_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f18E2->then_instructions;

                                 body.emit(assign(r18D7, r18BA, 0x01));

                                 body.emit(assign(r18D8, r18BB, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f18E2->else_instructions;

                                 body.emit(assign(r18D5, bit_or(r18B9, r18BA), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r18E5 = less(r18D6, body.constant(int(64)));
                                 ir_if *f18E4 = new(mem_ctx) ir_if(operand(r18E5).val);
                                 exec_list *const f18E4_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f18E4->then_instructions;

                                    body.emit(assign(r18D7, lshift(r18BB, r18DA), 0x01));

                                    ir_expression *const r18E6 = bit_and(r18D6, body.constant(int(31)));
                                    body.emit(assign(r18D8, rshift(r18BB, r18E6), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f18E4->else_instructions;

                                    ir_variable *const r18E7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r18E9 = equal(r18D6, body.constant(int(64)));
                                    ir_if *f18E8 = new(mem_ctx) ir_if(operand(r18E9).val);
                                    exec_list *const f18E8_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f18E8->then_instructions;

                                       body.emit(assign(r18E7, r18BB, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f18E8->else_instructions;

                                       ir_expression *const r18EA = nequal(r18BB, body.constant(0u));
                                       ir_expression *const r18EB = expr(ir_unop_b2i, r18EA);
                                       body.emit(assign(r18E7, expr(ir_unop_i2u, r18EB), 0x01));


                                    body.instructions = f18E8_parent_instructions;
                                    body.emit(f18E8);

                                    /* END IF */

                                    body.emit(assign(r18D7, r18E7, 0x01));

                                    body.emit(assign(r18D8, body.constant(0u), 0x01));


                                 body.instructions = f18E4_parent_instructions;
                                 body.emit(f18E4);

                                 /* END IF */


                              body.instructions = f18E2_parent_instructions;
                              body.emit(f18E2);

                              /* END IF */

                              body.emit(assign(r18D9, body.constant(0u), 0x01));


                           body.instructions = f18DE_parent_instructions;
                           body.emit(f18DE);

                           /* END IF */

                           ir_expression *const r18EC = nequal(r18D5, body.constant(0u));
                           ir_expression *const r18ED = expr(ir_unop_b2i, r18EC);
                           ir_expression *const r18EE = expr(ir_unop_i2u, r18ED);
                           body.emit(assign(r18D7, bit_or(r18D7, r18EE), 0x01));


                        body.instructions = f18DC_parent_instructions;
                        body.emit(f18DC);

                        /* END IF */

                        body.emit(assign(r18BF, r18D9, 0x01));

                        body.emit(assign(r18C0, r18D8, 0x01));

                        body.emit(assign(r18C1, r18D7, 0x01));

                        body.emit(assign(r18BE, body.constant(int(0)), 0x01));

                        body.emit(assign(r18C4, less(r18D7, body.constant(0u)), 0x01));


                     body.instructions = f18D3_parent_instructions;
                     body.emit(f18D3);

                     /* END IF */


                  body.instructions = f18D0_parent_instructions;
                  body.emit(f18D0);

                  /* END IF */


               body.instructions = f18C6_parent_instructions;
               body.emit(f18C6);

               /* END IF */

               /* IF CONDITION */
               ir_if *f18EF = new(mem_ctx) ir_if(operand(r18C2).val);
               exec_list *const f18EF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f18EF->then_instructions;

                  /* IF CONDITION */
                  ir_if *f18F0 = new(mem_ctx) ir_if(operand(r18C4).val);
                  exec_list *const f18F0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f18F0->then_instructions;

                     ir_variable *const r18F1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r18F1, add(r18C0, body.constant(1u)), 0x01));

                     ir_expression *const r18F2 = less(r18F1, r18C0);
                     ir_expression *const r18F3 = expr(ir_unop_b2i, r18F2);
                     ir_expression *const r18F4 = expr(ir_unop_i2u, r18F3);
                     body.emit(assign(r18BF, add(r18BF, r18F4), 0x01));

                     ir_expression *const r18F5 = equal(r18C1, body.constant(0u));
                     ir_expression *const r18F6 = expr(ir_unop_b2i, r18F5);
                     ir_expression *const r18F7 = expr(ir_unop_i2u, r18F6);
                     ir_expression *const r18F8 = add(r18C1, r18F7);
                     ir_expression *const r18F9 = bit_and(r18F8, body.constant(1u));
                     ir_expression *const r18FA = expr(ir_unop_bit_not, r18F9);
                     body.emit(assign(r18C0, bit_and(r18F1, r18FA), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f18F0->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r18FC = bit_or(r18BF, r18C0);
                     ir_expression *const r18FD = equal(r18FC, body.constant(0u));
                     ir_if *f18FB = new(mem_ctx) ir_if(operand(r18FD).val);
                     exec_list *const f18FB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f18FB->then_instructions;

                        body.emit(assign(r18BE, body.constant(int(0)), 0x01));


                     body.instructions = f18FB_parent_instructions;
                     body.emit(f18FB);

                     /* END IF */


                  body.instructions = f18F0_parent_instructions;
                  body.emit(f18F0);

                  /* END IF */

                  ir_variable *const r18FE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r18FE);
                  ir_expression *const r18FF = lshift(r1695, body.constant(int(31)));
                  ir_expression *const r1900 = expr(ir_unop_i2u, r18BE);
                  ir_expression *const r1901 = lshift(r1900, body.constant(int(20)));
                  ir_expression *const r1902 = add(r18FF, r1901);
                  body.emit(assign(r18FE, add(r1902, r18BF), 0x02));

                  body.emit(assign(r18FE, r18C0, 0x01));

                  body.emit(assign(r18C3, r18FE, 0x03));

                  body.emit(assign(r18C2, body.constant(false), 0x01));


               body.instructions = f18EF_parent_instructions;
               body.emit(f18EF);

               /* END IF */

               body.emit(assign(r1694, r18C3, 0x03));

               body.emit(assign(r1693, body.constant(false), 0x01));


            body.instructions = f17A1_parent_instructions;
            body.emit(f17A1);

            /* END IF */


         body.instructions = f1760_parent_instructions;
         body.emit(f1760);

         /* END IF */


      body.instructions = f16F6_parent_instructions;
      body.emit(f16F6);

      /* END IF */


   body.instructions = f16AF_parent_instructions;
   body.emit(f16AF);

   /* END IF */

   body.emit(ret(r1694));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
normalizeFloat32Subnormal(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1903 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac", ir_var_function_in);
   sig_parameters.push_tail(r1903);
   ir_variable *const r1904 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExpPtr", ir_var_function_inout);
   sig_parameters.push_tail(r1904);
   ir_variable *const r1905 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFracPtr", ir_var_function_inout);
   sig_parameters.push_tail(r1905);
   ir_variable *const r1906 = body.make_temp(glsl_type::uint_type, "a");
   body.emit(assign(r1906, r1903, 0x01));

   ir_variable *const r1907 = body.make_temp(glsl_type::int_type, "return_value");
   ir_variable *const r1908 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r1908);
   /* IF CONDITION */
   ir_expression *const r190A = equal(r1903, body.constant(0u));
   ir_if *f1909 = new(mem_ctx) ir_if(operand(r190A).val);
   exec_list *const f1909_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1909->then_instructions;

      body.emit(assign(r1907, body.constant(int(32)), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1909->else_instructions;

      body.emit(assign(r1908, body.constant(int(0)), 0x01));

      /* IF CONDITION */
      ir_expression *const r190C = bit_and(r1903, body.constant(4294901760u));
      ir_expression *const r190D = equal(r190C, body.constant(0u));
      ir_if *f190B = new(mem_ctx) ir_if(operand(r190D).val);
      exec_list *const f190B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f190B->then_instructions;

         body.emit(assign(r1908, body.constant(int(16)), 0x01));

         body.emit(assign(r1906, lshift(r1903, body.constant(int(16))), 0x01));


      body.instructions = f190B_parent_instructions;
      body.emit(f190B);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r190F = bit_and(r1906, body.constant(4278190080u));
      ir_expression *const r1910 = equal(r190F, body.constant(0u));
      ir_if *f190E = new(mem_ctx) ir_if(operand(r1910).val);
      exec_list *const f190E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f190E->then_instructions;

         body.emit(assign(r1908, add(r1908, body.constant(int(8))), 0x01));

         body.emit(assign(r1906, lshift(r1906, body.constant(int(8))), 0x01));


      body.instructions = f190E_parent_instructions;
      body.emit(f190E);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1912 = bit_and(r1906, body.constant(4026531840u));
      ir_expression *const r1913 = equal(r1912, body.constant(0u));
      ir_if *f1911 = new(mem_ctx) ir_if(operand(r1913).val);
      exec_list *const f1911_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1911->then_instructions;

         body.emit(assign(r1908, add(r1908, body.constant(int(4))), 0x01));

         body.emit(assign(r1906, lshift(r1906, body.constant(int(4))), 0x01));


      body.instructions = f1911_parent_instructions;
      body.emit(f1911);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1915 = bit_and(r1906, body.constant(3221225472u));
      ir_expression *const r1916 = equal(r1915, body.constant(0u));
      ir_if *f1914 = new(mem_ctx) ir_if(operand(r1916).val);
      exec_list *const f1914_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1914->then_instructions;

         body.emit(assign(r1908, add(r1908, body.constant(int(2))), 0x01));

         body.emit(assign(r1906, lshift(r1906, body.constant(int(2))), 0x01));


      body.instructions = f1914_parent_instructions;
      body.emit(f1914);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1918 = bit_and(r1906, body.constant(2147483648u));
      ir_expression *const r1919 = equal(r1918, body.constant(0u));
      ir_if *f1917 = new(mem_ctx) ir_if(operand(r1919).val);
      exec_list *const f1917_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1917->then_instructions;

         body.emit(assign(r1908, add(r1908, body.constant(int(1))), 0x01));


      body.instructions = f1917_parent_instructions;
      body.emit(f1917);

      /* END IF */

      body.emit(assign(r1907, r1908, 0x01));


   body.instructions = f1909_parent_instructions;
   body.emit(f1909);

   /* END IF */

   ir_variable *const r191A = body.make_temp(glsl_type::int_type, "assignment_tmp");
   body.emit(assign(r191A, add(r1907, body.constant(int(-8))), 0x01));

   body.emit(assign(r1905, lshift(r1903, r191A), 0x01));

   body.emit(assign(r1904, sub(body.constant(int(1)), r191A), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat32Frac(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r191B = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r191B);
   ir_expression *const r191C = bit_and(r191B, body.constant(8388607u));
   body.emit(ret(r191C));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat32Exp(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::int_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r191D = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r191D);
   ir_expression *const r191E = rshift(r191D, body.constant(int(23)));
   ir_expression *const r191F = bit_and(r191E, body.constant(255u));
   ir_expression *const r1920 = expr(ir_unop_u2i, r191F);
   body.emit(ret(r1920));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat32Sign(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1921 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1921);
   ir_expression *const r1922 = rshift(r1921, body.constant(int(31)));
   body.emit(ret(r1922));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fp32_to_fp64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1923 = new(mem_ctx) ir_variable(glsl_type::float_type, "f", ir_var_function_in);
   sig_parameters.push_tail(r1923);
   ir_variable *const r1924 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r1924, body.constant(true), 0x01));

   ir_variable *const r1925 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1926 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r1926);
   ir_variable *const r1927 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac", ir_var_auto);
   body.emit(r1927);
   ir_variable *const r1928 = body.make_temp(glsl_type::uint_type, "floatBitsToUint_retval");
   body.emit(assign(r1928, expr(ir_unop_bitcast_f2u, r1923), 0x01));

   ir_variable *const r1929 = body.make_temp(glsl_type::uint_type, "extractFloat32Frac_retval");
   body.emit(assign(r1929, bit_and(r1928, body.constant(8388607u)), 0x01));

   body.emit(assign(r1927, r1929, 0x01));

   ir_variable *const r192A = body.make_temp(glsl_type::int_type, "extractFloat32Exp_retval");
   ir_expression *const r192B = rshift(r1928, body.constant(int(23)));
   ir_expression *const r192C = bit_and(r192B, body.constant(255u));
   body.emit(assign(r192A, expr(ir_unop_u2i, r192C), 0x01));

   body.emit(assign(r1926, r192A, 0x01));

   ir_variable *const r192D = body.make_temp(glsl_type::uint_type, "extractFloat32Sign_retval");
   body.emit(assign(r192D, rshift(r1928, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r192F = equal(r192A, body.constant(int(255)));
   ir_if *f192E = new(mem_ctx) ir_if(operand(r192F).val);
   exec_list *const f192E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f192E->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1931 = nequal(r1929, body.constant(0u));
      ir_if *f1930 = new(mem_ctx) ir_if(operand(r1931).val);
      exec_list *const f1930_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1930->then_instructions;

         ir_variable *const r1932 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r1932, lshift(r1928, body.constant(int(9))), 0x01));

         ir_variable *const r1933 = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
         ir_expression *const r1934 = lshift(r1932, body.constant(int(20)));
         body.emit(assign(r1933, bit_or(r1934, body.constant(0u)), 0x01));

         ir_expression *const r1935 = rshift(r1932, body.constant(int(12)));
         ir_expression *const r1936 = lshift(r192D, body.constant(int(31)));
         ir_expression *const r1937 = bit_or(r1936, body.constant(2146959360u));
         body.emit(assign(r1933, bit_or(r1935, r1937), 0x02));

         body.emit(assign(r1925, r1933, 0x03));

         body.emit(assign(r1924, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1930->else_instructions;

         ir_variable *const r1938 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r1938);
         ir_expression *const r1939 = lshift(r192D, body.constant(int(31)));
         body.emit(assign(r1938, add(r1939, body.constant(2146435072u)), 0x02));

         body.emit(assign(r1938, body.constant(0u), 0x01));

         body.emit(assign(r1925, r1938, 0x03));

         body.emit(assign(r1924, body.constant(false), 0x01));


      body.instructions = f1930_parent_instructions;
      body.emit(f1930);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f192E->else_instructions;

      /* IF CONDITION */
      ir_expression *const r193B = equal(r192A, body.constant(int(0)));
      ir_if *f193A = new(mem_ctx) ir_if(operand(r193B).val);
      exec_list *const f193A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f193A->then_instructions;

         /* IF CONDITION */
         ir_expression *const r193D = equal(r1929, body.constant(0u));
         ir_if *f193C = new(mem_ctx) ir_if(operand(r193D).val);
         exec_list *const f193C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f193C->then_instructions;

            ir_variable *const r193E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r193E);
            body.emit(assign(r193E, lshift(r192D, body.constant(int(31))), 0x02));

            body.emit(assign(r193E, body.constant(0u), 0x01));

            body.emit(assign(r1925, r193E, 0x03));

            body.emit(assign(r1924, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f193C->else_instructions;

            ir_variable *const r193F = body.make_temp(glsl_type::int_type, "zExpPtr");
            body.emit(assign(r193F, r192A, 0x01));

            ir_variable *const r1940 = body.make_temp(glsl_type::uint_type, "zFracPtr");
            body.emit(assign(r1940, r1929, 0x01));

            ir_variable *const r1941 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r1941, r1929, 0x01));

            ir_variable *const r1942 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r1943 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r1943);
            /* IF CONDITION */
            ir_expression *const r1945 = equal(r1929, body.constant(0u));
            ir_if *f1944 = new(mem_ctx) ir_if(operand(r1945).val);
            exec_list *const f1944_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1944->then_instructions;

               body.emit(assign(r1942, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1944->else_instructions;

               body.emit(assign(r1943, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r1947 = bit_and(r1929, body.constant(4294901760u));
               ir_expression *const r1948 = equal(r1947, body.constant(0u));
               ir_if *f1946 = new(mem_ctx) ir_if(operand(r1948).val);
               exec_list *const f1946_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1946->then_instructions;

                  body.emit(assign(r1943, body.constant(int(16)), 0x01));

                  body.emit(assign(r1941, lshift(r1929, body.constant(int(16))), 0x01));


               body.instructions = f1946_parent_instructions;
               body.emit(f1946);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r194A = bit_and(r1941, body.constant(4278190080u));
               ir_expression *const r194B = equal(r194A, body.constant(0u));
               ir_if *f1949 = new(mem_ctx) ir_if(operand(r194B).val);
               exec_list *const f1949_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1949->then_instructions;

                  body.emit(assign(r1943, add(r1943, body.constant(int(8))), 0x01));

                  body.emit(assign(r1941, lshift(r1941, body.constant(int(8))), 0x01));


               body.instructions = f1949_parent_instructions;
               body.emit(f1949);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r194D = bit_and(r1941, body.constant(4026531840u));
               ir_expression *const r194E = equal(r194D, body.constant(0u));
               ir_if *f194C = new(mem_ctx) ir_if(operand(r194E).val);
               exec_list *const f194C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f194C->then_instructions;

                  body.emit(assign(r1943, add(r1943, body.constant(int(4))), 0x01));

                  body.emit(assign(r1941, lshift(r1941, body.constant(int(4))), 0x01));


               body.instructions = f194C_parent_instructions;
               body.emit(f194C);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1950 = bit_and(r1941, body.constant(3221225472u));
               ir_expression *const r1951 = equal(r1950, body.constant(0u));
               ir_if *f194F = new(mem_ctx) ir_if(operand(r1951).val);
               exec_list *const f194F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f194F->then_instructions;

                  body.emit(assign(r1943, add(r1943, body.constant(int(2))), 0x01));

                  body.emit(assign(r1941, lshift(r1941, body.constant(int(2))), 0x01));


               body.instructions = f194F_parent_instructions;
               body.emit(f194F);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1953 = bit_and(r1941, body.constant(2147483648u));
               ir_expression *const r1954 = equal(r1953, body.constant(0u));
               ir_if *f1952 = new(mem_ctx) ir_if(operand(r1954).val);
               exec_list *const f1952_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1952->then_instructions;

                  body.emit(assign(r1943, add(r1943, body.constant(int(1))), 0x01));


               body.instructions = f1952_parent_instructions;
               body.emit(f1952);

               /* END IF */

               body.emit(assign(r1942, r1943, 0x01));


            body.instructions = f1944_parent_instructions;
            body.emit(f1944);

            /* END IF */

            ir_variable *const r1955 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            body.emit(assign(r1955, add(r1942, body.constant(int(-8))), 0x01));

            body.emit(assign(r1940, lshift(r1929, r1955), 0x01));

            body.emit(assign(r193F, sub(body.constant(int(1)), r1955), 0x01));

            body.emit(assign(r1927, r1940, 0x01));

            body.emit(assign(r1926, add(r193F, body.constant(int(-1))), 0x01));


         body.instructions = f193C_parent_instructions;
         body.emit(f193C);

         /* END IF */


      body.instructions = f193A_parent_instructions;
      body.emit(f193A);

      /* END IF */

      /* IF CONDITION */
      ir_if *f1956 = new(mem_ctx) ir_if(operand(r1924).val);
      exec_list *const f1956_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1956->then_instructions;

         ir_variable *const r1957 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r1957);
         ir_expression *const r1958 = lshift(r192D, body.constant(int(31)));
         ir_expression *const r1959 = add(r1926, body.constant(int(896)));
         ir_expression *const r195A = expr(ir_unop_i2u, r1959);
         ir_expression *const r195B = lshift(r195A, body.constant(int(20)));
         ir_expression *const r195C = add(r1958, r195B);
         ir_expression *const r195D = rshift(r1927, body.constant(int(3)));
         body.emit(assign(r1957, add(r195C, r195D), 0x02));

         ir_expression *const r195E = lshift(r1927, body.constant(int(29)));
         body.emit(assign(r1957, bit_or(r195E, body.constant(0u)), 0x01));

         body.emit(assign(r1925, r1957, 0x03));

         body.emit(assign(r1924, body.constant(false), 0x01));


      body.instructions = f1956_parent_instructions;
      body.emit(f1956);

      /* END IF */


   body.instructions = f192E_parent_instructions;
   body.emit(f192E);

   /* END IF */

   body.emit(ret(r1925));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
packFloat32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::float_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r195F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r195F);
   ir_variable *const r1960 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r1960);
   ir_variable *const r1961 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac", ir_var_function_in);
   sig_parameters.push_tail(r1961);
   ir_variable *const r1962 = body.make_temp(glsl_type::float_type, "uintBitsToFloat_retval");
   ir_expression *const r1963 = lshift(r195F, body.constant(int(31)));
   ir_expression *const r1964 = expr(ir_unop_i2u, r1960);
   ir_expression *const r1965 = lshift(r1964, body.constant(int(23)));
   ir_expression *const r1966 = add(r1963, r1965);
   ir_expression *const r1967 = add(r1966, r1961);
   body.emit(assign(r1962, expr(ir_unop_bitcast_u2f, r1967), 0x01));

   body.emit(ret(r1962));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift32RightJamming(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1968 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1968);
   ir_variable *const r1969 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r1969);
   ir_variable *const r196A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zPtr", ir_var_function_inout);
   sig_parameters.push_tail(r196A);
   ir_variable *const r196B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
   body.emit(r196B);
   /* IF CONDITION */
   ir_expression *const r196D = equal(r1969, body.constant(int(0)));
   ir_if *f196C = new(mem_ctx) ir_if(operand(r196D).val);
   exec_list *const f196C_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f196C->then_instructions;

      body.emit(assign(r196B, r1968, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f196C->else_instructions;

      /* IF CONDITION */
      ir_expression *const r196F = less(r1969, body.constant(int(32)));
      ir_if *f196E = new(mem_ctx) ir_if(operand(r196F).val);
      exec_list *const f196E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f196E->then_instructions;

         ir_expression *const r1970 = rshift(r1968, r1969);
         ir_expression *const r1971 = neg(r1969);
         ir_expression *const r1972 = bit_and(r1971, body.constant(int(31)));
         ir_expression *const r1973 = lshift(r1968, r1972);
         ir_expression *const r1974 = nequal(r1973, body.constant(0u));
         ir_expression *const r1975 = expr(ir_unop_b2i, r1974);
         ir_expression *const r1976 = expr(ir_unop_i2u, r1975);
         body.emit(assign(r196B, bit_or(r1970, r1976), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f196E->else_instructions;

         ir_expression *const r1977 = nequal(r1968, body.constant(0u));
         ir_expression *const r1978 = expr(ir_unop_b2i, r1977);
         body.emit(assign(r196B, expr(ir_unop_i2u, r1978), 0x01));


      body.instructions = f196E_parent_instructions;
      body.emit(f196E);

      /* END IF */


   body.instructions = f196C_parent_instructions;
   body.emit(f196C);

   /* END IF */

   body.emit(assign(r196A, r196B, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
roundAndPackFloat32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::float_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1979 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r1979);
   ir_variable *const r197A = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r197A);
   ir_variable *const r197B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac", ir_var_function_in);
   sig_parameters.push_tail(r197B);
   ir_variable *const r197C = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r197C, body.constant(true), 0x01));

   ir_variable *const r197D = body.make_temp(glsl_type::float_type, "return_value");
   ir_variable *const r197E = new(mem_ctx) ir_variable(glsl_type::int_type, "roundBits", ir_var_auto);
   body.emit(r197E);
   ir_expression *const r197F = bit_and(r197B, body.constant(127u));
   body.emit(assign(r197E, expr(ir_unop_u2i, r197F), 0x01));

   /* IF CONDITION */
   ir_expression *const r1981 = expr(ir_unop_i2u, r197A);
   ir_expression *const r1982 = lequal(body.constant(253u), r1981);
   ir_if *f1980 = new(mem_ctx) ir_if(operand(r1982).val);
   exec_list *const f1980_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1980->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1984 = less(body.constant(int(253)), r197A);
      ir_expression *const r1985 = equal(r197A, body.constant(int(253)));
      ir_expression *const r1986 = expr(ir_unop_u2i, r197B);
      ir_expression *const r1987 = less(r1986, body.constant(int(-64)));
      ir_expression *const r1988 = logic_and(r1985, r1987);
      ir_expression *const r1989 = logic_or(r1984, r1988);
      ir_if *f1983 = new(mem_ctx) ir_if(operand(r1989).val);
      exec_list *const f1983_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1983->then_instructions;

         ir_expression *const r198A = lshift(r1979, body.constant(int(31)));
         ir_expression *const r198B = add(r198A, body.constant(2139095040u));
         body.emit(assign(r197D, expr(ir_unop_bitcast_u2f, r198B), 0x01));

         body.emit(assign(r197C, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1983->else_instructions;

         /* IF CONDITION */
         ir_expression *const r198D = less(r197A, body.constant(int(0)));
         ir_if *f198C = new(mem_ctx) ir_if(operand(r198D).val);
         exec_list *const f198C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f198C->then_instructions;

            ir_variable *const r198E = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r198E, neg(r197A), 0x01));

            ir_variable *const r198F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
            body.emit(r198F);
            /* IF CONDITION */
            ir_expression *const r1991 = equal(r198E, body.constant(int(0)));
            ir_if *f1990 = new(mem_ctx) ir_if(operand(r1991).val);
            exec_list *const f1990_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1990->then_instructions;

               body.emit(assign(r198F, r197B, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1990->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1993 = less(r198E, body.constant(int(32)));
               ir_if *f1992 = new(mem_ctx) ir_if(operand(r1993).val);
               exec_list *const f1992_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1992->then_instructions;

                  ir_expression *const r1994 = rshift(r197B, r198E);
                  ir_expression *const r1995 = neg(r198E);
                  ir_expression *const r1996 = bit_and(r1995, body.constant(int(31)));
                  ir_expression *const r1997 = lshift(r197B, r1996);
                  ir_expression *const r1998 = nequal(r1997, body.constant(0u));
                  ir_expression *const r1999 = expr(ir_unop_b2i, r1998);
                  ir_expression *const r199A = expr(ir_unop_i2u, r1999);
                  body.emit(assign(r198F, bit_or(r1994, r199A), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1992->else_instructions;

                  ir_expression *const r199B = nequal(r197B, body.constant(0u));
                  ir_expression *const r199C = expr(ir_unop_b2i, r199B);
                  body.emit(assign(r198F, expr(ir_unop_i2u, r199C), 0x01));


               body.instructions = f1992_parent_instructions;
               body.emit(f1992);

               /* END IF */


            body.instructions = f1990_parent_instructions;
            body.emit(f1990);

            /* END IF */

            body.emit(assign(r197B, r198F, 0x01));

            body.emit(assign(r197A, body.constant(int(0)), 0x01));

            ir_expression *const r199D = expr(ir_unop_u2i, r198F);
            body.emit(assign(r197E, bit_and(r199D, body.constant(int(127))), 0x01));


         body.instructions = f198C_parent_instructions;
         body.emit(f198C);

         /* END IF */


      body.instructions = f1983_parent_instructions;
      body.emit(f1983);

      /* END IF */


   body.instructions = f1980_parent_instructions;
   body.emit(f1980);

   /* END IF */

   /* IF CONDITION */
   ir_if *f199E = new(mem_ctx) ir_if(operand(r197C).val);
   exec_list *const f199E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f199E->then_instructions;

      ir_expression *const r199F = add(r197B, body.constant(64u));
      body.emit(assign(r197B, rshift(r199F, body.constant(int(7))), 0x01));

      ir_expression *const r19A0 = bit_xor(r197E, body.constant(int(64)));
      ir_expression *const r19A1 = equal(r19A0, body.constant(int(0)));
      ir_expression *const r19A2 = expr(ir_unop_b2i, r19A1);
      ir_expression *const r19A3 = expr(ir_unop_i2u, r19A2);
      ir_expression *const r19A4 = expr(ir_unop_bit_not, r19A3);
      body.emit(assign(r197B, bit_and(r197B, r19A4), 0x01));

      /* IF CONDITION */
      ir_expression *const r19A6 = equal(r197B, body.constant(0u));
      ir_if *f19A5 = new(mem_ctx) ir_if(operand(r19A6).val);
      exec_list *const f19A5_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f19A5->then_instructions;

         body.emit(assign(r197A, body.constant(int(0)), 0x01));


      body.instructions = f19A5_parent_instructions;
      body.emit(f19A5);

      /* END IF */

      ir_expression *const r19A7 = lshift(r1979, body.constant(int(31)));
      ir_expression *const r19A8 = expr(ir_unop_i2u, r197A);
      ir_expression *const r19A9 = lshift(r19A8, body.constant(int(23)));
      ir_expression *const r19AA = add(r19A7, r19A9);
      ir_expression *const r19AB = add(r19AA, r197B);
      body.emit(assign(r197D, expr(ir_unop_bitcast_u2f, r19AB), 0x01));

      body.emit(assign(r197C, body.constant(false), 0x01));


   body.instructions = f199E_parent_instructions;
   body.emit(f199E);

   /* END IF */

   body.emit(ret(r197D));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fp64_to_fp32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::float_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r19AC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r19AC);
   ir_variable *const r19AD = body.make_temp(glsl_type::float_type, "return_value");
   ir_variable *const r19AE = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac", ir_var_auto);
   body.emit(r19AE);
   body.emit(assign(r19AE, body.constant(0u), 0x01));

   ir_variable *const r19AF = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r19AF, swizzle_x(r19AC), 0x01));

   ir_variable *const r19B0 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r19B0, bit_and(swizzle_y(r19AC), body.constant(1048575u)), 0x01));

   ir_variable *const r19B1 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r19B2 = rshift(swizzle_y(r19AC), body.constant(int(20)));
   ir_expression *const r19B3 = bit_and(r19B2, body.constant(2047u));
   body.emit(assign(r19B1, expr(ir_unop_u2i, r19B3), 0x01));

   ir_variable *const r19B4 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r19B4, rshift(swizzle_y(r19AC), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r19B6 = equal(r19B1, body.constant(int(2047)));
   ir_if *f19B5 = new(mem_ctx) ir_if(operand(r19B6).val);
   exec_list *const f19B5_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f19B5->then_instructions;

      /* IF CONDITION */
      ir_expression *const r19B8 = bit_or(r19B0, swizzle_x(r19AC));
      ir_expression *const r19B9 = nequal(r19B8, body.constant(0u));
      ir_if *f19B7 = new(mem_ctx) ir_if(operand(r19B9).val);
      exec_list *const f19B7_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f19B7->then_instructions;

         ir_variable *const r19BA = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r19BA, lshift(swizzle_x(r19AC), body.constant(int(12))), 0x01));

         ir_variable *const r19BB = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         ir_expression *const r19BC = lshift(swizzle_y(r19AC), body.constant(int(12)));
         ir_expression *const r19BD = rshift(swizzle_x(r19AC), body.constant(int(20)));
         body.emit(assign(r19BB, bit_or(r19BC, r19BD), 0x01));

         body.emit(assign(r19AC, r19BB, 0x02));

         body.emit(assign(r19AC, r19BA, 0x01));

         ir_expression *const r19BE = lshift(r19B4, body.constant(int(31)));
         ir_expression *const r19BF = bit_or(r19BE, body.constant(2143289344u));
         ir_expression *const r19C0 = rshift(r19BB, body.constant(int(9)));
         ir_expression *const r19C1 = bit_or(r19BF, r19C0);
         body.emit(assign(r19AD, expr(ir_unop_bitcast_u2f, r19C1), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f19B7->else_instructions;

         ir_expression *const r19C2 = lshift(r19B4, body.constant(int(31)));
         ir_expression *const r19C3 = add(r19C2, body.constant(2139095040u));
         body.emit(assign(r19AD, expr(ir_unop_bitcast_u2f, r19C3), 0x01));


      body.instructions = f19B7_parent_instructions;
      body.emit(f19B7);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f19B5->else_instructions;

      ir_variable *const r19C4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r19C4);
      ir_variable *const r19C5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r19C5);
      ir_expression *const r19C6 = lshift(r19B0, body.constant(int(10)));
      ir_expression *const r19C7 = rshift(r19AF, body.constant(int(22)));
      ir_expression *const r19C8 = bit_or(r19C6, r19C7);
      ir_expression *const r19C9 = lshift(r19AF, body.constant(int(10)));
      ir_expression *const r19CA = nequal(r19C9, body.constant(0u));
      ir_expression *const r19CB = expr(ir_unop_b2i, r19CA);
      ir_expression *const r19CC = expr(ir_unop_i2u, r19CB);
      body.emit(assign(r19C4, bit_or(r19C8, r19CC), 0x01));

      body.emit(assign(r19C5, rshift(r19B0, body.constant(int(22))), 0x01));

      body.emit(assign(r19AE, r19C4, 0x01));

      /* IF CONDITION */
      ir_expression *const r19CE = nequal(r19B1, body.constant(int(0)));
      ir_if *f19CD = new(mem_ctx) ir_if(operand(r19CE).val);
      exec_list *const f19CD_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f19CD->then_instructions;

         body.emit(assign(r19AE, bit_or(r19C4, body.constant(1073741824u)), 0x01));


      body.instructions = f19CD_parent_instructions;
      body.emit(f19CD);

      /* END IF */

      ir_variable *const r19CF = body.make_temp(glsl_type::int_type, "zExp");
      body.emit(assign(r19CF, add(r19B1, body.constant(int(-897))), 0x01));

      ir_variable *const r19D0 = body.make_temp(glsl_type::uint_type, "zFrac");
      body.emit(assign(r19D0, r19AE, 0x01));

      ir_variable *const r19D1 = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r19D1, body.constant(true), 0x01));

      ir_variable *const r19D2 = body.make_temp(glsl_type::float_type, "return_value");
      ir_variable *const r19D3 = new(mem_ctx) ir_variable(glsl_type::int_type, "roundBits", ir_var_auto);
      body.emit(r19D3);
      ir_expression *const r19D4 = bit_and(r19AE, body.constant(127u));
      body.emit(assign(r19D3, expr(ir_unop_u2i, r19D4), 0x01));

      /* IF CONDITION */
      ir_expression *const r19D6 = expr(ir_unop_i2u, r19CF);
      ir_expression *const r19D7 = lequal(body.constant(253u), r19D6);
      ir_if *f19D5 = new(mem_ctx) ir_if(operand(r19D7).val);
      exec_list *const f19D5_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f19D5->then_instructions;

         /* IF CONDITION */
         ir_expression *const r19D9 = less(body.constant(int(253)), r19CF);
         ir_expression *const r19DA = equal(r19CF, body.constant(int(253)));
         ir_expression *const r19DB = expr(ir_unop_u2i, r19AE);
         ir_expression *const r19DC = less(r19DB, body.constant(int(-64)));
         ir_expression *const r19DD = logic_and(r19DA, r19DC);
         ir_expression *const r19DE = logic_or(r19D9, r19DD);
         ir_if *f19D8 = new(mem_ctx) ir_if(operand(r19DE).val);
         exec_list *const f19D8_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f19D8->then_instructions;

            ir_expression *const r19DF = lshift(r19B4, body.constant(int(31)));
            ir_expression *const r19E0 = add(r19DF, body.constant(2139095040u));
            body.emit(assign(r19D2, expr(ir_unop_bitcast_u2f, r19E0), 0x01));

            body.emit(assign(r19D1, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f19D8->else_instructions;

            /* IF CONDITION */
            ir_expression *const r19E2 = less(r19CF, body.constant(int(0)));
            ir_if *f19E1 = new(mem_ctx) ir_if(operand(r19E2).val);
            exec_list *const f19E1_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f19E1->then_instructions;

               ir_variable *const r19E3 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r19E3, neg(r19CF), 0x01));

               ir_variable *const r19E4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r19E4);
               /* IF CONDITION */
               ir_expression *const r19E6 = equal(r19E3, body.constant(int(0)));
               ir_if *f19E5 = new(mem_ctx) ir_if(operand(r19E6).val);
               exec_list *const f19E5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f19E5->then_instructions;

                  body.emit(assign(r19E4, r19AE, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f19E5->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r19E8 = less(r19E3, body.constant(int(32)));
                  ir_if *f19E7 = new(mem_ctx) ir_if(operand(r19E8).val);
                  exec_list *const f19E7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f19E7->then_instructions;

                     ir_expression *const r19E9 = rshift(r19AE, r19E3);
                     ir_expression *const r19EA = neg(r19E3);
                     ir_expression *const r19EB = bit_and(r19EA, body.constant(int(31)));
                     ir_expression *const r19EC = lshift(r19AE, r19EB);
                     ir_expression *const r19ED = nequal(r19EC, body.constant(0u));
                     ir_expression *const r19EE = expr(ir_unop_b2i, r19ED);
                     ir_expression *const r19EF = expr(ir_unop_i2u, r19EE);
                     body.emit(assign(r19E4, bit_or(r19E9, r19EF), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f19E7->else_instructions;

                     ir_expression *const r19F0 = nequal(r19AE, body.constant(0u));
                     ir_expression *const r19F1 = expr(ir_unop_b2i, r19F0);
                     body.emit(assign(r19E4, expr(ir_unop_i2u, r19F1), 0x01));


                  body.instructions = f19E7_parent_instructions;
                  body.emit(f19E7);

                  /* END IF */


               body.instructions = f19E5_parent_instructions;
               body.emit(f19E5);

               /* END IF */

               body.emit(assign(r19D0, r19E4, 0x01));

               body.emit(assign(r19CF, body.constant(int(0)), 0x01));

               ir_expression *const r19F2 = expr(ir_unop_u2i, r19E4);
               body.emit(assign(r19D3, bit_and(r19F2, body.constant(int(127))), 0x01));


            body.instructions = f19E1_parent_instructions;
            body.emit(f19E1);

            /* END IF */


         body.instructions = f19D8_parent_instructions;
         body.emit(f19D8);

         /* END IF */


      body.instructions = f19D5_parent_instructions;
      body.emit(f19D5);

      /* END IF */

      /* IF CONDITION */
      ir_if *f19F3 = new(mem_ctx) ir_if(operand(r19D1).val);
      exec_list *const f19F3_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f19F3->then_instructions;

         ir_expression *const r19F4 = add(r19D0, body.constant(64u));
         body.emit(assign(r19D0, rshift(r19F4, body.constant(int(7))), 0x01));

         ir_expression *const r19F5 = bit_xor(r19D3, body.constant(int(64)));
         ir_expression *const r19F6 = equal(r19F5, body.constant(int(0)));
         ir_expression *const r19F7 = expr(ir_unop_b2i, r19F6);
         ir_expression *const r19F8 = expr(ir_unop_i2u, r19F7);
         ir_expression *const r19F9 = expr(ir_unop_bit_not, r19F8);
         body.emit(assign(r19D0, bit_and(r19D0, r19F9), 0x01));

         /* IF CONDITION */
         ir_expression *const r19FB = equal(r19D0, body.constant(0u));
         ir_if *f19FA = new(mem_ctx) ir_if(operand(r19FB).val);
         exec_list *const f19FA_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f19FA->then_instructions;

            body.emit(assign(r19CF, body.constant(int(0)), 0x01));


         body.instructions = f19FA_parent_instructions;
         body.emit(f19FA);

         /* END IF */

         ir_expression *const r19FC = lshift(r19B4, body.constant(int(31)));
         ir_expression *const r19FD = expr(ir_unop_i2u, r19CF);
         ir_expression *const r19FE = lshift(r19FD, body.constant(int(23)));
         ir_expression *const r19FF = add(r19FC, r19FE);
         ir_expression *const r1A00 = add(r19FF, r19D0);
         body.emit(assign(r19D2, expr(ir_unop_bitcast_u2f, r1A00), 0x01));

         body.emit(assign(r19D1, body.constant(false), 0x01));


      body.instructions = f19F3_parent_instructions;
      body.emit(f19F3);

      /* END IF */

      body.emit(assign(r19AD, r19D2, 0x01));


   body.instructions = f19B5_parent_instructions;
   body.emit(f19B5);

   /* END IF */

   body.emit(ret(r19AD));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fp64_to_int(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::int_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1A01 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1A01);
   ir_variable *const r1A02 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r1A02, body.constant(true), 0x01));

   ir_variable *const r1A03 = body.make_temp(glsl_type::int_type, "return_value");
   ir_variable *const r1A04 = new(mem_ctx) ir_variable(glsl_type::uint_type, "absZ", ir_var_auto);
   body.emit(r1A04);
   ir_variable *const r1A05 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aSign", ir_var_auto);
   body.emit(r1A05);
   ir_variable *const r1A06 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r1A06);
   ir_variable *const r1A07 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r1A07, bit_and(swizzle_y(r1A01), body.constant(1048575u)), 0x01));

   body.emit(assign(r1A06, r1A07, 0x01));

   ir_variable *const r1A08 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r1A09 = rshift(swizzle_y(r1A01), body.constant(int(20)));
   ir_expression *const r1A0A = bit_and(r1A09, body.constant(2047u));
   body.emit(assign(r1A08, expr(ir_unop_u2i, r1A0A), 0x01));

   body.emit(assign(r1A05, rshift(swizzle_y(r1A01), body.constant(int(31))), 0x01));

   body.emit(assign(r1A04, body.constant(0u), 0x01));

   ir_variable *const r1A0B = body.make_temp(glsl_type::int_type, "assignment_tmp");
   body.emit(assign(r1A0B, add(r1A08, body.constant(int(-1043))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1A0D = lequal(body.constant(int(0)), r1A0B);
   ir_if *f1A0C = new(mem_ctx) ir_if(operand(r1A0D).val);
   exec_list *const f1A0C_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A0C->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1A0F = less(body.constant(int(1054)), r1A08);
      ir_if *f1A0E = new(mem_ctx) ir_if(operand(r1A0F).val);
      exec_list *const f1A0E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A0E->then_instructions;

         /* IF CONDITION */
         ir_expression *const r1A11 = equal(r1A08, body.constant(int(2047)));
         ir_expression *const r1A12 = bit_or(r1A07, swizzle_x(r1A01));
         ir_expression *const r1A13 = expr(ir_unop_u2i, r1A12);
         ir_expression *const r1A14 = expr(ir_unop_i2b, r1A13);
         ir_expression *const r1A15 = logic_and(r1A11, r1A14);
         ir_if *f1A10 = new(mem_ctx) ir_if(operand(r1A15).val);
         exec_list *const f1A10_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A10->then_instructions;

            body.emit(assign(r1A05, body.constant(0u), 0x01));


         body.instructions = f1A10_parent_instructions;
         body.emit(f1A10);

         /* END IF */

         ir_variable *const r1A16 = body.make_temp(glsl_type::int_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1A18 = expr(ir_unop_u2i, r1A05);
         ir_expression *const r1A19 = expr(ir_unop_i2b, r1A18);
         ir_if *f1A17 = new(mem_ctx) ir_if(operand(r1A19).val);
         exec_list *const f1A17_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A17->then_instructions;

            body.emit(assign(r1A16, body.constant(int(-2147483648)), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1A17->else_instructions;

            body.emit(assign(r1A16, body.constant(int(2147483647)), 0x01));


         body.instructions = f1A17_parent_instructions;
         body.emit(f1A17);

         /* END IF */

         body.emit(assign(r1A03, r1A16, 0x01));

         body.emit(assign(r1A02, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A0E->else_instructions;

         ir_variable *const r1A1A = body.make_temp(glsl_type::uint_type, "a0");
         body.emit(assign(r1A1A, bit_or(r1A07, body.constant(1048576u)), 0x01));

         ir_variable *const r1A1B = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r1A1B, lshift(swizzle_x(r1A01), r1A0B), 0x01));

         ir_variable *const r1A1C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1A1E = equal(r1A0B, body.constant(int(0)));
         ir_if *f1A1D = new(mem_ctx) ir_if(operand(r1A1E).val);
         exec_list *const f1A1D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A1D->then_instructions;

            body.emit(assign(r1A1C, r1A1A, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1A1D->else_instructions;

            ir_expression *const r1A1F = lshift(r1A1A, r1A0B);
            ir_expression *const r1A20 = neg(r1A0B);
            ir_expression *const r1A21 = bit_and(r1A20, body.constant(int(31)));
            ir_expression *const r1A22 = rshift(swizzle_x(r1A01), r1A21);
            body.emit(assign(r1A1C, bit_or(r1A1F, r1A22), 0x01));


         body.instructions = f1A1D_parent_instructions;
         body.emit(f1A1D);

         /* END IF */

         body.emit(assign(r1A04, r1A1C, 0x01));


      body.instructions = f1A0E_parent_instructions;
      body.emit(f1A0E);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1A0C->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1A24 = less(r1A08, body.constant(int(1023)));
      ir_if *f1A23 = new(mem_ctx) ir_if(operand(r1A24).val);
      exec_list *const f1A23_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A23->then_instructions;

         body.emit(assign(r1A03, body.constant(int(0)), 0x01));

         body.emit(assign(r1A02, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A23->else_instructions;

         body.emit(assign(r1A06, bit_or(r1A07, body.constant(1048576u)), 0x01));

         ir_expression *const r1A25 = neg(r1A0B);
         body.emit(assign(r1A04, rshift(r1A06, r1A25), 0x01));


      body.instructions = f1A23_parent_instructions;
      body.emit(f1A23);

      /* END IF */


   body.instructions = f1A0C_parent_instructions;
   body.emit(f1A0C);

   /* END IF */

   /* IF CONDITION */
   ir_if *f1A26 = new(mem_ctx) ir_if(operand(r1A02).val);
   exec_list *const f1A26_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A26->then_instructions;

      ir_variable *const r1A27 = body.make_temp(glsl_type::int_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r1A29 = nequal(r1A05, body.constant(0u));
      ir_if *f1A28 = new(mem_ctx) ir_if(operand(r1A29).val);
      exec_list *const f1A28_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A28->then_instructions;

         ir_expression *const r1A2A = expr(ir_unop_u2i, r1A04);
         body.emit(assign(r1A27, neg(r1A2A), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A28->else_instructions;

         body.emit(assign(r1A27, expr(ir_unop_u2i, r1A04), 0x01));


      body.instructions = f1A28_parent_instructions;
      body.emit(f1A28);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1A2C = less(r1A27, body.constant(int(0)));
      ir_expression *const r1A2D = expr(ir_unop_b2i, r1A2C);
      ir_expression *const r1A2E = expr(ir_unop_i2u, r1A2D);
      ir_expression *const r1A2F = bit_xor(r1A05, r1A2E);
      ir_expression *const r1A30 = expr(ir_unop_u2i, r1A2F);
      ir_expression *const r1A31 = expr(ir_unop_i2b, r1A30);
      ir_expression *const r1A32 = expr(ir_unop_i2b, r1A27);
      ir_expression *const r1A33 = logic_and(r1A31, r1A32);
      ir_if *f1A2B = new(mem_ctx) ir_if(operand(r1A33).val);
      exec_list *const f1A2B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A2B->then_instructions;

         ir_variable *const r1A34 = body.make_temp(glsl_type::int_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1A36 = expr(ir_unop_u2i, r1A05);
         ir_expression *const r1A37 = expr(ir_unop_i2b, r1A36);
         ir_if *f1A35 = new(mem_ctx) ir_if(operand(r1A37).val);
         exec_list *const f1A35_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A35->then_instructions;

            body.emit(assign(r1A34, body.constant(int(-2147483648)), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1A35->else_instructions;

            body.emit(assign(r1A34, body.constant(int(2147483647)), 0x01));


         body.instructions = f1A35_parent_instructions;
         body.emit(f1A35);

         /* END IF */

         body.emit(assign(r1A03, r1A34, 0x01));

         body.emit(assign(r1A02, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A2B->else_instructions;

         body.emit(assign(r1A03, r1A27, 0x01));

         body.emit(assign(r1A02, body.constant(false), 0x01));


      body.instructions = f1A2B_parent_instructions;
      body.emit(f1A2B);

      /* END IF */


   body.instructions = f1A26_parent_instructions;
   body.emit(f1A26);

   /* END IF */

   body.emit(ret(r1A03));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
int_to_fp64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1A38 = new(mem_ctx) ir_variable(glsl_type::int_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1A38);
   ir_variable *const r1A39 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1A3A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_auto);
   body.emit(r1A3A);
   ir_variable *const r1A3B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r1A3B);
   ir_variable *const r1A3C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r1A3C);
   body.emit(assign(r1A3C, body.constant(0u), 0x01));

   body.emit(assign(r1A3B, body.constant(0u), 0x01));

   /* IF CONDITION */
   ir_expression *const r1A3E = equal(r1A38, body.constant(int(0)));
   ir_if *f1A3D = new(mem_ctx) ir_if(operand(r1A3E).val);
   exec_list *const f1A3D_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A3D->then_instructions;

      ir_variable *const r1A3F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r1A3F);
      body.emit(assign(r1A3F, body.constant(0u), 0x02));

      body.emit(assign(r1A3F, body.constant(0u), 0x01));

      body.emit(assign(r1A39, r1A3F, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1A3D->else_instructions;

      ir_expression *const r1A40 = less(r1A38, body.constant(int(0)));
      ir_expression *const r1A41 = expr(ir_unop_b2i, r1A40);
      body.emit(assign(r1A3A, expr(ir_unop_i2u, r1A41), 0x01));

      ir_variable *const r1A42 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r1A44 = less(r1A38, body.constant(int(0)));
      ir_if *f1A43 = new(mem_ctx) ir_if(operand(r1A44).val);
      exec_list *const f1A43_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A43->then_instructions;

         ir_expression *const r1A45 = neg(r1A38);
         body.emit(assign(r1A42, expr(ir_unop_i2u, r1A45), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A43->else_instructions;

         body.emit(assign(r1A42, expr(ir_unop_i2u, r1A38), 0x01));


      body.instructions = f1A43_parent_instructions;
      body.emit(f1A43);

      /* END IF */

      ir_variable *const r1A46 = body.make_temp(glsl_type::uint_type, "a");
      body.emit(assign(r1A46, r1A42, 0x01));

      ir_variable *const r1A47 = body.make_temp(glsl_type::int_type, "return_value");
      ir_variable *const r1A48 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
      body.emit(r1A48);
      /* IF CONDITION */
      ir_expression *const r1A4A = equal(r1A42, body.constant(0u));
      ir_if *f1A49 = new(mem_ctx) ir_if(operand(r1A4A).val);
      exec_list *const f1A49_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A49->then_instructions;

         body.emit(assign(r1A47, body.constant(int(32)), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A49->else_instructions;

         body.emit(assign(r1A48, body.constant(int(0)), 0x01));

         /* IF CONDITION */
         ir_expression *const r1A4C = bit_and(r1A42, body.constant(4294901760u));
         ir_expression *const r1A4D = equal(r1A4C, body.constant(0u));
         ir_if *f1A4B = new(mem_ctx) ir_if(operand(r1A4D).val);
         exec_list *const f1A4B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A4B->then_instructions;

            body.emit(assign(r1A48, body.constant(int(16)), 0x01));

            body.emit(assign(r1A46, lshift(r1A42, body.constant(int(16))), 0x01));


         body.instructions = f1A4B_parent_instructions;
         body.emit(f1A4B);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1A4F = bit_and(r1A46, body.constant(4278190080u));
         ir_expression *const r1A50 = equal(r1A4F, body.constant(0u));
         ir_if *f1A4E = new(mem_ctx) ir_if(operand(r1A50).val);
         exec_list *const f1A4E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A4E->then_instructions;

            body.emit(assign(r1A48, add(r1A48, body.constant(int(8))), 0x01));

            body.emit(assign(r1A46, lshift(r1A46, body.constant(int(8))), 0x01));


         body.instructions = f1A4E_parent_instructions;
         body.emit(f1A4E);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1A52 = bit_and(r1A46, body.constant(4026531840u));
         ir_expression *const r1A53 = equal(r1A52, body.constant(0u));
         ir_if *f1A51 = new(mem_ctx) ir_if(operand(r1A53).val);
         exec_list *const f1A51_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A51->then_instructions;

            body.emit(assign(r1A48, add(r1A48, body.constant(int(4))), 0x01));

            body.emit(assign(r1A46, lshift(r1A46, body.constant(int(4))), 0x01));


         body.instructions = f1A51_parent_instructions;
         body.emit(f1A51);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1A55 = bit_and(r1A46, body.constant(3221225472u));
         ir_expression *const r1A56 = equal(r1A55, body.constant(0u));
         ir_if *f1A54 = new(mem_ctx) ir_if(operand(r1A56).val);
         exec_list *const f1A54_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A54->then_instructions;

            body.emit(assign(r1A48, add(r1A48, body.constant(int(2))), 0x01));

            body.emit(assign(r1A46, lshift(r1A46, body.constant(int(2))), 0x01));


         body.instructions = f1A54_parent_instructions;
         body.emit(f1A54);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1A58 = bit_and(r1A46, body.constant(2147483648u));
         ir_expression *const r1A59 = equal(r1A58, body.constant(0u));
         ir_if *f1A57 = new(mem_ctx) ir_if(operand(r1A59).val);
         exec_list *const f1A57_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A57->then_instructions;

            body.emit(assign(r1A48, add(r1A48, body.constant(int(1))), 0x01));


         body.instructions = f1A57_parent_instructions;
         body.emit(f1A57);

         /* END IF */

         body.emit(assign(r1A47, r1A48, 0x01));


      body.instructions = f1A49_parent_instructions;
      body.emit(f1A49);

      /* END IF */

      ir_variable *const r1A5A = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r1A5A, add(r1A47, body.constant(int(-11))), 0x01));

      /* IF CONDITION */
      ir_expression *const r1A5C = lequal(body.constant(int(0)), r1A5A);
      ir_if *f1A5B = new(mem_ctx) ir_if(operand(r1A5C).val);
      exec_list *const f1A5B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A5B->then_instructions;

         body.emit(assign(r1A3C, lshift(r1A42, r1A5A), 0x01));

         body.emit(assign(r1A3B, body.constant(0u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A5B->else_instructions;

         ir_variable *const r1A5D = body.make_temp(glsl_type::uint_type, "a1");
         body.emit(assign(r1A5D, body.constant(0u), 0x01));

         ir_variable *const r1A5E = body.make_temp(glsl_type::int_type, "count");
         body.emit(assign(r1A5E, neg(r1A5A), 0x01));

         ir_variable *const r1A5F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r1A5F);
         ir_variable *const r1A60 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r1A60);
         ir_variable *const r1A61 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         ir_expression *const r1A62 = neg(r1A5E);
         body.emit(assign(r1A61, bit_and(r1A62, body.constant(int(31))), 0x01));

         /* IF CONDITION */
         ir_expression *const r1A64 = equal(r1A5E, body.constant(int(0)));
         ir_if *f1A63 = new(mem_ctx) ir_if(operand(r1A64).val);
         exec_list *const f1A63_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A63->then_instructions;

            body.emit(assign(r1A5F, body.constant(0u), 0x01));

            body.emit(assign(r1A60, r1A42, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1A63->else_instructions;

            /* IF CONDITION */
            ir_expression *const r1A66 = less(r1A5E, body.constant(int(32)));
            ir_if *f1A65 = new(mem_ctx) ir_if(operand(r1A66).val);
            exec_list *const f1A65_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1A65->then_instructions;

               ir_expression *const r1A67 = lshift(r1A42, r1A61);
               body.emit(assign(r1A5F, bit_or(r1A67, body.constant(0u)), 0x01));

               body.emit(assign(r1A60, rshift(r1A42, r1A5E), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1A65->else_instructions;

               ir_variable *const r1A68 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r1A6A = less(r1A5E, body.constant(int(64)));
               ir_if *f1A69 = new(mem_ctx) ir_if(operand(r1A6A).val);
               exec_list *const f1A69_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1A69->then_instructions;

                  ir_expression *const r1A6B = bit_and(r1A5E, body.constant(int(31)));
                  body.emit(assign(r1A68, rshift(r1A42, r1A6B), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1A69->else_instructions;

                  body.emit(assign(r1A68, body.constant(0u), 0x01));


               body.instructions = f1A69_parent_instructions;
               body.emit(f1A69);

               /* END IF */

               body.emit(assign(r1A5F, r1A68, 0x01));

               body.emit(assign(r1A60, body.constant(0u), 0x01));


            body.instructions = f1A65_parent_instructions;
            body.emit(f1A65);

            /* END IF */


         body.instructions = f1A63_parent_instructions;
         body.emit(f1A63);

         /* END IF */

         body.emit(assign(r1A3C, r1A60, 0x01));

         body.emit(assign(r1A3B, r1A5F, 0x01));


      body.instructions = f1A5B_parent_instructions;
      body.emit(f1A5B);

      /* END IF */

      ir_variable *const r1A6C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r1A6C);
      ir_expression *const r1A6D = lshift(r1A3A, body.constant(int(31)));
      ir_expression *const r1A6E = sub(body.constant(int(1042)), r1A5A);
      ir_expression *const r1A6F = expr(ir_unop_i2u, r1A6E);
      ir_expression *const r1A70 = lshift(r1A6F, body.constant(int(20)));
      ir_expression *const r1A71 = add(r1A6D, r1A70);
      body.emit(assign(r1A6C, add(r1A71, r1A3C), 0x02));

      body.emit(assign(r1A6C, r1A3B, 0x01));

      body.emit(assign(r1A39, r1A6C, 0x03));


   body.instructions = f1A3D_parent_instructions;
   body.emit(f1A3D);

   /* END IF */

   body.emit(ret(r1A39));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
sqrtOddAdjustments(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1A72 = new(mem_ctx) ir_variable(glsl_type::int_type, "index", ir_var_function_in);
   sig_parameters.push_tail(r1A72);
   ir_variable *const r1A73 = new(mem_ctx) ir_variable(glsl_type::uint_type, "res", ir_var_auto);
   body.emit(r1A73);
   body.emit(assign(r1A73, body.constant(0u), 0x01));

   /* IF CONDITION */
   ir_expression *const r1A75 = equal(r1A72, body.constant(int(0)));
   ir_if *f1A74 = new(mem_ctx) ir_if(operand(r1A75).val);
   exec_list *const f1A74_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A74->then_instructions;

      body.emit(assign(r1A73, body.constant(4u), 0x01));


   body.instructions = f1A74_parent_instructions;
   body.emit(f1A74);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A77 = equal(r1A72, body.constant(int(1)));
   ir_if *f1A76 = new(mem_ctx) ir_if(operand(r1A77).val);
   exec_list *const f1A76_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A76->then_instructions;

      body.emit(assign(r1A73, body.constant(34u), 0x01));


   body.instructions = f1A76_parent_instructions;
   body.emit(f1A76);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A79 = equal(r1A72, body.constant(int(2)));
   ir_if *f1A78 = new(mem_ctx) ir_if(operand(r1A79).val);
   exec_list *const f1A78_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A78->then_instructions;

      body.emit(assign(r1A73, body.constant(93u), 0x01));


   body.instructions = f1A78_parent_instructions;
   body.emit(f1A78);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A7B = equal(r1A72, body.constant(int(3)));
   ir_if *f1A7A = new(mem_ctx) ir_if(operand(r1A7B).val);
   exec_list *const f1A7A_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A7A->then_instructions;

      body.emit(assign(r1A73, body.constant(177u), 0x01));


   body.instructions = f1A7A_parent_instructions;
   body.emit(f1A7A);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A7D = equal(r1A72, body.constant(int(4)));
   ir_if *f1A7C = new(mem_ctx) ir_if(operand(r1A7D).val);
   exec_list *const f1A7C_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A7C->then_instructions;

      body.emit(assign(r1A73, body.constant(285u), 0x01));


   body.instructions = f1A7C_parent_instructions;
   body.emit(f1A7C);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A7F = equal(r1A72, body.constant(int(5)));
   ir_if *f1A7E = new(mem_ctx) ir_if(operand(r1A7F).val);
   exec_list *const f1A7E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A7E->then_instructions;

      body.emit(assign(r1A73, body.constant(415u), 0x01));


   body.instructions = f1A7E_parent_instructions;
   body.emit(f1A7E);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A81 = equal(r1A72, body.constant(int(6)));
   ir_if *f1A80 = new(mem_ctx) ir_if(operand(r1A81).val);
   exec_list *const f1A80_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A80->then_instructions;

      body.emit(assign(r1A73, body.constant(566u), 0x01));


   body.instructions = f1A80_parent_instructions;
   body.emit(f1A80);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A83 = equal(r1A72, body.constant(int(7)));
   ir_if *f1A82 = new(mem_ctx) ir_if(operand(r1A83).val);
   exec_list *const f1A82_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A82->then_instructions;

      body.emit(assign(r1A73, body.constant(736u), 0x01));


   body.instructions = f1A82_parent_instructions;
   body.emit(f1A82);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A85 = equal(r1A72, body.constant(int(8)));
   ir_if *f1A84 = new(mem_ctx) ir_if(operand(r1A85).val);
   exec_list *const f1A84_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A84->then_instructions;

      body.emit(assign(r1A73, body.constant(924u), 0x01));


   body.instructions = f1A84_parent_instructions;
   body.emit(f1A84);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A87 = equal(r1A72, body.constant(int(9)));
   ir_if *f1A86 = new(mem_ctx) ir_if(operand(r1A87).val);
   exec_list *const f1A86_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A86->then_instructions;

      body.emit(assign(r1A73, body.constant(1128u), 0x01));


   body.instructions = f1A86_parent_instructions;
   body.emit(f1A86);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A89 = equal(r1A72, body.constant(int(10)));
   ir_if *f1A88 = new(mem_ctx) ir_if(operand(r1A89).val);
   exec_list *const f1A88_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A88->then_instructions;

      body.emit(assign(r1A73, body.constant(1349u), 0x01));


   body.instructions = f1A88_parent_instructions;
   body.emit(f1A88);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A8B = equal(r1A72, body.constant(int(11)));
   ir_if *f1A8A = new(mem_ctx) ir_if(operand(r1A8B).val);
   exec_list *const f1A8A_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A8A->then_instructions;

      body.emit(assign(r1A73, body.constant(1585u), 0x01));


   body.instructions = f1A8A_parent_instructions;
   body.emit(f1A8A);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A8D = equal(r1A72, body.constant(int(12)));
   ir_if *f1A8C = new(mem_ctx) ir_if(operand(r1A8D).val);
   exec_list *const f1A8C_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A8C->then_instructions;

      body.emit(assign(r1A73, body.constant(1835u), 0x01));


   body.instructions = f1A8C_parent_instructions;
   body.emit(f1A8C);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A8F = equal(r1A72, body.constant(int(13)));
   ir_if *f1A8E = new(mem_ctx) ir_if(operand(r1A8F).val);
   exec_list *const f1A8E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A8E->then_instructions;

      body.emit(assign(r1A73, body.constant(2098u), 0x01));


   body.instructions = f1A8E_parent_instructions;
   body.emit(f1A8E);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A91 = equal(r1A72, body.constant(int(14)));
   ir_if *f1A90 = new(mem_ctx) ir_if(operand(r1A91).val);
   exec_list *const f1A90_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A90->then_instructions;

      body.emit(assign(r1A73, body.constant(2374u), 0x01));


   body.instructions = f1A90_parent_instructions;
   body.emit(f1A90);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A93 = equal(r1A72, body.constant(int(15)));
   ir_if *f1A92 = new(mem_ctx) ir_if(operand(r1A93).val);
   exec_list *const f1A92_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A92->then_instructions;

      body.emit(assign(r1A73, body.constant(2663u), 0x01));


   body.instructions = f1A92_parent_instructions;
   body.emit(f1A92);

   /* END IF */

   body.emit(ret(r1A73));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
sqrtEvenAdjustments(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1A94 = new(mem_ctx) ir_variable(glsl_type::int_type, "index", ir_var_function_in);
   sig_parameters.push_tail(r1A94);
   ir_variable *const r1A95 = new(mem_ctx) ir_variable(glsl_type::uint_type, "res", ir_var_auto);
   body.emit(r1A95);
   body.emit(assign(r1A95, body.constant(0u), 0x01));

   /* IF CONDITION */
   ir_expression *const r1A97 = equal(r1A94, body.constant(int(0)));
   ir_if *f1A96 = new(mem_ctx) ir_if(operand(r1A97).val);
   exec_list *const f1A96_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A96->then_instructions;

      body.emit(assign(r1A95, body.constant(2605u), 0x01));


   body.instructions = f1A96_parent_instructions;
   body.emit(f1A96);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A99 = equal(r1A94, body.constant(int(1)));
   ir_if *f1A98 = new(mem_ctx) ir_if(operand(r1A99).val);
   exec_list *const f1A98_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A98->then_instructions;

      body.emit(assign(r1A95, body.constant(2223u), 0x01));


   body.instructions = f1A98_parent_instructions;
   body.emit(f1A98);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A9B = equal(r1A94, body.constant(int(2)));
   ir_if *f1A9A = new(mem_ctx) ir_if(operand(r1A9B).val);
   exec_list *const f1A9A_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A9A->then_instructions;

      body.emit(assign(r1A95, body.constant(1882u), 0x01));


   body.instructions = f1A9A_parent_instructions;
   body.emit(f1A9A);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A9D = equal(r1A94, body.constant(int(3)));
   ir_if *f1A9C = new(mem_ctx) ir_if(operand(r1A9D).val);
   exec_list *const f1A9C_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A9C->then_instructions;

      body.emit(assign(r1A95, body.constant(1577u), 0x01));


   body.instructions = f1A9C_parent_instructions;
   body.emit(f1A9C);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1A9F = equal(r1A94, body.constant(int(4)));
   ir_if *f1A9E = new(mem_ctx) ir_if(operand(r1A9F).val);
   exec_list *const f1A9E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A9E->then_instructions;

      body.emit(assign(r1A95, body.constant(1306u), 0x01));


   body.instructions = f1A9E_parent_instructions;
   body.emit(f1A9E);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AA1 = equal(r1A94, body.constant(int(5)));
   ir_if *f1AA0 = new(mem_ctx) ir_if(operand(r1AA1).val);
   exec_list *const f1AA0_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AA0->then_instructions;

      body.emit(assign(r1A95, body.constant(1065u), 0x01));


   body.instructions = f1AA0_parent_instructions;
   body.emit(f1AA0);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AA3 = equal(r1A94, body.constant(int(6)));
   ir_if *f1AA2 = new(mem_ctx) ir_if(operand(r1AA3).val);
   exec_list *const f1AA2_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AA2->then_instructions;

      body.emit(assign(r1A95, body.constant(854u), 0x01));


   body.instructions = f1AA2_parent_instructions;
   body.emit(f1AA2);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AA5 = equal(r1A94, body.constant(int(7)));
   ir_if *f1AA4 = new(mem_ctx) ir_if(operand(r1AA5).val);
   exec_list *const f1AA4_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AA4->then_instructions;

      body.emit(assign(r1A95, body.constant(670u), 0x01));


   body.instructions = f1AA4_parent_instructions;
   body.emit(f1AA4);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AA7 = equal(r1A94, body.constant(int(8)));
   ir_if *f1AA6 = new(mem_ctx) ir_if(operand(r1AA7).val);
   exec_list *const f1AA6_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AA6->then_instructions;

      body.emit(assign(r1A95, body.constant(512u), 0x01));


   body.instructions = f1AA6_parent_instructions;
   body.emit(f1AA6);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AA9 = equal(r1A94, body.constant(int(9)));
   ir_if *f1AA8 = new(mem_ctx) ir_if(operand(r1AA9).val);
   exec_list *const f1AA8_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AA8->then_instructions;

      body.emit(assign(r1A95, body.constant(377u), 0x01));


   body.instructions = f1AA8_parent_instructions;
   body.emit(f1AA8);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AAB = equal(r1A94, body.constant(int(10)));
   ir_if *f1AAA = new(mem_ctx) ir_if(operand(r1AAB).val);
   exec_list *const f1AAA_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AAA->then_instructions;

      body.emit(assign(r1A95, body.constant(265u), 0x01));


   body.instructions = f1AAA_parent_instructions;
   body.emit(f1AAA);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AAD = equal(r1A94, body.constant(int(11)));
   ir_if *f1AAC = new(mem_ctx) ir_if(operand(r1AAD).val);
   exec_list *const f1AAC_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AAC->then_instructions;

      body.emit(assign(r1A95, body.constant(175u), 0x01));


   body.instructions = f1AAC_parent_instructions;
   body.emit(f1AAC);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AAF = equal(r1A94, body.constant(int(12)));
   ir_if *f1AAE = new(mem_ctx) ir_if(operand(r1AAF).val);
   exec_list *const f1AAE_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AAE->then_instructions;

      body.emit(assign(r1A95, body.constant(104u), 0x01));


   body.instructions = f1AAE_parent_instructions;
   body.emit(f1AAE);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AB1 = equal(r1A94, body.constant(int(13)));
   ir_if *f1AB0 = new(mem_ctx) ir_if(operand(r1AB1).val);
   exec_list *const f1AB0_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AB0->then_instructions;

      body.emit(assign(r1A95, body.constant(52u), 0x01));


   body.instructions = f1AB0_parent_instructions;
   body.emit(f1AB0);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AB3 = equal(r1A94, body.constant(int(14)));
   ir_if *f1AB2 = new(mem_ctx) ir_if(operand(r1AB3).val);
   exec_list *const f1AB2_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AB2->then_instructions;

      body.emit(assign(r1A95, body.constant(18u), 0x01));


   body.instructions = f1AB2_parent_instructions;
   body.emit(f1AB2);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AB5 = equal(r1A94, body.constant(int(15)));
   ir_if *f1AB4 = new(mem_ctx) ir_if(operand(r1AB5).val);
   exec_list *const f1AB4_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AB4->then_instructions;

      body.emit(assign(r1A95, body.constant(2u), 0x01));


   body.instructions = f1AB4_parent_instructions;
   body.emit(f1AB4);

   /* END IF */

   body.emit(ret(r1A95));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
estimateSqrt32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1AB6 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_function_in);
   sig_parameters.push_tail(r1AB6);
   ir_variable *const r1AB7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1AB7);
   ir_variable *const r1AB8 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r1AB8, body.constant(true), 0x01));

   ir_variable *const r1AB9 = body.make_temp(glsl_type::uint_type, "return_value");
   ir_variable *const r1ABA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
   body.emit(r1ABA);
   ir_variable *const r1ABB = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r1ABC = rshift(r1AB7, body.constant(int(27)));
   ir_expression *const r1ABD = bit_and(r1ABC, body.constant(15u));
   body.emit(assign(r1ABB, expr(ir_unop_u2i, r1ABD), 0x01));

   /* IF CONDITION */
   ir_expression *const r1ABF = bit_and(r1AB6, body.constant(int(1)));
   ir_expression *const r1AC0 = nequal(r1ABF, body.constant(int(0)));
   ir_if *f1ABE = new(mem_ctx) ir_if(operand(r1AC0).val);
   exec_list *const f1ABE_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1ABE->then_instructions;

      ir_variable *const r1AC1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "res", ir_var_auto);
      body.emit(r1AC1);
      body.emit(assign(r1AC1, body.constant(0u), 0x01));

      /* IF CONDITION */
      ir_expression *const r1AC3 = equal(r1ABB, body.constant(int(0)));
      ir_if *f1AC2 = new(mem_ctx) ir_if(operand(r1AC3).val);
      exec_list *const f1AC2_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AC2->then_instructions;

         body.emit(assign(r1AC1, body.constant(4u), 0x01));


      body.instructions = f1AC2_parent_instructions;
      body.emit(f1AC2);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AC5 = equal(r1ABB, body.constant(int(1)));
      ir_if *f1AC4 = new(mem_ctx) ir_if(operand(r1AC5).val);
      exec_list *const f1AC4_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AC4->then_instructions;

         body.emit(assign(r1AC1, body.constant(34u), 0x01));


      body.instructions = f1AC4_parent_instructions;
      body.emit(f1AC4);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AC7 = equal(r1ABB, body.constant(int(2)));
      ir_if *f1AC6 = new(mem_ctx) ir_if(operand(r1AC7).val);
      exec_list *const f1AC6_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AC6->then_instructions;

         body.emit(assign(r1AC1, body.constant(93u), 0x01));


      body.instructions = f1AC6_parent_instructions;
      body.emit(f1AC6);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AC9 = equal(r1ABB, body.constant(int(3)));
      ir_if *f1AC8 = new(mem_ctx) ir_if(operand(r1AC9).val);
      exec_list *const f1AC8_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AC8->then_instructions;

         body.emit(assign(r1AC1, body.constant(177u), 0x01));


      body.instructions = f1AC8_parent_instructions;
      body.emit(f1AC8);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1ACB = equal(r1ABB, body.constant(int(4)));
      ir_if *f1ACA = new(mem_ctx) ir_if(operand(r1ACB).val);
      exec_list *const f1ACA_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1ACA->then_instructions;

         body.emit(assign(r1AC1, body.constant(285u), 0x01));


      body.instructions = f1ACA_parent_instructions;
      body.emit(f1ACA);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1ACD = equal(r1ABB, body.constant(int(5)));
      ir_if *f1ACC = new(mem_ctx) ir_if(operand(r1ACD).val);
      exec_list *const f1ACC_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1ACC->then_instructions;

         body.emit(assign(r1AC1, body.constant(415u), 0x01));


      body.instructions = f1ACC_parent_instructions;
      body.emit(f1ACC);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1ACF = equal(r1ABB, body.constant(int(6)));
      ir_if *f1ACE = new(mem_ctx) ir_if(operand(r1ACF).val);
      exec_list *const f1ACE_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1ACE->then_instructions;

         body.emit(assign(r1AC1, body.constant(566u), 0x01));


      body.instructions = f1ACE_parent_instructions;
      body.emit(f1ACE);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AD1 = equal(r1ABB, body.constant(int(7)));
      ir_if *f1AD0 = new(mem_ctx) ir_if(operand(r1AD1).val);
      exec_list *const f1AD0_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AD0->then_instructions;

         body.emit(assign(r1AC1, body.constant(736u), 0x01));


      body.instructions = f1AD0_parent_instructions;
      body.emit(f1AD0);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AD3 = equal(r1ABB, body.constant(int(8)));
      ir_if *f1AD2 = new(mem_ctx) ir_if(operand(r1AD3).val);
      exec_list *const f1AD2_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AD2->then_instructions;

         body.emit(assign(r1AC1, body.constant(924u), 0x01));


      body.instructions = f1AD2_parent_instructions;
      body.emit(f1AD2);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AD5 = equal(r1ABB, body.constant(int(9)));
      ir_if *f1AD4 = new(mem_ctx) ir_if(operand(r1AD5).val);
      exec_list *const f1AD4_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AD4->then_instructions;

         body.emit(assign(r1AC1, body.constant(1128u), 0x01));


      body.instructions = f1AD4_parent_instructions;
      body.emit(f1AD4);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AD7 = equal(r1ABB, body.constant(int(10)));
      ir_if *f1AD6 = new(mem_ctx) ir_if(operand(r1AD7).val);
      exec_list *const f1AD6_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AD6->then_instructions;

         body.emit(assign(r1AC1, body.constant(1349u), 0x01));


      body.instructions = f1AD6_parent_instructions;
      body.emit(f1AD6);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AD9 = equal(r1ABB, body.constant(int(11)));
      ir_if *f1AD8 = new(mem_ctx) ir_if(operand(r1AD9).val);
      exec_list *const f1AD8_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AD8->then_instructions;

         body.emit(assign(r1AC1, body.constant(1585u), 0x01));


      body.instructions = f1AD8_parent_instructions;
      body.emit(f1AD8);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1ADB = equal(r1ABB, body.constant(int(12)));
      ir_if *f1ADA = new(mem_ctx) ir_if(operand(r1ADB).val);
      exec_list *const f1ADA_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1ADA->then_instructions;

         body.emit(assign(r1AC1, body.constant(1835u), 0x01));


      body.instructions = f1ADA_parent_instructions;
      body.emit(f1ADA);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1ADD = equal(r1ABB, body.constant(int(13)));
      ir_if *f1ADC = new(mem_ctx) ir_if(operand(r1ADD).val);
      exec_list *const f1ADC_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1ADC->then_instructions;

         body.emit(assign(r1AC1, body.constant(2098u), 0x01));


      body.instructions = f1ADC_parent_instructions;
      body.emit(f1ADC);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1ADF = equal(r1ABB, body.constant(int(14)));
      ir_if *f1ADE = new(mem_ctx) ir_if(operand(r1ADF).val);
      exec_list *const f1ADE_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1ADE->then_instructions;

         body.emit(assign(r1AC1, body.constant(2374u), 0x01));


      body.instructions = f1ADE_parent_instructions;
      body.emit(f1ADE);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AE1 = equal(r1ABB, body.constant(int(15)));
      ir_if *f1AE0 = new(mem_ctx) ir_if(operand(r1AE1).val);
      exec_list *const f1AE0_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AE0->then_instructions;

         body.emit(assign(r1AC1, body.constant(2663u), 0x01));


      body.instructions = f1AE0_parent_instructions;
      body.emit(f1AE0);

      /* END IF */

      ir_expression *const r1AE2 = rshift(r1AB7, body.constant(int(17)));
      ir_expression *const r1AE3 = add(body.constant(16384u), r1AE2);
      body.emit(assign(r1ABA, sub(r1AE3, r1AC1), 0x01));

      ir_expression *const r1AE4 = expr(ir_binop_div, r1AB7, r1ABA);
      ir_expression *const r1AE5 = lshift(r1AE4, body.constant(int(14)));
      ir_expression *const r1AE6 = lshift(r1ABA, body.constant(int(15)));
      body.emit(assign(r1ABA, add(r1AE5, r1AE6), 0x01));

      body.emit(assign(r1AB7, rshift(r1AB7, body.constant(int(1))), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1ABE->else_instructions;

      ir_variable *const r1AE7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "res", ir_var_auto);
      body.emit(r1AE7);
      body.emit(assign(r1AE7, body.constant(0u), 0x01));

      /* IF CONDITION */
      ir_expression *const r1AE9 = equal(r1ABB, body.constant(int(0)));
      ir_if *f1AE8 = new(mem_ctx) ir_if(operand(r1AE9).val);
      exec_list *const f1AE8_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AE8->then_instructions;

         body.emit(assign(r1AE7, body.constant(2605u), 0x01));


      body.instructions = f1AE8_parent_instructions;
      body.emit(f1AE8);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AEB = equal(r1ABB, body.constant(int(1)));
      ir_if *f1AEA = new(mem_ctx) ir_if(operand(r1AEB).val);
      exec_list *const f1AEA_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AEA->then_instructions;

         body.emit(assign(r1AE7, body.constant(2223u), 0x01));


      body.instructions = f1AEA_parent_instructions;
      body.emit(f1AEA);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AED = equal(r1ABB, body.constant(int(2)));
      ir_if *f1AEC = new(mem_ctx) ir_if(operand(r1AED).val);
      exec_list *const f1AEC_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AEC->then_instructions;

         body.emit(assign(r1AE7, body.constant(1882u), 0x01));


      body.instructions = f1AEC_parent_instructions;
      body.emit(f1AEC);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AEF = equal(r1ABB, body.constant(int(3)));
      ir_if *f1AEE = new(mem_ctx) ir_if(operand(r1AEF).val);
      exec_list *const f1AEE_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AEE->then_instructions;

         body.emit(assign(r1AE7, body.constant(1577u), 0x01));


      body.instructions = f1AEE_parent_instructions;
      body.emit(f1AEE);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AF1 = equal(r1ABB, body.constant(int(4)));
      ir_if *f1AF0 = new(mem_ctx) ir_if(operand(r1AF1).val);
      exec_list *const f1AF0_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AF0->then_instructions;

         body.emit(assign(r1AE7, body.constant(1306u), 0x01));


      body.instructions = f1AF0_parent_instructions;
      body.emit(f1AF0);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AF3 = equal(r1ABB, body.constant(int(5)));
      ir_if *f1AF2 = new(mem_ctx) ir_if(operand(r1AF3).val);
      exec_list *const f1AF2_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AF2->then_instructions;

         body.emit(assign(r1AE7, body.constant(1065u), 0x01));


      body.instructions = f1AF2_parent_instructions;
      body.emit(f1AF2);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AF5 = equal(r1ABB, body.constant(int(6)));
      ir_if *f1AF4 = new(mem_ctx) ir_if(operand(r1AF5).val);
      exec_list *const f1AF4_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AF4->then_instructions;

         body.emit(assign(r1AE7, body.constant(854u), 0x01));


      body.instructions = f1AF4_parent_instructions;
      body.emit(f1AF4);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AF7 = equal(r1ABB, body.constant(int(7)));
      ir_if *f1AF6 = new(mem_ctx) ir_if(operand(r1AF7).val);
      exec_list *const f1AF6_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AF6->then_instructions;

         body.emit(assign(r1AE7, body.constant(670u), 0x01));


      body.instructions = f1AF6_parent_instructions;
      body.emit(f1AF6);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AF9 = equal(r1ABB, body.constant(int(8)));
      ir_if *f1AF8 = new(mem_ctx) ir_if(operand(r1AF9).val);
      exec_list *const f1AF8_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AF8->then_instructions;

         body.emit(assign(r1AE7, body.constant(512u), 0x01));


      body.instructions = f1AF8_parent_instructions;
      body.emit(f1AF8);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AFB = equal(r1ABB, body.constant(int(9)));
      ir_if *f1AFA = new(mem_ctx) ir_if(operand(r1AFB).val);
      exec_list *const f1AFA_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AFA->then_instructions;

         body.emit(assign(r1AE7, body.constant(377u), 0x01));


      body.instructions = f1AFA_parent_instructions;
      body.emit(f1AFA);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AFD = equal(r1ABB, body.constant(int(10)));
      ir_if *f1AFC = new(mem_ctx) ir_if(operand(r1AFD).val);
      exec_list *const f1AFC_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AFC->then_instructions;

         body.emit(assign(r1AE7, body.constant(265u), 0x01));


      body.instructions = f1AFC_parent_instructions;
      body.emit(f1AFC);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1AFF = equal(r1ABB, body.constant(int(11)));
      ir_if *f1AFE = new(mem_ctx) ir_if(operand(r1AFF).val);
      exec_list *const f1AFE_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AFE->then_instructions;

         body.emit(assign(r1AE7, body.constant(175u), 0x01));


      body.instructions = f1AFE_parent_instructions;
      body.emit(f1AFE);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B01 = equal(r1ABB, body.constant(int(12)));
      ir_if *f1B00 = new(mem_ctx) ir_if(operand(r1B01).val);
      exec_list *const f1B00_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B00->then_instructions;

         body.emit(assign(r1AE7, body.constant(104u), 0x01));


      body.instructions = f1B00_parent_instructions;
      body.emit(f1B00);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B03 = equal(r1ABB, body.constant(int(13)));
      ir_if *f1B02 = new(mem_ctx) ir_if(operand(r1B03).val);
      exec_list *const f1B02_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B02->then_instructions;

         body.emit(assign(r1AE7, body.constant(52u), 0x01));


      body.instructions = f1B02_parent_instructions;
      body.emit(f1B02);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B05 = equal(r1ABB, body.constant(int(14)));
      ir_if *f1B04 = new(mem_ctx) ir_if(operand(r1B05).val);
      exec_list *const f1B04_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B04->then_instructions;

         body.emit(assign(r1AE7, body.constant(18u), 0x01));


      body.instructions = f1B04_parent_instructions;
      body.emit(f1B04);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B07 = equal(r1ABB, body.constant(int(15)));
      ir_if *f1B06 = new(mem_ctx) ir_if(operand(r1B07).val);
      exec_list *const f1B06_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B06->then_instructions;

         body.emit(assign(r1AE7, body.constant(2u), 0x01));


      body.instructions = f1B06_parent_instructions;
      body.emit(f1B06);

      /* END IF */

      ir_expression *const r1B08 = rshift(r1AB7, body.constant(int(17)));
      ir_expression *const r1B09 = add(body.constant(32768u), r1B08);
      body.emit(assign(r1ABA, sub(r1B09, r1AE7), 0x01));

      ir_expression *const r1B0A = expr(ir_binop_div, r1AB7, r1ABA);
      body.emit(assign(r1ABA, add(r1B0A, r1ABA), 0x01));

      ir_variable *const r1B0B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r1B0D = lequal(body.constant(131072u), r1ABA);
      ir_if *f1B0C = new(mem_ctx) ir_if(operand(r1B0D).val);
      exec_list *const f1B0C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B0C->then_instructions;

         body.emit(assign(r1B0B, body.constant(4294934528u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1B0C->else_instructions;

         body.emit(assign(r1B0B, lshift(r1ABA, body.constant(int(15))), 0x01));


      body.instructions = f1B0C_parent_instructions;
      body.emit(f1B0C);

      /* END IF */

      body.emit(assign(r1ABA, r1B0B, 0x01));

      /* IF CONDITION */
      ir_expression *const r1B0F = lequal(r1B0B, r1AB7);
      ir_if *f1B0E = new(mem_ctx) ir_if(operand(r1B0F).val);
      exec_list *const f1B0E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B0E->then_instructions;

         ir_expression *const r1B10 = expr(ir_unop_u2i, r1AB7);
         ir_expression *const r1B11 = rshift(r1B10, body.constant(int(1)));
         body.emit(assign(r1AB9, expr(ir_unop_i2u, r1B11), 0x01));

         body.emit(assign(r1AB8, body.constant(false), 0x01));


      body.instructions = f1B0E_parent_instructions;
      body.emit(f1B0E);

      /* END IF */


   body.instructions = f1ABE_parent_instructions;
   body.emit(f1ABE);

   /* END IF */

   /* IF CONDITION */
   ir_if *f1B12 = new(mem_ctx) ir_if(operand(r1AB8).val);
   exec_list *const f1B12_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1B12->then_instructions;

      ir_variable *const r1B13 = body.make_temp(glsl_type::uint_type, "return_value");
      ir_variable *const r1B14 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
      body.emit(r1B14);
      ir_variable *const r1B15 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
      body.emit(r1B15);
      ir_variable *const r1B16 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
      body.emit(r1B16);
      ir_variable *const r1B17 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
      body.emit(r1B17);
      body.emit(assign(r1B16, body.constant(0u), 0x01));

      body.emit(assign(r1B15, body.constant(0u), 0x01));

      /* IF CONDITION */
      ir_expression *const r1B19 = lequal(r1ABA, r1AB7);
      ir_if *f1B18 = new(mem_ctx) ir_if(operand(r1B19).val);
      exec_list *const f1B18_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B18->then_instructions;

         body.emit(assign(r1B13, body.constant(4294967295u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1B18->else_instructions;

         body.emit(assign(r1B17, rshift(r1ABA, body.constant(int(16))), 0x01));

         ir_variable *const r1B1A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1B1C = lshift(r1B17, body.constant(int(16)));
         ir_expression *const r1B1D = lequal(r1B1C, r1AB7);
         ir_if *f1B1B = new(mem_ctx) ir_if(operand(r1B1D).val);
         exec_list *const f1B1B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1B1B->then_instructions;

            body.emit(assign(r1B1A, body.constant(4294901760u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1B1B->else_instructions;

            ir_expression *const r1B1E = expr(ir_binop_div, r1AB7, r1B17);
            body.emit(assign(r1B1A, lshift(r1B1E, body.constant(int(16))), 0x01));


         body.instructions = f1B1B_parent_instructions;
         body.emit(f1B1B);

         /* END IF */

         body.emit(assign(r1B14, r1B1A, 0x01));

         ir_variable *const r1B1F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r1B1F);
         ir_variable *const r1B20 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
         body.emit(r1B20);
         ir_variable *const r1B21 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r1B21);
         ir_variable *const r1B22 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r1B22, bit_and(r1ABA, body.constant(65535u)), 0x01));

         ir_variable *const r1B23 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r1B23, rshift(r1ABA, body.constant(int(16))), 0x01));

         ir_variable *const r1B24 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r1B24, bit_and(r1B1A, body.constant(65535u)), 0x01));

         ir_variable *const r1B25 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r1B25, rshift(r1B1A, body.constant(int(16))), 0x01));

         ir_variable *const r1B26 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r1B26, mul(r1B23, r1B24), 0x01));

         ir_expression *const r1B27 = mul(r1B22, r1B25);
         body.emit(assign(r1B20, add(r1B27, r1B26), 0x01));

         ir_expression *const r1B28 = mul(r1B23, r1B25);
         ir_expression *const r1B29 = less(r1B20, r1B26);
         ir_expression *const r1B2A = expr(ir_unop_b2i, r1B29);
         ir_expression *const r1B2B = expr(ir_unop_i2u, r1B2A);
         ir_expression *const r1B2C = lshift(r1B2B, body.constant(int(16)));
         ir_expression *const r1B2D = rshift(r1B20, body.constant(int(16)));
         ir_expression *const r1B2E = add(r1B2C, r1B2D);
         body.emit(assign(r1B1F, add(r1B28, r1B2E), 0x01));

         body.emit(assign(r1B20, lshift(r1B20, body.constant(int(16))), 0x01));

         ir_expression *const r1B2F = mul(r1B22, r1B24);
         body.emit(assign(r1B21, add(r1B2F, r1B20), 0x01));

         ir_expression *const r1B30 = less(r1B21, r1B20);
         ir_expression *const r1B31 = expr(ir_unop_b2i, r1B30);
         ir_expression *const r1B32 = expr(ir_unop_i2u, r1B31);
         body.emit(assign(r1B1F, add(r1B1F, r1B32), 0x01));

         ir_expression *const r1B33 = sub(r1AB7, r1B1F);
         ir_expression *const r1B34 = less(body.constant(0u), r1B21);
         ir_expression *const r1B35 = expr(ir_unop_b2i, r1B34);
         ir_expression *const r1B36 = expr(ir_unop_i2u, r1B35);
         body.emit(assign(r1B16, sub(r1B33, r1B36), 0x01));

         body.emit(assign(r1B15, neg(r1B21), 0x01));

         /* LOOP BEGIN */
         ir_loop *f1B37 = new(mem_ctx) ir_loop();
         exec_list *const f1B37_parent_instructions = body.instructions;

            body.instructions = &f1B37->body_instructions;

            /* IF CONDITION */
            ir_expression *const r1B39 = expr(ir_unop_u2i, r1B16);
            ir_expression *const r1B3A = gequal(r1B39, body.constant(int(0)));
            ir_if *f1B38 = new(mem_ctx) ir_if(operand(r1B3A).val);
            exec_list *const f1B38_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1B38->then_instructions;

               body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


            body.instructions = f1B38_parent_instructions;
            body.emit(f1B38);

            /* END IF */

            body.emit(assign(r1B14, add(r1B14, body.constant(4294901760u)), 0x01));

            ir_variable *const r1B3B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            ir_expression *const r1B3C = lshift(r1ABA, body.constant(int(16)));
            body.emit(assign(r1B3B, add(r1B15, r1B3C), 0x01));

            ir_expression *const r1B3D = add(r1B16, r1B17);
            ir_expression *const r1B3E = less(r1B3B, r1B15);
            ir_expression *const r1B3F = expr(ir_unop_b2i, r1B3E);
            ir_expression *const r1B40 = expr(ir_unop_i2u, r1B3F);
            body.emit(assign(r1B16, add(r1B3D, r1B40), 0x01));

            body.emit(assign(r1B15, r1B3B, 0x01));

         /* LOOP END */

         body.instructions = f1B37_parent_instructions;
         body.emit(f1B37);

         ir_expression *const r1B41 = lshift(r1B16, body.constant(int(16)));
         ir_expression *const r1B42 = rshift(r1B15, body.constant(int(16)));
         body.emit(assign(r1B16, bit_or(r1B41, r1B42), 0x01));

         ir_variable *const r1B43 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1B45 = lshift(r1B17, body.constant(int(16)));
         ir_expression *const r1B46 = lequal(r1B45, r1B16);
         ir_if *f1B44 = new(mem_ctx) ir_if(operand(r1B46).val);
         exec_list *const f1B44_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1B44->then_instructions;

            body.emit(assign(r1B43, body.constant(65535u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1B44->else_instructions;

            body.emit(assign(r1B43, expr(ir_binop_div, r1B16, r1B17), 0x01));


         body.instructions = f1B44_parent_instructions;
         body.emit(f1B44);

         /* END IF */

         body.emit(assign(r1B14, bit_or(r1B14, r1B43), 0x01));

         body.emit(assign(r1B13, r1B14, 0x01));


      body.instructions = f1B18_parent_instructions;
      body.emit(f1B18);

      /* END IF */

      ir_expression *const r1B47 = rshift(r1B13, body.constant(int(1)));
      ir_expression *const r1B48 = rshift(r1ABA, body.constant(int(1)));
      body.emit(assign(r1AB9, add(r1B47, r1B48), 0x01));

      body.emit(assign(r1AB8, body.constant(false), 0x01));


   body.instructions = f1B12_parent_instructions;
   body.emit(f1B12);

   /* END IF */

   body.emit(ret(r1AB9));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fsqrt64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1B49 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1B49);
   ir_variable *const r1B4A = body.make_temp(glsl_type::float_type, "return_value");
   ir_variable *const r1B4B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac", ir_var_auto);
   body.emit(r1B4B);
   body.emit(assign(r1B4B, body.constant(0u), 0x01));

   ir_variable *const r1B4C = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r1B4C, bit_and(swizzle_y(r1B49), body.constant(1048575u)), 0x01));

   ir_variable *const r1B4D = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r1B4E = rshift(swizzle_y(r1B49), body.constant(int(20)));
   ir_expression *const r1B4F = bit_and(r1B4E, body.constant(2047u));
   body.emit(assign(r1B4D, expr(ir_unop_u2i, r1B4F), 0x01));

   ir_variable *const r1B50 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r1B50, rshift(swizzle_y(r1B49), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1B52 = equal(r1B4D, body.constant(int(2047)));
   ir_if *f1B51 = new(mem_ctx) ir_if(operand(r1B52).val);
   exec_list *const f1B51_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1B51->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1B54 = bit_or(r1B4C, swizzle_x(r1B49));
      ir_expression *const r1B55 = nequal(r1B54, body.constant(0u));
      ir_if *f1B53 = new(mem_ctx) ir_if(operand(r1B55).val);
      exec_list *const f1B53_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B53->then_instructions;

         ir_variable *const r1B56 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r1B56, lshift(swizzle_x(r1B49), body.constant(int(12))), 0x01));

         ir_expression *const r1B57 = lshift(r1B50, body.constant(int(31)));
         ir_expression *const r1B58 = bit_or(r1B57, body.constant(2143289344u));
         ir_expression *const r1B59 = lshift(swizzle_y(r1B49), body.constant(int(12)));
         ir_expression *const r1B5A = rshift(swizzle_x(r1B49), body.constant(int(20)));
         ir_expression *const r1B5B = bit_or(r1B59, r1B5A);
         ir_expression *const r1B5C = rshift(r1B5B, body.constant(int(9)));
         ir_expression *const r1B5D = bit_or(r1B58, r1B5C);
         body.emit(assign(r1B4A, expr(ir_unop_bitcast_u2f, r1B5D), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1B53->else_instructions;

         ir_expression *const r1B5E = lshift(r1B50, body.constant(int(31)));
         ir_expression *const r1B5F = add(r1B5E, body.constant(2139095040u));
         body.emit(assign(r1B4A, expr(ir_unop_bitcast_u2f, r1B5F), 0x01));


      body.instructions = f1B53_parent_instructions;
      body.emit(f1B53);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1B51->else_instructions;

      ir_variable *const r1B60 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r1B60);
      ir_variable *const r1B61 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r1B61);
      ir_expression *const r1B62 = lshift(r1B4C, body.constant(int(10)));
      ir_expression *const r1B63 = rshift(swizzle_x(r1B49), body.constant(int(22)));
      ir_expression *const r1B64 = bit_or(r1B62, r1B63);
      ir_expression *const r1B65 = lshift(swizzle_x(r1B49), body.constant(int(10)));
      ir_expression *const r1B66 = nequal(r1B65, body.constant(0u));
      ir_expression *const r1B67 = expr(ir_unop_b2i, r1B66);
      ir_expression *const r1B68 = expr(ir_unop_i2u, r1B67);
      body.emit(assign(r1B60, bit_or(r1B64, r1B68), 0x01));

      body.emit(assign(r1B61, rshift(r1B4C, body.constant(int(22))), 0x01));

      body.emit(assign(r1B4B, r1B60, 0x01));

      /* IF CONDITION */
      ir_expression *const r1B6A = nequal(r1B4D, body.constant(int(0)));
      ir_if *f1B69 = new(mem_ctx) ir_if(operand(r1B6A).val);
      exec_list *const f1B69_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B69->then_instructions;

         body.emit(assign(r1B4B, bit_or(r1B60, body.constant(1073741824u)), 0x01));


      body.instructions = f1B69_parent_instructions;
      body.emit(f1B69);

      /* END IF */

      ir_variable *const r1B6B = body.make_temp(glsl_type::int_type, "zExp");
      body.emit(assign(r1B6B, add(r1B4D, body.constant(int(-897))), 0x01));

      ir_variable *const r1B6C = body.make_temp(glsl_type::uint_type, "zFrac");
      body.emit(assign(r1B6C, r1B4B, 0x01));

      ir_variable *const r1B6D = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r1B6D, body.constant(true), 0x01));

      ir_variable *const r1B6E = body.make_temp(glsl_type::float_type, "return_value");
      ir_variable *const r1B6F = new(mem_ctx) ir_variable(glsl_type::int_type, "roundBits", ir_var_auto);
      body.emit(r1B6F);
      ir_expression *const r1B70 = bit_and(r1B4B, body.constant(127u));
      body.emit(assign(r1B6F, expr(ir_unop_u2i, r1B70), 0x01));

      /* IF CONDITION */
      ir_expression *const r1B72 = expr(ir_unop_i2u, r1B6B);
      ir_expression *const r1B73 = lequal(body.constant(253u), r1B72);
      ir_if *f1B71 = new(mem_ctx) ir_if(operand(r1B73).val);
      exec_list *const f1B71_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B71->then_instructions;

         /* IF CONDITION */
         ir_expression *const r1B75 = less(body.constant(int(253)), r1B6B);
         ir_expression *const r1B76 = equal(r1B6B, body.constant(int(253)));
         ir_expression *const r1B77 = expr(ir_unop_u2i, r1B4B);
         ir_expression *const r1B78 = less(r1B77, body.constant(int(-64)));
         ir_expression *const r1B79 = logic_and(r1B76, r1B78);
         ir_expression *const r1B7A = logic_or(r1B75, r1B79);
         ir_if *f1B74 = new(mem_ctx) ir_if(operand(r1B7A).val);
         exec_list *const f1B74_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1B74->then_instructions;

            ir_expression *const r1B7B = lshift(r1B50, body.constant(int(31)));
            ir_expression *const r1B7C = add(r1B7B, body.constant(2139095040u));
            body.emit(assign(r1B6E, expr(ir_unop_bitcast_u2f, r1B7C), 0x01));

            body.emit(assign(r1B6D, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1B74->else_instructions;

            /* IF CONDITION */
            ir_expression *const r1B7E = less(r1B6B, body.constant(int(0)));
            ir_if *f1B7D = new(mem_ctx) ir_if(operand(r1B7E).val);
            exec_list *const f1B7D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1B7D->then_instructions;

               ir_variable *const r1B7F = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r1B7F, neg(r1B6B), 0x01));

               ir_variable *const r1B80 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r1B80);
               /* IF CONDITION */
               ir_expression *const r1B82 = equal(r1B7F, body.constant(int(0)));
               ir_if *f1B81 = new(mem_ctx) ir_if(operand(r1B82).val);
               exec_list *const f1B81_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1B81->then_instructions;

                  body.emit(assign(r1B80, r1B4B, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1B81->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1B84 = less(r1B7F, body.constant(int(32)));
                  ir_if *f1B83 = new(mem_ctx) ir_if(operand(r1B84).val);
                  exec_list *const f1B83_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1B83->then_instructions;

                     ir_expression *const r1B85 = rshift(r1B4B, r1B7F);
                     ir_expression *const r1B86 = neg(r1B7F);
                     ir_expression *const r1B87 = bit_and(r1B86, body.constant(int(31)));
                     ir_expression *const r1B88 = lshift(r1B4B, r1B87);
                     ir_expression *const r1B89 = nequal(r1B88, body.constant(0u));
                     ir_expression *const r1B8A = expr(ir_unop_b2i, r1B89);
                     ir_expression *const r1B8B = expr(ir_unop_i2u, r1B8A);
                     body.emit(assign(r1B80, bit_or(r1B85, r1B8B), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1B83->else_instructions;

                     ir_expression *const r1B8C = nequal(r1B4B, body.constant(0u));
                     ir_expression *const r1B8D = expr(ir_unop_b2i, r1B8C);
                     body.emit(assign(r1B80, expr(ir_unop_i2u, r1B8D), 0x01));


                  body.instructions = f1B83_parent_instructions;
                  body.emit(f1B83);

                  /* END IF */


               body.instructions = f1B81_parent_instructions;
               body.emit(f1B81);

               /* END IF */

               body.emit(assign(r1B6C, r1B80, 0x01));

               body.emit(assign(r1B6B, body.constant(int(0)), 0x01));

               ir_expression *const r1B8E = expr(ir_unop_u2i, r1B80);
               body.emit(assign(r1B6F, bit_and(r1B8E, body.constant(int(127))), 0x01));


            body.instructions = f1B7D_parent_instructions;
            body.emit(f1B7D);

            /* END IF */


         body.instructions = f1B74_parent_instructions;
         body.emit(f1B74);

         /* END IF */


      body.instructions = f1B71_parent_instructions;
      body.emit(f1B71);

      /* END IF */

      /* IF CONDITION */
      ir_if *f1B8F = new(mem_ctx) ir_if(operand(r1B6D).val);
      exec_list *const f1B8F_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B8F->then_instructions;

         ir_expression *const r1B90 = add(r1B6C, body.constant(64u));
         body.emit(assign(r1B6C, rshift(r1B90, body.constant(int(7))), 0x01));

         ir_expression *const r1B91 = bit_xor(r1B6F, body.constant(int(64)));
         ir_expression *const r1B92 = equal(r1B91, body.constant(int(0)));
         ir_expression *const r1B93 = expr(ir_unop_b2i, r1B92);
         ir_expression *const r1B94 = expr(ir_unop_i2u, r1B93);
         ir_expression *const r1B95 = expr(ir_unop_bit_not, r1B94);
         body.emit(assign(r1B6C, bit_and(r1B6C, r1B95), 0x01));

         /* IF CONDITION */
         ir_expression *const r1B97 = equal(r1B6C, body.constant(0u));
         ir_if *f1B96 = new(mem_ctx) ir_if(operand(r1B97).val);
         exec_list *const f1B96_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1B96->then_instructions;

            body.emit(assign(r1B6B, body.constant(int(0)), 0x01));


         body.instructions = f1B96_parent_instructions;
         body.emit(f1B96);

         /* END IF */

         ir_expression *const r1B98 = lshift(r1B50, body.constant(int(31)));
         ir_expression *const r1B99 = expr(ir_unop_i2u, r1B6B);
         ir_expression *const r1B9A = lshift(r1B99, body.constant(int(23)));
         ir_expression *const r1B9B = add(r1B98, r1B9A);
         ir_expression *const r1B9C = add(r1B9B, r1B6C);
         body.emit(assign(r1B6E, expr(ir_unop_bitcast_u2f, r1B9C), 0x01));

         body.emit(assign(r1B6D, body.constant(false), 0x01));


      body.instructions = f1B8F_parent_instructions;
      body.emit(f1B8F);

      /* END IF */

      body.emit(assign(r1B4A, r1B6E, 0x01));


   body.instructions = f1B51_parent_instructions;
   body.emit(f1B51);

   /* END IF */

   ir_variable *const r1B9D = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r1B9D, body.constant(true), 0x01));

   ir_variable *const r1B9E = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1B9F = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r1B9F);
   ir_variable *const r1BA0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac", ir_var_auto);
   body.emit(r1BA0);
   ir_variable *const r1BA1 = body.make_temp(glsl_type::uint_type, "floatBitsToUint_retval");
   ir_expression *const r1BA2 = expr(ir_unop_sqrt, r1B4A);
   body.emit(assign(r1BA1, expr(ir_unop_bitcast_f2u, r1BA2), 0x01));

   ir_variable *const r1BA3 = body.make_temp(glsl_type::uint_type, "extractFloat32Frac_retval");
   body.emit(assign(r1BA3, bit_and(r1BA1, body.constant(8388607u)), 0x01));

   body.emit(assign(r1BA0, r1BA3, 0x01));

   ir_variable *const r1BA4 = body.make_temp(glsl_type::int_type, "extractFloat32Exp_retval");
   ir_expression *const r1BA5 = rshift(r1BA1, body.constant(int(23)));
   ir_expression *const r1BA6 = bit_and(r1BA5, body.constant(255u));
   body.emit(assign(r1BA4, expr(ir_unop_u2i, r1BA6), 0x01));

   body.emit(assign(r1B9F, r1BA4, 0x01));

   ir_variable *const r1BA7 = body.make_temp(glsl_type::uint_type, "extractFloat32Sign_retval");
   body.emit(assign(r1BA7, rshift(r1BA1, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1BA9 = equal(r1BA4, body.constant(int(255)));
   ir_if *f1BA8 = new(mem_ctx) ir_if(operand(r1BA9).val);
   exec_list *const f1BA8_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1BA8->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1BAB = nequal(r1BA3, body.constant(0u));
      ir_if *f1BAA = new(mem_ctx) ir_if(operand(r1BAB).val);
      exec_list *const f1BAA_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1BAA->then_instructions;

         ir_variable *const r1BAC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r1BAC, lshift(r1BA1, body.constant(int(9))), 0x01));

         ir_variable *const r1BAD = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
         ir_expression *const r1BAE = lshift(r1BAC, body.constant(int(20)));
         body.emit(assign(r1BAD, bit_or(r1BAE, body.constant(0u)), 0x01));

         ir_expression *const r1BAF = rshift(r1BAC, body.constant(int(12)));
         ir_expression *const r1BB0 = lshift(r1BA7, body.constant(int(31)));
         ir_expression *const r1BB1 = bit_or(r1BB0, body.constant(2146959360u));
         body.emit(assign(r1BAD, bit_or(r1BAF, r1BB1), 0x02));

         body.emit(assign(r1B9E, r1BAD, 0x03));

         body.emit(assign(r1B9D, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1BAA->else_instructions;

         ir_variable *const r1BB2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r1BB2);
         ir_expression *const r1BB3 = lshift(r1BA7, body.constant(int(31)));
         body.emit(assign(r1BB2, add(r1BB3, body.constant(2146435072u)), 0x02));

         body.emit(assign(r1BB2, body.constant(0u), 0x01));

         body.emit(assign(r1B9E, r1BB2, 0x03));

         body.emit(assign(r1B9D, body.constant(false), 0x01));


      body.instructions = f1BAA_parent_instructions;
      body.emit(f1BAA);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1BA8->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1BB5 = equal(r1BA4, body.constant(int(0)));
      ir_if *f1BB4 = new(mem_ctx) ir_if(operand(r1BB5).val);
      exec_list *const f1BB4_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1BB4->then_instructions;

         /* IF CONDITION */
         ir_expression *const r1BB7 = equal(r1BA3, body.constant(0u));
         ir_if *f1BB6 = new(mem_ctx) ir_if(operand(r1BB7).val);
         exec_list *const f1BB6_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1BB6->then_instructions;

            ir_variable *const r1BB8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r1BB8);
            body.emit(assign(r1BB8, lshift(r1BA7, body.constant(int(31))), 0x02));

            body.emit(assign(r1BB8, body.constant(0u), 0x01));

            body.emit(assign(r1B9E, r1BB8, 0x03));

            body.emit(assign(r1B9D, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1BB6->else_instructions;

            ir_variable *const r1BB9 = body.make_temp(glsl_type::int_type, "zExpPtr");
            body.emit(assign(r1BB9, r1BA4, 0x01));

            ir_variable *const r1BBA = body.make_temp(glsl_type::uint_type, "zFracPtr");
            body.emit(assign(r1BBA, r1BA3, 0x01));

            ir_variable *const r1BBB = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r1BBB, r1BA3, 0x01));

            ir_variable *const r1BBC = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r1BBD = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r1BBD);
            /* IF CONDITION */
            ir_expression *const r1BBF = equal(r1BA3, body.constant(0u));
            ir_if *f1BBE = new(mem_ctx) ir_if(operand(r1BBF).val);
            exec_list *const f1BBE_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1BBE->then_instructions;

               body.emit(assign(r1BBC, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1BBE->else_instructions;

               body.emit(assign(r1BBD, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r1BC1 = bit_and(r1BA3, body.constant(4294901760u));
               ir_expression *const r1BC2 = equal(r1BC1, body.constant(0u));
               ir_if *f1BC0 = new(mem_ctx) ir_if(operand(r1BC2).val);
               exec_list *const f1BC0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1BC0->then_instructions;

                  body.emit(assign(r1BBD, body.constant(int(16)), 0x01));

                  body.emit(assign(r1BBB, lshift(r1BA3, body.constant(int(16))), 0x01));


               body.instructions = f1BC0_parent_instructions;
               body.emit(f1BC0);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1BC4 = bit_and(r1BBB, body.constant(4278190080u));
               ir_expression *const r1BC5 = equal(r1BC4, body.constant(0u));
               ir_if *f1BC3 = new(mem_ctx) ir_if(operand(r1BC5).val);
               exec_list *const f1BC3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1BC3->then_instructions;

                  body.emit(assign(r1BBD, add(r1BBD, body.constant(int(8))), 0x01));

                  body.emit(assign(r1BBB, lshift(r1BBB, body.constant(int(8))), 0x01));


               body.instructions = f1BC3_parent_instructions;
               body.emit(f1BC3);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1BC7 = bit_and(r1BBB, body.constant(4026531840u));
               ir_expression *const r1BC8 = equal(r1BC7, body.constant(0u));
               ir_if *f1BC6 = new(mem_ctx) ir_if(operand(r1BC8).val);
               exec_list *const f1BC6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1BC6->then_instructions;

                  body.emit(assign(r1BBD, add(r1BBD, body.constant(int(4))), 0x01));

                  body.emit(assign(r1BBB, lshift(r1BBB, body.constant(int(4))), 0x01));


               body.instructions = f1BC6_parent_instructions;
               body.emit(f1BC6);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1BCA = bit_and(r1BBB, body.constant(3221225472u));
               ir_expression *const r1BCB = equal(r1BCA, body.constant(0u));
               ir_if *f1BC9 = new(mem_ctx) ir_if(operand(r1BCB).val);
               exec_list *const f1BC9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1BC9->then_instructions;

                  body.emit(assign(r1BBD, add(r1BBD, body.constant(int(2))), 0x01));

                  body.emit(assign(r1BBB, lshift(r1BBB, body.constant(int(2))), 0x01));


               body.instructions = f1BC9_parent_instructions;
               body.emit(f1BC9);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1BCD = bit_and(r1BBB, body.constant(2147483648u));
               ir_expression *const r1BCE = equal(r1BCD, body.constant(0u));
               ir_if *f1BCC = new(mem_ctx) ir_if(operand(r1BCE).val);
               exec_list *const f1BCC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1BCC->then_instructions;

                  body.emit(assign(r1BBD, add(r1BBD, body.constant(int(1))), 0x01));


               body.instructions = f1BCC_parent_instructions;
               body.emit(f1BCC);

               /* END IF */

               body.emit(assign(r1BBC, r1BBD, 0x01));


            body.instructions = f1BBE_parent_instructions;
            body.emit(f1BBE);

            /* END IF */

            ir_variable *const r1BCF = body.make_temp(glsl_type::int_type, "assignment_tmp");
            body.emit(assign(r1BCF, add(r1BBC, body.constant(int(-8))), 0x01));

            body.emit(assign(r1BBA, lshift(r1BA3, r1BCF), 0x01));

            body.emit(assign(r1BB9, sub(body.constant(int(1)), r1BCF), 0x01));

            body.emit(assign(r1BA0, r1BBA, 0x01));

            body.emit(assign(r1B9F, add(r1BB9, body.constant(int(-1))), 0x01));


         body.instructions = f1BB6_parent_instructions;
         body.emit(f1BB6);

         /* END IF */


      body.instructions = f1BB4_parent_instructions;
      body.emit(f1BB4);

      /* END IF */

      /* IF CONDITION */
      ir_if *f1BD0 = new(mem_ctx) ir_if(operand(r1B9D).val);
      exec_list *const f1BD0_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1BD0->then_instructions;

         ir_variable *const r1BD1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r1BD1);
         ir_expression *const r1BD2 = lshift(r1BA7, body.constant(int(31)));
         ir_expression *const r1BD3 = add(r1B9F, body.constant(int(896)));
         ir_expression *const r1BD4 = expr(ir_unop_i2u, r1BD3);
         ir_expression *const r1BD5 = lshift(r1BD4, body.constant(int(20)));
         ir_expression *const r1BD6 = add(r1BD2, r1BD5);
         ir_expression *const r1BD7 = rshift(r1BA0, body.constant(int(3)));
         body.emit(assign(r1BD1, add(r1BD6, r1BD7), 0x02));

         ir_expression *const r1BD8 = lshift(r1BA0, body.constant(int(29)));
         body.emit(assign(r1BD1, bit_or(r1BD8, body.constant(0u)), 0x01));

         body.emit(assign(r1B9E, r1BD1, 0x03));

         body.emit(assign(r1B9D, body.constant(false), 0x01));


      body.instructions = f1BD0_parent_instructions;
      body.emit(f1BD0);

      /* END IF */


   body.instructions = f1BA8_parent_instructions;
   body.emit(f1BA8);

   /* END IF */

   body.emit(ret(r1B9E));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift64Left(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1BD9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r1BD9);
   ir_variable *const r1BDA = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r1BDA);
   ir_variable *const r1BDB = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r1BDB);
   ir_variable *const r1BDC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1BDC);
   ir_variable *const r1BDD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1BDD);
   ir_variable *const r1BDE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r1BDE);
   ir_variable *const r1BDF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r1BDF);
   ir_variable *const r1BE0 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r1BE1 = neg(r1BDB);
   body.emit(assign(r1BE0, bit_and(r1BE1, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1BE3 = equal(r1BDB, body.constant(int(0)));
   ir_if *f1BE2 = new(mem_ctx) ir_if(operand(r1BE3).val);
   exec_list *const f1BE2_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1BE2->then_instructions;

      body.emit(assign(r1BDF, r1BD9, 0x01));

      body.emit(assign(r1BDE, r1BDA, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1BE2->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1BE5 = less(r1BDB, body.constant(int(32)));
      ir_if *f1BE4 = new(mem_ctx) ir_if(operand(r1BE5).val);
      exec_list *const f1BE4_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1BE4->then_instructions;

         ir_expression *const r1BE6 = lshift(r1BD9, r1BDB);
         ir_expression *const r1BE7 = rshift(r1BDA, r1BE0);
         body.emit(assign(r1BDF, bit_or(r1BE6, r1BE7), 0x01));

         body.emit(assign(r1BDE, lshift(r1BDA, r1BDB), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1BE4->else_instructions;

         ir_variable *const r1BE8 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1BEA = less(r1BDB, body.constant(int(64)));
         ir_if *f1BE9 = new(mem_ctx) ir_if(operand(r1BEA).val);
         exec_list *const f1BE9_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1BE9->then_instructions;

            ir_expression *const r1BEB = add(r1BDB, body.constant(int(-32)));
            body.emit(assign(r1BE8, lshift(r1BDA, r1BEB), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1BE9->else_instructions;

            body.emit(assign(r1BE8, body.constant(0u), 0x01));


         body.instructions = f1BE9_parent_instructions;
         body.emit(f1BE9);

         /* END IF */

         body.emit(assign(r1BDF, r1BE8, 0x01));

         body.emit(assign(r1BDE, body.constant(0u), 0x01));


      body.instructions = f1BE4_parent_instructions;
      body.emit(f1BE4);

      /* END IF */


   body.instructions = f1BE2_parent_instructions;
   body.emit(f1BE2);

   /* END IF */

   body.emit(assign(r1BDC, r1BDF, 0x01));

   body.emit(assign(r1BDD, r1BDE, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
uint_to_fp64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1BEC = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1BEC);
   ir_variable *const r1BED = body.make_temp(glsl_type::uvec2_type, "return_value");
   /* IF CONDITION */
   ir_expression *const r1BEF = equal(r1BEC, body.constant(0u));
   ir_if *f1BEE = new(mem_ctx) ir_if(operand(r1BEF).val);
   exec_list *const f1BEE_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1BEE->then_instructions;

      body.emit(assign(r1BED, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1BEE->else_instructions;

      ir_variable *const r1BF0 = body.make_temp(glsl_type::uint_type, "a");
      body.emit(assign(r1BF0, r1BEC, 0x01));

      ir_variable *const r1BF1 = body.make_temp(glsl_type::int_type, "return_value");
      ir_variable *const r1BF2 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
      body.emit(r1BF2);
      /* IF CONDITION */
      ir_expression *const r1BF4 = equal(r1BEC, body.constant(0u));
      ir_if *f1BF3 = new(mem_ctx) ir_if(operand(r1BF4).val);
      exec_list *const f1BF3_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1BF3->then_instructions;

         body.emit(assign(r1BF1, body.constant(int(32)), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1BF3->else_instructions;

         body.emit(assign(r1BF2, body.constant(int(0)), 0x01));

         /* IF CONDITION */
         ir_expression *const r1BF6 = bit_and(r1BEC, body.constant(4294901760u));
         ir_expression *const r1BF7 = equal(r1BF6, body.constant(0u));
         ir_if *f1BF5 = new(mem_ctx) ir_if(operand(r1BF7).val);
         exec_list *const f1BF5_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1BF5->then_instructions;

            body.emit(assign(r1BF2, body.constant(int(16)), 0x01));

            body.emit(assign(r1BF0, lshift(r1BEC, body.constant(int(16))), 0x01));


         body.instructions = f1BF5_parent_instructions;
         body.emit(f1BF5);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1BF9 = bit_and(r1BF0, body.constant(4278190080u));
         ir_expression *const r1BFA = equal(r1BF9, body.constant(0u));
         ir_if *f1BF8 = new(mem_ctx) ir_if(operand(r1BFA).val);
         exec_list *const f1BF8_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1BF8->then_instructions;

            body.emit(assign(r1BF2, add(r1BF2, body.constant(int(8))), 0x01));

            body.emit(assign(r1BF0, lshift(r1BF0, body.constant(int(8))), 0x01));


         body.instructions = f1BF8_parent_instructions;
         body.emit(f1BF8);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1BFC = bit_and(r1BF0, body.constant(4026531840u));
         ir_expression *const r1BFD = equal(r1BFC, body.constant(0u));
         ir_if *f1BFB = new(mem_ctx) ir_if(operand(r1BFD).val);
         exec_list *const f1BFB_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1BFB->then_instructions;

            body.emit(assign(r1BF2, add(r1BF2, body.constant(int(4))), 0x01));

            body.emit(assign(r1BF0, lshift(r1BF0, body.constant(int(4))), 0x01));


         body.instructions = f1BFB_parent_instructions;
         body.emit(f1BFB);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1BFF = bit_and(r1BF0, body.constant(3221225472u));
         ir_expression *const r1C00 = equal(r1BFF, body.constant(0u));
         ir_if *f1BFE = new(mem_ctx) ir_if(operand(r1C00).val);
         exec_list *const f1BFE_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1BFE->then_instructions;

            body.emit(assign(r1BF2, add(r1BF2, body.constant(int(2))), 0x01));

            body.emit(assign(r1BF0, lshift(r1BF0, body.constant(int(2))), 0x01));


         body.instructions = f1BFE_parent_instructions;
         body.emit(f1BFE);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1C02 = bit_and(r1BF0, body.constant(2147483648u));
         ir_expression *const r1C03 = equal(r1C02, body.constant(0u));
         ir_if *f1C01 = new(mem_ctx) ir_if(operand(r1C03).val);
         exec_list *const f1C01_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1C01->then_instructions;

            body.emit(assign(r1BF2, add(r1BF2, body.constant(int(1))), 0x01));


         body.instructions = f1C01_parent_instructions;
         body.emit(f1C01);

         /* END IF */

         body.emit(assign(r1BF1, r1BF2, 0x01));


      body.instructions = f1BF3_parent_instructions;
      body.emit(f1BF3);

      /* END IF */

      ir_variable *const r1C04 = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r1C04, add(r1BF1, body.constant(int(21))), 0x01));

      ir_variable *const r1C05 = body.make_temp(glsl_type::uint_type, "a0");
      body.emit(assign(r1C05, body.constant(0u), 0x01));

      ir_variable *const r1C06 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r1C06);
      ir_variable *const r1C07 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r1C07);
      ir_variable *const r1C08 = body.make_temp(glsl_type::int_type, "assignment_tmp");
      ir_expression *const r1C09 = neg(r1C04);
      body.emit(assign(r1C08, bit_and(r1C09, body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r1C0B = equal(r1C04, body.constant(int(0)));
      ir_if *f1C0A = new(mem_ctx) ir_if(operand(r1C0B).val);
      exec_list *const f1C0A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1C0A->then_instructions;

         body.emit(assign(r1C07, body.constant(0u), 0x01));

         body.emit(assign(r1C06, r1BEC, 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1C0A->else_instructions;

         /* IF CONDITION */
         ir_expression *const r1C0D = less(r1C04, body.constant(int(32)));
         ir_if *f1C0C = new(mem_ctx) ir_if(operand(r1C0D).val);
         exec_list *const f1C0C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1C0C->then_instructions;

            ir_expression *const r1C0E = rshift(r1BEC, r1C08);
            body.emit(assign(r1C07, bit_or(body.constant(0u), r1C0E), 0x01));

            body.emit(assign(r1C06, lshift(r1BEC, r1C04), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1C0C->else_instructions;

            ir_variable *const r1C0F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r1C11 = less(r1C04, body.constant(int(64)));
            ir_if *f1C10 = new(mem_ctx) ir_if(operand(r1C11).val);
            exec_list *const f1C10_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1C10->then_instructions;

               ir_expression *const r1C12 = add(r1C04, body.constant(int(-32)));
               body.emit(assign(r1C0F, lshift(r1BEC, r1C12), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1C10->else_instructions;

               body.emit(assign(r1C0F, body.constant(0u), 0x01));


            body.instructions = f1C10_parent_instructions;
            body.emit(f1C10);

            /* END IF */

            body.emit(assign(r1C07, r1C0F, 0x01));

            body.emit(assign(r1C06, body.constant(0u), 0x01));


         body.instructions = f1C0C_parent_instructions;
         body.emit(f1C0C);

         /* END IF */


      body.instructions = f1C0A_parent_instructions;
      body.emit(f1C0A);

      /* END IF */

      ir_variable *const r1C13 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r1C13);
      ir_expression *const r1C14 = sub(body.constant(int(1074)), r1C04);
      ir_expression *const r1C15 = expr(ir_unop_i2u, r1C14);
      ir_expression *const r1C16 = lshift(r1C15, body.constant(int(20)));
      body.emit(assign(r1C13, add(r1C16, r1C07), 0x02));

      body.emit(assign(r1C13, r1C06, 0x01));

      body.emit(assign(r1BED, r1C13, 0x03));


   body.instructions = f1BEE_parent_instructions;
   body.emit(f1BEE);

   /* END IF */

   body.emit(ret(r1BED));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fp64_to_uint(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1C17 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1C17);
   ir_variable *const r1C18 = body.make_temp(glsl_type::uint_type, "return_value");
   ir_variable *const r1C19 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r1C19);
   ir_variable *const r1C1A = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
   body.emit(r1C1A);
   ir_variable *const r1C1B = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r1C1B, swizzle_x(r1C17), 0x01));

   body.emit(assign(r1C1A, r1C1B, 0x01));

   ir_variable *const r1C1C = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r1C1C, bit_and(swizzle_y(r1C17), body.constant(1048575u)), 0x01));

   body.emit(assign(r1C19, r1C1C, 0x01));

   ir_variable *const r1C1D = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r1C1E = rshift(swizzle_y(r1C17), body.constant(int(20)));
   ir_expression *const r1C1F = bit_and(r1C1E, body.constant(2047u));
   body.emit(assign(r1C1D, expr(ir_unop_u2i, r1C1F), 0x01));

   ir_variable *const r1C20 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r1C20, rshift(swizzle_y(r1C17), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1C22 = nequal(r1C20, body.constant(0u));
   ir_if *f1C21 = new(mem_ctx) ir_if(operand(r1C22).val);
   exec_list *const f1C21_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1C21->then_instructions;

      body.emit(assign(r1C18, body.constant(0u), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1C21->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1C24 = equal(r1C1D, body.constant(int(2047)));
      ir_expression *const r1C25 = bit_or(r1C1C, swizzle_x(r1C17));
      ir_expression *const r1C26 = nequal(r1C25, body.constant(0u));
      ir_expression *const r1C27 = logic_and(r1C24, r1C26);
      ir_if *f1C23 = new(mem_ctx) ir_if(operand(r1C27).val);
      exec_list *const f1C23_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1C23->then_instructions;

         body.emit(assign(r1C18, body.constant(4294967295u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1C23->else_instructions;

         /* IF CONDITION */
         ir_expression *const r1C29 = nequal(r1C1D, body.constant(int(0)));
         ir_if *f1C28 = new(mem_ctx) ir_if(operand(r1C29).val);
         exec_list *const f1C28_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1C28->then_instructions;

            body.emit(assign(r1C19, bit_or(r1C1C, body.constant(1048576u)), 0x01));


         body.instructions = f1C28_parent_instructions;
         body.emit(f1C28);

         /* END IF */

         ir_variable *const r1C2A = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r1C2A, sub(body.constant(int(1063)), r1C1D), 0x01));

         /* IF CONDITION */
         ir_expression *const r1C2C = less(body.constant(int(0)), r1C2A);
         ir_if *f1C2B = new(mem_ctx) ir_if(operand(r1C2C).val);
         exec_list *const f1C2B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1C2B->then_instructions;

            ir_variable *const r1C2D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r1C2D);
            ir_variable *const r1C2E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r1C2E);
            ir_variable *const r1C2F = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r1C30 = neg(r1C2A);
            body.emit(assign(r1C2F, bit_and(r1C30, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r1C32 = equal(r1C2A, body.constant(int(0)));
            ir_if *f1C31 = new(mem_ctx) ir_if(operand(r1C32).val);
            exec_list *const f1C31_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1C31->then_instructions;

               body.emit(assign(r1C2D, r1C1B, 0x01));

               body.emit(assign(r1C2E, r1C19, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1C31->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1C34 = less(r1C2A, body.constant(int(32)));
               ir_if *f1C33 = new(mem_ctx) ir_if(operand(r1C34).val);
               exec_list *const f1C33_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C33->then_instructions;

                  ir_expression *const r1C35 = lshift(r1C19, r1C2F);
                  ir_expression *const r1C36 = rshift(swizzle_x(r1C17), r1C2A);
                  ir_expression *const r1C37 = bit_or(r1C35, r1C36);
                  ir_expression *const r1C38 = lshift(swizzle_x(r1C17), r1C2F);
                  ir_expression *const r1C39 = nequal(r1C38, body.constant(0u));
                  ir_expression *const r1C3A = expr(ir_unop_b2i, r1C39);
                  ir_expression *const r1C3B = expr(ir_unop_i2u, r1C3A);
                  body.emit(assign(r1C2D, bit_or(r1C37, r1C3B), 0x01));

                  body.emit(assign(r1C2E, rshift(r1C19, r1C2A), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1C33->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1C3D = equal(r1C2A, body.constant(int(32)));
                  ir_if *f1C3C = new(mem_ctx) ir_if(operand(r1C3D).val);
                  exec_list *const f1C3C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1C3C->then_instructions;

                     ir_expression *const r1C3E = nequal(swizzle_x(r1C17), body.constant(0u));
                     ir_expression *const r1C3F = expr(ir_unop_b2i, r1C3E);
                     ir_expression *const r1C40 = expr(ir_unop_i2u, r1C3F);
                     body.emit(assign(r1C2D, bit_or(r1C19, r1C40), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1C3C->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1C42 = less(r1C2A, body.constant(int(64)));
                     ir_if *f1C41 = new(mem_ctx) ir_if(operand(r1C42).val);
                     exec_list *const f1C41_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1C41->then_instructions;

                        ir_expression *const r1C43 = bit_and(r1C2A, body.constant(int(31)));
                        ir_expression *const r1C44 = rshift(r1C19, r1C43);
                        ir_expression *const r1C45 = lshift(r1C19, r1C2F);
                        ir_expression *const r1C46 = bit_or(r1C45, swizzle_x(r1C17));
                        ir_expression *const r1C47 = nequal(r1C46, body.constant(0u));
                        ir_expression *const r1C48 = expr(ir_unop_b2i, r1C47);
                        ir_expression *const r1C49 = expr(ir_unop_i2u, r1C48);
                        body.emit(assign(r1C2D, bit_or(r1C44, r1C49), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1C41->else_instructions;

                        ir_expression *const r1C4A = bit_or(r1C19, swizzle_x(r1C17));
                        ir_expression *const r1C4B = nequal(r1C4A, body.constant(0u));
                        ir_expression *const r1C4C = expr(ir_unop_b2i, r1C4B);
                        body.emit(assign(r1C2D, expr(ir_unop_i2u, r1C4C), 0x01));


                     body.instructions = f1C41_parent_instructions;
                     body.emit(f1C41);

                     /* END IF */


                  body.instructions = f1C3C_parent_instructions;
                  body.emit(f1C3C);

                  /* END IF */

                  body.emit(assign(r1C2E, body.constant(0u), 0x01));


               body.instructions = f1C33_parent_instructions;
               body.emit(f1C33);

               /* END IF */


            body.instructions = f1C31_parent_instructions;
            body.emit(f1C31);

            /* END IF */

            body.emit(assign(r1C19, r1C2E, 0x01));

            body.emit(assign(r1C1A, r1C2D, 0x01));


         body.instructions = f1C2B_parent_instructions;
         body.emit(f1C2B);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1C4E = bit_and(r1C19, body.constant(4294963200u));
         ir_expression *const r1C4F = nequal(r1C4E, body.constant(0u));
         ir_if *f1C4D = new(mem_ctx) ir_if(operand(r1C4F).val);
         exec_list *const f1C4D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1C4D->then_instructions;

            ir_variable *const r1C50 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r1C52 = nequal(r1C20, body.constant(0u));
            ir_if *f1C51 = new(mem_ctx) ir_if(operand(r1C52).val);
            exec_list *const f1C51_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1C51->then_instructions;

               body.emit(assign(r1C50, body.constant(0u), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1C51->else_instructions;

               body.emit(assign(r1C50, body.constant(4294967295u), 0x01));


            body.instructions = f1C51_parent_instructions;
            body.emit(f1C51);

            /* END IF */

            body.emit(assign(r1C18, r1C50, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1C4D->else_instructions;

            ir_variable *const r1C53 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r1C53);
            ir_variable *const r1C54 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r1C54);
            ir_expression *const r1C55 = lshift(r1C19, body.constant(int(20)));
            ir_expression *const r1C56 = rshift(r1C1A, body.constant(int(12)));
            body.emit(assign(r1C53, bit_or(r1C55, r1C56), 0x01));

            body.emit(assign(r1C54, rshift(r1C19, body.constant(int(12))), 0x01));

            /* IF CONDITION */
            ir_expression *const r1C58 = nequal(r1C20, body.constant(0u));
            ir_expression *const r1C59 = nequal(r1C53, body.constant(0u));
            ir_expression *const r1C5A = logic_and(r1C58, r1C59);
            ir_if *f1C57 = new(mem_ctx) ir_if(operand(r1C5A).val);
            exec_list *const f1C57_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1C57->then_instructions;

               ir_variable *const r1C5B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r1C5D = nequal(r1C20, body.constant(0u));
               ir_if *f1C5C = new(mem_ctx) ir_if(operand(r1C5D).val);
               exec_list *const f1C5C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C5C->then_instructions;

                  body.emit(assign(r1C5B, body.constant(0u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1C5C->else_instructions;

                  body.emit(assign(r1C5B, body.constant(4294967295u), 0x01));


               body.instructions = f1C5C_parent_instructions;
               body.emit(f1C5C);

               /* END IF */

               body.emit(assign(r1C18, r1C5B, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1C57->else_instructions;

               body.emit(assign(r1C18, r1C53, 0x01));


            body.instructions = f1C57_parent_instructions;
            body.emit(f1C57);

            /* END IF */


         body.instructions = f1C4D_parent_instructions;
         body.emit(f1C4D);

         /* END IF */


      body.instructions = f1C23_parent_instructions;
      body.emit(f1C23);

      /* END IF */


   body.instructions = f1C21_parent_instructions;
   body.emit(f1C21);

   /* END IF */

   body.emit(ret(r1C18));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
ftrunc64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1C5E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1C5E);
   ir_variable *const r1C5F = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1C60 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r1C61 = rshift(swizzle_y(r1C5E), body.constant(int(20)));
   ir_expression *const r1C62 = bit_and(r1C61, body.constant(2047u));
   ir_expression *const r1C63 = expr(ir_unop_u2i, r1C62);
   body.emit(assign(r1C60, add(r1C63, body.constant(int(-1023))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1C65 = less(r1C60, body.constant(int(0)));
   ir_if *f1C64 = new(mem_ctx) ir_if(operand(r1C65).val);
   exec_list *const f1C64_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1C64->then_instructions;

      body.emit(assign(r1C5F, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1C64->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1C67 = greater(r1C60, body.constant(int(52)));
      ir_if *f1C66 = new(mem_ctx) ir_if(operand(r1C67).val);
      exec_list *const f1C66_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1C66->then_instructions;

         body.emit(assign(r1C5F, r1C5E, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1C66->else_instructions;

         ir_variable *const r1C68 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r1C68, sub(body.constant(int(52)), r1C60), 0x01));

         ir_variable *const r1C69 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1C6B = gequal(r1C68, body.constant(int(32)));
         ir_if *f1C6A = new(mem_ctx) ir_if(operand(r1C6B).val);
         exec_list *const f1C6A_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1C6A->then_instructions;

            body.emit(assign(r1C69, body.constant(0u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1C6A->else_instructions;

            body.emit(assign(r1C69, lshift(body.constant(4294967295u), r1C68), 0x01));


         body.instructions = f1C6A_parent_instructions;
         body.emit(f1C6A);

         /* END IF */

         ir_variable *const r1C6C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1C6E = less(r1C68, body.constant(int(33)));
         ir_if *f1C6D = new(mem_ctx) ir_if(operand(r1C6E).val);
         exec_list *const f1C6D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1C6D->then_instructions;

            body.emit(assign(r1C6C, body.constant(4294967295u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1C6D->else_instructions;

            ir_expression *const r1C6F = add(r1C68, body.constant(int(-32)));
            body.emit(assign(r1C6C, lshift(body.constant(4294967295u), r1C6F), 0x01));


         body.instructions = f1C6D_parent_instructions;
         body.emit(f1C6D);

         /* END IF */

         ir_variable *const r1C70 = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
         body.emit(assign(r1C70, bit_and(r1C69, swizzle_x(r1C5E)), 0x01));

         body.emit(assign(r1C70, bit_and(r1C6C, swizzle_y(r1C5E)), 0x02));

         body.emit(assign(r1C5F, r1C70, 0x03));


      body.instructions = f1C66_parent_instructions;
      body.emit(f1C66);

      /* END IF */


   body.instructions = f1C64_parent_instructions;
   body.emit(f1C64);

   /* END IF */

   body.emit(ret(r1C5F));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
ffloor64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1C71 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1C71);
   ir_variable *const r1C72 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1C73 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r1C74 = rshift(swizzle_y(r1C71), body.constant(int(20)));
   ir_expression *const r1C75 = bit_and(r1C74, body.constant(2047u));
   ir_expression *const r1C76 = expr(ir_unop_u2i, r1C75);
   body.emit(assign(r1C73, add(r1C76, body.constant(int(-1023))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1C78 = less(r1C73, body.constant(int(0)));
   ir_if *f1C77 = new(mem_ctx) ir_if(operand(r1C78).val);
   exec_list *const f1C77_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1C77->then_instructions;

      body.emit(assign(r1C72, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1C77->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1C7A = greater(r1C73, body.constant(int(52)));
      ir_if *f1C79 = new(mem_ctx) ir_if(operand(r1C7A).val);
      exec_list *const f1C79_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1C79->then_instructions;

         body.emit(assign(r1C72, r1C71, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1C79->else_instructions;

         ir_variable *const r1C7B = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r1C7B, sub(body.constant(int(52)), r1C73), 0x01));

         ir_variable *const r1C7C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1C7E = gequal(r1C7B, body.constant(int(32)));
         ir_if *f1C7D = new(mem_ctx) ir_if(operand(r1C7E).val);
         exec_list *const f1C7D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1C7D->then_instructions;

            body.emit(assign(r1C7C, body.constant(0u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1C7D->else_instructions;

            body.emit(assign(r1C7C, lshift(body.constant(4294967295u), r1C7B), 0x01));


         body.instructions = f1C7D_parent_instructions;
         body.emit(f1C7D);

         /* END IF */

         ir_variable *const r1C7F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1C81 = less(r1C7B, body.constant(int(33)));
         ir_if *f1C80 = new(mem_ctx) ir_if(operand(r1C81).val);
         exec_list *const f1C80_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1C80->then_instructions;

            body.emit(assign(r1C7F, body.constant(4294967295u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1C80->else_instructions;

            ir_expression *const r1C82 = add(r1C7B, body.constant(int(-32)));
            body.emit(assign(r1C7F, lshift(body.constant(4294967295u), r1C82), 0x01));


         body.instructions = f1C80_parent_instructions;
         body.emit(f1C80);

         /* END IF */

         ir_variable *const r1C83 = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
         body.emit(assign(r1C83, bit_and(r1C7C, swizzle_x(r1C71)), 0x01));

         body.emit(assign(r1C83, bit_and(r1C7F, swizzle_y(r1C71)), 0x02));

         body.emit(assign(r1C72, r1C83, 0x03));


      body.instructions = f1C79_parent_instructions;
      body.emit(f1C79);

      /* END IF */


   body.instructions = f1C77_parent_instructions;
   body.emit(f1C77);

   /* END IF */

   ir_variable *const r1C84 = body.make_temp(glsl_type::bool_type, "assignment_tmp");
   ir_expression *const r1C85 = rshift(swizzle_y(r1C71), body.constant(int(31)));
   ir_expression *const r1C86 = expr(ir_unop_u2i, r1C85);
   body.emit(assign(r1C84, expr(ir_unop_i2b, r1C86), 0x01));

   ir_variable *const r1C87 = body.make_temp(glsl_type::bool_type, "or_tmp");
   /* IF CONDITION */
   ir_expression *const r1C89 = expr(ir_unop_logic_not, r1C84);
   ir_if *f1C88 = new(mem_ctx) ir_if(operand(r1C89).val);
   exec_list *const f1C88_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1C88->then_instructions;

      body.emit(assign(r1C87, body.constant(true), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1C88->else_instructions;

      ir_variable *const r1C8A = body.make_temp(glsl_type::bool_type, "return_value");
      ir_variable *const r1C8B = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
      body.emit(r1C8B);
      ir_variable *const r1C8C = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
      body.emit(r1C8C);
      ir_expression *const r1C8D = rshift(swizzle_y(r1C71), body.constant(int(20)));
      ir_expression *const r1C8E = bit_and(r1C8D, body.constant(2047u));
      ir_expression *const r1C8F = expr(ir_unop_u2i, r1C8E);
      ir_expression *const r1C90 = equal(r1C8F, body.constant(int(2047)));
      ir_expression *const r1C91 = bit_and(swizzle_y(r1C71), body.constant(1048575u));
      ir_expression *const r1C92 = bit_or(r1C91, swizzle_x(r1C71));
      ir_expression *const r1C93 = nequal(r1C92, body.constant(0u));
      body.emit(assign(r1C8C, logic_and(r1C90, r1C93), 0x01));

      ir_expression *const r1C94 = rshift(swizzle_y(r1C72), body.constant(int(20)));
      ir_expression *const r1C95 = bit_and(r1C94, body.constant(2047u));
      ir_expression *const r1C96 = expr(ir_unop_u2i, r1C95);
      ir_expression *const r1C97 = equal(r1C96, body.constant(int(2047)));
      ir_expression *const r1C98 = bit_and(swizzle_y(r1C72), body.constant(1048575u));
      ir_expression *const r1C99 = bit_or(r1C98, swizzle_x(r1C72));
      ir_expression *const r1C9A = nequal(r1C99, body.constant(0u));
      body.emit(assign(r1C8B, logic_and(r1C97, r1C9A), 0x01));

      /* IF CONDITION */
      ir_expression *const r1C9C = logic_or(r1C8C, r1C8B);
      ir_if *f1C9B = new(mem_ctx) ir_if(operand(r1C9C).val);
      exec_list *const f1C9B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1C9B->then_instructions;

         body.emit(assign(r1C8A, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1C9B->else_instructions;

         ir_expression *const r1C9D = equal(swizzle_x(r1C71), swizzle_x(r1C72));
         ir_expression *const r1C9E = equal(swizzle_y(r1C71), swizzle_y(r1C72));
         ir_expression *const r1C9F = equal(swizzle_x(r1C71), body.constant(0u));
         ir_expression *const r1CA0 = bit_or(swizzle_y(r1C71), swizzle_y(r1C72));
         ir_expression *const r1CA1 = lshift(r1CA0, body.constant(int(1)));
         ir_expression *const r1CA2 = equal(r1CA1, body.constant(0u));
         ir_expression *const r1CA3 = logic_and(r1C9F, r1CA2);
         ir_expression *const r1CA4 = logic_or(r1C9E, r1CA3);
         body.emit(assign(r1C8A, logic_and(r1C9D, r1CA4), 0x01));


      body.instructions = f1C9B_parent_instructions;
      body.emit(f1C9B);

      /* END IF */

      body.emit(assign(r1C87, r1C8A, 0x01));


   body.instructions = f1C88_parent_instructions;
   body.emit(f1C88);

   /* END IF */

   ir_variable *const r1CA5 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
   /* IF CONDITION */
   ir_if *f1CA6 = new(mem_ctx) ir_if(operand(r1C87).val);
   exec_list *const f1CA6_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1CA6->then_instructions;

      body.emit(assign(r1CA5, r1C72, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1CA6->else_instructions;

      ir_variable *const r1CA7 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r1CA8 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r1CA8, rshift(swizzle_y(r1C72), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r1CAA = equal(r1CA8, body.constant(0u));
      ir_if *f1CA9 = new(mem_ctx) ir_if(operand(r1CAA).val);
      exec_list *const f1CA9_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1CA9->then_instructions;

         ir_variable *const r1CAB = body.make_temp(glsl_type::uint_type, "zSign");
         body.emit(assign(r1CAB, r1CA8, 0x01));

         ir_variable *const r1CAC = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r1CAD = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r1CAD);
         ir_variable *const r1CAE = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
         body.emit(r1CAE);
         ir_variable *const r1CAF = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
         body.emit(r1CAF);
         ir_variable *const r1CB0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r1CB0);
         ir_variable *const r1CB1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r1CB1);
         ir_variable *const r1CB2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r1CB2);
         ir_variable *const r1CB3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r1CB3);
         ir_variable *const r1CB4 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r1CB4);
         ir_variable *const r1CB5 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r1CB5, body.constant(0u), 0x01));

         ir_variable *const r1CB6 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r1CB7 = rshift(swizzle_y(r1C72), body.constant(int(20)));
         ir_expression *const r1CB8 = bit_and(r1CB7, body.constant(2047u));
         body.emit(assign(r1CB6, expr(ir_unop_u2i, r1CB8), 0x01));

         body.emit(assign(r1CAF, r1CB6, 0x01));

         body.emit(assign(r1CAE, body.constant(int(1023)), 0x01));

         body.emit(assign(r1CAD, add(r1CB6, body.constant(int(-1023))), 0x01));

         ir_variable *const r1CB9 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r1CB9, lshift(swizzle_x(r1C72), body.constant(int(10))), 0x01));

         ir_variable *const r1CBA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         ir_expression *const r1CBB = bit_and(swizzle_y(r1C72), body.constant(1048575u));
         ir_expression *const r1CBC = lshift(r1CBB, body.constant(int(10)));
         ir_expression *const r1CBD = rshift(swizzle_x(r1C72), body.constant(int(22)));
         body.emit(assign(r1CBA, bit_or(r1CBC, r1CBD), 0x01));

         body.emit(assign(r1CB2, r1CBA, 0x01));

         body.emit(assign(r1CB3, r1CB9, 0x01));

         ir_variable *const r1CBE = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r1CBE, body.constant(0u), 0x01));

         ir_variable *const r1CBF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         body.emit(assign(r1CBF, body.constant(0u), 0x01));

         body.emit(assign(r1CB0, r1CBF, 0x01));

         body.emit(assign(r1CB1, body.constant(0u), 0x01));

         /* IF CONDITION */
         ir_expression *const r1CC1 = less(body.constant(int(0)), r1CAD);
         ir_if *f1CC0 = new(mem_ctx) ir_if(operand(r1CC1).val);
         exec_list *const f1CC0_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1CC0->then_instructions;

            /* IF CONDITION */
            ir_expression *const r1CC3 = equal(r1CB6, body.constant(int(2047)));
            ir_if *f1CC2 = new(mem_ctx) ir_if(operand(r1CC3).val);
            exec_list *const f1CC2_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1CC2->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1CC5 = bit_or(r1CBA, r1CB9);
               ir_expression *const r1CC6 = nequal(r1CC5, body.constant(0u));
               ir_if *f1CC4 = new(mem_ctx) ir_if(operand(r1CC6).val);
               exec_list *const f1CC4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1CC4->then_instructions;

                  ir_variable *const r1CC7 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r1CC7, swizzle_x(r1C72), 0x01));

                  ir_variable *const r1CC8 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r1CC8, body.constant(0u), 0x01));

                  ir_variable *const r1CC9 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r1CC7, bit_or(swizzle_y(r1C72), body.constant(524288u)), 0x02));

                  body.emit(assign(r1CC8, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r1CCB = lshift(swizzle_y(r1C72), body.constant(int(1)));
                  ir_expression *const r1CCC = lequal(body.constant(4292870144u), r1CCB);
                  ir_expression *const r1CCD = nequal(swizzle_x(r1C72), body.constant(0u));
                  ir_expression *const r1CCE = bit_and(swizzle_y(r1C72), body.constant(1048575u));
                  ir_expression *const r1CCF = nequal(r1CCE, body.constant(0u));
                  ir_expression *const r1CD0 = logic_or(r1CCD, r1CCF);
                  ir_expression *const r1CD1 = logic_and(r1CCC, r1CD0);
                  ir_if *f1CCA = new(mem_ctx) ir_if(operand(r1CD1).val);
                  exec_list *const f1CCA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1CCA->then_instructions;

                     body.emit(assign(r1CC9, r1CC7, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1CCA->else_instructions;

                     body.emit(assign(r1CC9, r1CC8, 0x03));


                  body.instructions = f1CCA_parent_instructions;
                  body.emit(f1CCA);

                  /* END IF */

                  body.emit(assign(r1CAC, r1CC9, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1CC4->else_instructions;

                  body.emit(assign(r1CAC, r1C72, 0x03));


               body.instructions = f1CC4_parent_instructions;
               body.emit(f1CC4);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1CC2->else_instructions;

               body.emit(assign(r1CB0, body.constant(1073741824u), 0x01));

               ir_variable *const r1CD2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1CD2);
               ir_variable *const r1CD3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1CD3);
               ir_variable *const r1CD4 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r1CD5 = neg(r1CAD);
               body.emit(assign(r1CD4, bit_and(r1CD5, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1CD7 = equal(r1CAD, body.constant(int(0)));
               ir_if *f1CD6 = new(mem_ctx) ir_if(operand(r1CD7).val);
               exec_list *const f1CD6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1CD6->then_instructions;

                  body.emit(assign(r1CD2, body.constant(0u), 0x01));

                  body.emit(assign(r1CD3, r1CB0, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1CD6->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1CD9 = less(r1CAD, body.constant(int(32)));
                  ir_if *f1CD8 = new(mem_ctx) ir_if(operand(r1CD9).val);
                  exec_list *const f1CD8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1CD8->then_instructions;

                     ir_expression *const r1CDA = lshift(body.constant(1073741824u), r1CD4);
                     ir_expression *const r1CDB = bit_or(r1CDA, body.constant(0u));
                     body.emit(assign(r1CD2, bit_or(r1CDB, body.constant(0u)), 0x01));

                     body.emit(assign(r1CD3, rshift(body.constant(1073741824u), r1CAD), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1CD8->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1CDD = equal(r1CAD, body.constant(int(32)));
                     ir_if *f1CDC = new(mem_ctx) ir_if(operand(r1CDD).val);
                     exec_list *const f1CDC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1CDC->then_instructions;

                        body.emit(assign(r1CD2, body.constant(1073741824u), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1CDC->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1CDF = less(r1CAD, body.constant(int(64)));
                        ir_if *f1CDE = new(mem_ctx) ir_if(operand(r1CDF).val);
                        exec_list *const f1CDE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1CDE->then_instructions;

                           ir_expression *const r1CE0 = bit_and(r1CAD, body.constant(int(31)));
                           ir_expression *const r1CE1 = rshift(body.constant(1073741824u), r1CE0);
                           ir_expression *const r1CE2 = lshift(body.constant(1073741824u), r1CD4);
                           ir_expression *const r1CE3 = bit_or(r1CE2, body.constant(0u));
                           ir_expression *const r1CE4 = nequal(r1CE3, body.constant(0u));
                           ir_expression *const r1CE5 = expr(ir_unop_b2i, r1CE4);
                           ir_expression *const r1CE6 = expr(ir_unop_i2u, r1CE5);
                           body.emit(assign(r1CD2, bit_or(r1CE1, r1CE6), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1CDE->else_instructions;

                           body.emit(assign(r1CD2, body.constant(1u), 0x01));


                        body.instructions = f1CDE_parent_instructions;
                        body.emit(f1CDE);

                        /* END IF */


                     body.instructions = f1CDC_parent_instructions;
                     body.emit(f1CDC);

                     /* END IF */

                     body.emit(assign(r1CD3, body.constant(0u), 0x01));


                  body.instructions = f1CD8_parent_instructions;
                  body.emit(f1CD8);

                  /* END IF */


               body.instructions = f1CD6_parent_instructions;
               body.emit(f1CD6);

               /* END IF */

               body.emit(assign(r1CB0, r1CD3, 0x01));

               body.emit(assign(r1CB1, r1CD2, 0x01));

               body.emit(assign(r1CB2, bit_or(r1CBA, body.constant(1073741824u)), 0x01));

               ir_variable *const r1CE7 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r1CE8 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r1CE8, sub(r1CB9, r1CD2), 0x01));

               ir_expression *const r1CE9 = sub(r1CB2, r1CD3);
               ir_expression *const r1CEA = less(r1CB9, r1CD2);
               ir_expression *const r1CEB = expr(ir_unop_b2i, r1CEA);
               ir_expression *const r1CEC = expr(ir_unop_i2u, r1CEB);
               body.emit(assign(r1CE7, sub(r1CE9, r1CEC), 0x01));

               body.emit(assign(r1CB4, add(r1CB6, body.constant(int(-1))), 0x01));

               ir_variable *const r1CED = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r1CED, add(r1CB4, body.constant(int(-10))), 0x01));

               ir_variable *const r1CEE = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r1CEE, r1CE7, 0x01));

               ir_variable *const r1CEF = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r1CEF, r1CE8, 0x01));

               ir_variable *const r1CF0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r1CF0);
               ir_variable *const r1CF1 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1CF1);
               /* IF CONDITION */
               ir_expression *const r1CF3 = equal(r1CE7, body.constant(0u));
               ir_if *f1CF2 = new(mem_ctx) ir_if(operand(r1CF3).val);
               exec_list *const f1CF2_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1CF2->then_instructions;

                  body.emit(assign(r1CEE, r1CE8, 0x01));

                  body.emit(assign(r1CEF, body.constant(0u), 0x01));

                  body.emit(assign(r1CED, add(r1CED, body.constant(int(-32))), 0x01));


               body.instructions = f1CF2_parent_instructions;
               body.emit(f1CF2);

               /* END IF */

               ir_variable *const r1CF4 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r1CF4, r1CEE, 0x01));

               ir_variable *const r1CF5 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r1CF6 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1CF6);
               /* IF CONDITION */
               ir_expression *const r1CF8 = equal(r1CEE, body.constant(0u));
               ir_if *f1CF7 = new(mem_ctx) ir_if(operand(r1CF8).val);
               exec_list *const f1CF7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1CF7->then_instructions;

                  body.emit(assign(r1CF5, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1CF7->else_instructions;

                  body.emit(assign(r1CF6, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1CFA = bit_and(r1CEE, body.constant(4294901760u));
                  ir_expression *const r1CFB = equal(r1CFA, body.constant(0u));
                  ir_if *f1CF9 = new(mem_ctx) ir_if(operand(r1CFB).val);
                  exec_list *const f1CF9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1CF9->then_instructions;

                     body.emit(assign(r1CF6, body.constant(int(16)), 0x01));

                     body.emit(assign(r1CF4, lshift(r1CEE, body.constant(int(16))), 0x01));


                  body.instructions = f1CF9_parent_instructions;
                  body.emit(f1CF9);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1CFD = bit_and(r1CF4, body.constant(4278190080u));
                  ir_expression *const r1CFE = equal(r1CFD, body.constant(0u));
                  ir_if *f1CFC = new(mem_ctx) ir_if(operand(r1CFE).val);
                  exec_list *const f1CFC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1CFC->then_instructions;

                     body.emit(assign(r1CF6, add(r1CF6, body.constant(int(8))), 0x01));

                     body.emit(assign(r1CF4, lshift(r1CF4, body.constant(int(8))), 0x01));


                  body.instructions = f1CFC_parent_instructions;
                  body.emit(f1CFC);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1D00 = bit_and(r1CF4, body.constant(4026531840u));
                  ir_expression *const r1D01 = equal(r1D00, body.constant(0u));
                  ir_if *f1CFF = new(mem_ctx) ir_if(operand(r1D01).val);
                  exec_list *const f1CFF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1CFF->then_instructions;

                     body.emit(assign(r1CF6, add(r1CF6, body.constant(int(4))), 0x01));

                     body.emit(assign(r1CF4, lshift(r1CF4, body.constant(int(4))), 0x01));


                  body.instructions = f1CFF_parent_instructions;
                  body.emit(f1CFF);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1D03 = bit_and(r1CF4, body.constant(3221225472u));
                  ir_expression *const r1D04 = equal(r1D03, body.constant(0u));
                  ir_if *f1D02 = new(mem_ctx) ir_if(operand(r1D04).val);
                  exec_list *const f1D02_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D02->then_instructions;

                     body.emit(assign(r1CF6, add(r1CF6, body.constant(int(2))), 0x01));

                     body.emit(assign(r1CF4, lshift(r1CF4, body.constant(int(2))), 0x01));


                  body.instructions = f1D02_parent_instructions;
                  body.emit(f1D02);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1D06 = bit_and(r1CF4, body.constant(2147483648u));
                  ir_expression *const r1D07 = equal(r1D06, body.constant(0u));
                  ir_if *f1D05 = new(mem_ctx) ir_if(operand(r1D07).val);
                  exec_list *const f1D05_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D05->then_instructions;

                     body.emit(assign(r1CF6, add(r1CF6, body.constant(int(1))), 0x01));


                  body.instructions = f1D05_parent_instructions;
                  body.emit(f1D05);

                  /* END IF */

                  body.emit(assign(r1CF5, r1CF6, 0x01));


               body.instructions = f1CF7_parent_instructions;
               body.emit(f1CF7);

               /* END IF */

               body.emit(assign(r1CF1, add(r1CF5, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1D09 = lequal(body.constant(int(0)), r1CF1);
               ir_if *f1D08 = new(mem_ctx) ir_if(operand(r1D09).val);
               exec_list *const f1D08_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1D08->then_instructions;

                  body.emit(assign(r1CF0, body.constant(0u), 0x01));

                  ir_variable *const r1D0A = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r1D0A, lshift(r1CEF, r1CF1), 0x01));

                  ir_variable *const r1D0B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1D0D = equal(r1CF1, body.constant(int(0)));
                  ir_if *f1D0C = new(mem_ctx) ir_if(operand(r1D0D).val);
                  exec_list *const f1D0C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D0C->then_instructions;

                     body.emit(assign(r1D0B, r1CEE, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1D0C->else_instructions;

                     ir_expression *const r1D0E = lshift(r1CEE, r1CF1);
                     ir_expression *const r1D0F = neg(r1CF1);
                     ir_expression *const r1D10 = bit_and(r1D0F, body.constant(int(31)));
                     ir_expression *const r1D11 = rshift(r1CEF, r1D10);
                     body.emit(assign(r1D0B, bit_or(r1D0E, r1D11), 0x01));


                  body.instructions = f1D0C_parent_instructions;
                  body.emit(f1D0C);

                  /* END IF */

                  body.emit(assign(r1CEE, r1D0B, 0x01));

                  body.emit(assign(r1CEF, r1D0A, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1D08->else_instructions;

                  ir_variable *const r1D12 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r1D12, body.constant(0u), 0x01));

                  ir_variable *const r1D13 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r1D13, neg(r1CF1), 0x01));

                  ir_variable *const r1D14 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r1D14);
                  ir_variable *const r1D15 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1D15);
                  ir_variable *const r1D16 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1D16);
                  ir_variable *const r1D17 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r1D18 = neg(r1D13);
                  body.emit(assign(r1D17, bit_and(r1D18, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1D1A = equal(r1D13, body.constant(int(0)));
                  ir_if *f1D19 = new(mem_ctx) ir_if(operand(r1D1A).val);
                  exec_list *const f1D19_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D19->then_instructions;

                     body.emit(assign(r1D14, r1D12, 0x01));

                     body.emit(assign(r1D15, r1CEF, 0x01));

                     body.emit(assign(r1D16, r1CEE, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1D19->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1D1C = less(r1D13, body.constant(int(32)));
                     ir_if *f1D1B = new(mem_ctx) ir_if(operand(r1D1C).val);
                     exec_list *const f1D1B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1D1B->then_instructions;

                        body.emit(assign(r1D14, lshift(r1CEF, r1D17), 0x01));

                        ir_expression *const r1D1D = lshift(r1CEE, r1D17);
                        ir_expression *const r1D1E = rshift(r1CEF, r1D13);
                        body.emit(assign(r1D15, bit_or(r1D1D, r1D1E), 0x01));

                        body.emit(assign(r1D16, rshift(r1CEE, r1D13), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1D1B->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1D20 = equal(r1D13, body.constant(int(32)));
                        ir_if *f1D1F = new(mem_ctx) ir_if(operand(r1D20).val);
                        exec_list *const f1D1F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1D1F->then_instructions;

                           body.emit(assign(r1D14, r1CEF, 0x01));

                           body.emit(assign(r1D15, r1CEE, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1D1F->else_instructions;

                           body.emit(assign(r1D12, bit_or(body.constant(0u), r1CEF), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1D22 = less(r1D13, body.constant(int(64)));
                           ir_if *f1D21 = new(mem_ctx) ir_if(operand(r1D22).val);
                           exec_list *const f1D21_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1D21->then_instructions;

                              body.emit(assign(r1D14, lshift(r1CEE, r1D17), 0x01));

                              ir_expression *const r1D23 = bit_and(r1D13, body.constant(int(31)));
                              body.emit(assign(r1D15, rshift(r1CEE, r1D23), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1D21->else_instructions;

                              ir_variable *const r1D24 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1D26 = equal(r1D13, body.constant(int(64)));
                              ir_if *f1D25 = new(mem_ctx) ir_if(operand(r1D26).val);
                              exec_list *const f1D25_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1D25->then_instructions;

                                 body.emit(assign(r1D24, r1CEE, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1D25->else_instructions;

                                 ir_expression *const r1D27 = nequal(r1CEE, body.constant(0u));
                                 ir_expression *const r1D28 = expr(ir_unop_b2i, r1D27);
                                 body.emit(assign(r1D24, expr(ir_unop_i2u, r1D28), 0x01));


                              body.instructions = f1D25_parent_instructions;
                              body.emit(f1D25);

                              /* END IF */

                              body.emit(assign(r1D14, r1D24, 0x01));

                              body.emit(assign(r1D15, body.constant(0u), 0x01));


                           body.instructions = f1D21_parent_instructions;
                           body.emit(f1D21);

                           /* END IF */


                        body.instructions = f1D1F_parent_instructions;
                        body.emit(f1D1F);

                        /* END IF */

                        body.emit(assign(r1D16, body.constant(0u), 0x01));


                     body.instructions = f1D1B_parent_instructions;
                     body.emit(f1D1B);

                     /* END IF */

                     ir_expression *const r1D29 = nequal(r1D12, body.constant(0u));
                     ir_expression *const r1D2A = expr(ir_unop_b2i, r1D29);
                     ir_expression *const r1D2B = expr(ir_unop_i2u, r1D2A);
                     body.emit(assign(r1D14, bit_or(r1D14, r1D2B), 0x01));


                  body.instructions = f1D19_parent_instructions;
                  body.emit(f1D19);

                  /* END IF */

                  body.emit(assign(r1CEE, r1D16, 0x01));

                  body.emit(assign(r1CEF, r1D15, 0x01));

                  body.emit(assign(r1CF0, r1D14, 0x01));


               body.instructions = f1D08_parent_instructions;
               body.emit(f1D08);

               /* END IF */

               body.emit(assign(r1CED, sub(r1CED, r1CF1), 0x01));

               ir_variable *const r1D2C = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r1D2C, r1CED, 0x01));

               ir_variable *const r1D2D = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r1D2D, r1CEE, 0x01));

               ir_variable *const r1D2E = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r1D2E, r1CEF, 0x01));

               ir_variable *const r1D2F = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r1D2F, r1CF0, 0x01));

               ir_variable *const r1D30 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r1D30, body.constant(true), 0x01));

               ir_variable *const r1D31 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r1D32 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r1D32);
               ir_expression *const r1D33 = expr(ir_unop_u2i, r1CF0);
               body.emit(assign(r1D32, less(r1D33, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1D35 = lequal(body.constant(int(2045)), r1CED);
               ir_if *f1D34 = new(mem_ctx) ir_if(operand(r1D35).val);
               exec_list *const f1D34_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1D34->then_instructions;

                  ir_variable *const r1D36 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1D38 = less(body.constant(int(2045)), r1CED);
                  ir_if *f1D37 = new(mem_ctx) ir_if(operand(r1D38).val);
                  exec_list *const f1D37_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D37->then_instructions;

                     body.emit(assign(r1D36, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1D37->else_instructions;

                     ir_variable *const r1D39 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1D3B = equal(r1CED, body.constant(int(2045)));
                     ir_if *f1D3A = new(mem_ctx) ir_if(operand(r1D3B).val);
                     exec_list *const f1D3A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1D3A->then_instructions;

                        ir_expression *const r1D3C = equal(body.constant(2097151u), r1CEE);
                        ir_expression *const r1D3D = equal(body.constant(4294967295u), r1CEF);
                        body.emit(assign(r1D39, logic_and(r1D3C, r1D3D), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1D3A->else_instructions;

                        body.emit(assign(r1D39, body.constant(false), 0x01));


                     body.instructions = f1D3A_parent_instructions;
                     body.emit(f1D3A);

                     /* END IF */

                     body.emit(assign(r1D36, logic_and(r1D39, r1D32), 0x01));


                  body.instructions = f1D37_parent_instructions;
                  body.emit(f1D37);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f1D3E = new(mem_ctx) ir_if(operand(r1D36).val);
                  exec_list *const f1D3E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D3E->then_instructions;

                     ir_variable *const r1D3F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r1D3F);
                     ir_expression *const r1D40 = lshift(r1CA8, body.constant(int(31)));
                     body.emit(assign(r1D3F, add(r1D40, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r1D3F, body.constant(0u), 0x01));

                     body.emit(assign(r1D31, r1D3F, 0x03));

                     body.emit(assign(r1D30, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1D3E->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1D42 = less(r1CED, body.constant(int(0)));
                     ir_if *f1D41 = new(mem_ctx) ir_if(operand(r1D42).val);
                     exec_list *const f1D41_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1D41->then_instructions;

                        ir_variable *const r1D43 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r1D43, r1CF0, 0x01));

                        ir_variable *const r1D44 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r1D44, neg(r1CED), 0x01));

                        ir_variable *const r1D45 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r1D45);
                        ir_variable *const r1D46 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r1D46);
                        ir_variable *const r1D47 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r1D47);
                        ir_variable *const r1D48 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r1D49 = neg(r1D44);
                        body.emit(assign(r1D48, bit_and(r1D49, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1D4B = equal(r1D44, body.constant(int(0)));
                        ir_if *f1D4A = new(mem_ctx) ir_if(operand(r1D4B).val);
                        exec_list *const f1D4A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1D4A->then_instructions;

                           body.emit(assign(r1D45, r1CF0, 0x01));

                           body.emit(assign(r1D46, r1CEF, 0x01));

                           body.emit(assign(r1D47, r1CEE, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1D4A->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1D4D = less(r1D44, body.constant(int(32)));
                           ir_if *f1D4C = new(mem_ctx) ir_if(operand(r1D4D).val);
                           exec_list *const f1D4C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1D4C->then_instructions;

                              body.emit(assign(r1D45, lshift(r1CEF, r1D48), 0x01));

                              ir_expression *const r1D4E = lshift(r1CEE, r1D48);
                              ir_expression *const r1D4F = rshift(r1CEF, r1D44);
                              body.emit(assign(r1D46, bit_or(r1D4E, r1D4F), 0x01));

                              body.emit(assign(r1D47, rshift(r1CEE, r1D44), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1D4C->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1D51 = equal(r1D44, body.constant(int(32)));
                              ir_if *f1D50 = new(mem_ctx) ir_if(operand(r1D51).val);
                              exec_list *const f1D50_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1D50->then_instructions;

                                 body.emit(assign(r1D45, r1CEF, 0x01));

                                 body.emit(assign(r1D46, r1CEE, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1D50->else_instructions;

                                 body.emit(assign(r1D43, bit_or(r1CF0, r1CEF), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1D53 = less(r1D44, body.constant(int(64)));
                                 ir_if *f1D52 = new(mem_ctx) ir_if(operand(r1D53).val);
                                 exec_list *const f1D52_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1D52->then_instructions;

                                    body.emit(assign(r1D45, lshift(r1CEE, r1D48), 0x01));

                                    ir_expression *const r1D54 = bit_and(r1D44, body.constant(int(31)));
                                    body.emit(assign(r1D46, rshift(r1CEE, r1D54), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1D52->else_instructions;

                                    ir_variable *const r1D55 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r1D57 = equal(r1D44, body.constant(int(64)));
                                    ir_if *f1D56 = new(mem_ctx) ir_if(operand(r1D57).val);
                                    exec_list *const f1D56_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1D56->then_instructions;

                                       body.emit(assign(r1D55, r1CEE, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1D56->else_instructions;

                                       ir_expression *const r1D58 = nequal(r1CEE, body.constant(0u));
                                       ir_expression *const r1D59 = expr(ir_unop_b2i, r1D58);
                                       body.emit(assign(r1D55, expr(ir_unop_i2u, r1D59), 0x01));


                                    body.instructions = f1D56_parent_instructions;
                                    body.emit(f1D56);

                                    /* END IF */

                                    body.emit(assign(r1D45, r1D55, 0x01));

                                    body.emit(assign(r1D46, body.constant(0u), 0x01));


                                 body.instructions = f1D52_parent_instructions;
                                 body.emit(f1D52);

                                 /* END IF */


                              body.instructions = f1D50_parent_instructions;
                              body.emit(f1D50);

                              /* END IF */

                              body.emit(assign(r1D47, body.constant(0u), 0x01));


                           body.instructions = f1D4C_parent_instructions;
                           body.emit(f1D4C);

                           /* END IF */

                           ir_expression *const r1D5A = nequal(r1D43, body.constant(0u));
                           ir_expression *const r1D5B = expr(ir_unop_b2i, r1D5A);
                           ir_expression *const r1D5C = expr(ir_unop_i2u, r1D5B);
                           body.emit(assign(r1D45, bit_or(r1D45, r1D5C), 0x01));


                        body.instructions = f1D4A_parent_instructions;
                        body.emit(f1D4A);

                        /* END IF */

                        body.emit(assign(r1D2D, r1D47, 0x01));

                        body.emit(assign(r1D2E, r1D46, 0x01));

                        body.emit(assign(r1D2F, r1D45, 0x01));

                        body.emit(assign(r1D2C, body.constant(int(0)), 0x01));

                        body.emit(assign(r1D32, less(r1D45, body.constant(0u)), 0x01));


                     body.instructions = f1D41_parent_instructions;
                     body.emit(f1D41);

                     /* END IF */


                  body.instructions = f1D3E_parent_instructions;
                  body.emit(f1D3E);

                  /* END IF */


               body.instructions = f1D34_parent_instructions;
               body.emit(f1D34);

               /* END IF */

               /* IF CONDITION */
               ir_if *f1D5D = new(mem_ctx) ir_if(operand(r1D30).val);
               exec_list *const f1D5D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1D5D->then_instructions;

                  /* IF CONDITION */
                  ir_if *f1D5E = new(mem_ctx) ir_if(operand(r1D32).val);
                  exec_list *const f1D5E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D5E->then_instructions;

                     ir_variable *const r1D5F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r1D5F, add(r1D2E, body.constant(1u)), 0x01));

                     ir_expression *const r1D60 = less(r1D5F, r1D2E);
                     ir_expression *const r1D61 = expr(ir_unop_b2i, r1D60);
                     ir_expression *const r1D62 = expr(ir_unop_i2u, r1D61);
                     body.emit(assign(r1D2D, add(r1D2D, r1D62), 0x01));

                     ir_expression *const r1D63 = equal(r1D2F, body.constant(0u));
                     ir_expression *const r1D64 = expr(ir_unop_b2i, r1D63);
                     ir_expression *const r1D65 = expr(ir_unop_i2u, r1D64);
                     ir_expression *const r1D66 = add(r1D2F, r1D65);
                     ir_expression *const r1D67 = bit_and(r1D66, body.constant(1u));
                     ir_expression *const r1D68 = expr(ir_unop_bit_not, r1D67);
                     body.emit(assign(r1D2E, bit_and(r1D5F, r1D68), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1D5E->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1D6A = bit_or(r1D2D, r1D2E);
                     ir_expression *const r1D6B = equal(r1D6A, body.constant(0u));
                     ir_if *f1D69 = new(mem_ctx) ir_if(operand(r1D6B).val);
                     exec_list *const f1D69_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1D69->then_instructions;

                        body.emit(assign(r1D2C, body.constant(int(0)), 0x01));


                     body.instructions = f1D69_parent_instructions;
                     body.emit(f1D69);

                     /* END IF */


                  body.instructions = f1D5E_parent_instructions;
                  body.emit(f1D5E);

                  /* END IF */

                  ir_variable *const r1D6C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1D6C);
                  ir_expression *const r1D6D = lshift(r1CA8, body.constant(int(31)));
                  ir_expression *const r1D6E = expr(ir_unop_i2u, r1D2C);
                  ir_expression *const r1D6F = lshift(r1D6E, body.constant(int(20)));
                  ir_expression *const r1D70 = add(r1D6D, r1D6F);
                  body.emit(assign(r1D6C, add(r1D70, r1D2D), 0x02));

                  body.emit(assign(r1D6C, r1D2E, 0x01));

                  body.emit(assign(r1D31, r1D6C, 0x03));

                  body.emit(assign(r1D30, body.constant(false), 0x01));


               body.instructions = f1D5D_parent_instructions;
               body.emit(f1D5D);

               /* END IF */

               body.emit(assign(r1CAC, r1D31, 0x03));


            body.instructions = f1CC2_parent_instructions;
            body.emit(f1CC2);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1CC0->else_instructions;

            /* IF CONDITION */
            ir_expression *const r1D72 = less(r1CAD, body.constant(int(0)));
            ir_if *f1D71 = new(mem_ctx) ir_if(operand(r1D72).val);
            exec_list *const f1D71_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1D71->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1D74 = equal(r1CB6, body.constant(int(0)));
               ir_if *f1D73 = new(mem_ctx) ir_if(operand(r1D74).val);
               exec_list *const f1D73_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1D73->then_instructions;

                  body.emit(assign(r1CAD, add(r1CAD, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1D73->else_instructions;

                  body.emit(assign(r1CB2, bit_or(r1CB2, body.constant(1073741824u)), 0x01));


               body.instructions = f1D73_parent_instructions;
               body.emit(f1D73);

               /* END IF */

               ir_variable *const r1D75 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r1D75, neg(r1CAD), 0x01));

               ir_variable *const r1D76 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1D76);
               ir_variable *const r1D77 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1D77);
               ir_variable *const r1D78 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r1D79 = neg(r1D75);
               body.emit(assign(r1D78, bit_and(r1D79, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1D7B = equal(r1D75, body.constant(int(0)));
               ir_if *f1D7A = new(mem_ctx) ir_if(operand(r1D7B).val);
               exec_list *const f1D7A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1D7A->then_instructions;

                  body.emit(assign(r1D76, r1CB9, 0x01));

                  body.emit(assign(r1D77, r1CB2, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1D7A->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1D7D = less(r1D75, body.constant(int(32)));
                  ir_if *f1D7C = new(mem_ctx) ir_if(operand(r1D7D).val);
                  exec_list *const f1D7C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D7C->then_instructions;

                     ir_expression *const r1D7E = lshift(r1CB2, r1D78);
                     ir_expression *const r1D7F = rshift(r1CB9, r1D75);
                     ir_expression *const r1D80 = bit_or(r1D7E, r1D7F);
                     ir_expression *const r1D81 = lshift(r1CB9, r1D78);
                     ir_expression *const r1D82 = nequal(r1D81, body.constant(0u));
                     ir_expression *const r1D83 = expr(ir_unop_b2i, r1D82);
                     ir_expression *const r1D84 = expr(ir_unop_i2u, r1D83);
                     body.emit(assign(r1D76, bit_or(r1D80, r1D84), 0x01));

                     body.emit(assign(r1D77, rshift(r1CB2, r1D75), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1D7C->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1D86 = equal(r1D75, body.constant(int(32)));
                     ir_if *f1D85 = new(mem_ctx) ir_if(operand(r1D86).val);
                     exec_list *const f1D85_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1D85->then_instructions;

                        ir_expression *const r1D87 = nequal(r1CB9, body.constant(0u));
                        ir_expression *const r1D88 = expr(ir_unop_b2i, r1D87);
                        ir_expression *const r1D89 = expr(ir_unop_i2u, r1D88);
                        body.emit(assign(r1D76, bit_or(r1CB2, r1D89), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1D85->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1D8B = less(r1D75, body.constant(int(64)));
                        ir_if *f1D8A = new(mem_ctx) ir_if(operand(r1D8B).val);
                        exec_list *const f1D8A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1D8A->then_instructions;

                           ir_expression *const r1D8C = bit_and(r1D75, body.constant(int(31)));
                           ir_expression *const r1D8D = rshift(r1CB2, r1D8C);
                           ir_expression *const r1D8E = lshift(r1CB2, r1D78);
                           ir_expression *const r1D8F = bit_or(r1D8E, r1CB9);
                           ir_expression *const r1D90 = nequal(r1D8F, body.constant(0u));
                           ir_expression *const r1D91 = expr(ir_unop_b2i, r1D90);
                           ir_expression *const r1D92 = expr(ir_unop_i2u, r1D91);
                           body.emit(assign(r1D76, bit_or(r1D8D, r1D92), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1D8A->else_instructions;

                           ir_expression *const r1D93 = bit_or(r1CB2, r1CB9);
                           ir_expression *const r1D94 = nequal(r1D93, body.constant(0u));
                           ir_expression *const r1D95 = expr(ir_unop_b2i, r1D94);
                           body.emit(assign(r1D76, expr(ir_unop_i2u, r1D95), 0x01));


                        body.instructions = f1D8A_parent_instructions;
                        body.emit(f1D8A);

                        /* END IF */


                     body.instructions = f1D85_parent_instructions;
                     body.emit(f1D85);

                     /* END IF */

                     body.emit(assign(r1D77, body.constant(0u), 0x01));


                  body.instructions = f1D7C_parent_instructions;
                  body.emit(f1D7C);

                  /* END IF */


               body.instructions = f1D7A_parent_instructions;
               body.emit(f1D7A);

               /* END IF */

               body.emit(assign(r1CB2, r1D77, 0x01));

               body.emit(assign(r1CB3, r1D76, 0x01));

               body.emit(assign(r1CB0, bit_or(r1CB0, body.constant(1073741824u)), 0x01));

               ir_variable *const r1D96 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r1D97 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r1D97, sub(r1CB1, r1D76), 0x01));

               ir_expression *const r1D98 = sub(r1CB0, r1D77);
               ir_expression *const r1D99 = less(r1CB1, r1D76);
               ir_expression *const r1D9A = expr(ir_unop_b2i, r1D99);
               ir_expression *const r1D9B = expr(ir_unop_i2u, r1D9A);
               body.emit(assign(r1D96, sub(r1D98, r1D9B), 0x01));

               body.emit(assign(r1CAB, bit_xor(r1CA8, body.constant(1u)), 0x01));

               body.emit(assign(r1CB4, body.constant(int(1022)), 0x01));

               ir_variable *const r1D9C = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r1D9C, body.constant(int(1012)), 0x01));

               ir_variable *const r1D9D = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r1D9D, r1D96, 0x01));

               ir_variable *const r1D9E = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r1D9E, r1D97, 0x01));

               ir_variable *const r1D9F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r1D9F);
               ir_variable *const r1DA0 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1DA0);
               /* IF CONDITION */
               ir_expression *const r1DA2 = equal(r1D96, body.constant(0u));
               ir_if *f1DA1 = new(mem_ctx) ir_if(operand(r1DA2).val);
               exec_list *const f1DA1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1DA1->then_instructions;

                  body.emit(assign(r1D9D, r1D97, 0x01));

                  body.emit(assign(r1D9E, body.constant(0u), 0x01));

                  body.emit(assign(r1D9C, body.constant(int(980)), 0x01));


               body.instructions = f1DA1_parent_instructions;
               body.emit(f1DA1);

               /* END IF */

               ir_variable *const r1DA3 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r1DA3, r1D9D, 0x01));

               ir_variable *const r1DA4 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r1DA5 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1DA5);
               /* IF CONDITION */
               ir_expression *const r1DA7 = equal(r1D9D, body.constant(0u));
               ir_if *f1DA6 = new(mem_ctx) ir_if(operand(r1DA7).val);
               exec_list *const f1DA6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1DA6->then_instructions;

                  body.emit(assign(r1DA4, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1DA6->else_instructions;

                  body.emit(assign(r1DA5, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1DA9 = bit_and(r1D9D, body.constant(4294901760u));
                  ir_expression *const r1DAA = equal(r1DA9, body.constant(0u));
                  ir_if *f1DA8 = new(mem_ctx) ir_if(operand(r1DAA).val);
                  exec_list *const f1DA8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1DA8->then_instructions;

                     body.emit(assign(r1DA5, body.constant(int(16)), 0x01));

                     body.emit(assign(r1DA3, lshift(r1D9D, body.constant(int(16))), 0x01));


                  body.instructions = f1DA8_parent_instructions;
                  body.emit(f1DA8);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1DAC = bit_and(r1DA3, body.constant(4278190080u));
                  ir_expression *const r1DAD = equal(r1DAC, body.constant(0u));
                  ir_if *f1DAB = new(mem_ctx) ir_if(operand(r1DAD).val);
                  exec_list *const f1DAB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1DAB->then_instructions;

                     body.emit(assign(r1DA5, add(r1DA5, body.constant(int(8))), 0x01));

                     body.emit(assign(r1DA3, lshift(r1DA3, body.constant(int(8))), 0x01));


                  body.instructions = f1DAB_parent_instructions;
                  body.emit(f1DAB);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1DAF = bit_and(r1DA3, body.constant(4026531840u));
                  ir_expression *const r1DB0 = equal(r1DAF, body.constant(0u));
                  ir_if *f1DAE = new(mem_ctx) ir_if(operand(r1DB0).val);
                  exec_list *const f1DAE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1DAE->then_instructions;

                     body.emit(assign(r1DA5, add(r1DA5, body.constant(int(4))), 0x01));

                     body.emit(assign(r1DA3, lshift(r1DA3, body.constant(int(4))), 0x01));


                  body.instructions = f1DAE_parent_instructions;
                  body.emit(f1DAE);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1DB2 = bit_and(r1DA3, body.constant(3221225472u));
                  ir_expression *const r1DB3 = equal(r1DB2, body.constant(0u));
                  ir_if *f1DB1 = new(mem_ctx) ir_if(operand(r1DB3).val);
                  exec_list *const f1DB1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1DB1->then_instructions;

                     body.emit(assign(r1DA5, add(r1DA5, body.constant(int(2))), 0x01));

                     body.emit(assign(r1DA3, lshift(r1DA3, body.constant(int(2))), 0x01));


                  body.instructions = f1DB1_parent_instructions;
                  body.emit(f1DB1);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1DB5 = bit_and(r1DA3, body.constant(2147483648u));
                  ir_expression *const r1DB6 = equal(r1DB5, body.constant(0u));
                  ir_if *f1DB4 = new(mem_ctx) ir_if(operand(r1DB6).val);
                  exec_list *const f1DB4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1DB4->then_instructions;

                     body.emit(assign(r1DA5, add(r1DA5, body.constant(int(1))), 0x01));


                  body.instructions = f1DB4_parent_instructions;
                  body.emit(f1DB4);

                  /* END IF */

                  body.emit(assign(r1DA4, r1DA5, 0x01));


               body.instructions = f1DA6_parent_instructions;
               body.emit(f1DA6);

               /* END IF */

               body.emit(assign(r1DA0, add(r1DA4, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1DB8 = lequal(body.constant(int(0)), r1DA0);
               ir_if *f1DB7 = new(mem_ctx) ir_if(operand(r1DB8).val);
               exec_list *const f1DB7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1DB7->then_instructions;

                  body.emit(assign(r1D9F, body.constant(0u), 0x01));

                  ir_variable *const r1DB9 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r1DB9, lshift(r1D9E, r1DA0), 0x01));

                  ir_variable *const r1DBA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1DBC = equal(r1DA0, body.constant(int(0)));
                  ir_if *f1DBB = new(mem_ctx) ir_if(operand(r1DBC).val);
                  exec_list *const f1DBB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1DBB->then_instructions;

                     body.emit(assign(r1DBA, r1D9D, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1DBB->else_instructions;

                     ir_expression *const r1DBD = lshift(r1D9D, r1DA0);
                     ir_expression *const r1DBE = neg(r1DA0);
                     ir_expression *const r1DBF = bit_and(r1DBE, body.constant(int(31)));
                     ir_expression *const r1DC0 = rshift(r1D9E, r1DBF);
                     body.emit(assign(r1DBA, bit_or(r1DBD, r1DC0), 0x01));


                  body.instructions = f1DBB_parent_instructions;
                  body.emit(f1DBB);

                  /* END IF */

                  body.emit(assign(r1D9D, r1DBA, 0x01));

                  body.emit(assign(r1D9E, r1DB9, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1DB7->else_instructions;

                  ir_variable *const r1DC1 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r1DC1, body.constant(0u), 0x01));

                  ir_variable *const r1DC2 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r1DC2, neg(r1DA0), 0x01));

                  ir_variable *const r1DC3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r1DC3);
                  ir_variable *const r1DC4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1DC4);
                  ir_variable *const r1DC5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1DC5);
                  ir_variable *const r1DC6 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r1DC7 = neg(r1DC2);
                  body.emit(assign(r1DC6, bit_and(r1DC7, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1DC9 = equal(r1DC2, body.constant(int(0)));
                  ir_if *f1DC8 = new(mem_ctx) ir_if(operand(r1DC9).val);
                  exec_list *const f1DC8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1DC8->then_instructions;

                     body.emit(assign(r1DC3, r1DC1, 0x01));

                     body.emit(assign(r1DC4, r1D9E, 0x01));

                     body.emit(assign(r1DC5, r1D9D, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1DC8->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1DCB = less(r1DC2, body.constant(int(32)));
                     ir_if *f1DCA = new(mem_ctx) ir_if(operand(r1DCB).val);
                     exec_list *const f1DCA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1DCA->then_instructions;

                        body.emit(assign(r1DC3, lshift(r1D9E, r1DC6), 0x01));

                        ir_expression *const r1DCC = lshift(r1D9D, r1DC6);
                        ir_expression *const r1DCD = rshift(r1D9E, r1DC2);
                        body.emit(assign(r1DC4, bit_or(r1DCC, r1DCD), 0x01));

                        body.emit(assign(r1DC5, rshift(r1D9D, r1DC2), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1DCA->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1DCF = equal(r1DC2, body.constant(int(32)));
                        ir_if *f1DCE = new(mem_ctx) ir_if(operand(r1DCF).val);
                        exec_list *const f1DCE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1DCE->then_instructions;

                           body.emit(assign(r1DC3, r1D9E, 0x01));

                           body.emit(assign(r1DC4, r1D9D, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1DCE->else_instructions;

                           body.emit(assign(r1DC1, bit_or(body.constant(0u), r1D9E), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1DD1 = less(r1DC2, body.constant(int(64)));
                           ir_if *f1DD0 = new(mem_ctx) ir_if(operand(r1DD1).val);
                           exec_list *const f1DD0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1DD0->then_instructions;

                              body.emit(assign(r1DC3, lshift(r1D9D, r1DC6), 0x01));

                              ir_expression *const r1DD2 = bit_and(r1DC2, body.constant(int(31)));
                              body.emit(assign(r1DC4, rshift(r1D9D, r1DD2), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1DD0->else_instructions;

                              ir_variable *const r1DD3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1DD5 = equal(r1DC2, body.constant(int(64)));
                              ir_if *f1DD4 = new(mem_ctx) ir_if(operand(r1DD5).val);
                              exec_list *const f1DD4_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1DD4->then_instructions;

                                 body.emit(assign(r1DD3, r1D9D, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1DD4->else_instructions;

                                 ir_expression *const r1DD6 = nequal(r1D9D, body.constant(0u));
                                 ir_expression *const r1DD7 = expr(ir_unop_b2i, r1DD6);
                                 body.emit(assign(r1DD3, expr(ir_unop_i2u, r1DD7), 0x01));


                              body.instructions = f1DD4_parent_instructions;
                              body.emit(f1DD4);

                              /* END IF */

                              body.emit(assign(r1DC3, r1DD3, 0x01));

                              body.emit(assign(r1DC4, body.constant(0u), 0x01));


                           body.instructions = f1DD0_parent_instructions;
                           body.emit(f1DD0);

                           /* END IF */


                        body.instructions = f1DCE_parent_instructions;
                        body.emit(f1DCE);

                        /* END IF */

                        body.emit(assign(r1DC5, body.constant(0u), 0x01));


                     body.instructions = f1DCA_parent_instructions;
                     body.emit(f1DCA);

                     /* END IF */

                     ir_expression *const r1DD8 = nequal(r1DC1, body.constant(0u));
                     ir_expression *const r1DD9 = expr(ir_unop_b2i, r1DD8);
                     ir_expression *const r1DDA = expr(ir_unop_i2u, r1DD9);
                     body.emit(assign(r1DC3, bit_or(r1DC3, r1DDA), 0x01));


                  body.instructions = f1DC8_parent_instructions;
                  body.emit(f1DC8);

                  /* END IF */

                  body.emit(assign(r1D9D, r1DC5, 0x01));

                  body.emit(assign(r1D9E, r1DC4, 0x01));

                  body.emit(assign(r1D9F, r1DC3, 0x01));


               body.instructions = f1DB7_parent_instructions;
               body.emit(f1DB7);

               /* END IF */

               body.emit(assign(r1D9C, sub(r1D9C, r1DA0), 0x01));

               ir_variable *const r1DDB = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r1DDB, r1D9C, 0x01));

               ir_variable *const r1DDC = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r1DDC, r1D9D, 0x01));

               ir_variable *const r1DDD = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r1DDD, r1D9E, 0x01));

               ir_variable *const r1DDE = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r1DDE, r1D9F, 0x01));

               ir_variable *const r1DDF = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r1DDF, body.constant(true), 0x01));

               ir_variable *const r1DE0 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r1DE1 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r1DE1);
               ir_expression *const r1DE2 = expr(ir_unop_u2i, r1D9F);
               body.emit(assign(r1DE1, less(r1DE2, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1DE4 = lequal(body.constant(int(2045)), r1D9C);
               ir_if *f1DE3 = new(mem_ctx) ir_if(operand(r1DE4).val);
               exec_list *const f1DE3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1DE3->then_instructions;

                  ir_variable *const r1DE5 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1DE7 = less(body.constant(int(2045)), r1D9C);
                  ir_if *f1DE6 = new(mem_ctx) ir_if(operand(r1DE7).val);
                  exec_list *const f1DE6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1DE6->then_instructions;

                     body.emit(assign(r1DE5, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1DE6->else_instructions;

                     ir_variable *const r1DE8 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1DEA = equal(r1D9C, body.constant(int(2045)));
                     ir_if *f1DE9 = new(mem_ctx) ir_if(operand(r1DEA).val);
                     exec_list *const f1DE9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1DE9->then_instructions;

                        ir_expression *const r1DEB = equal(body.constant(2097151u), r1D9D);
                        ir_expression *const r1DEC = equal(body.constant(4294967295u), r1D9E);
                        body.emit(assign(r1DE8, logic_and(r1DEB, r1DEC), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1DE9->else_instructions;

                        body.emit(assign(r1DE8, body.constant(false), 0x01));


                     body.instructions = f1DE9_parent_instructions;
                     body.emit(f1DE9);

                     /* END IF */

                     body.emit(assign(r1DE5, logic_and(r1DE8, r1DE1), 0x01));


                  body.instructions = f1DE6_parent_instructions;
                  body.emit(f1DE6);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f1DED = new(mem_ctx) ir_if(operand(r1DE5).val);
                  exec_list *const f1DED_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1DED->then_instructions;

                     ir_variable *const r1DEE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r1DEE);
                     ir_expression *const r1DEF = lshift(r1CAB, body.constant(int(31)));
                     body.emit(assign(r1DEE, add(r1DEF, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r1DEE, body.constant(0u), 0x01));

                     body.emit(assign(r1DE0, r1DEE, 0x03));

                     body.emit(assign(r1DDF, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1DED->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1DF1 = less(r1D9C, body.constant(int(0)));
                     ir_if *f1DF0 = new(mem_ctx) ir_if(operand(r1DF1).val);
                     exec_list *const f1DF0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1DF0->then_instructions;

                        ir_variable *const r1DF2 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r1DF2, r1D9F, 0x01));

                        ir_variable *const r1DF3 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r1DF3, neg(r1D9C), 0x01));

                        ir_variable *const r1DF4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r1DF4);
                        ir_variable *const r1DF5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r1DF5);
                        ir_variable *const r1DF6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r1DF6);
                        ir_variable *const r1DF7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r1DF8 = neg(r1DF3);
                        body.emit(assign(r1DF7, bit_and(r1DF8, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1DFA = equal(r1DF3, body.constant(int(0)));
                        ir_if *f1DF9 = new(mem_ctx) ir_if(operand(r1DFA).val);
                        exec_list *const f1DF9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1DF9->then_instructions;

                           body.emit(assign(r1DF4, r1D9F, 0x01));

                           body.emit(assign(r1DF5, r1D9E, 0x01));

                           body.emit(assign(r1DF6, r1D9D, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1DF9->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1DFC = less(r1DF3, body.constant(int(32)));
                           ir_if *f1DFB = new(mem_ctx) ir_if(operand(r1DFC).val);
                           exec_list *const f1DFB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1DFB->then_instructions;

                              body.emit(assign(r1DF4, lshift(r1D9E, r1DF7), 0x01));

                              ir_expression *const r1DFD = lshift(r1D9D, r1DF7);
                              ir_expression *const r1DFE = rshift(r1D9E, r1DF3);
                              body.emit(assign(r1DF5, bit_or(r1DFD, r1DFE), 0x01));

                              body.emit(assign(r1DF6, rshift(r1D9D, r1DF3), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1DFB->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1E00 = equal(r1DF3, body.constant(int(32)));
                              ir_if *f1DFF = new(mem_ctx) ir_if(operand(r1E00).val);
                              exec_list *const f1DFF_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1DFF->then_instructions;

                                 body.emit(assign(r1DF4, r1D9E, 0x01));

                                 body.emit(assign(r1DF5, r1D9D, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1DFF->else_instructions;

                                 body.emit(assign(r1DF2, bit_or(r1D9F, r1D9E), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1E02 = less(r1DF3, body.constant(int(64)));
                                 ir_if *f1E01 = new(mem_ctx) ir_if(operand(r1E02).val);
                                 exec_list *const f1E01_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1E01->then_instructions;

                                    body.emit(assign(r1DF4, lshift(r1D9D, r1DF7), 0x01));

                                    ir_expression *const r1E03 = bit_and(r1DF3, body.constant(int(31)));
                                    body.emit(assign(r1DF5, rshift(r1D9D, r1E03), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1E01->else_instructions;

                                    ir_variable *const r1E04 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r1E06 = equal(r1DF3, body.constant(int(64)));
                                    ir_if *f1E05 = new(mem_ctx) ir_if(operand(r1E06).val);
                                    exec_list *const f1E05_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1E05->then_instructions;

                                       body.emit(assign(r1E04, r1D9D, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1E05->else_instructions;

                                       ir_expression *const r1E07 = nequal(r1D9D, body.constant(0u));
                                       ir_expression *const r1E08 = expr(ir_unop_b2i, r1E07);
                                       body.emit(assign(r1E04, expr(ir_unop_i2u, r1E08), 0x01));


                                    body.instructions = f1E05_parent_instructions;
                                    body.emit(f1E05);

                                    /* END IF */

                                    body.emit(assign(r1DF4, r1E04, 0x01));

                                    body.emit(assign(r1DF5, body.constant(0u), 0x01));


                                 body.instructions = f1E01_parent_instructions;
                                 body.emit(f1E01);

                                 /* END IF */


                              body.instructions = f1DFF_parent_instructions;
                              body.emit(f1DFF);

                              /* END IF */

                              body.emit(assign(r1DF6, body.constant(0u), 0x01));


                           body.instructions = f1DFB_parent_instructions;
                           body.emit(f1DFB);

                           /* END IF */

                           ir_expression *const r1E09 = nequal(r1DF2, body.constant(0u));
                           ir_expression *const r1E0A = expr(ir_unop_b2i, r1E09);
                           ir_expression *const r1E0B = expr(ir_unop_i2u, r1E0A);
                           body.emit(assign(r1DF4, bit_or(r1DF4, r1E0B), 0x01));


                        body.instructions = f1DF9_parent_instructions;
                        body.emit(f1DF9);

                        /* END IF */

                        body.emit(assign(r1DDC, r1DF6, 0x01));

                        body.emit(assign(r1DDD, r1DF5, 0x01));

                        body.emit(assign(r1DDE, r1DF4, 0x01));

                        body.emit(assign(r1DDB, body.constant(int(0)), 0x01));

                        body.emit(assign(r1DE1, less(r1DF4, body.constant(0u)), 0x01));


                     body.instructions = f1DF0_parent_instructions;
                     body.emit(f1DF0);

                     /* END IF */


                  body.instructions = f1DED_parent_instructions;
                  body.emit(f1DED);

                  /* END IF */


               body.instructions = f1DE3_parent_instructions;
               body.emit(f1DE3);

               /* END IF */

               /* IF CONDITION */
               ir_if *f1E0C = new(mem_ctx) ir_if(operand(r1DDF).val);
               exec_list *const f1E0C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1E0C->then_instructions;

                  /* IF CONDITION */
                  ir_if *f1E0D = new(mem_ctx) ir_if(operand(r1DE1).val);
                  exec_list *const f1E0D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1E0D->then_instructions;

                     ir_variable *const r1E0E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r1E0E, add(r1DDD, body.constant(1u)), 0x01));

                     ir_expression *const r1E0F = less(r1E0E, r1DDD);
                     ir_expression *const r1E10 = expr(ir_unop_b2i, r1E0F);
                     ir_expression *const r1E11 = expr(ir_unop_i2u, r1E10);
                     body.emit(assign(r1DDC, add(r1DDC, r1E11), 0x01));

                     ir_expression *const r1E12 = equal(r1DDE, body.constant(0u));
                     ir_expression *const r1E13 = expr(ir_unop_b2i, r1E12);
                     ir_expression *const r1E14 = expr(ir_unop_i2u, r1E13);
                     ir_expression *const r1E15 = add(r1DDE, r1E14);
                     ir_expression *const r1E16 = bit_and(r1E15, body.constant(1u));
                     ir_expression *const r1E17 = expr(ir_unop_bit_not, r1E16);
                     body.emit(assign(r1DDD, bit_and(r1E0E, r1E17), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1E0D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1E19 = bit_or(r1DDC, r1DDD);
                     ir_expression *const r1E1A = equal(r1E19, body.constant(0u));
                     ir_if *f1E18 = new(mem_ctx) ir_if(operand(r1E1A).val);
                     exec_list *const f1E18_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1E18->then_instructions;

                        body.emit(assign(r1DDB, body.constant(int(0)), 0x01));


                     body.instructions = f1E18_parent_instructions;
                     body.emit(f1E18);

                     /* END IF */


                  body.instructions = f1E0D_parent_instructions;
                  body.emit(f1E0D);

                  /* END IF */

                  ir_variable *const r1E1B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1E1B);
                  ir_expression *const r1E1C = lshift(r1CAB, body.constant(int(31)));
                  ir_expression *const r1E1D = expr(ir_unop_i2u, r1DDB);
                  ir_expression *const r1E1E = lshift(r1E1D, body.constant(int(20)));
                  ir_expression *const r1E1F = add(r1E1C, r1E1E);
                  body.emit(assign(r1E1B, add(r1E1F, r1DDC), 0x02));

                  body.emit(assign(r1E1B, r1DDD, 0x01));

                  body.emit(assign(r1DE0, r1E1B, 0x03));

                  body.emit(assign(r1DDF, body.constant(false), 0x01));


               body.instructions = f1E0C_parent_instructions;
               body.emit(f1E0C);

               /* END IF */

               body.emit(assign(r1CAC, r1DE0, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1D71->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1E21 = equal(r1CB6, body.constant(int(2047)));
               ir_if *f1E20 = new(mem_ctx) ir_if(operand(r1E21).val);
               exec_list *const f1E20_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1E20->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1E23 = bit_or(r1CB2, r1CB3);
                  ir_expression *const r1E24 = bit_or(r1CB0, r1CB1);
                  ir_expression *const r1E25 = bit_or(r1E23, r1E24);
                  ir_expression *const r1E26 = nequal(r1E25, body.constant(0u));
                  ir_if *f1E22 = new(mem_ctx) ir_if(operand(r1E26).val);
                  exec_list *const f1E22_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1E22->then_instructions;

                     ir_variable *const r1E27 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r1E27, swizzle_x(r1C72), 0x01));

                     ir_variable *const r1E28 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r1E28, body.constant(0u), 0x01));

                     ir_variable *const r1E29 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r1E27, bit_or(swizzle_y(r1C72), body.constant(524288u)), 0x02));

                     body.emit(assign(r1E28, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r1E2B = lshift(swizzle_y(r1C72), body.constant(int(1)));
                     ir_expression *const r1E2C = lequal(body.constant(4292870144u), r1E2B);
                     ir_expression *const r1E2D = nequal(swizzle_x(r1C72), body.constant(0u));
                     ir_expression *const r1E2E = bit_and(swizzle_y(r1C72), body.constant(1048575u));
                     ir_expression *const r1E2F = nequal(r1E2E, body.constant(0u));
                     ir_expression *const r1E30 = logic_or(r1E2D, r1E2F);
                     ir_expression *const r1E31 = logic_and(r1E2C, r1E30);
                     ir_if *f1E2A = new(mem_ctx) ir_if(operand(r1E31).val);
                     exec_list *const f1E2A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1E2A->then_instructions;

                        body.emit(assign(r1E29, r1E27, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1E2A->else_instructions;

                        body.emit(assign(r1E29, r1E28, 0x03));


                     body.instructions = f1E2A_parent_instructions;
                     body.emit(f1E2A);

                     /* END IF */

                     body.emit(assign(r1CAC, r1E29, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1E22->else_instructions;

                     ir_constant_data r1E32_data;
                     memset(&r1E32_data, 0, sizeof(ir_constant_data));
                     r1E32_data.u[0] = 4294967295;
                     r1E32_data.u[1] = 4294967295;
                     ir_constant *const r1E32 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r1E32_data);
                     body.emit(assign(r1CAC, r1E32, 0x03));


                  body.instructions = f1E22_parent_instructions;
                  body.emit(f1E22);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1E20->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1E34 = equal(r1CB6, body.constant(int(0)));
                  ir_if *f1E33 = new(mem_ctx) ir_if(operand(r1E34).val);
                  exec_list *const f1E33_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1E33->then_instructions;

                     body.emit(assign(r1CAF, body.constant(int(1)), 0x01));

                     body.emit(assign(r1CAE, body.constant(int(1)), 0x01));


                  body.instructions = f1E33_parent_instructions;
                  body.emit(f1E33);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1E36 = less(r1CB0, r1CB2);
                  ir_if *f1E35 = new(mem_ctx) ir_if(operand(r1E36).val);
                  exec_list *const f1E35_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1E35->then_instructions;

                     ir_variable *const r1E37 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r1E38 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r1E38, sub(r1CB3, r1CB1), 0x01));

                     ir_expression *const r1E39 = sub(r1CB2, r1CB0);
                     ir_expression *const r1E3A = less(r1CB3, r1CB1);
                     ir_expression *const r1E3B = expr(ir_unop_b2i, r1E3A);
                     ir_expression *const r1E3C = expr(ir_unop_i2u, r1E3B);
                     body.emit(assign(r1E37, sub(r1E39, r1E3C), 0x01));

                     body.emit(assign(r1CB4, add(r1CAF, body.constant(int(-1))), 0x01));

                     ir_variable *const r1E3D = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r1E3D, add(r1CB4, body.constant(int(-10))), 0x01));

                     ir_variable *const r1E3E = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r1E3E, r1E37, 0x01));

                     ir_variable *const r1E3F = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r1E3F, r1E38, 0x01));

                     ir_variable *const r1E40 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r1E40);
                     ir_variable *const r1E41 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r1E41);
                     /* IF CONDITION */
                     ir_expression *const r1E43 = equal(r1E37, body.constant(0u));
                     ir_if *f1E42 = new(mem_ctx) ir_if(operand(r1E43).val);
                     exec_list *const f1E42_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1E42->then_instructions;

                        body.emit(assign(r1E3E, r1E38, 0x01));

                        body.emit(assign(r1E3F, body.constant(0u), 0x01));

                        body.emit(assign(r1E3D, add(r1E3D, body.constant(int(-32))), 0x01));


                     body.instructions = f1E42_parent_instructions;
                     body.emit(f1E42);

                     /* END IF */

                     ir_variable *const r1E44 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r1E44, r1E3E, 0x01));

                     ir_variable *const r1E45 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r1E46 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r1E46);
                     /* IF CONDITION */
                     ir_expression *const r1E48 = equal(r1E3E, body.constant(0u));
                     ir_if *f1E47 = new(mem_ctx) ir_if(operand(r1E48).val);
                     exec_list *const f1E47_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1E47->then_instructions;

                        body.emit(assign(r1E45, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1E47->else_instructions;

                        body.emit(assign(r1E46, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1E4A = bit_and(r1E3E, body.constant(4294901760u));
                        ir_expression *const r1E4B = equal(r1E4A, body.constant(0u));
                        ir_if *f1E49 = new(mem_ctx) ir_if(operand(r1E4B).val);
                        exec_list *const f1E49_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1E49->then_instructions;

                           body.emit(assign(r1E46, body.constant(int(16)), 0x01));

                           body.emit(assign(r1E44, lshift(r1E3E, body.constant(int(16))), 0x01));


                        body.instructions = f1E49_parent_instructions;
                        body.emit(f1E49);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1E4D = bit_and(r1E44, body.constant(4278190080u));
                        ir_expression *const r1E4E = equal(r1E4D, body.constant(0u));
                        ir_if *f1E4C = new(mem_ctx) ir_if(operand(r1E4E).val);
                        exec_list *const f1E4C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1E4C->then_instructions;

                           body.emit(assign(r1E46, add(r1E46, body.constant(int(8))), 0x01));

                           body.emit(assign(r1E44, lshift(r1E44, body.constant(int(8))), 0x01));


                        body.instructions = f1E4C_parent_instructions;
                        body.emit(f1E4C);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1E50 = bit_and(r1E44, body.constant(4026531840u));
                        ir_expression *const r1E51 = equal(r1E50, body.constant(0u));
                        ir_if *f1E4F = new(mem_ctx) ir_if(operand(r1E51).val);
                        exec_list *const f1E4F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1E4F->then_instructions;

                           body.emit(assign(r1E46, add(r1E46, body.constant(int(4))), 0x01));

                           body.emit(assign(r1E44, lshift(r1E44, body.constant(int(4))), 0x01));


                        body.instructions = f1E4F_parent_instructions;
                        body.emit(f1E4F);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1E53 = bit_and(r1E44, body.constant(3221225472u));
                        ir_expression *const r1E54 = equal(r1E53, body.constant(0u));
                        ir_if *f1E52 = new(mem_ctx) ir_if(operand(r1E54).val);
                        exec_list *const f1E52_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1E52->then_instructions;

                           body.emit(assign(r1E46, add(r1E46, body.constant(int(2))), 0x01));

                           body.emit(assign(r1E44, lshift(r1E44, body.constant(int(2))), 0x01));


                        body.instructions = f1E52_parent_instructions;
                        body.emit(f1E52);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1E56 = bit_and(r1E44, body.constant(2147483648u));
                        ir_expression *const r1E57 = equal(r1E56, body.constant(0u));
                        ir_if *f1E55 = new(mem_ctx) ir_if(operand(r1E57).val);
                        exec_list *const f1E55_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1E55->then_instructions;

                           body.emit(assign(r1E46, add(r1E46, body.constant(int(1))), 0x01));


                        body.instructions = f1E55_parent_instructions;
                        body.emit(f1E55);

                        /* END IF */

                        body.emit(assign(r1E45, r1E46, 0x01));


                     body.instructions = f1E47_parent_instructions;
                     body.emit(f1E47);

                     /* END IF */

                     body.emit(assign(r1E41, add(r1E45, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1E59 = lequal(body.constant(int(0)), r1E41);
                     ir_if *f1E58 = new(mem_ctx) ir_if(operand(r1E59).val);
                     exec_list *const f1E58_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1E58->then_instructions;

                        body.emit(assign(r1E40, body.constant(0u), 0x01));

                        ir_variable *const r1E5A = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r1E5A, lshift(r1E3F, r1E41), 0x01));

                        ir_variable *const r1E5B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r1E5D = equal(r1E41, body.constant(int(0)));
                        ir_if *f1E5C = new(mem_ctx) ir_if(operand(r1E5D).val);
                        exec_list *const f1E5C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1E5C->then_instructions;

                           body.emit(assign(r1E5B, r1E3E, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1E5C->else_instructions;

                           ir_expression *const r1E5E = lshift(r1E3E, r1E41);
                           ir_expression *const r1E5F = neg(r1E41);
                           ir_expression *const r1E60 = bit_and(r1E5F, body.constant(int(31)));
                           ir_expression *const r1E61 = rshift(r1E3F, r1E60);
                           body.emit(assign(r1E5B, bit_or(r1E5E, r1E61), 0x01));


                        body.instructions = f1E5C_parent_instructions;
                        body.emit(f1E5C);

                        /* END IF */

                        body.emit(assign(r1E3E, r1E5B, 0x01));

                        body.emit(assign(r1E3F, r1E5A, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1E58->else_instructions;

                        ir_variable *const r1E62 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r1E62, body.constant(0u), 0x01));

                        ir_variable *const r1E63 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r1E63, neg(r1E41), 0x01));

                        ir_variable *const r1E64 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r1E64);
                        ir_variable *const r1E65 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r1E65);
                        ir_variable *const r1E66 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r1E66);
                        ir_variable *const r1E67 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r1E68 = neg(r1E63);
                        body.emit(assign(r1E67, bit_and(r1E68, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1E6A = equal(r1E63, body.constant(int(0)));
                        ir_if *f1E69 = new(mem_ctx) ir_if(operand(r1E6A).val);
                        exec_list *const f1E69_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1E69->then_instructions;

                           body.emit(assign(r1E64, r1E62, 0x01));

                           body.emit(assign(r1E65, r1E3F, 0x01));

                           body.emit(assign(r1E66, r1E3E, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1E69->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1E6C = less(r1E63, body.constant(int(32)));
                           ir_if *f1E6B = new(mem_ctx) ir_if(operand(r1E6C).val);
                           exec_list *const f1E6B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1E6B->then_instructions;

                              body.emit(assign(r1E64, lshift(r1E3F, r1E67), 0x01));

                              ir_expression *const r1E6D = lshift(r1E3E, r1E67);
                              ir_expression *const r1E6E = rshift(r1E3F, r1E63);
                              body.emit(assign(r1E65, bit_or(r1E6D, r1E6E), 0x01));

                              body.emit(assign(r1E66, rshift(r1E3E, r1E63), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1E6B->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1E70 = equal(r1E63, body.constant(int(32)));
                              ir_if *f1E6F = new(mem_ctx) ir_if(operand(r1E70).val);
                              exec_list *const f1E6F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1E6F->then_instructions;

                                 body.emit(assign(r1E64, r1E3F, 0x01));

                                 body.emit(assign(r1E65, r1E3E, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1E6F->else_instructions;

                                 body.emit(assign(r1E62, bit_or(body.constant(0u), r1E3F), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1E72 = less(r1E63, body.constant(int(64)));
                                 ir_if *f1E71 = new(mem_ctx) ir_if(operand(r1E72).val);
                                 exec_list *const f1E71_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1E71->then_instructions;

                                    body.emit(assign(r1E64, lshift(r1E3E, r1E67), 0x01));

                                    ir_expression *const r1E73 = bit_and(r1E63, body.constant(int(31)));
                                    body.emit(assign(r1E65, rshift(r1E3E, r1E73), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1E71->else_instructions;

                                    ir_variable *const r1E74 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r1E76 = equal(r1E63, body.constant(int(64)));
                                    ir_if *f1E75 = new(mem_ctx) ir_if(operand(r1E76).val);
                                    exec_list *const f1E75_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1E75->then_instructions;

                                       body.emit(assign(r1E74, r1E3E, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1E75->else_instructions;

                                       ir_expression *const r1E77 = nequal(r1E3E, body.constant(0u));
                                       ir_expression *const r1E78 = expr(ir_unop_b2i, r1E77);
                                       body.emit(assign(r1E74, expr(ir_unop_i2u, r1E78), 0x01));


                                    body.instructions = f1E75_parent_instructions;
                                    body.emit(f1E75);

                                    /* END IF */

                                    body.emit(assign(r1E64, r1E74, 0x01));

                                    body.emit(assign(r1E65, body.constant(0u), 0x01));


                                 body.instructions = f1E71_parent_instructions;
                                 body.emit(f1E71);

                                 /* END IF */


                              body.instructions = f1E6F_parent_instructions;
                              body.emit(f1E6F);

                              /* END IF */

                              body.emit(assign(r1E66, body.constant(0u), 0x01));


                           body.instructions = f1E6B_parent_instructions;
                           body.emit(f1E6B);

                           /* END IF */

                           ir_expression *const r1E79 = nequal(r1E62, body.constant(0u));
                           ir_expression *const r1E7A = expr(ir_unop_b2i, r1E79);
                           ir_expression *const r1E7B = expr(ir_unop_i2u, r1E7A);
                           body.emit(assign(r1E64, bit_or(r1E64, r1E7B), 0x01));


                        body.instructions = f1E69_parent_instructions;
                        body.emit(f1E69);

                        /* END IF */

                        body.emit(assign(r1E3E, r1E66, 0x01));

                        body.emit(assign(r1E3F, r1E65, 0x01));

                        body.emit(assign(r1E40, r1E64, 0x01));


                     body.instructions = f1E58_parent_instructions;
                     body.emit(f1E58);

                     /* END IF */

                     body.emit(assign(r1E3D, sub(r1E3D, r1E41), 0x01));

                     ir_variable *const r1E7C = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r1E7C, r1E3D, 0x01));

                     ir_variable *const r1E7D = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r1E7D, r1E3E, 0x01));

                     ir_variable *const r1E7E = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r1E7E, r1E3F, 0x01));

                     ir_variable *const r1E7F = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r1E7F, r1E40, 0x01));

                     ir_variable *const r1E80 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r1E80, body.constant(true), 0x01));

                     ir_variable *const r1E81 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r1E82 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r1E82);
                     ir_expression *const r1E83 = expr(ir_unop_u2i, r1E40);
                     body.emit(assign(r1E82, less(r1E83, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1E85 = lequal(body.constant(int(2045)), r1E3D);
                     ir_if *f1E84 = new(mem_ctx) ir_if(operand(r1E85).val);
                     exec_list *const f1E84_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1E84->then_instructions;

                        ir_variable *const r1E86 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r1E88 = less(body.constant(int(2045)), r1E3D);
                        ir_if *f1E87 = new(mem_ctx) ir_if(operand(r1E88).val);
                        exec_list *const f1E87_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1E87->then_instructions;

                           body.emit(assign(r1E86, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1E87->else_instructions;

                           ir_variable *const r1E89 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r1E8B = equal(r1E3D, body.constant(int(2045)));
                           ir_if *f1E8A = new(mem_ctx) ir_if(operand(r1E8B).val);
                           exec_list *const f1E8A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1E8A->then_instructions;

                              ir_expression *const r1E8C = equal(body.constant(2097151u), r1E3E);
                              ir_expression *const r1E8D = equal(body.constant(4294967295u), r1E3F);
                              body.emit(assign(r1E89, logic_and(r1E8C, r1E8D), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1E8A->else_instructions;

                              body.emit(assign(r1E89, body.constant(false), 0x01));


                           body.instructions = f1E8A_parent_instructions;
                           body.emit(f1E8A);

                           /* END IF */

                           body.emit(assign(r1E86, logic_and(r1E89, r1E82), 0x01));


                        body.instructions = f1E87_parent_instructions;
                        body.emit(f1E87);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f1E8E = new(mem_ctx) ir_if(operand(r1E86).val);
                        exec_list *const f1E8E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1E8E->then_instructions;

                           ir_variable *const r1E8F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r1E8F);
                           ir_expression *const r1E90 = lshift(r1CAB, body.constant(int(31)));
                           body.emit(assign(r1E8F, add(r1E90, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r1E8F, body.constant(0u), 0x01));

                           body.emit(assign(r1E81, r1E8F, 0x03));

                           body.emit(assign(r1E80, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1E8E->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1E92 = less(r1E3D, body.constant(int(0)));
                           ir_if *f1E91 = new(mem_ctx) ir_if(operand(r1E92).val);
                           exec_list *const f1E91_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1E91->then_instructions;

                              ir_variable *const r1E93 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r1E93, r1E40, 0x01));

                              ir_variable *const r1E94 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r1E94, neg(r1E3D), 0x01));

                              ir_variable *const r1E95 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r1E95);
                              ir_variable *const r1E96 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r1E96);
                              ir_variable *const r1E97 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r1E97);
                              ir_variable *const r1E98 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r1E99 = neg(r1E94);
                              body.emit(assign(r1E98, bit_and(r1E99, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1E9B = equal(r1E94, body.constant(int(0)));
                              ir_if *f1E9A = new(mem_ctx) ir_if(operand(r1E9B).val);
                              exec_list *const f1E9A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1E9A->then_instructions;

                                 body.emit(assign(r1E95, r1E40, 0x01));

                                 body.emit(assign(r1E96, r1E3F, 0x01));

                                 body.emit(assign(r1E97, r1E3E, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1E9A->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1E9D = less(r1E94, body.constant(int(32)));
                                 ir_if *f1E9C = new(mem_ctx) ir_if(operand(r1E9D).val);
                                 exec_list *const f1E9C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1E9C->then_instructions;

                                    body.emit(assign(r1E95, lshift(r1E3F, r1E98), 0x01));

                                    ir_expression *const r1E9E = lshift(r1E3E, r1E98);
                                    ir_expression *const r1E9F = rshift(r1E3F, r1E94);
                                    body.emit(assign(r1E96, bit_or(r1E9E, r1E9F), 0x01));

                                    body.emit(assign(r1E97, rshift(r1E3E, r1E94), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1E9C->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r1EA1 = equal(r1E94, body.constant(int(32)));
                                    ir_if *f1EA0 = new(mem_ctx) ir_if(operand(r1EA1).val);
                                    exec_list *const f1EA0_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1EA0->then_instructions;

                                       body.emit(assign(r1E95, r1E3F, 0x01));

                                       body.emit(assign(r1E96, r1E3E, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1EA0->else_instructions;

                                       body.emit(assign(r1E93, bit_or(r1E40, r1E3F), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r1EA3 = less(r1E94, body.constant(int(64)));
                                       ir_if *f1EA2 = new(mem_ctx) ir_if(operand(r1EA3).val);
                                       exec_list *const f1EA2_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1EA2->then_instructions;

                                          body.emit(assign(r1E95, lshift(r1E3E, r1E98), 0x01));

                                          ir_expression *const r1EA4 = bit_and(r1E94, body.constant(int(31)));
                                          body.emit(assign(r1E96, rshift(r1E3E, r1EA4), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1EA2->else_instructions;

                                          ir_variable *const r1EA5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r1EA7 = equal(r1E94, body.constant(int(64)));
                                          ir_if *f1EA6 = new(mem_ctx) ir_if(operand(r1EA7).val);
                                          exec_list *const f1EA6_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1EA6->then_instructions;

                                             body.emit(assign(r1EA5, r1E3E, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1EA6->else_instructions;

                                             ir_expression *const r1EA8 = nequal(r1E3E, body.constant(0u));
                                             ir_expression *const r1EA9 = expr(ir_unop_b2i, r1EA8);
                                             body.emit(assign(r1EA5, expr(ir_unop_i2u, r1EA9), 0x01));


                                          body.instructions = f1EA6_parent_instructions;
                                          body.emit(f1EA6);

                                          /* END IF */

                                          body.emit(assign(r1E95, r1EA5, 0x01));

                                          body.emit(assign(r1E96, body.constant(0u), 0x01));


                                       body.instructions = f1EA2_parent_instructions;
                                       body.emit(f1EA2);

                                       /* END IF */


                                    body.instructions = f1EA0_parent_instructions;
                                    body.emit(f1EA0);

                                    /* END IF */

                                    body.emit(assign(r1E97, body.constant(0u), 0x01));


                                 body.instructions = f1E9C_parent_instructions;
                                 body.emit(f1E9C);

                                 /* END IF */

                                 ir_expression *const r1EAA = nequal(r1E93, body.constant(0u));
                                 ir_expression *const r1EAB = expr(ir_unop_b2i, r1EAA);
                                 ir_expression *const r1EAC = expr(ir_unop_i2u, r1EAB);
                                 body.emit(assign(r1E95, bit_or(r1E95, r1EAC), 0x01));


                              body.instructions = f1E9A_parent_instructions;
                              body.emit(f1E9A);

                              /* END IF */

                              body.emit(assign(r1E7D, r1E97, 0x01));

                              body.emit(assign(r1E7E, r1E96, 0x01));

                              body.emit(assign(r1E7F, r1E95, 0x01));

                              body.emit(assign(r1E7C, body.constant(int(0)), 0x01));

                              body.emit(assign(r1E82, less(r1E95, body.constant(0u)), 0x01));


                           body.instructions = f1E91_parent_instructions;
                           body.emit(f1E91);

                           /* END IF */


                        body.instructions = f1E8E_parent_instructions;
                        body.emit(f1E8E);

                        /* END IF */


                     body.instructions = f1E84_parent_instructions;
                     body.emit(f1E84);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f1EAD = new(mem_ctx) ir_if(operand(r1E80).val);
                     exec_list *const f1EAD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1EAD->then_instructions;

                        /* IF CONDITION */
                        ir_if *f1EAE = new(mem_ctx) ir_if(operand(r1E82).val);
                        exec_list *const f1EAE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1EAE->then_instructions;

                           ir_variable *const r1EAF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r1EAF, add(r1E7E, body.constant(1u)), 0x01));

                           ir_expression *const r1EB0 = less(r1EAF, r1E7E);
                           ir_expression *const r1EB1 = expr(ir_unop_b2i, r1EB0);
                           ir_expression *const r1EB2 = expr(ir_unop_i2u, r1EB1);
                           body.emit(assign(r1E7D, add(r1E7D, r1EB2), 0x01));

                           ir_expression *const r1EB3 = equal(r1E7F, body.constant(0u));
                           ir_expression *const r1EB4 = expr(ir_unop_b2i, r1EB3);
                           ir_expression *const r1EB5 = expr(ir_unop_i2u, r1EB4);
                           ir_expression *const r1EB6 = add(r1E7F, r1EB5);
                           ir_expression *const r1EB7 = bit_and(r1EB6, body.constant(1u));
                           ir_expression *const r1EB8 = expr(ir_unop_bit_not, r1EB7);
                           body.emit(assign(r1E7E, bit_and(r1EAF, r1EB8), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1EAE->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1EBA = bit_or(r1E7D, r1E7E);
                           ir_expression *const r1EBB = equal(r1EBA, body.constant(0u));
                           ir_if *f1EB9 = new(mem_ctx) ir_if(operand(r1EBB).val);
                           exec_list *const f1EB9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1EB9->then_instructions;

                              body.emit(assign(r1E7C, body.constant(int(0)), 0x01));


                           body.instructions = f1EB9_parent_instructions;
                           body.emit(f1EB9);

                           /* END IF */


                        body.instructions = f1EAE_parent_instructions;
                        body.emit(f1EAE);

                        /* END IF */

                        ir_variable *const r1EBC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r1EBC);
                        ir_expression *const r1EBD = lshift(r1CAB, body.constant(int(31)));
                        ir_expression *const r1EBE = expr(ir_unop_i2u, r1E7C);
                        ir_expression *const r1EBF = lshift(r1EBE, body.constant(int(20)));
                        ir_expression *const r1EC0 = add(r1EBD, r1EBF);
                        body.emit(assign(r1EBC, add(r1EC0, r1E7D), 0x02));

                        body.emit(assign(r1EBC, r1E7E, 0x01));

                        body.emit(assign(r1E81, r1EBC, 0x03));

                        body.emit(assign(r1E80, body.constant(false), 0x01));


                     body.instructions = f1EAD_parent_instructions;
                     body.emit(f1EAD);

                     /* END IF */

                     body.emit(assign(r1CAC, r1E81, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1E35->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1EC2 = less(r1CB2, r1CB0);
                     ir_if *f1EC1 = new(mem_ctx) ir_if(operand(r1EC2).val);
                     exec_list *const f1EC1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1EC1->then_instructions;

                        ir_variable *const r1EC3 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r1EC4 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r1EC4, sub(r1CB1, r1CB3), 0x01));

                        ir_expression *const r1EC5 = sub(r1CB0, r1CB2);
                        ir_expression *const r1EC6 = less(r1CB1, r1CB3);
                        ir_expression *const r1EC7 = expr(ir_unop_b2i, r1EC6);
                        ir_expression *const r1EC8 = expr(ir_unop_i2u, r1EC7);
                        body.emit(assign(r1EC3, sub(r1EC5, r1EC8), 0x01));

                        body.emit(assign(r1CAB, bit_xor(r1CAB, body.constant(1u)), 0x01));

                        body.emit(assign(r1CB4, add(r1CAE, body.constant(int(-1))), 0x01));

                        ir_variable *const r1EC9 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r1EC9, add(r1CB4, body.constant(int(-10))), 0x01));

                        ir_variable *const r1ECA = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r1ECA, r1EC3, 0x01));

                        ir_variable *const r1ECB = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r1ECB, r1EC4, 0x01));

                        ir_variable *const r1ECC = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r1ECC);
                        ir_variable *const r1ECD = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r1ECD);
                        /* IF CONDITION */
                        ir_expression *const r1ECF = equal(r1EC3, body.constant(0u));
                        ir_if *f1ECE = new(mem_ctx) ir_if(operand(r1ECF).val);
                        exec_list *const f1ECE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1ECE->then_instructions;

                           body.emit(assign(r1ECA, r1EC4, 0x01));

                           body.emit(assign(r1ECB, body.constant(0u), 0x01));

                           body.emit(assign(r1EC9, add(r1EC9, body.constant(int(-32))), 0x01));


                        body.instructions = f1ECE_parent_instructions;
                        body.emit(f1ECE);

                        /* END IF */

                        ir_variable *const r1ED0 = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r1ED0, r1ECA, 0x01));

                        ir_variable *const r1ED1 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r1ED2 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r1ED2);
                        /* IF CONDITION */
                        ir_expression *const r1ED4 = equal(r1ECA, body.constant(0u));
                        ir_if *f1ED3 = new(mem_ctx) ir_if(operand(r1ED4).val);
                        exec_list *const f1ED3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1ED3->then_instructions;

                           body.emit(assign(r1ED1, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1ED3->else_instructions;

                           body.emit(assign(r1ED2, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1ED6 = bit_and(r1ECA, body.constant(4294901760u));
                           ir_expression *const r1ED7 = equal(r1ED6, body.constant(0u));
                           ir_if *f1ED5 = new(mem_ctx) ir_if(operand(r1ED7).val);
                           exec_list *const f1ED5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1ED5->then_instructions;

                              body.emit(assign(r1ED2, body.constant(int(16)), 0x01));

                              body.emit(assign(r1ED0, lshift(r1ECA, body.constant(int(16))), 0x01));


                           body.instructions = f1ED5_parent_instructions;
                           body.emit(f1ED5);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r1ED9 = bit_and(r1ED0, body.constant(4278190080u));
                           ir_expression *const r1EDA = equal(r1ED9, body.constant(0u));
                           ir_if *f1ED8 = new(mem_ctx) ir_if(operand(r1EDA).val);
                           exec_list *const f1ED8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1ED8->then_instructions;

                              body.emit(assign(r1ED2, add(r1ED2, body.constant(int(8))), 0x01));

                              body.emit(assign(r1ED0, lshift(r1ED0, body.constant(int(8))), 0x01));


                           body.instructions = f1ED8_parent_instructions;
                           body.emit(f1ED8);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r1EDC = bit_and(r1ED0, body.constant(4026531840u));
                           ir_expression *const r1EDD = equal(r1EDC, body.constant(0u));
                           ir_if *f1EDB = new(mem_ctx) ir_if(operand(r1EDD).val);
                           exec_list *const f1EDB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1EDB->then_instructions;

                              body.emit(assign(r1ED2, add(r1ED2, body.constant(int(4))), 0x01));

                              body.emit(assign(r1ED0, lshift(r1ED0, body.constant(int(4))), 0x01));


                           body.instructions = f1EDB_parent_instructions;
                           body.emit(f1EDB);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r1EDF = bit_and(r1ED0, body.constant(3221225472u));
                           ir_expression *const r1EE0 = equal(r1EDF, body.constant(0u));
                           ir_if *f1EDE = new(mem_ctx) ir_if(operand(r1EE0).val);
                           exec_list *const f1EDE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1EDE->then_instructions;

                              body.emit(assign(r1ED2, add(r1ED2, body.constant(int(2))), 0x01));

                              body.emit(assign(r1ED0, lshift(r1ED0, body.constant(int(2))), 0x01));


                           body.instructions = f1EDE_parent_instructions;
                           body.emit(f1EDE);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r1EE2 = bit_and(r1ED0, body.constant(2147483648u));
                           ir_expression *const r1EE3 = equal(r1EE2, body.constant(0u));
                           ir_if *f1EE1 = new(mem_ctx) ir_if(operand(r1EE3).val);
                           exec_list *const f1EE1_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1EE1->then_instructions;

                              body.emit(assign(r1ED2, add(r1ED2, body.constant(int(1))), 0x01));


                           body.instructions = f1EE1_parent_instructions;
                           body.emit(f1EE1);

                           /* END IF */

                           body.emit(assign(r1ED1, r1ED2, 0x01));


                        body.instructions = f1ED3_parent_instructions;
                        body.emit(f1ED3);

                        /* END IF */

                        body.emit(assign(r1ECD, add(r1ED1, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1EE5 = lequal(body.constant(int(0)), r1ECD);
                        ir_if *f1EE4 = new(mem_ctx) ir_if(operand(r1EE5).val);
                        exec_list *const f1EE4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1EE4->then_instructions;

                           body.emit(assign(r1ECC, body.constant(0u), 0x01));

                           ir_variable *const r1EE6 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r1EE6, lshift(r1ECB, r1ECD), 0x01));

                           ir_variable *const r1EE7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r1EE9 = equal(r1ECD, body.constant(int(0)));
                           ir_if *f1EE8 = new(mem_ctx) ir_if(operand(r1EE9).val);
                           exec_list *const f1EE8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1EE8->then_instructions;

                              body.emit(assign(r1EE7, r1ECA, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1EE8->else_instructions;

                              ir_expression *const r1EEA = lshift(r1ECA, r1ECD);
                              ir_expression *const r1EEB = neg(r1ECD);
                              ir_expression *const r1EEC = bit_and(r1EEB, body.constant(int(31)));
                              ir_expression *const r1EED = rshift(r1ECB, r1EEC);
                              body.emit(assign(r1EE7, bit_or(r1EEA, r1EED), 0x01));


                           body.instructions = f1EE8_parent_instructions;
                           body.emit(f1EE8);

                           /* END IF */

                           body.emit(assign(r1ECA, r1EE7, 0x01));

                           body.emit(assign(r1ECB, r1EE6, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1EE4->else_instructions;

                           ir_variable *const r1EEE = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r1EEE, body.constant(0u), 0x01));

                           ir_variable *const r1EEF = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r1EEF, neg(r1ECD), 0x01));

                           ir_variable *const r1EF0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r1EF0);
                           ir_variable *const r1EF1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r1EF1);
                           ir_variable *const r1EF2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r1EF2);
                           ir_variable *const r1EF3 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r1EF4 = neg(r1EEF);
                           body.emit(assign(r1EF3, bit_and(r1EF4, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1EF6 = equal(r1EEF, body.constant(int(0)));
                           ir_if *f1EF5 = new(mem_ctx) ir_if(operand(r1EF6).val);
                           exec_list *const f1EF5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1EF5->then_instructions;

                              body.emit(assign(r1EF0, r1EEE, 0x01));

                              body.emit(assign(r1EF1, r1ECB, 0x01));

                              body.emit(assign(r1EF2, r1ECA, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1EF5->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1EF8 = less(r1EEF, body.constant(int(32)));
                              ir_if *f1EF7 = new(mem_ctx) ir_if(operand(r1EF8).val);
                              exec_list *const f1EF7_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1EF7->then_instructions;

                                 body.emit(assign(r1EF0, lshift(r1ECB, r1EF3), 0x01));

                                 ir_expression *const r1EF9 = lshift(r1ECA, r1EF3);
                                 ir_expression *const r1EFA = rshift(r1ECB, r1EEF);
                                 body.emit(assign(r1EF1, bit_or(r1EF9, r1EFA), 0x01));

                                 body.emit(assign(r1EF2, rshift(r1ECA, r1EEF), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1EF7->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1EFC = equal(r1EEF, body.constant(int(32)));
                                 ir_if *f1EFB = new(mem_ctx) ir_if(operand(r1EFC).val);
                                 exec_list *const f1EFB_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1EFB->then_instructions;

                                    body.emit(assign(r1EF0, r1ECB, 0x01));

                                    body.emit(assign(r1EF1, r1ECA, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1EFB->else_instructions;

                                    body.emit(assign(r1EEE, bit_or(body.constant(0u), r1ECB), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r1EFE = less(r1EEF, body.constant(int(64)));
                                    ir_if *f1EFD = new(mem_ctx) ir_if(operand(r1EFE).val);
                                    exec_list *const f1EFD_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1EFD->then_instructions;

                                       body.emit(assign(r1EF0, lshift(r1ECA, r1EF3), 0x01));

                                       ir_expression *const r1EFF = bit_and(r1EEF, body.constant(int(31)));
                                       body.emit(assign(r1EF1, rshift(r1ECA, r1EFF), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1EFD->else_instructions;

                                       ir_variable *const r1F00 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r1F02 = equal(r1EEF, body.constant(int(64)));
                                       ir_if *f1F01 = new(mem_ctx) ir_if(operand(r1F02).val);
                                       exec_list *const f1F01_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1F01->then_instructions;

                                          body.emit(assign(r1F00, r1ECA, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1F01->else_instructions;

                                          ir_expression *const r1F03 = nequal(r1ECA, body.constant(0u));
                                          ir_expression *const r1F04 = expr(ir_unop_b2i, r1F03);
                                          body.emit(assign(r1F00, expr(ir_unop_i2u, r1F04), 0x01));


                                       body.instructions = f1F01_parent_instructions;
                                       body.emit(f1F01);

                                       /* END IF */

                                       body.emit(assign(r1EF0, r1F00, 0x01));

                                       body.emit(assign(r1EF1, body.constant(0u), 0x01));


                                    body.instructions = f1EFD_parent_instructions;
                                    body.emit(f1EFD);

                                    /* END IF */


                                 body.instructions = f1EFB_parent_instructions;
                                 body.emit(f1EFB);

                                 /* END IF */

                                 body.emit(assign(r1EF2, body.constant(0u), 0x01));


                              body.instructions = f1EF7_parent_instructions;
                              body.emit(f1EF7);

                              /* END IF */

                              ir_expression *const r1F05 = nequal(r1EEE, body.constant(0u));
                              ir_expression *const r1F06 = expr(ir_unop_b2i, r1F05);
                              ir_expression *const r1F07 = expr(ir_unop_i2u, r1F06);
                              body.emit(assign(r1EF0, bit_or(r1EF0, r1F07), 0x01));


                           body.instructions = f1EF5_parent_instructions;
                           body.emit(f1EF5);

                           /* END IF */

                           body.emit(assign(r1ECA, r1EF2, 0x01));

                           body.emit(assign(r1ECB, r1EF1, 0x01));

                           body.emit(assign(r1ECC, r1EF0, 0x01));


                        body.instructions = f1EE4_parent_instructions;
                        body.emit(f1EE4);

                        /* END IF */

                        body.emit(assign(r1EC9, sub(r1EC9, r1ECD), 0x01));

                        ir_variable *const r1F08 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r1F08, r1EC9, 0x01));

                        ir_variable *const r1F09 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r1F09, r1ECA, 0x01));

                        ir_variable *const r1F0A = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r1F0A, r1ECB, 0x01));

                        ir_variable *const r1F0B = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r1F0B, r1ECC, 0x01));

                        ir_variable *const r1F0C = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r1F0C, body.constant(true), 0x01));

                        ir_variable *const r1F0D = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r1F0E = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r1F0E);
                        ir_expression *const r1F0F = expr(ir_unop_u2i, r1ECC);
                        body.emit(assign(r1F0E, less(r1F0F, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1F11 = lequal(body.constant(int(2045)), r1EC9);
                        ir_if *f1F10 = new(mem_ctx) ir_if(operand(r1F11).val);
                        exec_list *const f1F10_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1F10->then_instructions;

                           ir_variable *const r1F12 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r1F14 = less(body.constant(int(2045)), r1EC9);
                           ir_if *f1F13 = new(mem_ctx) ir_if(operand(r1F14).val);
                           exec_list *const f1F13_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1F13->then_instructions;

                              body.emit(assign(r1F12, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1F13->else_instructions;

                              ir_variable *const r1F15 = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1F17 = equal(r1EC9, body.constant(int(2045)));
                              ir_if *f1F16 = new(mem_ctx) ir_if(operand(r1F17).val);
                              exec_list *const f1F16_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F16->then_instructions;

                                 ir_expression *const r1F18 = equal(body.constant(2097151u), r1ECA);
                                 ir_expression *const r1F19 = equal(body.constant(4294967295u), r1ECB);
                                 body.emit(assign(r1F15, logic_and(r1F18, r1F19), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1F16->else_instructions;

                                 body.emit(assign(r1F15, body.constant(false), 0x01));


                              body.instructions = f1F16_parent_instructions;
                              body.emit(f1F16);

                              /* END IF */

                              body.emit(assign(r1F12, logic_and(r1F15, r1F0E), 0x01));


                           body.instructions = f1F13_parent_instructions;
                           body.emit(f1F13);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f1F1A = new(mem_ctx) ir_if(operand(r1F12).val);
                           exec_list *const f1F1A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1F1A->then_instructions;

                              ir_variable *const r1F1B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r1F1B);
                              ir_expression *const r1F1C = lshift(r1CAB, body.constant(int(31)));
                              body.emit(assign(r1F1B, add(r1F1C, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r1F1B, body.constant(0u), 0x01));

                              body.emit(assign(r1F0D, r1F1B, 0x03));

                              body.emit(assign(r1F0C, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1F1A->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1F1E = less(r1EC9, body.constant(int(0)));
                              ir_if *f1F1D = new(mem_ctx) ir_if(operand(r1F1E).val);
                              exec_list *const f1F1D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F1D->then_instructions;

                                 ir_variable *const r1F1F = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r1F1F, r1ECC, 0x01));

                                 ir_variable *const r1F20 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r1F20, neg(r1EC9), 0x01));

                                 ir_variable *const r1F21 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r1F21);
                                 ir_variable *const r1F22 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r1F22);
                                 ir_variable *const r1F23 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r1F23);
                                 ir_variable *const r1F24 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r1F25 = neg(r1F20);
                                 body.emit(assign(r1F24, bit_and(r1F25, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1F27 = equal(r1F20, body.constant(int(0)));
                                 ir_if *f1F26 = new(mem_ctx) ir_if(operand(r1F27).val);
                                 exec_list *const f1F26_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1F26->then_instructions;

                                    body.emit(assign(r1F21, r1ECC, 0x01));

                                    body.emit(assign(r1F22, r1ECB, 0x01));

                                    body.emit(assign(r1F23, r1ECA, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1F26->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r1F29 = less(r1F20, body.constant(int(32)));
                                    ir_if *f1F28 = new(mem_ctx) ir_if(operand(r1F29).val);
                                    exec_list *const f1F28_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1F28->then_instructions;

                                       body.emit(assign(r1F21, lshift(r1ECB, r1F24), 0x01));

                                       ir_expression *const r1F2A = lshift(r1ECA, r1F24);
                                       ir_expression *const r1F2B = rshift(r1ECB, r1F20);
                                       body.emit(assign(r1F22, bit_or(r1F2A, r1F2B), 0x01));

                                       body.emit(assign(r1F23, rshift(r1ECA, r1F20), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1F28->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r1F2D = equal(r1F20, body.constant(int(32)));
                                       ir_if *f1F2C = new(mem_ctx) ir_if(operand(r1F2D).val);
                                       exec_list *const f1F2C_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1F2C->then_instructions;

                                          body.emit(assign(r1F21, r1ECB, 0x01));

                                          body.emit(assign(r1F22, r1ECA, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1F2C->else_instructions;

                                          body.emit(assign(r1F1F, bit_or(r1ECC, r1ECB), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r1F2F = less(r1F20, body.constant(int(64)));
                                          ir_if *f1F2E = new(mem_ctx) ir_if(operand(r1F2F).val);
                                          exec_list *const f1F2E_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1F2E->then_instructions;

                                             body.emit(assign(r1F21, lshift(r1ECA, r1F24), 0x01));

                                             ir_expression *const r1F30 = bit_and(r1F20, body.constant(int(31)));
                                             body.emit(assign(r1F22, rshift(r1ECA, r1F30), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1F2E->else_instructions;

                                             ir_variable *const r1F31 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r1F33 = equal(r1F20, body.constant(int(64)));
                                             ir_if *f1F32 = new(mem_ctx) ir_if(operand(r1F33).val);
                                             exec_list *const f1F32_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f1F32->then_instructions;

                                                body.emit(assign(r1F31, r1ECA, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f1F32->else_instructions;

                                                ir_expression *const r1F34 = nequal(r1ECA, body.constant(0u));
                                                ir_expression *const r1F35 = expr(ir_unop_b2i, r1F34);
                                                body.emit(assign(r1F31, expr(ir_unop_i2u, r1F35), 0x01));


                                             body.instructions = f1F32_parent_instructions;
                                             body.emit(f1F32);

                                             /* END IF */

                                             body.emit(assign(r1F21, r1F31, 0x01));

                                             body.emit(assign(r1F22, body.constant(0u), 0x01));


                                          body.instructions = f1F2E_parent_instructions;
                                          body.emit(f1F2E);

                                          /* END IF */


                                       body.instructions = f1F2C_parent_instructions;
                                       body.emit(f1F2C);

                                       /* END IF */

                                       body.emit(assign(r1F23, body.constant(0u), 0x01));


                                    body.instructions = f1F28_parent_instructions;
                                    body.emit(f1F28);

                                    /* END IF */

                                    ir_expression *const r1F36 = nequal(r1F1F, body.constant(0u));
                                    ir_expression *const r1F37 = expr(ir_unop_b2i, r1F36);
                                    ir_expression *const r1F38 = expr(ir_unop_i2u, r1F37);
                                    body.emit(assign(r1F21, bit_or(r1F21, r1F38), 0x01));


                                 body.instructions = f1F26_parent_instructions;
                                 body.emit(f1F26);

                                 /* END IF */

                                 body.emit(assign(r1F09, r1F23, 0x01));

                                 body.emit(assign(r1F0A, r1F22, 0x01));

                                 body.emit(assign(r1F0B, r1F21, 0x01));

                                 body.emit(assign(r1F08, body.constant(int(0)), 0x01));

                                 body.emit(assign(r1F0E, less(r1F21, body.constant(0u)), 0x01));


                              body.instructions = f1F1D_parent_instructions;
                              body.emit(f1F1D);

                              /* END IF */


                           body.instructions = f1F1A_parent_instructions;
                           body.emit(f1F1A);

                           /* END IF */


                        body.instructions = f1F10_parent_instructions;
                        body.emit(f1F10);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f1F39 = new(mem_ctx) ir_if(operand(r1F0C).val);
                        exec_list *const f1F39_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1F39->then_instructions;

                           /* IF CONDITION */
                           ir_if *f1F3A = new(mem_ctx) ir_if(operand(r1F0E).val);
                           exec_list *const f1F3A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1F3A->then_instructions;

                              ir_variable *const r1F3B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r1F3B, add(r1F0A, body.constant(1u)), 0x01));

                              ir_expression *const r1F3C = less(r1F3B, r1F0A);
                              ir_expression *const r1F3D = expr(ir_unop_b2i, r1F3C);
                              ir_expression *const r1F3E = expr(ir_unop_i2u, r1F3D);
                              body.emit(assign(r1F09, add(r1F09, r1F3E), 0x01));

                              ir_expression *const r1F3F = equal(r1F0B, body.constant(0u));
                              ir_expression *const r1F40 = expr(ir_unop_b2i, r1F3F);
                              ir_expression *const r1F41 = expr(ir_unop_i2u, r1F40);
                              ir_expression *const r1F42 = add(r1F0B, r1F41);
                              ir_expression *const r1F43 = bit_and(r1F42, body.constant(1u));
                              ir_expression *const r1F44 = expr(ir_unop_bit_not, r1F43);
                              body.emit(assign(r1F0A, bit_and(r1F3B, r1F44), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1F3A->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1F46 = bit_or(r1F09, r1F0A);
                              ir_expression *const r1F47 = equal(r1F46, body.constant(0u));
                              ir_if *f1F45 = new(mem_ctx) ir_if(operand(r1F47).val);
                              exec_list *const f1F45_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F45->then_instructions;

                                 body.emit(assign(r1F08, body.constant(int(0)), 0x01));


                              body.instructions = f1F45_parent_instructions;
                              body.emit(f1F45);

                              /* END IF */


                           body.instructions = f1F3A_parent_instructions;
                           body.emit(f1F3A);

                           /* END IF */

                           ir_variable *const r1F48 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r1F48);
                           ir_expression *const r1F49 = lshift(r1CAB, body.constant(int(31)));
                           ir_expression *const r1F4A = expr(ir_unop_i2u, r1F08);
                           ir_expression *const r1F4B = lshift(r1F4A, body.constant(int(20)));
                           ir_expression *const r1F4C = add(r1F49, r1F4B);
                           body.emit(assign(r1F48, add(r1F4C, r1F09), 0x02));

                           body.emit(assign(r1F48, r1F0A, 0x01));

                           body.emit(assign(r1F0D, r1F48, 0x03));

                           body.emit(assign(r1F0C, body.constant(false), 0x01));


                        body.instructions = f1F39_parent_instructions;
                        body.emit(f1F39);

                        /* END IF */

                        body.emit(assign(r1CAC, r1F0D, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1EC1->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1F4E = less(r1CB1, r1CB3);
                        ir_if *f1F4D = new(mem_ctx) ir_if(operand(r1F4E).val);
                        exec_list *const f1F4D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1F4D->then_instructions;

                           ir_variable *const r1F4F = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r1F50 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r1F50, sub(r1CB3, r1CB1), 0x01));

                           ir_expression *const r1F51 = sub(r1CB2, r1CB0);
                           ir_expression *const r1F52 = less(r1CB3, r1CB1);
                           ir_expression *const r1F53 = expr(ir_unop_b2i, r1F52);
                           ir_expression *const r1F54 = expr(ir_unop_i2u, r1F53);
                           body.emit(assign(r1F4F, sub(r1F51, r1F54), 0x01));

                           body.emit(assign(r1CB4, add(r1CAF, body.constant(int(-1))), 0x01));

                           ir_variable *const r1F55 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r1F55, add(r1CB4, body.constant(int(-10))), 0x01));

                           ir_variable *const r1F56 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r1F56, r1F4F, 0x01));

                           ir_variable *const r1F57 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r1F57, r1F50, 0x01));

                           ir_variable *const r1F58 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r1F58);
                           ir_variable *const r1F59 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r1F59);
                           /* IF CONDITION */
                           ir_expression *const r1F5B = equal(r1F4F, body.constant(0u));
                           ir_if *f1F5A = new(mem_ctx) ir_if(operand(r1F5B).val);
                           exec_list *const f1F5A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1F5A->then_instructions;

                              body.emit(assign(r1F56, r1F50, 0x01));

                              body.emit(assign(r1F57, body.constant(0u), 0x01));

                              body.emit(assign(r1F55, add(r1F55, body.constant(int(-32))), 0x01));


                           body.instructions = f1F5A_parent_instructions;
                           body.emit(f1F5A);

                           /* END IF */

                           ir_variable *const r1F5C = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r1F5C, r1F56, 0x01));

                           ir_variable *const r1F5D = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r1F5E = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r1F5E);
                           /* IF CONDITION */
                           ir_expression *const r1F60 = equal(r1F56, body.constant(0u));
                           ir_if *f1F5F = new(mem_ctx) ir_if(operand(r1F60).val);
                           exec_list *const f1F5F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1F5F->then_instructions;

                              body.emit(assign(r1F5D, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1F5F->else_instructions;

                              body.emit(assign(r1F5E, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1F62 = bit_and(r1F56, body.constant(4294901760u));
                              ir_expression *const r1F63 = equal(r1F62, body.constant(0u));
                              ir_if *f1F61 = new(mem_ctx) ir_if(operand(r1F63).val);
                              exec_list *const f1F61_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F61->then_instructions;

                                 body.emit(assign(r1F5E, body.constant(int(16)), 0x01));

                                 body.emit(assign(r1F5C, lshift(r1F56, body.constant(int(16))), 0x01));


                              body.instructions = f1F61_parent_instructions;
                              body.emit(f1F61);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r1F65 = bit_and(r1F5C, body.constant(4278190080u));
                              ir_expression *const r1F66 = equal(r1F65, body.constant(0u));
                              ir_if *f1F64 = new(mem_ctx) ir_if(operand(r1F66).val);
                              exec_list *const f1F64_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F64->then_instructions;

                                 body.emit(assign(r1F5E, add(r1F5E, body.constant(int(8))), 0x01));

                                 body.emit(assign(r1F5C, lshift(r1F5C, body.constant(int(8))), 0x01));


                              body.instructions = f1F64_parent_instructions;
                              body.emit(f1F64);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r1F68 = bit_and(r1F5C, body.constant(4026531840u));
                              ir_expression *const r1F69 = equal(r1F68, body.constant(0u));
                              ir_if *f1F67 = new(mem_ctx) ir_if(operand(r1F69).val);
                              exec_list *const f1F67_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F67->then_instructions;

                                 body.emit(assign(r1F5E, add(r1F5E, body.constant(int(4))), 0x01));

                                 body.emit(assign(r1F5C, lshift(r1F5C, body.constant(int(4))), 0x01));


                              body.instructions = f1F67_parent_instructions;
                              body.emit(f1F67);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r1F6B = bit_and(r1F5C, body.constant(3221225472u));
                              ir_expression *const r1F6C = equal(r1F6B, body.constant(0u));
                              ir_if *f1F6A = new(mem_ctx) ir_if(operand(r1F6C).val);
                              exec_list *const f1F6A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F6A->then_instructions;

                                 body.emit(assign(r1F5E, add(r1F5E, body.constant(int(2))), 0x01));

                                 body.emit(assign(r1F5C, lshift(r1F5C, body.constant(int(2))), 0x01));


                              body.instructions = f1F6A_parent_instructions;
                              body.emit(f1F6A);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r1F6E = bit_and(r1F5C, body.constant(2147483648u));
                              ir_expression *const r1F6F = equal(r1F6E, body.constant(0u));
                              ir_if *f1F6D = new(mem_ctx) ir_if(operand(r1F6F).val);
                              exec_list *const f1F6D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F6D->then_instructions;

                                 body.emit(assign(r1F5E, add(r1F5E, body.constant(int(1))), 0x01));


                              body.instructions = f1F6D_parent_instructions;
                              body.emit(f1F6D);

                              /* END IF */

                              body.emit(assign(r1F5D, r1F5E, 0x01));


                           body.instructions = f1F5F_parent_instructions;
                           body.emit(f1F5F);

                           /* END IF */

                           body.emit(assign(r1F59, add(r1F5D, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1F71 = lequal(body.constant(int(0)), r1F59);
                           ir_if *f1F70 = new(mem_ctx) ir_if(operand(r1F71).val);
                           exec_list *const f1F70_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1F70->then_instructions;

                              body.emit(assign(r1F58, body.constant(0u), 0x01));

                              ir_variable *const r1F72 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r1F72, lshift(r1F57, r1F59), 0x01));

                              ir_variable *const r1F73 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1F75 = equal(r1F59, body.constant(int(0)));
                              ir_if *f1F74 = new(mem_ctx) ir_if(operand(r1F75).val);
                              exec_list *const f1F74_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F74->then_instructions;

                                 body.emit(assign(r1F73, r1F56, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1F74->else_instructions;

                                 ir_expression *const r1F76 = lshift(r1F56, r1F59);
                                 ir_expression *const r1F77 = neg(r1F59);
                                 ir_expression *const r1F78 = bit_and(r1F77, body.constant(int(31)));
                                 ir_expression *const r1F79 = rshift(r1F57, r1F78);
                                 body.emit(assign(r1F73, bit_or(r1F76, r1F79), 0x01));


                              body.instructions = f1F74_parent_instructions;
                              body.emit(f1F74);

                              /* END IF */

                              body.emit(assign(r1F56, r1F73, 0x01));

                              body.emit(assign(r1F57, r1F72, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1F70->else_instructions;

                              ir_variable *const r1F7A = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r1F7A, body.constant(0u), 0x01));

                              ir_variable *const r1F7B = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r1F7B, neg(r1F59), 0x01));

                              ir_variable *const r1F7C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r1F7C);
                              ir_variable *const r1F7D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r1F7D);
                              ir_variable *const r1F7E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r1F7E);
                              ir_variable *const r1F7F = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r1F80 = neg(r1F7B);
                              body.emit(assign(r1F7F, bit_and(r1F80, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1F82 = equal(r1F7B, body.constant(int(0)));
                              ir_if *f1F81 = new(mem_ctx) ir_if(operand(r1F82).val);
                              exec_list *const f1F81_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F81->then_instructions;

                                 body.emit(assign(r1F7C, r1F7A, 0x01));

                                 body.emit(assign(r1F7D, r1F57, 0x01));

                                 body.emit(assign(r1F7E, r1F56, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1F81->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1F84 = less(r1F7B, body.constant(int(32)));
                                 ir_if *f1F83 = new(mem_ctx) ir_if(operand(r1F84).val);
                                 exec_list *const f1F83_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1F83->then_instructions;

                                    body.emit(assign(r1F7C, lshift(r1F57, r1F7F), 0x01));

                                    ir_expression *const r1F85 = lshift(r1F56, r1F7F);
                                    ir_expression *const r1F86 = rshift(r1F57, r1F7B);
                                    body.emit(assign(r1F7D, bit_or(r1F85, r1F86), 0x01));

                                    body.emit(assign(r1F7E, rshift(r1F56, r1F7B), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1F83->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r1F88 = equal(r1F7B, body.constant(int(32)));
                                    ir_if *f1F87 = new(mem_ctx) ir_if(operand(r1F88).val);
                                    exec_list *const f1F87_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1F87->then_instructions;

                                       body.emit(assign(r1F7C, r1F57, 0x01));

                                       body.emit(assign(r1F7D, r1F56, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1F87->else_instructions;

                                       body.emit(assign(r1F7A, bit_or(body.constant(0u), r1F57), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r1F8A = less(r1F7B, body.constant(int(64)));
                                       ir_if *f1F89 = new(mem_ctx) ir_if(operand(r1F8A).val);
                                       exec_list *const f1F89_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1F89->then_instructions;

                                          body.emit(assign(r1F7C, lshift(r1F56, r1F7F), 0x01));

                                          ir_expression *const r1F8B = bit_and(r1F7B, body.constant(int(31)));
                                          body.emit(assign(r1F7D, rshift(r1F56, r1F8B), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1F89->else_instructions;

                                          ir_variable *const r1F8C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r1F8E = equal(r1F7B, body.constant(int(64)));
                                          ir_if *f1F8D = new(mem_ctx) ir_if(operand(r1F8E).val);
                                          exec_list *const f1F8D_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1F8D->then_instructions;

                                             body.emit(assign(r1F8C, r1F56, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1F8D->else_instructions;

                                             ir_expression *const r1F8F = nequal(r1F56, body.constant(0u));
                                             ir_expression *const r1F90 = expr(ir_unop_b2i, r1F8F);
                                             body.emit(assign(r1F8C, expr(ir_unop_i2u, r1F90), 0x01));


                                          body.instructions = f1F8D_parent_instructions;
                                          body.emit(f1F8D);

                                          /* END IF */

                                          body.emit(assign(r1F7C, r1F8C, 0x01));

                                          body.emit(assign(r1F7D, body.constant(0u), 0x01));


                                       body.instructions = f1F89_parent_instructions;
                                       body.emit(f1F89);

                                       /* END IF */


                                    body.instructions = f1F87_parent_instructions;
                                    body.emit(f1F87);

                                    /* END IF */

                                    body.emit(assign(r1F7E, body.constant(0u), 0x01));


                                 body.instructions = f1F83_parent_instructions;
                                 body.emit(f1F83);

                                 /* END IF */

                                 ir_expression *const r1F91 = nequal(r1F7A, body.constant(0u));
                                 ir_expression *const r1F92 = expr(ir_unop_b2i, r1F91);
                                 ir_expression *const r1F93 = expr(ir_unop_i2u, r1F92);
                                 body.emit(assign(r1F7C, bit_or(r1F7C, r1F93), 0x01));


                              body.instructions = f1F81_parent_instructions;
                              body.emit(f1F81);

                              /* END IF */

                              body.emit(assign(r1F56, r1F7E, 0x01));

                              body.emit(assign(r1F57, r1F7D, 0x01));

                              body.emit(assign(r1F58, r1F7C, 0x01));


                           body.instructions = f1F70_parent_instructions;
                           body.emit(f1F70);

                           /* END IF */

                           body.emit(assign(r1F55, sub(r1F55, r1F59), 0x01));

                           ir_variable *const r1F94 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r1F94, r1F55, 0x01));

                           ir_variable *const r1F95 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r1F95, r1F56, 0x01));

                           ir_variable *const r1F96 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r1F96, r1F57, 0x01));

                           ir_variable *const r1F97 = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r1F97, r1F58, 0x01));

                           ir_variable *const r1F98 = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r1F98, body.constant(true), 0x01));

                           ir_variable *const r1F99 = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r1F9A = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r1F9A);
                           ir_expression *const r1F9B = expr(ir_unop_u2i, r1F58);
                           body.emit(assign(r1F9A, less(r1F9B, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1F9D = lequal(body.constant(int(2045)), r1F55);
                           ir_if *f1F9C = new(mem_ctx) ir_if(operand(r1F9D).val);
                           exec_list *const f1F9C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1F9C->then_instructions;

                              ir_variable *const r1F9E = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1FA0 = less(body.constant(int(2045)), r1F55);
                              ir_if *f1F9F = new(mem_ctx) ir_if(operand(r1FA0).val);
                              exec_list *const f1F9F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F9F->then_instructions;

                                 body.emit(assign(r1F9E, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1F9F->else_instructions;

                                 ir_variable *const r1FA1 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r1FA3 = equal(r1F55, body.constant(int(2045)));
                                 ir_if *f1FA2 = new(mem_ctx) ir_if(operand(r1FA3).val);
                                 exec_list *const f1FA2_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1FA2->then_instructions;

                                    ir_expression *const r1FA4 = equal(body.constant(2097151u), r1F56);
                                    ir_expression *const r1FA5 = equal(body.constant(4294967295u), r1F57);
                                    body.emit(assign(r1FA1, logic_and(r1FA4, r1FA5), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1FA2->else_instructions;

                                    body.emit(assign(r1FA1, body.constant(false), 0x01));


                                 body.instructions = f1FA2_parent_instructions;
                                 body.emit(f1FA2);

                                 /* END IF */

                                 body.emit(assign(r1F9E, logic_and(r1FA1, r1F9A), 0x01));


                              body.instructions = f1F9F_parent_instructions;
                              body.emit(f1F9F);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f1FA6 = new(mem_ctx) ir_if(operand(r1F9E).val);
                              exec_list *const f1FA6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1FA6->then_instructions;

                                 ir_variable *const r1FA7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r1FA7);
                                 ir_expression *const r1FA8 = lshift(r1CAB, body.constant(int(31)));
                                 body.emit(assign(r1FA7, add(r1FA8, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r1FA7, body.constant(0u), 0x01));

                                 body.emit(assign(r1F99, r1FA7, 0x03));

                                 body.emit(assign(r1F98, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1FA6->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1FAA = less(r1F55, body.constant(int(0)));
                                 ir_if *f1FA9 = new(mem_ctx) ir_if(operand(r1FAA).val);
                                 exec_list *const f1FA9_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1FA9->then_instructions;

                                    ir_variable *const r1FAB = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r1FAB, r1F58, 0x01));

                                    ir_variable *const r1FAC = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r1FAC, neg(r1F55), 0x01));

                                    ir_variable *const r1FAD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r1FAD);
                                    ir_variable *const r1FAE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r1FAE);
                                    ir_variable *const r1FAF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r1FAF);
                                    ir_variable *const r1FB0 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r1FB1 = neg(r1FAC);
                                    body.emit(assign(r1FB0, bit_and(r1FB1, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r1FB3 = equal(r1FAC, body.constant(int(0)));
                                    ir_if *f1FB2 = new(mem_ctx) ir_if(operand(r1FB3).val);
                                    exec_list *const f1FB2_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1FB2->then_instructions;

                                       body.emit(assign(r1FAD, r1F58, 0x01));

                                       body.emit(assign(r1FAE, r1F57, 0x01));

                                       body.emit(assign(r1FAF, r1F56, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1FB2->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r1FB5 = less(r1FAC, body.constant(int(32)));
                                       ir_if *f1FB4 = new(mem_ctx) ir_if(operand(r1FB5).val);
                                       exec_list *const f1FB4_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1FB4->then_instructions;

                                          body.emit(assign(r1FAD, lshift(r1F57, r1FB0), 0x01));

                                          ir_expression *const r1FB6 = lshift(r1F56, r1FB0);
                                          ir_expression *const r1FB7 = rshift(r1F57, r1FAC);
                                          body.emit(assign(r1FAE, bit_or(r1FB6, r1FB7), 0x01));

                                          body.emit(assign(r1FAF, rshift(r1F56, r1FAC), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1FB4->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r1FB9 = equal(r1FAC, body.constant(int(32)));
                                          ir_if *f1FB8 = new(mem_ctx) ir_if(operand(r1FB9).val);
                                          exec_list *const f1FB8_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1FB8->then_instructions;

                                             body.emit(assign(r1FAD, r1F57, 0x01));

                                             body.emit(assign(r1FAE, r1F56, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1FB8->else_instructions;

                                             body.emit(assign(r1FAB, bit_or(r1F58, r1F57), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r1FBB = less(r1FAC, body.constant(int(64)));
                                             ir_if *f1FBA = new(mem_ctx) ir_if(operand(r1FBB).val);
                                             exec_list *const f1FBA_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f1FBA->then_instructions;

                                                body.emit(assign(r1FAD, lshift(r1F56, r1FB0), 0x01));

                                                ir_expression *const r1FBC = bit_and(r1FAC, body.constant(int(31)));
                                                body.emit(assign(r1FAE, rshift(r1F56, r1FBC), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f1FBA->else_instructions;

                                                ir_variable *const r1FBD = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r1FBF = equal(r1FAC, body.constant(int(64)));
                                                ir_if *f1FBE = new(mem_ctx) ir_if(operand(r1FBF).val);
                                                exec_list *const f1FBE_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f1FBE->then_instructions;

                                                   body.emit(assign(r1FBD, r1F56, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f1FBE->else_instructions;

                                                   ir_expression *const r1FC0 = nequal(r1F56, body.constant(0u));
                                                   ir_expression *const r1FC1 = expr(ir_unop_b2i, r1FC0);
                                                   body.emit(assign(r1FBD, expr(ir_unop_i2u, r1FC1), 0x01));


                                                body.instructions = f1FBE_parent_instructions;
                                                body.emit(f1FBE);

                                                /* END IF */

                                                body.emit(assign(r1FAD, r1FBD, 0x01));

                                                body.emit(assign(r1FAE, body.constant(0u), 0x01));


                                             body.instructions = f1FBA_parent_instructions;
                                             body.emit(f1FBA);

                                             /* END IF */


                                          body.instructions = f1FB8_parent_instructions;
                                          body.emit(f1FB8);

                                          /* END IF */

                                          body.emit(assign(r1FAF, body.constant(0u), 0x01));


                                       body.instructions = f1FB4_parent_instructions;
                                       body.emit(f1FB4);

                                       /* END IF */

                                       ir_expression *const r1FC2 = nequal(r1FAB, body.constant(0u));
                                       ir_expression *const r1FC3 = expr(ir_unop_b2i, r1FC2);
                                       ir_expression *const r1FC4 = expr(ir_unop_i2u, r1FC3);
                                       body.emit(assign(r1FAD, bit_or(r1FAD, r1FC4), 0x01));


                                    body.instructions = f1FB2_parent_instructions;
                                    body.emit(f1FB2);

                                    /* END IF */

                                    body.emit(assign(r1F95, r1FAF, 0x01));

                                    body.emit(assign(r1F96, r1FAE, 0x01));

                                    body.emit(assign(r1F97, r1FAD, 0x01));

                                    body.emit(assign(r1F94, body.constant(int(0)), 0x01));

                                    body.emit(assign(r1F9A, less(r1FAD, body.constant(0u)), 0x01));


                                 body.instructions = f1FA9_parent_instructions;
                                 body.emit(f1FA9);

                                 /* END IF */


                              body.instructions = f1FA6_parent_instructions;
                              body.emit(f1FA6);

                              /* END IF */


                           body.instructions = f1F9C_parent_instructions;
                           body.emit(f1F9C);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f1FC5 = new(mem_ctx) ir_if(operand(r1F98).val);
                           exec_list *const f1FC5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1FC5->then_instructions;

                              /* IF CONDITION */
                              ir_if *f1FC6 = new(mem_ctx) ir_if(operand(r1F9A).val);
                              exec_list *const f1FC6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1FC6->then_instructions;

                                 ir_variable *const r1FC7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r1FC7, add(r1F96, body.constant(1u)), 0x01));

                                 ir_expression *const r1FC8 = less(r1FC7, r1F96);
                                 ir_expression *const r1FC9 = expr(ir_unop_b2i, r1FC8);
                                 ir_expression *const r1FCA = expr(ir_unop_i2u, r1FC9);
                                 body.emit(assign(r1F95, add(r1F95, r1FCA), 0x01));

                                 ir_expression *const r1FCB = equal(r1F97, body.constant(0u));
                                 ir_expression *const r1FCC = expr(ir_unop_b2i, r1FCB);
                                 ir_expression *const r1FCD = expr(ir_unop_i2u, r1FCC);
                                 ir_expression *const r1FCE = add(r1F97, r1FCD);
                                 ir_expression *const r1FCF = bit_and(r1FCE, body.constant(1u));
                                 ir_expression *const r1FD0 = expr(ir_unop_bit_not, r1FCF);
                                 body.emit(assign(r1F96, bit_and(r1FC7, r1FD0), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1FC6->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1FD2 = bit_or(r1F95, r1F96);
                                 ir_expression *const r1FD3 = equal(r1FD2, body.constant(0u));
                                 ir_if *f1FD1 = new(mem_ctx) ir_if(operand(r1FD3).val);
                                 exec_list *const f1FD1_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1FD1->then_instructions;

                                    body.emit(assign(r1F94, body.constant(int(0)), 0x01));


                                 body.instructions = f1FD1_parent_instructions;
                                 body.emit(f1FD1);

                                 /* END IF */


                              body.instructions = f1FC6_parent_instructions;
                              body.emit(f1FC6);

                              /* END IF */

                              ir_variable *const r1FD4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r1FD4);
                              ir_expression *const r1FD5 = lshift(r1CAB, body.constant(int(31)));
                              ir_expression *const r1FD6 = expr(ir_unop_i2u, r1F94);
                              ir_expression *const r1FD7 = lshift(r1FD6, body.constant(int(20)));
                              ir_expression *const r1FD8 = add(r1FD5, r1FD7);
                              body.emit(assign(r1FD4, add(r1FD8, r1F95), 0x02));

                              body.emit(assign(r1FD4, r1F96, 0x01));

                              body.emit(assign(r1F99, r1FD4, 0x03));

                              body.emit(assign(r1F98, body.constant(false), 0x01));


                           body.instructions = f1FC5_parent_instructions;
                           body.emit(f1FC5);

                           /* END IF */

                           body.emit(assign(r1CAC, r1F99, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1F4D->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1FDA = less(r1CB3, r1CB1);
                           ir_if *f1FD9 = new(mem_ctx) ir_if(operand(r1FDA).val);
                           exec_list *const f1FD9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1FD9->then_instructions;

                              ir_variable *const r1FDB = body.make_temp(glsl_type::uint_type, "z0Ptr");
                              ir_variable *const r1FDC = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r1FDC, sub(r1CB1, r1CB3), 0x01));

                              ir_expression *const r1FDD = sub(r1CB0, r1CB2);
                              ir_expression *const r1FDE = less(r1CB1, r1CB3);
                              ir_expression *const r1FDF = expr(ir_unop_b2i, r1FDE);
                              ir_expression *const r1FE0 = expr(ir_unop_i2u, r1FDF);
                              body.emit(assign(r1FDB, sub(r1FDD, r1FE0), 0x01));

                              body.emit(assign(r1CAB, bit_xor(r1CAB, body.constant(1u)), 0x01));

                              body.emit(assign(r1CB4, add(r1CAE, body.constant(int(-1))), 0x01));

                              ir_variable *const r1FE1 = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r1FE1, add(r1CB4, body.constant(int(-10))), 0x01));

                              ir_variable *const r1FE2 = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r1FE2, r1FDB, 0x01));

                              ir_variable *const r1FE3 = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r1FE3, r1FDC, 0x01));

                              ir_variable *const r1FE4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                              body.emit(r1FE4);
                              ir_variable *const r1FE5 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r1FE5);
                              /* IF CONDITION */
                              ir_expression *const r1FE7 = equal(r1FDB, body.constant(0u));
                              ir_if *f1FE6 = new(mem_ctx) ir_if(operand(r1FE7).val);
                              exec_list *const f1FE6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1FE6->then_instructions;

                                 body.emit(assign(r1FE2, r1FDC, 0x01));

                                 body.emit(assign(r1FE3, body.constant(0u), 0x01));

                                 body.emit(assign(r1FE1, add(r1FE1, body.constant(int(-32))), 0x01));


                              body.instructions = f1FE6_parent_instructions;
                              body.emit(f1FE6);

                              /* END IF */

                              ir_variable *const r1FE8 = body.make_temp(glsl_type::uint_type, "a");
                              body.emit(assign(r1FE8, r1FE2, 0x01));

                              ir_variable *const r1FE9 = body.make_temp(glsl_type::int_type, "return_value");
                              ir_variable *const r1FEA = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r1FEA);
                              /* IF CONDITION */
                              ir_expression *const r1FEC = equal(r1FE2, body.constant(0u));
                              ir_if *f1FEB = new(mem_ctx) ir_if(operand(r1FEC).val);
                              exec_list *const f1FEB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1FEB->then_instructions;

                                 body.emit(assign(r1FE9, body.constant(int(32)), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1FEB->else_instructions;

                                 body.emit(assign(r1FEA, body.constant(int(0)), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1FEE = bit_and(r1FE2, body.constant(4294901760u));
                                 ir_expression *const r1FEF = equal(r1FEE, body.constant(0u));
                                 ir_if *f1FED = new(mem_ctx) ir_if(operand(r1FEF).val);
                                 exec_list *const f1FED_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1FED->then_instructions;

                                    body.emit(assign(r1FEA, body.constant(int(16)), 0x01));

                                    body.emit(assign(r1FE8, lshift(r1FE2, body.constant(int(16))), 0x01));


                                 body.instructions = f1FED_parent_instructions;
                                 body.emit(f1FED);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r1FF1 = bit_and(r1FE8, body.constant(4278190080u));
                                 ir_expression *const r1FF2 = equal(r1FF1, body.constant(0u));
                                 ir_if *f1FF0 = new(mem_ctx) ir_if(operand(r1FF2).val);
                                 exec_list *const f1FF0_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1FF0->then_instructions;

                                    body.emit(assign(r1FEA, add(r1FEA, body.constant(int(8))), 0x01));

                                    body.emit(assign(r1FE8, lshift(r1FE8, body.constant(int(8))), 0x01));


                                 body.instructions = f1FF0_parent_instructions;
                                 body.emit(f1FF0);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r1FF4 = bit_and(r1FE8, body.constant(4026531840u));
                                 ir_expression *const r1FF5 = equal(r1FF4, body.constant(0u));
                                 ir_if *f1FF3 = new(mem_ctx) ir_if(operand(r1FF5).val);
                                 exec_list *const f1FF3_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1FF3->then_instructions;

                                    body.emit(assign(r1FEA, add(r1FEA, body.constant(int(4))), 0x01));

                                    body.emit(assign(r1FE8, lshift(r1FE8, body.constant(int(4))), 0x01));


                                 body.instructions = f1FF3_parent_instructions;
                                 body.emit(f1FF3);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r1FF7 = bit_and(r1FE8, body.constant(3221225472u));
                                 ir_expression *const r1FF8 = equal(r1FF7, body.constant(0u));
                                 ir_if *f1FF6 = new(mem_ctx) ir_if(operand(r1FF8).val);
                                 exec_list *const f1FF6_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1FF6->then_instructions;

                                    body.emit(assign(r1FEA, add(r1FEA, body.constant(int(2))), 0x01));

                                    body.emit(assign(r1FE8, lshift(r1FE8, body.constant(int(2))), 0x01));


                                 body.instructions = f1FF6_parent_instructions;
                                 body.emit(f1FF6);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r1FFA = bit_and(r1FE8, body.constant(2147483648u));
                                 ir_expression *const r1FFB = equal(r1FFA, body.constant(0u));
                                 ir_if *f1FF9 = new(mem_ctx) ir_if(operand(r1FFB).val);
                                 exec_list *const f1FF9_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1FF9->then_instructions;

                                    body.emit(assign(r1FEA, add(r1FEA, body.constant(int(1))), 0x01));


                                 body.instructions = f1FF9_parent_instructions;
                                 body.emit(f1FF9);

                                 /* END IF */

                                 body.emit(assign(r1FE9, r1FEA, 0x01));


                              body.instructions = f1FEB_parent_instructions;
                              body.emit(f1FEB);

                              /* END IF */

                              body.emit(assign(r1FE5, add(r1FE9, body.constant(int(-11))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1FFD = lequal(body.constant(int(0)), r1FE5);
                              ir_if *f1FFC = new(mem_ctx) ir_if(operand(r1FFD).val);
                              exec_list *const f1FFC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1FFC->then_instructions;

                                 body.emit(assign(r1FE4, body.constant(0u), 0x01));

                                 ir_variable *const r1FFE = body.make_temp(glsl_type::uint_type, "z1Ptr");
                                 body.emit(assign(r1FFE, lshift(r1FE3, r1FE5), 0x01));

                                 ir_variable *const r1FFF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2001 = equal(r1FE5, body.constant(int(0)));
                                 ir_if *f2000 = new(mem_ctx) ir_if(operand(r2001).val);
                                 exec_list *const f2000_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2000->then_instructions;

                                    body.emit(assign(r1FFF, r1FE2, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2000->else_instructions;

                                    ir_expression *const r2002 = lshift(r1FE2, r1FE5);
                                    ir_expression *const r2003 = neg(r1FE5);
                                    ir_expression *const r2004 = bit_and(r2003, body.constant(int(31)));
                                    ir_expression *const r2005 = rshift(r1FE3, r2004);
                                    body.emit(assign(r1FFF, bit_or(r2002, r2005), 0x01));


                                 body.instructions = f2000_parent_instructions;
                                 body.emit(f2000);

                                 /* END IF */

                                 body.emit(assign(r1FE2, r1FFF, 0x01));

                                 body.emit(assign(r1FE3, r1FFE, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1FFC->else_instructions;

                                 ir_variable *const r2006 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r2006, body.constant(0u), 0x01));

                                 ir_variable *const r2007 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r2007, neg(r1FE5), 0x01));

                                 ir_variable *const r2008 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r2008);
                                 ir_variable *const r2009 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r2009);
                                 ir_variable *const r200A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r200A);
                                 ir_variable *const r200B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r200C = neg(r2007);
                                 body.emit(assign(r200B, bit_and(r200C, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r200E = equal(r2007, body.constant(int(0)));
                                 ir_if *f200D = new(mem_ctx) ir_if(operand(r200E).val);
                                 exec_list *const f200D_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f200D->then_instructions;

                                    body.emit(assign(r2008, r2006, 0x01));

                                    body.emit(assign(r2009, r1FE3, 0x01));

                                    body.emit(assign(r200A, r1FE2, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f200D->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2010 = less(r2007, body.constant(int(32)));
                                    ir_if *f200F = new(mem_ctx) ir_if(operand(r2010).val);
                                    exec_list *const f200F_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f200F->then_instructions;

                                       body.emit(assign(r2008, lshift(r1FE3, r200B), 0x01));

                                       ir_expression *const r2011 = lshift(r1FE2, r200B);
                                       ir_expression *const r2012 = rshift(r1FE3, r2007);
                                       body.emit(assign(r2009, bit_or(r2011, r2012), 0x01));

                                       body.emit(assign(r200A, rshift(r1FE2, r2007), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f200F->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r2014 = equal(r2007, body.constant(int(32)));
                                       ir_if *f2013 = new(mem_ctx) ir_if(operand(r2014).val);
                                       exec_list *const f2013_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2013->then_instructions;

                                          body.emit(assign(r2008, r1FE3, 0x01));

                                          body.emit(assign(r2009, r1FE2, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2013->else_instructions;

                                          body.emit(assign(r2006, bit_or(body.constant(0u), r1FE3), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r2016 = less(r2007, body.constant(int(64)));
                                          ir_if *f2015 = new(mem_ctx) ir_if(operand(r2016).val);
                                          exec_list *const f2015_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2015->then_instructions;

                                             body.emit(assign(r2008, lshift(r1FE2, r200B), 0x01));

                                             ir_expression *const r2017 = bit_and(r2007, body.constant(int(31)));
                                             body.emit(assign(r2009, rshift(r1FE2, r2017), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2015->else_instructions;

                                             ir_variable *const r2018 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r201A = equal(r2007, body.constant(int(64)));
                                             ir_if *f2019 = new(mem_ctx) ir_if(operand(r201A).val);
                                             exec_list *const f2019_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2019->then_instructions;

                                                body.emit(assign(r2018, r1FE2, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2019->else_instructions;

                                                ir_expression *const r201B = nequal(r1FE2, body.constant(0u));
                                                ir_expression *const r201C = expr(ir_unop_b2i, r201B);
                                                body.emit(assign(r2018, expr(ir_unop_i2u, r201C), 0x01));


                                             body.instructions = f2019_parent_instructions;
                                             body.emit(f2019);

                                             /* END IF */

                                             body.emit(assign(r2008, r2018, 0x01));

                                             body.emit(assign(r2009, body.constant(0u), 0x01));


                                          body.instructions = f2015_parent_instructions;
                                          body.emit(f2015);

                                          /* END IF */


                                       body.instructions = f2013_parent_instructions;
                                       body.emit(f2013);

                                       /* END IF */

                                       body.emit(assign(r200A, body.constant(0u), 0x01));


                                    body.instructions = f200F_parent_instructions;
                                    body.emit(f200F);

                                    /* END IF */

                                    ir_expression *const r201D = nequal(r2006, body.constant(0u));
                                    ir_expression *const r201E = expr(ir_unop_b2i, r201D);
                                    ir_expression *const r201F = expr(ir_unop_i2u, r201E);
                                    body.emit(assign(r2008, bit_or(r2008, r201F), 0x01));


                                 body.instructions = f200D_parent_instructions;
                                 body.emit(f200D);

                                 /* END IF */

                                 body.emit(assign(r1FE2, r200A, 0x01));

                                 body.emit(assign(r1FE3, r2009, 0x01));

                                 body.emit(assign(r1FE4, r2008, 0x01));


                              body.instructions = f1FFC_parent_instructions;
                              body.emit(f1FFC);

                              /* END IF */

                              body.emit(assign(r1FE1, sub(r1FE1, r1FE5), 0x01));

                              ir_variable *const r2020 = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r2020, r1FE1, 0x01));

                              ir_variable *const r2021 = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r2021, r1FE2, 0x01));

                              ir_variable *const r2022 = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r2022, r1FE3, 0x01));

                              ir_variable *const r2023 = body.make_temp(glsl_type::uint_type, "zFrac2");
                              body.emit(assign(r2023, r1FE4, 0x01));

                              ir_variable *const r2024 = body.make_temp(glsl_type::bool_type, "execute_flag");
                              body.emit(assign(r2024, body.constant(true), 0x01));

                              ir_variable *const r2025 = body.make_temp(glsl_type::uvec2_type, "return_value");
                              ir_variable *const r2026 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                              body.emit(r2026);
                              ir_expression *const r2027 = expr(ir_unop_u2i, r1FE4);
                              body.emit(assign(r2026, less(r2027, body.constant(int(0))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2029 = lequal(body.constant(int(2045)), r1FE1);
                              ir_if *f2028 = new(mem_ctx) ir_if(operand(r2029).val);
                              exec_list *const f2028_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2028->then_instructions;

                                 ir_variable *const r202A = body.make_temp(glsl_type::bool_type, "or_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r202C = less(body.constant(int(2045)), r1FE1);
                                 ir_if *f202B = new(mem_ctx) ir_if(operand(r202C).val);
                                 exec_list *const f202B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f202B->then_instructions;

                                    body.emit(assign(r202A, body.constant(true), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f202B->else_instructions;

                                    ir_variable *const r202D = body.make_temp(glsl_type::bool_type, "and_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r202F = equal(r1FE1, body.constant(int(2045)));
                                    ir_if *f202E = new(mem_ctx) ir_if(operand(r202F).val);
                                    exec_list *const f202E_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f202E->then_instructions;

                                       ir_expression *const r2030 = equal(body.constant(2097151u), r1FE2);
                                       ir_expression *const r2031 = equal(body.constant(4294967295u), r1FE3);
                                       body.emit(assign(r202D, logic_and(r2030, r2031), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f202E->else_instructions;

                                       body.emit(assign(r202D, body.constant(false), 0x01));


                                    body.instructions = f202E_parent_instructions;
                                    body.emit(f202E);

                                    /* END IF */

                                    body.emit(assign(r202A, logic_and(r202D, r2026), 0x01));


                                 body.instructions = f202B_parent_instructions;
                                 body.emit(f202B);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_if *f2032 = new(mem_ctx) ir_if(operand(r202A).val);
                                 exec_list *const f2032_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2032->then_instructions;

                                    ir_variable *const r2033 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                    body.emit(r2033);
                                    ir_expression *const r2034 = lshift(r1CAB, body.constant(int(31)));
                                    body.emit(assign(r2033, add(r2034, body.constant(2146435072u)), 0x02));

                                    body.emit(assign(r2033, body.constant(0u), 0x01));

                                    body.emit(assign(r2025, r2033, 0x03));

                                    body.emit(assign(r2024, body.constant(false), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2032->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2036 = less(r1FE1, body.constant(int(0)));
                                    ir_if *f2035 = new(mem_ctx) ir_if(operand(r2036).val);
                                    exec_list *const f2035_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2035->then_instructions;

                                       ir_variable *const r2037 = body.make_temp(glsl_type::uint_type, "a2");
                                       body.emit(assign(r2037, r1FE4, 0x01));

                                       ir_variable *const r2038 = body.make_temp(glsl_type::int_type, "count");
                                       body.emit(assign(r2038, neg(r1FE1), 0x01));

                                       ir_variable *const r2039 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                       body.emit(r2039);
                                       ir_variable *const r203A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                       body.emit(r203A);
                                       ir_variable *const r203B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                       body.emit(r203B);
                                       ir_variable *const r203C = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                       ir_expression *const r203D = neg(r2038);
                                       body.emit(assign(r203C, bit_and(r203D, body.constant(int(31))), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r203F = equal(r2038, body.constant(int(0)));
                                       ir_if *f203E = new(mem_ctx) ir_if(operand(r203F).val);
                                       exec_list *const f203E_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f203E->then_instructions;

                                          body.emit(assign(r2039, r1FE4, 0x01));

                                          body.emit(assign(r203A, r1FE3, 0x01));

                                          body.emit(assign(r203B, r1FE2, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f203E->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r2041 = less(r2038, body.constant(int(32)));
                                          ir_if *f2040 = new(mem_ctx) ir_if(operand(r2041).val);
                                          exec_list *const f2040_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2040->then_instructions;

                                             body.emit(assign(r2039, lshift(r1FE3, r203C), 0x01));

                                             ir_expression *const r2042 = lshift(r1FE2, r203C);
                                             ir_expression *const r2043 = rshift(r1FE3, r2038);
                                             body.emit(assign(r203A, bit_or(r2042, r2043), 0x01));

                                             body.emit(assign(r203B, rshift(r1FE2, r2038), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2040->else_instructions;

                                             /* IF CONDITION */
                                             ir_expression *const r2045 = equal(r2038, body.constant(int(32)));
                                             ir_if *f2044 = new(mem_ctx) ir_if(operand(r2045).val);
                                             exec_list *const f2044_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2044->then_instructions;

                                                body.emit(assign(r2039, r1FE3, 0x01));

                                                body.emit(assign(r203A, r1FE2, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2044->else_instructions;

                                                body.emit(assign(r2037, bit_or(r1FE4, r1FE3), 0x01));

                                                /* IF CONDITION */
                                                ir_expression *const r2047 = less(r2038, body.constant(int(64)));
                                                ir_if *f2046 = new(mem_ctx) ir_if(operand(r2047).val);
                                                exec_list *const f2046_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f2046->then_instructions;

                                                   body.emit(assign(r2039, lshift(r1FE2, r203C), 0x01));

                                                   ir_expression *const r2048 = bit_and(r2038, body.constant(int(31)));
                                                   body.emit(assign(r203A, rshift(r1FE2, r2048), 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f2046->else_instructions;

                                                   ir_variable *const r2049 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                   /* IF CONDITION */
                                                   ir_expression *const r204B = equal(r2038, body.constant(int(64)));
                                                   ir_if *f204A = new(mem_ctx) ir_if(operand(r204B).val);
                                                   exec_list *const f204A_parent_instructions = body.instructions;

                                                      /* THEN INSTRUCTIONS */
                                                      body.instructions = &f204A->then_instructions;

                                                      body.emit(assign(r2049, r1FE2, 0x01));


                                                      /* ELSE INSTRUCTIONS */
                                                      body.instructions = &f204A->else_instructions;

                                                      ir_expression *const r204C = nequal(r1FE2, body.constant(0u));
                                                      ir_expression *const r204D = expr(ir_unop_b2i, r204C);
                                                      body.emit(assign(r2049, expr(ir_unop_i2u, r204D), 0x01));


                                                   body.instructions = f204A_parent_instructions;
                                                   body.emit(f204A);

                                                   /* END IF */

                                                   body.emit(assign(r2039, r2049, 0x01));

                                                   body.emit(assign(r203A, body.constant(0u), 0x01));


                                                body.instructions = f2046_parent_instructions;
                                                body.emit(f2046);

                                                /* END IF */


                                             body.instructions = f2044_parent_instructions;
                                             body.emit(f2044);

                                             /* END IF */

                                             body.emit(assign(r203B, body.constant(0u), 0x01));


                                          body.instructions = f2040_parent_instructions;
                                          body.emit(f2040);

                                          /* END IF */

                                          ir_expression *const r204E = nequal(r2037, body.constant(0u));
                                          ir_expression *const r204F = expr(ir_unop_b2i, r204E);
                                          ir_expression *const r2050 = expr(ir_unop_i2u, r204F);
                                          body.emit(assign(r2039, bit_or(r2039, r2050), 0x01));


                                       body.instructions = f203E_parent_instructions;
                                       body.emit(f203E);

                                       /* END IF */

                                       body.emit(assign(r2021, r203B, 0x01));

                                       body.emit(assign(r2022, r203A, 0x01));

                                       body.emit(assign(r2023, r2039, 0x01));

                                       body.emit(assign(r2020, body.constant(int(0)), 0x01));

                                       body.emit(assign(r2026, less(r2039, body.constant(0u)), 0x01));


                                    body.instructions = f2035_parent_instructions;
                                    body.emit(f2035);

                                    /* END IF */


                                 body.instructions = f2032_parent_instructions;
                                 body.emit(f2032);

                                 /* END IF */


                              body.instructions = f2028_parent_instructions;
                              body.emit(f2028);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f2051 = new(mem_ctx) ir_if(operand(r2024).val);
                              exec_list *const f2051_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2051->then_instructions;

                                 /* IF CONDITION */
                                 ir_if *f2052 = new(mem_ctx) ir_if(operand(r2026).val);
                                 exec_list *const f2052_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2052->then_instructions;

                                    ir_variable *const r2053 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                    body.emit(assign(r2053, add(r2022, body.constant(1u)), 0x01));

                                    ir_expression *const r2054 = less(r2053, r2022);
                                    ir_expression *const r2055 = expr(ir_unop_b2i, r2054);
                                    ir_expression *const r2056 = expr(ir_unop_i2u, r2055);
                                    body.emit(assign(r2021, add(r2021, r2056), 0x01));

                                    ir_expression *const r2057 = equal(r2023, body.constant(0u));
                                    ir_expression *const r2058 = expr(ir_unop_b2i, r2057);
                                    ir_expression *const r2059 = expr(ir_unop_i2u, r2058);
                                    ir_expression *const r205A = add(r2023, r2059);
                                    ir_expression *const r205B = bit_and(r205A, body.constant(1u));
                                    ir_expression *const r205C = expr(ir_unop_bit_not, r205B);
                                    body.emit(assign(r2022, bit_and(r2053, r205C), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2052->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r205E = bit_or(r2021, r2022);
                                    ir_expression *const r205F = equal(r205E, body.constant(0u));
                                    ir_if *f205D = new(mem_ctx) ir_if(operand(r205F).val);
                                    exec_list *const f205D_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f205D->then_instructions;

                                       body.emit(assign(r2020, body.constant(int(0)), 0x01));


                                    body.instructions = f205D_parent_instructions;
                                    body.emit(f205D);

                                    /* END IF */


                                 body.instructions = f2052_parent_instructions;
                                 body.emit(f2052);

                                 /* END IF */

                                 ir_variable *const r2060 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r2060);
                                 ir_expression *const r2061 = lshift(r1CAB, body.constant(int(31)));
                                 ir_expression *const r2062 = expr(ir_unop_i2u, r2020);
                                 ir_expression *const r2063 = lshift(r2062, body.constant(int(20)));
                                 ir_expression *const r2064 = add(r2061, r2063);
                                 body.emit(assign(r2060, add(r2064, r2021), 0x02));

                                 body.emit(assign(r2060, r2022, 0x01));

                                 body.emit(assign(r2025, r2060, 0x03));

                                 body.emit(assign(r2024, body.constant(false), 0x01));


                              body.instructions = f2051_parent_instructions;
                              body.emit(f2051);

                              /* END IF */

                              body.emit(assign(r1CAC, r2025, 0x03));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1FD9->else_instructions;

                              ir_variable *const r2065 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r2065);
                              body.emit(assign(r2065, body.constant(0u), 0x02));

                              body.emit(assign(r2065, body.constant(0u), 0x01));

                              body.emit(assign(r1CAC, r2065, 0x03));


                           body.instructions = f1FD9_parent_instructions;
                           body.emit(f1FD9);

                           /* END IF */


                        body.instructions = f1F4D_parent_instructions;
                        body.emit(f1F4D);

                        /* END IF */


                     body.instructions = f1EC1_parent_instructions;
                     body.emit(f1EC1);

                     /* END IF */


                  body.instructions = f1E35_parent_instructions;
                  body.emit(f1E35);

                  /* END IF */


               body.instructions = f1E20_parent_instructions;
               body.emit(f1E20);

               /* END IF */


            body.instructions = f1D71_parent_instructions;
            body.emit(f1D71);

            /* END IF */


         body.instructions = f1CC0_parent_instructions;
         body.emit(f1CC0);

         /* END IF */

         body.emit(assign(r1CA7, r1CAC, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1CA9->else_instructions;

         ir_variable *const r2066 = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r2066, body.constant(true), 0x01));

         ir_variable *const r2067 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r2068 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r2068);
         ir_variable *const r2069 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r2069);
         ir_variable *const r206A = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r206A);
         ir_variable *const r206B = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r206B);
         ir_variable *const r206C = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r206C);
         ir_variable *const r206D = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r206D);
         ir_variable *const r206E = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
         body.emit(r206E);
         ir_variable *const r206F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
         body.emit(r206F);
         body.emit(assign(r206F, body.constant(0u), 0x01));

         body.emit(assign(r206E, body.constant(0u), 0x01));

         ir_variable *const r2070 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r2070, swizzle_x(r1C72), 0x01));

         body.emit(assign(r206C, r2070, 0x01));

         ir_variable *const r2071 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r2071, bit_and(swizzle_y(r1C72), body.constant(1048575u)), 0x01));

         body.emit(assign(r206B, r2071, 0x01));

         ir_variable *const r2072 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r2072, body.constant(0u), 0x01));

         body.emit(assign(r206A, body.constant(0u), 0x01));

         body.emit(assign(r2069, body.constant(0u), 0x01));

         ir_variable *const r2073 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r2074 = rshift(swizzle_y(r1C72), body.constant(int(20)));
         ir_expression *const r2075 = bit_and(r2074, body.constant(2047u));
         body.emit(assign(r2073, expr(ir_unop_u2i, r2075), 0x01));

         ir_variable *const r2076 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         body.emit(assign(r2076, body.constant(int(1023)), 0x01));

         ir_variable *const r2077 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r2077, add(r2073, body.constant(int(-1023))), 0x01));

         body.emit(assign(r2068, r2077, 0x01));

         /* IF CONDITION */
         ir_expression *const r2079 = less(body.constant(int(0)), r2077);
         ir_if *f2078 = new(mem_ctx) ir_if(operand(r2079).val);
         exec_list *const f2078_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2078->then_instructions;

            /* IF CONDITION */
            ir_expression *const r207B = equal(r2073, body.constant(int(2047)));
            ir_if *f207A = new(mem_ctx) ir_if(operand(r207B).val);
            exec_list *const f207A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f207A->then_instructions;

               /* IF CONDITION */
               ir_expression *const r207D = bit_or(r2071, swizzle_x(r1C72));
               ir_expression *const r207E = nequal(r207D, body.constant(0u));
               ir_if *f207C = new(mem_ctx) ir_if(operand(r207E).val);
               exec_list *const f207C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f207C->then_instructions;

                  ir_variable *const r207F = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r207F, swizzle_x(r1C72), 0x01));

                  ir_variable *const r2080 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r2080, body.constant(0u), 0x01));

                  ir_variable *const r2081 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r207F, bit_or(swizzle_y(r1C72), body.constant(524288u)), 0x02));

                  body.emit(assign(r2080, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r2083 = lshift(swizzle_y(r1C72), body.constant(int(1)));
                  ir_expression *const r2084 = lequal(body.constant(4292870144u), r2083);
                  ir_expression *const r2085 = nequal(swizzle_x(r1C72), body.constant(0u));
                  ir_expression *const r2086 = bit_and(swizzle_y(r1C72), body.constant(1048575u));
                  ir_expression *const r2087 = nequal(r2086, body.constant(0u));
                  ir_expression *const r2088 = logic_or(r2085, r2087);
                  ir_expression *const r2089 = logic_and(r2084, r2088);
                  ir_if *f2082 = new(mem_ctx) ir_if(operand(r2089).val);
                  exec_list *const f2082_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2082->then_instructions;

                     body.emit(assign(r2081, r207F, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2082->else_instructions;

                     body.emit(assign(r2081, r2080, 0x03));


                  body.instructions = f2082_parent_instructions;
                  body.emit(f2082);

                  /* END IF */

                  body.emit(assign(r2067, r2081, 0x03));

                  body.emit(assign(r2066, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f207C->else_instructions;

                  body.emit(assign(r2067, r1C72, 0x03));

                  body.emit(assign(r2066, body.constant(false), 0x01));


               body.instructions = f207C_parent_instructions;
               body.emit(f207C);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f207A->else_instructions;

               body.emit(assign(r2069, body.constant(1048576u), 0x01));

               ir_variable *const r208A = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r208A, body.constant(0u), 0x01));

               ir_variable *const r208B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r208B);
               ir_variable *const r208C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r208C);
               ir_variable *const r208D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r208D);
               ir_variable *const r208E = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r208F = neg(r2077);
               body.emit(assign(r208E, bit_and(r208F, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2091 = equal(r2077, body.constant(int(0)));
               ir_if *f2090 = new(mem_ctx) ir_if(operand(r2091).val);
               exec_list *const f2090_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2090->then_instructions;

                  body.emit(assign(r208B, r208A, 0x01));

                  body.emit(assign(r208C, body.constant(0u), 0x01));

                  body.emit(assign(r208D, r2069, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2090->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2093 = less(r2077, body.constant(int(32)));
                  ir_if *f2092 = new(mem_ctx) ir_if(operand(r2093).val);
                  exec_list *const f2092_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2092->then_instructions;

                     body.emit(assign(r208B, body.constant(0u), 0x01));

                     ir_expression *const r2094 = lshift(body.constant(1048576u), r208E);
                     body.emit(assign(r208C, bit_or(r2094, body.constant(0u)), 0x01));

                     body.emit(assign(r208D, rshift(body.constant(1048576u), r2077), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2092->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2096 = equal(r2077, body.constant(int(32)));
                     ir_if *f2095 = new(mem_ctx) ir_if(operand(r2096).val);
                     exec_list *const f2095_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2095->then_instructions;

                        body.emit(assign(r208B, body.constant(0u), 0x01));

                        body.emit(assign(r208C, r2069, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2095->else_instructions;

                        body.emit(assign(r208A, body.constant(0u), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2098 = less(r2077, body.constant(int(64)));
                        ir_if *f2097 = new(mem_ctx) ir_if(operand(r2098).val);
                        exec_list *const f2097_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2097->then_instructions;

                           body.emit(assign(r208B, lshift(body.constant(1048576u), r208E), 0x01));

                           ir_expression *const r2099 = bit_and(r2077, body.constant(int(31)));
                           body.emit(assign(r208C, rshift(body.constant(1048576u), r2099), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2097->else_instructions;

                           ir_variable *const r209A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r209C = equal(r2077, body.constant(int(64)));
                           ir_if *f209B = new(mem_ctx) ir_if(operand(r209C).val);
                           exec_list *const f209B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f209B->then_instructions;

                              body.emit(assign(r209A, r2069, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f209B->else_instructions;

                              body.emit(assign(r209A, body.constant(1u), 0x01));


                           body.instructions = f209B_parent_instructions;
                           body.emit(f209B);

                           /* END IF */

                           body.emit(assign(r208B, r209A, 0x01));

                           body.emit(assign(r208C, body.constant(0u), 0x01));


                        body.instructions = f2097_parent_instructions;
                        body.emit(f2097);

                        /* END IF */


                     body.instructions = f2095_parent_instructions;
                     body.emit(f2095);

                     /* END IF */

                     body.emit(assign(r208D, body.constant(0u), 0x01));


                  body.instructions = f2092_parent_instructions;
                  body.emit(f2092);

                  /* END IF */

                  ir_expression *const r209D = nequal(r208A, body.constant(0u));
                  ir_expression *const r209E = expr(ir_unop_b2i, r209D);
                  ir_expression *const r209F = expr(ir_unop_i2u, r209E);
                  body.emit(assign(r208B, bit_or(r208B, r209F), 0x01));


               body.instructions = f2090_parent_instructions;
               body.emit(f2090);

               /* END IF */

               body.emit(assign(r2069, r208D, 0x01));

               body.emit(assign(r206A, r208C, 0x01));

               body.emit(assign(r206E, r208B, 0x01));

               body.emit(assign(r206D, r2073, 0x01));


            body.instructions = f207A_parent_instructions;
            body.emit(f207A);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2078->else_instructions;

            /* IF CONDITION */
            ir_expression *const r20A1 = less(r2077, body.constant(int(0)));
            ir_if *f20A0 = new(mem_ctx) ir_if(operand(r20A1).val);
            exec_list *const f20A0_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f20A0->then_instructions;

               /* IF CONDITION */
               ir_expression *const r20A3 = equal(r2073, body.constant(int(0)));
               ir_if *f20A2 = new(mem_ctx) ir_if(operand(r20A3).val);
               exec_list *const f20A2_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f20A2->then_instructions;

                  body.emit(assign(r2068, add(r2077, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f20A2->else_instructions;

                  body.emit(assign(r206B, bit_or(r2071, body.constant(1048576u)), 0x01));


               body.instructions = f20A2_parent_instructions;
               body.emit(f20A2);

               /* END IF */

               ir_variable *const r20A4 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r20A4, body.constant(0u), 0x01));

               ir_variable *const r20A5 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r20A5, neg(r2068), 0x01));

               ir_variable *const r20A6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r20A6);
               ir_variable *const r20A7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r20A7);
               ir_variable *const r20A8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r20A8);
               ir_variable *const r20A9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r20AA = neg(r20A5);
               body.emit(assign(r20A9, bit_and(r20AA, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r20AC = equal(r20A5, body.constant(int(0)));
               ir_if *f20AB = new(mem_ctx) ir_if(operand(r20AC).val);
               exec_list *const f20AB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f20AB->then_instructions;

                  body.emit(assign(r20A6, r20A4, 0x01));

                  body.emit(assign(r20A7, r2070, 0x01));

                  body.emit(assign(r20A8, r206B, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f20AB->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r20AE = less(r20A5, body.constant(int(32)));
                  ir_if *f20AD = new(mem_ctx) ir_if(operand(r20AE).val);
                  exec_list *const f20AD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f20AD->then_instructions;

                     body.emit(assign(r20A6, lshift(swizzle_x(r1C72), r20A9), 0x01));

                     ir_expression *const r20AF = lshift(r206B, r20A9);
                     ir_expression *const r20B0 = rshift(swizzle_x(r1C72), r20A5);
                     body.emit(assign(r20A7, bit_or(r20AF, r20B0), 0x01));

                     body.emit(assign(r20A8, rshift(r206B, r20A5), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f20AD->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r20B2 = equal(r20A5, body.constant(int(32)));
                     ir_if *f20B1 = new(mem_ctx) ir_if(operand(r20B2).val);
                     exec_list *const f20B1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f20B1->then_instructions;

                        body.emit(assign(r20A6, r2070, 0x01));

                        body.emit(assign(r20A7, r206B, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f20B1->else_instructions;

                        body.emit(assign(r20A4, bit_or(body.constant(0u), swizzle_x(r1C72)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r20B4 = less(r20A5, body.constant(int(64)));
                        ir_if *f20B3 = new(mem_ctx) ir_if(operand(r20B4).val);
                        exec_list *const f20B3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f20B3->then_instructions;

                           body.emit(assign(r20A6, lshift(r206B, r20A9), 0x01));

                           ir_expression *const r20B5 = bit_and(r20A5, body.constant(int(31)));
                           body.emit(assign(r20A7, rshift(r206B, r20B5), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f20B3->else_instructions;

                           ir_variable *const r20B6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r20B8 = equal(r20A5, body.constant(int(64)));
                           ir_if *f20B7 = new(mem_ctx) ir_if(operand(r20B8).val);
                           exec_list *const f20B7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f20B7->then_instructions;

                              body.emit(assign(r20B6, r206B, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f20B7->else_instructions;

                              ir_expression *const r20B9 = nequal(r206B, body.constant(0u));
                              ir_expression *const r20BA = expr(ir_unop_b2i, r20B9);
                              body.emit(assign(r20B6, expr(ir_unop_i2u, r20BA), 0x01));


                           body.instructions = f20B7_parent_instructions;
                           body.emit(f20B7);

                           /* END IF */

                           body.emit(assign(r20A6, r20B6, 0x01));

                           body.emit(assign(r20A7, body.constant(0u), 0x01));


                        body.instructions = f20B3_parent_instructions;
                        body.emit(f20B3);

                        /* END IF */


                     body.instructions = f20B1_parent_instructions;
                     body.emit(f20B1);

                     /* END IF */

                     body.emit(assign(r20A8, body.constant(0u), 0x01));


                  body.instructions = f20AD_parent_instructions;
                  body.emit(f20AD);

                  /* END IF */

                  ir_expression *const r20BB = nequal(r20A4, body.constant(0u));
                  ir_expression *const r20BC = expr(ir_unop_b2i, r20BB);
                  ir_expression *const r20BD = expr(ir_unop_i2u, r20BC);
                  body.emit(assign(r20A6, bit_or(r20A6, r20BD), 0x01));


               body.instructions = f20AB_parent_instructions;
               body.emit(f20AB);

               /* END IF */

               body.emit(assign(r206B, r20A8, 0x01));

               body.emit(assign(r206C, r20A7, 0x01));

               body.emit(assign(r206E, r20A6, 0x01));

               body.emit(assign(r206D, body.constant(int(1023)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f20A0->else_instructions;

               /* IF CONDITION */
               ir_expression *const r20BF = equal(r2073, body.constant(int(2047)));
               ir_if *f20BE = new(mem_ctx) ir_if(operand(r20BF).val);
               exec_list *const f20BE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f20BE->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r20C1 = bit_or(r206B, r206C);
                  ir_expression *const r20C2 = bit_or(r2069, r206A);
                  ir_expression *const r20C3 = bit_or(r20C1, r20C2);
                  ir_expression *const r20C4 = nequal(r20C3, body.constant(0u));
                  ir_if *f20C0 = new(mem_ctx) ir_if(operand(r20C4).val);
                  exec_list *const f20C0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f20C0->then_instructions;

                     ir_variable *const r20C5 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r20C5, swizzle_x(r1C72), 0x01));

                     ir_variable *const r20C6 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r20C6, body.constant(0u), 0x01));

                     ir_variable *const r20C7 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r20C5, bit_or(swizzle_y(r1C72), body.constant(524288u)), 0x02));

                     body.emit(assign(r20C6, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r20C9 = lshift(swizzle_y(r1C72), body.constant(int(1)));
                     ir_expression *const r20CA = lequal(body.constant(4292870144u), r20C9);
                     ir_expression *const r20CB = nequal(swizzle_x(r1C72), body.constant(0u));
                     ir_expression *const r20CC = bit_and(swizzle_y(r1C72), body.constant(1048575u));
                     ir_expression *const r20CD = nequal(r20CC, body.constant(0u));
                     ir_expression *const r20CE = logic_or(r20CB, r20CD);
                     ir_expression *const r20CF = logic_and(r20CA, r20CE);
                     ir_if *f20C8 = new(mem_ctx) ir_if(operand(r20CF).val);
                     exec_list *const f20C8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f20C8->then_instructions;

                        body.emit(assign(r20C7, r20C5, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f20C8->else_instructions;

                        body.emit(assign(r20C7, r20C6, 0x03));


                     body.instructions = f20C8_parent_instructions;
                     body.emit(f20C8);

                     /* END IF */

                     body.emit(assign(r2067, r20C7, 0x03));

                     body.emit(assign(r2066, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f20C0->else_instructions;

                     body.emit(assign(r2067, r1C72, 0x03));

                     body.emit(assign(r2066, body.constant(false), 0x01));


                  body.instructions = f20C0_parent_instructions;
                  body.emit(f20C0);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f20BE->else_instructions;

                  ir_variable *const r20D0 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r20D1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r20D1, add(r206C, r206A), 0x01));

                  ir_expression *const r20D2 = add(r206B, r2069);
                  ir_expression *const r20D3 = less(r20D1, r206C);
                  ir_expression *const r20D4 = expr(ir_unop_b2i, r20D3);
                  ir_expression *const r20D5 = expr(ir_unop_i2u, r20D4);
                  body.emit(assign(r20D0, add(r20D2, r20D5), 0x01));

                  body.emit(assign(r206F, r20D0, 0x01));

                  /* IF CONDITION */
                  ir_expression *const r20D7 = equal(r2073, body.constant(int(0)));
                  ir_if *f20D6 = new(mem_ctx) ir_if(operand(r20D7).val);
                  exec_list *const f20D6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f20D6->then_instructions;

                     ir_variable *const r20D8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r20D8);
                     ir_expression *const r20D9 = lshift(r1CA8, body.constant(int(31)));
                     body.emit(assign(r20D8, add(r20D9, r20D0), 0x02));

                     body.emit(assign(r20D8, r20D1, 0x01));

                     body.emit(assign(r2067, r20D8, 0x03));

                     body.emit(assign(r2066, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f20D6->else_instructions;

                     body.emit(assign(r206F, bit_or(r20D0, body.constant(2097152u)), 0x01));

                     body.emit(assign(r206D, r2073, 0x01));

                     ir_variable *const r20DA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r20DA);
                     ir_variable *const r20DB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r20DB);
                     ir_variable *const r20DC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r20DC);
                     body.emit(assign(r20DA, lshift(r20D1, body.constant(int(31))), 0x01));

                     ir_expression *const r20DD = lshift(r206F, body.constant(int(31)));
                     ir_expression *const r20DE = rshift(r20D1, body.constant(int(1)));
                     body.emit(assign(r20DB, bit_or(r20DD, r20DE), 0x01));

                     body.emit(assign(r20DC, rshift(r206F, body.constant(int(1))), 0x01));

                     body.emit(assign(r20DA, bit_or(r20DA, body.constant(0u)), 0x01));

                     body.emit(assign(r206F, r20DC, 0x01));

                     body.emit(assign(r206E, r20DA, 0x01));

                     ir_variable *const r20DF = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r20DF, r2073, 0x01));

                     ir_variable *const r20E0 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r20E0, r20DC, 0x01));

                     ir_variable *const r20E1 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r20E1, r20DB, 0x01));

                     ir_variable *const r20E2 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r20E2, r20DA, 0x01));

                     ir_variable *const r20E3 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r20E3, body.constant(true), 0x01));

                     ir_variable *const r20E4 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r20E5 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r20E5);
                     ir_expression *const r20E6 = expr(ir_unop_u2i, r20DA);
                     body.emit(assign(r20E5, less(r20E6, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r20E8 = lequal(body.constant(int(2045)), r2073);
                     ir_if *f20E7 = new(mem_ctx) ir_if(operand(r20E8).val);
                     exec_list *const f20E7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f20E7->then_instructions;

                        ir_variable *const r20E9 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r20EB = less(body.constant(int(2045)), r2073);
                        ir_if *f20EA = new(mem_ctx) ir_if(operand(r20EB).val);
                        exec_list *const f20EA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f20EA->then_instructions;

                           body.emit(assign(r20E9, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f20EA->else_instructions;

                           ir_variable *const r20EC = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r20EE = equal(r2073, body.constant(int(2045)));
                           ir_if *f20ED = new(mem_ctx) ir_if(operand(r20EE).val);
                           exec_list *const f20ED_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f20ED->then_instructions;

                              ir_expression *const r20EF = equal(body.constant(2097151u), r20DC);
                              ir_expression *const r20F0 = equal(body.constant(4294967295u), r20DB);
                              body.emit(assign(r20EC, logic_and(r20EF, r20F0), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f20ED->else_instructions;

                              body.emit(assign(r20EC, body.constant(false), 0x01));


                           body.instructions = f20ED_parent_instructions;
                           body.emit(f20ED);

                           /* END IF */

                           body.emit(assign(r20E9, logic_and(r20EC, r20E5), 0x01));


                        body.instructions = f20EA_parent_instructions;
                        body.emit(f20EA);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f20F1 = new(mem_ctx) ir_if(operand(r20E9).val);
                        exec_list *const f20F1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f20F1->then_instructions;

                           ir_variable *const r20F2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r20F2);
                           ir_expression *const r20F3 = lshift(r1CA8, body.constant(int(31)));
                           body.emit(assign(r20F2, add(r20F3, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r20F2, body.constant(0u), 0x01));

                           body.emit(assign(r20E4, r20F2, 0x03));

                           body.emit(assign(r20E3, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f20F1->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r20F5 = less(r2073, body.constant(int(0)));
                           ir_if *f20F4 = new(mem_ctx) ir_if(operand(r20F5).val);
                           exec_list *const f20F4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f20F4->then_instructions;

                              ir_variable *const r20F6 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r20F6, r20DA, 0x01));

                              ir_variable *const r20F7 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r20F7, neg(r2073), 0x01));

                              ir_variable *const r20F8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r20F8);
                              ir_variable *const r20F9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r20F9);
                              ir_variable *const r20FA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r20FA);
                              ir_variable *const r20FB = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r20FC = neg(r20F7);
                              body.emit(assign(r20FB, bit_and(r20FC, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r20FE = equal(r20F7, body.constant(int(0)));
                              ir_if *f20FD = new(mem_ctx) ir_if(operand(r20FE).val);
                              exec_list *const f20FD_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f20FD->then_instructions;

                                 body.emit(assign(r20F8, r20DA, 0x01));

                                 body.emit(assign(r20F9, r20DB, 0x01));

                                 body.emit(assign(r20FA, r20DC, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f20FD->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2100 = less(r20F7, body.constant(int(32)));
                                 ir_if *f20FF = new(mem_ctx) ir_if(operand(r2100).val);
                                 exec_list *const f20FF_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f20FF->then_instructions;

                                    body.emit(assign(r20F8, lshift(r20DB, r20FB), 0x01));

                                    ir_expression *const r2101 = lshift(r20DC, r20FB);
                                    ir_expression *const r2102 = rshift(r20DB, r20F7);
                                    body.emit(assign(r20F9, bit_or(r2101, r2102), 0x01));

                                    body.emit(assign(r20FA, rshift(r20DC, r20F7), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f20FF->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2104 = equal(r20F7, body.constant(int(32)));
                                    ir_if *f2103 = new(mem_ctx) ir_if(operand(r2104).val);
                                    exec_list *const f2103_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2103->then_instructions;

                                       body.emit(assign(r20F8, r20DB, 0x01));

                                       body.emit(assign(r20F9, r20DC, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2103->else_instructions;

                                       body.emit(assign(r20F6, bit_or(r20DA, r20DB), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2106 = less(r20F7, body.constant(int(64)));
                                       ir_if *f2105 = new(mem_ctx) ir_if(operand(r2106).val);
                                       exec_list *const f2105_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2105->then_instructions;

                                          body.emit(assign(r20F8, lshift(r20DC, r20FB), 0x01));

                                          ir_expression *const r2107 = bit_and(r20F7, body.constant(int(31)));
                                          body.emit(assign(r20F9, rshift(r20DC, r2107), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2105->else_instructions;

                                          ir_variable *const r2108 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r210A = equal(r20F7, body.constant(int(64)));
                                          ir_if *f2109 = new(mem_ctx) ir_if(operand(r210A).val);
                                          exec_list *const f2109_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2109->then_instructions;

                                             body.emit(assign(r2108, r20DC, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2109->else_instructions;

                                             ir_expression *const r210B = nequal(r20DC, body.constant(0u));
                                             ir_expression *const r210C = expr(ir_unop_b2i, r210B);
                                             body.emit(assign(r2108, expr(ir_unop_i2u, r210C), 0x01));


                                          body.instructions = f2109_parent_instructions;
                                          body.emit(f2109);

                                          /* END IF */

                                          body.emit(assign(r20F8, r2108, 0x01));

                                          body.emit(assign(r20F9, body.constant(0u), 0x01));


                                       body.instructions = f2105_parent_instructions;
                                       body.emit(f2105);

                                       /* END IF */


                                    body.instructions = f2103_parent_instructions;
                                    body.emit(f2103);

                                    /* END IF */

                                    body.emit(assign(r20FA, body.constant(0u), 0x01));


                                 body.instructions = f20FF_parent_instructions;
                                 body.emit(f20FF);

                                 /* END IF */

                                 ir_expression *const r210D = nequal(r20F6, body.constant(0u));
                                 ir_expression *const r210E = expr(ir_unop_b2i, r210D);
                                 ir_expression *const r210F = expr(ir_unop_i2u, r210E);
                                 body.emit(assign(r20F8, bit_or(r20F8, r210F), 0x01));


                              body.instructions = f20FD_parent_instructions;
                              body.emit(f20FD);

                              /* END IF */

                              body.emit(assign(r20E0, r20FA, 0x01));

                              body.emit(assign(r20E1, r20F9, 0x01));

                              body.emit(assign(r20E2, r20F8, 0x01));

                              body.emit(assign(r20DF, body.constant(int(0)), 0x01));

                              body.emit(assign(r20E5, less(r20F8, body.constant(0u)), 0x01));


                           body.instructions = f20F4_parent_instructions;
                           body.emit(f20F4);

                           /* END IF */


                        body.instructions = f20F1_parent_instructions;
                        body.emit(f20F1);

                        /* END IF */


                     body.instructions = f20E7_parent_instructions;
                     body.emit(f20E7);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f2110 = new(mem_ctx) ir_if(operand(r20E3).val);
                     exec_list *const f2110_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2110->then_instructions;

                        /* IF CONDITION */
                        ir_if *f2111 = new(mem_ctx) ir_if(operand(r20E5).val);
                        exec_list *const f2111_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2111->then_instructions;

                           ir_variable *const r2112 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r2112, add(r20E1, body.constant(1u)), 0x01));

                           ir_expression *const r2113 = less(r2112, r20E1);
                           ir_expression *const r2114 = expr(ir_unop_b2i, r2113);
                           ir_expression *const r2115 = expr(ir_unop_i2u, r2114);
                           body.emit(assign(r20E0, add(r20E0, r2115), 0x01));

                           ir_expression *const r2116 = equal(r20E2, body.constant(0u));
                           ir_expression *const r2117 = expr(ir_unop_b2i, r2116);
                           ir_expression *const r2118 = expr(ir_unop_i2u, r2117);
                           ir_expression *const r2119 = add(r20E2, r2118);
                           ir_expression *const r211A = bit_and(r2119, body.constant(1u));
                           ir_expression *const r211B = expr(ir_unop_bit_not, r211A);
                           body.emit(assign(r20E1, bit_and(r2112, r211B), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2111->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r211D = bit_or(r20E0, r20E1);
                           ir_expression *const r211E = equal(r211D, body.constant(0u));
                           ir_if *f211C = new(mem_ctx) ir_if(operand(r211E).val);
                           exec_list *const f211C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f211C->then_instructions;

                              body.emit(assign(r20DF, body.constant(int(0)), 0x01));


                           body.instructions = f211C_parent_instructions;
                           body.emit(f211C);

                           /* END IF */


                        body.instructions = f2111_parent_instructions;
                        body.emit(f2111);

                        /* END IF */

                        ir_variable *const r211F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r211F);
                        ir_expression *const r2120 = lshift(r1CA8, body.constant(int(31)));
                        ir_expression *const r2121 = expr(ir_unop_i2u, r20DF);
                        ir_expression *const r2122 = lshift(r2121, body.constant(int(20)));
                        ir_expression *const r2123 = add(r2120, r2122);
                        body.emit(assign(r211F, add(r2123, r20E0), 0x02));

                        body.emit(assign(r211F, r20E1, 0x01));

                        body.emit(assign(r20E4, r211F, 0x03));

                        body.emit(assign(r20E3, body.constant(false), 0x01));


                     body.instructions = f2110_parent_instructions;
                     body.emit(f2110);

                     /* END IF */

                     body.emit(assign(r2067, r20E4, 0x03));

                     body.emit(assign(r2066, body.constant(false), 0x01));


                  body.instructions = f20D6_parent_instructions;
                  body.emit(f20D6);

                  /* END IF */


               body.instructions = f20BE_parent_instructions;
               body.emit(f20BE);

               /* END IF */


            body.instructions = f20A0_parent_instructions;
            body.emit(f20A0);

            /* END IF */


         body.instructions = f2078_parent_instructions;
         body.emit(f2078);

         /* END IF */

         /* IF CONDITION */
         ir_if *f2124 = new(mem_ctx) ir_if(operand(r2066).val);
         exec_list *const f2124_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2124->then_instructions;

            body.emit(assign(r206B, bit_or(r206B, body.constant(1048576u)), 0x01));

            ir_variable *const r2125 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r2126 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r2126, add(r206C, r206A), 0x01));

            ir_expression *const r2127 = add(r206B, r2069);
            ir_expression *const r2128 = less(r2126, r206C);
            ir_expression *const r2129 = expr(ir_unop_b2i, r2128);
            ir_expression *const r212A = expr(ir_unop_i2u, r2129);
            body.emit(assign(r2125, add(r2127, r212A), 0x01));

            body.emit(assign(r206F, r2125, 0x01));

            body.emit(assign(r206D, add(r206D, body.constant(int(-1))), 0x01));

            /* IF CONDITION */
            ir_expression *const r212C = less(r2125, body.constant(2097152u));
            ir_if *f212B = new(mem_ctx) ir_if(operand(r212C).val);
            exec_list *const f212B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f212B->then_instructions;

               ir_variable *const r212D = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r212D, r206D, 0x01));

               ir_variable *const r212E = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r212E, r2125, 0x01));

               ir_variable *const r212F = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r212F, r2126, 0x01));

               ir_variable *const r2130 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r2130, r206E, 0x01));

               ir_variable *const r2131 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r2131, body.constant(true), 0x01));

               ir_variable *const r2132 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2133 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2133);
               ir_expression *const r2134 = expr(ir_unop_u2i, r206E);
               body.emit(assign(r2133, less(r2134, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2136 = lequal(body.constant(int(2045)), r206D);
               ir_if *f2135 = new(mem_ctx) ir_if(operand(r2136).val);
               exec_list *const f2135_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2135->then_instructions;

                  ir_variable *const r2137 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2139 = less(body.constant(int(2045)), r206D);
                  ir_if *f2138 = new(mem_ctx) ir_if(operand(r2139).val);
                  exec_list *const f2138_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2138->then_instructions;

                     body.emit(assign(r2137, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2138->else_instructions;

                     ir_variable *const r213A = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r213C = equal(r206D, body.constant(int(2045)));
                     ir_if *f213B = new(mem_ctx) ir_if(operand(r213C).val);
                     exec_list *const f213B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f213B->then_instructions;

                        ir_expression *const r213D = equal(body.constant(2097151u), r2125);
                        ir_expression *const r213E = equal(body.constant(4294967295u), r2126);
                        body.emit(assign(r213A, logic_and(r213D, r213E), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f213B->else_instructions;

                        body.emit(assign(r213A, body.constant(false), 0x01));


                     body.instructions = f213B_parent_instructions;
                     body.emit(f213B);

                     /* END IF */

                     body.emit(assign(r2137, logic_and(r213A, r2133), 0x01));


                  body.instructions = f2138_parent_instructions;
                  body.emit(f2138);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f213F = new(mem_ctx) ir_if(operand(r2137).val);
                  exec_list *const f213F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f213F->then_instructions;

                     ir_variable *const r2140 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2140);
                     ir_expression *const r2141 = lshift(r1CA8, body.constant(int(31)));
                     body.emit(assign(r2140, add(r2141, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r2140, body.constant(0u), 0x01));

                     body.emit(assign(r2132, r2140, 0x03));

                     body.emit(assign(r2131, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f213F->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2143 = less(r206D, body.constant(int(0)));
                     ir_if *f2142 = new(mem_ctx) ir_if(operand(r2143).val);
                     exec_list *const f2142_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2142->then_instructions;

                        ir_variable *const r2144 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2144, r206E, 0x01));

                        ir_variable *const r2145 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2145, neg(r206D), 0x01));

                        ir_variable *const r2146 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2146);
                        ir_variable *const r2147 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2147);
                        ir_variable *const r2148 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2148);
                        ir_variable *const r2149 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r214A = neg(r2145);
                        body.emit(assign(r2149, bit_and(r214A, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r214C = equal(r2145, body.constant(int(0)));
                        ir_if *f214B = new(mem_ctx) ir_if(operand(r214C).val);
                        exec_list *const f214B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f214B->then_instructions;

                           body.emit(assign(r2146, r206E, 0x01));

                           body.emit(assign(r2147, r2126, 0x01));

                           body.emit(assign(r2148, r2125, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f214B->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r214E = less(r2145, body.constant(int(32)));
                           ir_if *f214D = new(mem_ctx) ir_if(operand(r214E).val);
                           exec_list *const f214D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f214D->then_instructions;

                              body.emit(assign(r2146, lshift(r2126, r2149), 0x01));

                              ir_expression *const r214F = lshift(r2125, r2149);
                              ir_expression *const r2150 = rshift(r2126, r2145);
                              body.emit(assign(r2147, bit_or(r214F, r2150), 0x01));

                              body.emit(assign(r2148, rshift(r2125, r2145), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f214D->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2152 = equal(r2145, body.constant(int(32)));
                              ir_if *f2151 = new(mem_ctx) ir_if(operand(r2152).val);
                              exec_list *const f2151_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2151->then_instructions;

                                 body.emit(assign(r2146, r2126, 0x01));

                                 body.emit(assign(r2147, r2125, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2151->else_instructions;

                                 body.emit(assign(r2144, bit_or(r206E, r2126), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2154 = less(r2145, body.constant(int(64)));
                                 ir_if *f2153 = new(mem_ctx) ir_if(operand(r2154).val);
                                 exec_list *const f2153_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2153->then_instructions;

                                    body.emit(assign(r2146, lshift(r2125, r2149), 0x01));

                                    ir_expression *const r2155 = bit_and(r2145, body.constant(int(31)));
                                    body.emit(assign(r2147, rshift(r2125, r2155), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2153->else_instructions;

                                    ir_variable *const r2156 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2158 = equal(r2145, body.constant(int(64)));
                                    ir_if *f2157 = new(mem_ctx) ir_if(operand(r2158).val);
                                    exec_list *const f2157_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2157->then_instructions;

                                       body.emit(assign(r2156, r2125, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2157->else_instructions;

                                       ir_expression *const r2159 = nequal(r2125, body.constant(0u));
                                       ir_expression *const r215A = expr(ir_unop_b2i, r2159);
                                       body.emit(assign(r2156, expr(ir_unop_i2u, r215A), 0x01));


                                    body.instructions = f2157_parent_instructions;
                                    body.emit(f2157);

                                    /* END IF */

                                    body.emit(assign(r2146, r2156, 0x01));

                                    body.emit(assign(r2147, body.constant(0u), 0x01));


                                 body.instructions = f2153_parent_instructions;
                                 body.emit(f2153);

                                 /* END IF */


                              body.instructions = f2151_parent_instructions;
                              body.emit(f2151);

                              /* END IF */

                              body.emit(assign(r2148, body.constant(0u), 0x01));


                           body.instructions = f214D_parent_instructions;
                           body.emit(f214D);

                           /* END IF */

                           ir_expression *const r215B = nequal(r2144, body.constant(0u));
                           ir_expression *const r215C = expr(ir_unop_b2i, r215B);
                           ir_expression *const r215D = expr(ir_unop_i2u, r215C);
                           body.emit(assign(r2146, bit_or(r2146, r215D), 0x01));


                        body.instructions = f214B_parent_instructions;
                        body.emit(f214B);

                        /* END IF */

                        body.emit(assign(r212E, r2148, 0x01));

                        body.emit(assign(r212F, r2147, 0x01));

                        body.emit(assign(r2130, r2146, 0x01));

                        body.emit(assign(r212D, body.constant(int(0)), 0x01));

                        body.emit(assign(r2133, less(r2146, body.constant(0u)), 0x01));


                     body.instructions = f2142_parent_instructions;
                     body.emit(f2142);

                     /* END IF */


                  body.instructions = f213F_parent_instructions;
                  body.emit(f213F);

                  /* END IF */


               body.instructions = f2135_parent_instructions;
               body.emit(f2135);

               /* END IF */

               /* IF CONDITION */
               ir_if *f215E = new(mem_ctx) ir_if(operand(r2131).val);
               exec_list *const f215E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f215E->then_instructions;

                  /* IF CONDITION */
                  ir_if *f215F = new(mem_ctx) ir_if(operand(r2133).val);
                  exec_list *const f215F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f215F->then_instructions;

                     ir_variable *const r2160 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r2160, add(r212F, body.constant(1u)), 0x01));

                     ir_expression *const r2161 = less(r2160, r212F);
                     ir_expression *const r2162 = expr(ir_unop_b2i, r2161);
                     ir_expression *const r2163 = expr(ir_unop_i2u, r2162);
                     body.emit(assign(r212E, add(r212E, r2163), 0x01));

                     ir_expression *const r2164 = equal(r2130, body.constant(0u));
                     ir_expression *const r2165 = expr(ir_unop_b2i, r2164);
                     ir_expression *const r2166 = expr(ir_unop_i2u, r2165);
                     ir_expression *const r2167 = add(r2130, r2166);
                     ir_expression *const r2168 = bit_and(r2167, body.constant(1u));
                     ir_expression *const r2169 = expr(ir_unop_bit_not, r2168);
                     body.emit(assign(r212F, bit_and(r2160, r2169), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f215F->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r216B = bit_or(r212E, r212F);
                     ir_expression *const r216C = equal(r216B, body.constant(0u));
                     ir_if *f216A = new(mem_ctx) ir_if(operand(r216C).val);
                     exec_list *const f216A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f216A->then_instructions;

                        body.emit(assign(r212D, body.constant(int(0)), 0x01));


                     body.instructions = f216A_parent_instructions;
                     body.emit(f216A);

                     /* END IF */


                  body.instructions = f215F_parent_instructions;
                  body.emit(f215F);

                  /* END IF */

                  ir_variable *const r216D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r216D);
                  ir_expression *const r216E = lshift(r1CA8, body.constant(int(31)));
                  ir_expression *const r216F = expr(ir_unop_i2u, r212D);
                  ir_expression *const r2170 = lshift(r216F, body.constant(int(20)));
                  ir_expression *const r2171 = add(r216E, r2170);
                  body.emit(assign(r216D, add(r2171, r212E), 0x02));

                  body.emit(assign(r216D, r212F, 0x01));

                  body.emit(assign(r2132, r216D, 0x03));

                  body.emit(assign(r2131, body.constant(false), 0x01));


               body.instructions = f215E_parent_instructions;
               body.emit(f215E);

               /* END IF */

               body.emit(assign(r2067, r2132, 0x03));

               body.emit(assign(r2066, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f212B->else_instructions;

               body.emit(assign(r206D, add(r206D, body.constant(int(1))), 0x01));

               ir_variable *const r2172 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r2172);
               ir_variable *const r2173 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2173);
               ir_variable *const r2174 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2174);
               body.emit(assign(r2172, lshift(r2126, body.constant(int(31))), 0x01));

               ir_expression *const r2175 = lshift(r2125, body.constant(int(31)));
               ir_expression *const r2176 = rshift(r2126, body.constant(int(1)));
               body.emit(assign(r2173, bit_or(r2175, r2176), 0x01));

               body.emit(assign(r2174, rshift(r2125, body.constant(int(1))), 0x01));

               ir_expression *const r2177 = nequal(r206E, body.constant(0u));
               ir_expression *const r2178 = expr(ir_unop_b2i, r2177);
               ir_expression *const r2179 = expr(ir_unop_i2u, r2178);
               body.emit(assign(r2172, bit_or(r2172, r2179), 0x01));

               body.emit(assign(r206F, r2174, 0x01));

               body.emit(assign(r206E, r2172, 0x01));

               ir_variable *const r217A = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r217A, r206D, 0x01));

               ir_variable *const r217B = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r217B, r2174, 0x01));

               ir_variable *const r217C = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r217C, r2173, 0x01));

               ir_variable *const r217D = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r217D, r2172, 0x01));

               ir_variable *const r217E = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r217E, body.constant(true), 0x01));

               ir_variable *const r217F = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2180 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2180);
               ir_expression *const r2181 = expr(ir_unop_u2i, r2172);
               body.emit(assign(r2180, less(r2181, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2183 = lequal(body.constant(int(2045)), r206D);
               ir_if *f2182 = new(mem_ctx) ir_if(operand(r2183).val);
               exec_list *const f2182_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2182->then_instructions;

                  ir_variable *const r2184 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2186 = less(body.constant(int(2045)), r206D);
                  ir_if *f2185 = new(mem_ctx) ir_if(operand(r2186).val);
                  exec_list *const f2185_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2185->then_instructions;

                     body.emit(assign(r2184, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2185->else_instructions;

                     ir_variable *const r2187 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2189 = equal(r206D, body.constant(int(2045)));
                     ir_if *f2188 = new(mem_ctx) ir_if(operand(r2189).val);
                     exec_list *const f2188_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2188->then_instructions;

                        ir_expression *const r218A = equal(body.constant(2097151u), r2174);
                        ir_expression *const r218B = equal(body.constant(4294967295u), r2173);
                        body.emit(assign(r2187, logic_and(r218A, r218B), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2188->else_instructions;

                        body.emit(assign(r2187, body.constant(false), 0x01));


                     body.instructions = f2188_parent_instructions;
                     body.emit(f2188);

                     /* END IF */

                     body.emit(assign(r2184, logic_and(r2187, r2180), 0x01));


                  body.instructions = f2185_parent_instructions;
                  body.emit(f2185);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f218C = new(mem_ctx) ir_if(operand(r2184).val);
                  exec_list *const f218C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f218C->then_instructions;

                     ir_variable *const r218D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r218D);
                     ir_expression *const r218E = lshift(r1CA8, body.constant(int(31)));
                     body.emit(assign(r218D, add(r218E, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r218D, body.constant(0u), 0x01));

                     body.emit(assign(r217F, r218D, 0x03));

                     body.emit(assign(r217E, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f218C->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2190 = less(r206D, body.constant(int(0)));
                     ir_if *f218F = new(mem_ctx) ir_if(operand(r2190).val);
                     exec_list *const f218F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f218F->then_instructions;

                        ir_variable *const r2191 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2191, r2172, 0x01));

                        ir_variable *const r2192 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2192, neg(r206D), 0x01));

                        ir_variable *const r2193 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2193);
                        ir_variable *const r2194 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2194);
                        ir_variable *const r2195 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2195);
                        ir_variable *const r2196 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2197 = neg(r2192);
                        body.emit(assign(r2196, bit_and(r2197, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2199 = equal(r2192, body.constant(int(0)));
                        ir_if *f2198 = new(mem_ctx) ir_if(operand(r2199).val);
                        exec_list *const f2198_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2198->then_instructions;

                           body.emit(assign(r2193, r2172, 0x01));

                           body.emit(assign(r2194, r2173, 0x01));

                           body.emit(assign(r2195, r2174, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2198->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r219B = less(r2192, body.constant(int(32)));
                           ir_if *f219A = new(mem_ctx) ir_if(operand(r219B).val);
                           exec_list *const f219A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f219A->then_instructions;

                              body.emit(assign(r2193, lshift(r2173, r2196), 0x01));

                              ir_expression *const r219C = lshift(r2174, r2196);
                              ir_expression *const r219D = rshift(r2173, r2192);
                              body.emit(assign(r2194, bit_or(r219C, r219D), 0x01));

                              body.emit(assign(r2195, rshift(r2174, r2192), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f219A->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r219F = equal(r2192, body.constant(int(32)));
                              ir_if *f219E = new(mem_ctx) ir_if(operand(r219F).val);
                              exec_list *const f219E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f219E->then_instructions;

                                 body.emit(assign(r2193, r2173, 0x01));

                                 body.emit(assign(r2194, r2174, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f219E->else_instructions;

                                 body.emit(assign(r2191, bit_or(r2172, r2173), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r21A1 = less(r2192, body.constant(int(64)));
                                 ir_if *f21A0 = new(mem_ctx) ir_if(operand(r21A1).val);
                                 exec_list *const f21A0_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f21A0->then_instructions;

                                    body.emit(assign(r2193, lshift(r2174, r2196), 0x01));

                                    ir_expression *const r21A2 = bit_and(r2192, body.constant(int(31)));
                                    body.emit(assign(r2194, rshift(r2174, r21A2), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f21A0->else_instructions;

                                    ir_variable *const r21A3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r21A5 = equal(r2192, body.constant(int(64)));
                                    ir_if *f21A4 = new(mem_ctx) ir_if(operand(r21A5).val);
                                    exec_list *const f21A4_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f21A4->then_instructions;

                                       body.emit(assign(r21A3, r2174, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f21A4->else_instructions;

                                       ir_expression *const r21A6 = nequal(r2174, body.constant(0u));
                                       ir_expression *const r21A7 = expr(ir_unop_b2i, r21A6);
                                       body.emit(assign(r21A3, expr(ir_unop_i2u, r21A7), 0x01));


                                    body.instructions = f21A4_parent_instructions;
                                    body.emit(f21A4);

                                    /* END IF */

                                    body.emit(assign(r2193, r21A3, 0x01));

                                    body.emit(assign(r2194, body.constant(0u), 0x01));


                                 body.instructions = f21A0_parent_instructions;
                                 body.emit(f21A0);

                                 /* END IF */


                              body.instructions = f219E_parent_instructions;
                              body.emit(f219E);

                              /* END IF */

                              body.emit(assign(r2195, body.constant(0u), 0x01));


                           body.instructions = f219A_parent_instructions;
                           body.emit(f219A);

                           /* END IF */

                           ir_expression *const r21A8 = nequal(r2191, body.constant(0u));
                           ir_expression *const r21A9 = expr(ir_unop_b2i, r21A8);
                           ir_expression *const r21AA = expr(ir_unop_i2u, r21A9);
                           body.emit(assign(r2193, bit_or(r2193, r21AA), 0x01));


                        body.instructions = f2198_parent_instructions;
                        body.emit(f2198);

                        /* END IF */

                        body.emit(assign(r217B, r2195, 0x01));

                        body.emit(assign(r217C, r2194, 0x01));

                        body.emit(assign(r217D, r2193, 0x01));

                        body.emit(assign(r217A, body.constant(int(0)), 0x01));

                        body.emit(assign(r2180, less(r2193, body.constant(0u)), 0x01));


                     body.instructions = f218F_parent_instructions;
                     body.emit(f218F);

                     /* END IF */


                  body.instructions = f218C_parent_instructions;
                  body.emit(f218C);

                  /* END IF */


               body.instructions = f2182_parent_instructions;
               body.emit(f2182);

               /* END IF */

               /* IF CONDITION */
               ir_if *f21AB = new(mem_ctx) ir_if(operand(r217E).val);
               exec_list *const f21AB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f21AB->then_instructions;

                  /* IF CONDITION */
                  ir_if *f21AC = new(mem_ctx) ir_if(operand(r2180).val);
                  exec_list *const f21AC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f21AC->then_instructions;

                     ir_variable *const r21AD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r21AD, add(r217C, body.constant(1u)), 0x01));

                     ir_expression *const r21AE = less(r21AD, r217C);
                     ir_expression *const r21AF = expr(ir_unop_b2i, r21AE);
                     ir_expression *const r21B0 = expr(ir_unop_i2u, r21AF);
                     body.emit(assign(r217B, add(r217B, r21B0), 0x01));

                     ir_expression *const r21B1 = equal(r217D, body.constant(0u));
                     ir_expression *const r21B2 = expr(ir_unop_b2i, r21B1);
                     ir_expression *const r21B3 = expr(ir_unop_i2u, r21B2);
                     ir_expression *const r21B4 = add(r217D, r21B3);
                     ir_expression *const r21B5 = bit_and(r21B4, body.constant(1u));
                     ir_expression *const r21B6 = expr(ir_unop_bit_not, r21B5);
                     body.emit(assign(r217C, bit_and(r21AD, r21B6), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f21AC->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r21B8 = bit_or(r217B, r217C);
                     ir_expression *const r21B9 = equal(r21B8, body.constant(0u));
                     ir_if *f21B7 = new(mem_ctx) ir_if(operand(r21B9).val);
                     exec_list *const f21B7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f21B7->then_instructions;

                        body.emit(assign(r217A, body.constant(int(0)), 0x01));


                     body.instructions = f21B7_parent_instructions;
                     body.emit(f21B7);

                     /* END IF */


                  body.instructions = f21AC_parent_instructions;
                  body.emit(f21AC);

                  /* END IF */

                  ir_variable *const r21BA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r21BA);
                  ir_expression *const r21BB = lshift(r1CA8, body.constant(int(31)));
                  ir_expression *const r21BC = expr(ir_unop_i2u, r217A);
                  ir_expression *const r21BD = lshift(r21BC, body.constant(int(20)));
                  ir_expression *const r21BE = add(r21BB, r21BD);
                  body.emit(assign(r21BA, add(r21BE, r217B), 0x02));

                  body.emit(assign(r21BA, r217C, 0x01));

                  body.emit(assign(r217F, r21BA, 0x03));

                  body.emit(assign(r217E, body.constant(false), 0x01));


               body.instructions = f21AB_parent_instructions;
               body.emit(f21AB);

               /* END IF */

               body.emit(assign(r2067, r217F, 0x03));

               body.emit(assign(r2066, body.constant(false), 0x01));


            body.instructions = f212B_parent_instructions;
            body.emit(f212B);

            /* END IF */


         body.instructions = f2124_parent_instructions;
         body.emit(f2124);

         /* END IF */

         body.emit(assign(r1CA7, r2067, 0x03));


      body.instructions = f1CA9_parent_instructions;
      body.emit(f1CA9);

      /* END IF */

      body.emit(assign(r1CA5, r1CA7, 0x03));


   body.instructions = f1CA6_parent_instructions;
   body.emit(f1CA6);

   /* END IF */

   body.emit(ret(r1CA5));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fceil64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r21BF = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r21BF);
   ir_variable *const r21C0 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r21C1 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r21C2 = rshift(swizzle_y(r21BF), body.constant(int(20)));
   ir_expression *const r21C3 = bit_and(r21C2, body.constant(2047u));
   ir_expression *const r21C4 = expr(ir_unop_u2i, r21C3);
   body.emit(assign(r21C1, add(r21C4, body.constant(int(-1023))), 0x01));

   /* IF CONDITION */
   ir_expression *const r21C6 = less(r21C1, body.constant(int(0)));
   ir_if *f21C5 = new(mem_ctx) ir_if(operand(r21C6).val);
   exec_list *const f21C5_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f21C5->then_instructions;

      body.emit(assign(r21C0, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f21C5->else_instructions;

      /* IF CONDITION */
      ir_expression *const r21C8 = greater(r21C1, body.constant(int(52)));
      ir_if *f21C7 = new(mem_ctx) ir_if(operand(r21C8).val);
      exec_list *const f21C7_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f21C7->then_instructions;

         body.emit(assign(r21C0, r21BF, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f21C7->else_instructions;

         ir_variable *const r21C9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r21C9, sub(body.constant(int(52)), r21C1), 0x01));

         ir_variable *const r21CA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r21CC = gequal(r21C9, body.constant(int(32)));
         ir_if *f21CB = new(mem_ctx) ir_if(operand(r21CC).val);
         exec_list *const f21CB_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f21CB->then_instructions;

            body.emit(assign(r21CA, body.constant(0u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f21CB->else_instructions;

            body.emit(assign(r21CA, lshift(body.constant(4294967295u), r21C9), 0x01));


         body.instructions = f21CB_parent_instructions;
         body.emit(f21CB);

         /* END IF */

         ir_variable *const r21CD = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r21CF = less(r21C9, body.constant(int(33)));
         ir_if *f21CE = new(mem_ctx) ir_if(operand(r21CF).val);
         exec_list *const f21CE_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f21CE->then_instructions;

            body.emit(assign(r21CD, body.constant(4294967295u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f21CE->else_instructions;

            ir_expression *const r21D0 = add(r21C9, body.constant(int(-32)));
            body.emit(assign(r21CD, lshift(body.constant(4294967295u), r21D0), 0x01));


         body.instructions = f21CE_parent_instructions;
         body.emit(f21CE);

         /* END IF */

         ir_variable *const r21D1 = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
         body.emit(assign(r21D1, bit_and(r21CA, swizzle_x(r21BF)), 0x01));

         body.emit(assign(r21D1, bit_and(r21CD, swizzle_y(r21BF)), 0x02));

         body.emit(assign(r21C0, r21D1, 0x03));


      body.instructions = f21C7_parent_instructions;
      body.emit(f21C7);

      /* END IF */


   body.instructions = f21C5_parent_instructions;
   body.emit(f21C5);

   /* END IF */

   ir_variable *const r21D2 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r21D2, rshift(swizzle_y(r21BF), body.constant(int(31))), 0x01));

   ir_variable *const r21D3 = body.make_temp(glsl_type::bool_type, "or_tmp");
   /* IF CONDITION */
   ir_expression *const r21D5 = expr(ir_unop_u2i, r21D2);
   ir_expression *const r21D6 = expr(ir_unop_i2b, r21D5);
   ir_if *f21D4 = new(mem_ctx) ir_if(operand(r21D6).val);
   exec_list *const f21D4_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f21D4->then_instructions;

      body.emit(assign(r21D3, body.constant(true), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f21D4->else_instructions;

      ir_variable *const r21D7 = body.make_temp(glsl_type::bool_type, "return_value");
      ir_variable *const r21D8 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
      body.emit(r21D8);
      ir_variable *const r21D9 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
      body.emit(r21D9);
      ir_expression *const r21DA = rshift(swizzle_y(r21BF), body.constant(int(20)));
      ir_expression *const r21DB = bit_and(r21DA, body.constant(2047u));
      ir_expression *const r21DC = expr(ir_unop_u2i, r21DB);
      ir_expression *const r21DD = equal(r21DC, body.constant(int(2047)));
      ir_expression *const r21DE = bit_and(swizzle_y(r21BF), body.constant(1048575u));
      ir_expression *const r21DF = bit_or(r21DE, swizzle_x(r21BF));
      ir_expression *const r21E0 = nequal(r21DF, body.constant(0u));
      body.emit(assign(r21D9, logic_and(r21DD, r21E0), 0x01));

      ir_expression *const r21E1 = rshift(swizzle_y(r21C0), body.constant(int(20)));
      ir_expression *const r21E2 = bit_and(r21E1, body.constant(2047u));
      ir_expression *const r21E3 = expr(ir_unop_u2i, r21E2);
      ir_expression *const r21E4 = equal(r21E3, body.constant(int(2047)));
      ir_expression *const r21E5 = bit_and(swizzle_y(r21C0), body.constant(1048575u));
      ir_expression *const r21E6 = bit_or(r21E5, swizzle_x(r21C0));
      ir_expression *const r21E7 = nequal(r21E6, body.constant(0u));
      body.emit(assign(r21D8, logic_and(r21E4, r21E7), 0x01));

      /* IF CONDITION */
      ir_expression *const r21E9 = logic_or(r21D9, r21D8);
      ir_if *f21E8 = new(mem_ctx) ir_if(operand(r21E9).val);
      exec_list *const f21E8_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f21E8->then_instructions;

         body.emit(assign(r21D7, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f21E8->else_instructions;

         ir_expression *const r21EA = equal(swizzle_x(r21BF), swizzle_x(r21C0));
         ir_expression *const r21EB = equal(swizzle_y(r21BF), swizzle_y(r21C0));
         ir_expression *const r21EC = equal(swizzle_x(r21BF), body.constant(0u));
         ir_expression *const r21ED = bit_or(swizzle_y(r21BF), swizzle_y(r21C0));
         ir_expression *const r21EE = lshift(r21ED, body.constant(int(1)));
         ir_expression *const r21EF = equal(r21EE, body.constant(0u));
         ir_expression *const r21F0 = logic_and(r21EC, r21EF);
         ir_expression *const r21F1 = logic_or(r21EB, r21F0);
         body.emit(assign(r21D7, logic_and(r21EA, r21F1), 0x01));


      body.instructions = f21E8_parent_instructions;
      body.emit(f21E8);

      /* END IF */

      body.emit(assign(r21D3, r21D7, 0x01));


   body.instructions = f21D4_parent_instructions;
   body.emit(f21D4);

   /* END IF */

   ir_variable *const r21F2 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
   /* IF CONDITION */
   ir_if *f21F3 = new(mem_ctx) ir_if(operand(r21D3).val);
   exec_list *const f21F3_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f21F3->then_instructions;

      body.emit(assign(r21F2, r21C0, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f21F3->else_instructions;

      ir_variable *const r21F4 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r21F5 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r21F5, rshift(swizzle_y(r21C0), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r21F7 = equal(r21F5, body.constant(0u));
      ir_if *f21F6 = new(mem_ctx) ir_if(operand(r21F7).val);
      exec_list *const f21F6_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f21F6->then_instructions;

         ir_variable *const r21F8 = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r21F8, body.constant(true), 0x01));

         ir_variable *const r21F9 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r21FA = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r21FA);
         ir_variable *const r21FB = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r21FB);
         ir_variable *const r21FC = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r21FC);
         ir_variable *const r21FD = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r21FD);
         ir_variable *const r21FE = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r21FE);
         ir_variable *const r21FF = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r21FF);
         ir_variable *const r2200 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
         body.emit(r2200);
         ir_variable *const r2201 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
         body.emit(r2201);
         body.emit(assign(r2201, body.constant(0u), 0x01));

         body.emit(assign(r2200, body.constant(0u), 0x01));

         ir_variable *const r2202 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r2202, swizzle_x(r21C0), 0x01));

         body.emit(assign(r21FE, r2202, 0x01));

         ir_variable *const r2203 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r2203, bit_and(swizzle_y(r21C0), body.constant(1048575u)), 0x01));

         body.emit(assign(r21FD, r2203, 0x01));

         ir_variable *const r2204 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r2204, body.constant(0u), 0x01));

         body.emit(assign(r21FC, body.constant(0u), 0x01));

         body.emit(assign(r21FB, body.constant(0u), 0x01));

         ir_variable *const r2205 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r2206 = rshift(swizzle_y(r21C0), body.constant(int(20)));
         ir_expression *const r2207 = bit_and(r2206, body.constant(2047u));
         body.emit(assign(r2205, expr(ir_unop_u2i, r2207), 0x01));

         ir_variable *const r2208 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         body.emit(assign(r2208, body.constant(int(1023)), 0x01));

         ir_variable *const r2209 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r2209, add(r2205, body.constant(int(-1023))), 0x01));

         body.emit(assign(r21FA, r2209, 0x01));

         /* IF CONDITION */
         ir_expression *const r220B = less(body.constant(int(0)), r2209);
         ir_if *f220A = new(mem_ctx) ir_if(operand(r220B).val);
         exec_list *const f220A_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f220A->then_instructions;

            /* IF CONDITION */
            ir_expression *const r220D = equal(r2205, body.constant(int(2047)));
            ir_if *f220C = new(mem_ctx) ir_if(operand(r220D).val);
            exec_list *const f220C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f220C->then_instructions;

               /* IF CONDITION */
               ir_expression *const r220F = bit_or(r2203, swizzle_x(r21C0));
               ir_expression *const r2210 = nequal(r220F, body.constant(0u));
               ir_if *f220E = new(mem_ctx) ir_if(operand(r2210).val);
               exec_list *const f220E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f220E->then_instructions;

                  ir_variable *const r2211 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r2211, swizzle_x(r21C0), 0x01));

                  ir_variable *const r2212 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r2212, body.constant(0u), 0x01));

                  ir_variable *const r2213 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r2211, bit_or(swizzle_y(r21C0), body.constant(524288u)), 0x02));

                  body.emit(assign(r2212, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r2215 = lshift(swizzle_y(r21C0), body.constant(int(1)));
                  ir_expression *const r2216 = lequal(body.constant(4292870144u), r2215);
                  ir_expression *const r2217 = nequal(swizzle_x(r21C0), body.constant(0u));
                  ir_expression *const r2218 = bit_and(swizzle_y(r21C0), body.constant(1048575u));
                  ir_expression *const r2219 = nequal(r2218, body.constant(0u));
                  ir_expression *const r221A = logic_or(r2217, r2219);
                  ir_expression *const r221B = logic_and(r2216, r221A);
                  ir_if *f2214 = new(mem_ctx) ir_if(operand(r221B).val);
                  exec_list *const f2214_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2214->then_instructions;

                     body.emit(assign(r2213, r2211, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2214->else_instructions;

                     body.emit(assign(r2213, r2212, 0x03));


                  body.instructions = f2214_parent_instructions;
                  body.emit(f2214);

                  /* END IF */

                  body.emit(assign(r21F9, r2213, 0x03));

                  body.emit(assign(r21F8, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f220E->else_instructions;

                  body.emit(assign(r21F9, r21C0, 0x03));

                  body.emit(assign(r21F8, body.constant(false), 0x01));


               body.instructions = f220E_parent_instructions;
               body.emit(f220E);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f220C->else_instructions;

               body.emit(assign(r21FB, body.constant(1048576u), 0x01));

               ir_variable *const r221C = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r221C, body.constant(0u), 0x01));

               ir_variable *const r221D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r221D);
               ir_variable *const r221E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r221E);
               ir_variable *const r221F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r221F);
               ir_variable *const r2220 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2221 = neg(r2209);
               body.emit(assign(r2220, bit_and(r2221, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2223 = equal(r2209, body.constant(int(0)));
               ir_if *f2222 = new(mem_ctx) ir_if(operand(r2223).val);
               exec_list *const f2222_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2222->then_instructions;

                  body.emit(assign(r221D, r221C, 0x01));

                  body.emit(assign(r221E, body.constant(0u), 0x01));

                  body.emit(assign(r221F, r21FB, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2222->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2225 = less(r2209, body.constant(int(32)));
                  ir_if *f2224 = new(mem_ctx) ir_if(operand(r2225).val);
                  exec_list *const f2224_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2224->then_instructions;

                     body.emit(assign(r221D, body.constant(0u), 0x01));

                     ir_expression *const r2226 = lshift(body.constant(1048576u), r2220);
                     body.emit(assign(r221E, bit_or(r2226, body.constant(0u)), 0x01));

                     body.emit(assign(r221F, rshift(body.constant(1048576u), r2209), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2224->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2228 = equal(r2209, body.constant(int(32)));
                     ir_if *f2227 = new(mem_ctx) ir_if(operand(r2228).val);
                     exec_list *const f2227_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2227->then_instructions;

                        body.emit(assign(r221D, body.constant(0u), 0x01));

                        body.emit(assign(r221E, r21FB, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2227->else_instructions;

                        body.emit(assign(r221C, body.constant(0u), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r222A = less(r2209, body.constant(int(64)));
                        ir_if *f2229 = new(mem_ctx) ir_if(operand(r222A).val);
                        exec_list *const f2229_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2229->then_instructions;

                           body.emit(assign(r221D, lshift(body.constant(1048576u), r2220), 0x01));

                           ir_expression *const r222B = bit_and(r2209, body.constant(int(31)));
                           body.emit(assign(r221E, rshift(body.constant(1048576u), r222B), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2229->else_instructions;

                           ir_variable *const r222C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r222E = equal(r2209, body.constant(int(64)));
                           ir_if *f222D = new(mem_ctx) ir_if(operand(r222E).val);
                           exec_list *const f222D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f222D->then_instructions;

                              body.emit(assign(r222C, r21FB, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f222D->else_instructions;

                              body.emit(assign(r222C, body.constant(1u), 0x01));


                           body.instructions = f222D_parent_instructions;
                           body.emit(f222D);

                           /* END IF */

                           body.emit(assign(r221D, r222C, 0x01));

                           body.emit(assign(r221E, body.constant(0u), 0x01));


                        body.instructions = f2229_parent_instructions;
                        body.emit(f2229);

                        /* END IF */


                     body.instructions = f2227_parent_instructions;
                     body.emit(f2227);

                     /* END IF */

                     body.emit(assign(r221F, body.constant(0u), 0x01));


                  body.instructions = f2224_parent_instructions;
                  body.emit(f2224);

                  /* END IF */

                  ir_expression *const r222F = nequal(r221C, body.constant(0u));
                  ir_expression *const r2230 = expr(ir_unop_b2i, r222F);
                  ir_expression *const r2231 = expr(ir_unop_i2u, r2230);
                  body.emit(assign(r221D, bit_or(r221D, r2231), 0x01));


               body.instructions = f2222_parent_instructions;
               body.emit(f2222);

               /* END IF */

               body.emit(assign(r21FB, r221F, 0x01));

               body.emit(assign(r21FC, r221E, 0x01));

               body.emit(assign(r2200, r221D, 0x01));

               body.emit(assign(r21FF, r2205, 0x01));


            body.instructions = f220C_parent_instructions;
            body.emit(f220C);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f220A->else_instructions;

            /* IF CONDITION */
            ir_expression *const r2233 = less(r2209, body.constant(int(0)));
            ir_if *f2232 = new(mem_ctx) ir_if(operand(r2233).val);
            exec_list *const f2232_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2232->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2235 = equal(r2205, body.constant(int(0)));
               ir_if *f2234 = new(mem_ctx) ir_if(operand(r2235).val);
               exec_list *const f2234_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2234->then_instructions;

                  body.emit(assign(r21FA, add(r2209, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2234->else_instructions;

                  body.emit(assign(r21FD, bit_or(r2203, body.constant(1048576u)), 0x01));


               body.instructions = f2234_parent_instructions;
               body.emit(f2234);

               /* END IF */

               ir_variable *const r2236 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r2236, body.constant(0u), 0x01));

               ir_variable *const r2237 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r2237, neg(r21FA), 0x01));

               ir_variable *const r2238 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r2238);
               ir_variable *const r2239 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2239);
               ir_variable *const r223A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r223A);
               ir_variable *const r223B = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r223C = neg(r2237);
               body.emit(assign(r223B, bit_and(r223C, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r223E = equal(r2237, body.constant(int(0)));
               ir_if *f223D = new(mem_ctx) ir_if(operand(r223E).val);
               exec_list *const f223D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f223D->then_instructions;

                  body.emit(assign(r2238, r2236, 0x01));

                  body.emit(assign(r2239, r2202, 0x01));

                  body.emit(assign(r223A, r21FD, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f223D->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2240 = less(r2237, body.constant(int(32)));
                  ir_if *f223F = new(mem_ctx) ir_if(operand(r2240).val);
                  exec_list *const f223F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f223F->then_instructions;

                     body.emit(assign(r2238, lshift(swizzle_x(r21C0), r223B), 0x01));

                     ir_expression *const r2241 = lshift(r21FD, r223B);
                     ir_expression *const r2242 = rshift(swizzle_x(r21C0), r2237);
                     body.emit(assign(r2239, bit_or(r2241, r2242), 0x01));

                     body.emit(assign(r223A, rshift(r21FD, r2237), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f223F->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2244 = equal(r2237, body.constant(int(32)));
                     ir_if *f2243 = new(mem_ctx) ir_if(operand(r2244).val);
                     exec_list *const f2243_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2243->then_instructions;

                        body.emit(assign(r2238, r2202, 0x01));

                        body.emit(assign(r2239, r21FD, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2243->else_instructions;

                        body.emit(assign(r2236, bit_or(body.constant(0u), swizzle_x(r21C0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2246 = less(r2237, body.constant(int(64)));
                        ir_if *f2245 = new(mem_ctx) ir_if(operand(r2246).val);
                        exec_list *const f2245_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2245->then_instructions;

                           body.emit(assign(r2238, lshift(r21FD, r223B), 0x01));

                           ir_expression *const r2247 = bit_and(r2237, body.constant(int(31)));
                           body.emit(assign(r2239, rshift(r21FD, r2247), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2245->else_instructions;

                           ir_variable *const r2248 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r224A = equal(r2237, body.constant(int(64)));
                           ir_if *f2249 = new(mem_ctx) ir_if(operand(r224A).val);
                           exec_list *const f2249_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2249->then_instructions;

                              body.emit(assign(r2248, r21FD, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2249->else_instructions;

                              ir_expression *const r224B = nequal(r21FD, body.constant(0u));
                              ir_expression *const r224C = expr(ir_unop_b2i, r224B);
                              body.emit(assign(r2248, expr(ir_unop_i2u, r224C), 0x01));


                           body.instructions = f2249_parent_instructions;
                           body.emit(f2249);

                           /* END IF */

                           body.emit(assign(r2238, r2248, 0x01));

                           body.emit(assign(r2239, body.constant(0u), 0x01));


                        body.instructions = f2245_parent_instructions;
                        body.emit(f2245);

                        /* END IF */


                     body.instructions = f2243_parent_instructions;
                     body.emit(f2243);

                     /* END IF */

                     body.emit(assign(r223A, body.constant(0u), 0x01));


                  body.instructions = f223F_parent_instructions;
                  body.emit(f223F);

                  /* END IF */

                  ir_expression *const r224D = nequal(r2236, body.constant(0u));
                  ir_expression *const r224E = expr(ir_unop_b2i, r224D);
                  ir_expression *const r224F = expr(ir_unop_i2u, r224E);
                  body.emit(assign(r2238, bit_or(r2238, r224F), 0x01));


               body.instructions = f223D_parent_instructions;
               body.emit(f223D);

               /* END IF */

               body.emit(assign(r21FD, r223A, 0x01));

               body.emit(assign(r21FE, r2239, 0x01));

               body.emit(assign(r2200, r2238, 0x01));

               body.emit(assign(r21FF, body.constant(int(1023)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2232->else_instructions;

               /* IF CONDITION */
               ir_expression *const r2251 = equal(r2205, body.constant(int(2047)));
               ir_if *f2250 = new(mem_ctx) ir_if(operand(r2251).val);
               exec_list *const f2250_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2250->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2253 = bit_or(r21FD, r21FE);
                  ir_expression *const r2254 = bit_or(r21FB, r21FC);
                  ir_expression *const r2255 = bit_or(r2253, r2254);
                  ir_expression *const r2256 = nequal(r2255, body.constant(0u));
                  ir_if *f2252 = new(mem_ctx) ir_if(operand(r2256).val);
                  exec_list *const f2252_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2252->then_instructions;

                     ir_variable *const r2257 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r2257, swizzle_x(r21C0), 0x01));

                     ir_variable *const r2258 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r2258, body.constant(0u), 0x01));

                     ir_variable *const r2259 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r2257, bit_or(swizzle_y(r21C0), body.constant(524288u)), 0x02));

                     body.emit(assign(r2258, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r225B = lshift(swizzle_y(r21C0), body.constant(int(1)));
                     ir_expression *const r225C = lequal(body.constant(4292870144u), r225B);
                     ir_expression *const r225D = nequal(swizzle_x(r21C0), body.constant(0u));
                     ir_expression *const r225E = bit_and(swizzle_y(r21C0), body.constant(1048575u));
                     ir_expression *const r225F = nequal(r225E, body.constant(0u));
                     ir_expression *const r2260 = logic_or(r225D, r225F);
                     ir_expression *const r2261 = logic_and(r225C, r2260);
                     ir_if *f225A = new(mem_ctx) ir_if(operand(r2261).val);
                     exec_list *const f225A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f225A->then_instructions;

                        body.emit(assign(r2259, r2257, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f225A->else_instructions;

                        body.emit(assign(r2259, r2258, 0x03));


                     body.instructions = f225A_parent_instructions;
                     body.emit(f225A);

                     /* END IF */

                     body.emit(assign(r21F9, r2259, 0x03));

                     body.emit(assign(r21F8, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2252->else_instructions;

                     body.emit(assign(r21F9, r21C0, 0x03));

                     body.emit(assign(r21F8, body.constant(false), 0x01));


                  body.instructions = f2252_parent_instructions;
                  body.emit(f2252);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2250->else_instructions;

                  ir_variable *const r2262 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r2263 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2263, add(r21FE, r21FC), 0x01));

                  ir_expression *const r2264 = add(r21FD, r21FB);
                  ir_expression *const r2265 = less(r2263, r21FE);
                  ir_expression *const r2266 = expr(ir_unop_b2i, r2265);
                  ir_expression *const r2267 = expr(ir_unop_i2u, r2266);
                  body.emit(assign(r2262, add(r2264, r2267), 0x01));

                  body.emit(assign(r2201, r2262, 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2269 = equal(r2205, body.constant(int(0)));
                  ir_if *f2268 = new(mem_ctx) ir_if(operand(r2269).val);
                  exec_list *const f2268_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2268->then_instructions;

                     ir_variable *const r226A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r226A);
                     ir_expression *const r226B = lshift(r21F5, body.constant(int(31)));
                     body.emit(assign(r226A, add(r226B, r2262), 0x02));

                     body.emit(assign(r226A, r2263, 0x01));

                     body.emit(assign(r21F9, r226A, 0x03));

                     body.emit(assign(r21F8, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2268->else_instructions;

                     body.emit(assign(r2201, bit_or(r2262, body.constant(2097152u)), 0x01));

                     body.emit(assign(r21FF, r2205, 0x01));

                     ir_variable *const r226C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r226C);
                     ir_variable *const r226D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r226D);
                     ir_variable *const r226E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r226E);
                     body.emit(assign(r226C, lshift(r2263, body.constant(int(31))), 0x01));

                     ir_expression *const r226F = lshift(r2201, body.constant(int(31)));
                     ir_expression *const r2270 = rshift(r2263, body.constant(int(1)));
                     body.emit(assign(r226D, bit_or(r226F, r2270), 0x01));

                     body.emit(assign(r226E, rshift(r2201, body.constant(int(1))), 0x01));

                     body.emit(assign(r226C, bit_or(r226C, body.constant(0u)), 0x01));

                     body.emit(assign(r2201, r226E, 0x01));

                     body.emit(assign(r2200, r226C, 0x01));

                     ir_variable *const r2271 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r2271, r2205, 0x01));

                     ir_variable *const r2272 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r2272, r226E, 0x01));

                     ir_variable *const r2273 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r2273, r226D, 0x01));

                     ir_variable *const r2274 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r2274, r226C, 0x01));

                     ir_variable *const r2275 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r2275, body.constant(true), 0x01));

                     ir_variable *const r2276 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r2277 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r2277);
                     ir_expression *const r2278 = expr(ir_unop_u2i, r226C);
                     body.emit(assign(r2277, less(r2278, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r227A = lequal(body.constant(int(2045)), r2205);
                     ir_if *f2279 = new(mem_ctx) ir_if(operand(r227A).val);
                     exec_list *const f2279_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2279->then_instructions;

                        ir_variable *const r227B = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r227D = less(body.constant(int(2045)), r2205);
                        ir_if *f227C = new(mem_ctx) ir_if(operand(r227D).val);
                        exec_list *const f227C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f227C->then_instructions;

                           body.emit(assign(r227B, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f227C->else_instructions;

                           ir_variable *const r227E = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2280 = equal(r2205, body.constant(int(2045)));
                           ir_if *f227F = new(mem_ctx) ir_if(operand(r2280).val);
                           exec_list *const f227F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f227F->then_instructions;

                              ir_expression *const r2281 = equal(body.constant(2097151u), r226E);
                              ir_expression *const r2282 = equal(body.constant(4294967295u), r226D);
                              body.emit(assign(r227E, logic_and(r2281, r2282), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f227F->else_instructions;

                              body.emit(assign(r227E, body.constant(false), 0x01));


                           body.instructions = f227F_parent_instructions;
                           body.emit(f227F);

                           /* END IF */

                           body.emit(assign(r227B, logic_and(r227E, r2277), 0x01));


                        body.instructions = f227C_parent_instructions;
                        body.emit(f227C);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f2283 = new(mem_ctx) ir_if(operand(r227B).val);
                        exec_list *const f2283_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2283->then_instructions;

                           ir_variable *const r2284 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r2284);
                           ir_expression *const r2285 = lshift(r21F5, body.constant(int(31)));
                           body.emit(assign(r2284, add(r2285, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r2284, body.constant(0u), 0x01));

                           body.emit(assign(r2276, r2284, 0x03));

                           body.emit(assign(r2275, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2283->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2287 = less(r2205, body.constant(int(0)));
                           ir_if *f2286 = new(mem_ctx) ir_if(operand(r2287).val);
                           exec_list *const f2286_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2286->then_instructions;

                              ir_variable *const r2288 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r2288, r226C, 0x01));

                              ir_variable *const r2289 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r2289, neg(r2205), 0x01));

                              ir_variable *const r228A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r228A);
                              ir_variable *const r228B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r228B);
                              ir_variable *const r228C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r228C);
                              ir_variable *const r228D = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r228E = neg(r2289);
                              body.emit(assign(r228D, bit_and(r228E, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2290 = equal(r2289, body.constant(int(0)));
                              ir_if *f228F = new(mem_ctx) ir_if(operand(r2290).val);
                              exec_list *const f228F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f228F->then_instructions;

                                 body.emit(assign(r228A, r226C, 0x01));

                                 body.emit(assign(r228B, r226D, 0x01));

                                 body.emit(assign(r228C, r226E, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f228F->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2292 = less(r2289, body.constant(int(32)));
                                 ir_if *f2291 = new(mem_ctx) ir_if(operand(r2292).val);
                                 exec_list *const f2291_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2291->then_instructions;

                                    body.emit(assign(r228A, lshift(r226D, r228D), 0x01));

                                    ir_expression *const r2293 = lshift(r226E, r228D);
                                    ir_expression *const r2294 = rshift(r226D, r2289);
                                    body.emit(assign(r228B, bit_or(r2293, r2294), 0x01));

                                    body.emit(assign(r228C, rshift(r226E, r2289), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2291->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2296 = equal(r2289, body.constant(int(32)));
                                    ir_if *f2295 = new(mem_ctx) ir_if(operand(r2296).val);
                                    exec_list *const f2295_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2295->then_instructions;

                                       body.emit(assign(r228A, r226D, 0x01));

                                       body.emit(assign(r228B, r226E, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2295->else_instructions;

                                       body.emit(assign(r2288, bit_or(r226C, r226D), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2298 = less(r2289, body.constant(int(64)));
                                       ir_if *f2297 = new(mem_ctx) ir_if(operand(r2298).val);
                                       exec_list *const f2297_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2297->then_instructions;

                                          body.emit(assign(r228A, lshift(r226E, r228D), 0x01));

                                          ir_expression *const r2299 = bit_and(r2289, body.constant(int(31)));
                                          body.emit(assign(r228B, rshift(r226E, r2299), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2297->else_instructions;

                                          ir_variable *const r229A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r229C = equal(r2289, body.constant(int(64)));
                                          ir_if *f229B = new(mem_ctx) ir_if(operand(r229C).val);
                                          exec_list *const f229B_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f229B->then_instructions;

                                             body.emit(assign(r229A, r226E, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f229B->else_instructions;

                                             ir_expression *const r229D = nequal(r226E, body.constant(0u));
                                             ir_expression *const r229E = expr(ir_unop_b2i, r229D);
                                             body.emit(assign(r229A, expr(ir_unop_i2u, r229E), 0x01));


                                          body.instructions = f229B_parent_instructions;
                                          body.emit(f229B);

                                          /* END IF */

                                          body.emit(assign(r228A, r229A, 0x01));

                                          body.emit(assign(r228B, body.constant(0u), 0x01));


                                       body.instructions = f2297_parent_instructions;
                                       body.emit(f2297);

                                       /* END IF */


                                    body.instructions = f2295_parent_instructions;
                                    body.emit(f2295);

                                    /* END IF */

                                    body.emit(assign(r228C, body.constant(0u), 0x01));


                                 body.instructions = f2291_parent_instructions;
                                 body.emit(f2291);

                                 /* END IF */

                                 ir_expression *const r229F = nequal(r2288, body.constant(0u));
                                 ir_expression *const r22A0 = expr(ir_unop_b2i, r229F);
                                 ir_expression *const r22A1 = expr(ir_unop_i2u, r22A0);
                                 body.emit(assign(r228A, bit_or(r228A, r22A1), 0x01));


                              body.instructions = f228F_parent_instructions;
                              body.emit(f228F);

                              /* END IF */

                              body.emit(assign(r2272, r228C, 0x01));

                              body.emit(assign(r2273, r228B, 0x01));

                              body.emit(assign(r2274, r228A, 0x01));

                              body.emit(assign(r2271, body.constant(int(0)), 0x01));

                              body.emit(assign(r2277, less(r228A, body.constant(0u)), 0x01));


                           body.instructions = f2286_parent_instructions;
                           body.emit(f2286);

                           /* END IF */


                        body.instructions = f2283_parent_instructions;
                        body.emit(f2283);

                        /* END IF */


                     body.instructions = f2279_parent_instructions;
                     body.emit(f2279);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f22A2 = new(mem_ctx) ir_if(operand(r2275).val);
                     exec_list *const f22A2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f22A2->then_instructions;

                        /* IF CONDITION */
                        ir_if *f22A3 = new(mem_ctx) ir_if(operand(r2277).val);
                        exec_list *const f22A3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f22A3->then_instructions;

                           ir_variable *const r22A4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r22A4, add(r2273, body.constant(1u)), 0x01));

                           ir_expression *const r22A5 = less(r22A4, r2273);
                           ir_expression *const r22A6 = expr(ir_unop_b2i, r22A5);
                           ir_expression *const r22A7 = expr(ir_unop_i2u, r22A6);
                           body.emit(assign(r2272, add(r2272, r22A7), 0x01));

                           ir_expression *const r22A8 = equal(r2274, body.constant(0u));
                           ir_expression *const r22A9 = expr(ir_unop_b2i, r22A8);
                           ir_expression *const r22AA = expr(ir_unop_i2u, r22A9);
                           ir_expression *const r22AB = add(r2274, r22AA);
                           ir_expression *const r22AC = bit_and(r22AB, body.constant(1u));
                           ir_expression *const r22AD = expr(ir_unop_bit_not, r22AC);
                           body.emit(assign(r2273, bit_and(r22A4, r22AD), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f22A3->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r22AF = bit_or(r2272, r2273);
                           ir_expression *const r22B0 = equal(r22AF, body.constant(0u));
                           ir_if *f22AE = new(mem_ctx) ir_if(operand(r22B0).val);
                           exec_list *const f22AE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f22AE->then_instructions;

                              body.emit(assign(r2271, body.constant(int(0)), 0x01));


                           body.instructions = f22AE_parent_instructions;
                           body.emit(f22AE);

                           /* END IF */


                        body.instructions = f22A3_parent_instructions;
                        body.emit(f22A3);

                        /* END IF */

                        ir_variable *const r22B1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r22B1);
                        ir_expression *const r22B2 = lshift(r21F5, body.constant(int(31)));
                        ir_expression *const r22B3 = expr(ir_unop_i2u, r2271);
                        ir_expression *const r22B4 = lshift(r22B3, body.constant(int(20)));
                        ir_expression *const r22B5 = add(r22B2, r22B4);
                        body.emit(assign(r22B1, add(r22B5, r2272), 0x02));

                        body.emit(assign(r22B1, r2273, 0x01));

                        body.emit(assign(r2276, r22B1, 0x03));

                        body.emit(assign(r2275, body.constant(false), 0x01));


                     body.instructions = f22A2_parent_instructions;
                     body.emit(f22A2);

                     /* END IF */

                     body.emit(assign(r21F9, r2276, 0x03));

                     body.emit(assign(r21F8, body.constant(false), 0x01));


                  body.instructions = f2268_parent_instructions;
                  body.emit(f2268);

                  /* END IF */


               body.instructions = f2250_parent_instructions;
               body.emit(f2250);

               /* END IF */


            body.instructions = f2232_parent_instructions;
            body.emit(f2232);

            /* END IF */


         body.instructions = f220A_parent_instructions;
         body.emit(f220A);

         /* END IF */

         /* IF CONDITION */
         ir_if *f22B6 = new(mem_ctx) ir_if(operand(r21F8).val);
         exec_list *const f22B6_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f22B6->then_instructions;

            body.emit(assign(r21FD, bit_or(r21FD, body.constant(1048576u)), 0x01));

            ir_variable *const r22B7 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r22B8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r22B8, add(r21FE, r21FC), 0x01));

            ir_expression *const r22B9 = add(r21FD, r21FB);
            ir_expression *const r22BA = less(r22B8, r21FE);
            ir_expression *const r22BB = expr(ir_unop_b2i, r22BA);
            ir_expression *const r22BC = expr(ir_unop_i2u, r22BB);
            body.emit(assign(r22B7, add(r22B9, r22BC), 0x01));

            body.emit(assign(r2201, r22B7, 0x01));

            body.emit(assign(r21FF, add(r21FF, body.constant(int(-1))), 0x01));

            /* IF CONDITION */
            ir_expression *const r22BE = less(r22B7, body.constant(2097152u));
            ir_if *f22BD = new(mem_ctx) ir_if(operand(r22BE).val);
            exec_list *const f22BD_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f22BD->then_instructions;

               ir_variable *const r22BF = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r22BF, r21FF, 0x01));

               ir_variable *const r22C0 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r22C0, r22B7, 0x01));

               ir_variable *const r22C1 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r22C1, r22B8, 0x01));

               ir_variable *const r22C2 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r22C2, r2200, 0x01));

               ir_variable *const r22C3 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r22C3, body.constant(true), 0x01));

               ir_variable *const r22C4 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r22C5 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r22C5);
               ir_expression *const r22C6 = expr(ir_unop_u2i, r2200);
               body.emit(assign(r22C5, less(r22C6, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r22C8 = lequal(body.constant(int(2045)), r21FF);
               ir_if *f22C7 = new(mem_ctx) ir_if(operand(r22C8).val);
               exec_list *const f22C7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f22C7->then_instructions;

                  ir_variable *const r22C9 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r22CB = less(body.constant(int(2045)), r21FF);
                  ir_if *f22CA = new(mem_ctx) ir_if(operand(r22CB).val);
                  exec_list *const f22CA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f22CA->then_instructions;

                     body.emit(assign(r22C9, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f22CA->else_instructions;

                     ir_variable *const r22CC = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r22CE = equal(r21FF, body.constant(int(2045)));
                     ir_if *f22CD = new(mem_ctx) ir_if(operand(r22CE).val);
                     exec_list *const f22CD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f22CD->then_instructions;

                        ir_expression *const r22CF = equal(body.constant(2097151u), r22B7);
                        ir_expression *const r22D0 = equal(body.constant(4294967295u), r22B8);
                        body.emit(assign(r22CC, logic_and(r22CF, r22D0), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f22CD->else_instructions;

                        body.emit(assign(r22CC, body.constant(false), 0x01));


                     body.instructions = f22CD_parent_instructions;
                     body.emit(f22CD);

                     /* END IF */

                     body.emit(assign(r22C9, logic_and(r22CC, r22C5), 0x01));


                  body.instructions = f22CA_parent_instructions;
                  body.emit(f22CA);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f22D1 = new(mem_ctx) ir_if(operand(r22C9).val);
                  exec_list *const f22D1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f22D1->then_instructions;

                     ir_variable *const r22D2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r22D2);
                     ir_expression *const r22D3 = lshift(r21F5, body.constant(int(31)));
                     body.emit(assign(r22D2, add(r22D3, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r22D2, body.constant(0u), 0x01));

                     body.emit(assign(r22C4, r22D2, 0x03));

                     body.emit(assign(r22C3, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f22D1->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r22D5 = less(r21FF, body.constant(int(0)));
                     ir_if *f22D4 = new(mem_ctx) ir_if(operand(r22D5).val);
                     exec_list *const f22D4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f22D4->then_instructions;

                        ir_variable *const r22D6 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r22D6, r2200, 0x01));

                        ir_variable *const r22D7 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r22D7, neg(r21FF), 0x01));

                        ir_variable *const r22D8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r22D8);
                        ir_variable *const r22D9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r22D9);
                        ir_variable *const r22DA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r22DA);
                        ir_variable *const r22DB = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r22DC = neg(r22D7);
                        body.emit(assign(r22DB, bit_and(r22DC, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r22DE = equal(r22D7, body.constant(int(0)));
                        ir_if *f22DD = new(mem_ctx) ir_if(operand(r22DE).val);
                        exec_list *const f22DD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f22DD->then_instructions;

                           body.emit(assign(r22D8, r2200, 0x01));

                           body.emit(assign(r22D9, r22B8, 0x01));

                           body.emit(assign(r22DA, r22B7, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f22DD->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r22E0 = less(r22D7, body.constant(int(32)));
                           ir_if *f22DF = new(mem_ctx) ir_if(operand(r22E0).val);
                           exec_list *const f22DF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f22DF->then_instructions;

                              body.emit(assign(r22D8, lshift(r22B8, r22DB), 0x01));

                              ir_expression *const r22E1 = lshift(r22B7, r22DB);
                              ir_expression *const r22E2 = rshift(r22B8, r22D7);
                              body.emit(assign(r22D9, bit_or(r22E1, r22E2), 0x01));

                              body.emit(assign(r22DA, rshift(r22B7, r22D7), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f22DF->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r22E4 = equal(r22D7, body.constant(int(32)));
                              ir_if *f22E3 = new(mem_ctx) ir_if(operand(r22E4).val);
                              exec_list *const f22E3_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f22E3->then_instructions;

                                 body.emit(assign(r22D8, r22B8, 0x01));

                                 body.emit(assign(r22D9, r22B7, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f22E3->else_instructions;

                                 body.emit(assign(r22D6, bit_or(r2200, r22B8), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r22E6 = less(r22D7, body.constant(int(64)));
                                 ir_if *f22E5 = new(mem_ctx) ir_if(operand(r22E6).val);
                                 exec_list *const f22E5_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f22E5->then_instructions;

                                    body.emit(assign(r22D8, lshift(r22B7, r22DB), 0x01));

                                    ir_expression *const r22E7 = bit_and(r22D7, body.constant(int(31)));
                                    body.emit(assign(r22D9, rshift(r22B7, r22E7), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f22E5->else_instructions;

                                    ir_variable *const r22E8 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r22EA = equal(r22D7, body.constant(int(64)));
                                    ir_if *f22E9 = new(mem_ctx) ir_if(operand(r22EA).val);
                                    exec_list *const f22E9_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f22E9->then_instructions;

                                       body.emit(assign(r22E8, r22B7, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f22E9->else_instructions;

                                       ir_expression *const r22EB = nequal(r22B7, body.constant(0u));
                                       ir_expression *const r22EC = expr(ir_unop_b2i, r22EB);
                                       body.emit(assign(r22E8, expr(ir_unop_i2u, r22EC), 0x01));


                                    body.instructions = f22E9_parent_instructions;
                                    body.emit(f22E9);

                                    /* END IF */

                                    body.emit(assign(r22D8, r22E8, 0x01));

                                    body.emit(assign(r22D9, body.constant(0u), 0x01));


                                 body.instructions = f22E5_parent_instructions;
                                 body.emit(f22E5);

                                 /* END IF */


                              body.instructions = f22E3_parent_instructions;
                              body.emit(f22E3);

                              /* END IF */

                              body.emit(assign(r22DA, body.constant(0u), 0x01));


                           body.instructions = f22DF_parent_instructions;
                           body.emit(f22DF);

                           /* END IF */

                           ir_expression *const r22ED = nequal(r22D6, body.constant(0u));
                           ir_expression *const r22EE = expr(ir_unop_b2i, r22ED);
                           ir_expression *const r22EF = expr(ir_unop_i2u, r22EE);
                           body.emit(assign(r22D8, bit_or(r22D8, r22EF), 0x01));


                        body.instructions = f22DD_parent_instructions;
                        body.emit(f22DD);

                        /* END IF */

                        body.emit(assign(r22C0, r22DA, 0x01));

                        body.emit(assign(r22C1, r22D9, 0x01));

                        body.emit(assign(r22C2, r22D8, 0x01));

                        body.emit(assign(r22BF, body.constant(int(0)), 0x01));

                        body.emit(assign(r22C5, less(r22D8, body.constant(0u)), 0x01));


                     body.instructions = f22D4_parent_instructions;
                     body.emit(f22D4);

                     /* END IF */


                  body.instructions = f22D1_parent_instructions;
                  body.emit(f22D1);

                  /* END IF */


               body.instructions = f22C7_parent_instructions;
               body.emit(f22C7);

               /* END IF */

               /* IF CONDITION */
               ir_if *f22F0 = new(mem_ctx) ir_if(operand(r22C3).val);
               exec_list *const f22F0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f22F0->then_instructions;

                  /* IF CONDITION */
                  ir_if *f22F1 = new(mem_ctx) ir_if(operand(r22C5).val);
                  exec_list *const f22F1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f22F1->then_instructions;

                     ir_variable *const r22F2 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r22F2, add(r22C1, body.constant(1u)), 0x01));

                     ir_expression *const r22F3 = less(r22F2, r22C1);
                     ir_expression *const r22F4 = expr(ir_unop_b2i, r22F3);
                     ir_expression *const r22F5 = expr(ir_unop_i2u, r22F4);
                     body.emit(assign(r22C0, add(r22C0, r22F5), 0x01));

                     ir_expression *const r22F6 = equal(r22C2, body.constant(0u));
                     ir_expression *const r22F7 = expr(ir_unop_b2i, r22F6);
                     ir_expression *const r22F8 = expr(ir_unop_i2u, r22F7);
                     ir_expression *const r22F9 = add(r22C2, r22F8);
                     ir_expression *const r22FA = bit_and(r22F9, body.constant(1u));
                     ir_expression *const r22FB = expr(ir_unop_bit_not, r22FA);
                     body.emit(assign(r22C1, bit_and(r22F2, r22FB), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f22F1->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r22FD = bit_or(r22C0, r22C1);
                     ir_expression *const r22FE = equal(r22FD, body.constant(0u));
                     ir_if *f22FC = new(mem_ctx) ir_if(operand(r22FE).val);
                     exec_list *const f22FC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f22FC->then_instructions;

                        body.emit(assign(r22BF, body.constant(int(0)), 0x01));


                     body.instructions = f22FC_parent_instructions;
                     body.emit(f22FC);

                     /* END IF */


                  body.instructions = f22F1_parent_instructions;
                  body.emit(f22F1);

                  /* END IF */

                  ir_variable *const r22FF = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r22FF);
                  ir_expression *const r2300 = lshift(r21F5, body.constant(int(31)));
                  ir_expression *const r2301 = expr(ir_unop_i2u, r22BF);
                  ir_expression *const r2302 = lshift(r2301, body.constant(int(20)));
                  ir_expression *const r2303 = add(r2300, r2302);
                  body.emit(assign(r22FF, add(r2303, r22C0), 0x02));

                  body.emit(assign(r22FF, r22C1, 0x01));

                  body.emit(assign(r22C4, r22FF, 0x03));

                  body.emit(assign(r22C3, body.constant(false), 0x01));


               body.instructions = f22F0_parent_instructions;
               body.emit(f22F0);

               /* END IF */

               body.emit(assign(r21F9, r22C4, 0x03));

               body.emit(assign(r21F8, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f22BD->else_instructions;

               body.emit(assign(r21FF, add(r21FF, body.constant(int(1))), 0x01));

               ir_variable *const r2304 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r2304);
               ir_variable *const r2305 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2305);
               ir_variable *const r2306 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2306);
               body.emit(assign(r2304, lshift(r22B8, body.constant(int(31))), 0x01));

               ir_expression *const r2307 = lshift(r22B7, body.constant(int(31)));
               ir_expression *const r2308 = rshift(r22B8, body.constant(int(1)));
               body.emit(assign(r2305, bit_or(r2307, r2308), 0x01));

               body.emit(assign(r2306, rshift(r22B7, body.constant(int(1))), 0x01));

               ir_expression *const r2309 = nequal(r2200, body.constant(0u));
               ir_expression *const r230A = expr(ir_unop_b2i, r2309);
               ir_expression *const r230B = expr(ir_unop_i2u, r230A);
               body.emit(assign(r2304, bit_or(r2304, r230B), 0x01));

               body.emit(assign(r2201, r2306, 0x01));

               body.emit(assign(r2200, r2304, 0x01));

               ir_variable *const r230C = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r230C, r21FF, 0x01));

               ir_variable *const r230D = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r230D, r2306, 0x01));

               ir_variable *const r230E = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r230E, r2305, 0x01));

               ir_variable *const r230F = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r230F, r2304, 0x01));

               ir_variable *const r2310 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r2310, body.constant(true), 0x01));

               ir_variable *const r2311 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2312 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2312);
               ir_expression *const r2313 = expr(ir_unop_u2i, r2304);
               body.emit(assign(r2312, less(r2313, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2315 = lequal(body.constant(int(2045)), r21FF);
               ir_if *f2314 = new(mem_ctx) ir_if(operand(r2315).val);
               exec_list *const f2314_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2314->then_instructions;

                  ir_variable *const r2316 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2318 = less(body.constant(int(2045)), r21FF);
                  ir_if *f2317 = new(mem_ctx) ir_if(operand(r2318).val);
                  exec_list *const f2317_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2317->then_instructions;

                     body.emit(assign(r2316, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2317->else_instructions;

                     ir_variable *const r2319 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r231B = equal(r21FF, body.constant(int(2045)));
                     ir_if *f231A = new(mem_ctx) ir_if(operand(r231B).val);
                     exec_list *const f231A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f231A->then_instructions;

                        ir_expression *const r231C = equal(body.constant(2097151u), r2306);
                        ir_expression *const r231D = equal(body.constant(4294967295u), r2305);
                        body.emit(assign(r2319, logic_and(r231C, r231D), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f231A->else_instructions;

                        body.emit(assign(r2319, body.constant(false), 0x01));


                     body.instructions = f231A_parent_instructions;
                     body.emit(f231A);

                     /* END IF */

                     body.emit(assign(r2316, logic_and(r2319, r2312), 0x01));


                  body.instructions = f2317_parent_instructions;
                  body.emit(f2317);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f231E = new(mem_ctx) ir_if(operand(r2316).val);
                  exec_list *const f231E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f231E->then_instructions;

                     ir_variable *const r231F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r231F);
                     ir_expression *const r2320 = lshift(r21F5, body.constant(int(31)));
                     body.emit(assign(r231F, add(r2320, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r231F, body.constant(0u), 0x01));

                     body.emit(assign(r2311, r231F, 0x03));

                     body.emit(assign(r2310, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f231E->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2322 = less(r21FF, body.constant(int(0)));
                     ir_if *f2321 = new(mem_ctx) ir_if(operand(r2322).val);
                     exec_list *const f2321_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2321->then_instructions;

                        ir_variable *const r2323 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2323, r2304, 0x01));

                        ir_variable *const r2324 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2324, neg(r21FF), 0x01));

                        ir_variable *const r2325 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2325);
                        ir_variable *const r2326 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2326);
                        ir_variable *const r2327 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2327);
                        ir_variable *const r2328 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2329 = neg(r2324);
                        body.emit(assign(r2328, bit_and(r2329, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r232B = equal(r2324, body.constant(int(0)));
                        ir_if *f232A = new(mem_ctx) ir_if(operand(r232B).val);
                        exec_list *const f232A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f232A->then_instructions;

                           body.emit(assign(r2325, r2304, 0x01));

                           body.emit(assign(r2326, r2305, 0x01));

                           body.emit(assign(r2327, r2306, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f232A->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r232D = less(r2324, body.constant(int(32)));
                           ir_if *f232C = new(mem_ctx) ir_if(operand(r232D).val);
                           exec_list *const f232C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f232C->then_instructions;

                              body.emit(assign(r2325, lshift(r2305, r2328), 0x01));

                              ir_expression *const r232E = lshift(r2306, r2328);
                              ir_expression *const r232F = rshift(r2305, r2324);
                              body.emit(assign(r2326, bit_or(r232E, r232F), 0x01));

                              body.emit(assign(r2327, rshift(r2306, r2324), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f232C->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2331 = equal(r2324, body.constant(int(32)));
                              ir_if *f2330 = new(mem_ctx) ir_if(operand(r2331).val);
                              exec_list *const f2330_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2330->then_instructions;

                                 body.emit(assign(r2325, r2305, 0x01));

                                 body.emit(assign(r2326, r2306, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2330->else_instructions;

                                 body.emit(assign(r2323, bit_or(r2304, r2305), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2333 = less(r2324, body.constant(int(64)));
                                 ir_if *f2332 = new(mem_ctx) ir_if(operand(r2333).val);
                                 exec_list *const f2332_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2332->then_instructions;

                                    body.emit(assign(r2325, lshift(r2306, r2328), 0x01));

                                    ir_expression *const r2334 = bit_and(r2324, body.constant(int(31)));
                                    body.emit(assign(r2326, rshift(r2306, r2334), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2332->else_instructions;

                                    ir_variable *const r2335 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2337 = equal(r2324, body.constant(int(64)));
                                    ir_if *f2336 = new(mem_ctx) ir_if(operand(r2337).val);
                                    exec_list *const f2336_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2336->then_instructions;

                                       body.emit(assign(r2335, r2306, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2336->else_instructions;

                                       ir_expression *const r2338 = nequal(r2306, body.constant(0u));
                                       ir_expression *const r2339 = expr(ir_unop_b2i, r2338);
                                       body.emit(assign(r2335, expr(ir_unop_i2u, r2339), 0x01));


                                    body.instructions = f2336_parent_instructions;
                                    body.emit(f2336);

                                    /* END IF */

                                    body.emit(assign(r2325, r2335, 0x01));

                                    body.emit(assign(r2326, body.constant(0u), 0x01));


                                 body.instructions = f2332_parent_instructions;
                                 body.emit(f2332);

                                 /* END IF */


                              body.instructions = f2330_parent_instructions;
                              body.emit(f2330);

                              /* END IF */

                              body.emit(assign(r2327, body.constant(0u), 0x01));


                           body.instructions = f232C_parent_instructions;
                           body.emit(f232C);

                           /* END IF */

                           ir_expression *const r233A = nequal(r2323, body.constant(0u));
                           ir_expression *const r233B = expr(ir_unop_b2i, r233A);
                           ir_expression *const r233C = expr(ir_unop_i2u, r233B);
                           body.emit(assign(r2325, bit_or(r2325, r233C), 0x01));


                        body.instructions = f232A_parent_instructions;
                        body.emit(f232A);

                        /* END IF */

                        body.emit(assign(r230D, r2327, 0x01));

                        body.emit(assign(r230E, r2326, 0x01));

                        body.emit(assign(r230F, r2325, 0x01));

                        body.emit(assign(r230C, body.constant(int(0)), 0x01));

                        body.emit(assign(r2312, less(r2325, body.constant(0u)), 0x01));


                     body.instructions = f2321_parent_instructions;
                     body.emit(f2321);

                     /* END IF */


                  body.instructions = f231E_parent_instructions;
                  body.emit(f231E);

                  /* END IF */


               body.instructions = f2314_parent_instructions;
               body.emit(f2314);

               /* END IF */

               /* IF CONDITION */
               ir_if *f233D = new(mem_ctx) ir_if(operand(r2310).val);
               exec_list *const f233D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f233D->then_instructions;

                  /* IF CONDITION */
                  ir_if *f233E = new(mem_ctx) ir_if(operand(r2312).val);
                  exec_list *const f233E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f233E->then_instructions;

                     ir_variable *const r233F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r233F, add(r230E, body.constant(1u)), 0x01));

                     ir_expression *const r2340 = less(r233F, r230E);
                     ir_expression *const r2341 = expr(ir_unop_b2i, r2340);
                     ir_expression *const r2342 = expr(ir_unop_i2u, r2341);
                     body.emit(assign(r230D, add(r230D, r2342), 0x01));

                     ir_expression *const r2343 = equal(r230F, body.constant(0u));
                     ir_expression *const r2344 = expr(ir_unop_b2i, r2343);
                     ir_expression *const r2345 = expr(ir_unop_i2u, r2344);
                     ir_expression *const r2346 = add(r230F, r2345);
                     ir_expression *const r2347 = bit_and(r2346, body.constant(1u));
                     ir_expression *const r2348 = expr(ir_unop_bit_not, r2347);
                     body.emit(assign(r230E, bit_and(r233F, r2348), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f233E->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r234A = bit_or(r230D, r230E);
                     ir_expression *const r234B = equal(r234A, body.constant(0u));
                     ir_if *f2349 = new(mem_ctx) ir_if(operand(r234B).val);
                     exec_list *const f2349_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2349->then_instructions;

                        body.emit(assign(r230C, body.constant(int(0)), 0x01));


                     body.instructions = f2349_parent_instructions;
                     body.emit(f2349);

                     /* END IF */


                  body.instructions = f233E_parent_instructions;
                  body.emit(f233E);

                  /* END IF */

                  ir_variable *const r234C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r234C);
                  ir_expression *const r234D = lshift(r21F5, body.constant(int(31)));
                  ir_expression *const r234E = expr(ir_unop_i2u, r230C);
                  ir_expression *const r234F = lshift(r234E, body.constant(int(20)));
                  ir_expression *const r2350 = add(r234D, r234F);
                  body.emit(assign(r234C, add(r2350, r230D), 0x02));

                  body.emit(assign(r234C, r230E, 0x01));

                  body.emit(assign(r2311, r234C, 0x03));

                  body.emit(assign(r2310, body.constant(false), 0x01));


               body.instructions = f233D_parent_instructions;
               body.emit(f233D);

               /* END IF */

               body.emit(assign(r21F9, r2311, 0x03));

               body.emit(assign(r21F8, body.constant(false), 0x01));


            body.instructions = f22BD_parent_instructions;
            body.emit(f22BD);

            /* END IF */


         body.instructions = f22B6_parent_instructions;
         body.emit(f22B6);

         /* END IF */

         body.emit(assign(r21F4, r21F9, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f21F6->else_instructions;

         ir_variable *const r2351 = body.make_temp(glsl_type::uint_type, "zSign");
         body.emit(assign(r2351, r21F5, 0x01));

         ir_variable *const r2352 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r2353 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r2353);
         ir_variable *const r2354 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
         body.emit(r2354);
         ir_variable *const r2355 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
         body.emit(r2355);
         ir_variable *const r2356 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r2356);
         ir_variable *const r2357 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r2357);
         ir_variable *const r2358 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r2358);
         ir_variable *const r2359 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r2359);
         ir_variable *const r235A = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r235A);
         ir_variable *const r235B = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r235B, body.constant(0u), 0x01));

         ir_variable *const r235C = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r235D = rshift(swizzle_y(r21C0), body.constant(int(20)));
         ir_expression *const r235E = bit_and(r235D, body.constant(2047u));
         body.emit(assign(r235C, expr(ir_unop_u2i, r235E), 0x01));

         body.emit(assign(r2355, r235C, 0x01));

         body.emit(assign(r2354, body.constant(int(1023)), 0x01));

         body.emit(assign(r2353, add(r235C, body.constant(int(-1023))), 0x01));

         ir_variable *const r235F = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r235F, lshift(swizzle_x(r21C0), body.constant(int(10))), 0x01));

         ir_variable *const r2360 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         ir_expression *const r2361 = bit_and(swizzle_y(r21C0), body.constant(1048575u));
         ir_expression *const r2362 = lshift(r2361, body.constant(int(10)));
         ir_expression *const r2363 = rshift(swizzle_x(r21C0), body.constant(int(22)));
         body.emit(assign(r2360, bit_or(r2362, r2363), 0x01));

         body.emit(assign(r2358, r2360, 0x01));

         body.emit(assign(r2359, r235F, 0x01));

         ir_variable *const r2364 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r2364, body.constant(0u), 0x01));

         ir_variable *const r2365 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         body.emit(assign(r2365, body.constant(0u), 0x01));

         body.emit(assign(r2356, r2365, 0x01));

         body.emit(assign(r2357, body.constant(0u), 0x01));

         /* IF CONDITION */
         ir_expression *const r2367 = less(body.constant(int(0)), r2353);
         ir_if *f2366 = new(mem_ctx) ir_if(operand(r2367).val);
         exec_list *const f2366_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2366->then_instructions;

            /* IF CONDITION */
            ir_expression *const r2369 = equal(r235C, body.constant(int(2047)));
            ir_if *f2368 = new(mem_ctx) ir_if(operand(r2369).val);
            exec_list *const f2368_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2368->then_instructions;

               /* IF CONDITION */
               ir_expression *const r236B = bit_or(r2360, r235F);
               ir_expression *const r236C = nequal(r236B, body.constant(0u));
               ir_if *f236A = new(mem_ctx) ir_if(operand(r236C).val);
               exec_list *const f236A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f236A->then_instructions;

                  ir_variable *const r236D = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r236D, swizzle_x(r21C0), 0x01));

                  ir_variable *const r236E = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r236E, body.constant(0u), 0x01));

                  ir_variable *const r236F = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r236D, bit_or(swizzle_y(r21C0), body.constant(524288u)), 0x02));

                  body.emit(assign(r236E, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r2371 = lshift(swizzle_y(r21C0), body.constant(int(1)));
                  ir_expression *const r2372 = lequal(body.constant(4292870144u), r2371);
                  ir_expression *const r2373 = nequal(swizzle_x(r21C0), body.constant(0u));
                  ir_expression *const r2374 = bit_and(swizzle_y(r21C0), body.constant(1048575u));
                  ir_expression *const r2375 = nequal(r2374, body.constant(0u));
                  ir_expression *const r2376 = logic_or(r2373, r2375);
                  ir_expression *const r2377 = logic_and(r2372, r2376);
                  ir_if *f2370 = new(mem_ctx) ir_if(operand(r2377).val);
                  exec_list *const f2370_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2370->then_instructions;

                     body.emit(assign(r236F, r236D, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2370->else_instructions;

                     body.emit(assign(r236F, r236E, 0x03));


                  body.instructions = f2370_parent_instructions;
                  body.emit(f2370);

                  /* END IF */

                  body.emit(assign(r2352, r236F, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f236A->else_instructions;

                  body.emit(assign(r2352, r21C0, 0x03));


               body.instructions = f236A_parent_instructions;
               body.emit(f236A);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2368->else_instructions;

               body.emit(assign(r2356, body.constant(1073741824u), 0x01));

               ir_variable *const r2378 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2378);
               ir_variable *const r2379 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2379);
               ir_variable *const r237A = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r237B = neg(r2353);
               body.emit(assign(r237A, bit_and(r237B, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r237D = equal(r2353, body.constant(int(0)));
               ir_if *f237C = new(mem_ctx) ir_if(operand(r237D).val);
               exec_list *const f237C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f237C->then_instructions;

                  body.emit(assign(r2378, body.constant(0u), 0x01));

                  body.emit(assign(r2379, r2356, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f237C->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r237F = less(r2353, body.constant(int(32)));
                  ir_if *f237E = new(mem_ctx) ir_if(operand(r237F).val);
                  exec_list *const f237E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f237E->then_instructions;

                     ir_expression *const r2380 = lshift(body.constant(1073741824u), r237A);
                     ir_expression *const r2381 = bit_or(r2380, body.constant(0u));
                     body.emit(assign(r2378, bit_or(r2381, body.constant(0u)), 0x01));

                     body.emit(assign(r2379, rshift(body.constant(1073741824u), r2353), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f237E->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2383 = equal(r2353, body.constant(int(32)));
                     ir_if *f2382 = new(mem_ctx) ir_if(operand(r2383).val);
                     exec_list *const f2382_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2382->then_instructions;

                        body.emit(assign(r2378, body.constant(1073741824u), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2382->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2385 = less(r2353, body.constant(int(64)));
                        ir_if *f2384 = new(mem_ctx) ir_if(operand(r2385).val);
                        exec_list *const f2384_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2384->then_instructions;

                           ir_expression *const r2386 = bit_and(r2353, body.constant(int(31)));
                           ir_expression *const r2387 = rshift(body.constant(1073741824u), r2386);
                           ir_expression *const r2388 = lshift(body.constant(1073741824u), r237A);
                           ir_expression *const r2389 = bit_or(r2388, body.constant(0u));
                           ir_expression *const r238A = nequal(r2389, body.constant(0u));
                           ir_expression *const r238B = expr(ir_unop_b2i, r238A);
                           ir_expression *const r238C = expr(ir_unop_i2u, r238B);
                           body.emit(assign(r2378, bit_or(r2387, r238C), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2384->else_instructions;

                           body.emit(assign(r2378, body.constant(1u), 0x01));


                        body.instructions = f2384_parent_instructions;
                        body.emit(f2384);

                        /* END IF */


                     body.instructions = f2382_parent_instructions;
                     body.emit(f2382);

                     /* END IF */

                     body.emit(assign(r2379, body.constant(0u), 0x01));


                  body.instructions = f237E_parent_instructions;
                  body.emit(f237E);

                  /* END IF */


               body.instructions = f237C_parent_instructions;
               body.emit(f237C);

               /* END IF */

               body.emit(assign(r2356, r2379, 0x01));

               body.emit(assign(r2357, r2378, 0x01));

               body.emit(assign(r2358, bit_or(r2360, body.constant(1073741824u)), 0x01));

               ir_variable *const r238D = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r238E = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r238E, sub(r235F, r2378), 0x01));

               ir_expression *const r238F = sub(r2358, r2379);
               ir_expression *const r2390 = less(r235F, r2378);
               ir_expression *const r2391 = expr(ir_unop_b2i, r2390);
               ir_expression *const r2392 = expr(ir_unop_i2u, r2391);
               body.emit(assign(r238D, sub(r238F, r2392), 0x01));

               body.emit(assign(r235A, add(r235C, body.constant(int(-1))), 0x01));

               ir_variable *const r2393 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2393, add(r235A, body.constant(int(-10))), 0x01));

               ir_variable *const r2394 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2394, r238D, 0x01));

               ir_variable *const r2395 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2395, r238E, 0x01));

               ir_variable *const r2396 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r2396);
               ir_variable *const r2397 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r2397);
               /* IF CONDITION */
               ir_expression *const r2399 = equal(r238D, body.constant(0u));
               ir_if *f2398 = new(mem_ctx) ir_if(operand(r2399).val);
               exec_list *const f2398_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2398->then_instructions;

                  body.emit(assign(r2394, r238E, 0x01));

                  body.emit(assign(r2395, body.constant(0u), 0x01));

                  body.emit(assign(r2393, add(r2393, body.constant(int(-32))), 0x01));


               body.instructions = f2398_parent_instructions;
               body.emit(f2398);

               /* END IF */

               ir_variable *const r239A = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r239A, r2394, 0x01));

               ir_variable *const r239B = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r239C = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r239C);
               /* IF CONDITION */
               ir_expression *const r239E = equal(r2394, body.constant(0u));
               ir_if *f239D = new(mem_ctx) ir_if(operand(r239E).val);
               exec_list *const f239D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f239D->then_instructions;

                  body.emit(assign(r239B, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f239D->else_instructions;

                  body.emit(assign(r239C, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r23A0 = bit_and(r2394, body.constant(4294901760u));
                  ir_expression *const r23A1 = equal(r23A0, body.constant(0u));
                  ir_if *f239F = new(mem_ctx) ir_if(operand(r23A1).val);
                  exec_list *const f239F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f239F->then_instructions;

                     body.emit(assign(r239C, body.constant(int(16)), 0x01));

                     body.emit(assign(r239A, lshift(r2394, body.constant(int(16))), 0x01));


                  body.instructions = f239F_parent_instructions;
                  body.emit(f239F);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r23A3 = bit_and(r239A, body.constant(4278190080u));
                  ir_expression *const r23A4 = equal(r23A3, body.constant(0u));
                  ir_if *f23A2 = new(mem_ctx) ir_if(operand(r23A4).val);
                  exec_list *const f23A2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f23A2->then_instructions;

                     body.emit(assign(r239C, add(r239C, body.constant(int(8))), 0x01));

                     body.emit(assign(r239A, lshift(r239A, body.constant(int(8))), 0x01));


                  body.instructions = f23A2_parent_instructions;
                  body.emit(f23A2);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r23A6 = bit_and(r239A, body.constant(4026531840u));
                  ir_expression *const r23A7 = equal(r23A6, body.constant(0u));
                  ir_if *f23A5 = new(mem_ctx) ir_if(operand(r23A7).val);
                  exec_list *const f23A5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f23A5->then_instructions;

                     body.emit(assign(r239C, add(r239C, body.constant(int(4))), 0x01));

                     body.emit(assign(r239A, lshift(r239A, body.constant(int(4))), 0x01));


                  body.instructions = f23A5_parent_instructions;
                  body.emit(f23A5);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r23A9 = bit_and(r239A, body.constant(3221225472u));
                  ir_expression *const r23AA = equal(r23A9, body.constant(0u));
                  ir_if *f23A8 = new(mem_ctx) ir_if(operand(r23AA).val);
                  exec_list *const f23A8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f23A8->then_instructions;

                     body.emit(assign(r239C, add(r239C, body.constant(int(2))), 0x01));

                     body.emit(assign(r239A, lshift(r239A, body.constant(int(2))), 0x01));


                  body.instructions = f23A8_parent_instructions;
                  body.emit(f23A8);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r23AC = bit_and(r239A, body.constant(2147483648u));
                  ir_expression *const r23AD = equal(r23AC, body.constant(0u));
                  ir_if *f23AB = new(mem_ctx) ir_if(operand(r23AD).val);
                  exec_list *const f23AB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f23AB->then_instructions;

                     body.emit(assign(r239C, add(r239C, body.constant(int(1))), 0x01));


                  body.instructions = f23AB_parent_instructions;
                  body.emit(f23AB);

                  /* END IF */

                  body.emit(assign(r239B, r239C, 0x01));


               body.instructions = f239D_parent_instructions;
               body.emit(f239D);

               /* END IF */

               body.emit(assign(r2397, add(r239B, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r23AF = lequal(body.constant(int(0)), r2397);
               ir_if *f23AE = new(mem_ctx) ir_if(operand(r23AF).val);
               exec_list *const f23AE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f23AE->then_instructions;

                  body.emit(assign(r2396, body.constant(0u), 0x01));

                  ir_variable *const r23B0 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r23B0, lshift(r2395, r2397), 0x01));

                  ir_variable *const r23B1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r23B3 = equal(r2397, body.constant(int(0)));
                  ir_if *f23B2 = new(mem_ctx) ir_if(operand(r23B3).val);
                  exec_list *const f23B2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f23B2->then_instructions;

                     body.emit(assign(r23B1, r2394, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f23B2->else_instructions;

                     ir_expression *const r23B4 = lshift(r2394, r2397);
                     ir_expression *const r23B5 = neg(r2397);
                     ir_expression *const r23B6 = bit_and(r23B5, body.constant(int(31)));
                     ir_expression *const r23B7 = rshift(r2395, r23B6);
                     body.emit(assign(r23B1, bit_or(r23B4, r23B7), 0x01));


                  body.instructions = f23B2_parent_instructions;
                  body.emit(f23B2);

                  /* END IF */

                  body.emit(assign(r2394, r23B1, 0x01));

                  body.emit(assign(r2395, r23B0, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f23AE->else_instructions;

                  ir_variable *const r23B8 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r23B8, body.constant(0u), 0x01));

                  ir_variable *const r23B9 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r23B9, neg(r2397), 0x01));

                  ir_variable *const r23BA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r23BA);
                  ir_variable *const r23BB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r23BB);
                  ir_variable *const r23BC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r23BC);
                  ir_variable *const r23BD = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r23BE = neg(r23B9);
                  body.emit(assign(r23BD, bit_and(r23BE, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r23C0 = equal(r23B9, body.constant(int(0)));
                  ir_if *f23BF = new(mem_ctx) ir_if(operand(r23C0).val);
                  exec_list *const f23BF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f23BF->then_instructions;

                     body.emit(assign(r23BA, r23B8, 0x01));

                     body.emit(assign(r23BB, r2395, 0x01));

                     body.emit(assign(r23BC, r2394, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f23BF->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r23C2 = less(r23B9, body.constant(int(32)));
                     ir_if *f23C1 = new(mem_ctx) ir_if(operand(r23C2).val);
                     exec_list *const f23C1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f23C1->then_instructions;

                        body.emit(assign(r23BA, lshift(r2395, r23BD), 0x01));

                        ir_expression *const r23C3 = lshift(r2394, r23BD);
                        ir_expression *const r23C4 = rshift(r2395, r23B9);
                        body.emit(assign(r23BB, bit_or(r23C3, r23C4), 0x01));

                        body.emit(assign(r23BC, rshift(r2394, r23B9), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f23C1->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r23C6 = equal(r23B9, body.constant(int(32)));
                        ir_if *f23C5 = new(mem_ctx) ir_if(operand(r23C6).val);
                        exec_list *const f23C5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f23C5->then_instructions;

                           body.emit(assign(r23BA, r2395, 0x01));

                           body.emit(assign(r23BB, r2394, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f23C5->else_instructions;

                           body.emit(assign(r23B8, bit_or(body.constant(0u), r2395), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r23C8 = less(r23B9, body.constant(int(64)));
                           ir_if *f23C7 = new(mem_ctx) ir_if(operand(r23C8).val);
                           exec_list *const f23C7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f23C7->then_instructions;

                              body.emit(assign(r23BA, lshift(r2394, r23BD), 0x01));

                              ir_expression *const r23C9 = bit_and(r23B9, body.constant(int(31)));
                              body.emit(assign(r23BB, rshift(r2394, r23C9), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f23C7->else_instructions;

                              ir_variable *const r23CA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r23CC = equal(r23B9, body.constant(int(64)));
                              ir_if *f23CB = new(mem_ctx) ir_if(operand(r23CC).val);
                              exec_list *const f23CB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f23CB->then_instructions;

                                 body.emit(assign(r23CA, r2394, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f23CB->else_instructions;

                                 ir_expression *const r23CD = nequal(r2394, body.constant(0u));
                                 ir_expression *const r23CE = expr(ir_unop_b2i, r23CD);
                                 body.emit(assign(r23CA, expr(ir_unop_i2u, r23CE), 0x01));


                              body.instructions = f23CB_parent_instructions;
                              body.emit(f23CB);

                              /* END IF */

                              body.emit(assign(r23BA, r23CA, 0x01));

                              body.emit(assign(r23BB, body.constant(0u), 0x01));


                           body.instructions = f23C7_parent_instructions;
                           body.emit(f23C7);

                           /* END IF */


                        body.instructions = f23C5_parent_instructions;
                        body.emit(f23C5);

                        /* END IF */

                        body.emit(assign(r23BC, body.constant(0u), 0x01));


                     body.instructions = f23C1_parent_instructions;
                     body.emit(f23C1);

                     /* END IF */

                     ir_expression *const r23CF = nequal(r23B8, body.constant(0u));
                     ir_expression *const r23D0 = expr(ir_unop_b2i, r23CF);
                     ir_expression *const r23D1 = expr(ir_unop_i2u, r23D0);
                     body.emit(assign(r23BA, bit_or(r23BA, r23D1), 0x01));


                  body.instructions = f23BF_parent_instructions;
                  body.emit(f23BF);

                  /* END IF */

                  body.emit(assign(r2394, r23BC, 0x01));

                  body.emit(assign(r2395, r23BB, 0x01));

                  body.emit(assign(r2396, r23BA, 0x01));


               body.instructions = f23AE_parent_instructions;
               body.emit(f23AE);

               /* END IF */

               body.emit(assign(r2393, sub(r2393, r2397), 0x01));

               ir_variable *const r23D2 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r23D2, r2393, 0x01));

               ir_variable *const r23D3 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r23D3, r2394, 0x01));

               ir_variable *const r23D4 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r23D4, r2395, 0x01));

               ir_variable *const r23D5 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r23D5, r2396, 0x01));

               ir_variable *const r23D6 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r23D6, body.constant(true), 0x01));

               ir_variable *const r23D7 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r23D8 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r23D8);
               ir_expression *const r23D9 = expr(ir_unop_u2i, r2396);
               body.emit(assign(r23D8, less(r23D9, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r23DB = lequal(body.constant(int(2045)), r2393);
               ir_if *f23DA = new(mem_ctx) ir_if(operand(r23DB).val);
               exec_list *const f23DA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f23DA->then_instructions;

                  ir_variable *const r23DC = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r23DE = less(body.constant(int(2045)), r2393);
                  ir_if *f23DD = new(mem_ctx) ir_if(operand(r23DE).val);
                  exec_list *const f23DD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f23DD->then_instructions;

                     body.emit(assign(r23DC, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f23DD->else_instructions;

                     ir_variable *const r23DF = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r23E1 = equal(r2393, body.constant(int(2045)));
                     ir_if *f23E0 = new(mem_ctx) ir_if(operand(r23E1).val);
                     exec_list *const f23E0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f23E0->then_instructions;

                        ir_expression *const r23E2 = equal(body.constant(2097151u), r2394);
                        ir_expression *const r23E3 = equal(body.constant(4294967295u), r2395);
                        body.emit(assign(r23DF, logic_and(r23E2, r23E3), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f23E0->else_instructions;

                        body.emit(assign(r23DF, body.constant(false), 0x01));


                     body.instructions = f23E0_parent_instructions;
                     body.emit(f23E0);

                     /* END IF */

                     body.emit(assign(r23DC, logic_and(r23DF, r23D8), 0x01));


                  body.instructions = f23DD_parent_instructions;
                  body.emit(f23DD);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f23E4 = new(mem_ctx) ir_if(operand(r23DC).val);
                  exec_list *const f23E4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f23E4->then_instructions;

                     ir_variable *const r23E5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r23E5);
                     ir_expression *const r23E6 = lshift(r21F5, body.constant(int(31)));
                     body.emit(assign(r23E5, add(r23E6, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r23E5, body.constant(0u), 0x01));

                     body.emit(assign(r23D7, r23E5, 0x03));

                     body.emit(assign(r23D6, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f23E4->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r23E8 = less(r2393, body.constant(int(0)));
                     ir_if *f23E7 = new(mem_ctx) ir_if(operand(r23E8).val);
                     exec_list *const f23E7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f23E7->then_instructions;

                        ir_variable *const r23E9 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r23E9, r2396, 0x01));

                        ir_variable *const r23EA = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r23EA, neg(r2393), 0x01));

                        ir_variable *const r23EB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r23EB);
                        ir_variable *const r23EC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r23EC);
                        ir_variable *const r23ED = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r23ED);
                        ir_variable *const r23EE = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r23EF = neg(r23EA);
                        body.emit(assign(r23EE, bit_and(r23EF, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r23F1 = equal(r23EA, body.constant(int(0)));
                        ir_if *f23F0 = new(mem_ctx) ir_if(operand(r23F1).val);
                        exec_list *const f23F0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f23F0->then_instructions;

                           body.emit(assign(r23EB, r2396, 0x01));

                           body.emit(assign(r23EC, r2395, 0x01));

                           body.emit(assign(r23ED, r2394, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f23F0->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r23F3 = less(r23EA, body.constant(int(32)));
                           ir_if *f23F2 = new(mem_ctx) ir_if(operand(r23F3).val);
                           exec_list *const f23F2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f23F2->then_instructions;

                              body.emit(assign(r23EB, lshift(r2395, r23EE), 0x01));

                              ir_expression *const r23F4 = lshift(r2394, r23EE);
                              ir_expression *const r23F5 = rshift(r2395, r23EA);
                              body.emit(assign(r23EC, bit_or(r23F4, r23F5), 0x01));

                              body.emit(assign(r23ED, rshift(r2394, r23EA), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f23F2->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r23F7 = equal(r23EA, body.constant(int(32)));
                              ir_if *f23F6 = new(mem_ctx) ir_if(operand(r23F7).val);
                              exec_list *const f23F6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f23F6->then_instructions;

                                 body.emit(assign(r23EB, r2395, 0x01));

                                 body.emit(assign(r23EC, r2394, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f23F6->else_instructions;

                                 body.emit(assign(r23E9, bit_or(r2396, r2395), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r23F9 = less(r23EA, body.constant(int(64)));
                                 ir_if *f23F8 = new(mem_ctx) ir_if(operand(r23F9).val);
                                 exec_list *const f23F8_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f23F8->then_instructions;

                                    body.emit(assign(r23EB, lshift(r2394, r23EE), 0x01));

                                    ir_expression *const r23FA = bit_and(r23EA, body.constant(int(31)));
                                    body.emit(assign(r23EC, rshift(r2394, r23FA), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f23F8->else_instructions;

                                    ir_variable *const r23FB = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r23FD = equal(r23EA, body.constant(int(64)));
                                    ir_if *f23FC = new(mem_ctx) ir_if(operand(r23FD).val);
                                    exec_list *const f23FC_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f23FC->then_instructions;

                                       body.emit(assign(r23FB, r2394, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f23FC->else_instructions;

                                       ir_expression *const r23FE = nequal(r2394, body.constant(0u));
                                       ir_expression *const r23FF = expr(ir_unop_b2i, r23FE);
                                       body.emit(assign(r23FB, expr(ir_unop_i2u, r23FF), 0x01));


                                    body.instructions = f23FC_parent_instructions;
                                    body.emit(f23FC);

                                    /* END IF */

                                    body.emit(assign(r23EB, r23FB, 0x01));

                                    body.emit(assign(r23EC, body.constant(0u), 0x01));


                                 body.instructions = f23F8_parent_instructions;
                                 body.emit(f23F8);

                                 /* END IF */


                              body.instructions = f23F6_parent_instructions;
                              body.emit(f23F6);

                              /* END IF */

                              body.emit(assign(r23ED, body.constant(0u), 0x01));


                           body.instructions = f23F2_parent_instructions;
                           body.emit(f23F2);

                           /* END IF */

                           ir_expression *const r2400 = nequal(r23E9, body.constant(0u));
                           ir_expression *const r2401 = expr(ir_unop_b2i, r2400);
                           ir_expression *const r2402 = expr(ir_unop_i2u, r2401);
                           body.emit(assign(r23EB, bit_or(r23EB, r2402), 0x01));


                        body.instructions = f23F0_parent_instructions;
                        body.emit(f23F0);

                        /* END IF */

                        body.emit(assign(r23D3, r23ED, 0x01));

                        body.emit(assign(r23D4, r23EC, 0x01));

                        body.emit(assign(r23D5, r23EB, 0x01));

                        body.emit(assign(r23D2, body.constant(int(0)), 0x01));

                        body.emit(assign(r23D8, less(r23EB, body.constant(0u)), 0x01));


                     body.instructions = f23E7_parent_instructions;
                     body.emit(f23E7);

                     /* END IF */


                  body.instructions = f23E4_parent_instructions;
                  body.emit(f23E4);

                  /* END IF */


               body.instructions = f23DA_parent_instructions;
               body.emit(f23DA);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2403 = new(mem_ctx) ir_if(operand(r23D6).val);
               exec_list *const f2403_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2403->then_instructions;

                  /* IF CONDITION */
                  ir_if *f2404 = new(mem_ctx) ir_if(operand(r23D8).val);
                  exec_list *const f2404_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2404->then_instructions;

                     ir_variable *const r2405 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r2405, add(r23D4, body.constant(1u)), 0x01));

                     ir_expression *const r2406 = less(r2405, r23D4);
                     ir_expression *const r2407 = expr(ir_unop_b2i, r2406);
                     ir_expression *const r2408 = expr(ir_unop_i2u, r2407);
                     body.emit(assign(r23D3, add(r23D3, r2408), 0x01));

                     ir_expression *const r2409 = equal(r23D5, body.constant(0u));
                     ir_expression *const r240A = expr(ir_unop_b2i, r2409);
                     ir_expression *const r240B = expr(ir_unop_i2u, r240A);
                     ir_expression *const r240C = add(r23D5, r240B);
                     ir_expression *const r240D = bit_and(r240C, body.constant(1u));
                     ir_expression *const r240E = expr(ir_unop_bit_not, r240D);
                     body.emit(assign(r23D4, bit_and(r2405, r240E), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2404->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2410 = bit_or(r23D3, r23D4);
                     ir_expression *const r2411 = equal(r2410, body.constant(0u));
                     ir_if *f240F = new(mem_ctx) ir_if(operand(r2411).val);
                     exec_list *const f240F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f240F->then_instructions;

                        body.emit(assign(r23D2, body.constant(int(0)), 0x01));


                     body.instructions = f240F_parent_instructions;
                     body.emit(f240F);

                     /* END IF */


                  body.instructions = f2404_parent_instructions;
                  body.emit(f2404);

                  /* END IF */

                  ir_variable *const r2412 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2412);
                  ir_expression *const r2413 = lshift(r21F5, body.constant(int(31)));
                  ir_expression *const r2414 = expr(ir_unop_i2u, r23D2);
                  ir_expression *const r2415 = lshift(r2414, body.constant(int(20)));
                  ir_expression *const r2416 = add(r2413, r2415);
                  body.emit(assign(r2412, add(r2416, r23D3), 0x02));

                  body.emit(assign(r2412, r23D4, 0x01));

                  body.emit(assign(r23D7, r2412, 0x03));

                  body.emit(assign(r23D6, body.constant(false), 0x01));


               body.instructions = f2403_parent_instructions;
               body.emit(f2403);

               /* END IF */

               body.emit(assign(r2352, r23D7, 0x03));


            body.instructions = f2368_parent_instructions;
            body.emit(f2368);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2366->else_instructions;

            /* IF CONDITION */
            ir_expression *const r2418 = less(r2353, body.constant(int(0)));
            ir_if *f2417 = new(mem_ctx) ir_if(operand(r2418).val);
            exec_list *const f2417_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2417->then_instructions;

               /* IF CONDITION */
               ir_expression *const r241A = equal(r235C, body.constant(int(0)));
               ir_if *f2419 = new(mem_ctx) ir_if(operand(r241A).val);
               exec_list *const f2419_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2419->then_instructions;

                  body.emit(assign(r2353, add(r2353, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2419->else_instructions;

                  body.emit(assign(r2358, bit_or(r2358, body.constant(1073741824u)), 0x01));


               body.instructions = f2419_parent_instructions;
               body.emit(f2419);

               /* END IF */

               ir_variable *const r241B = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r241B, neg(r2353), 0x01));

               ir_variable *const r241C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r241C);
               ir_variable *const r241D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r241D);
               ir_variable *const r241E = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r241F = neg(r241B);
               body.emit(assign(r241E, bit_and(r241F, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2421 = equal(r241B, body.constant(int(0)));
               ir_if *f2420 = new(mem_ctx) ir_if(operand(r2421).val);
               exec_list *const f2420_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2420->then_instructions;

                  body.emit(assign(r241C, r235F, 0x01));

                  body.emit(assign(r241D, r2358, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2420->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2423 = less(r241B, body.constant(int(32)));
                  ir_if *f2422 = new(mem_ctx) ir_if(operand(r2423).val);
                  exec_list *const f2422_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2422->then_instructions;

                     ir_expression *const r2424 = lshift(r2358, r241E);
                     ir_expression *const r2425 = rshift(r235F, r241B);
                     ir_expression *const r2426 = bit_or(r2424, r2425);
                     ir_expression *const r2427 = lshift(r235F, r241E);
                     ir_expression *const r2428 = nequal(r2427, body.constant(0u));
                     ir_expression *const r2429 = expr(ir_unop_b2i, r2428);
                     ir_expression *const r242A = expr(ir_unop_i2u, r2429);
                     body.emit(assign(r241C, bit_or(r2426, r242A), 0x01));

                     body.emit(assign(r241D, rshift(r2358, r241B), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2422->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r242C = equal(r241B, body.constant(int(32)));
                     ir_if *f242B = new(mem_ctx) ir_if(operand(r242C).val);
                     exec_list *const f242B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f242B->then_instructions;

                        ir_expression *const r242D = nequal(r235F, body.constant(0u));
                        ir_expression *const r242E = expr(ir_unop_b2i, r242D);
                        ir_expression *const r242F = expr(ir_unop_i2u, r242E);
                        body.emit(assign(r241C, bit_or(r2358, r242F), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f242B->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2431 = less(r241B, body.constant(int(64)));
                        ir_if *f2430 = new(mem_ctx) ir_if(operand(r2431).val);
                        exec_list *const f2430_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2430->then_instructions;

                           ir_expression *const r2432 = bit_and(r241B, body.constant(int(31)));
                           ir_expression *const r2433 = rshift(r2358, r2432);
                           ir_expression *const r2434 = lshift(r2358, r241E);
                           ir_expression *const r2435 = bit_or(r2434, r235F);
                           ir_expression *const r2436 = nequal(r2435, body.constant(0u));
                           ir_expression *const r2437 = expr(ir_unop_b2i, r2436);
                           ir_expression *const r2438 = expr(ir_unop_i2u, r2437);
                           body.emit(assign(r241C, bit_or(r2433, r2438), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2430->else_instructions;

                           ir_expression *const r2439 = bit_or(r2358, r235F);
                           ir_expression *const r243A = nequal(r2439, body.constant(0u));
                           ir_expression *const r243B = expr(ir_unop_b2i, r243A);
                           body.emit(assign(r241C, expr(ir_unop_i2u, r243B), 0x01));


                        body.instructions = f2430_parent_instructions;
                        body.emit(f2430);

                        /* END IF */


                     body.instructions = f242B_parent_instructions;
                     body.emit(f242B);

                     /* END IF */

                     body.emit(assign(r241D, body.constant(0u), 0x01));


                  body.instructions = f2422_parent_instructions;
                  body.emit(f2422);

                  /* END IF */


               body.instructions = f2420_parent_instructions;
               body.emit(f2420);

               /* END IF */

               body.emit(assign(r2358, r241D, 0x01));

               body.emit(assign(r2359, r241C, 0x01));

               body.emit(assign(r2356, bit_or(r2356, body.constant(1073741824u)), 0x01));

               ir_variable *const r243C = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r243D = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r243D, sub(r2357, r241C), 0x01));

               ir_expression *const r243E = sub(r2356, r241D);
               ir_expression *const r243F = less(r2357, r241C);
               ir_expression *const r2440 = expr(ir_unop_b2i, r243F);
               ir_expression *const r2441 = expr(ir_unop_i2u, r2440);
               body.emit(assign(r243C, sub(r243E, r2441), 0x01));

               body.emit(assign(r2351, bit_xor(r21F5, body.constant(1u)), 0x01));

               body.emit(assign(r235A, body.constant(int(1022)), 0x01));

               ir_variable *const r2442 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2442, body.constant(int(1012)), 0x01));

               ir_variable *const r2443 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2443, r243C, 0x01));

               ir_variable *const r2444 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2444, r243D, 0x01));

               ir_variable *const r2445 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r2445);
               ir_variable *const r2446 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r2446);
               /* IF CONDITION */
               ir_expression *const r2448 = equal(r243C, body.constant(0u));
               ir_if *f2447 = new(mem_ctx) ir_if(operand(r2448).val);
               exec_list *const f2447_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2447->then_instructions;

                  body.emit(assign(r2443, r243D, 0x01));

                  body.emit(assign(r2444, body.constant(0u), 0x01));

                  body.emit(assign(r2442, body.constant(int(980)), 0x01));


               body.instructions = f2447_parent_instructions;
               body.emit(f2447);

               /* END IF */

               ir_variable *const r2449 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r2449, r2443, 0x01));

               ir_variable *const r244A = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r244B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r244B);
               /* IF CONDITION */
               ir_expression *const r244D = equal(r2443, body.constant(0u));
               ir_if *f244C = new(mem_ctx) ir_if(operand(r244D).val);
               exec_list *const f244C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f244C->then_instructions;

                  body.emit(assign(r244A, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f244C->else_instructions;

                  body.emit(assign(r244B, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r244F = bit_and(r2443, body.constant(4294901760u));
                  ir_expression *const r2450 = equal(r244F, body.constant(0u));
                  ir_if *f244E = new(mem_ctx) ir_if(operand(r2450).val);
                  exec_list *const f244E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f244E->then_instructions;

                     body.emit(assign(r244B, body.constant(int(16)), 0x01));

                     body.emit(assign(r2449, lshift(r2443, body.constant(int(16))), 0x01));


                  body.instructions = f244E_parent_instructions;
                  body.emit(f244E);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2452 = bit_and(r2449, body.constant(4278190080u));
                  ir_expression *const r2453 = equal(r2452, body.constant(0u));
                  ir_if *f2451 = new(mem_ctx) ir_if(operand(r2453).val);
                  exec_list *const f2451_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2451->then_instructions;

                     body.emit(assign(r244B, add(r244B, body.constant(int(8))), 0x01));

                     body.emit(assign(r2449, lshift(r2449, body.constant(int(8))), 0x01));


                  body.instructions = f2451_parent_instructions;
                  body.emit(f2451);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2455 = bit_and(r2449, body.constant(4026531840u));
                  ir_expression *const r2456 = equal(r2455, body.constant(0u));
                  ir_if *f2454 = new(mem_ctx) ir_if(operand(r2456).val);
                  exec_list *const f2454_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2454->then_instructions;

                     body.emit(assign(r244B, add(r244B, body.constant(int(4))), 0x01));

                     body.emit(assign(r2449, lshift(r2449, body.constant(int(4))), 0x01));


                  body.instructions = f2454_parent_instructions;
                  body.emit(f2454);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2458 = bit_and(r2449, body.constant(3221225472u));
                  ir_expression *const r2459 = equal(r2458, body.constant(0u));
                  ir_if *f2457 = new(mem_ctx) ir_if(operand(r2459).val);
                  exec_list *const f2457_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2457->then_instructions;

                     body.emit(assign(r244B, add(r244B, body.constant(int(2))), 0x01));

                     body.emit(assign(r2449, lshift(r2449, body.constant(int(2))), 0x01));


                  body.instructions = f2457_parent_instructions;
                  body.emit(f2457);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r245B = bit_and(r2449, body.constant(2147483648u));
                  ir_expression *const r245C = equal(r245B, body.constant(0u));
                  ir_if *f245A = new(mem_ctx) ir_if(operand(r245C).val);
                  exec_list *const f245A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f245A->then_instructions;

                     body.emit(assign(r244B, add(r244B, body.constant(int(1))), 0x01));


                  body.instructions = f245A_parent_instructions;
                  body.emit(f245A);

                  /* END IF */

                  body.emit(assign(r244A, r244B, 0x01));


               body.instructions = f244C_parent_instructions;
               body.emit(f244C);

               /* END IF */

               body.emit(assign(r2446, add(r244A, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r245E = lequal(body.constant(int(0)), r2446);
               ir_if *f245D = new(mem_ctx) ir_if(operand(r245E).val);
               exec_list *const f245D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f245D->then_instructions;

                  body.emit(assign(r2445, body.constant(0u), 0x01));

                  ir_variable *const r245F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r245F, lshift(r2444, r2446), 0x01));

                  ir_variable *const r2460 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2462 = equal(r2446, body.constant(int(0)));
                  ir_if *f2461 = new(mem_ctx) ir_if(operand(r2462).val);
                  exec_list *const f2461_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2461->then_instructions;

                     body.emit(assign(r2460, r2443, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2461->else_instructions;

                     ir_expression *const r2463 = lshift(r2443, r2446);
                     ir_expression *const r2464 = neg(r2446);
                     ir_expression *const r2465 = bit_and(r2464, body.constant(int(31)));
                     ir_expression *const r2466 = rshift(r2444, r2465);
                     body.emit(assign(r2460, bit_or(r2463, r2466), 0x01));


                  body.instructions = f2461_parent_instructions;
                  body.emit(f2461);

                  /* END IF */

                  body.emit(assign(r2443, r2460, 0x01));

                  body.emit(assign(r2444, r245F, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f245D->else_instructions;

                  ir_variable *const r2467 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r2467, body.constant(0u), 0x01));

                  ir_variable *const r2468 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r2468, neg(r2446), 0x01));

                  ir_variable *const r2469 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r2469);
                  ir_variable *const r246A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r246A);
                  ir_variable *const r246B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r246B);
                  ir_variable *const r246C = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r246D = neg(r2468);
                  body.emit(assign(r246C, bit_and(r246D, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r246F = equal(r2468, body.constant(int(0)));
                  ir_if *f246E = new(mem_ctx) ir_if(operand(r246F).val);
                  exec_list *const f246E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f246E->then_instructions;

                     body.emit(assign(r2469, r2467, 0x01));

                     body.emit(assign(r246A, r2444, 0x01));

                     body.emit(assign(r246B, r2443, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f246E->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2471 = less(r2468, body.constant(int(32)));
                     ir_if *f2470 = new(mem_ctx) ir_if(operand(r2471).val);
                     exec_list *const f2470_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2470->then_instructions;

                        body.emit(assign(r2469, lshift(r2444, r246C), 0x01));

                        ir_expression *const r2472 = lshift(r2443, r246C);
                        ir_expression *const r2473 = rshift(r2444, r2468);
                        body.emit(assign(r246A, bit_or(r2472, r2473), 0x01));

                        body.emit(assign(r246B, rshift(r2443, r2468), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2470->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2475 = equal(r2468, body.constant(int(32)));
                        ir_if *f2474 = new(mem_ctx) ir_if(operand(r2475).val);
                        exec_list *const f2474_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2474->then_instructions;

                           body.emit(assign(r2469, r2444, 0x01));

                           body.emit(assign(r246A, r2443, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2474->else_instructions;

                           body.emit(assign(r2467, bit_or(body.constant(0u), r2444), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2477 = less(r2468, body.constant(int(64)));
                           ir_if *f2476 = new(mem_ctx) ir_if(operand(r2477).val);
                           exec_list *const f2476_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2476->then_instructions;

                              body.emit(assign(r2469, lshift(r2443, r246C), 0x01));

                              ir_expression *const r2478 = bit_and(r2468, body.constant(int(31)));
                              body.emit(assign(r246A, rshift(r2443, r2478), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2476->else_instructions;

                              ir_variable *const r2479 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r247B = equal(r2468, body.constant(int(64)));
                              ir_if *f247A = new(mem_ctx) ir_if(operand(r247B).val);
                              exec_list *const f247A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f247A->then_instructions;

                                 body.emit(assign(r2479, r2443, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f247A->else_instructions;

                                 ir_expression *const r247C = nequal(r2443, body.constant(0u));
                                 ir_expression *const r247D = expr(ir_unop_b2i, r247C);
                                 body.emit(assign(r2479, expr(ir_unop_i2u, r247D), 0x01));


                              body.instructions = f247A_parent_instructions;
                              body.emit(f247A);

                              /* END IF */

                              body.emit(assign(r2469, r2479, 0x01));

                              body.emit(assign(r246A, body.constant(0u), 0x01));


                           body.instructions = f2476_parent_instructions;
                           body.emit(f2476);

                           /* END IF */


                        body.instructions = f2474_parent_instructions;
                        body.emit(f2474);

                        /* END IF */

                        body.emit(assign(r246B, body.constant(0u), 0x01));


                     body.instructions = f2470_parent_instructions;
                     body.emit(f2470);

                     /* END IF */

                     ir_expression *const r247E = nequal(r2467, body.constant(0u));
                     ir_expression *const r247F = expr(ir_unop_b2i, r247E);
                     ir_expression *const r2480 = expr(ir_unop_i2u, r247F);
                     body.emit(assign(r2469, bit_or(r2469, r2480), 0x01));


                  body.instructions = f246E_parent_instructions;
                  body.emit(f246E);

                  /* END IF */

                  body.emit(assign(r2443, r246B, 0x01));

                  body.emit(assign(r2444, r246A, 0x01));

                  body.emit(assign(r2445, r2469, 0x01));


               body.instructions = f245D_parent_instructions;
               body.emit(f245D);

               /* END IF */

               body.emit(assign(r2442, sub(r2442, r2446), 0x01));

               ir_variable *const r2481 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2481, r2442, 0x01));

               ir_variable *const r2482 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2482, r2443, 0x01));

               ir_variable *const r2483 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2483, r2444, 0x01));

               ir_variable *const r2484 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r2484, r2445, 0x01));

               ir_variable *const r2485 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r2485, body.constant(true), 0x01));

               ir_variable *const r2486 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2487 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2487);
               ir_expression *const r2488 = expr(ir_unop_u2i, r2445);
               body.emit(assign(r2487, less(r2488, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r248A = lequal(body.constant(int(2045)), r2442);
               ir_if *f2489 = new(mem_ctx) ir_if(operand(r248A).val);
               exec_list *const f2489_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2489->then_instructions;

                  ir_variable *const r248B = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r248D = less(body.constant(int(2045)), r2442);
                  ir_if *f248C = new(mem_ctx) ir_if(operand(r248D).val);
                  exec_list *const f248C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f248C->then_instructions;

                     body.emit(assign(r248B, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f248C->else_instructions;

                     ir_variable *const r248E = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2490 = equal(r2442, body.constant(int(2045)));
                     ir_if *f248F = new(mem_ctx) ir_if(operand(r2490).val);
                     exec_list *const f248F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f248F->then_instructions;

                        ir_expression *const r2491 = equal(body.constant(2097151u), r2443);
                        ir_expression *const r2492 = equal(body.constant(4294967295u), r2444);
                        body.emit(assign(r248E, logic_and(r2491, r2492), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f248F->else_instructions;

                        body.emit(assign(r248E, body.constant(false), 0x01));


                     body.instructions = f248F_parent_instructions;
                     body.emit(f248F);

                     /* END IF */

                     body.emit(assign(r248B, logic_and(r248E, r2487), 0x01));


                  body.instructions = f248C_parent_instructions;
                  body.emit(f248C);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2493 = new(mem_ctx) ir_if(operand(r248B).val);
                  exec_list *const f2493_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2493->then_instructions;

                     ir_variable *const r2494 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2494);
                     ir_expression *const r2495 = lshift(r2351, body.constant(int(31)));
                     body.emit(assign(r2494, add(r2495, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r2494, body.constant(0u), 0x01));

                     body.emit(assign(r2486, r2494, 0x03));

                     body.emit(assign(r2485, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2493->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2497 = less(r2442, body.constant(int(0)));
                     ir_if *f2496 = new(mem_ctx) ir_if(operand(r2497).val);
                     exec_list *const f2496_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2496->then_instructions;

                        ir_variable *const r2498 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2498, r2445, 0x01));

                        ir_variable *const r2499 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2499, neg(r2442), 0x01));

                        ir_variable *const r249A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r249A);
                        ir_variable *const r249B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r249B);
                        ir_variable *const r249C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r249C);
                        ir_variable *const r249D = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r249E = neg(r2499);
                        body.emit(assign(r249D, bit_and(r249E, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r24A0 = equal(r2499, body.constant(int(0)));
                        ir_if *f249F = new(mem_ctx) ir_if(operand(r24A0).val);
                        exec_list *const f249F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f249F->then_instructions;

                           body.emit(assign(r249A, r2445, 0x01));

                           body.emit(assign(r249B, r2444, 0x01));

                           body.emit(assign(r249C, r2443, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f249F->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r24A2 = less(r2499, body.constant(int(32)));
                           ir_if *f24A1 = new(mem_ctx) ir_if(operand(r24A2).val);
                           exec_list *const f24A1_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f24A1->then_instructions;

                              body.emit(assign(r249A, lshift(r2444, r249D), 0x01));

                              ir_expression *const r24A3 = lshift(r2443, r249D);
                              ir_expression *const r24A4 = rshift(r2444, r2499);
                              body.emit(assign(r249B, bit_or(r24A3, r24A4), 0x01));

                              body.emit(assign(r249C, rshift(r2443, r2499), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f24A1->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r24A6 = equal(r2499, body.constant(int(32)));
                              ir_if *f24A5 = new(mem_ctx) ir_if(operand(r24A6).val);
                              exec_list *const f24A5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f24A5->then_instructions;

                                 body.emit(assign(r249A, r2444, 0x01));

                                 body.emit(assign(r249B, r2443, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f24A5->else_instructions;

                                 body.emit(assign(r2498, bit_or(r2445, r2444), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r24A8 = less(r2499, body.constant(int(64)));
                                 ir_if *f24A7 = new(mem_ctx) ir_if(operand(r24A8).val);
                                 exec_list *const f24A7_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f24A7->then_instructions;

                                    body.emit(assign(r249A, lshift(r2443, r249D), 0x01));

                                    ir_expression *const r24A9 = bit_and(r2499, body.constant(int(31)));
                                    body.emit(assign(r249B, rshift(r2443, r24A9), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f24A7->else_instructions;

                                    ir_variable *const r24AA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r24AC = equal(r2499, body.constant(int(64)));
                                    ir_if *f24AB = new(mem_ctx) ir_if(operand(r24AC).val);
                                    exec_list *const f24AB_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f24AB->then_instructions;

                                       body.emit(assign(r24AA, r2443, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f24AB->else_instructions;

                                       ir_expression *const r24AD = nequal(r2443, body.constant(0u));
                                       ir_expression *const r24AE = expr(ir_unop_b2i, r24AD);
                                       body.emit(assign(r24AA, expr(ir_unop_i2u, r24AE), 0x01));


                                    body.instructions = f24AB_parent_instructions;
                                    body.emit(f24AB);

                                    /* END IF */

                                    body.emit(assign(r249A, r24AA, 0x01));

                                    body.emit(assign(r249B, body.constant(0u), 0x01));


                                 body.instructions = f24A7_parent_instructions;
                                 body.emit(f24A7);

                                 /* END IF */


                              body.instructions = f24A5_parent_instructions;
                              body.emit(f24A5);

                              /* END IF */

                              body.emit(assign(r249C, body.constant(0u), 0x01));


                           body.instructions = f24A1_parent_instructions;
                           body.emit(f24A1);

                           /* END IF */

                           ir_expression *const r24AF = nequal(r2498, body.constant(0u));
                           ir_expression *const r24B0 = expr(ir_unop_b2i, r24AF);
                           ir_expression *const r24B1 = expr(ir_unop_i2u, r24B0);
                           body.emit(assign(r249A, bit_or(r249A, r24B1), 0x01));


                        body.instructions = f249F_parent_instructions;
                        body.emit(f249F);

                        /* END IF */

                        body.emit(assign(r2482, r249C, 0x01));

                        body.emit(assign(r2483, r249B, 0x01));

                        body.emit(assign(r2484, r249A, 0x01));

                        body.emit(assign(r2481, body.constant(int(0)), 0x01));

                        body.emit(assign(r2487, less(r249A, body.constant(0u)), 0x01));


                     body.instructions = f2496_parent_instructions;
                     body.emit(f2496);

                     /* END IF */


                  body.instructions = f2493_parent_instructions;
                  body.emit(f2493);

                  /* END IF */


               body.instructions = f2489_parent_instructions;
               body.emit(f2489);

               /* END IF */

               /* IF CONDITION */
               ir_if *f24B2 = new(mem_ctx) ir_if(operand(r2485).val);
               exec_list *const f24B2_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f24B2->then_instructions;

                  /* IF CONDITION */
                  ir_if *f24B3 = new(mem_ctx) ir_if(operand(r2487).val);
                  exec_list *const f24B3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f24B3->then_instructions;

                     ir_variable *const r24B4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r24B4, add(r2483, body.constant(1u)), 0x01));

                     ir_expression *const r24B5 = less(r24B4, r2483);
                     ir_expression *const r24B6 = expr(ir_unop_b2i, r24B5);
                     ir_expression *const r24B7 = expr(ir_unop_i2u, r24B6);
                     body.emit(assign(r2482, add(r2482, r24B7), 0x01));

                     ir_expression *const r24B8 = equal(r2484, body.constant(0u));
                     ir_expression *const r24B9 = expr(ir_unop_b2i, r24B8);
                     ir_expression *const r24BA = expr(ir_unop_i2u, r24B9);
                     ir_expression *const r24BB = add(r2484, r24BA);
                     ir_expression *const r24BC = bit_and(r24BB, body.constant(1u));
                     ir_expression *const r24BD = expr(ir_unop_bit_not, r24BC);
                     body.emit(assign(r2483, bit_and(r24B4, r24BD), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f24B3->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r24BF = bit_or(r2482, r2483);
                     ir_expression *const r24C0 = equal(r24BF, body.constant(0u));
                     ir_if *f24BE = new(mem_ctx) ir_if(operand(r24C0).val);
                     exec_list *const f24BE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f24BE->then_instructions;

                        body.emit(assign(r2481, body.constant(int(0)), 0x01));


                     body.instructions = f24BE_parent_instructions;
                     body.emit(f24BE);

                     /* END IF */


                  body.instructions = f24B3_parent_instructions;
                  body.emit(f24B3);

                  /* END IF */

                  ir_variable *const r24C1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r24C1);
                  ir_expression *const r24C2 = lshift(r2351, body.constant(int(31)));
                  ir_expression *const r24C3 = expr(ir_unop_i2u, r2481);
                  ir_expression *const r24C4 = lshift(r24C3, body.constant(int(20)));
                  ir_expression *const r24C5 = add(r24C2, r24C4);
                  body.emit(assign(r24C1, add(r24C5, r2482), 0x02));

                  body.emit(assign(r24C1, r2483, 0x01));

                  body.emit(assign(r2486, r24C1, 0x03));

                  body.emit(assign(r2485, body.constant(false), 0x01));


               body.instructions = f24B2_parent_instructions;
               body.emit(f24B2);

               /* END IF */

               body.emit(assign(r2352, r2486, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2417->else_instructions;

               /* IF CONDITION */
               ir_expression *const r24C7 = equal(r235C, body.constant(int(2047)));
               ir_if *f24C6 = new(mem_ctx) ir_if(operand(r24C7).val);
               exec_list *const f24C6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f24C6->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r24C9 = bit_or(r2358, r2359);
                  ir_expression *const r24CA = bit_or(r2356, r2357);
                  ir_expression *const r24CB = bit_or(r24C9, r24CA);
                  ir_expression *const r24CC = nequal(r24CB, body.constant(0u));
                  ir_if *f24C8 = new(mem_ctx) ir_if(operand(r24CC).val);
                  exec_list *const f24C8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f24C8->then_instructions;

                     ir_variable *const r24CD = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r24CD, swizzle_x(r21C0), 0x01));

                     ir_variable *const r24CE = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r24CE, body.constant(0u), 0x01));

                     ir_variable *const r24CF = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r24CD, bit_or(swizzle_y(r21C0), body.constant(524288u)), 0x02));

                     body.emit(assign(r24CE, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r24D1 = lshift(swizzle_y(r21C0), body.constant(int(1)));
                     ir_expression *const r24D2 = lequal(body.constant(4292870144u), r24D1);
                     ir_expression *const r24D3 = nequal(swizzle_x(r21C0), body.constant(0u));
                     ir_expression *const r24D4 = bit_and(swizzle_y(r21C0), body.constant(1048575u));
                     ir_expression *const r24D5 = nequal(r24D4, body.constant(0u));
                     ir_expression *const r24D6 = logic_or(r24D3, r24D5);
                     ir_expression *const r24D7 = logic_and(r24D2, r24D6);
                     ir_if *f24D0 = new(mem_ctx) ir_if(operand(r24D7).val);
                     exec_list *const f24D0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f24D0->then_instructions;

                        body.emit(assign(r24CF, r24CD, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f24D0->else_instructions;

                        body.emit(assign(r24CF, r24CE, 0x03));


                     body.instructions = f24D0_parent_instructions;
                     body.emit(f24D0);

                     /* END IF */

                     body.emit(assign(r2352, r24CF, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f24C8->else_instructions;

                     ir_constant_data r24D8_data;
                     memset(&r24D8_data, 0, sizeof(ir_constant_data));
                     r24D8_data.u[0] = 4294967295;
                     r24D8_data.u[1] = 4294967295;
                     ir_constant *const r24D8 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r24D8_data);
                     body.emit(assign(r2352, r24D8, 0x03));


                  body.instructions = f24C8_parent_instructions;
                  body.emit(f24C8);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f24C6->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r24DA = equal(r235C, body.constant(int(0)));
                  ir_if *f24D9 = new(mem_ctx) ir_if(operand(r24DA).val);
                  exec_list *const f24D9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f24D9->then_instructions;

                     body.emit(assign(r2355, body.constant(int(1)), 0x01));

                     body.emit(assign(r2354, body.constant(int(1)), 0x01));


                  body.instructions = f24D9_parent_instructions;
                  body.emit(f24D9);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r24DC = less(r2356, r2358);
                  ir_if *f24DB = new(mem_ctx) ir_if(operand(r24DC).val);
                  exec_list *const f24DB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f24DB->then_instructions;

                     ir_variable *const r24DD = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r24DE = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r24DE, sub(r2359, r2357), 0x01));

                     ir_expression *const r24DF = sub(r2358, r2356);
                     ir_expression *const r24E0 = less(r2359, r2357);
                     ir_expression *const r24E1 = expr(ir_unop_b2i, r24E0);
                     ir_expression *const r24E2 = expr(ir_unop_i2u, r24E1);
                     body.emit(assign(r24DD, sub(r24DF, r24E2), 0x01));

                     body.emit(assign(r235A, add(r2355, body.constant(int(-1))), 0x01));

                     ir_variable *const r24E3 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r24E3, add(r235A, body.constant(int(-10))), 0x01));

                     ir_variable *const r24E4 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r24E4, r24DD, 0x01));

                     ir_variable *const r24E5 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r24E5, r24DE, 0x01));

                     ir_variable *const r24E6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r24E6);
                     ir_variable *const r24E7 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r24E7);
                     /* IF CONDITION */
                     ir_expression *const r24E9 = equal(r24DD, body.constant(0u));
                     ir_if *f24E8 = new(mem_ctx) ir_if(operand(r24E9).val);
                     exec_list *const f24E8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f24E8->then_instructions;

                        body.emit(assign(r24E4, r24DE, 0x01));

                        body.emit(assign(r24E5, body.constant(0u), 0x01));

                        body.emit(assign(r24E3, add(r24E3, body.constant(int(-32))), 0x01));


                     body.instructions = f24E8_parent_instructions;
                     body.emit(f24E8);

                     /* END IF */

                     ir_variable *const r24EA = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r24EA, r24E4, 0x01));

                     ir_variable *const r24EB = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r24EC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r24EC);
                     /* IF CONDITION */
                     ir_expression *const r24EE = equal(r24E4, body.constant(0u));
                     ir_if *f24ED = new(mem_ctx) ir_if(operand(r24EE).val);
                     exec_list *const f24ED_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f24ED->then_instructions;

                        body.emit(assign(r24EB, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f24ED->else_instructions;

                        body.emit(assign(r24EC, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r24F0 = bit_and(r24E4, body.constant(4294901760u));
                        ir_expression *const r24F1 = equal(r24F0, body.constant(0u));
                        ir_if *f24EF = new(mem_ctx) ir_if(operand(r24F1).val);
                        exec_list *const f24EF_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f24EF->then_instructions;

                           body.emit(assign(r24EC, body.constant(int(16)), 0x01));

                           body.emit(assign(r24EA, lshift(r24E4, body.constant(int(16))), 0x01));


                        body.instructions = f24EF_parent_instructions;
                        body.emit(f24EF);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r24F3 = bit_and(r24EA, body.constant(4278190080u));
                        ir_expression *const r24F4 = equal(r24F3, body.constant(0u));
                        ir_if *f24F2 = new(mem_ctx) ir_if(operand(r24F4).val);
                        exec_list *const f24F2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f24F2->then_instructions;

                           body.emit(assign(r24EC, add(r24EC, body.constant(int(8))), 0x01));

                           body.emit(assign(r24EA, lshift(r24EA, body.constant(int(8))), 0x01));


                        body.instructions = f24F2_parent_instructions;
                        body.emit(f24F2);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r24F6 = bit_and(r24EA, body.constant(4026531840u));
                        ir_expression *const r24F7 = equal(r24F6, body.constant(0u));
                        ir_if *f24F5 = new(mem_ctx) ir_if(operand(r24F7).val);
                        exec_list *const f24F5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f24F5->then_instructions;

                           body.emit(assign(r24EC, add(r24EC, body.constant(int(4))), 0x01));

                           body.emit(assign(r24EA, lshift(r24EA, body.constant(int(4))), 0x01));


                        body.instructions = f24F5_parent_instructions;
                        body.emit(f24F5);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r24F9 = bit_and(r24EA, body.constant(3221225472u));
                        ir_expression *const r24FA = equal(r24F9, body.constant(0u));
                        ir_if *f24F8 = new(mem_ctx) ir_if(operand(r24FA).val);
                        exec_list *const f24F8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f24F8->then_instructions;

                           body.emit(assign(r24EC, add(r24EC, body.constant(int(2))), 0x01));

                           body.emit(assign(r24EA, lshift(r24EA, body.constant(int(2))), 0x01));


                        body.instructions = f24F8_parent_instructions;
                        body.emit(f24F8);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r24FC = bit_and(r24EA, body.constant(2147483648u));
                        ir_expression *const r24FD = equal(r24FC, body.constant(0u));
                        ir_if *f24FB = new(mem_ctx) ir_if(operand(r24FD).val);
                        exec_list *const f24FB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f24FB->then_instructions;

                           body.emit(assign(r24EC, add(r24EC, body.constant(int(1))), 0x01));


                        body.instructions = f24FB_parent_instructions;
                        body.emit(f24FB);

                        /* END IF */

                        body.emit(assign(r24EB, r24EC, 0x01));


                     body.instructions = f24ED_parent_instructions;
                     body.emit(f24ED);

                     /* END IF */

                     body.emit(assign(r24E7, add(r24EB, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r24FF = lequal(body.constant(int(0)), r24E7);
                     ir_if *f24FE = new(mem_ctx) ir_if(operand(r24FF).val);
                     exec_list *const f24FE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f24FE->then_instructions;

                        body.emit(assign(r24E6, body.constant(0u), 0x01));

                        ir_variable *const r2500 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r2500, lshift(r24E5, r24E7), 0x01));

                        ir_variable *const r2501 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2503 = equal(r24E7, body.constant(int(0)));
                        ir_if *f2502 = new(mem_ctx) ir_if(operand(r2503).val);
                        exec_list *const f2502_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2502->then_instructions;

                           body.emit(assign(r2501, r24E4, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2502->else_instructions;

                           ir_expression *const r2504 = lshift(r24E4, r24E7);
                           ir_expression *const r2505 = neg(r24E7);
                           ir_expression *const r2506 = bit_and(r2505, body.constant(int(31)));
                           ir_expression *const r2507 = rshift(r24E5, r2506);
                           body.emit(assign(r2501, bit_or(r2504, r2507), 0x01));


                        body.instructions = f2502_parent_instructions;
                        body.emit(f2502);

                        /* END IF */

                        body.emit(assign(r24E4, r2501, 0x01));

                        body.emit(assign(r24E5, r2500, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f24FE->else_instructions;

                        ir_variable *const r2508 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2508, body.constant(0u), 0x01));

                        ir_variable *const r2509 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2509, neg(r24E7), 0x01));

                        ir_variable *const r250A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r250A);
                        ir_variable *const r250B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r250B);
                        ir_variable *const r250C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r250C);
                        ir_variable *const r250D = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r250E = neg(r2509);
                        body.emit(assign(r250D, bit_and(r250E, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2510 = equal(r2509, body.constant(int(0)));
                        ir_if *f250F = new(mem_ctx) ir_if(operand(r2510).val);
                        exec_list *const f250F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f250F->then_instructions;

                           body.emit(assign(r250A, r2508, 0x01));

                           body.emit(assign(r250B, r24E5, 0x01));

                           body.emit(assign(r250C, r24E4, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f250F->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2512 = less(r2509, body.constant(int(32)));
                           ir_if *f2511 = new(mem_ctx) ir_if(operand(r2512).val);
                           exec_list *const f2511_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2511->then_instructions;

                              body.emit(assign(r250A, lshift(r24E5, r250D), 0x01));

                              ir_expression *const r2513 = lshift(r24E4, r250D);
                              ir_expression *const r2514 = rshift(r24E5, r2509);
                              body.emit(assign(r250B, bit_or(r2513, r2514), 0x01));

                              body.emit(assign(r250C, rshift(r24E4, r2509), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2511->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2516 = equal(r2509, body.constant(int(32)));
                              ir_if *f2515 = new(mem_ctx) ir_if(operand(r2516).val);
                              exec_list *const f2515_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2515->then_instructions;

                                 body.emit(assign(r250A, r24E5, 0x01));

                                 body.emit(assign(r250B, r24E4, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2515->else_instructions;

                                 body.emit(assign(r2508, bit_or(body.constant(0u), r24E5), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2518 = less(r2509, body.constant(int(64)));
                                 ir_if *f2517 = new(mem_ctx) ir_if(operand(r2518).val);
                                 exec_list *const f2517_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2517->then_instructions;

                                    body.emit(assign(r250A, lshift(r24E4, r250D), 0x01));

                                    ir_expression *const r2519 = bit_and(r2509, body.constant(int(31)));
                                    body.emit(assign(r250B, rshift(r24E4, r2519), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2517->else_instructions;

                                    ir_variable *const r251A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r251C = equal(r2509, body.constant(int(64)));
                                    ir_if *f251B = new(mem_ctx) ir_if(operand(r251C).val);
                                    exec_list *const f251B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f251B->then_instructions;

                                       body.emit(assign(r251A, r24E4, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f251B->else_instructions;

                                       ir_expression *const r251D = nequal(r24E4, body.constant(0u));
                                       ir_expression *const r251E = expr(ir_unop_b2i, r251D);
                                       body.emit(assign(r251A, expr(ir_unop_i2u, r251E), 0x01));


                                    body.instructions = f251B_parent_instructions;
                                    body.emit(f251B);

                                    /* END IF */

                                    body.emit(assign(r250A, r251A, 0x01));

                                    body.emit(assign(r250B, body.constant(0u), 0x01));


                                 body.instructions = f2517_parent_instructions;
                                 body.emit(f2517);

                                 /* END IF */


                              body.instructions = f2515_parent_instructions;
                              body.emit(f2515);

                              /* END IF */

                              body.emit(assign(r250C, body.constant(0u), 0x01));


                           body.instructions = f2511_parent_instructions;
                           body.emit(f2511);

                           /* END IF */

                           ir_expression *const r251F = nequal(r2508, body.constant(0u));
                           ir_expression *const r2520 = expr(ir_unop_b2i, r251F);
                           ir_expression *const r2521 = expr(ir_unop_i2u, r2520);
                           body.emit(assign(r250A, bit_or(r250A, r2521), 0x01));


                        body.instructions = f250F_parent_instructions;
                        body.emit(f250F);

                        /* END IF */

                        body.emit(assign(r24E4, r250C, 0x01));

                        body.emit(assign(r24E5, r250B, 0x01));

                        body.emit(assign(r24E6, r250A, 0x01));


                     body.instructions = f24FE_parent_instructions;
                     body.emit(f24FE);

                     /* END IF */

                     body.emit(assign(r24E3, sub(r24E3, r24E7), 0x01));

                     ir_variable *const r2522 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r2522, r24E3, 0x01));

                     ir_variable *const r2523 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r2523, r24E4, 0x01));

                     ir_variable *const r2524 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r2524, r24E5, 0x01));

                     ir_variable *const r2525 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r2525, r24E6, 0x01));

                     ir_variable *const r2526 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r2526, body.constant(true), 0x01));

                     ir_variable *const r2527 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r2528 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r2528);
                     ir_expression *const r2529 = expr(ir_unop_u2i, r24E6);
                     body.emit(assign(r2528, less(r2529, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r252B = lequal(body.constant(int(2045)), r24E3);
                     ir_if *f252A = new(mem_ctx) ir_if(operand(r252B).val);
                     exec_list *const f252A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f252A->then_instructions;

                        ir_variable *const r252C = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r252E = less(body.constant(int(2045)), r24E3);
                        ir_if *f252D = new(mem_ctx) ir_if(operand(r252E).val);
                        exec_list *const f252D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f252D->then_instructions;

                           body.emit(assign(r252C, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f252D->else_instructions;

                           ir_variable *const r252F = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2531 = equal(r24E3, body.constant(int(2045)));
                           ir_if *f2530 = new(mem_ctx) ir_if(operand(r2531).val);
                           exec_list *const f2530_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2530->then_instructions;

                              ir_expression *const r2532 = equal(body.constant(2097151u), r24E4);
                              ir_expression *const r2533 = equal(body.constant(4294967295u), r24E5);
                              body.emit(assign(r252F, logic_and(r2532, r2533), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2530->else_instructions;

                              body.emit(assign(r252F, body.constant(false), 0x01));


                           body.instructions = f2530_parent_instructions;
                           body.emit(f2530);

                           /* END IF */

                           body.emit(assign(r252C, logic_and(r252F, r2528), 0x01));


                        body.instructions = f252D_parent_instructions;
                        body.emit(f252D);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f2534 = new(mem_ctx) ir_if(operand(r252C).val);
                        exec_list *const f2534_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2534->then_instructions;

                           ir_variable *const r2535 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r2535);
                           ir_expression *const r2536 = lshift(r2351, body.constant(int(31)));
                           body.emit(assign(r2535, add(r2536, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r2535, body.constant(0u), 0x01));

                           body.emit(assign(r2527, r2535, 0x03));

                           body.emit(assign(r2526, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2534->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2538 = less(r24E3, body.constant(int(0)));
                           ir_if *f2537 = new(mem_ctx) ir_if(operand(r2538).val);
                           exec_list *const f2537_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2537->then_instructions;

                              ir_variable *const r2539 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r2539, r24E6, 0x01));

                              ir_variable *const r253A = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r253A, neg(r24E3), 0x01));

                              ir_variable *const r253B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r253B);
                              ir_variable *const r253C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r253C);
                              ir_variable *const r253D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r253D);
                              ir_variable *const r253E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r253F = neg(r253A);
                              body.emit(assign(r253E, bit_and(r253F, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2541 = equal(r253A, body.constant(int(0)));
                              ir_if *f2540 = new(mem_ctx) ir_if(operand(r2541).val);
                              exec_list *const f2540_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2540->then_instructions;

                                 body.emit(assign(r253B, r24E6, 0x01));

                                 body.emit(assign(r253C, r24E5, 0x01));

                                 body.emit(assign(r253D, r24E4, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2540->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2543 = less(r253A, body.constant(int(32)));
                                 ir_if *f2542 = new(mem_ctx) ir_if(operand(r2543).val);
                                 exec_list *const f2542_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2542->then_instructions;

                                    body.emit(assign(r253B, lshift(r24E5, r253E), 0x01));

                                    ir_expression *const r2544 = lshift(r24E4, r253E);
                                    ir_expression *const r2545 = rshift(r24E5, r253A);
                                    body.emit(assign(r253C, bit_or(r2544, r2545), 0x01));

                                    body.emit(assign(r253D, rshift(r24E4, r253A), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2542->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2547 = equal(r253A, body.constant(int(32)));
                                    ir_if *f2546 = new(mem_ctx) ir_if(operand(r2547).val);
                                    exec_list *const f2546_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2546->then_instructions;

                                       body.emit(assign(r253B, r24E5, 0x01));

                                       body.emit(assign(r253C, r24E4, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2546->else_instructions;

                                       body.emit(assign(r2539, bit_or(r24E6, r24E5), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2549 = less(r253A, body.constant(int(64)));
                                       ir_if *f2548 = new(mem_ctx) ir_if(operand(r2549).val);
                                       exec_list *const f2548_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2548->then_instructions;

                                          body.emit(assign(r253B, lshift(r24E4, r253E), 0x01));

                                          ir_expression *const r254A = bit_and(r253A, body.constant(int(31)));
                                          body.emit(assign(r253C, rshift(r24E4, r254A), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2548->else_instructions;

                                          ir_variable *const r254B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r254D = equal(r253A, body.constant(int(64)));
                                          ir_if *f254C = new(mem_ctx) ir_if(operand(r254D).val);
                                          exec_list *const f254C_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f254C->then_instructions;

                                             body.emit(assign(r254B, r24E4, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f254C->else_instructions;

                                             ir_expression *const r254E = nequal(r24E4, body.constant(0u));
                                             ir_expression *const r254F = expr(ir_unop_b2i, r254E);
                                             body.emit(assign(r254B, expr(ir_unop_i2u, r254F), 0x01));


                                          body.instructions = f254C_parent_instructions;
                                          body.emit(f254C);

                                          /* END IF */

                                          body.emit(assign(r253B, r254B, 0x01));

                                          body.emit(assign(r253C, body.constant(0u), 0x01));


                                       body.instructions = f2548_parent_instructions;
                                       body.emit(f2548);

                                       /* END IF */


                                    body.instructions = f2546_parent_instructions;
                                    body.emit(f2546);

                                    /* END IF */

                                    body.emit(assign(r253D, body.constant(0u), 0x01));


                                 body.instructions = f2542_parent_instructions;
                                 body.emit(f2542);

                                 /* END IF */

                                 ir_expression *const r2550 = nequal(r2539, body.constant(0u));
                                 ir_expression *const r2551 = expr(ir_unop_b2i, r2550);
                                 ir_expression *const r2552 = expr(ir_unop_i2u, r2551);
                                 body.emit(assign(r253B, bit_or(r253B, r2552), 0x01));


                              body.instructions = f2540_parent_instructions;
                              body.emit(f2540);

                              /* END IF */

                              body.emit(assign(r2523, r253D, 0x01));

                              body.emit(assign(r2524, r253C, 0x01));

                              body.emit(assign(r2525, r253B, 0x01));

                              body.emit(assign(r2522, body.constant(int(0)), 0x01));

                              body.emit(assign(r2528, less(r253B, body.constant(0u)), 0x01));


                           body.instructions = f2537_parent_instructions;
                           body.emit(f2537);

                           /* END IF */


                        body.instructions = f2534_parent_instructions;
                        body.emit(f2534);

                        /* END IF */


                     body.instructions = f252A_parent_instructions;
                     body.emit(f252A);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f2553 = new(mem_ctx) ir_if(operand(r2526).val);
                     exec_list *const f2553_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2553->then_instructions;

                        /* IF CONDITION */
                        ir_if *f2554 = new(mem_ctx) ir_if(operand(r2528).val);
                        exec_list *const f2554_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2554->then_instructions;

                           ir_variable *const r2555 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r2555, add(r2524, body.constant(1u)), 0x01));

                           ir_expression *const r2556 = less(r2555, r2524);
                           ir_expression *const r2557 = expr(ir_unop_b2i, r2556);
                           ir_expression *const r2558 = expr(ir_unop_i2u, r2557);
                           body.emit(assign(r2523, add(r2523, r2558), 0x01));

                           ir_expression *const r2559 = equal(r2525, body.constant(0u));
                           ir_expression *const r255A = expr(ir_unop_b2i, r2559);
                           ir_expression *const r255B = expr(ir_unop_i2u, r255A);
                           ir_expression *const r255C = add(r2525, r255B);
                           ir_expression *const r255D = bit_and(r255C, body.constant(1u));
                           ir_expression *const r255E = expr(ir_unop_bit_not, r255D);
                           body.emit(assign(r2524, bit_and(r2555, r255E), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2554->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2560 = bit_or(r2523, r2524);
                           ir_expression *const r2561 = equal(r2560, body.constant(0u));
                           ir_if *f255F = new(mem_ctx) ir_if(operand(r2561).val);
                           exec_list *const f255F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f255F->then_instructions;

                              body.emit(assign(r2522, body.constant(int(0)), 0x01));


                           body.instructions = f255F_parent_instructions;
                           body.emit(f255F);

                           /* END IF */


                        body.instructions = f2554_parent_instructions;
                        body.emit(f2554);

                        /* END IF */

                        ir_variable *const r2562 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r2562);
                        ir_expression *const r2563 = lshift(r2351, body.constant(int(31)));
                        ir_expression *const r2564 = expr(ir_unop_i2u, r2522);
                        ir_expression *const r2565 = lshift(r2564, body.constant(int(20)));
                        ir_expression *const r2566 = add(r2563, r2565);
                        body.emit(assign(r2562, add(r2566, r2523), 0x02));

                        body.emit(assign(r2562, r2524, 0x01));

                        body.emit(assign(r2527, r2562, 0x03));

                        body.emit(assign(r2526, body.constant(false), 0x01));


                     body.instructions = f2553_parent_instructions;
                     body.emit(f2553);

                     /* END IF */

                     body.emit(assign(r2352, r2527, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f24DB->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2568 = less(r2358, r2356);
                     ir_if *f2567 = new(mem_ctx) ir_if(operand(r2568).val);
                     exec_list *const f2567_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2567->then_instructions;

                        ir_variable *const r2569 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r256A = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r256A, sub(r2357, r2359), 0x01));

                        ir_expression *const r256B = sub(r2356, r2358);
                        ir_expression *const r256C = less(r2357, r2359);
                        ir_expression *const r256D = expr(ir_unop_b2i, r256C);
                        ir_expression *const r256E = expr(ir_unop_i2u, r256D);
                        body.emit(assign(r2569, sub(r256B, r256E), 0x01));

                        body.emit(assign(r2351, bit_xor(r2351, body.constant(1u)), 0x01));

                        body.emit(assign(r235A, add(r2354, body.constant(int(-1))), 0x01));

                        ir_variable *const r256F = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r256F, add(r235A, body.constant(int(-10))), 0x01));

                        ir_variable *const r2570 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r2570, r2569, 0x01));

                        ir_variable *const r2571 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r2571, r256A, 0x01));

                        ir_variable *const r2572 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r2572);
                        ir_variable *const r2573 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r2573);
                        /* IF CONDITION */
                        ir_expression *const r2575 = equal(r2569, body.constant(0u));
                        ir_if *f2574 = new(mem_ctx) ir_if(operand(r2575).val);
                        exec_list *const f2574_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2574->then_instructions;

                           body.emit(assign(r2570, r256A, 0x01));

                           body.emit(assign(r2571, body.constant(0u), 0x01));

                           body.emit(assign(r256F, add(r256F, body.constant(int(-32))), 0x01));


                        body.instructions = f2574_parent_instructions;
                        body.emit(f2574);

                        /* END IF */

                        ir_variable *const r2576 = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r2576, r2570, 0x01));

                        ir_variable *const r2577 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r2578 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r2578);
                        /* IF CONDITION */
                        ir_expression *const r257A = equal(r2570, body.constant(0u));
                        ir_if *f2579 = new(mem_ctx) ir_if(operand(r257A).val);
                        exec_list *const f2579_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2579->then_instructions;

                           body.emit(assign(r2577, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2579->else_instructions;

                           body.emit(assign(r2578, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r257C = bit_and(r2570, body.constant(4294901760u));
                           ir_expression *const r257D = equal(r257C, body.constant(0u));
                           ir_if *f257B = new(mem_ctx) ir_if(operand(r257D).val);
                           exec_list *const f257B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f257B->then_instructions;

                              body.emit(assign(r2578, body.constant(int(16)), 0x01));

                              body.emit(assign(r2576, lshift(r2570, body.constant(int(16))), 0x01));


                           body.instructions = f257B_parent_instructions;
                           body.emit(f257B);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r257F = bit_and(r2576, body.constant(4278190080u));
                           ir_expression *const r2580 = equal(r257F, body.constant(0u));
                           ir_if *f257E = new(mem_ctx) ir_if(operand(r2580).val);
                           exec_list *const f257E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f257E->then_instructions;

                              body.emit(assign(r2578, add(r2578, body.constant(int(8))), 0x01));

                              body.emit(assign(r2576, lshift(r2576, body.constant(int(8))), 0x01));


                           body.instructions = f257E_parent_instructions;
                           body.emit(f257E);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2582 = bit_and(r2576, body.constant(4026531840u));
                           ir_expression *const r2583 = equal(r2582, body.constant(0u));
                           ir_if *f2581 = new(mem_ctx) ir_if(operand(r2583).val);
                           exec_list *const f2581_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2581->then_instructions;

                              body.emit(assign(r2578, add(r2578, body.constant(int(4))), 0x01));

                              body.emit(assign(r2576, lshift(r2576, body.constant(int(4))), 0x01));


                           body.instructions = f2581_parent_instructions;
                           body.emit(f2581);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2585 = bit_and(r2576, body.constant(3221225472u));
                           ir_expression *const r2586 = equal(r2585, body.constant(0u));
                           ir_if *f2584 = new(mem_ctx) ir_if(operand(r2586).val);
                           exec_list *const f2584_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2584->then_instructions;

                              body.emit(assign(r2578, add(r2578, body.constant(int(2))), 0x01));

                              body.emit(assign(r2576, lshift(r2576, body.constant(int(2))), 0x01));


                           body.instructions = f2584_parent_instructions;
                           body.emit(f2584);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2588 = bit_and(r2576, body.constant(2147483648u));
                           ir_expression *const r2589 = equal(r2588, body.constant(0u));
                           ir_if *f2587 = new(mem_ctx) ir_if(operand(r2589).val);
                           exec_list *const f2587_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2587->then_instructions;

                              body.emit(assign(r2578, add(r2578, body.constant(int(1))), 0x01));


                           body.instructions = f2587_parent_instructions;
                           body.emit(f2587);

                           /* END IF */

                           body.emit(assign(r2577, r2578, 0x01));


                        body.instructions = f2579_parent_instructions;
                        body.emit(f2579);

                        /* END IF */

                        body.emit(assign(r2573, add(r2577, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r258B = lequal(body.constant(int(0)), r2573);
                        ir_if *f258A = new(mem_ctx) ir_if(operand(r258B).val);
                        exec_list *const f258A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f258A->then_instructions;

                           body.emit(assign(r2572, body.constant(0u), 0x01));

                           ir_variable *const r258C = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r258C, lshift(r2571, r2573), 0x01));

                           ir_variable *const r258D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r258F = equal(r2573, body.constant(int(0)));
                           ir_if *f258E = new(mem_ctx) ir_if(operand(r258F).val);
                           exec_list *const f258E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f258E->then_instructions;

                              body.emit(assign(r258D, r2570, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f258E->else_instructions;

                              ir_expression *const r2590 = lshift(r2570, r2573);
                              ir_expression *const r2591 = neg(r2573);
                              ir_expression *const r2592 = bit_and(r2591, body.constant(int(31)));
                              ir_expression *const r2593 = rshift(r2571, r2592);
                              body.emit(assign(r258D, bit_or(r2590, r2593), 0x01));


                           body.instructions = f258E_parent_instructions;
                           body.emit(f258E);

                           /* END IF */

                           body.emit(assign(r2570, r258D, 0x01));

                           body.emit(assign(r2571, r258C, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f258A->else_instructions;

                           ir_variable *const r2594 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r2594, body.constant(0u), 0x01));

                           ir_variable *const r2595 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r2595, neg(r2573), 0x01));

                           ir_variable *const r2596 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r2596);
                           ir_variable *const r2597 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r2597);
                           ir_variable *const r2598 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r2598);
                           ir_variable *const r2599 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r259A = neg(r2595);
                           body.emit(assign(r2599, bit_and(r259A, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r259C = equal(r2595, body.constant(int(0)));
                           ir_if *f259B = new(mem_ctx) ir_if(operand(r259C).val);
                           exec_list *const f259B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f259B->then_instructions;

                              body.emit(assign(r2596, r2594, 0x01));

                              body.emit(assign(r2597, r2571, 0x01));

                              body.emit(assign(r2598, r2570, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f259B->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r259E = less(r2595, body.constant(int(32)));
                              ir_if *f259D = new(mem_ctx) ir_if(operand(r259E).val);
                              exec_list *const f259D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f259D->then_instructions;

                                 body.emit(assign(r2596, lshift(r2571, r2599), 0x01));

                                 ir_expression *const r259F = lshift(r2570, r2599);
                                 ir_expression *const r25A0 = rshift(r2571, r2595);
                                 body.emit(assign(r2597, bit_or(r259F, r25A0), 0x01));

                                 body.emit(assign(r2598, rshift(r2570, r2595), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f259D->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r25A2 = equal(r2595, body.constant(int(32)));
                                 ir_if *f25A1 = new(mem_ctx) ir_if(operand(r25A2).val);
                                 exec_list *const f25A1_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f25A1->then_instructions;

                                    body.emit(assign(r2596, r2571, 0x01));

                                    body.emit(assign(r2597, r2570, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f25A1->else_instructions;

                                    body.emit(assign(r2594, bit_or(body.constant(0u), r2571), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r25A4 = less(r2595, body.constant(int(64)));
                                    ir_if *f25A3 = new(mem_ctx) ir_if(operand(r25A4).val);
                                    exec_list *const f25A3_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f25A3->then_instructions;

                                       body.emit(assign(r2596, lshift(r2570, r2599), 0x01));

                                       ir_expression *const r25A5 = bit_and(r2595, body.constant(int(31)));
                                       body.emit(assign(r2597, rshift(r2570, r25A5), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f25A3->else_instructions;

                                       ir_variable *const r25A6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r25A8 = equal(r2595, body.constant(int(64)));
                                       ir_if *f25A7 = new(mem_ctx) ir_if(operand(r25A8).val);
                                       exec_list *const f25A7_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f25A7->then_instructions;

                                          body.emit(assign(r25A6, r2570, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f25A7->else_instructions;

                                          ir_expression *const r25A9 = nequal(r2570, body.constant(0u));
                                          ir_expression *const r25AA = expr(ir_unop_b2i, r25A9);
                                          body.emit(assign(r25A6, expr(ir_unop_i2u, r25AA), 0x01));


                                       body.instructions = f25A7_parent_instructions;
                                       body.emit(f25A7);

                                       /* END IF */

                                       body.emit(assign(r2596, r25A6, 0x01));

                                       body.emit(assign(r2597, body.constant(0u), 0x01));


                                    body.instructions = f25A3_parent_instructions;
                                    body.emit(f25A3);

                                    /* END IF */


                                 body.instructions = f25A1_parent_instructions;
                                 body.emit(f25A1);

                                 /* END IF */

                                 body.emit(assign(r2598, body.constant(0u), 0x01));


                              body.instructions = f259D_parent_instructions;
                              body.emit(f259D);

                              /* END IF */

                              ir_expression *const r25AB = nequal(r2594, body.constant(0u));
                              ir_expression *const r25AC = expr(ir_unop_b2i, r25AB);
                              ir_expression *const r25AD = expr(ir_unop_i2u, r25AC);
                              body.emit(assign(r2596, bit_or(r2596, r25AD), 0x01));


                           body.instructions = f259B_parent_instructions;
                           body.emit(f259B);

                           /* END IF */

                           body.emit(assign(r2570, r2598, 0x01));

                           body.emit(assign(r2571, r2597, 0x01));

                           body.emit(assign(r2572, r2596, 0x01));


                        body.instructions = f258A_parent_instructions;
                        body.emit(f258A);

                        /* END IF */

                        body.emit(assign(r256F, sub(r256F, r2573), 0x01));

                        ir_variable *const r25AE = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r25AE, r256F, 0x01));

                        ir_variable *const r25AF = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r25AF, r2570, 0x01));

                        ir_variable *const r25B0 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r25B0, r2571, 0x01));

                        ir_variable *const r25B1 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r25B1, r2572, 0x01));

                        ir_variable *const r25B2 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r25B2, body.constant(true), 0x01));

                        ir_variable *const r25B3 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r25B4 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r25B4);
                        ir_expression *const r25B5 = expr(ir_unop_u2i, r2572);
                        body.emit(assign(r25B4, less(r25B5, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r25B7 = lequal(body.constant(int(2045)), r256F);
                        ir_if *f25B6 = new(mem_ctx) ir_if(operand(r25B7).val);
                        exec_list *const f25B6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f25B6->then_instructions;

                           ir_variable *const r25B8 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r25BA = less(body.constant(int(2045)), r256F);
                           ir_if *f25B9 = new(mem_ctx) ir_if(operand(r25BA).val);
                           exec_list *const f25B9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f25B9->then_instructions;

                              body.emit(assign(r25B8, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f25B9->else_instructions;

                              ir_variable *const r25BB = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r25BD = equal(r256F, body.constant(int(2045)));
                              ir_if *f25BC = new(mem_ctx) ir_if(operand(r25BD).val);
                              exec_list *const f25BC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f25BC->then_instructions;

                                 ir_expression *const r25BE = equal(body.constant(2097151u), r2570);
                                 ir_expression *const r25BF = equal(body.constant(4294967295u), r2571);
                                 body.emit(assign(r25BB, logic_and(r25BE, r25BF), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f25BC->else_instructions;

                                 body.emit(assign(r25BB, body.constant(false), 0x01));


                              body.instructions = f25BC_parent_instructions;
                              body.emit(f25BC);

                              /* END IF */

                              body.emit(assign(r25B8, logic_and(r25BB, r25B4), 0x01));


                           body.instructions = f25B9_parent_instructions;
                           body.emit(f25B9);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f25C0 = new(mem_ctx) ir_if(operand(r25B8).val);
                           exec_list *const f25C0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f25C0->then_instructions;

                              ir_variable *const r25C1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r25C1);
                              ir_expression *const r25C2 = lshift(r2351, body.constant(int(31)));
                              body.emit(assign(r25C1, add(r25C2, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r25C1, body.constant(0u), 0x01));

                              body.emit(assign(r25B3, r25C1, 0x03));

                              body.emit(assign(r25B2, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f25C0->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r25C4 = less(r256F, body.constant(int(0)));
                              ir_if *f25C3 = new(mem_ctx) ir_if(operand(r25C4).val);
                              exec_list *const f25C3_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f25C3->then_instructions;

                                 ir_variable *const r25C5 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r25C5, r2572, 0x01));

                                 ir_variable *const r25C6 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r25C6, neg(r256F), 0x01));

                                 ir_variable *const r25C7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r25C7);
                                 ir_variable *const r25C8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r25C8);
                                 ir_variable *const r25C9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r25C9);
                                 ir_variable *const r25CA = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r25CB = neg(r25C6);
                                 body.emit(assign(r25CA, bit_and(r25CB, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r25CD = equal(r25C6, body.constant(int(0)));
                                 ir_if *f25CC = new(mem_ctx) ir_if(operand(r25CD).val);
                                 exec_list *const f25CC_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f25CC->then_instructions;

                                    body.emit(assign(r25C7, r2572, 0x01));

                                    body.emit(assign(r25C8, r2571, 0x01));

                                    body.emit(assign(r25C9, r2570, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f25CC->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r25CF = less(r25C6, body.constant(int(32)));
                                    ir_if *f25CE = new(mem_ctx) ir_if(operand(r25CF).val);
                                    exec_list *const f25CE_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f25CE->then_instructions;

                                       body.emit(assign(r25C7, lshift(r2571, r25CA), 0x01));

                                       ir_expression *const r25D0 = lshift(r2570, r25CA);
                                       ir_expression *const r25D1 = rshift(r2571, r25C6);
                                       body.emit(assign(r25C8, bit_or(r25D0, r25D1), 0x01));

                                       body.emit(assign(r25C9, rshift(r2570, r25C6), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f25CE->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r25D3 = equal(r25C6, body.constant(int(32)));
                                       ir_if *f25D2 = new(mem_ctx) ir_if(operand(r25D3).val);
                                       exec_list *const f25D2_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f25D2->then_instructions;

                                          body.emit(assign(r25C7, r2571, 0x01));

                                          body.emit(assign(r25C8, r2570, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f25D2->else_instructions;

                                          body.emit(assign(r25C5, bit_or(r2572, r2571), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r25D5 = less(r25C6, body.constant(int(64)));
                                          ir_if *f25D4 = new(mem_ctx) ir_if(operand(r25D5).val);
                                          exec_list *const f25D4_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f25D4->then_instructions;

                                             body.emit(assign(r25C7, lshift(r2570, r25CA), 0x01));

                                             ir_expression *const r25D6 = bit_and(r25C6, body.constant(int(31)));
                                             body.emit(assign(r25C8, rshift(r2570, r25D6), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f25D4->else_instructions;

                                             ir_variable *const r25D7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r25D9 = equal(r25C6, body.constant(int(64)));
                                             ir_if *f25D8 = new(mem_ctx) ir_if(operand(r25D9).val);
                                             exec_list *const f25D8_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f25D8->then_instructions;

                                                body.emit(assign(r25D7, r2570, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f25D8->else_instructions;

                                                ir_expression *const r25DA = nequal(r2570, body.constant(0u));
                                                ir_expression *const r25DB = expr(ir_unop_b2i, r25DA);
                                                body.emit(assign(r25D7, expr(ir_unop_i2u, r25DB), 0x01));


                                             body.instructions = f25D8_parent_instructions;
                                             body.emit(f25D8);

                                             /* END IF */

                                             body.emit(assign(r25C7, r25D7, 0x01));

                                             body.emit(assign(r25C8, body.constant(0u), 0x01));


                                          body.instructions = f25D4_parent_instructions;
                                          body.emit(f25D4);

                                          /* END IF */


                                       body.instructions = f25D2_parent_instructions;
                                       body.emit(f25D2);

                                       /* END IF */

                                       body.emit(assign(r25C9, body.constant(0u), 0x01));


                                    body.instructions = f25CE_parent_instructions;
                                    body.emit(f25CE);

                                    /* END IF */

                                    ir_expression *const r25DC = nequal(r25C5, body.constant(0u));
                                    ir_expression *const r25DD = expr(ir_unop_b2i, r25DC);
                                    ir_expression *const r25DE = expr(ir_unop_i2u, r25DD);
                                    body.emit(assign(r25C7, bit_or(r25C7, r25DE), 0x01));


                                 body.instructions = f25CC_parent_instructions;
                                 body.emit(f25CC);

                                 /* END IF */

                                 body.emit(assign(r25AF, r25C9, 0x01));

                                 body.emit(assign(r25B0, r25C8, 0x01));

                                 body.emit(assign(r25B1, r25C7, 0x01));

                                 body.emit(assign(r25AE, body.constant(int(0)), 0x01));

                                 body.emit(assign(r25B4, less(r25C7, body.constant(0u)), 0x01));


                              body.instructions = f25C3_parent_instructions;
                              body.emit(f25C3);

                              /* END IF */


                           body.instructions = f25C0_parent_instructions;
                           body.emit(f25C0);

                           /* END IF */


                        body.instructions = f25B6_parent_instructions;
                        body.emit(f25B6);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f25DF = new(mem_ctx) ir_if(operand(r25B2).val);
                        exec_list *const f25DF_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f25DF->then_instructions;

                           /* IF CONDITION */
                           ir_if *f25E0 = new(mem_ctx) ir_if(operand(r25B4).val);
                           exec_list *const f25E0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f25E0->then_instructions;

                              ir_variable *const r25E1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r25E1, add(r25B0, body.constant(1u)), 0x01));

                              ir_expression *const r25E2 = less(r25E1, r25B0);
                              ir_expression *const r25E3 = expr(ir_unop_b2i, r25E2);
                              ir_expression *const r25E4 = expr(ir_unop_i2u, r25E3);
                              body.emit(assign(r25AF, add(r25AF, r25E4), 0x01));

                              ir_expression *const r25E5 = equal(r25B1, body.constant(0u));
                              ir_expression *const r25E6 = expr(ir_unop_b2i, r25E5);
                              ir_expression *const r25E7 = expr(ir_unop_i2u, r25E6);
                              ir_expression *const r25E8 = add(r25B1, r25E7);
                              ir_expression *const r25E9 = bit_and(r25E8, body.constant(1u));
                              ir_expression *const r25EA = expr(ir_unop_bit_not, r25E9);
                              body.emit(assign(r25B0, bit_and(r25E1, r25EA), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f25E0->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r25EC = bit_or(r25AF, r25B0);
                              ir_expression *const r25ED = equal(r25EC, body.constant(0u));
                              ir_if *f25EB = new(mem_ctx) ir_if(operand(r25ED).val);
                              exec_list *const f25EB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f25EB->then_instructions;

                                 body.emit(assign(r25AE, body.constant(int(0)), 0x01));


                              body.instructions = f25EB_parent_instructions;
                              body.emit(f25EB);

                              /* END IF */


                           body.instructions = f25E0_parent_instructions;
                           body.emit(f25E0);

                           /* END IF */

                           ir_variable *const r25EE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r25EE);
                           ir_expression *const r25EF = lshift(r2351, body.constant(int(31)));
                           ir_expression *const r25F0 = expr(ir_unop_i2u, r25AE);
                           ir_expression *const r25F1 = lshift(r25F0, body.constant(int(20)));
                           ir_expression *const r25F2 = add(r25EF, r25F1);
                           body.emit(assign(r25EE, add(r25F2, r25AF), 0x02));

                           body.emit(assign(r25EE, r25B0, 0x01));

                           body.emit(assign(r25B3, r25EE, 0x03));

                           body.emit(assign(r25B2, body.constant(false), 0x01));


                        body.instructions = f25DF_parent_instructions;
                        body.emit(f25DF);

                        /* END IF */

                        body.emit(assign(r2352, r25B3, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2567->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r25F4 = less(r2357, r2359);
                        ir_if *f25F3 = new(mem_ctx) ir_if(operand(r25F4).val);
                        exec_list *const f25F3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f25F3->then_instructions;

                           ir_variable *const r25F5 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r25F6 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r25F6, sub(r2359, r2357), 0x01));

                           ir_expression *const r25F7 = sub(r2358, r2356);
                           ir_expression *const r25F8 = less(r2359, r2357);
                           ir_expression *const r25F9 = expr(ir_unop_b2i, r25F8);
                           ir_expression *const r25FA = expr(ir_unop_i2u, r25F9);
                           body.emit(assign(r25F5, sub(r25F7, r25FA), 0x01));

                           body.emit(assign(r235A, add(r2355, body.constant(int(-1))), 0x01));

                           ir_variable *const r25FB = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r25FB, add(r235A, body.constant(int(-10))), 0x01));

                           ir_variable *const r25FC = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r25FC, r25F5, 0x01));

                           ir_variable *const r25FD = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r25FD, r25F6, 0x01));

                           ir_variable *const r25FE = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r25FE);
                           ir_variable *const r25FF = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r25FF);
                           /* IF CONDITION */
                           ir_expression *const r2601 = equal(r25F5, body.constant(0u));
                           ir_if *f2600 = new(mem_ctx) ir_if(operand(r2601).val);
                           exec_list *const f2600_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2600->then_instructions;

                              body.emit(assign(r25FC, r25F6, 0x01));

                              body.emit(assign(r25FD, body.constant(0u), 0x01));

                              body.emit(assign(r25FB, add(r25FB, body.constant(int(-32))), 0x01));


                           body.instructions = f2600_parent_instructions;
                           body.emit(f2600);

                           /* END IF */

                           ir_variable *const r2602 = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r2602, r25FC, 0x01));

                           ir_variable *const r2603 = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r2604 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r2604);
                           /* IF CONDITION */
                           ir_expression *const r2606 = equal(r25FC, body.constant(0u));
                           ir_if *f2605 = new(mem_ctx) ir_if(operand(r2606).val);
                           exec_list *const f2605_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2605->then_instructions;

                              body.emit(assign(r2603, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2605->else_instructions;

                              body.emit(assign(r2604, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2608 = bit_and(r25FC, body.constant(4294901760u));
                              ir_expression *const r2609 = equal(r2608, body.constant(0u));
                              ir_if *f2607 = new(mem_ctx) ir_if(operand(r2609).val);
                              exec_list *const f2607_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2607->then_instructions;

                                 body.emit(assign(r2604, body.constant(int(16)), 0x01));

                                 body.emit(assign(r2602, lshift(r25FC, body.constant(int(16))), 0x01));


                              body.instructions = f2607_parent_instructions;
                              body.emit(f2607);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r260B = bit_and(r2602, body.constant(4278190080u));
                              ir_expression *const r260C = equal(r260B, body.constant(0u));
                              ir_if *f260A = new(mem_ctx) ir_if(operand(r260C).val);
                              exec_list *const f260A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f260A->then_instructions;

                                 body.emit(assign(r2604, add(r2604, body.constant(int(8))), 0x01));

                                 body.emit(assign(r2602, lshift(r2602, body.constant(int(8))), 0x01));


                              body.instructions = f260A_parent_instructions;
                              body.emit(f260A);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r260E = bit_and(r2602, body.constant(4026531840u));
                              ir_expression *const r260F = equal(r260E, body.constant(0u));
                              ir_if *f260D = new(mem_ctx) ir_if(operand(r260F).val);
                              exec_list *const f260D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f260D->then_instructions;

                                 body.emit(assign(r2604, add(r2604, body.constant(int(4))), 0x01));

                                 body.emit(assign(r2602, lshift(r2602, body.constant(int(4))), 0x01));


                              body.instructions = f260D_parent_instructions;
                              body.emit(f260D);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2611 = bit_and(r2602, body.constant(3221225472u));
                              ir_expression *const r2612 = equal(r2611, body.constant(0u));
                              ir_if *f2610 = new(mem_ctx) ir_if(operand(r2612).val);
                              exec_list *const f2610_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2610->then_instructions;

                                 body.emit(assign(r2604, add(r2604, body.constant(int(2))), 0x01));

                                 body.emit(assign(r2602, lshift(r2602, body.constant(int(2))), 0x01));


                              body.instructions = f2610_parent_instructions;
                              body.emit(f2610);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2614 = bit_and(r2602, body.constant(2147483648u));
                              ir_expression *const r2615 = equal(r2614, body.constant(0u));
                              ir_if *f2613 = new(mem_ctx) ir_if(operand(r2615).val);
                              exec_list *const f2613_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2613->then_instructions;

                                 body.emit(assign(r2604, add(r2604, body.constant(int(1))), 0x01));


                              body.instructions = f2613_parent_instructions;
                              body.emit(f2613);

                              /* END IF */

                              body.emit(assign(r2603, r2604, 0x01));


                           body.instructions = f2605_parent_instructions;
                           body.emit(f2605);

                           /* END IF */

                           body.emit(assign(r25FF, add(r2603, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2617 = lequal(body.constant(int(0)), r25FF);
                           ir_if *f2616 = new(mem_ctx) ir_if(operand(r2617).val);
                           exec_list *const f2616_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2616->then_instructions;

                              body.emit(assign(r25FE, body.constant(0u), 0x01));

                              ir_variable *const r2618 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r2618, lshift(r25FD, r25FF), 0x01));

                              ir_variable *const r2619 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r261B = equal(r25FF, body.constant(int(0)));
                              ir_if *f261A = new(mem_ctx) ir_if(operand(r261B).val);
                              exec_list *const f261A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f261A->then_instructions;

                                 body.emit(assign(r2619, r25FC, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f261A->else_instructions;

                                 ir_expression *const r261C = lshift(r25FC, r25FF);
                                 ir_expression *const r261D = neg(r25FF);
                                 ir_expression *const r261E = bit_and(r261D, body.constant(int(31)));
                                 ir_expression *const r261F = rshift(r25FD, r261E);
                                 body.emit(assign(r2619, bit_or(r261C, r261F), 0x01));


                              body.instructions = f261A_parent_instructions;
                              body.emit(f261A);

                              /* END IF */

                              body.emit(assign(r25FC, r2619, 0x01));

                              body.emit(assign(r25FD, r2618, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2616->else_instructions;

                              ir_variable *const r2620 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r2620, body.constant(0u), 0x01));

                              ir_variable *const r2621 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r2621, neg(r25FF), 0x01));

                              ir_variable *const r2622 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r2622);
                              ir_variable *const r2623 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r2623);
                              ir_variable *const r2624 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r2624);
                              ir_variable *const r2625 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r2626 = neg(r2621);
                              body.emit(assign(r2625, bit_and(r2626, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2628 = equal(r2621, body.constant(int(0)));
                              ir_if *f2627 = new(mem_ctx) ir_if(operand(r2628).val);
                              exec_list *const f2627_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2627->then_instructions;

                                 body.emit(assign(r2622, r2620, 0x01));

                                 body.emit(assign(r2623, r25FD, 0x01));

                                 body.emit(assign(r2624, r25FC, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2627->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r262A = less(r2621, body.constant(int(32)));
                                 ir_if *f2629 = new(mem_ctx) ir_if(operand(r262A).val);
                                 exec_list *const f2629_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2629->then_instructions;

                                    body.emit(assign(r2622, lshift(r25FD, r2625), 0x01));

                                    ir_expression *const r262B = lshift(r25FC, r2625);
                                    ir_expression *const r262C = rshift(r25FD, r2621);
                                    body.emit(assign(r2623, bit_or(r262B, r262C), 0x01));

                                    body.emit(assign(r2624, rshift(r25FC, r2621), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2629->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r262E = equal(r2621, body.constant(int(32)));
                                    ir_if *f262D = new(mem_ctx) ir_if(operand(r262E).val);
                                    exec_list *const f262D_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f262D->then_instructions;

                                       body.emit(assign(r2622, r25FD, 0x01));

                                       body.emit(assign(r2623, r25FC, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f262D->else_instructions;

                                       body.emit(assign(r2620, bit_or(body.constant(0u), r25FD), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2630 = less(r2621, body.constant(int(64)));
                                       ir_if *f262F = new(mem_ctx) ir_if(operand(r2630).val);
                                       exec_list *const f262F_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f262F->then_instructions;

                                          body.emit(assign(r2622, lshift(r25FC, r2625), 0x01));

                                          ir_expression *const r2631 = bit_and(r2621, body.constant(int(31)));
                                          body.emit(assign(r2623, rshift(r25FC, r2631), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f262F->else_instructions;

                                          ir_variable *const r2632 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r2634 = equal(r2621, body.constant(int(64)));
                                          ir_if *f2633 = new(mem_ctx) ir_if(operand(r2634).val);
                                          exec_list *const f2633_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2633->then_instructions;

                                             body.emit(assign(r2632, r25FC, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2633->else_instructions;

                                             ir_expression *const r2635 = nequal(r25FC, body.constant(0u));
                                             ir_expression *const r2636 = expr(ir_unop_b2i, r2635);
                                             body.emit(assign(r2632, expr(ir_unop_i2u, r2636), 0x01));


                                          body.instructions = f2633_parent_instructions;
                                          body.emit(f2633);

                                          /* END IF */

                                          body.emit(assign(r2622, r2632, 0x01));

                                          body.emit(assign(r2623, body.constant(0u), 0x01));


                                       body.instructions = f262F_parent_instructions;
                                       body.emit(f262F);

                                       /* END IF */


                                    body.instructions = f262D_parent_instructions;
                                    body.emit(f262D);

                                    /* END IF */

                                    body.emit(assign(r2624, body.constant(0u), 0x01));


                                 body.instructions = f2629_parent_instructions;
                                 body.emit(f2629);

                                 /* END IF */

                                 ir_expression *const r2637 = nequal(r2620, body.constant(0u));
                                 ir_expression *const r2638 = expr(ir_unop_b2i, r2637);
                                 ir_expression *const r2639 = expr(ir_unop_i2u, r2638);
                                 body.emit(assign(r2622, bit_or(r2622, r2639), 0x01));


                              body.instructions = f2627_parent_instructions;
                              body.emit(f2627);

                              /* END IF */

                              body.emit(assign(r25FC, r2624, 0x01));

                              body.emit(assign(r25FD, r2623, 0x01));

                              body.emit(assign(r25FE, r2622, 0x01));


                           body.instructions = f2616_parent_instructions;
                           body.emit(f2616);

                           /* END IF */

                           body.emit(assign(r25FB, sub(r25FB, r25FF), 0x01));

                           ir_variable *const r263A = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r263A, r25FB, 0x01));

                           ir_variable *const r263B = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r263B, r25FC, 0x01));

                           ir_variable *const r263C = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r263C, r25FD, 0x01));

                           ir_variable *const r263D = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r263D, r25FE, 0x01));

                           ir_variable *const r263E = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r263E, body.constant(true), 0x01));

                           ir_variable *const r263F = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r2640 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r2640);
                           ir_expression *const r2641 = expr(ir_unop_u2i, r25FE);
                           body.emit(assign(r2640, less(r2641, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2643 = lequal(body.constant(int(2045)), r25FB);
                           ir_if *f2642 = new(mem_ctx) ir_if(operand(r2643).val);
                           exec_list *const f2642_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2642->then_instructions;

                              ir_variable *const r2644 = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2646 = less(body.constant(int(2045)), r25FB);
                              ir_if *f2645 = new(mem_ctx) ir_if(operand(r2646).val);
                              exec_list *const f2645_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2645->then_instructions;

                                 body.emit(assign(r2644, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2645->else_instructions;

                                 ir_variable *const r2647 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2649 = equal(r25FB, body.constant(int(2045)));
                                 ir_if *f2648 = new(mem_ctx) ir_if(operand(r2649).val);
                                 exec_list *const f2648_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2648->then_instructions;

                                    ir_expression *const r264A = equal(body.constant(2097151u), r25FC);
                                    ir_expression *const r264B = equal(body.constant(4294967295u), r25FD);
                                    body.emit(assign(r2647, logic_and(r264A, r264B), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2648->else_instructions;

                                    body.emit(assign(r2647, body.constant(false), 0x01));


                                 body.instructions = f2648_parent_instructions;
                                 body.emit(f2648);

                                 /* END IF */

                                 body.emit(assign(r2644, logic_and(r2647, r2640), 0x01));


                              body.instructions = f2645_parent_instructions;
                              body.emit(f2645);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f264C = new(mem_ctx) ir_if(operand(r2644).val);
                              exec_list *const f264C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f264C->then_instructions;

                                 ir_variable *const r264D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r264D);
                                 ir_expression *const r264E = lshift(r2351, body.constant(int(31)));
                                 body.emit(assign(r264D, add(r264E, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r264D, body.constant(0u), 0x01));

                                 body.emit(assign(r263F, r264D, 0x03));

                                 body.emit(assign(r263E, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f264C->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2650 = less(r25FB, body.constant(int(0)));
                                 ir_if *f264F = new(mem_ctx) ir_if(operand(r2650).val);
                                 exec_list *const f264F_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f264F->then_instructions;

                                    ir_variable *const r2651 = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r2651, r25FE, 0x01));

                                    ir_variable *const r2652 = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r2652, neg(r25FB), 0x01));

                                    ir_variable *const r2653 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r2653);
                                    ir_variable *const r2654 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r2654);
                                    ir_variable *const r2655 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r2655);
                                    ir_variable *const r2656 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r2657 = neg(r2652);
                                    body.emit(assign(r2656, bit_and(r2657, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r2659 = equal(r2652, body.constant(int(0)));
                                    ir_if *f2658 = new(mem_ctx) ir_if(operand(r2659).val);
                                    exec_list *const f2658_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2658->then_instructions;

                                       body.emit(assign(r2653, r25FE, 0x01));

                                       body.emit(assign(r2654, r25FD, 0x01));

                                       body.emit(assign(r2655, r25FC, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2658->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r265B = less(r2652, body.constant(int(32)));
                                       ir_if *f265A = new(mem_ctx) ir_if(operand(r265B).val);
                                       exec_list *const f265A_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f265A->then_instructions;

                                          body.emit(assign(r2653, lshift(r25FD, r2656), 0x01));

                                          ir_expression *const r265C = lshift(r25FC, r2656);
                                          ir_expression *const r265D = rshift(r25FD, r2652);
                                          body.emit(assign(r2654, bit_or(r265C, r265D), 0x01));

                                          body.emit(assign(r2655, rshift(r25FC, r2652), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f265A->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r265F = equal(r2652, body.constant(int(32)));
                                          ir_if *f265E = new(mem_ctx) ir_if(operand(r265F).val);
                                          exec_list *const f265E_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f265E->then_instructions;

                                             body.emit(assign(r2653, r25FD, 0x01));

                                             body.emit(assign(r2654, r25FC, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f265E->else_instructions;

                                             body.emit(assign(r2651, bit_or(r25FE, r25FD), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r2661 = less(r2652, body.constant(int(64)));
                                             ir_if *f2660 = new(mem_ctx) ir_if(operand(r2661).val);
                                             exec_list *const f2660_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2660->then_instructions;

                                                body.emit(assign(r2653, lshift(r25FC, r2656), 0x01));

                                                ir_expression *const r2662 = bit_and(r2652, body.constant(int(31)));
                                                body.emit(assign(r2654, rshift(r25FC, r2662), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2660->else_instructions;

                                                ir_variable *const r2663 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r2665 = equal(r2652, body.constant(int(64)));
                                                ir_if *f2664 = new(mem_ctx) ir_if(operand(r2665).val);
                                                exec_list *const f2664_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f2664->then_instructions;

                                                   body.emit(assign(r2663, r25FC, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f2664->else_instructions;

                                                   ir_expression *const r2666 = nequal(r25FC, body.constant(0u));
                                                   ir_expression *const r2667 = expr(ir_unop_b2i, r2666);
                                                   body.emit(assign(r2663, expr(ir_unop_i2u, r2667), 0x01));


                                                body.instructions = f2664_parent_instructions;
                                                body.emit(f2664);

                                                /* END IF */

                                                body.emit(assign(r2653, r2663, 0x01));

                                                body.emit(assign(r2654, body.constant(0u), 0x01));


                                             body.instructions = f2660_parent_instructions;
                                             body.emit(f2660);

                                             /* END IF */


                                          body.instructions = f265E_parent_instructions;
                                          body.emit(f265E);

                                          /* END IF */

                                          body.emit(assign(r2655, body.constant(0u), 0x01));


                                       body.instructions = f265A_parent_instructions;
                                       body.emit(f265A);

                                       /* END IF */

                                       ir_expression *const r2668 = nequal(r2651, body.constant(0u));
                                       ir_expression *const r2669 = expr(ir_unop_b2i, r2668);
                                       ir_expression *const r266A = expr(ir_unop_i2u, r2669);
                                       body.emit(assign(r2653, bit_or(r2653, r266A), 0x01));


                                    body.instructions = f2658_parent_instructions;
                                    body.emit(f2658);

                                    /* END IF */

                                    body.emit(assign(r263B, r2655, 0x01));

                                    body.emit(assign(r263C, r2654, 0x01));

                                    body.emit(assign(r263D, r2653, 0x01));

                                    body.emit(assign(r263A, body.constant(int(0)), 0x01));

                                    body.emit(assign(r2640, less(r2653, body.constant(0u)), 0x01));


                                 body.instructions = f264F_parent_instructions;
                                 body.emit(f264F);

                                 /* END IF */


                              body.instructions = f264C_parent_instructions;
                              body.emit(f264C);

                              /* END IF */


                           body.instructions = f2642_parent_instructions;
                           body.emit(f2642);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f266B = new(mem_ctx) ir_if(operand(r263E).val);
                           exec_list *const f266B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f266B->then_instructions;

                              /* IF CONDITION */
                              ir_if *f266C = new(mem_ctx) ir_if(operand(r2640).val);
                              exec_list *const f266C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f266C->then_instructions;

                                 ir_variable *const r266D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r266D, add(r263C, body.constant(1u)), 0x01));

                                 ir_expression *const r266E = less(r266D, r263C);
                                 ir_expression *const r266F = expr(ir_unop_b2i, r266E);
                                 ir_expression *const r2670 = expr(ir_unop_i2u, r266F);
                                 body.emit(assign(r263B, add(r263B, r2670), 0x01));

                                 ir_expression *const r2671 = equal(r263D, body.constant(0u));
                                 ir_expression *const r2672 = expr(ir_unop_b2i, r2671);
                                 ir_expression *const r2673 = expr(ir_unop_i2u, r2672);
                                 ir_expression *const r2674 = add(r263D, r2673);
                                 ir_expression *const r2675 = bit_and(r2674, body.constant(1u));
                                 ir_expression *const r2676 = expr(ir_unop_bit_not, r2675);
                                 body.emit(assign(r263C, bit_and(r266D, r2676), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f266C->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2678 = bit_or(r263B, r263C);
                                 ir_expression *const r2679 = equal(r2678, body.constant(0u));
                                 ir_if *f2677 = new(mem_ctx) ir_if(operand(r2679).val);
                                 exec_list *const f2677_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2677->then_instructions;

                                    body.emit(assign(r263A, body.constant(int(0)), 0x01));


                                 body.instructions = f2677_parent_instructions;
                                 body.emit(f2677);

                                 /* END IF */


                              body.instructions = f266C_parent_instructions;
                              body.emit(f266C);

                              /* END IF */

                              ir_variable *const r267A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r267A);
                              ir_expression *const r267B = lshift(r2351, body.constant(int(31)));
                              ir_expression *const r267C = expr(ir_unop_i2u, r263A);
                              ir_expression *const r267D = lshift(r267C, body.constant(int(20)));
                              ir_expression *const r267E = add(r267B, r267D);
                              body.emit(assign(r267A, add(r267E, r263B), 0x02));

                              body.emit(assign(r267A, r263C, 0x01));

                              body.emit(assign(r263F, r267A, 0x03));

                              body.emit(assign(r263E, body.constant(false), 0x01));


                           body.instructions = f266B_parent_instructions;
                           body.emit(f266B);

                           /* END IF */

                           body.emit(assign(r2352, r263F, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f25F3->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2680 = less(r2359, r2357);
                           ir_if *f267F = new(mem_ctx) ir_if(operand(r2680).val);
                           exec_list *const f267F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f267F->then_instructions;

                              ir_variable *const r2681 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                              ir_variable *const r2682 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r2682, sub(r2357, r2359), 0x01));

                              ir_expression *const r2683 = sub(r2356, r2358);
                              ir_expression *const r2684 = less(r2357, r2359);
                              ir_expression *const r2685 = expr(ir_unop_b2i, r2684);
                              ir_expression *const r2686 = expr(ir_unop_i2u, r2685);
                              body.emit(assign(r2681, sub(r2683, r2686), 0x01));

                              body.emit(assign(r2351, bit_xor(r2351, body.constant(1u)), 0x01));

                              body.emit(assign(r235A, add(r2354, body.constant(int(-1))), 0x01));

                              ir_variable *const r2687 = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r2687, add(r235A, body.constant(int(-10))), 0x01));

                              ir_variable *const r2688 = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r2688, r2681, 0x01));

                              ir_variable *const r2689 = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r2689, r2682, 0x01));

                              ir_variable *const r268A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                              body.emit(r268A);
                              ir_variable *const r268B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r268B);
                              /* IF CONDITION */
                              ir_expression *const r268D = equal(r2681, body.constant(0u));
                              ir_if *f268C = new(mem_ctx) ir_if(operand(r268D).val);
                              exec_list *const f268C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f268C->then_instructions;

                                 body.emit(assign(r2688, r2682, 0x01));

                                 body.emit(assign(r2689, body.constant(0u), 0x01));

                                 body.emit(assign(r2687, add(r2687, body.constant(int(-32))), 0x01));


                              body.instructions = f268C_parent_instructions;
                              body.emit(f268C);

                              /* END IF */

                              ir_variable *const r268E = body.make_temp(glsl_type::uint_type, "a");
                              body.emit(assign(r268E, r2688, 0x01));

                              ir_variable *const r268F = body.make_temp(glsl_type::int_type, "return_value");
                              ir_variable *const r2690 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r2690);
                              /* IF CONDITION */
                              ir_expression *const r2692 = equal(r2688, body.constant(0u));
                              ir_if *f2691 = new(mem_ctx) ir_if(operand(r2692).val);
                              exec_list *const f2691_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2691->then_instructions;

                                 body.emit(assign(r268F, body.constant(int(32)), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2691->else_instructions;

                                 body.emit(assign(r2690, body.constant(int(0)), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2694 = bit_and(r2688, body.constant(4294901760u));
                                 ir_expression *const r2695 = equal(r2694, body.constant(0u));
                                 ir_if *f2693 = new(mem_ctx) ir_if(operand(r2695).val);
                                 exec_list *const f2693_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2693->then_instructions;

                                    body.emit(assign(r2690, body.constant(int(16)), 0x01));

                                    body.emit(assign(r268E, lshift(r2688, body.constant(int(16))), 0x01));


                                 body.instructions = f2693_parent_instructions;
                                 body.emit(f2693);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2697 = bit_and(r268E, body.constant(4278190080u));
                                 ir_expression *const r2698 = equal(r2697, body.constant(0u));
                                 ir_if *f2696 = new(mem_ctx) ir_if(operand(r2698).val);
                                 exec_list *const f2696_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2696->then_instructions;

                                    body.emit(assign(r2690, add(r2690, body.constant(int(8))), 0x01));

                                    body.emit(assign(r268E, lshift(r268E, body.constant(int(8))), 0x01));


                                 body.instructions = f2696_parent_instructions;
                                 body.emit(f2696);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r269A = bit_and(r268E, body.constant(4026531840u));
                                 ir_expression *const r269B = equal(r269A, body.constant(0u));
                                 ir_if *f2699 = new(mem_ctx) ir_if(operand(r269B).val);
                                 exec_list *const f2699_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2699->then_instructions;

                                    body.emit(assign(r2690, add(r2690, body.constant(int(4))), 0x01));

                                    body.emit(assign(r268E, lshift(r268E, body.constant(int(4))), 0x01));


                                 body.instructions = f2699_parent_instructions;
                                 body.emit(f2699);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r269D = bit_and(r268E, body.constant(3221225472u));
                                 ir_expression *const r269E = equal(r269D, body.constant(0u));
                                 ir_if *f269C = new(mem_ctx) ir_if(operand(r269E).val);
                                 exec_list *const f269C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f269C->then_instructions;

                                    body.emit(assign(r2690, add(r2690, body.constant(int(2))), 0x01));

                                    body.emit(assign(r268E, lshift(r268E, body.constant(int(2))), 0x01));


                                 body.instructions = f269C_parent_instructions;
                                 body.emit(f269C);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r26A0 = bit_and(r268E, body.constant(2147483648u));
                                 ir_expression *const r26A1 = equal(r26A0, body.constant(0u));
                                 ir_if *f269F = new(mem_ctx) ir_if(operand(r26A1).val);
                                 exec_list *const f269F_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f269F->then_instructions;

                                    body.emit(assign(r2690, add(r2690, body.constant(int(1))), 0x01));


                                 body.instructions = f269F_parent_instructions;
                                 body.emit(f269F);

                                 /* END IF */

                                 body.emit(assign(r268F, r2690, 0x01));


                              body.instructions = f2691_parent_instructions;
                              body.emit(f2691);

                              /* END IF */

                              body.emit(assign(r268B, add(r268F, body.constant(int(-11))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r26A3 = lequal(body.constant(int(0)), r268B);
                              ir_if *f26A2 = new(mem_ctx) ir_if(operand(r26A3).val);
                              exec_list *const f26A2_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f26A2->then_instructions;

                                 body.emit(assign(r268A, body.constant(0u), 0x01));

                                 ir_variable *const r26A4 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                                 body.emit(assign(r26A4, lshift(r2689, r268B), 0x01));

                                 ir_variable *const r26A5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r26A7 = equal(r268B, body.constant(int(0)));
                                 ir_if *f26A6 = new(mem_ctx) ir_if(operand(r26A7).val);
                                 exec_list *const f26A6_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f26A6->then_instructions;

                                    body.emit(assign(r26A5, r2688, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f26A6->else_instructions;

                                    ir_expression *const r26A8 = lshift(r2688, r268B);
                                    ir_expression *const r26A9 = neg(r268B);
                                    ir_expression *const r26AA = bit_and(r26A9, body.constant(int(31)));
                                    ir_expression *const r26AB = rshift(r2689, r26AA);
                                    body.emit(assign(r26A5, bit_or(r26A8, r26AB), 0x01));


                                 body.instructions = f26A6_parent_instructions;
                                 body.emit(f26A6);

                                 /* END IF */

                                 body.emit(assign(r2688, r26A5, 0x01));

                                 body.emit(assign(r2689, r26A4, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f26A2->else_instructions;

                                 ir_variable *const r26AC = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r26AC, body.constant(0u), 0x01));

                                 ir_variable *const r26AD = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r26AD, neg(r268B), 0x01));

                                 ir_variable *const r26AE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r26AE);
                                 ir_variable *const r26AF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r26AF);
                                 ir_variable *const r26B0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r26B0);
                                 ir_variable *const r26B1 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r26B2 = neg(r26AD);
                                 body.emit(assign(r26B1, bit_and(r26B2, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r26B4 = equal(r26AD, body.constant(int(0)));
                                 ir_if *f26B3 = new(mem_ctx) ir_if(operand(r26B4).val);
                                 exec_list *const f26B3_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f26B3->then_instructions;

                                    body.emit(assign(r26AE, r26AC, 0x01));

                                    body.emit(assign(r26AF, r2689, 0x01));

                                    body.emit(assign(r26B0, r2688, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f26B3->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r26B6 = less(r26AD, body.constant(int(32)));
                                    ir_if *f26B5 = new(mem_ctx) ir_if(operand(r26B6).val);
                                    exec_list *const f26B5_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f26B5->then_instructions;

                                       body.emit(assign(r26AE, lshift(r2689, r26B1), 0x01));

                                       ir_expression *const r26B7 = lshift(r2688, r26B1);
                                       ir_expression *const r26B8 = rshift(r2689, r26AD);
                                       body.emit(assign(r26AF, bit_or(r26B7, r26B8), 0x01));

                                       body.emit(assign(r26B0, rshift(r2688, r26AD), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f26B5->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r26BA = equal(r26AD, body.constant(int(32)));
                                       ir_if *f26B9 = new(mem_ctx) ir_if(operand(r26BA).val);
                                       exec_list *const f26B9_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f26B9->then_instructions;

                                          body.emit(assign(r26AE, r2689, 0x01));

                                          body.emit(assign(r26AF, r2688, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f26B9->else_instructions;

                                          body.emit(assign(r26AC, bit_or(body.constant(0u), r2689), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r26BC = less(r26AD, body.constant(int(64)));
                                          ir_if *f26BB = new(mem_ctx) ir_if(operand(r26BC).val);
                                          exec_list *const f26BB_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f26BB->then_instructions;

                                             body.emit(assign(r26AE, lshift(r2688, r26B1), 0x01));

                                             ir_expression *const r26BD = bit_and(r26AD, body.constant(int(31)));
                                             body.emit(assign(r26AF, rshift(r2688, r26BD), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f26BB->else_instructions;

                                             ir_variable *const r26BE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r26C0 = equal(r26AD, body.constant(int(64)));
                                             ir_if *f26BF = new(mem_ctx) ir_if(operand(r26C0).val);
                                             exec_list *const f26BF_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f26BF->then_instructions;

                                                body.emit(assign(r26BE, r2688, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f26BF->else_instructions;

                                                ir_expression *const r26C1 = nequal(r2688, body.constant(0u));
                                                ir_expression *const r26C2 = expr(ir_unop_b2i, r26C1);
                                                body.emit(assign(r26BE, expr(ir_unop_i2u, r26C2), 0x01));


                                             body.instructions = f26BF_parent_instructions;
                                             body.emit(f26BF);

                                             /* END IF */

                                             body.emit(assign(r26AE, r26BE, 0x01));

                                             body.emit(assign(r26AF, body.constant(0u), 0x01));


                                          body.instructions = f26BB_parent_instructions;
                                          body.emit(f26BB);

                                          /* END IF */


                                       body.instructions = f26B9_parent_instructions;
                                       body.emit(f26B9);

                                       /* END IF */

                                       body.emit(assign(r26B0, body.constant(0u), 0x01));


                                    body.instructions = f26B5_parent_instructions;
                                    body.emit(f26B5);

                                    /* END IF */

                                    ir_expression *const r26C3 = nequal(r26AC, body.constant(0u));
                                    ir_expression *const r26C4 = expr(ir_unop_b2i, r26C3);
                                    ir_expression *const r26C5 = expr(ir_unop_i2u, r26C4);
                                    body.emit(assign(r26AE, bit_or(r26AE, r26C5), 0x01));


                                 body.instructions = f26B3_parent_instructions;
                                 body.emit(f26B3);

                                 /* END IF */

                                 body.emit(assign(r2688, r26B0, 0x01));

                                 body.emit(assign(r2689, r26AF, 0x01));

                                 body.emit(assign(r268A, r26AE, 0x01));


                              body.instructions = f26A2_parent_instructions;
                              body.emit(f26A2);

                              /* END IF */

                              body.emit(assign(r2687, sub(r2687, r268B), 0x01));

                              ir_variable *const r26C6 = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r26C6, r2687, 0x01));

                              ir_variable *const r26C7 = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r26C7, r2688, 0x01));

                              ir_variable *const r26C8 = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r26C8, r2689, 0x01));

                              ir_variable *const r26C9 = body.make_temp(glsl_type::uint_type, "zFrac2");
                              body.emit(assign(r26C9, r268A, 0x01));

                              ir_variable *const r26CA = body.make_temp(glsl_type::bool_type, "execute_flag");
                              body.emit(assign(r26CA, body.constant(true), 0x01));

                              ir_variable *const r26CB = body.make_temp(glsl_type::uvec2_type, "return_value");
                              ir_variable *const r26CC = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                              body.emit(r26CC);
                              ir_expression *const r26CD = expr(ir_unop_u2i, r268A);
                              body.emit(assign(r26CC, less(r26CD, body.constant(int(0))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r26CF = lequal(body.constant(int(2045)), r2687);
                              ir_if *f26CE = new(mem_ctx) ir_if(operand(r26CF).val);
                              exec_list *const f26CE_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f26CE->then_instructions;

                                 ir_variable *const r26D0 = body.make_temp(glsl_type::bool_type, "or_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r26D2 = less(body.constant(int(2045)), r2687);
                                 ir_if *f26D1 = new(mem_ctx) ir_if(operand(r26D2).val);
                                 exec_list *const f26D1_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f26D1->then_instructions;

                                    body.emit(assign(r26D0, body.constant(true), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f26D1->else_instructions;

                                    ir_variable *const r26D3 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r26D5 = equal(r2687, body.constant(int(2045)));
                                    ir_if *f26D4 = new(mem_ctx) ir_if(operand(r26D5).val);
                                    exec_list *const f26D4_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f26D4->then_instructions;

                                       ir_expression *const r26D6 = equal(body.constant(2097151u), r2688);
                                       ir_expression *const r26D7 = equal(body.constant(4294967295u), r2689);
                                       body.emit(assign(r26D3, logic_and(r26D6, r26D7), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f26D4->else_instructions;

                                       body.emit(assign(r26D3, body.constant(false), 0x01));


                                    body.instructions = f26D4_parent_instructions;
                                    body.emit(f26D4);

                                    /* END IF */

                                    body.emit(assign(r26D0, logic_and(r26D3, r26CC), 0x01));


                                 body.instructions = f26D1_parent_instructions;
                                 body.emit(f26D1);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_if *f26D8 = new(mem_ctx) ir_if(operand(r26D0).val);
                                 exec_list *const f26D8_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f26D8->then_instructions;

                                    ir_variable *const r26D9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                    body.emit(r26D9);
                                    ir_expression *const r26DA = lshift(r2351, body.constant(int(31)));
                                    body.emit(assign(r26D9, add(r26DA, body.constant(2146435072u)), 0x02));

                                    body.emit(assign(r26D9, body.constant(0u), 0x01));

                                    body.emit(assign(r26CB, r26D9, 0x03));

                                    body.emit(assign(r26CA, body.constant(false), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f26D8->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r26DC = less(r2687, body.constant(int(0)));
                                    ir_if *f26DB = new(mem_ctx) ir_if(operand(r26DC).val);
                                    exec_list *const f26DB_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f26DB->then_instructions;

                                       ir_variable *const r26DD = body.make_temp(glsl_type::uint_type, "a2");
                                       body.emit(assign(r26DD, r268A, 0x01));

                                       ir_variable *const r26DE = body.make_temp(glsl_type::int_type, "count");
                                       body.emit(assign(r26DE, neg(r2687), 0x01));

                                       ir_variable *const r26DF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                       body.emit(r26DF);
                                       ir_variable *const r26E0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                       body.emit(r26E0);
                                       ir_variable *const r26E1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                       body.emit(r26E1);
                                       ir_variable *const r26E2 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                       ir_expression *const r26E3 = neg(r26DE);
                                       body.emit(assign(r26E2, bit_and(r26E3, body.constant(int(31))), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r26E5 = equal(r26DE, body.constant(int(0)));
                                       ir_if *f26E4 = new(mem_ctx) ir_if(operand(r26E5).val);
                                       exec_list *const f26E4_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f26E4->then_instructions;

                                          body.emit(assign(r26DF, r268A, 0x01));

                                          body.emit(assign(r26E0, r2689, 0x01));

                                          body.emit(assign(r26E1, r2688, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f26E4->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r26E7 = less(r26DE, body.constant(int(32)));
                                          ir_if *f26E6 = new(mem_ctx) ir_if(operand(r26E7).val);
                                          exec_list *const f26E6_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f26E6->then_instructions;

                                             body.emit(assign(r26DF, lshift(r2689, r26E2), 0x01));

                                             ir_expression *const r26E8 = lshift(r2688, r26E2);
                                             ir_expression *const r26E9 = rshift(r2689, r26DE);
                                             body.emit(assign(r26E0, bit_or(r26E8, r26E9), 0x01));

                                             body.emit(assign(r26E1, rshift(r2688, r26DE), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f26E6->else_instructions;

                                             /* IF CONDITION */
                                             ir_expression *const r26EB = equal(r26DE, body.constant(int(32)));
                                             ir_if *f26EA = new(mem_ctx) ir_if(operand(r26EB).val);
                                             exec_list *const f26EA_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f26EA->then_instructions;

                                                body.emit(assign(r26DF, r2689, 0x01));

                                                body.emit(assign(r26E0, r2688, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f26EA->else_instructions;

                                                body.emit(assign(r26DD, bit_or(r268A, r2689), 0x01));

                                                /* IF CONDITION */
                                                ir_expression *const r26ED = less(r26DE, body.constant(int(64)));
                                                ir_if *f26EC = new(mem_ctx) ir_if(operand(r26ED).val);
                                                exec_list *const f26EC_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f26EC->then_instructions;

                                                   body.emit(assign(r26DF, lshift(r2688, r26E2), 0x01));

                                                   ir_expression *const r26EE = bit_and(r26DE, body.constant(int(31)));
                                                   body.emit(assign(r26E0, rshift(r2688, r26EE), 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f26EC->else_instructions;

                                                   ir_variable *const r26EF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                   /* IF CONDITION */
                                                   ir_expression *const r26F1 = equal(r26DE, body.constant(int(64)));
                                                   ir_if *f26F0 = new(mem_ctx) ir_if(operand(r26F1).val);
                                                   exec_list *const f26F0_parent_instructions = body.instructions;

                                                      /* THEN INSTRUCTIONS */
                                                      body.instructions = &f26F0->then_instructions;

                                                      body.emit(assign(r26EF, r2688, 0x01));


                                                      /* ELSE INSTRUCTIONS */
                                                      body.instructions = &f26F0->else_instructions;

                                                      ir_expression *const r26F2 = nequal(r2688, body.constant(0u));
                                                      ir_expression *const r26F3 = expr(ir_unop_b2i, r26F2);
                                                      body.emit(assign(r26EF, expr(ir_unop_i2u, r26F3), 0x01));


                                                   body.instructions = f26F0_parent_instructions;
                                                   body.emit(f26F0);

                                                   /* END IF */

                                                   body.emit(assign(r26DF, r26EF, 0x01));

                                                   body.emit(assign(r26E0, body.constant(0u), 0x01));


                                                body.instructions = f26EC_parent_instructions;
                                                body.emit(f26EC);

                                                /* END IF */


                                             body.instructions = f26EA_parent_instructions;
                                             body.emit(f26EA);

                                             /* END IF */

                                             body.emit(assign(r26E1, body.constant(0u), 0x01));


                                          body.instructions = f26E6_parent_instructions;
                                          body.emit(f26E6);

                                          /* END IF */

                                          ir_expression *const r26F4 = nequal(r26DD, body.constant(0u));
                                          ir_expression *const r26F5 = expr(ir_unop_b2i, r26F4);
                                          ir_expression *const r26F6 = expr(ir_unop_i2u, r26F5);
                                          body.emit(assign(r26DF, bit_or(r26DF, r26F6), 0x01));


                                       body.instructions = f26E4_parent_instructions;
                                       body.emit(f26E4);

                                       /* END IF */

                                       body.emit(assign(r26C7, r26E1, 0x01));

                                       body.emit(assign(r26C8, r26E0, 0x01));

                                       body.emit(assign(r26C9, r26DF, 0x01));

                                       body.emit(assign(r26C6, body.constant(int(0)), 0x01));

                                       body.emit(assign(r26CC, less(r26DF, body.constant(0u)), 0x01));


                                    body.instructions = f26DB_parent_instructions;
                                    body.emit(f26DB);

                                    /* END IF */


                                 body.instructions = f26D8_parent_instructions;
                                 body.emit(f26D8);

                                 /* END IF */


                              body.instructions = f26CE_parent_instructions;
                              body.emit(f26CE);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f26F7 = new(mem_ctx) ir_if(operand(r26CA).val);
                              exec_list *const f26F7_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f26F7->then_instructions;

                                 /* IF CONDITION */
                                 ir_if *f26F8 = new(mem_ctx) ir_if(operand(r26CC).val);
                                 exec_list *const f26F8_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f26F8->then_instructions;

                                    ir_variable *const r26F9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                    body.emit(assign(r26F9, add(r26C8, body.constant(1u)), 0x01));

                                    ir_expression *const r26FA = less(r26F9, r26C8);
                                    ir_expression *const r26FB = expr(ir_unop_b2i, r26FA);
                                    ir_expression *const r26FC = expr(ir_unop_i2u, r26FB);
                                    body.emit(assign(r26C7, add(r26C7, r26FC), 0x01));

                                    ir_expression *const r26FD = equal(r26C9, body.constant(0u));
                                    ir_expression *const r26FE = expr(ir_unop_b2i, r26FD);
                                    ir_expression *const r26FF = expr(ir_unop_i2u, r26FE);
                                    ir_expression *const r2700 = add(r26C9, r26FF);
                                    ir_expression *const r2701 = bit_and(r2700, body.constant(1u));
                                    ir_expression *const r2702 = expr(ir_unop_bit_not, r2701);
                                    body.emit(assign(r26C8, bit_and(r26F9, r2702), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f26F8->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2704 = bit_or(r26C7, r26C8);
                                    ir_expression *const r2705 = equal(r2704, body.constant(0u));
                                    ir_if *f2703 = new(mem_ctx) ir_if(operand(r2705).val);
                                    exec_list *const f2703_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2703->then_instructions;

                                       body.emit(assign(r26C6, body.constant(int(0)), 0x01));


                                    body.instructions = f2703_parent_instructions;
                                    body.emit(f2703);

                                    /* END IF */


                                 body.instructions = f26F8_parent_instructions;
                                 body.emit(f26F8);

                                 /* END IF */

                                 ir_variable *const r2706 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r2706);
                                 ir_expression *const r2707 = lshift(r2351, body.constant(int(31)));
                                 ir_expression *const r2708 = expr(ir_unop_i2u, r26C6);
                                 ir_expression *const r2709 = lshift(r2708, body.constant(int(20)));
                                 ir_expression *const r270A = add(r2707, r2709);
                                 body.emit(assign(r2706, add(r270A, r26C7), 0x02));

                                 body.emit(assign(r2706, r26C8, 0x01));

                                 body.emit(assign(r26CB, r2706, 0x03));

                                 body.emit(assign(r26CA, body.constant(false), 0x01));


                              body.instructions = f26F7_parent_instructions;
                              body.emit(f26F7);

                              /* END IF */

                              body.emit(assign(r2352, r26CB, 0x03));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f267F->else_instructions;

                              ir_variable *const r270B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r270B);
                              body.emit(assign(r270B, body.constant(0u), 0x02));

                              body.emit(assign(r270B, body.constant(0u), 0x01));

                              body.emit(assign(r2352, r270B, 0x03));


                           body.instructions = f267F_parent_instructions;
                           body.emit(f267F);

                           /* END IF */


                        body.instructions = f25F3_parent_instructions;
                        body.emit(f25F3);

                        /* END IF */


                     body.instructions = f2567_parent_instructions;
                     body.emit(f2567);

                     /* END IF */


                  body.instructions = f24DB_parent_instructions;
                  body.emit(f24DB);

                  /* END IF */


               body.instructions = f24C6_parent_instructions;
               body.emit(f24C6);

               /* END IF */


            body.instructions = f2417_parent_instructions;
            body.emit(f2417);

            /* END IF */


         body.instructions = f2366_parent_instructions;
         body.emit(f2366);

         /* END IF */

         body.emit(assign(r21F4, r2352, 0x03));


      body.instructions = f21F6_parent_instructions;
      body.emit(f21F6);

      /* END IF */

      body.emit(assign(r21F2, r21F4, 0x03));


   body.instructions = f21F3_parent_instructions;
   body.emit(f21F3);

   /* END IF */

   body.emit(ret(r21F2));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
ffract64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r270C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r270C);
   ir_variable *const r270D = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r270E = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r270F = rshift(swizzle_y(r270C), body.constant(int(20)));
   ir_expression *const r2710 = bit_and(r270F, body.constant(2047u));
   ir_expression *const r2711 = expr(ir_unop_u2i, r2710);
   body.emit(assign(r270E, add(r2711, body.constant(int(-1023))), 0x01));

   /* IF CONDITION */
   ir_expression *const r2713 = less(r270E, body.constant(int(0)));
   ir_if *f2712 = new(mem_ctx) ir_if(operand(r2713).val);
   exec_list *const f2712_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f2712->then_instructions;

      body.emit(assign(r270D, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f2712->else_instructions;

      /* IF CONDITION */
      ir_expression *const r2715 = greater(r270E, body.constant(int(52)));
      ir_if *f2714 = new(mem_ctx) ir_if(operand(r2715).val);
      exec_list *const f2714_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f2714->then_instructions;

         body.emit(assign(r270D, r270C, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f2714->else_instructions;

         ir_variable *const r2716 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r2716, sub(body.constant(int(52)), r270E), 0x01));

         ir_variable *const r2717 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r2719 = gequal(r2716, body.constant(int(32)));
         ir_if *f2718 = new(mem_ctx) ir_if(operand(r2719).val);
         exec_list *const f2718_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2718->then_instructions;

            body.emit(assign(r2717, body.constant(0u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2718->else_instructions;

            body.emit(assign(r2717, lshift(body.constant(4294967295u), r2716), 0x01));


         body.instructions = f2718_parent_instructions;
         body.emit(f2718);

         /* END IF */

         ir_variable *const r271A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r271C = less(r2716, body.constant(int(33)));
         ir_if *f271B = new(mem_ctx) ir_if(operand(r271C).val);
         exec_list *const f271B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f271B->then_instructions;

            body.emit(assign(r271A, body.constant(4294967295u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f271B->else_instructions;

            ir_expression *const r271D = add(r2716, body.constant(int(-32)));
            body.emit(assign(r271A, lshift(body.constant(4294967295u), r271D), 0x01));


         body.instructions = f271B_parent_instructions;
         body.emit(f271B);

         /* END IF */

         ir_variable *const r271E = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
         body.emit(assign(r271E, bit_and(r2717, swizzle_x(r270C)), 0x01));

         body.emit(assign(r271E, bit_and(r271A, swizzle_y(r270C)), 0x02));

         body.emit(assign(r270D, r271E, 0x03));


      body.instructions = f2714_parent_instructions;
      body.emit(f2714);

      /* END IF */


   body.instructions = f2712_parent_instructions;
   body.emit(f2712);

   /* END IF */

   ir_variable *const r271F = body.make_temp(glsl_type::bool_type, "assignment_tmp");
   ir_expression *const r2720 = rshift(swizzle_y(r270C), body.constant(int(31)));
   ir_expression *const r2721 = expr(ir_unop_u2i, r2720);
   body.emit(assign(r271F, expr(ir_unop_i2b, r2721), 0x01));

   ir_variable *const r2722 = body.make_temp(glsl_type::bool_type, "or_tmp");
   /* IF CONDITION */
   ir_expression *const r2724 = expr(ir_unop_logic_not, r271F);
   ir_if *f2723 = new(mem_ctx) ir_if(operand(r2724).val);
   exec_list *const f2723_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f2723->then_instructions;

      body.emit(assign(r2722, body.constant(true), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f2723->else_instructions;

      ir_variable *const r2725 = body.make_temp(glsl_type::bool_type, "return_value");
      ir_variable *const r2726 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
      body.emit(r2726);
      ir_variable *const r2727 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
      body.emit(r2727);
      ir_expression *const r2728 = rshift(swizzle_y(r270C), body.constant(int(20)));
      ir_expression *const r2729 = bit_and(r2728, body.constant(2047u));
      ir_expression *const r272A = expr(ir_unop_u2i, r2729);
      ir_expression *const r272B = equal(r272A, body.constant(int(2047)));
      ir_expression *const r272C = bit_and(swizzle_y(r270C), body.constant(1048575u));
      ir_expression *const r272D = bit_or(r272C, swizzle_x(r270C));
      ir_expression *const r272E = nequal(r272D, body.constant(0u));
      body.emit(assign(r2727, logic_and(r272B, r272E), 0x01));

      ir_expression *const r272F = rshift(swizzle_y(r270D), body.constant(int(20)));
      ir_expression *const r2730 = bit_and(r272F, body.constant(2047u));
      ir_expression *const r2731 = expr(ir_unop_u2i, r2730);
      ir_expression *const r2732 = equal(r2731, body.constant(int(2047)));
      ir_expression *const r2733 = bit_and(swizzle_y(r270D), body.constant(1048575u));
      ir_expression *const r2734 = bit_or(r2733, swizzle_x(r270D));
      ir_expression *const r2735 = nequal(r2734, body.constant(0u));
      body.emit(assign(r2726, logic_and(r2732, r2735), 0x01));

      /* IF CONDITION */
      ir_expression *const r2737 = logic_or(r2727, r2726);
      ir_if *f2736 = new(mem_ctx) ir_if(operand(r2737).val);
      exec_list *const f2736_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f2736->then_instructions;

         body.emit(assign(r2725, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f2736->else_instructions;

         ir_expression *const r2738 = equal(swizzle_x(r270C), swizzle_x(r270D));
         ir_expression *const r2739 = equal(swizzle_y(r270C), swizzle_y(r270D));
         ir_expression *const r273A = equal(swizzle_x(r270C), body.constant(0u));
         ir_expression *const r273B = bit_or(swizzle_y(r270C), swizzle_y(r270D));
         ir_expression *const r273C = lshift(r273B, body.constant(int(1)));
         ir_expression *const r273D = equal(r273C, body.constant(0u));
         ir_expression *const r273E = logic_and(r273A, r273D);
         ir_expression *const r273F = logic_or(r2739, r273E);
         body.emit(assign(r2725, logic_and(r2738, r273F), 0x01));


      body.instructions = f2736_parent_instructions;
      body.emit(f2736);

      /* END IF */

      body.emit(assign(r2722, r2725, 0x01));


   body.instructions = f2723_parent_instructions;
   body.emit(f2723);

   /* END IF */

   ir_variable *const r2740 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
   /* IF CONDITION */
   ir_if *f2741 = new(mem_ctx) ir_if(operand(r2722).val);
   exec_list *const f2741_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f2741->then_instructions;

      body.emit(assign(r2740, r270D, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f2741->else_instructions;

      ir_variable *const r2742 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r2743 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r2743, rshift(swizzle_y(r270D), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r2745 = equal(r2743, body.constant(0u));
      ir_if *f2744 = new(mem_ctx) ir_if(operand(r2745).val);
      exec_list *const f2744_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f2744->then_instructions;

         ir_variable *const r2746 = body.make_temp(glsl_type::uint_type, "zSign");
         body.emit(assign(r2746, r2743, 0x01));

         ir_variable *const r2747 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r2748 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r2748);
         ir_variable *const r2749 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
         body.emit(r2749);
         ir_variable *const r274A = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
         body.emit(r274A);
         ir_variable *const r274B = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r274B);
         ir_variable *const r274C = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r274C);
         ir_variable *const r274D = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r274D);
         ir_variable *const r274E = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r274E);
         ir_variable *const r274F = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r274F);
         ir_variable *const r2750 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r2750, body.constant(0u), 0x01));

         ir_variable *const r2751 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r2752 = rshift(swizzle_y(r270D), body.constant(int(20)));
         ir_expression *const r2753 = bit_and(r2752, body.constant(2047u));
         body.emit(assign(r2751, expr(ir_unop_u2i, r2753), 0x01));

         body.emit(assign(r274A, r2751, 0x01));

         body.emit(assign(r2749, body.constant(int(1023)), 0x01));

         body.emit(assign(r2748, add(r2751, body.constant(int(-1023))), 0x01));

         ir_variable *const r2754 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r2754, lshift(swizzle_x(r270D), body.constant(int(10))), 0x01));

         ir_variable *const r2755 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         ir_expression *const r2756 = bit_and(swizzle_y(r270D), body.constant(1048575u));
         ir_expression *const r2757 = lshift(r2756, body.constant(int(10)));
         ir_expression *const r2758 = rshift(swizzle_x(r270D), body.constant(int(22)));
         body.emit(assign(r2755, bit_or(r2757, r2758), 0x01));

         body.emit(assign(r274D, r2755, 0x01));

         body.emit(assign(r274E, r2754, 0x01));

         ir_variable *const r2759 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r2759, body.constant(0u), 0x01));

         ir_variable *const r275A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         body.emit(assign(r275A, body.constant(0u), 0x01));

         body.emit(assign(r274B, r275A, 0x01));

         body.emit(assign(r274C, body.constant(0u), 0x01));

         /* IF CONDITION */
         ir_expression *const r275C = less(body.constant(int(0)), r2748);
         ir_if *f275B = new(mem_ctx) ir_if(operand(r275C).val);
         exec_list *const f275B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f275B->then_instructions;

            /* IF CONDITION */
            ir_expression *const r275E = equal(r2751, body.constant(int(2047)));
            ir_if *f275D = new(mem_ctx) ir_if(operand(r275E).val);
            exec_list *const f275D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f275D->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2760 = bit_or(r2755, r2754);
               ir_expression *const r2761 = nequal(r2760, body.constant(0u));
               ir_if *f275F = new(mem_ctx) ir_if(operand(r2761).val);
               exec_list *const f275F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f275F->then_instructions;

                  ir_variable *const r2762 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r2762, swizzle_x(r270D), 0x01));

                  ir_variable *const r2763 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r2763, body.constant(0u), 0x01));

                  ir_variable *const r2764 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r2762, bit_or(swizzle_y(r270D), body.constant(524288u)), 0x02));

                  body.emit(assign(r2763, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r2766 = lshift(swizzle_y(r270D), body.constant(int(1)));
                  ir_expression *const r2767 = lequal(body.constant(4292870144u), r2766);
                  ir_expression *const r2768 = nequal(swizzle_x(r270D), body.constant(0u));
                  ir_expression *const r2769 = bit_and(swizzle_y(r270D), body.constant(1048575u));
                  ir_expression *const r276A = nequal(r2769, body.constant(0u));
                  ir_expression *const r276B = logic_or(r2768, r276A);
                  ir_expression *const r276C = logic_and(r2767, r276B);
                  ir_if *f2765 = new(mem_ctx) ir_if(operand(r276C).val);
                  exec_list *const f2765_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2765->then_instructions;

                     body.emit(assign(r2764, r2762, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2765->else_instructions;

                     body.emit(assign(r2764, r2763, 0x03));


                  body.instructions = f2765_parent_instructions;
                  body.emit(f2765);

                  /* END IF */

                  body.emit(assign(r2747, r2764, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f275F->else_instructions;

                  body.emit(assign(r2747, r270D, 0x03));


               body.instructions = f275F_parent_instructions;
               body.emit(f275F);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f275D->else_instructions;

               body.emit(assign(r274B, body.constant(1073741824u), 0x01));

               ir_variable *const r276D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r276D);
               ir_variable *const r276E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r276E);
               ir_variable *const r276F = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2770 = neg(r2748);
               body.emit(assign(r276F, bit_and(r2770, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2772 = equal(r2748, body.constant(int(0)));
               ir_if *f2771 = new(mem_ctx) ir_if(operand(r2772).val);
               exec_list *const f2771_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2771->then_instructions;

                  body.emit(assign(r276D, body.constant(0u), 0x01));

                  body.emit(assign(r276E, r274B, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2771->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2774 = less(r2748, body.constant(int(32)));
                  ir_if *f2773 = new(mem_ctx) ir_if(operand(r2774).val);
                  exec_list *const f2773_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2773->then_instructions;

                     ir_expression *const r2775 = lshift(body.constant(1073741824u), r276F);
                     ir_expression *const r2776 = bit_or(r2775, body.constant(0u));
                     body.emit(assign(r276D, bit_or(r2776, body.constant(0u)), 0x01));

                     body.emit(assign(r276E, rshift(body.constant(1073741824u), r2748), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2773->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2778 = equal(r2748, body.constant(int(32)));
                     ir_if *f2777 = new(mem_ctx) ir_if(operand(r2778).val);
                     exec_list *const f2777_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2777->then_instructions;

                        body.emit(assign(r276D, body.constant(1073741824u), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2777->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r277A = less(r2748, body.constant(int(64)));
                        ir_if *f2779 = new(mem_ctx) ir_if(operand(r277A).val);
                        exec_list *const f2779_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2779->then_instructions;

                           ir_expression *const r277B = bit_and(r2748, body.constant(int(31)));
                           ir_expression *const r277C = rshift(body.constant(1073741824u), r277B);
                           ir_expression *const r277D = lshift(body.constant(1073741824u), r276F);
                           ir_expression *const r277E = bit_or(r277D, body.constant(0u));
                           ir_expression *const r277F = nequal(r277E, body.constant(0u));
                           ir_expression *const r2780 = expr(ir_unop_b2i, r277F);
                           ir_expression *const r2781 = expr(ir_unop_i2u, r2780);
                           body.emit(assign(r276D, bit_or(r277C, r2781), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2779->else_instructions;

                           body.emit(assign(r276D, body.constant(1u), 0x01));


                        body.instructions = f2779_parent_instructions;
                        body.emit(f2779);

                        /* END IF */


                     body.instructions = f2777_parent_instructions;
                     body.emit(f2777);

                     /* END IF */

                     body.emit(assign(r276E, body.constant(0u), 0x01));


                  body.instructions = f2773_parent_instructions;
                  body.emit(f2773);

                  /* END IF */


               body.instructions = f2771_parent_instructions;
               body.emit(f2771);

               /* END IF */

               body.emit(assign(r274B, r276E, 0x01));

               body.emit(assign(r274C, r276D, 0x01));

               body.emit(assign(r274D, bit_or(r2755, body.constant(1073741824u)), 0x01));

               ir_variable *const r2782 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r2783 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r2783, sub(r2754, r276D), 0x01));

               ir_expression *const r2784 = sub(r274D, r276E);
               ir_expression *const r2785 = less(r2754, r276D);
               ir_expression *const r2786 = expr(ir_unop_b2i, r2785);
               ir_expression *const r2787 = expr(ir_unop_i2u, r2786);
               body.emit(assign(r2782, sub(r2784, r2787), 0x01));

               body.emit(assign(r274F, add(r2751, body.constant(int(-1))), 0x01));

               ir_variable *const r2788 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2788, add(r274F, body.constant(int(-10))), 0x01));

               ir_variable *const r2789 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2789, r2782, 0x01));

               ir_variable *const r278A = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r278A, r2783, 0x01));

               ir_variable *const r278B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r278B);
               ir_variable *const r278C = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r278C);
               /* IF CONDITION */
               ir_expression *const r278E = equal(r2782, body.constant(0u));
               ir_if *f278D = new(mem_ctx) ir_if(operand(r278E).val);
               exec_list *const f278D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f278D->then_instructions;

                  body.emit(assign(r2789, r2783, 0x01));

                  body.emit(assign(r278A, body.constant(0u), 0x01));

                  body.emit(assign(r2788, add(r2788, body.constant(int(-32))), 0x01));


               body.instructions = f278D_parent_instructions;
               body.emit(f278D);

               /* END IF */

               ir_variable *const r278F = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r278F, r2789, 0x01));

               ir_variable *const r2790 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r2791 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r2791);
               /* IF CONDITION */
               ir_expression *const r2793 = equal(r2789, body.constant(0u));
               ir_if *f2792 = new(mem_ctx) ir_if(operand(r2793).val);
               exec_list *const f2792_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2792->then_instructions;

                  body.emit(assign(r2790, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2792->else_instructions;

                  body.emit(assign(r2791, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2795 = bit_and(r2789, body.constant(4294901760u));
                  ir_expression *const r2796 = equal(r2795, body.constant(0u));
                  ir_if *f2794 = new(mem_ctx) ir_if(operand(r2796).val);
                  exec_list *const f2794_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2794->then_instructions;

                     body.emit(assign(r2791, body.constant(int(16)), 0x01));

                     body.emit(assign(r278F, lshift(r2789, body.constant(int(16))), 0x01));


                  body.instructions = f2794_parent_instructions;
                  body.emit(f2794);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2798 = bit_and(r278F, body.constant(4278190080u));
                  ir_expression *const r2799 = equal(r2798, body.constant(0u));
                  ir_if *f2797 = new(mem_ctx) ir_if(operand(r2799).val);
                  exec_list *const f2797_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2797->then_instructions;

                     body.emit(assign(r2791, add(r2791, body.constant(int(8))), 0x01));

                     body.emit(assign(r278F, lshift(r278F, body.constant(int(8))), 0x01));


                  body.instructions = f2797_parent_instructions;
                  body.emit(f2797);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r279B = bit_and(r278F, body.constant(4026531840u));
                  ir_expression *const r279C = equal(r279B, body.constant(0u));
                  ir_if *f279A = new(mem_ctx) ir_if(operand(r279C).val);
                  exec_list *const f279A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f279A->then_instructions;

                     body.emit(assign(r2791, add(r2791, body.constant(int(4))), 0x01));

                     body.emit(assign(r278F, lshift(r278F, body.constant(int(4))), 0x01));


                  body.instructions = f279A_parent_instructions;
                  body.emit(f279A);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r279E = bit_and(r278F, body.constant(3221225472u));
                  ir_expression *const r279F = equal(r279E, body.constant(0u));
                  ir_if *f279D = new(mem_ctx) ir_if(operand(r279F).val);
                  exec_list *const f279D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f279D->then_instructions;

                     body.emit(assign(r2791, add(r2791, body.constant(int(2))), 0x01));

                     body.emit(assign(r278F, lshift(r278F, body.constant(int(2))), 0x01));


                  body.instructions = f279D_parent_instructions;
                  body.emit(f279D);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r27A1 = bit_and(r278F, body.constant(2147483648u));
                  ir_expression *const r27A2 = equal(r27A1, body.constant(0u));
                  ir_if *f27A0 = new(mem_ctx) ir_if(operand(r27A2).val);
                  exec_list *const f27A0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f27A0->then_instructions;

                     body.emit(assign(r2791, add(r2791, body.constant(int(1))), 0x01));


                  body.instructions = f27A0_parent_instructions;
                  body.emit(f27A0);

                  /* END IF */

                  body.emit(assign(r2790, r2791, 0x01));


               body.instructions = f2792_parent_instructions;
               body.emit(f2792);

               /* END IF */

               body.emit(assign(r278C, add(r2790, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r27A4 = lequal(body.constant(int(0)), r278C);
               ir_if *f27A3 = new(mem_ctx) ir_if(operand(r27A4).val);
               exec_list *const f27A3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f27A3->then_instructions;

                  body.emit(assign(r278B, body.constant(0u), 0x01));

                  ir_variable *const r27A5 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r27A5, lshift(r278A, r278C), 0x01));

                  ir_variable *const r27A6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r27A8 = equal(r278C, body.constant(int(0)));
                  ir_if *f27A7 = new(mem_ctx) ir_if(operand(r27A8).val);
                  exec_list *const f27A7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f27A7->then_instructions;

                     body.emit(assign(r27A6, r2789, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f27A7->else_instructions;

                     ir_expression *const r27A9 = lshift(r2789, r278C);
                     ir_expression *const r27AA = neg(r278C);
                     ir_expression *const r27AB = bit_and(r27AA, body.constant(int(31)));
                     ir_expression *const r27AC = rshift(r278A, r27AB);
                     body.emit(assign(r27A6, bit_or(r27A9, r27AC), 0x01));


                  body.instructions = f27A7_parent_instructions;
                  body.emit(f27A7);

                  /* END IF */

                  body.emit(assign(r2789, r27A6, 0x01));

                  body.emit(assign(r278A, r27A5, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f27A3->else_instructions;

                  ir_variable *const r27AD = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r27AD, body.constant(0u), 0x01));

                  ir_variable *const r27AE = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r27AE, neg(r278C), 0x01));

                  ir_variable *const r27AF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r27AF);
                  ir_variable *const r27B0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r27B0);
                  ir_variable *const r27B1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r27B1);
                  ir_variable *const r27B2 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r27B3 = neg(r27AE);
                  body.emit(assign(r27B2, bit_and(r27B3, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r27B5 = equal(r27AE, body.constant(int(0)));
                  ir_if *f27B4 = new(mem_ctx) ir_if(operand(r27B5).val);
                  exec_list *const f27B4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f27B4->then_instructions;

                     body.emit(assign(r27AF, r27AD, 0x01));

                     body.emit(assign(r27B0, r278A, 0x01));

                     body.emit(assign(r27B1, r2789, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f27B4->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r27B7 = less(r27AE, body.constant(int(32)));
                     ir_if *f27B6 = new(mem_ctx) ir_if(operand(r27B7).val);
                     exec_list *const f27B6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f27B6->then_instructions;

                        body.emit(assign(r27AF, lshift(r278A, r27B2), 0x01));

                        ir_expression *const r27B8 = lshift(r2789, r27B2);
                        ir_expression *const r27B9 = rshift(r278A, r27AE);
                        body.emit(assign(r27B0, bit_or(r27B8, r27B9), 0x01));

                        body.emit(assign(r27B1, rshift(r2789, r27AE), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f27B6->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r27BB = equal(r27AE, body.constant(int(32)));
                        ir_if *f27BA = new(mem_ctx) ir_if(operand(r27BB).val);
                        exec_list *const f27BA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f27BA->then_instructions;

                           body.emit(assign(r27AF, r278A, 0x01));

                           body.emit(assign(r27B0, r2789, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f27BA->else_instructions;

                           body.emit(assign(r27AD, bit_or(body.constant(0u), r278A), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r27BD = less(r27AE, body.constant(int(64)));
                           ir_if *f27BC = new(mem_ctx) ir_if(operand(r27BD).val);
                           exec_list *const f27BC_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f27BC->then_instructions;

                              body.emit(assign(r27AF, lshift(r2789, r27B2), 0x01));

                              ir_expression *const r27BE = bit_and(r27AE, body.constant(int(31)));
                              body.emit(assign(r27B0, rshift(r2789, r27BE), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f27BC->else_instructions;

                              ir_variable *const r27BF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r27C1 = equal(r27AE, body.constant(int(64)));
                              ir_if *f27C0 = new(mem_ctx) ir_if(operand(r27C1).val);
                              exec_list *const f27C0_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f27C0->then_instructions;

                                 body.emit(assign(r27BF, r2789, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f27C0->else_instructions;

                                 ir_expression *const r27C2 = nequal(r2789, body.constant(0u));
                                 ir_expression *const r27C3 = expr(ir_unop_b2i, r27C2);
                                 body.emit(assign(r27BF, expr(ir_unop_i2u, r27C3), 0x01));


                              body.instructions = f27C0_parent_instructions;
                              body.emit(f27C0);

                              /* END IF */

                              body.emit(assign(r27AF, r27BF, 0x01));

                              body.emit(assign(r27B0, body.constant(0u), 0x01));


                           body.instructions = f27BC_parent_instructions;
                           body.emit(f27BC);

                           /* END IF */


                        body.instructions = f27BA_parent_instructions;
                        body.emit(f27BA);

                        /* END IF */

                        body.emit(assign(r27B1, body.constant(0u), 0x01));


                     body.instructions = f27B6_parent_instructions;
                     body.emit(f27B6);

                     /* END IF */

                     ir_expression *const r27C4 = nequal(r27AD, body.constant(0u));
                     ir_expression *const r27C5 = expr(ir_unop_b2i, r27C4);
                     ir_expression *const r27C6 = expr(ir_unop_i2u, r27C5);
                     body.emit(assign(r27AF, bit_or(r27AF, r27C6), 0x01));


                  body.instructions = f27B4_parent_instructions;
                  body.emit(f27B4);

                  /* END IF */

                  body.emit(assign(r2789, r27B1, 0x01));

                  body.emit(assign(r278A, r27B0, 0x01));

                  body.emit(assign(r278B, r27AF, 0x01));


               body.instructions = f27A3_parent_instructions;
               body.emit(f27A3);

               /* END IF */

               body.emit(assign(r2788, sub(r2788, r278C), 0x01));

               ir_variable *const r27C7 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r27C7, r2788, 0x01));

               ir_variable *const r27C8 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r27C8, r2789, 0x01));

               ir_variable *const r27C9 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r27C9, r278A, 0x01));

               ir_variable *const r27CA = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r27CA, r278B, 0x01));

               ir_variable *const r27CB = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r27CB, body.constant(true), 0x01));

               ir_variable *const r27CC = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r27CD = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r27CD);
               ir_expression *const r27CE = expr(ir_unop_u2i, r278B);
               body.emit(assign(r27CD, less(r27CE, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r27D0 = lequal(body.constant(int(2045)), r2788);
               ir_if *f27CF = new(mem_ctx) ir_if(operand(r27D0).val);
               exec_list *const f27CF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f27CF->then_instructions;

                  ir_variable *const r27D1 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r27D3 = less(body.constant(int(2045)), r2788);
                  ir_if *f27D2 = new(mem_ctx) ir_if(operand(r27D3).val);
                  exec_list *const f27D2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f27D2->then_instructions;

                     body.emit(assign(r27D1, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f27D2->else_instructions;

                     ir_variable *const r27D4 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r27D6 = equal(r2788, body.constant(int(2045)));
                     ir_if *f27D5 = new(mem_ctx) ir_if(operand(r27D6).val);
                     exec_list *const f27D5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f27D5->then_instructions;

                        ir_expression *const r27D7 = equal(body.constant(2097151u), r2789);
                        ir_expression *const r27D8 = equal(body.constant(4294967295u), r278A);
                        body.emit(assign(r27D4, logic_and(r27D7, r27D8), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f27D5->else_instructions;

                        body.emit(assign(r27D4, body.constant(false), 0x01));


                     body.instructions = f27D5_parent_instructions;
                     body.emit(f27D5);

                     /* END IF */

                     body.emit(assign(r27D1, logic_and(r27D4, r27CD), 0x01));


                  body.instructions = f27D2_parent_instructions;
                  body.emit(f27D2);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f27D9 = new(mem_ctx) ir_if(operand(r27D1).val);
                  exec_list *const f27D9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f27D9->then_instructions;

                     ir_variable *const r27DA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r27DA);
                     ir_expression *const r27DB = lshift(r2743, body.constant(int(31)));
                     body.emit(assign(r27DA, add(r27DB, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r27DA, body.constant(0u), 0x01));

                     body.emit(assign(r27CC, r27DA, 0x03));

                     body.emit(assign(r27CB, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f27D9->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r27DD = less(r2788, body.constant(int(0)));
                     ir_if *f27DC = new(mem_ctx) ir_if(operand(r27DD).val);
                     exec_list *const f27DC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f27DC->then_instructions;

                        ir_variable *const r27DE = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r27DE, r278B, 0x01));

                        ir_variable *const r27DF = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r27DF, neg(r2788), 0x01));

                        ir_variable *const r27E0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r27E0);
                        ir_variable *const r27E1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r27E1);
                        ir_variable *const r27E2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r27E2);
                        ir_variable *const r27E3 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r27E4 = neg(r27DF);
                        body.emit(assign(r27E3, bit_and(r27E4, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r27E6 = equal(r27DF, body.constant(int(0)));
                        ir_if *f27E5 = new(mem_ctx) ir_if(operand(r27E6).val);
                        exec_list *const f27E5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f27E5->then_instructions;

                           body.emit(assign(r27E0, r278B, 0x01));

                           body.emit(assign(r27E1, r278A, 0x01));

                           body.emit(assign(r27E2, r2789, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f27E5->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r27E8 = less(r27DF, body.constant(int(32)));
                           ir_if *f27E7 = new(mem_ctx) ir_if(operand(r27E8).val);
                           exec_list *const f27E7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f27E7->then_instructions;

                              body.emit(assign(r27E0, lshift(r278A, r27E3), 0x01));

                              ir_expression *const r27E9 = lshift(r2789, r27E3);
                              ir_expression *const r27EA = rshift(r278A, r27DF);
                              body.emit(assign(r27E1, bit_or(r27E9, r27EA), 0x01));

                              body.emit(assign(r27E2, rshift(r2789, r27DF), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f27E7->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r27EC = equal(r27DF, body.constant(int(32)));
                              ir_if *f27EB = new(mem_ctx) ir_if(operand(r27EC).val);
                              exec_list *const f27EB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f27EB->then_instructions;

                                 body.emit(assign(r27E0, r278A, 0x01));

                                 body.emit(assign(r27E1, r2789, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f27EB->else_instructions;

                                 body.emit(assign(r27DE, bit_or(r278B, r278A), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r27EE = less(r27DF, body.constant(int(64)));
                                 ir_if *f27ED = new(mem_ctx) ir_if(operand(r27EE).val);
                                 exec_list *const f27ED_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f27ED->then_instructions;

                                    body.emit(assign(r27E0, lshift(r2789, r27E3), 0x01));

                                    ir_expression *const r27EF = bit_and(r27DF, body.constant(int(31)));
                                    body.emit(assign(r27E1, rshift(r2789, r27EF), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f27ED->else_instructions;

                                    ir_variable *const r27F0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r27F2 = equal(r27DF, body.constant(int(64)));
                                    ir_if *f27F1 = new(mem_ctx) ir_if(operand(r27F2).val);
                                    exec_list *const f27F1_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f27F1->then_instructions;

                                       body.emit(assign(r27F0, r2789, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f27F1->else_instructions;

                                       ir_expression *const r27F3 = nequal(r2789, body.constant(0u));
                                       ir_expression *const r27F4 = expr(ir_unop_b2i, r27F3);
                                       body.emit(assign(r27F0, expr(ir_unop_i2u, r27F4), 0x01));


                                    body.instructions = f27F1_parent_instructions;
                                    body.emit(f27F1);

                                    /* END IF */

                                    body.emit(assign(r27E0, r27F0, 0x01));

                                    body.emit(assign(r27E1, body.constant(0u), 0x01));


                                 body.instructions = f27ED_parent_instructions;
                                 body.emit(f27ED);

                                 /* END IF */


                              body.instructions = f27EB_parent_instructions;
                              body.emit(f27EB);

                              /* END IF */

                              body.emit(assign(r27E2, body.constant(0u), 0x01));


                           body.instructions = f27E7_parent_instructions;
                           body.emit(f27E7);

                           /* END IF */

                           ir_expression *const r27F5 = nequal(r27DE, body.constant(0u));
                           ir_expression *const r27F6 = expr(ir_unop_b2i, r27F5);
                           ir_expression *const r27F7 = expr(ir_unop_i2u, r27F6);
                           body.emit(assign(r27E0, bit_or(r27E0, r27F7), 0x01));


                        body.instructions = f27E5_parent_instructions;
                        body.emit(f27E5);

                        /* END IF */

                        body.emit(assign(r27C8, r27E2, 0x01));

                        body.emit(assign(r27C9, r27E1, 0x01));

                        body.emit(assign(r27CA, r27E0, 0x01));

                        body.emit(assign(r27C7, body.constant(int(0)), 0x01));

                        body.emit(assign(r27CD, less(r27E0, body.constant(0u)), 0x01));


                     body.instructions = f27DC_parent_instructions;
                     body.emit(f27DC);

                     /* END IF */


                  body.instructions = f27D9_parent_instructions;
                  body.emit(f27D9);

                  /* END IF */


               body.instructions = f27CF_parent_instructions;
               body.emit(f27CF);

               /* END IF */

               /* IF CONDITION */
               ir_if *f27F8 = new(mem_ctx) ir_if(operand(r27CB).val);
               exec_list *const f27F8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f27F8->then_instructions;

                  /* IF CONDITION */
                  ir_if *f27F9 = new(mem_ctx) ir_if(operand(r27CD).val);
                  exec_list *const f27F9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f27F9->then_instructions;

                     ir_variable *const r27FA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r27FA, add(r27C9, body.constant(1u)), 0x01));

                     ir_expression *const r27FB = less(r27FA, r27C9);
                     ir_expression *const r27FC = expr(ir_unop_b2i, r27FB);
                     ir_expression *const r27FD = expr(ir_unop_i2u, r27FC);
                     body.emit(assign(r27C8, add(r27C8, r27FD), 0x01));

                     ir_expression *const r27FE = equal(r27CA, body.constant(0u));
                     ir_expression *const r27FF = expr(ir_unop_b2i, r27FE);
                     ir_expression *const r2800 = expr(ir_unop_i2u, r27FF);
                     ir_expression *const r2801 = add(r27CA, r2800);
                     ir_expression *const r2802 = bit_and(r2801, body.constant(1u));
                     ir_expression *const r2803 = expr(ir_unop_bit_not, r2802);
                     body.emit(assign(r27C9, bit_and(r27FA, r2803), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f27F9->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2805 = bit_or(r27C8, r27C9);
                     ir_expression *const r2806 = equal(r2805, body.constant(0u));
                     ir_if *f2804 = new(mem_ctx) ir_if(operand(r2806).val);
                     exec_list *const f2804_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2804->then_instructions;

                        body.emit(assign(r27C7, body.constant(int(0)), 0x01));


                     body.instructions = f2804_parent_instructions;
                     body.emit(f2804);

                     /* END IF */


                  body.instructions = f27F9_parent_instructions;
                  body.emit(f27F9);

                  /* END IF */

                  ir_variable *const r2807 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2807);
                  ir_expression *const r2808 = lshift(r2743, body.constant(int(31)));
                  ir_expression *const r2809 = expr(ir_unop_i2u, r27C7);
                  ir_expression *const r280A = lshift(r2809, body.constant(int(20)));
                  ir_expression *const r280B = add(r2808, r280A);
                  body.emit(assign(r2807, add(r280B, r27C8), 0x02));

                  body.emit(assign(r2807, r27C9, 0x01));

                  body.emit(assign(r27CC, r2807, 0x03));

                  body.emit(assign(r27CB, body.constant(false), 0x01));


               body.instructions = f27F8_parent_instructions;
               body.emit(f27F8);

               /* END IF */

               body.emit(assign(r2747, r27CC, 0x03));


            body.instructions = f275D_parent_instructions;
            body.emit(f275D);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f275B->else_instructions;

            /* IF CONDITION */
            ir_expression *const r280D = less(r2748, body.constant(int(0)));
            ir_if *f280C = new(mem_ctx) ir_if(operand(r280D).val);
            exec_list *const f280C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f280C->then_instructions;

               /* IF CONDITION */
               ir_expression *const r280F = equal(r2751, body.constant(int(0)));
               ir_if *f280E = new(mem_ctx) ir_if(operand(r280F).val);
               exec_list *const f280E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f280E->then_instructions;

                  body.emit(assign(r2748, add(r2748, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f280E->else_instructions;

                  body.emit(assign(r274D, bit_or(r274D, body.constant(1073741824u)), 0x01));


               body.instructions = f280E_parent_instructions;
               body.emit(f280E);

               /* END IF */

               ir_variable *const r2810 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r2810, neg(r2748), 0x01));

               ir_variable *const r2811 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2811);
               ir_variable *const r2812 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2812);
               ir_variable *const r2813 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2814 = neg(r2810);
               body.emit(assign(r2813, bit_and(r2814, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2816 = equal(r2810, body.constant(int(0)));
               ir_if *f2815 = new(mem_ctx) ir_if(operand(r2816).val);
               exec_list *const f2815_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2815->then_instructions;

                  body.emit(assign(r2811, r2754, 0x01));

                  body.emit(assign(r2812, r274D, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2815->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2818 = less(r2810, body.constant(int(32)));
                  ir_if *f2817 = new(mem_ctx) ir_if(operand(r2818).val);
                  exec_list *const f2817_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2817->then_instructions;

                     ir_expression *const r2819 = lshift(r274D, r2813);
                     ir_expression *const r281A = rshift(r2754, r2810);
                     ir_expression *const r281B = bit_or(r2819, r281A);
                     ir_expression *const r281C = lshift(r2754, r2813);
                     ir_expression *const r281D = nequal(r281C, body.constant(0u));
                     ir_expression *const r281E = expr(ir_unop_b2i, r281D);
                     ir_expression *const r281F = expr(ir_unop_i2u, r281E);
                     body.emit(assign(r2811, bit_or(r281B, r281F), 0x01));

                     body.emit(assign(r2812, rshift(r274D, r2810), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2817->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2821 = equal(r2810, body.constant(int(32)));
                     ir_if *f2820 = new(mem_ctx) ir_if(operand(r2821).val);
                     exec_list *const f2820_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2820->then_instructions;

                        ir_expression *const r2822 = nequal(r2754, body.constant(0u));
                        ir_expression *const r2823 = expr(ir_unop_b2i, r2822);
                        ir_expression *const r2824 = expr(ir_unop_i2u, r2823);
                        body.emit(assign(r2811, bit_or(r274D, r2824), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2820->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2826 = less(r2810, body.constant(int(64)));
                        ir_if *f2825 = new(mem_ctx) ir_if(operand(r2826).val);
                        exec_list *const f2825_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2825->then_instructions;

                           ir_expression *const r2827 = bit_and(r2810, body.constant(int(31)));
                           ir_expression *const r2828 = rshift(r274D, r2827);
                           ir_expression *const r2829 = lshift(r274D, r2813);
                           ir_expression *const r282A = bit_or(r2829, r2754);
                           ir_expression *const r282B = nequal(r282A, body.constant(0u));
                           ir_expression *const r282C = expr(ir_unop_b2i, r282B);
                           ir_expression *const r282D = expr(ir_unop_i2u, r282C);
                           body.emit(assign(r2811, bit_or(r2828, r282D), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2825->else_instructions;

                           ir_expression *const r282E = bit_or(r274D, r2754);
                           ir_expression *const r282F = nequal(r282E, body.constant(0u));
                           ir_expression *const r2830 = expr(ir_unop_b2i, r282F);
                           body.emit(assign(r2811, expr(ir_unop_i2u, r2830), 0x01));


                        body.instructions = f2825_parent_instructions;
                        body.emit(f2825);

                        /* END IF */


                     body.instructions = f2820_parent_instructions;
                     body.emit(f2820);

                     /* END IF */

                     body.emit(assign(r2812, body.constant(0u), 0x01));


                  body.instructions = f2817_parent_instructions;
                  body.emit(f2817);

                  /* END IF */


               body.instructions = f2815_parent_instructions;
               body.emit(f2815);

               /* END IF */

               body.emit(assign(r274D, r2812, 0x01));

               body.emit(assign(r274E, r2811, 0x01));

               body.emit(assign(r274B, bit_or(r274B, body.constant(1073741824u)), 0x01));

               ir_variable *const r2831 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r2832 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r2832, sub(r274C, r2811), 0x01));

               ir_expression *const r2833 = sub(r274B, r2812);
               ir_expression *const r2834 = less(r274C, r2811);
               ir_expression *const r2835 = expr(ir_unop_b2i, r2834);
               ir_expression *const r2836 = expr(ir_unop_i2u, r2835);
               body.emit(assign(r2831, sub(r2833, r2836), 0x01));

               body.emit(assign(r2746, bit_xor(r2743, body.constant(1u)), 0x01));

               body.emit(assign(r274F, body.constant(int(1022)), 0x01));

               ir_variable *const r2837 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2837, body.constant(int(1012)), 0x01));

               ir_variable *const r2838 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2838, r2831, 0x01));

               ir_variable *const r2839 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2839, r2832, 0x01));

               ir_variable *const r283A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r283A);
               ir_variable *const r283B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r283B);
               /* IF CONDITION */
               ir_expression *const r283D = equal(r2831, body.constant(0u));
               ir_if *f283C = new(mem_ctx) ir_if(operand(r283D).val);
               exec_list *const f283C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f283C->then_instructions;

                  body.emit(assign(r2838, r2832, 0x01));

                  body.emit(assign(r2839, body.constant(0u), 0x01));

                  body.emit(assign(r2837, body.constant(int(980)), 0x01));


               body.instructions = f283C_parent_instructions;
               body.emit(f283C);

               /* END IF */

               ir_variable *const r283E = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r283E, r2838, 0x01));

               ir_variable *const r283F = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r2840 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r2840);
               /* IF CONDITION */
               ir_expression *const r2842 = equal(r2838, body.constant(0u));
               ir_if *f2841 = new(mem_ctx) ir_if(operand(r2842).val);
               exec_list *const f2841_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2841->then_instructions;

                  body.emit(assign(r283F, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2841->else_instructions;

                  body.emit(assign(r2840, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2844 = bit_and(r2838, body.constant(4294901760u));
                  ir_expression *const r2845 = equal(r2844, body.constant(0u));
                  ir_if *f2843 = new(mem_ctx) ir_if(operand(r2845).val);
                  exec_list *const f2843_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2843->then_instructions;

                     body.emit(assign(r2840, body.constant(int(16)), 0x01));

                     body.emit(assign(r283E, lshift(r2838, body.constant(int(16))), 0x01));


                  body.instructions = f2843_parent_instructions;
                  body.emit(f2843);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2847 = bit_and(r283E, body.constant(4278190080u));
                  ir_expression *const r2848 = equal(r2847, body.constant(0u));
                  ir_if *f2846 = new(mem_ctx) ir_if(operand(r2848).val);
                  exec_list *const f2846_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2846->then_instructions;

                     body.emit(assign(r2840, add(r2840, body.constant(int(8))), 0x01));

                     body.emit(assign(r283E, lshift(r283E, body.constant(int(8))), 0x01));


                  body.instructions = f2846_parent_instructions;
                  body.emit(f2846);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r284A = bit_and(r283E, body.constant(4026531840u));
                  ir_expression *const r284B = equal(r284A, body.constant(0u));
                  ir_if *f2849 = new(mem_ctx) ir_if(operand(r284B).val);
                  exec_list *const f2849_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2849->then_instructions;

                     body.emit(assign(r2840, add(r2840, body.constant(int(4))), 0x01));

                     body.emit(assign(r283E, lshift(r283E, body.constant(int(4))), 0x01));


                  body.instructions = f2849_parent_instructions;
                  body.emit(f2849);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r284D = bit_and(r283E, body.constant(3221225472u));
                  ir_expression *const r284E = equal(r284D, body.constant(0u));
                  ir_if *f284C = new(mem_ctx) ir_if(operand(r284E).val);
                  exec_list *const f284C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f284C->then_instructions;

                     body.emit(assign(r2840, add(r2840, body.constant(int(2))), 0x01));

                     body.emit(assign(r283E, lshift(r283E, body.constant(int(2))), 0x01));


                  body.instructions = f284C_parent_instructions;
                  body.emit(f284C);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2850 = bit_and(r283E, body.constant(2147483648u));
                  ir_expression *const r2851 = equal(r2850, body.constant(0u));
                  ir_if *f284F = new(mem_ctx) ir_if(operand(r2851).val);
                  exec_list *const f284F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f284F->then_instructions;

                     body.emit(assign(r2840, add(r2840, body.constant(int(1))), 0x01));


                  body.instructions = f284F_parent_instructions;
                  body.emit(f284F);

                  /* END IF */

                  body.emit(assign(r283F, r2840, 0x01));


               body.instructions = f2841_parent_instructions;
               body.emit(f2841);

               /* END IF */

               body.emit(assign(r283B, add(r283F, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2853 = lequal(body.constant(int(0)), r283B);
               ir_if *f2852 = new(mem_ctx) ir_if(operand(r2853).val);
               exec_list *const f2852_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2852->then_instructions;

                  body.emit(assign(r283A, body.constant(0u), 0x01));

                  ir_variable *const r2854 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r2854, lshift(r2839, r283B), 0x01));

                  ir_variable *const r2855 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2857 = equal(r283B, body.constant(int(0)));
                  ir_if *f2856 = new(mem_ctx) ir_if(operand(r2857).val);
                  exec_list *const f2856_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2856->then_instructions;

                     body.emit(assign(r2855, r2838, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2856->else_instructions;

                     ir_expression *const r2858 = lshift(r2838, r283B);
                     ir_expression *const r2859 = neg(r283B);
                     ir_expression *const r285A = bit_and(r2859, body.constant(int(31)));
                     ir_expression *const r285B = rshift(r2839, r285A);
                     body.emit(assign(r2855, bit_or(r2858, r285B), 0x01));


                  body.instructions = f2856_parent_instructions;
                  body.emit(f2856);

                  /* END IF */

                  body.emit(assign(r2838, r2855, 0x01));

                  body.emit(assign(r2839, r2854, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2852->else_instructions;

                  ir_variable *const r285C = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r285C, body.constant(0u), 0x01));

                  ir_variable *const r285D = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r285D, neg(r283B), 0x01));

                  ir_variable *const r285E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r285E);
                  ir_variable *const r285F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r285F);
                  ir_variable *const r2860 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r2860);
                  ir_variable *const r2861 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r2862 = neg(r285D);
                  body.emit(assign(r2861, bit_and(r2862, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2864 = equal(r285D, body.constant(int(0)));
                  ir_if *f2863 = new(mem_ctx) ir_if(operand(r2864).val);
                  exec_list *const f2863_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2863->then_instructions;

                     body.emit(assign(r285E, r285C, 0x01));

                     body.emit(assign(r285F, r2839, 0x01));

                     body.emit(assign(r2860, r2838, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2863->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2866 = less(r285D, body.constant(int(32)));
                     ir_if *f2865 = new(mem_ctx) ir_if(operand(r2866).val);
                     exec_list *const f2865_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2865->then_instructions;

                        body.emit(assign(r285E, lshift(r2839, r2861), 0x01));

                        ir_expression *const r2867 = lshift(r2838, r2861);
                        ir_expression *const r2868 = rshift(r2839, r285D);
                        body.emit(assign(r285F, bit_or(r2867, r2868), 0x01));

                        body.emit(assign(r2860, rshift(r2838, r285D), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2865->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r286A = equal(r285D, body.constant(int(32)));
                        ir_if *f2869 = new(mem_ctx) ir_if(operand(r286A).val);
                        exec_list *const f2869_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2869->then_instructions;

                           body.emit(assign(r285E, r2839, 0x01));

                           body.emit(assign(r285F, r2838, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2869->else_instructions;

                           body.emit(assign(r285C, bit_or(body.constant(0u), r2839), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r286C = less(r285D, body.constant(int(64)));
                           ir_if *f286B = new(mem_ctx) ir_if(operand(r286C).val);
                           exec_list *const f286B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f286B->then_instructions;

                              body.emit(assign(r285E, lshift(r2838, r2861), 0x01));

                              ir_expression *const r286D = bit_and(r285D, body.constant(int(31)));
                              body.emit(assign(r285F, rshift(r2838, r286D), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f286B->else_instructions;

                              ir_variable *const r286E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2870 = equal(r285D, body.constant(int(64)));
                              ir_if *f286F = new(mem_ctx) ir_if(operand(r2870).val);
                              exec_list *const f286F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f286F->then_instructions;

                                 body.emit(assign(r286E, r2838, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f286F->else_instructions;

                                 ir_expression *const r2871 = nequal(r2838, body.constant(0u));
                                 ir_expression *const r2872 = expr(ir_unop_b2i, r2871);
                                 body.emit(assign(r286E, expr(ir_unop_i2u, r2872), 0x01));


                              body.instructions = f286F_parent_instructions;
                              body.emit(f286F);

                              /* END IF */

                              body.emit(assign(r285E, r286E, 0x01));

                              body.emit(assign(r285F, body.constant(0u), 0x01));


                           body.instructions = f286B_parent_instructions;
                           body.emit(f286B);

                           /* END IF */


                        body.instructions = f2869_parent_instructions;
                        body.emit(f2869);

                        /* END IF */

                        body.emit(assign(r2860, body.constant(0u), 0x01));


                     body.instructions = f2865_parent_instructions;
                     body.emit(f2865);

                     /* END IF */

                     ir_expression *const r2873 = nequal(r285C, body.constant(0u));
                     ir_expression *const r2874 = expr(ir_unop_b2i, r2873);
                     ir_expression *const r2875 = expr(ir_unop_i2u, r2874);
                     body.emit(assign(r285E, bit_or(r285E, r2875), 0x01));


                  body.instructions = f2863_parent_instructions;
                  body.emit(f2863);

                  /* END IF */

                  body.emit(assign(r2838, r2860, 0x01));

                  body.emit(assign(r2839, r285F, 0x01));

                  body.emit(assign(r283A, r285E, 0x01));


               body.instructions = f2852_parent_instructions;
               body.emit(f2852);

               /* END IF */

               body.emit(assign(r2837, sub(r2837, r283B), 0x01));

               ir_variable *const r2876 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2876, r2837, 0x01));

               ir_variable *const r2877 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2877, r2838, 0x01));

               ir_variable *const r2878 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2878, r2839, 0x01));

               ir_variable *const r2879 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r2879, r283A, 0x01));

               ir_variable *const r287A = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r287A, body.constant(true), 0x01));

               ir_variable *const r287B = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r287C = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r287C);
               ir_expression *const r287D = expr(ir_unop_u2i, r283A);
               body.emit(assign(r287C, less(r287D, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r287F = lequal(body.constant(int(2045)), r2837);
               ir_if *f287E = new(mem_ctx) ir_if(operand(r287F).val);
               exec_list *const f287E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f287E->then_instructions;

                  ir_variable *const r2880 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2882 = less(body.constant(int(2045)), r2837);
                  ir_if *f2881 = new(mem_ctx) ir_if(operand(r2882).val);
                  exec_list *const f2881_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2881->then_instructions;

                     body.emit(assign(r2880, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2881->else_instructions;

                     ir_variable *const r2883 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2885 = equal(r2837, body.constant(int(2045)));
                     ir_if *f2884 = new(mem_ctx) ir_if(operand(r2885).val);
                     exec_list *const f2884_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2884->then_instructions;

                        ir_expression *const r2886 = equal(body.constant(2097151u), r2838);
                        ir_expression *const r2887 = equal(body.constant(4294967295u), r2839);
                        body.emit(assign(r2883, logic_and(r2886, r2887), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2884->else_instructions;

                        body.emit(assign(r2883, body.constant(false), 0x01));


                     body.instructions = f2884_parent_instructions;
                     body.emit(f2884);

                     /* END IF */

                     body.emit(assign(r2880, logic_and(r2883, r287C), 0x01));


                  body.instructions = f2881_parent_instructions;
                  body.emit(f2881);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2888 = new(mem_ctx) ir_if(operand(r2880).val);
                  exec_list *const f2888_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2888->then_instructions;

                     ir_variable *const r2889 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2889);
                     ir_expression *const r288A = lshift(r2746, body.constant(int(31)));
                     body.emit(assign(r2889, add(r288A, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r2889, body.constant(0u), 0x01));

                     body.emit(assign(r287B, r2889, 0x03));

                     body.emit(assign(r287A, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2888->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r288C = less(r2837, body.constant(int(0)));
                     ir_if *f288B = new(mem_ctx) ir_if(operand(r288C).val);
                     exec_list *const f288B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f288B->then_instructions;

                        ir_variable *const r288D = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r288D, r283A, 0x01));

                        ir_variable *const r288E = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r288E, neg(r2837), 0x01));

                        ir_variable *const r288F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r288F);
                        ir_variable *const r2890 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2890);
                        ir_variable *const r2891 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2891);
                        ir_variable *const r2892 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2893 = neg(r288E);
                        body.emit(assign(r2892, bit_and(r2893, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2895 = equal(r288E, body.constant(int(0)));
                        ir_if *f2894 = new(mem_ctx) ir_if(operand(r2895).val);
                        exec_list *const f2894_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2894->then_instructions;

                           body.emit(assign(r288F, r283A, 0x01));

                           body.emit(assign(r2890, r2839, 0x01));

                           body.emit(assign(r2891, r2838, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2894->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2897 = less(r288E, body.constant(int(32)));
                           ir_if *f2896 = new(mem_ctx) ir_if(operand(r2897).val);
                           exec_list *const f2896_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2896->then_instructions;

                              body.emit(assign(r288F, lshift(r2839, r2892), 0x01));

                              ir_expression *const r2898 = lshift(r2838, r2892);
                              ir_expression *const r2899 = rshift(r2839, r288E);
                              body.emit(assign(r2890, bit_or(r2898, r2899), 0x01));

                              body.emit(assign(r2891, rshift(r2838, r288E), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2896->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r289B = equal(r288E, body.constant(int(32)));
                              ir_if *f289A = new(mem_ctx) ir_if(operand(r289B).val);
                              exec_list *const f289A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f289A->then_instructions;

                                 body.emit(assign(r288F, r2839, 0x01));

                                 body.emit(assign(r2890, r2838, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f289A->else_instructions;

                                 body.emit(assign(r288D, bit_or(r283A, r2839), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r289D = less(r288E, body.constant(int(64)));
                                 ir_if *f289C = new(mem_ctx) ir_if(operand(r289D).val);
                                 exec_list *const f289C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f289C->then_instructions;

                                    body.emit(assign(r288F, lshift(r2838, r2892), 0x01));

                                    ir_expression *const r289E = bit_and(r288E, body.constant(int(31)));
                                    body.emit(assign(r2890, rshift(r2838, r289E), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f289C->else_instructions;

                                    ir_variable *const r289F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r28A1 = equal(r288E, body.constant(int(64)));
                                    ir_if *f28A0 = new(mem_ctx) ir_if(operand(r28A1).val);
                                    exec_list *const f28A0_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f28A0->then_instructions;

                                       body.emit(assign(r289F, r2838, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f28A0->else_instructions;

                                       ir_expression *const r28A2 = nequal(r2838, body.constant(0u));
                                       ir_expression *const r28A3 = expr(ir_unop_b2i, r28A2);
                                       body.emit(assign(r289F, expr(ir_unop_i2u, r28A3), 0x01));


                                    body.instructions = f28A0_parent_instructions;
                                    body.emit(f28A0);

                                    /* END IF */

                                    body.emit(assign(r288F, r289F, 0x01));

                                    body.emit(assign(r2890, body.constant(0u), 0x01));


                                 body.instructions = f289C_parent_instructions;
                                 body.emit(f289C);

                                 /* END IF */


                              body.instructions = f289A_parent_instructions;
                              body.emit(f289A);

                              /* END IF */

                              body.emit(assign(r2891, body.constant(0u), 0x01));


                           body.instructions = f2896_parent_instructions;
                           body.emit(f2896);

                           /* END IF */

                           ir_expression *const r28A4 = nequal(r288D, body.constant(0u));
                           ir_expression *const r28A5 = expr(ir_unop_b2i, r28A4);
                           ir_expression *const r28A6 = expr(ir_unop_i2u, r28A5);
                           body.emit(assign(r288F, bit_or(r288F, r28A6), 0x01));


                        body.instructions = f2894_parent_instructions;
                        body.emit(f2894);

                        /* END IF */

                        body.emit(assign(r2877, r2891, 0x01));

                        body.emit(assign(r2878, r2890, 0x01));

                        body.emit(assign(r2879, r288F, 0x01));

                        body.emit(assign(r2876, body.constant(int(0)), 0x01));

                        body.emit(assign(r287C, less(r288F, body.constant(0u)), 0x01));


                     body.instructions = f288B_parent_instructions;
                     body.emit(f288B);

                     /* END IF */


                  body.instructions = f2888_parent_instructions;
                  body.emit(f2888);

                  /* END IF */


               body.instructions = f287E_parent_instructions;
               body.emit(f287E);

               /* END IF */

               /* IF CONDITION */
               ir_if *f28A7 = new(mem_ctx) ir_if(operand(r287A).val);
               exec_list *const f28A7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f28A7->then_instructions;

                  /* IF CONDITION */
                  ir_if *f28A8 = new(mem_ctx) ir_if(operand(r287C).val);
                  exec_list *const f28A8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f28A8->then_instructions;

                     ir_variable *const r28A9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r28A9, add(r2878, body.constant(1u)), 0x01));

                     ir_expression *const r28AA = less(r28A9, r2878);
                     ir_expression *const r28AB = expr(ir_unop_b2i, r28AA);
                     ir_expression *const r28AC = expr(ir_unop_i2u, r28AB);
                     body.emit(assign(r2877, add(r2877, r28AC), 0x01));

                     ir_expression *const r28AD = equal(r2879, body.constant(0u));
                     ir_expression *const r28AE = expr(ir_unop_b2i, r28AD);
                     ir_expression *const r28AF = expr(ir_unop_i2u, r28AE);
                     ir_expression *const r28B0 = add(r2879, r28AF);
                     ir_expression *const r28B1 = bit_and(r28B0, body.constant(1u));
                     ir_expression *const r28B2 = expr(ir_unop_bit_not, r28B1);
                     body.emit(assign(r2878, bit_and(r28A9, r28B2), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f28A8->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r28B4 = bit_or(r2877, r2878);
                     ir_expression *const r28B5 = equal(r28B4, body.constant(0u));
                     ir_if *f28B3 = new(mem_ctx) ir_if(operand(r28B5).val);
                     exec_list *const f28B3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f28B3->then_instructions;

                        body.emit(assign(r2876, body.constant(int(0)), 0x01));


                     body.instructions = f28B3_parent_instructions;
                     body.emit(f28B3);

                     /* END IF */


                  body.instructions = f28A8_parent_instructions;
                  body.emit(f28A8);

                  /* END IF */

                  ir_variable *const r28B6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r28B6);
                  ir_expression *const r28B7 = lshift(r2746, body.constant(int(31)));
                  ir_expression *const r28B8 = expr(ir_unop_i2u, r2876);
                  ir_expression *const r28B9 = lshift(r28B8, body.constant(int(20)));
                  ir_expression *const r28BA = add(r28B7, r28B9);
                  body.emit(assign(r28B6, add(r28BA, r2877), 0x02));

                  body.emit(assign(r28B6, r2878, 0x01));

                  body.emit(assign(r287B, r28B6, 0x03));

                  body.emit(assign(r287A, body.constant(false), 0x01));


               body.instructions = f28A7_parent_instructions;
               body.emit(f28A7);

               /* END IF */

               body.emit(assign(r2747, r287B, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f280C->else_instructions;

               /* IF CONDITION */
               ir_expression *const r28BC = equal(r2751, body.constant(int(2047)));
               ir_if *f28BB = new(mem_ctx) ir_if(operand(r28BC).val);
               exec_list *const f28BB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f28BB->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r28BE = bit_or(r274D, r274E);
                  ir_expression *const r28BF = bit_or(r274B, r274C);
                  ir_expression *const r28C0 = bit_or(r28BE, r28BF);
                  ir_expression *const r28C1 = nequal(r28C0, body.constant(0u));
                  ir_if *f28BD = new(mem_ctx) ir_if(operand(r28C1).val);
                  exec_list *const f28BD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f28BD->then_instructions;

                     ir_variable *const r28C2 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r28C2, swizzle_x(r270D), 0x01));

                     ir_variable *const r28C3 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r28C3, body.constant(0u), 0x01));

                     ir_variable *const r28C4 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r28C2, bit_or(swizzle_y(r270D), body.constant(524288u)), 0x02));

                     body.emit(assign(r28C3, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r28C6 = lshift(swizzle_y(r270D), body.constant(int(1)));
                     ir_expression *const r28C7 = lequal(body.constant(4292870144u), r28C6);
                     ir_expression *const r28C8 = nequal(swizzle_x(r270D), body.constant(0u));
                     ir_expression *const r28C9 = bit_and(swizzle_y(r270D), body.constant(1048575u));
                     ir_expression *const r28CA = nequal(r28C9, body.constant(0u));
                     ir_expression *const r28CB = logic_or(r28C8, r28CA);
                     ir_expression *const r28CC = logic_and(r28C7, r28CB);
                     ir_if *f28C5 = new(mem_ctx) ir_if(operand(r28CC).val);
                     exec_list *const f28C5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f28C5->then_instructions;

                        body.emit(assign(r28C4, r28C2, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f28C5->else_instructions;

                        body.emit(assign(r28C4, r28C3, 0x03));


                     body.instructions = f28C5_parent_instructions;
                     body.emit(f28C5);

                     /* END IF */

                     body.emit(assign(r2747, r28C4, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f28BD->else_instructions;

                     ir_constant_data r28CD_data;
                     memset(&r28CD_data, 0, sizeof(ir_constant_data));
                     r28CD_data.u[0] = 4294967295;
                     r28CD_data.u[1] = 4294967295;
                     ir_constant *const r28CD = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r28CD_data);
                     body.emit(assign(r2747, r28CD, 0x03));


                  body.instructions = f28BD_parent_instructions;
                  body.emit(f28BD);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f28BB->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r28CF = equal(r2751, body.constant(int(0)));
                  ir_if *f28CE = new(mem_ctx) ir_if(operand(r28CF).val);
                  exec_list *const f28CE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f28CE->then_instructions;

                     body.emit(assign(r274A, body.constant(int(1)), 0x01));

                     body.emit(assign(r2749, body.constant(int(1)), 0x01));


                  body.instructions = f28CE_parent_instructions;
                  body.emit(f28CE);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r28D1 = less(r274B, r274D);
                  ir_if *f28D0 = new(mem_ctx) ir_if(operand(r28D1).val);
                  exec_list *const f28D0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f28D0->then_instructions;

                     ir_variable *const r28D2 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r28D3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r28D3, sub(r274E, r274C), 0x01));

                     ir_expression *const r28D4 = sub(r274D, r274B);
                     ir_expression *const r28D5 = less(r274E, r274C);
                     ir_expression *const r28D6 = expr(ir_unop_b2i, r28D5);
                     ir_expression *const r28D7 = expr(ir_unop_i2u, r28D6);
                     body.emit(assign(r28D2, sub(r28D4, r28D7), 0x01));

                     body.emit(assign(r274F, add(r274A, body.constant(int(-1))), 0x01));

                     ir_variable *const r28D8 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r28D8, add(r274F, body.constant(int(-10))), 0x01));

                     ir_variable *const r28D9 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r28D9, r28D2, 0x01));

                     ir_variable *const r28DA = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r28DA, r28D3, 0x01));

                     ir_variable *const r28DB = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r28DB);
                     ir_variable *const r28DC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r28DC);
                     /* IF CONDITION */
                     ir_expression *const r28DE = equal(r28D2, body.constant(0u));
                     ir_if *f28DD = new(mem_ctx) ir_if(operand(r28DE).val);
                     exec_list *const f28DD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f28DD->then_instructions;

                        body.emit(assign(r28D9, r28D3, 0x01));

                        body.emit(assign(r28DA, body.constant(0u), 0x01));

                        body.emit(assign(r28D8, add(r28D8, body.constant(int(-32))), 0x01));


                     body.instructions = f28DD_parent_instructions;
                     body.emit(f28DD);

                     /* END IF */

                     ir_variable *const r28DF = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r28DF, r28D9, 0x01));

                     ir_variable *const r28E0 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r28E1 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r28E1);
                     /* IF CONDITION */
                     ir_expression *const r28E3 = equal(r28D9, body.constant(0u));
                     ir_if *f28E2 = new(mem_ctx) ir_if(operand(r28E3).val);
                     exec_list *const f28E2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f28E2->then_instructions;

                        body.emit(assign(r28E0, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f28E2->else_instructions;

                        body.emit(assign(r28E1, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r28E5 = bit_and(r28D9, body.constant(4294901760u));
                        ir_expression *const r28E6 = equal(r28E5, body.constant(0u));
                        ir_if *f28E4 = new(mem_ctx) ir_if(operand(r28E6).val);
                        exec_list *const f28E4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f28E4->then_instructions;

                           body.emit(assign(r28E1, body.constant(int(16)), 0x01));

                           body.emit(assign(r28DF, lshift(r28D9, body.constant(int(16))), 0x01));


                        body.instructions = f28E4_parent_instructions;
                        body.emit(f28E4);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r28E8 = bit_and(r28DF, body.constant(4278190080u));
                        ir_expression *const r28E9 = equal(r28E8, body.constant(0u));
                        ir_if *f28E7 = new(mem_ctx) ir_if(operand(r28E9).val);
                        exec_list *const f28E7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f28E7->then_instructions;

                           body.emit(assign(r28E1, add(r28E1, body.constant(int(8))), 0x01));

                           body.emit(assign(r28DF, lshift(r28DF, body.constant(int(8))), 0x01));


                        body.instructions = f28E7_parent_instructions;
                        body.emit(f28E7);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r28EB = bit_and(r28DF, body.constant(4026531840u));
                        ir_expression *const r28EC = equal(r28EB, body.constant(0u));
                        ir_if *f28EA = new(mem_ctx) ir_if(operand(r28EC).val);
                        exec_list *const f28EA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f28EA->then_instructions;

                           body.emit(assign(r28E1, add(r28E1, body.constant(int(4))), 0x01));

                           body.emit(assign(r28DF, lshift(r28DF, body.constant(int(4))), 0x01));


                        body.instructions = f28EA_parent_instructions;
                        body.emit(f28EA);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r28EE = bit_and(r28DF, body.constant(3221225472u));
                        ir_expression *const r28EF = equal(r28EE, body.constant(0u));
                        ir_if *f28ED = new(mem_ctx) ir_if(operand(r28EF).val);
                        exec_list *const f28ED_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f28ED->then_instructions;

                           body.emit(assign(r28E1, add(r28E1, body.constant(int(2))), 0x01));

                           body.emit(assign(r28DF, lshift(r28DF, body.constant(int(2))), 0x01));


                        body.instructions = f28ED_parent_instructions;
                        body.emit(f28ED);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r28F1 = bit_and(r28DF, body.constant(2147483648u));
                        ir_expression *const r28F2 = equal(r28F1, body.constant(0u));
                        ir_if *f28F0 = new(mem_ctx) ir_if(operand(r28F2).val);
                        exec_list *const f28F0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f28F0->then_instructions;

                           body.emit(assign(r28E1, add(r28E1, body.constant(int(1))), 0x01));


                        body.instructions = f28F0_parent_instructions;
                        body.emit(f28F0);

                        /* END IF */

                        body.emit(assign(r28E0, r28E1, 0x01));


                     body.instructions = f28E2_parent_instructions;
                     body.emit(f28E2);

                     /* END IF */

                     body.emit(assign(r28DC, add(r28E0, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r28F4 = lequal(body.constant(int(0)), r28DC);
                     ir_if *f28F3 = new(mem_ctx) ir_if(operand(r28F4).val);
                     exec_list *const f28F3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f28F3->then_instructions;

                        body.emit(assign(r28DB, body.constant(0u), 0x01));

                        ir_variable *const r28F5 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r28F5, lshift(r28DA, r28DC), 0x01));

                        ir_variable *const r28F6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r28F8 = equal(r28DC, body.constant(int(0)));
                        ir_if *f28F7 = new(mem_ctx) ir_if(operand(r28F8).val);
                        exec_list *const f28F7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f28F7->then_instructions;

                           body.emit(assign(r28F6, r28D9, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f28F7->else_instructions;

                           ir_expression *const r28F9 = lshift(r28D9, r28DC);
                           ir_expression *const r28FA = neg(r28DC);
                           ir_expression *const r28FB = bit_and(r28FA, body.constant(int(31)));
                           ir_expression *const r28FC = rshift(r28DA, r28FB);
                           body.emit(assign(r28F6, bit_or(r28F9, r28FC), 0x01));


                        body.instructions = f28F7_parent_instructions;
                        body.emit(f28F7);

                        /* END IF */

                        body.emit(assign(r28D9, r28F6, 0x01));

                        body.emit(assign(r28DA, r28F5, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f28F3->else_instructions;

                        ir_variable *const r28FD = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r28FD, body.constant(0u), 0x01));

                        ir_variable *const r28FE = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r28FE, neg(r28DC), 0x01));

                        ir_variable *const r28FF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r28FF);
                        ir_variable *const r2900 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2900);
                        ir_variable *const r2901 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2901);
                        ir_variable *const r2902 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2903 = neg(r28FE);
                        body.emit(assign(r2902, bit_and(r2903, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2905 = equal(r28FE, body.constant(int(0)));
                        ir_if *f2904 = new(mem_ctx) ir_if(operand(r2905).val);
                        exec_list *const f2904_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2904->then_instructions;

                           body.emit(assign(r28FF, r28FD, 0x01));

                           body.emit(assign(r2900, r28DA, 0x01));

                           body.emit(assign(r2901, r28D9, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2904->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2907 = less(r28FE, body.constant(int(32)));
                           ir_if *f2906 = new(mem_ctx) ir_if(operand(r2907).val);
                           exec_list *const f2906_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2906->then_instructions;

                              body.emit(assign(r28FF, lshift(r28DA, r2902), 0x01));

                              ir_expression *const r2908 = lshift(r28D9, r2902);
                              ir_expression *const r2909 = rshift(r28DA, r28FE);
                              body.emit(assign(r2900, bit_or(r2908, r2909), 0x01));

                              body.emit(assign(r2901, rshift(r28D9, r28FE), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2906->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r290B = equal(r28FE, body.constant(int(32)));
                              ir_if *f290A = new(mem_ctx) ir_if(operand(r290B).val);
                              exec_list *const f290A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f290A->then_instructions;

                                 body.emit(assign(r28FF, r28DA, 0x01));

                                 body.emit(assign(r2900, r28D9, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f290A->else_instructions;

                                 body.emit(assign(r28FD, bit_or(body.constant(0u), r28DA), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r290D = less(r28FE, body.constant(int(64)));
                                 ir_if *f290C = new(mem_ctx) ir_if(operand(r290D).val);
                                 exec_list *const f290C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f290C->then_instructions;

                                    body.emit(assign(r28FF, lshift(r28D9, r2902), 0x01));

                                    ir_expression *const r290E = bit_and(r28FE, body.constant(int(31)));
                                    body.emit(assign(r2900, rshift(r28D9, r290E), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f290C->else_instructions;

                                    ir_variable *const r290F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2911 = equal(r28FE, body.constant(int(64)));
                                    ir_if *f2910 = new(mem_ctx) ir_if(operand(r2911).val);
                                    exec_list *const f2910_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2910->then_instructions;

                                       body.emit(assign(r290F, r28D9, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2910->else_instructions;

                                       ir_expression *const r2912 = nequal(r28D9, body.constant(0u));
                                       ir_expression *const r2913 = expr(ir_unop_b2i, r2912);
                                       body.emit(assign(r290F, expr(ir_unop_i2u, r2913), 0x01));


                                    body.instructions = f2910_parent_instructions;
                                    body.emit(f2910);

                                    /* END IF */

                                    body.emit(assign(r28FF, r290F, 0x01));

                                    body.emit(assign(r2900, body.constant(0u), 0x01));


                                 body.instructions = f290C_parent_instructions;
                                 body.emit(f290C);

                                 /* END IF */


                              body.instructions = f290A_parent_instructions;
                              body.emit(f290A);

                              /* END IF */

                              body.emit(assign(r2901, body.constant(0u), 0x01));


                           body.instructions = f2906_parent_instructions;
                           body.emit(f2906);

                           /* END IF */

                           ir_expression *const r2914 = nequal(r28FD, body.constant(0u));
                           ir_expression *const r2915 = expr(ir_unop_b2i, r2914);
                           ir_expression *const r2916 = expr(ir_unop_i2u, r2915);
                           body.emit(assign(r28FF, bit_or(r28FF, r2916), 0x01));


                        body.instructions = f2904_parent_instructions;
                        body.emit(f2904);

                        /* END IF */

                        body.emit(assign(r28D9, r2901, 0x01));

                        body.emit(assign(r28DA, r2900, 0x01));

                        body.emit(assign(r28DB, r28FF, 0x01));


                     body.instructions = f28F3_parent_instructions;
                     body.emit(f28F3);

                     /* END IF */

                     body.emit(assign(r28D8, sub(r28D8, r28DC), 0x01));

                     ir_variable *const r2917 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r2917, r28D8, 0x01));

                     ir_variable *const r2918 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r2918, r28D9, 0x01));

                     ir_variable *const r2919 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r2919, r28DA, 0x01));

                     ir_variable *const r291A = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r291A, r28DB, 0x01));

                     ir_variable *const r291B = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r291B, body.constant(true), 0x01));

                     ir_variable *const r291C = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r291D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r291D);
                     ir_expression *const r291E = expr(ir_unop_u2i, r28DB);
                     body.emit(assign(r291D, less(r291E, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2920 = lequal(body.constant(int(2045)), r28D8);
                     ir_if *f291F = new(mem_ctx) ir_if(operand(r2920).val);
                     exec_list *const f291F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f291F->then_instructions;

                        ir_variable *const r2921 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2923 = less(body.constant(int(2045)), r28D8);
                        ir_if *f2922 = new(mem_ctx) ir_if(operand(r2923).val);
                        exec_list *const f2922_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2922->then_instructions;

                           body.emit(assign(r2921, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2922->else_instructions;

                           ir_variable *const r2924 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2926 = equal(r28D8, body.constant(int(2045)));
                           ir_if *f2925 = new(mem_ctx) ir_if(operand(r2926).val);
                           exec_list *const f2925_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2925->then_instructions;

                              ir_expression *const r2927 = equal(body.constant(2097151u), r28D9);
                              ir_expression *const r2928 = equal(body.constant(4294967295u), r28DA);
                              body.emit(assign(r2924, logic_and(r2927, r2928), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2925->else_instructions;

                              body.emit(assign(r2924, body.constant(false), 0x01));


                           body.instructions = f2925_parent_instructions;
                           body.emit(f2925);

                           /* END IF */

                           body.emit(assign(r2921, logic_and(r2924, r291D), 0x01));


                        body.instructions = f2922_parent_instructions;
                        body.emit(f2922);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f2929 = new(mem_ctx) ir_if(operand(r2921).val);
                        exec_list *const f2929_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2929->then_instructions;

                           ir_variable *const r292A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r292A);
                           ir_expression *const r292B = lshift(r2746, body.constant(int(31)));
                           body.emit(assign(r292A, add(r292B, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r292A, body.constant(0u), 0x01));

                           body.emit(assign(r291C, r292A, 0x03));

                           body.emit(assign(r291B, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2929->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r292D = less(r28D8, body.constant(int(0)));
                           ir_if *f292C = new(mem_ctx) ir_if(operand(r292D).val);
                           exec_list *const f292C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f292C->then_instructions;

                              ir_variable *const r292E = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r292E, r28DB, 0x01));

                              ir_variable *const r292F = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r292F, neg(r28D8), 0x01));

                              ir_variable *const r2930 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r2930);
                              ir_variable *const r2931 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r2931);
                              ir_variable *const r2932 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r2932);
                              ir_variable *const r2933 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r2934 = neg(r292F);
                              body.emit(assign(r2933, bit_and(r2934, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2936 = equal(r292F, body.constant(int(0)));
                              ir_if *f2935 = new(mem_ctx) ir_if(operand(r2936).val);
                              exec_list *const f2935_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2935->then_instructions;

                                 body.emit(assign(r2930, r28DB, 0x01));

                                 body.emit(assign(r2931, r28DA, 0x01));

                                 body.emit(assign(r2932, r28D9, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2935->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2938 = less(r292F, body.constant(int(32)));
                                 ir_if *f2937 = new(mem_ctx) ir_if(operand(r2938).val);
                                 exec_list *const f2937_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2937->then_instructions;

                                    body.emit(assign(r2930, lshift(r28DA, r2933), 0x01));

                                    ir_expression *const r2939 = lshift(r28D9, r2933);
                                    ir_expression *const r293A = rshift(r28DA, r292F);
                                    body.emit(assign(r2931, bit_or(r2939, r293A), 0x01));

                                    body.emit(assign(r2932, rshift(r28D9, r292F), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2937->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r293C = equal(r292F, body.constant(int(32)));
                                    ir_if *f293B = new(mem_ctx) ir_if(operand(r293C).val);
                                    exec_list *const f293B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f293B->then_instructions;

                                       body.emit(assign(r2930, r28DA, 0x01));

                                       body.emit(assign(r2931, r28D9, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f293B->else_instructions;

                                       body.emit(assign(r292E, bit_or(r28DB, r28DA), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r293E = less(r292F, body.constant(int(64)));
                                       ir_if *f293D = new(mem_ctx) ir_if(operand(r293E).val);
                                       exec_list *const f293D_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f293D->then_instructions;

                                          body.emit(assign(r2930, lshift(r28D9, r2933), 0x01));

                                          ir_expression *const r293F = bit_and(r292F, body.constant(int(31)));
                                          body.emit(assign(r2931, rshift(r28D9, r293F), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f293D->else_instructions;

                                          ir_variable *const r2940 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r2942 = equal(r292F, body.constant(int(64)));
                                          ir_if *f2941 = new(mem_ctx) ir_if(operand(r2942).val);
                                          exec_list *const f2941_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2941->then_instructions;

                                             body.emit(assign(r2940, r28D9, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2941->else_instructions;

                                             ir_expression *const r2943 = nequal(r28D9, body.constant(0u));
                                             ir_expression *const r2944 = expr(ir_unop_b2i, r2943);
                                             body.emit(assign(r2940, expr(ir_unop_i2u, r2944), 0x01));


                                          body.instructions = f2941_parent_instructions;
                                          body.emit(f2941);

                                          /* END IF */

                                          body.emit(assign(r2930, r2940, 0x01));

                                          body.emit(assign(r2931, body.constant(0u), 0x01));


                                       body.instructions = f293D_parent_instructions;
                                       body.emit(f293D);

                                       /* END IF */


                                    body.instructions = f293B_parent_instructions;
                                    body.emit(f293B);

                                    /* END IF */

                                    body.emit(assign(r2932, body.constant(0u), 0x01));


                                 body.instructions = f2937_parent_instructions;
                                 body.emit(f2937);

                                 /* END IF */

                                 ir_expression *const r2945 = nequal(r292E, body.constant(0u));
                                 ir_expression *const r2946 = expr(ir_unop_b2i, r2945);
                                 ir_expression *const r2947 = expr(ir_unop_i2u, r2946);
                                 body.emit(assign(r2930, bit_or(r2930, r2947), 0x01));


                              body.instructions = f2935_parent_instructions;
                              body.emit(f2935);

                              /* END IF */

                              body.emit(assign(r2918, r2932, 0x01));

                              body.emit(assign(r2919, r2931, 0x01));

                              body.emit(assign(r291A, r2930, 0x01));

                              body.emit(assign(r2917, body.constant(int(0)), 0x01));

                              body.emit(assign(r291D, less(r2930, body.constant(0u)), 0x01));


                           body.instructions = f292C_parent_instructions;
                           body.emit(f292C);

                           /* END IF */


                        body.instructions = f2929_parent_instructions;
                        body.emit(f2929);

                        /* END IF */


                     body.instructions = f291F_parent_instructions;
                     body.emit(f291F);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f2948 = new(mem_ctx) ir_if(operand(r291B).val);
                     exec_list *const f2948_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2948->then_instructions;

                        /* IF CONDITION */
                        ir_if *f2949 = new(mem_ctx) ir_if(operand(r291D).val);
                        exec_list *const f2949_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2949->then_instructions;

                           ir_variable *const r294A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r294A, add(r2919, body.constant(1u)), 0x01));

                           ir_expression *const r294B = less(r294A, r2919);
                           ir_expression *const r294C = expr(ir_unop_b2i, r294B);
                           ir_expression *const r294D = expr(ir_unop_i2u, r294C);
                           body.emit(assign(r2918, add(r2918, r294D), 0x01));

                           ir_expression *const r294E = equal(r291A, body.constant(0u));
                           ir_expression *const r294F = expr(ir_unop_b2i, r294E);
                           ir_expression *const r2950 = expr(ir_unop_i2u, r294F);
                           ir_expression *const r2951 = add(r291A, r2950);
                           ir_expression *const r2952 = bit_and(r2951, body.constant(1u));
                           ir_expression *const r2953 = expr(ir_unop_bit_not, r2952);
                           body.emit(assign(r2919, bit_and(r294A, r2953), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2949->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2955 = bit_or(r2918, r2919);
                           ir_expression *const r2956 = equal(r2955, body.constant(0u));
                           ir_if *f2954 = new(mem_ctx) ir_if(operand(r2956).val);
                           exec_list *const f2954_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2954->then_instructions;

                              body.emit(assign(r2917, body.constant(int(0)), 0x01));


                           body.instructions = f2954_parent_instructions;
                           body.emit(f2954);

                           /* END IF */


                        body.instructions = f2949_parent_instructions;
                        body.emit(f2949);

                        /* END IF */

                        ir_variable *const r2957 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r2957);
                        ir_expression *const r2958 = lshift(r2746, body.constant(int(31)));
                        ir_expression *const r2959 = expr(ir_unop_i2u, r2917);
                        ir_expression *const r295A = lshift(r2959, body.constant(int(20)));
                        ir_expression *const r295B = add(r2958, r295A);
                        body.emit(assign(r2957, add(r295B, r2918), 0x02));

                        body.emit(assign(r2957, r2919, 0x01));

                        body.emit(assign(r291C, r2957, 0x03));

                        body.emit(assign(r291B, body.constant(false), 0x01));


                     body.instructions = f2948_parent_instructions;
                     body.emit(f2948);

                     /* END IF */

                     body.emit(assign(r2747, r291C, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f28D0->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r295D = less(r274D, r274B);
                     ir_if *f295C = new(mem_ctx) ir_if(operand(r295D).val);
                     exec_list *const f295C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f295C->then_instructions;

                        ir_variable *const r295E = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r295F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r295F, sub(r274C, r274E), 0x01));

                        ir_expression *const r2960 = sub(r274B, r274D);
                        ir_expression *const r2961 = less(r274C, r274E);
                        ir_expression *const r2962 = expr(ir_unop_b2i, r2961);
                        ir_expression *const r2963 = expr(ir_unop_i2u, r2962);
                        body.emit(assign(r295E, sub(r2960, r2963), 0x01));

                        body.emit(assign(r2746, bit_xor(r2746, body.constant(1u)), 0x01));

                        body.emit(assign(r274F, add(r2749, body.constant(int(-1))), 0x01));

                        ir_variable *const r2964 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r2964, add(r274F, body.constant(int(-10))), 0x01));

                        ir_variable *const r2965 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r2965, r295E, 0x01));

                        ir_variable *const r2966 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r2966, r295F, 0x01));

                        ir_variable *const r2967 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r2967);
                        ir_variable *const r2968 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r2968);
                        /* IF CONDITION */
                        ir_expression *const r296A = equal(r295E, body.constant(0u));
                        ir_if *f2969 = new(mem_ctx) ir_if(operand(r296A).val);
                        exec_list *const f2969_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2969->then_instructions;

                           body.emit(assign(r2965, r295F, 0x01));

                           body.emit(assign(r2966, body.constant(0u), 0x01));

                           body.emit(assign(r2964, add(r2964, body.constant(int(-32))), 0x01));


                        body.instructions = f2969_parent_instructions;
                        body.emit(f2969);

                        /* END IF */

                        ir_variable *const r296B = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r296B, r2965, 0x01));

                        ir_variable *const r296C = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r296D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r296D);
                        /* IF CONDITION */
                        ir_expression *const r296F = equal(r2965, body.constant(0u));
                        ir_if *f296E = new(mem_ctx) ir_if(operand(r296F).val);
                        exec_list *const f296E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f296E->then_instructions;

                           body.emit(assign(r296C, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f296E->else_instructions;

                           body.emit(assign(r296D, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2971 = bit_and(r2965, body.constant(4294901760u));
                           ir_expression *const r2972 = equal(r2971, body.constant(0u));
                           ir_if *f2970 = new(mem_ctx) ir_if(operand(r2972).val);
                           exec_list *const f2970_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2970->then_instructions;

                              body.emit(assign(r296D, body.constant(int(16)), 0x01));

                              body.emit(assign(r296B, lshift(r2965, body.constant(int(16))), 0x01));


                           body.instructions = f2970_parent_instructions;
                           body.emit(f2970);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2974 = bit_and(r296B, body.constant(4278190080u));
                           ir_expression *const r2975 = equal(r2974, body.constant(0u));
                           ir_if *f2973 = new(mem_ctx) ir_if(operand(r2975).val);
                           exec_list *const f2973_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2973->then_instructions;

                              body.emit(assign(r296D, add(r296D, body.constant(int(8))), 0x01));

                              body.emit(assign(r296B, lshift(r296B, body.constant(int(8))), 0x01));


                           body.instructions = f2973_parent_instructions;
                           body.emit(f2973);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2977 = bit_and(r296B, body.constant(4026531840u));
                           ir_expression *const r2978 = equal(r2977, body.constant(0u));
                           ir_if *f2976 = new(mem_ctx) ir_if(operand(r2978).val);
                           exec_list *const f2976_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2976->then_instructions;

                              body.emit(assign(r296D, add(r296D, body.constant(int(4))), 0x01));

                              body.emit(assign(r296B, lshift(r296B, body.constant(int(4))), 0x01));


                           body.instructions = f2976_parent_instructions;
                           body.emit(f2976);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r297A = bit_and(r296B, body.constant(3221225472u));
                           ir_expression *const r297B = equal(r297A, body.constant(0u));
                           ir_if *f2979 = new(mem_ctx) ir_if(operand(r297B).val);
                           exec_list *const f2979_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2979->then_instructions;

                              body.emit(assign(r296D, add(r296D, body.constant(int(2))), 0x01));

                              body.emit(assign(r296B, lshift(r296B, body.constant(int(2))), 0x01));


                           body.instructions = f2979_parent_instructions;
                           body.emit(f2979);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r297D = bit_and(r296B, body.constant(2147483648u));
                           ir_expression *const r297E = equal(r297D, body.constant(0u));
                           ir_if *f297C = new(mem_ctx) ir_if(operand(r297E).val);
                           exec_list *const f297C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f297C->then_instructions;

                              body.emit(assign(r296D, add(r296D, body.constant(int(1))), 0x01));


                           body.instructions = f297C_parent_instructions;
                           body.emit(f297C);

                           /* END IF */

                           body.emit(assign(r296C, r296D, 0x01));


                        body.instructions = f296E_parent_instructions;
                        body.emit(f296E);

                        /* END IF */

                        body.emit(assign(r2968, add(r296C, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2980 = lequal(body.constant(int(0)), r2968);
                        ir_if *f297F = new(mem_ctx) ir_if(operand(r2980).val);
                        exec_list *const f297F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f297F->then_instructions;

                           body.emit(assign(r2967, body.constant(0u), 0x01));

                           ir_variable *const r2981 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r2981, lshift(r2966, r2968), 0x01));

                           ir_variable *const r2982 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2984 = equal(r2968, body.constant(int(0)));
                           ir_if *f2983 = new(mem_ctx) ir_if(operand(r2984).val);
                           exec_list *const f2983_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2983->then_instructions;

                              body.emit(assign(r2982, r2965, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2983->else_instructions;

                              ir_expression *const r2985 = lshift(r2965, r2968);
                              ir_expression *const r2986 = neg(r2968);
                              ir_expression *const r2987 = bit_and(r2986, body.constant(int(31)));
                              ir_expression *const r2988 = rshift(r2966, r2987);
                              body.emit(assign(r2982, bit_or(r2985, r2988), 0x01));


                           body.instructions = f2983_parent_instructions;
                           body.emit(f2983);

                           /* END IF */

                           body.emit(assign(r2965, r2982, 0x01));

                           body.emit(assign(r2966, r2981, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f297F->else_instructions;

                           ir_variable *const r2989 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r2989, body.constant(0u), 0x01));

                           ir_variable *const r298A = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r298A, neg(r2968), 0x01));

                           ir_variable *const r298B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r298B);
                           ir_variable *const r298C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r298C);
                           ir_variable *const r298D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r298D);
                           ir_variable *const r298E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r298F = neg(r298A);
                           body.emit(assign(r298E, bit_and(r298F, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2991 = equal(r298A, body.constant(int(0)));
                           ir_if *f2990 = new(mem_ctx) ir_if(operand(r2991).val);
                           exec_list *const f2990_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2990->then_instructions;

                              body.emit(assign(r298B, r2989, 0x01));

                              body.emit(assign(r298C, r2966, 0x01));

                              body.emit(assign(r298D, r2965, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2990->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2993 = less(r298A, body.constant(int(32)));
                              ir_if *f2992 = new(mem_ctx) ir_if(operand(r2993).val);
                              exec_list *const f2992_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2992->then_instructions;

                                 body.emit(assign(r298B, lshift(r2966, r298E), 0x01));

                                 ir_expression *const r2994 = lshift(r2965, r298E);
                                 ir_expression *const r2995 = rshift(r2966, r298A);
                                 body.emit(assign(r298C, bit_or(r2994, r2995), 0x01));

                                 body.emit(assign(r298D, rshift(r2965, r298A), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2992->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2997 = equal(r298A, body.constant(int(32)));
                                 ir_if *f2996 = new(mem_ctx) ir_if(operand(r2997).val);
                                 exec_list *const f2996_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2996->then_instructions;

                                    body.emit(assign(r298B, r2966, 0x01));

                                    body.emit(assign(r298C, r2965, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2996->else_instructions;

                                    body.emit(assign(r2989, bit_or(body.constant(0u), r2966), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r2999 = less(r298A, body.constant(int(64)));
                                    ir_if *f2998 = new(mem_ctx) ir_if(operand(r2999).val);
                                    exec_list *const f2998_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2998->then_instructions;

                                       body.emit(assign(r298B, lshift(r2965, r298E), 0x01));

                                       ir_expression *const r299A = bit_and(r298A, body.constant(int(31)));
                                       body.emit(assign(r298C, rshift(r2965, r299A), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2998->else_instructions;

                                       ir_variable *const r299B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r299D = equal(r298A, body.constant(int(64)));
                                       ir_if *f299C = new(mem_ctx) ir_if(operand(r299D).val);
                                       exec_list *const f299C_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f299C->then_instructions;

                                          body.emit(assign(r299B, r2965, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f299C->else_instructions;

                                          ir_expression *const r299E = nequal(r2965, body.constant(0u));
                                          ir_expression *const r299F = expr(ir_unop_b2i, r299E);
                                          body.emit(assign(r299B, expr(ir_unop_i2u, r299F), 0x01));


                                       body.instructions = f299C_parent_instructions;
                                       body.emit(f299C);

                                       /* END IF */

                                       body.emit(assign(r298B, r299B, 0x01));

                                       body.emit(assign(r298C, body.constant(0u), 0x01));


                                    body.instructions = f2998_parent_instructions;
                                    body.emit(f2998);

                                    /* END IF */


                                 body.instructions = f2996_parent_instructions;
                                 body.emit(f2996);

                                 /* END IF */

                                 body.emit(assign(r298D, body.constant(0u), 0x01));


                              body.instructions = f2992_parent_instructions;
                              body.emit(f2992);

                              /* END IF */

                              ir_expression *const r29A0 = nequal(r2989, body.constant(0u));
                              ir_expression *const r29A1 = expr(ir_unop_b2i, r29A0);
                              ir_expression *const r29A2 = expr(ir_unop_i2u, r29A1);
                              body.emit(assign(r298B, bit_or(r298B, r29A2), 0x01));


                           body.instructions = f2990_parent_instructions;
                           body.emit(f2990);

                           /* END IF */

                           body.emit(assign(r2965, r298D, 0x01));

                           body.emit(assign(r2966, r298C, 0x01));

                           body.emit(assign(r2967, r298B, 0x01));


                        body.instructions = f297F_parent_instructions;
                        body.emit(f297F);

                        /* END IF */

                        body.emit(assign(r2964, sub(r2964, r2968), 0x01));

                        ir_variable *const r29A3 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r29A3, r2964, 0x01));

                        ir_variable *const r29A4 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r29A4, r2965, 0x01));

                        ir_variable *const r29A5 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r29A5, r2966, 0x01));

                        ir_variable *const r29A6 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r29A6, r2967, 0x01));

                        ir_variable *const r29A7 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r29A7, body.constant(true), 0x01));

                        ir_variable *const r29A8 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r29A9 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r29A9);
                        ir_expression *const r29AA = expr(ir_unop_u2i, r2967);
                        body.emit(assign(r29A9, less(r29AA, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r29AC = lequal(body.constant(int(2045)), r2964);
                        ir_if *f29AB = new(mem_ctx) ir_if(operand(r29AC).val);
                        exec_list *const f29AB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f29AB->then_instructions;

                           ir_variable *const r29AD = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r29AF = less(body.constant(int(2045)), r2964);
                           ir_if *f29AE = new(mem_ctx) ir_if(operand(r29AF).val);
                           exec_list *const f29AE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f29AE->then_instructions;

                              body.emit(assign(r29AD, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f29AE->else_instructions;

                              ir_variable *const r29B0 = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r29B2 = equal(r2964, body.constant(int(2045)));
                              ir_if *f29B1 = new(mem_ctx) ir_if(operand(r29B2).val);
                              exec_list *const f29B1_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f29B1->then_instructions;

                                 ir_expression *const r29B3 = equal(body.constant(2097151u), r2965);
                                 ir_expression *const r29B4 = equal(body.constant(4294967295u), r2966);
                                 body.emit(assign(r29B0, logic_and(r29B3, r29B4), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f29B1->else_instructions;

                                 body.emit(assign(r29B0, body.constant(false), 0x01));


                              body.instructions = f29B1_parent_instructions;
                              body.emit(f29B1);

                              /* END IF */

                              body.emit(assign(r29AD, logic_and(r29B0, r29A9), 0x01));


                           body.instructions = f29AE_parent_instructions;
                           body.emit(f29AE);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f29B5 = new(mem_ctx) ir_if(operand(r29AD).val);
                           exec_list *const f29B5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f29B5->then_instructions;

                              ir_variable *const r29B6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r29B6);
                              ir_expression *const r29B7 = lshift(r2746, body.constant(int(31)));
                              body.emit(assign(r29B6, add(r29B7, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r29B6, body.constant(0u), 0x01));

                              body.emit(assign(r29A8, r29B6, 0x03));

                              body.emit(assign(r29A7, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f29B5->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r29B9 = less(r2964, body.constant(int(0)));
                              ir_if *f29B8 = new(mem_ctx) ir_if(operand(r29B9).val);
                              exec_list *const f29B8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f29B8->then_instructions;

                                 ir_variable *const r29BA = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r29BA, r2967, 0x01));

                                 ir_variable *const r29BB = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r29BB, neg(r2964), 0x01));

                                 ir_variable *const r29BC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r29BC);
                                 ir_variable *const r29BD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r29BD);
                                 ir_variable *const r29BE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r29BE);
                                 ir_variable *const r29BF = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r29C0 = neg(r29BB);
                                 body.emit(assign(r29BF, bit_and(r29C0, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r29C2 = equal(r29BB, body.constant(int(0)));
                                 ir_if *f29C1 = new(mem_ctx) ir_if(operand(r29C2).val);
                                 exec_list *const f29C1_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f29C1->then_instructions;

                                    body.emit(assign(r29BC, r2967, 0x01));

                                    body.emit(assign(r29BD, r2966, 0x01));

                                    body.emit(assign(r29BE, r2965, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f29C1->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r29C4 = less(r29BB, body.constant(int(32)));
                                    ir_if *f29C3 = new(mem_ctx) ir_if(operand(r29C4).val);
                                    exec_list *const f29C3_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f29C3->then_instructions;

                                       body.emit(assign(r29BC, lshift(r2966, r29BF), 0x01));

                                       ir_expression *const r29C5 = lshift(r2965, r29BF);
                                       ir_expression *const r29C6 = rshift(r2966, r29BB);
                                       body.emit(assign(r29BD, bit_or(r29C5, r29C6), 0x01));

                                       body.emit(assign(r29BE, rshift(r2965, r29BB), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f29C3->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r29C8 = equal(r29BB, body.constant(int(32)));
                                       ir_if *f29C7 = new(mem_ctx) ir_if(operand(r29C8).val);
                                       exec_list *const f29C7_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f29C7->then_instructions;

                                          body.emit(assign(r29BC, r2966, 0x01));

                                          body.emit(assign(r29BD, r2965, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f29C7->else_instructions;

                                          body.emit(assign(r29BA, bit_or(r2967, r2966), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r29CA = less(r29BB, body.constant(int(64)));
                                          ir_if *f29C9 = new(mem_ctx) ir_if(operand(r29CA).val);
                                          exec_list *const f29C9_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f29C9->then_instructions;

                                             body.emit(assign(r29BC, lshift(r2965, r29BF), 0x01));

                                             ir_expression *const r29CB = bit_and(r29BB, body.constant(int(31)));
                                             body.emit(assign(r29BD, rshift(r2965, r29CB), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f29C9->else_instructions;

                                             ir_variable *const r29CC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r29CE = equal(r29BB, body.constant(int(64)));
                                             ir_if *f29CD = new(mem_ctx) ir_if(operand(r29CE).val);
                                             exec_list *const f29CD_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f29CD->then_instructions;

                                                body.emit(assign(r29CC, r2965, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f29CD->else_instructions;

                                                ir_expression *const r29CF = nequal(r2965, body.constant(0u));
                                                ir_expression *const r29D0 = expr(ir_unop_b2i, r29CF);
                                                body.emit(assign(r29CC, expr(ir_unop_i2u, r29D0), 0x01));


                                             body.instructions = f29CD_parent_instructions;
                                             body.emit(f29CD);

                                             /* END IF */

                                             body.emit(assign(r29BC, r29CC, 0x01));

                                             body.emit(assign(r29BD, body.constant(0u), 0x01));


                                          body.instructions = f29C9_parent_instructions;
                                          body.emit(f29C9);

                                          /* END IF */


                                       body.instructions = f29C7_parent_instructions;
                                       body.emit(f29C7);

                                       /* END IF */

                                       body.emit(assign(r29BE, body.constant(0u), 0x01));


                                    body.instructions = f29C3_parent_instructions;
                                    body.emit(f29C3);

                                    /* END IF */

                                    ir_expression *const r29D1 = nequal(r29BA, body.constant(0u));
                                    ir_expression *const r29D2 = expr(ir_unop_b2i, r29D1);
                                    ir_expression *const r29D3 = expr(ir_unop_i2u, r29D2);
                                    body.emit(assign(r29BC, bit_or(r29BC, r29D3), 0x01));


                                 body.instructions = f29C1_parent_instructions;
                                 body.emit(f29C1);

                                 /* END IF */

                                 body.emit(assign(r29A4, r29BE, 0x01));

                                 body.emit(assign(r29A5, r29BD, 0x01));

                                 body.emit(assign(r29A6, r29BC, 0x01));

                                 body.emit(assign(r29A3, body.constant(int(0)), 0x01));

                                 body.emit(assign(r29A9, less(r29BC, body.constant(0u)), 0x01));


                              body.instructions = f29B8_parent_instructions;
                              body.emit(f29B8);

                              /* END IF */


                           body.instructions = f29B5_parent_instructions;
                           body.emit(f29B5);

                           /* END IF */


                        body.instructions = f29AB_parent_instructions;
                        body.emit(f29AB);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f29D4 = new(mem_ctx) ir_if(operand(r29A7).val);
                        exec_list *const f29D4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f29D4->then_instructions;

                           /* IF CONDITION */
                           ir_if *f29D5 = new(mem_ctx) ir_if(operand(r29A9).val);
                           exec_list *const f29D5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f29D5->then_instructions;

                              ir_variable *const r29D6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r29D6, add(r29A5, body.constant(1u)), 0x01));

                              ir_expression *const r29D7 = less(r29D6, r29A5);
                              ir_expression *const r29D8 = expr(ir_unop_b2i, r29D7);
                              ir_expression *const r29D9 = expr(ir_unop_i2u, r29D8);
                              body.emit(assign(r29A4, add(r29A4, r29D9), 0x01));

                              ir_expression *const r29DA = equal(r29A6, body.constant(0u));
                              ir_expression *const r29DB = expr(ir_unop_b2i, r29DA);
                              ir_expression *const r29DC = expr(ir_unop_i2u, r29DB);
                              ir_expression *const r29DD = add(r29A6, r29DC);
                              ir_expression *const r29DE = bit_and(r29DD, body.constant(1u));
                              ir_expression *const r29DF = expr(ir_unop_bit_not, r29DE);
                              body.emit(assign(r29A5, bit_and(r29D6, r29DF), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f29D5->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r29E1 = bit_or(r29A4, r29A5);
                              ir_expression *const r29E2 = equal(r29E1, body.constant(0u));
                              ir_if *f29E0 = new(mem_ctx) ir_if(operand(r29E2).val);
                              exec_list *const f29E0_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f29E0->then_instructions;

                                 body.emit(assign(r29A3, body.constant(int(0)), 0x01));


                              body.instructions = f29E0_parent_instructions;
                              body.emit(f29E0);

                              /* END IF */


                           body.instructions = f29D5_parent_instructions;
                           body.emit(f29D5);

                           /* END IF */

                           ir_variable *const r29E3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r29E3);
                           ir_expression *const r29E4 = lshift(r2746, body.constant(int(31)));
                           ir_expression *const r29E5 = expr(ir_unop_i2u, r29A3);
                           ir_expression *const r29E6 = lshift(r29E5, body.constant(int(20)));
                           ir_expression *const r29E7 = add(r29E4, r29E6);
                           body.emit(assign(r29E3, add(r29E7, r29A4), 0x02));

                           body.emit(assign(r29E3, r29A5, 0x01));

                           body.emit(assign(r29A8, r29E3, 0x03));

                           body.emit(assign(r29A7, body.constant(false), 0x01));


                        body.instructions = f29D4_parent_instructions;
                        body.emit(f29D4);

                        /* END IF */

                        body.emit(assign(r2747, r29A8, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f295C->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r29E9 = less(r274C, r274E);
                        ir_if *f29E8 = new(mem_ctx) ir_if(operand(r29E9).val);
                        exec_list *const f29E8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f29E8->then_instructions;

                           ir_variable *const r29EA = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r29EB = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r29EB, sub(r274E, r274C), 0x01));

                           ir_expression *const r29EC = sub(r274D, r274B);
                           ir_expression *const r29ED = less(r274E, r274C);
                           ir_expression *const r29EE = expr(ir_unop_b2i, r29ED);
                           ir_expression *const r29EF = expr(ir_unop_i2u, r29EE);
                           body.emit(assign(r29EA, sub(r29EC, r29EF), 0x01));

                           body.emit(assign(r274F, add(r274A, body.constant(int(-1))), 0x01));

                           ir_variable *const r29F0 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r29F0, add(r274F, body.constant(int(-10))), 0x01));

                           ir_variable *const r29F1 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r29F1, r29EA, 0x01));

                           ir_variable *const r29F2 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r29F2, r29EB, 0x01));

                           ir_variable *const r29F3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r29F3);
                           ir_variable *const r29F4 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r29F4);
                           /* IF CONDITION */
                           ir_expression *const r29F6 = equal(r29EA, body.constant(0u));
                           ir_if *f29F5 = new(mem_ctx) ir_if(operand(r29F6).val);
                           exec_list *const f29F5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f29F5->then_instructions;

                              body.emit(assign(r29F1, r29EB, 0x01));

                              body.emit(assign(r29F2, body.constant(0u), 0x01));

                              body.emit(assign(r29F0, add(r29F0, body.constant(int(-32))), 0x01));


                           body.instructions = f29F5_parent_instructions;
                           body.emit(f29F5);

                           /* END IF */

                           ir_variable *const r29F7 = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r29F7, r29F1, 0x01));

                           ir_variable *const r29F8 = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r29F9 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r29F9);
                           /* IF CONDITION */
                           ir_expression *const r29FB = equal(r29F1, body.constant(0u));
                           ir_if *f29FA = new(mem_ctx) ir_if(operand(r29FB).val);
                           exec_list *const f29FA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f29FA->then_instructions;

                              body.emit(assign(r29F8, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f29FA->else_instructions;

                              body.emit(assign(r29F9, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r29FD = bit_and(r29F1, body.constant(4294901760u));
                              ir_expression *const r29FE = equal(r29FD, body.constant(0u));
                              ir_if *f29FC = new(mem_ctx) ir_if(operand(r29FE).val);
                              exec_list *const f29FC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f29FC->then_instructions;

                                 body.emit(assign(r29F9, body.constant(int(16)), 0x01));

                                 body.emit(assign(r29F7, lshift(r29F1, body.constant(int(16))), 0x01));


                              body.instructions = f29FC_parent_instructions;
                              body.emit(f29FC);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2A00 = bit_and(r29F7, body.constant(4278190080u));
                              ir_expression *const r2A01 = equal(r2A00, body.constant(0u));
                              ir_if *f29FF = new(mem_ctx) ir_if(operand(r2A01).val);
                              exec_list *const f29FF_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f29FF->then_instructions;

                                 body.emit(assign(r29F9, add(r29F9, body.constant(int(8))), 0x01));

                                 body.emit(assign(r29F7, lshift(r29F7, body.constant(int(8))), 0x01));


                              body.instructions = f29FF_parent_instructions;
                              body.emit(f29FF);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2A03 = bit_and(r29F7, body.constant(4026531840u));
                              ir_expression *const r2A04 = equal(r2A03, body.constant(0u));
                              ir_if *f2A02 = new(mem_ctx) ir_if(operand(r2A04).val);
                              exec_list *const f2A02_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A02->then_instructions;

                                 body.emit(assign(r29F9, add(r29F9, body.constant(int(4))), 0x01));

                                 body.emit(assign(r29F7, lshift(r29F7, body.constant(int(4))), 0x01));


                              body.instructions = f2A02_parent_instructions;
                              body.emit(f2A02);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2A06 = bit_and(r29F7, body.constant(3221225472u));
                              ir_expression *const r2A07 = equal(r2A06, body.constant(0u));
                              ir_if *f2A05 = new(mem_ctx) ir_if(operand(r2A07).val);
                              exec_list *const f2A05_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A05->then_instructions;

                                 body.emit(assign(r29F9, add(r29F9, body.constant(int(2))), 0x01));

                                 body.emit(assign(r29F7, lshift(r29F7, body.constant(int(2))), 0x01));


                              body.instructions = f2A05_parent_instructions;
                              body.emit(f2A05);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2A09 = bit_and(r29F7, body.constant(2147483648u));
                              ir_expression *const r2A0A = equal(r2A09, body.constant(0u));
                              ir_if *f2A08 = new(mem_ctx) ir_if(operand(r2A0A).val);
                              exec_list *const f2A08_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A08->then_instructions;

                                 body.emit(assign(r29F9, add(r29F9, body.constant(int(1))), 0x01));


                              body.instructions = f2A08_parent_instructions;
                              body.emit(f2A08);

                              /* END IF */

                              body.emit(assign(r29F8, r29F9, 0x01));


                           body.instructions = f29FA_parent_instructions;
                           body.emit(f29FA);

                           /* END IF */

                           body.emit(assign(r29F4, add(r29F8, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2A0C = lequal(body.constant(int(0)), r29F4);
                           ir_if *f2A0B = new(mem_ctx) ir_if(operand(r2A0C).val);
                           exec_list *const f2A0B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2A0B->then_instructions;

                              body.emit(assign(r29F3, body.constant(0u), 0x01));

                              ir_variable *const r2A0D = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r2A0D, lshift(r29F2, r29F4), 0x01));

                              ir_variable *const r2A0E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2A10 = equal(r29F4, body.constant(int(0)));
                              ir_if *f2A0F = new(mem_ctx) ir_if(operand(r2A10).val);
                              exec_list *const f2A0F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A0F->then_instructions;

                                 body.emit(assign(r2A0E, r29F1, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2A0F->else_instructions;

                                 ir_expression *const r2A11 = lshift(r29F1, r29F4);
                                 ir_expression *const r2A12 = neg(r29F4);
                                 ir_expression *const r2A13 = bit_and(r2A12, body.constant(int(31)));
                                 ir_expression *const r2A14 = rshift(r29F2, r2A13);
                                 body.emit(assign(r2A0E, bit_or(r2A11, r2A14), 0x01));


                              body.instructions = f2A0F_parent_instructions;
                              body.emit(f2A0F);

                              /* END IF */

                              body.emit(assign(r29F1, r2A0E, 0x01));

                              body.emit(assign(r29F2, r2A0D, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2A0B->else_instructions;

                              ir_variable *const r2A15 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r2A15, body.constant(0u), 0x01));

                              ir_variable *const r2A16 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r2A16, neg(r29F4), 0x01));

                              ir_variable *const r2A17 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r2A17);
                              ir_variable *const r2A18 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r2A18);
                              ir_variable *const r2A19 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r2A19);
                              ir_variable *const r2A1A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r2A1B = neg(r2A16);
                              body.emit(assign(r2A1A, bit_and(r2A1B, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2A1D = equal(r2A16, body.constant(int(0)));
                              ir_if *f2A1C = new(mem_ctx) ir_if(operand(r2A1D).val);
                              exec_list *const f2A1C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A1C->then_instructions;

                                 body.emit(assign(r2A17, r2A15, 0x01));

                                 body.emit(assign(r2A18, r29F2, 0x01));

                                 body.emit(assign(r2A19, r29F1, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2A1C->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2A1F = less(r2A16, body.constant(int(32)));
                                 ir_if *f2A1E = new(mem_ctx) ir_if(operand(r2A1F).val);
                                 exec_list *const f2A1E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2A1E->then_instructions;

                                    body.emit(assign(r2A17, lshift(r29F2, r2A1A), 0x01));

                                    ir_expression *const r2A20 = lshift(r29F1, r2A1A);
                                    ir_expression *const r2A21 = rshift(r29F2, r2A16);
                                    body.emit(assign(r2A18, bit_or(r2A20, r2A21), 0x01));

                                    body.emit(assign(r2A19, rshift(r29F1, r2A16), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2A1E->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2A23 = equal(r2A16, body.constant(int(32)));
                                    ir_if *f2A22 = new(mem_ctx) ir_if(operand(r2A23).val);
                                    exec_list *const f2A22_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2A22->then_instructions;

                                       body.emit(assign(r2A17, r29F2, 0x01));

                                       body.emit(assign(r2A18, r29F1, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2A22->else_instructions;

                                       body.emit(assign(r2A15, bit_or(body.constant(0u), r29F2), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2A25 = less(r2A16, body.constant(int(64)));
                                       ir_if *f2A24 = new(mem_ctx) ir_if(operand(r2A25).val);
                                       exec_list *const f2A24_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2A24->then_instructions;

                                          body.emit(assign(r2A17, lshift(r29F1, r2A1A), 0x01));

                                          ir_expression *const r2A26 = bit_and(r2A16, body.constant(int(31)));
                                          body.emit(assign(r2A18, rshift(r29F1, r2A26), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2A24->else_instructions;

                                          ir_variable *const r2A27 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r2A29 = equal(r2A16, body.constant(int(64)));
                                          ir_if *f2A28 = new(mem_ctx) ir_if(operand(r2A29).val);
                                          exec_list *const f2A28_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2A28->then_instructions;

                                             body.emit(assign(r2A27, r29F1, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2A28->else_instructions;

                                             ir_expression *const r2A2A = nequal(r29F1, body.constant(0u));
                                             ir_expression *const r2A2B = expr(ir_unop_b2i, r2A2A);
                                             body.emit(assign(r2A27, expr(ir_unop_i2u, r2A2B), 0x01));


                                          body.instructions = f2A28_parent_instructions;
                                          body.emit(f2A28);

                                          /* END IF */

                                          body.emit(assign(r2A17, r2A27, 0x01));

                                          body.emit(assign(r2A18, body.constant(0u), 0x01));


                                       body.instructions = f2A24_parent_instructions;
                                       body.emit(f2A24);

                                       /* END IF */


                                    body.instructions = f2A22_parent_instructions;
                                    body.emit(f2A22);

                                    /* END IF */

                                    body.emit(assign(r2A19, body.constant(0u), 0x01));


                                 body.instructions = f2A1E_parent_instructions;
                                 body.emit(f2A1E);

                                 /* END IF */

                                 ir_expression *const r2A2C = nequal(r2A15, body.constant(0u));
                                 ir_expression *const r2A2D = expr(ir_unop_b2i, r2A2C);
                                 ir_expression *const r2A2E = expr(ir_unop_i2u, r2A2D);
                                 body.emit(assign(r2A17, bit_or(r2A17, r2A2E), 0x01));


                              body.instructions = f2A1C_parent_instructions;
                              body.emit(f2A1C);

                              /* END IF */

                              body.emit(assign(r29F1, r2A19, 0x01));

                              body.emit(assign(r29F2, r2A18, 0x01));

                              body.emit(assign(r29F3, r2A17, 0x01));


                           body.instructions = f2A0B_parent_instructions;
                           body.emit(f2A0B);

                           /* END IF */

                           body.emit(assign(r29F0, sub(r29F0, r29F4), 0x01));

                           ir_variable *const r2A2F = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r2A2F, r29F0, 0x01));

                           ir_variable *const r2A30 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r2A30, r29F1, 0x01));

                           ir_variable *const r2A31 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r2A31, r29F2, 0x01));

                           ir_variable *const r2A32 = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r2A32, r29F3, 0x01));

                           ir_variable *const r2A33 = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r2A33, body.constant(true), 0x01));

                           ir_variable *const r2A34 = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r2A35 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r2A35);
                           ir_expression *const r2A36 = expr(ir_unop_u2i, r29F3);
                           body.emit(assign(r2A35, less(r2A36, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2A38 = lequal(body.constant(int(2045)), r29F0);
                           ir_if *f2A37 = new(mem_ctx) ir_if(operand(r2A38).val);
                           exec_list *const f2A37_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2A37->then_instructions;

                              ir_variable *const r2A39 = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2A3B = less(body.constant(int(2045)), r29F0);
                              ir_if *f2A3A = new(mem_ctx) ir_if(operand(r2A3B).val);
                              exec_list *const f2A3A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A3A->then_instructions;

                                 body.emit(assign(r2A39, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2A3A->else_instructions;

                                 ir_variable *const r2A3C = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2A3E = equal(r29F0, body.constant(int(2045)));
                                 ir_if *f2A3D = new(mem_ctx) ir_if(operand(r2A3E).val);
                                 exec_list *const f2A3D_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2A3D->then_instructions;

                                    ir_expression *const r2A3F = equal(body.constant(2097151u), r29F1);
                                    ir_expression *const r2A40 = equal(body.constant(4294967295u), r29F2);
                                    body.emit(assign(r2A3C, logic_and(r2A3F, r2A40), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2A3D->else_instructions;

                                    body.emit(assign(r2A3C, body.constant(false), 0x01));


                                 body.instructions = f2A3D_parent_instructions;
                                 body.emit(f2A3D);

                                 /* END IF */

                                 body.emit(assign(r2A39, logic_and(r2A3C, r2A35), 0x01));


                              body.instructions = f2A3A_parent_instructions;
                              body.emit(f2A3A);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f2A41 = new(mem_ctx) ir_if(operand(r2A39).val);
                              exec_list *const f2A41_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A41->then_instructions;

                                 ir_variable *const r2A42 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r2A42);
                                 ir_expression *const r2A43 = lshift(r2746, body.constant(int(31)));
                                 body.emit(assign(r2A42, add(r2A43, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r2A42, body.constant(0u), 0x01));

                                 body.emit(assign(r2A34, r2A42, 0x03));

                                 body.emit(assign(r2A33, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2A41->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2A45 = less(r29F0, body.constant(int(0)));
                                 ir_if *f2A44 = new(mem_ctx) ir_if(operand(r2A45).val);
                                 exec_list *const f2A44_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2A44->then_instructions;

                                    ir_variable *const r2A46 = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r2A46, r29F3, 0x01));

                                    ir_variable *const r2A47 = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r2A47, neg(r29F0), 0x01));

                                    ir_variable *const r2A48 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r2A48);
                                    ir_variable *const r2A49 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r2A49);
                                    ir_variable *const r2A4A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r2A4A);
                                    ir_variable *const r2A4B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r2A4C = neg(r2A47);
                                    body.emit(assign(r2A4B, bit_and(r2A4C, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r2A4E = equal(r2A47, body.constant(int(0)));
                                    ir_if *f2A4D = new(mem_ctx) ir_if(operand(r2A4E).val);
                                    exec_list *const f2A4D_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2A4D->then_instructions;

                                       body.emit(assign(r2A48, r29F3, 0x01));

                                       body.emit(assign(r2A49, r29F2, 0x01));

                                       body.emit(assign(r2A4A, r29F1, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2A4D->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r2A50 = less(r2A47, body.constant(int(32)));
                                       ir_if *f2A4F = new(mem_ctx) ir_if(operand(r2A50).val);
                                       exec_list *const f2A4F_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2A4F->then_instructions;

                                          body.emit(assign(r2A48, lshift(r29F2, r2A4B), 0x01));

                                          ir_expression *const r2A51 = lshift(r29F1, r2A4B);
                                          ir_expression *const r2A52 = rshift(r29F2, r2A47);
                                          body.emit(assign(r2A49, bit_or(r2A51, r2A52), 0x01));

                                          body.emit(assign(r2A4A, rshift(r29F1, r2A47), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2A4F->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r2A54 = equal(r2A47, body.constant(int(32)));
                                          ir_if *f2A53 = new(mem_ctx) ir_if(operand(r2A54).val);
                                          exec_list *const f2A53_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2A53->then_instructions;

                                             body.emit(assign(r2A48, r29F2, 0x01));

                                             body.emit(assign(r2A49, r29F1, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2A53->else_instructions;

                                             body.emit(assign(r2A46, bit_or(r29F3, r29F2), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r2A56 = less(r2A47, body.constant(int(64)));
                                             ir_if *f2A55 = new(mem_ctx) ir_if(operand(r2A56).val);
                                             exec_list *const f2A55_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2A55->then_instructions;

                                                body.emit(assign(r2A48, lshift(r29F1, r2A4B), 0x01));

                                                ir_expression *const r2A57 = bit_and(r2A47, body.constant(int(31)));
                                                body.emit(assign(r2A49, rshift(r29F1, r2A57), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2A55->else_instructions;

                                                ir_variable *const r2A58 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r2A5A = equal(r2A47, body.constant(int(64)));
                                                ir_if *f2A59 = new(mem_ctx) ir_if(operand(r2A5A).val);
                                                exec_list *const f2A59_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f2A59->then_instructions;

                                                   body.emit(assign(r2A58, r29F1, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f2A59->else_instructions;

                                                   ir_expression *const r2A5B = nequal(r29F1, body.constant(0u));
                                                   ir_expression *const r2A5C = expr(ir_unop_b2i, r2A5B);
                                                   body.emit(assign(r2A58, expr(ir_unop_i2u, r2A5C), 0x01));


                                                body.instructions = f2A59_parent_instructions;
                                                body.emit(f2A59);

                                                /* END IF */

                                                body.emit(assign(r2A48, r2A58, 0x01));

                                                body.emit(assign(r2A49, body.constant(0u), 0x01));


                                             body.instructions = f2A55_parent_instructions;
                                             body.emit(f2A55);

                                             /* END IF */


                                          body.instructions = f2A53_parent_instructions;
                                          body.emit(f2A53);

                                          /* END IF */

                                          body.emit(assign(r2A4A, body.constant(0u), 0x01));


                                       body.instructions = f2A4F_parent_instructions;
                                       body.emit(f2A4F);

                                       /* END IF */

                                       ir_expression *const r2A5D = nequal(r2A46, body.constant(0u));
                                       ir_expression *const r2A5E = expr(ir_unop_b2i, r2A5D);
                                       ir_expression *const r2A5F = expr(ir_unop_i2u, r2A5E);
                                       body.emit(assign(r2A48, bit_or(r2A48, r2A5F), 0x01));


                                    body.instructions = f2A4D_parent_instructions;
                                    body.emit(f2A4D);

                                    /* END IF */

                                    body.emit(assign(r2A30, r2A4A, 0x01));

                                    body.emit(assign(r2A31, r2A49, 0x01));

                                    body.emit(assign(r2A32, r2A48, 0x01));

                                    body.emit(assign(r2A2F, body.constant(int(0)), 0x01));

                                    body.emit(assign(r2A35, less(r2A48, body.constant(0u)), 0x01));


                                 body.instructions = f2A44_parent_instructions;
                                 body.emit(f2A44);

                                 /* END IF */


                              body.instructions = f2A41_parent_instructions;
                              body.emit(f2A41);

                              /* END IF */


                           body.instructions = f2A37_parent_instructions;
                           body.emit(f2A37);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f2A60 = new(mem_ctx) ir_if(operand(r2A33).val);
                           exec_list *const f2A60_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2A60->then_instructions;

                              /* IF CONDITION */
                              ir_if *f2A61 = new(mem_ctx) ir_if(operand(r2A35).val);
                              exec_list *const f2A61_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A61->then_instructions;

                                 ir_variable *const r2A62 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r2A62, add(r2A31, body.constant(1u)), 0x01));

                                 ir_expression *const r2A63 = less(r2A62, r2A31);
                                 ir_expression *const r2A64 = expr(ir_unop_b2i, r2A63);
                                 ir_expression *const r2A65 = expr(ir_unop_i2u, r2A64);
                                 body.emit(assign(r2A30, add(r2A30, r2A65), 0x01));

                                 ir_expression *const r2A66 = equal(r2A32, body.constant(0u));
                                 ir_expression *const r2A67 = expr(ir_unop_b2i, r2A66);
                                 ir_expression *const r2A68 = expr(ir_unop_i2u, r2A67);
                                 ir_expression *const r2A69 = add(r2A32, r2A68);
                                 ir_expression *const r2A6A = bit_and(r2A69, body.constant(1u));
                                 ir_expression *const r2A6B = expr(ir_unop_bit_not, r2A6A);
                                 body.emit(assign(r2A31, bit_and(r2A62, r2A6B), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2A61->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2A6D = bit_or(r2A30, r2A31);
                                 ir_expression *const r2A6E = equal(r2A6D, body.constant(0u));
                                 ir_if *f2A6C = new(mem_ctx) ir_if(operand(r2A6E).val);
                                 exec_list *const f2A6C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2A6C->then_instructions;

                                    body.emit(assign(r2A2F, body.constant(int(0)), 0x01));


                                 body.instructions = f2A6C_parent_instructions;
                                 body.emit(f2A6C);

                                 /* END IF */


                              body.instructions = f2A61_parent_instructions;
                              body.emit(f2A61);

                              /* END IF */

                              ir_variable *const r2A6F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r2A6F);
                              ir_expression *const r2A70 = lshift(r2746, body.constant(int(31)));
                              ir_expression *const r2A71 = expr(ir_unop_i2u, r2A2F);
                              ir_expression *const r2A72 = lshift(r2A71, body.constant(int(20)));
                              ir_expression *const r2A73 = add(r2A70, r2A72);
                              body.emit(assign(r2A6F, add(r2A73, r2A30), 0x02));

                              body.emit(assign(r2A6F, r2A31, 0x01));

                              body.emit(assign(r2A34, r2A6F, 0x03));

                              body.emit(assign(r2A33, body.constant(false), 0x01));


                           body.instructions = f2A60_parent_instructions;
                           body.emit(f2A60);

                           /* END IF */

                           body.emit(assign(r2747, r2A34, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f29E8->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2A75 = less(r274E, r274C);
                           ir_if *f2A74 = new(mem_ctx) ir_if(operand(r2A75).val);
                           exec_list *const f2A74_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2A74->then_instructions;

                              ir_variable *const r2A76 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                              ir_variable *const r2A77 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r2A77, sub(r274C, r274E), 0x01));

                              ir_expression *const r2A78 = sub(r274B, r274D);
                              ir_expression *const r2A79 = less(r274C, r274E);
                              ir_expression *const r2A7A = expr(ir_unop_b2i, r2A79);
                              ir_expression *const r2A7B = expr(ir_unop_i2u, r2A7A);
                              body.emit(assign(r2A76, sub(r2A78, r2A7B), 0x01));

                              body.emit(assign(r2746, bit_xor(r2746, body.constant(1u)), 0x01));

                              body.emit(assign(r274F, add(r2749, body.constant(int(-1))), 0x01));

                              ir_variable *const r2A7C = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r2A7C, add(r274F, body.constant(int(-10))), 0x01));

                              ir_variable *const r2A7D = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r2A7D, r2A76, 0x01));

                              ir_variable *const r2A7E = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r2A7E, r2A77, 0x01));

                              ir_variable *const r2A7F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                              body.emit(r2A7F);
                              ir_variable *const r2A80 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r2A80);
                              /* IF CONDITION */
                              ir_expression *const r2A82 = equal(r2A76, body.constant(0u));
                              ir_if *f2A81 = new(mem_ctx) ir_if(operand(r2A82).val);
                              exec_list *const f2A81_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A81->then_instructions;

                                 body.emit(assign(r2A7D, r2A77, 0x01));

                                 body.emit(assign(r2A7E, body.constant(0u), 0x01));

                                 body.emit(assign(r2A7C, add(r2A7C, body.constant(int(-32))), 0x01));


                              body.instructions = f2A81_parent_instructions;
                              body.emit(f2A81);

                              /* END IF */

                              ir_variable *const r2A83 = body.make_temp(glsl_type::uint_type, "a");
                              body.emit(assign(r2A83, r2A7D, 0x01));

                              ir_variable *const r2A84 = body.make_temp(glsl_type::int_type, "return_value");
                              ir_variable *const r2A85 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r2A85);
                              /* IF CONDITION */
                              ir_expression *const r2A87 = equal(r2A7D, body.constant(0u));
                              ir_if *f2A86 = new(mem_ctx) ir_if(operand(r2A87).val);
                              exec_list *const f2A86_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A86->then_instructions;

                                 body.emit(assign(r2A84, body.constant(int(32)), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2A86->else_instructions;

                                 body.emit(assign(r2A85, body.constant(int(0)), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2A89 = bit_and(r2A7D, body.constant(4294901760u));
                                 ir_expression *const r2A8A = equal(r2A89, body.constant(0u));
                                 ir_if *f2A88 = new(mem_ctx) ir_if(operand(r2A8A).val);
                                 exec_list *const f2A88_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2A88->then_instructions;

                                    body.emit(assign(r2A85, body.constant(int(16)), 0x01));

                                    body.emit(assign(r2A83, lshift(r2A7D, body.constant(int(16))), 0x01));


                                 body.instructions = f2A88_parent_instructions;
                                 body.emit(f2A88);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2A8C = bit_and(r2A83, body.constant(4278190080u));
                                 ir_expression *const r2A8D = equal(r2A8C, body.constant(0u));
                                 ir_if *f2A8B = new(mem_ctx) ir_if(operand(r2A8D).val);
                                 exec_list *const f2A8B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2A8B->then_instructions;

                                    body.emit(assign(r2A85, add(r2A85, body.constant(int(8))), 0x01));

                                    body.emit(assign(r2A83, lshift(r2A83, body.constant(int(8))), 0x01));


                                 body.instructions = f2A8B_parent_instructions;
                                 body.emit(f2A8B);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2A8F = bit_and(r2A83, body.constant(4026531840u));
                                 ir_expression *const r2A90 = equal(r2A8F, body.constant(0u));
                                 ir_if *f2A8E = new(mem_ctx) ir_if(operand(r2A90).val);
                                 exec_list *const f2A8E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2A8E->then_instructions;

                                    body.emit(assign(r2A85, add(r2A85, body.constant(int(4))), 0x01));

                                    body.emit(assign(r2A83, lshift(r2A83, body.constant(int(4))), 0x01));


                                 body.instructions = f2A8E_parent_instructions;
                                 body.emit(f2A8E);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2A92 = bit_and(r2A83, body.constant(3221225472u));
                                 ir_expression *const r2A93 = equal(r2A92, body.constant(0u));
                                 ir_if *f2A91 = new(mem_ctx) ir_if(operand(r2A93).val);
                                 exec_list *const f2A91_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2A91->then_instructions;

                                    body.emit(assign(r2A85, add(r2A85, body.constant(int(2))), 0x01));

                                    body.emit(assign(r2A83, lshift(r2A83, body.constant(int(2))), 0x01));


                                 body.instructions = f2A91_parent_instructions;
                                 body.emit(f2A91);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2A95 = bit_and(r2A83, body.constant(2147483648u));
                                 ir_expression *const r2A96 = equal(r2A95, body.constant(0u));
                                 ir_if *f2A94 = new(mem_ctx) ir_if(operand(r2A96).val);
                                 exec_list *const f2A94_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2A94->then_instructions;

                                    body.emit(assign(r2A85, add(r2A85, body.constant(int(1))), 0x01));


                                 body.instructions = f2A94_parent_instructions;
                                 body.emit(f2A94);

                                 /* END IF */

                                 body.emit(assign(r2A84, r2A85, 0x01));


                              body.instructions = f2A86_parent_instructions;
                              body.emit(f2A86);

                              /* END IF */

                              body.emit(assign(r2A80, add(r2A84, body.constant(int(-11))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2A98 = lequal(body.constant(int(0)), r2A80);
                              ir_if *f2A97 = new(mem_ctx) ir_if(operand(r2A98).val);
                              exec_list *const f2A97_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A97->then_instructions;

                                 body.emit(assign(r2A7F, body.constant(0u), 0x01));

                                 ir_variable *const r2A99 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                                 body.emit(assign(r2A99, lshift(r2A7E, r2A80), 0x01));

                                 ir_variable *const r2A9A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2A9C = equal(r2A80, body.constant(int(0)));
                                 ir_if *f2A9B = new(mem_ctx) ir_if(operand(r2A9C).val);
                                 exec_list *const f2A9B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2A9B->then_instructions;

                                    body.emit(assign(r2A9A, r2A7D, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2A9B->else_instructions;

                                    ir_expression *const r2A9D = lshift(r2A7D, r2A80);
                                    ir_expression *const r2A9E = neg(r2A80);
                                    ir_expression *const r2A9F = bit_and(r2A9E, body.constant(int(31)));
                                    ir_expression *const r2AA0 = rshift(r2A7E, r2A9F);
                                    body.emit(assign(r2A9A, bit_or(r2A9D, r2AA0), 0x01));


                                 body.instructions = f2A9B_parent_instructions;
                                 body.emit(f2A9B);

                                 /* END IF */

                                 body.emit(assign(r2A7D, r2A9A, 0x01));

                                 body.emit(assign(r2A7E, r2A99, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2A97->else_instructions;

                                 ir_variable *const r2AA1 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r2AA1, body.constant(0u), 0x01));

                                 ir_variable *const r2AA2 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r2AA2, neg(r2A80), 0x01));

                                 ir_variable *const r2AA3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r2AA3);
                                 ir_variable *const r2AA4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r2AA4);
                                 ir_variable *const r2AA5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r2AA5);
                                 ir_variable *const r2AA6 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r2AA7 = neg(r2AA2);
                                 body.emit(assign(r2AA6, bit_and(r2AA7, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2AA9 = equal(r2AA2, body.constant(int(0)));
                                 ir_if *f2AA8 = new(mem_ctx) ir_if(operand(r2AA9).val);
                                 exec_list *const f2AA8_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2AA8->then_instructions;

                                    body.emit(assign(r2AA3, r2AA1, 0x01));

                                    body.emit(assign(r2AA4, r2A7E, 0x01));

                                    body.emit(assign(r2AA5, r2A7D, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2AA8->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2AAB = less(r2AA2, body.constant(int(32)));
                                    ir_if *f2AAA = new(mem_ctx) ir_if(operand(r2AAB).val);
                                    exec_list *const f2AAA_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2AAA->then_instructions;

                                       body.emit(assign(r2AA3, lshift(r2A7E, r2AA6), 0x01));

                                       ir_expression *const r2AAC = lshift(r2A7D, r2AA6);
                                       ir_expression *const r2AAD = rshift(r2A7E, r2AA2);
                                       body.emit(assign(r2AA4, bit_or(r2AAC, r2AAD), 0x01));

                                       body.emit(assign(r2AA5, rshift(r2A7D, r2AA2), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2AAA->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r2AAF = equal(r2AA2, body.constant(int(32)));
                                       ir_if *f2AAE = new(mem_ctx) ir_if(operand(r2AAF).val);
                                       exec_list *const f2AAE_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2AAE->then_instructions;

                                          body.emit(assign(r2AA3, r2A7E, 0x01));

                                          body.emit(assign(r2AA4, r2A7D, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2AAE->else_instructions;

                                          body.emit(assign(r2AA1, bit_or(body.constant(0u), r2A7E), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r2AB1 = less(r2AA2, body.constant(int(64)));
                                          ir_if *f2AB0 = new(mem_ctx) ir_if(operand(r2AB1).val);
                                          exec_list *const f2AB0_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2AB0->then_instructions;

                                             body.emit(assign(r2AA3, lshift(r2A7D, r2AA6), 0x01));

                                             ir_expression *const r2AB2 = bit_and(r2AA2, body.constant(int(31)));
                                             body.emit(assign(r2AA4, rshift(r2A7D, r2AB2), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2AB0->else_instructions;

                                             ir_variable *const r2AB3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r2AB5 = equal(r2AA2, body.constant(int(64)));
                                             ir_if *f2AB4 = new(mem_ctx) ir_if(operand(r2AB5).val);
                                             exec_list *const f2AB4_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2AB4->then_instructions;

                                                body.emit(assign(r2AB3, r2A7D, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2AB4->else_instructions;

                                                ir_expression *const r2AB6 = nequal(r2A7D, body.constant(0u));
                                                ir_expression *const r2AB7 = expr(ir_unop_b2i, r2AB6);
                                                body.emit(assign(r2AB3, expr(ir_unop_i2u, r2AB7), 0x01));


                                             body.instructions = f2AB4_parent_instructions;
                                             body.emit(f2AB4);

                                             /* END IF */

                                             body.emit(assign(r2AA3, r2AB3, 0x01));

                                             body.emit(assign(r2AA4, body.constant(0u), 0x01));


                                          body.instructions = f2AB0_parent_instructions;
                                          body.emit(f2AB0);

                                          /* END IF */


                                       body.instructions = f2AAE_parent_instructions;
                                       body.emit(f2AAE);

                                       /* END IF */

                                       body.emit(assign(r2AA5, body.constant(0u), 0x01));


                                    body.instructions = f2AAA_parent_instructions;
                                    body.emit(f2AAA);

                                    /* END IF */

                                    ir_expression *const r2AB8 = nequal(r2AA1, body.constant(0u));
                                    ir_expression *const r2AB9 = expr(ir_unop_b2i, r2AB8);
                                    ir_expression *const r2ABA = expr(ir_unop_i2u, r2AB9);
                                    body.emit(assign(r2AA3, bit_or(r2AA3, r2ABA), 0x01));


                                 body.instructions = f2AA8_parent_instructions;
                                 body.emit(f2AA8);

                                 /* END IF */

                                 body.emit(assign(r2A7D, r2AA5, 0x01));

                                 body.emit(assign(r2A7E, r2AA4, 0x01));

                                 body.emit(assign(r2A7F, r2AA3, 0x01));


                              body.instructions = f2A97_parent_instructions;
                              body.emit(f2A97);

                              /* END IF */

                              body.emit(assign(r2A7C, sub(r2A7C, r2A80), 0x01));

                              ir_variable *const r2ABB = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r2ABB, r2A7C, 0x01));

                              ir_variable *const r2ABC = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r2ABC, r2A7D, 0x01));

                              ir_variable *const r2ABD = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r2ABD, r2A7E, 0x01));

                              ir_variable *const r2ABE = body.make_temp(glsl_type::uint_type, "zFrac2");
                              body.emit(assign(r2ABE, r2A7F, 0x01));

                              ir_variable *const r2ABF = body.make_temp(glsl_type::bool_type, "execute_flag");
                              body.emit(assign(r2ABF, body.constant(true), 0x01));

                              ir_variable *const r2AC0 = body.make_temp(glsl_type::uvec2_type, "return_value");
                              ir_variable *const r2AC1 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                              body.emit(r2AC1);
                              ir_expression *const r2AC2 = expr(ir_unop_u2i, r2A7F);
                              body.emit(assign(r2AC1, less(r2AC2, body.constant(int(0))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2AC4 = lequal(body.constant(int(2045)), r2A7C);
                              ir_if *f2AC3 = new(mem_ctx) ir_if(operand(r2AC4).val);
                              exec_list *const f2AC3_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2AC3->then_instructions;

                                 ir_variable *const r2AC5 = body.make_temp(glsl_type::bool_type, "or_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2AC7 = less(body.constant(int(2045)), r2A7C);
                                 ir_if *f2AC6 = new(mem_ctx) ir_if(operand(r2AC7).val);
                                 exec_list *const f2AC6_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2AC6->then_instructions;

                                    body.emit(assign(r2AC5, body.constant(true), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2AC6->else_instructions;

                                    ir_variable *const r2AC8 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2ACA = equal(r2A7C, body.constant(int(2045)));
                                    ir_if *f2AC9 = new(mem_ctx) ir_if(operand(r2ACA).val);
                                    exec_list *const f2AC9_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2AC9->then_instructions;

                                       ir_expression *const r2ACB = equal(body.constant(2097151u), r2A7D);
                                       ir_expression *const r2ACC = equal(body.constant(4294967295u), r2A7E);
                                       body.emit(assign(r2AC8, logic_and(r2ACB, r2ACC), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2AC9->else_instructions;

                                       body.emit(assign(r2AC8, body.constant(false), 0x01));


                                    body.instructions = f2AC9_parent_instructions;
                                    body.emit(f2AC9);

                                    /* END IF */

                                    body.emit(assign(r2AC5, logic_and(r2AC8, r2AC1), 0x01));


                                 body.instructions = f2AC6_parent_instructions;
                                 body.emit(f2AC6);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_if *f2ACD = new(mem_ctx) ir_if(operand(r2AC5).val);
                                 exec_list *const f2ACD_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2ACD->then_instructions;

                                    ir_variable *const r2ACE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                    body.emit(r2ACE);
                                    ir_expression *const r2ACF = lshift(r2746, body.constant(int(31)));
                                    body.emit(assign(r2ACE, add(r2ACF, body.constant(2146435072u)), 0x02));

                                    body.emit(assign(r2ACE, body.constant(0u), 0x01));

                                    body.emit(assign(r2AC0, r2ACE, 0x03));

                                    body.emit(assign(r2ABF, body.constant(false), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2ACD->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2AD1 = less(r2A7C, body.constant(int(0)));
                                    ir_if *f2AD0 = new(mem_ctx) ir_if(operand(r2AD1).val);
                                    exec_list *const f2AD0_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2AD0->then_instructions;

                                       ir_variable *const r2AD2 = body.make_temp(glsl_type::uint_type, "a2");
                                       body.emit(assign(r2AD2, r2A7F, 0x01));

                                       ir_variable *const r2AD3 = body.make_temp(glsl_type::int_type, "count");
                                       body.emit(assign(r2AD3, neg(r2A7C), 0x01));

                                       ir_variable *const r2AD4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                       body.emit(r2AD4);
                                       ir_variable *const r2AD5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                       body.emit(r2AD5);
                                       ir_variable *const r2AD6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                       body.emit(r2AD6);
                                       ir_variable *const r2AD7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                       ir_expression *const r2AD8 = neg(r2AD3);
                                       body.emit(assign(r2AD7, bit_and(r2AD8, body.constant(int(31))), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2ADA = equal(r2AD3, body.constant(int(0)));
                                       ir_if *f2AD9 = new(mem_ctx) ir_if(operand(r2ADA).val);
                                       exec_list *const f2AD9_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2AD9->then_instructions;

                                          body.emit(assign(r2AD4, r2A7F, 0x01));

                                          body.emit(assign(r2AD5, r2A7E, 0x01));

                                          body.emit(assign(r2AD6, r2A7D, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2AD9->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r2ADC = less(r2AD3, body.constant(int(32)));
                                          ir_if *f2ADB = new(mem_ctx) ir_if(operand(r2ADC).val);
                                          exec_list *const f2ADB_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2ADB->then_instructions;

                                             body.emit(assign(r2AD4, lshift(r2A7E, r2AD7), 0x01));

                                             ir_expression *const r2ADD = lshift(r2A7D, r2AD7);
                                             ir_expression *const r2ADE = rshift(r2A7E, r2AD3);
                                             body.emit(assign(r2AD5, bit_or(r2ADD, r2ADE), 0x01));

                                             body.emit(assign(r2AD6, rshift(r2A7D, r2AD3), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2ADB->else_instructions;

                                             /* IF CONDITION */
                                             ir_expression *const r2AE0 = equal(r2AD3, body.constant(int(32)));
                                             ir_if *f2ADF = new(mem_ctx) ir_if(operand(r2AE0).val);
                                             exec_list *const f2ADF_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2ADF->then_instructions;

                                                body.emit(assign(r2AD4, r2A7E, 0x01));

                                                body.emit(assign(r2AD5, r2A7D, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2ADF->else_instructions;

                                                body.emit(assign(r2AD2, bit_or(r2A7F, r2A7E), 0x01));

                                                /* IF CONDITION */
                                                ir_expression *const r2AE2 = less(r2AD3, body.constant(int(64)));
                                                ir_if *f2AE1 = new(mem_ctx) ir_if(operand(r2AE2).val);
                                                exec_list *const f2AE1_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f2AE1->then_instructions;

                                                   body.emit(assign(r2AD4, lshift(r2A7D, r2AD7), 0x01));

                                                   ir_expression *const r2AE3 = bit_and(r2AD3, body.constant(int(31)));
                                                   body.emit(assign(r2AD5, rshift(r2A7D, r2AE3), 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f2AE1->else_instructions;

                                                   ir_variable *const r2AE4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                   /* IF CONDITION */
                                                   ir_expression *const r2AE6 = equal(r2AD3, body.constant(int(64)));
                                                   ir_if *f2AE5 = new(mem_ctx) ir_if(operand(r2AE6).val);
                                                   exec_list *const f2AE5_parent_instructions = body.instructions;

                                                      /* THEN INSTRUCTIONS */
                                                      body.instructions = &f2AE5->then_instructions;

                                                      body.emit(assign(r2AE4, r2A7D, 0x01));


                                                      /* ELSE INSTRUCTIONS */
                                                      body.instructions = &f2AE5->else_instructions;

                                                      ir_expression *const r2AE7 = nequal(r2A7D, body.constant(0u));
                                                      ir_expression *const r2AE8 = expr(ir_unop_b2i, r2AE7);
                                                      body.emit(assign(r2AE4, expr(ir_unop_i2u, r2AE8), 0x01));


                                                   body.instructions = f2AE5_parent_instructions;
                                                   body.emit(f2AE5);

                                                   /* END IF */

                                                   body.emit(assign(r2AD4, r2AE4, 0x01));

                                                   body.emit(assign(r2AD5, body.constant(0u), 0x01));


                                                body.instructions = f2AE1_parent_instructions;
                                                body.emit(f2AE1);

                                                /* END IF */


                                             body.instructions = f2ADF_parent_instructions;
                                             body.emit(f2ADF);

                                             /* END IF */

                                             body.emit(assign(r2AD6, body.constant(0u), 0x01));


                                          body.instructions = f2ADB_parent_instructions;
                                          body.emit(f2ADB);

                                          /* END IF */

                                          ir_expression *const r2AE9 = nequal(r2AD2, body.constant(0u));
                                          ir_expression *const r2AEA = expr(ir_unop_b2i, r2AE9);
                                          ir_expression *const r2AEB = expr(ir_unop_i2u, r2AEA);
                                          body.emit(assign(r2AD4, bit_or(r2AD4, r2AEB), 0x01));


                                       body.instructions = f2AD9_parent_instructions;
                                       body.emit(f2AD9);

                                       /* END IF */

                                       body.emit(assign(r2ABC, r2AD6, 0x01));

                                       body.emit(assign(r2ABD, r2AD5, 0x01));

                                       body.emit(assign(r2ABE, r2AD4, 0x01));

                                       body.emit(assign(r2ABB, body.constant(int(0)), 0x01));

                                       body.emit(assign(r2AC1, less(r2AD4, body.constant(0u)), 0x01));


                                    body.instructions = f2AD0_parent_instructions;
                                    body.emit(f2AD0);

                                    /* END IF */


                                 body.instructions = f2ACD_parent_instructions;
                                 body.emit(f2ACD);

                                 /* END IF */


                              body.instructions = f2AC3_parent_instructions;
                              body.emit(f2AC3);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f2AEC = new(mem_ctx) ir_if(operand(r2ABF).val);
                              exec_list *const f2AEC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2AEC->then_instructions;

                                 /* IF CONDITION */
                                 ir_if *f2AED = new(mem_ctx) ir_if(operand(r2AC1).val);
                                 exec_list *const f2AED_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2AED->then_instructions;

                                    ir_variable *const r2AEE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                    body.emit(assign(r2AEE, add(r2ABD, body.constant(1u)), 0x01));

                                    ir_expression *const r2AEF = less(r2AEE, r2ABD);
                                    ir_expression *const r2AF0 = expr(ir_unop_b2i, r2AEF);
                                    ir_expression *const r2AF1 = expr(ir_unop_i2u, r2AF0);
                                    body.emit(assign(r2ABC, add(r2ABC, r2AF1), 0x01));

                                    ir_expression *const r2AF2 = equal(r2ABE, body.constant(0u));
                                    ir_expression *const r2AF3 = expr(ir_unop_b2i, r2AF2);
                                    ir_expression *const r2AF4 = expr(ir_unop_i2u, r2AF3);
                                    ir_expression *const r2AF5 = add(r2ABE, r2AF4);
                                    ir_expression *const r2AF6 = bit_and(r2AF5, body.constant(1u));
                                    ir_expression *const r2AF7 = expr(ir_unop_bit_not, r2AF6);
                                    body.emit(assign(r2ABD, bit_and(r2AEE, r2AF7), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2AED->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2AF9 = bit_or(r2ABC, r2ABD);
                                    ir_expression *const r2AFA = equal(r2AF9, body.constant(0u));
                                    ir_if *f2AF8 = new(mem_ctx) ir_if(operand(r2AFA).val);
                                    exec_list *const f2AF8_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2AF8->then_instructions;

                                       body.emit(assign(r2ABB, body.constant(int(0)), 0x01));


                                    body.instructions = f2AF8_parent_instructions;
                                    body.emit(f2AF8);

                                    /* END IF */


                                 body.instructions = f2AED_parent_instructions;
                                 body.emit(f2AED);

                                 /* END IF */

                                 ir_variable *const r2AFB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r2AFB);
                                 ir_expression *const r2AFC = lshift(r2746, body.constant(int(31)));
                                 ir_expression *const r2AFD = expr(ir_unop_i2u, r2ABB);
                                 ir_expression *const r2AFE = lshift(r2AFD, body.constant(int(20)));
                                 ir_expression *const r2AFF = add(r2AFC, r2AFE);
                                 body.emit(assign(r2AFB, add(r2AFF, r2ABC), 0x02));

                                 body.emit(assign(r2AFB, r2ABD, 0x01));

                                 body.emit(assign(r2AC0, r2AFB, 0x03));

                                 body.emit(assign(r2ABF, body.constant(false), 0x01));


                              body.instructions = f2AEC_parent_instructions;
                              body.emit(f2AEC);

                              /* END IF */

                              body.emit(assign(r2747, r2AC0, 0x03));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2A74->else_instructions;

                              ir_variable *const r2B00 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r2B00);
                              body.emit(assign(r2B00, body.constant(0u), 0x02));

                              body.emit(assign(r2B00, body.constant(0u), 0x01));

                              body.emit(assign(r2747, r2B00, 0x03));


                           body.instructions = f2A74_parent_instructions;
                           body.emit(f2A74);

                           /* END IF */


                        body.instructions = f29E8_parent_instructions;
                        body.emit(f29E8);

                        /* END IF */


                     body.instructions = f295C_parent_instructions;
                     body.emit(f295C);

                     /* END IF */


                  body.instructions = f28D0_parent_instructions;
                  body.emit(f28D0);

                  /* END IF */


               body.instructions = f28BB_parent_instructions;
               body.emit(f28BB);

               /* END IF */


            body.instructions = f280C_parent_instructions;
            body.emit(f280C);

            /* END IF */


         body.instructions = f275B_parent_instructions;
         body.emit(f275B);

         /* END IF */

         body.emit(assign(r2742, r2747, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f2744->else_instructions;

         ir_variable *const r2B01 = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r2B01, body.constant(true), 0x01));

         ir_variable *const r2B02 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r2B03 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r2B03);
         ir_variable *const r2B04 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r2B04);
         ir_variable *const r2B05 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r2B05);
         ir_variable *const r2B06 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r2B06);
         ir_variable *const r2B07 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r2B07);
         ir_variable *const r2B08 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r2B08);
         ir_variable *const r2B09 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
         body.emit(r2B09);
         ir_variable *const r2B0A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
         body.emit(r2B0A);
         body.emit(assign(r2B0A, body.constant(0u), 0x01));

         body.emit(assign(r2B09, body.constant(0u), 0x01));

         ir_variable *const r2B0B = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r2B0B, swizzle_x(r270D), 0x01));

         body.emit(assign(r2B07, r2B0B, 0x01));

         ir_variable *const r2B0C = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r2B0C, bit_and(swizzle_y(r270D), body.constant(1048575u)), 0x01));

         body.emit(assign(r2B06, r2B0C, 0x01));

         ir_variable *const r2B0D = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r2B0D, body.constant(0u), 0x01));

         body.emit(assign(r2B05, body.constant(0u), 0x01));

         body.emit(assign(r2B04, body.constant(0u), 0x01));

         ir_variable *const r2B0E = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r2B0F = rshift(swizzle_y(r270D), body.constant(int(20)));
         ir_expression *const r2B10 = bit_and(r2B0F, body.constant(2047u));
         body.emit(assign(r2B0E, expr(ir_unop_u2i, r2B10), 0x01));

         ir_variable *const r2B11 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         body.emit(assign(r2B11, body.constant(int(1023)), 0x01));

         ir_variable *const r2B12 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r2B12, add(r2B0E, body.constant(int(-1023))), 0x01));

         body.emit(assign(r2B03, r2B12, 0x01));

         /* IF CONDITION */
         ir_expression *const r2B14 = less(body.constant(int(0)), r2B12);
         ir_if *f2B13 = new(mem_ctx) ir_if(operand(r2B14).val);
         exec_list *const f2B13_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2B13->then_instructions;

            /* IF CONDITION */
            ir_expression *const r2B16 = equal(r2B0E, body.constant(int(2047)));
            ir_if *f2B15 = new(mem_ctx) ir_if(operand(r2B16).val);
            exec_list *const f2B15_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2B15->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2B18 = bit_or(r2B0C, swizzle_x(r270D));
               ir_expression *const r2B19 = nequal(r2B18, body.constant(0u));
               ir_if *f2B17 = new(mem_ctx) ir_if(operand(r2B19).val);
               exec_list *const f2B17_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2B17->then_instructions;

                  ir_variable *const r2B1A = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r2B1A, swizzle_x(r270D), 0x01));

                  ir_variable *const r2B1B = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r2B1B, body.constant(0u), 0x01));

                  ir_variable *const r2B1C = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r2B1A, bit_or(swizzle_y(r270D), body.constant(524288u)), 0x02));

                  body.emit(assign(r2B1B, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r2B1E = lshift(swizzle_y(r270D), body.constant(int(1)));
                  ir_expression *const r2B1F = lequal(body.constant(4292870144u), r2B1E);
                  ir_expression *const r2B20 = nequal(swizzle_x(r270D), body.constant(0u));
                  ir_expression *const r2B21 = bit_and(swizzle_y(r270D), body.constant(1048575u));
                  ir_expression *const r2B22 = nequal(r2B21, body.constant(0u));
                  ir_expression *const r2B23 = logic_or(r2B20, r2B22);
                  ir_expression *const r2B24 = logic_and(r2B1F, r2B23);
                  ir_if *f2B1D = new(mem_ctx) ir_if(operand(r2B24).val);
                  exec_list *const f2B1D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2B1D->then_instructions;

                     body.emit(assign(r2B1C, r2B1A, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2B1D->else_instructions;

                     body.emit(assign(r2B1C, r2B1B, 0x03));


                  body.instructions = f2B1D_parent_instructions;
                  body.emit(f2B1D);

                  /* END IF */

                  body.emit(assign(r2B02, r2B1C, 0x03));

                  body.emit(assign(r2B01, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2B17->else_instructions;

                  body.emit(assign(r2B02, r270D, 0x03));

                  body.emit(assign(r2B01, body.constant(false), 0x01));


               body.instructions = f2B17_parent_instructions;
               body.emit(f2B17);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2B15->else_instructions;

               body.emit(assign(r2B04, body.constant(1048576u), 0x01));

               ir_variable *const r2B25 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r2B25, body.constant(0u), 0x01));

               ir_variable *const r2B26 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r2B26);
               ir_variable *const r2B27 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2B27);
               ir_variable *const r2B28 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2B28);
               ir_variable *const r2B29 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2B2A = neg(r2B12);
               body.emit(assign(r2B29, bit_and(r2B2A, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2B2C = equal(r2B12, body.constant(int(0)));
               ir_if *f2B2B = new(mem_ctx) ir_if(operand(r2B2C).val);
               exec_list *const f2B2B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2B2B->then_instructions;

                  body.emit(assign(r2B26, r2B25, 0x01));

                  body.emit(assign(r2B27, body.constant(0u), 0x01));

                  body.emit(assign(r2B28, r2B04, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2B2B->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2B2E = less(r2B12, body.constant(int(32)));
                  ir_if *f2B2D = new(mem_ctx) ir_if(operand(r2B2E).val);
                  exec_list *const f2B2D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2B2D->then_instructions;

                     body.emit(assign(r2B26, body.constant(0u), 0x01));

                     ir_expression *const r2B2F = lshift(body.constant(1048576u), r2B29);
                     body.emit(assign(r2B27, bit_or(r2B2F, body.constant(0u)), 0x01));

                     body.emit(assign(r2B28, rshift(body.constant(1048576u), r2B12), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2B2D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2B31 = equal(r2B12, body.constant(int(32)));
                     ir_if *f2B30 = new(mem_ctx) ir_if(operand(r2B31).val);
                     exec_list *const f2B30_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2B30->then_instructions;

                        body.emit(assign(r2B26, body.constant(0u), 0x01));

                        body.emit(assign(r2B27, r2B04, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2B30->else_instructions;

                        body.emit(assign(r2B25, body.constant(0u), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2B33 = less(r2B12, body.constant(int(64)));
                        ir_if *f2B32 = new(mem_ctx) ir_if(operand(r2B33).val);
                        exec_list *const f2B32_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2B32->then_instructions;

                           body.emit(assign(r2B26, lshift(body.constant(1048576u), r2B29), 0x01));

                           ir_expression *const r2B34 = bit_and(r2B12, body.constant(int(31)));
                           body.emit(assign(r2B27, rshift(body.constant(1048576u), r2B34), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2B32->else_instructions;

                           ir_variable *const r2B35 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2B37 = equal(r2B12, body.constant(int(64)));
                           ir_if *f2B36 = new(mem_ctx) ir_if(operand(r2B37).val);
                           exec_list *const f2B36_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2B36->then_instructions;

                              body.emit(assign(r2B35, r2B04, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2B36->else_instructions;

                              body.emit(assign(r2B35, body.constant(1u), 0x01));


                           body.instructions = f2B36_parent_instructions;
                           body.emit(f2B36);

                           /* END IF */

                           body.emit(assign(r2B26, r2B35, 0x01));

                           body.emit(assign(r2B27, body.constant(0u), 0x01));


                        body.instructions = f2B32_parent_instructions;
                        body.emit(f2B32);

                        /* END IF */


                     body.instructions = f2B30_parent_instructions;
                     body.emit(f2B30);

                     /* END IF */

                     body.emit(assign(r2B28, body.constant(0u), 0x01));


                  body.instructions = f2B2D_parent_instructions;
                  body.emit(f2B2D);

                  /* END IF */

                  ir_expression *const r2B38 = nequal(r2B25, body.constant(0u));
                  ir_expression *const r2B39 = expr(ir_unop_b2i, r2B38);
                  ir_expression *const r2B3A = expr(ir_unop_i2u, r2B39);
                  body.emit(assign(r2B26, bit_or(r2B26, r2B3A), 0x01));


               body.instructions = f2B2B_parent_instructions;
               body.emit(f2B2B);

               /* END IF */

               body.emit(assign(r2B04, r2B28, 0x01));

               body.emit(assign(r2B05, r2B27, 0x01));

               body.emit(assign(r2B09, r2B26, 0x01));

               body.emit(assign(r2B08, r2B0E, 0x01));


            body.instructions = f2B15_parent_instructions;
            body.emit(f2B15);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2B13->else_instructions;

            /* IF CONDITION */
            ir_expression *const r2B3C = less(r2B12, body.constant(int(0)));
            ir_if *f2B3B = new(mem_ctx) ir_if(operand(r2B3C).val);
            exec_list *const f2B3B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2B3B->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2B3E = equal(r2B0E, body.constant(int(0)));
               ir_if *f2B3D = new(mem_ctx) ir_if(operand(r2B3E).val);
               exec_list *const f2B3D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2B3D->then_instructions;

                  body.emit(assign(r2B03, add(r2B12, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2B3D->else_instructions;

                  body.emit(assign(r2B06, bit_or(r2B0C, body.constant(1048576u)), 0x01));


               body.instructions = f2B3D_parent_instructions;
               body.emit(f2B3D);

               /* END IF */

               ir_variable *const r2B3F = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r2B3F, body.constant(0u), 0x01));

               ir_variable *const r2B40 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r2B40, neg(r2B03), 0x01));

               ir_variable *const r2B41 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r2B41);
               ir_variable *const r2B42 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2B42);
               ir_variable *const r2B43 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2B43);
               ir_variable *const r2B44 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2B45 = neg(r2B40);
               body.emit(assign(r2B44, bit_and(r2B45, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2B47 = equal(r2B40, body.constant(int(0)));
               ir_if *f2B46 = new(mem_ctx) ir_if(operand(r2B47).val);
               exec_list *const f2B46_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2B46->then_instructions;

                  body.emit(assign(r2B41, r2B3F, 0x01));

                  body.emit(assign(r2B42, r2B0B, 0x01));

                  body.emit(assign(r2B43, r2B06, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2B46->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2B49 = less(r2B40, body.constant(int(32)));
                  ir_if *f2B48 = new(mem_ctx) ir_if(operand(r2B49).val);
                  exec_list *const f2B48_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2B48->then_instructions;

                     body.emit(assign(r2B41, lshift(swizzle_x(r270D), r2B44), 0x01));

                     ir_expression *const r2B4A = lshift(r2B06, r2B44);
                     ir_expression *const r2B4B = rshift(swizzle_x(r270D), r2B40);
                     body.emit(assign(r2B42, bit_or(r2B4A, r2B4B), 0x01));

                     body.emit(assign(r2B43, rshift(r2B06, r2B40), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2B48->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2B4D = equal(r2B40, body.constant(int(32)));
                     ir_if *f2B4C = new(mem_ctx) ir_if(operand(r2B4D).val);
                     exec_list *const f2B4C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2B4C->then_instructions;

                        body.emit(assign(r2B41, r2B0B, 0x01));

                        body.emit(assign(r2B42, r2B06, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2B4C->else_instructions;

                        body.emit(assign(r2B3F, bit_or(body.constant(0u), swizzle_x(r270D)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2B4F = less(r2B40, body.constant(int(64)));
                        ir_if *f2B4E = new(mem_ctx) ir_if(operand(r2B4F).val);
                        exec_list *const f2B4E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2B4E->then_instructions;

                           body.emit(assign(r2B41, lshift(r2B06, r2B44), 0x01));

                           ir_expression *const r2B50 = bit_and(r2B40, body.constant(int(31)));
                           body.emit(assign(r2B42, rshift(r2B06, r2B50), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2B4E->else_instructions;

                           ir_variable *const r2B51 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2B53 = equal(r2B40, body.constant(int(64)));
                           ir_if *f2B52 = new(mem_ctx) ir_if(operand(r2B53).val);
                           exec_list *const f2B52_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2B52->then_instructions;

                              body.emit(assign(r2B51, r2B06, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2B52->else_instructions;

                              ir_expression *const r2B54 = nequal(r2B06, body.constant(0u));
                              ir_expression *const r2B55 = expr(ir_unop_b2i, r2B54);
                              body.emit(assign(r2B51, expr(ir_unop_i2u, r2B55), 0x01));


                           body.instructions = f2B52_parent_instructions;
                           body.emit(f2B52);

                           /* END IF */

                           body.emit(assign(r2B41, r2B51, 0x01));

                           body.emit(assign(r2B42, body.constant(0u), 0x01));


                        body.instructions = f2B4E_parent_instructions;
                        body.emit(f2B4E);

                        /* END IF */


                     body.instructions = f2B4C_parent_instructions;
                     body.emit(f2B4C);

                     /* END IF */

                     body.emit(assign(r2B43, body.constant(0u), 0x01));


                  body.instructions = f2B48_parent_instructions;
                  body.emit(f2B48);

                  /* END IF */

                  ir_expression *const r2B56 = nequal(r2B3F, body.constant(0u));
                  ir_expression *const r2B57 = expr(ir_unop_b2i, r2B56);
                  ir_expression *const r2B58 = expr(ir_unop_i2u, r2B57);
                  body.emit(assign(r2B41, bit_or(r2B41, r2B58), 0x01));


               body.instructions = f2B46_parent_instructions;
               body.emit(f2B46);

               /* END IF */

               body.emit(assign(r2B06, r2B43, 0x01));

               body.emit(assign(r2B07, r2B42, 0x01));

               body.emit(assign(r2B09, r2B41, 0x01));

               body.emit(assign(r2B08, body.constant(int(1023)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2B3B->else_instructions;

               /* IF CONDITION */
               ir_expression *const r2B5A = equal(r2B0E, body.constant(int(2047)));
               ir_if *f2B59 = new(mem_ctx) ir_if(operand(r2B5A).val);
               exec_list *const f2B59_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2B59->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2B5C = bit_or(r2B06, r2B07);
                  ir_expression *const r2B5D = bit_or(r2B04, r2B05);
                  ir_expression *const r2B5E = bit_or(r2B5C, r2B5D);
                  ir_expression *const r2B5F = nequal(r2B5E, body.constant(0u));
                  ir_if *f2B5B = new(mem_ctx) ir_if(operand(r2B5F).val);
                  exec_list *const f2B5B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2B5B->then_instructions;

                     ir_variable *const r2B60 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r2B60, swizzle_x(r270D), 0x01));

                     ir_variable *const r2B61 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r2B61, body.constant(0u), 0x01));

                     ir_variable *const r2B62 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r2B60, bit_or(swizzle_y(r270D), body.constant(524288u)), 0x02));

                     body.emit(assign(r2B61, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r2B64 = lshift(swizzle_y(r270D), body.constant(int(1)));
                     ir_expression *const r2B65 = lequal(body.constant(4292870144u), r2B64);
                     ir_expression *const r2B66 = nequal(swizzle_x(r270D), body.constant(0u));
                     ir_expression *const r2B67 = bit_and(swizzle_y(r270D), body.constant(1048575u));
                     ir_expression *const r2B68 = nequal(r2B67, body.constant(0u));
                     ir_expression *const r2B69 = logic_or(r2B66, r2B68);
                     ir_expression *const r2B6A = logic_and(r2B65, r2B69);
                     ir_if *f2B63 = new(mem_ctx) ir_if(operand(r2B6A).val);
                     exec_list *const f2B63_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2B63->then_instructions;

                        body.emit(assign(r2B62, r2B60, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2B63->else_instructions;

                        body.emit(assign(r2B62, r2B61, 0x03));


                     body.instructions = f2B63_parent_instructions;
                     body.emit(f2B63);

                     /* END IF */

                     body.emit(assign(r2B02, r2B62, 0x03));

                     body.emit(assign(r2B01, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2B5B->else_instructions;

                     body.emit(assign(r2B02, r270D, 0x03));

                     body.emit(assign(r2B01, body.constant(false), 0x01));


                  body.instructions = f2B5B_parent_instructions;
                  body.emit(f2B5B);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2B59->else_instructions;

                  ir_variable *const r2B6B = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r2B6C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2B6C, add(r2B07, r2B05), 0x01));

                  ir_expression *const r2B6D = add(r2B06, r2B04);
                  ir_expression *const r2B6E = less(r2B6C, r2B07);
                  ir_expression *const r2B6F = expr(ir_unop_b2i, r2B6E);
                  ir_expression *const r2B70 = expr(ir_unop_i2u, r2B6F);
                  body.emit(assign(r2B6B, add(r2B6D, r2B70), 0x01));

                  body.emit(assign(r2B0A, r2B6B, 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2B72 = equal(r2B0E, body.constant(int(0)));
                  ir_if *f2B71 = new(mem_ctx) ir_if(operand(r2B72).val);
                  exec_list *const f2B71_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2B71->then_instructions;

                     ir_variable *const r2B73 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2B73);
                     ir_expression *const r2B74 = lshift(r2743, body.constant(int(31)));
                     body.emit(assign(r2B73, add(r2B74, r2B6B), 0x02));

                     body.emit(assign(r2B73, r2B6C, 0x01));

                     body.emit(assign(r2B02, r2B73, 0x03));

                     body.emit(assign(r2B01, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2B71->else_instructions;

                     body.emit(assign(r2B0A, bit_or(r2B6B, body.constant(2097152u)), 0x01));

                     body.emit(assign(r2B08, r2B0E, 0x01));

                     ir_variable *const r2B75 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r2B75);
                     ir_variable *const r2B76 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r2B76);
                     ir_variable *const r2B77 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r2B77);
                     body.emit(assign(r2B75, lshift(r2B6C, body.constant(int(31))), 0x01));

                     ir_expression *const r2B78 = lshift(r2B0A, body.constant(int(31)));
                     ir_expression *const r2B79 = rshift(r2B6C, body.constant(int(1)));
                     body.emit(assign(r2B76, bit_or(r2B78, r2B79), 0x01));

                     body.emit(assign(r2B77, rshift(r2B0A, body.constant(int(1))), 0x01));

                     body.emit(assign(r2B75, bit_or(r2B75, body.constant(0u)), 0x01));

                     body.emit(assign(r2B0A, r2B77, 0x01));

                     body.emit(assign(r2B09, r2B75, 0x01));

                     ir_variable *const r2B7A = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r2B7A, r2B0E, 0x01));

                     ir_variable *const r2B7B = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r2B7B, r2B77, 0x01));

                     ir_variable *const r2B7C = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r2B7C, r2B76, 0x01));

                     ir_variable *const r2B7D = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r2B7D, r2B75, 0x01));

                     ir_variable *const r2B7E = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r2B7E, body.constant(true), 0x01));

                     ir_variable *const r2B7F = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r2B80 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r2B80);
                     ir_expression *const r2B81 = expr(ir_unop_u2i, r2B75);
                     body.emit(assign(r2B80, less(r2B81, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2B83 = lequal(body.constant(int(2045)), r2B0E);
                     ir_if *f2B82 = new(mem_ctx) ir_if(operand(r2B83).val);
                     exec_list *const f2B82_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2B82->then_instructions;

                        ir_variable *const r2B84 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2B86 = less(body.constant(int(2045)), r2B0E);
                        ir_if *f2B85 = new(mem_ctx) ir_if(operand(r2B86).val);
                        exec_list *const f2B85_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2B85->then_instructions;

                           body.emit(assign(r2B84, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2B85->else_instructions;

                           ir_variable *const r2B87 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2B89 = equal(r2B0E, body.constant(int(2045)));
                           ir_if *f2B88 = new(mem_ctx) ir_if(operand(r2B89).val);
                           exec_list *const f2B88_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2B88->then_instructions;

                              ir_expression *const r2B8A = equal(body.constant(2097151u), r2B77);
                              ir_expression *const r2B8B = equal(body.constant(4294967295u), r2B76);
                              body.emit(assign(r2B87, logic_and(r2B8A, r2B8B), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2B88->else_instructions;

                              body.emit(assign(r2B87, body.constant(false), 0x01));


                           body.instructions = f2B88_parent_instructions;
                           body.emit(f2B88);

                           /* END IF */

                           body.emit(assign(r2B84, logic_and(r2B87, r2B80), 0x01));


                        body.instructions = f2B85_parent_instructions;
                        body.emit(f2B85);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f2B8C = new(mem_ctx) ir_if(operand(r2B84).val);
                        exec_list *const f2B8C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2B8C->then_instructions;

                           ir_variable *const r2B8D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r2B8D);
                           ir_expression *const r2B8E = lshift(r2743, body.constant(int(31)));
                           body.emit(assign(r2B8D, add(r2B8E, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r2B8D, body.constant(0u), 0x01));

                           body.emit(assign(r2B7F, r2B8D, 0x03));

                           body.emit(assign(r2B7E, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2B8C->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2B90 = less(r2B0E, body.constant(int(0)));
                           ir_if *f2B8F = new(mem_ctx) ir_if(operand(r2B90).val);
                           exec_list *const f2B8F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2B8F->then_instructions;

                              ir_variable *const r2B91 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r2B91, r2B75, 0x01));

                              ir_variable *const r2B92 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r2B92, neg(r2B0E), 0x01));

                              ir_variable *const r2B93 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r2B93);
                              ir_variable *const r2B94 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r2B94);
                              ir_variable *const r2B95 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r2B95);
                              ir_variable *const r2B96 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r2B97 = neg(r2B92);
                              body.emit(assign(r2B96, bit_and(r2B97, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2B99 = equal(r2B92, body.constant(int(0)));
                              ir_if *f2B98 = new(mem_ctx) ir_if(operand(r2B99).val);
                              exec_list *const f2B98_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2B98->then_instructions;

                                 body.emit(assign(r2B93, r2B75, 0x01));

                                 body.emit(assign(r2B94, r2B76, 0x01));

                                 body.emit(assign(r2B95, r2B77, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2B98->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2B9B = less(r2B92, body.constant(int(32)));
                                 ir_if *f2B9A = new(mem_ctx) ir_if(operand(r2B9B).val);
                                 exec_list *const f2B9A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2B9A->then_instructions;

                                    body.emit(assign(r2B93, lshift(r2B76, r2B96), 0x01));

                                    ir_expression *const r2B9C = lshift(r2B77, r2B96);
                                    ir_expression *const r2B9D = rshift(r2B76, r2B92);
                                    body.emit(assign(r2B94, bit_or(r2B9C, r2B9D), 0x01));

                                    body.emit(assign(r2B95, rshift(r2B77, r2B92), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2B9A->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2B9F = equal(r2B92, body.constant(int(32)));
                                    ir_if *f2B9E = new(mem_ctx) ir_if(operand(r2B9F).val);
                                    exec_list *const f2B9E_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2B9E->then_instructions;

                                       body.emit(assign(r2B93, r2B76, 0x01));

                                       body.emit(assign(r2B94, r2B77, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2B9E->else_instructions;

                                       body.emit(assign(r2B91, bit_or(r2B75, r2B76), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2BA1 = less(r2B92, body.constant(int(64)));
                                       ir_if *f2BA0 = new(mem_ctx) ir_if(operand(r2BA1).val);
                                       exec_list *const f2BA0_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2BA0->then_instructions;

                                          body.emit(assign(r2B93, lshift(r2B77, r2B96), 0x01));

                                          ir_expression *const r2BA2 = bit_and(r2B92, body.constant(int(31)));
                                          body.emit(assign(r2B94, rshift(r2B77, r2BA2), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2BA0->else_instructions;

                                          ir_variable *const r2BA3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r2BA5 = equal(r2B92, body.constant(int(64)));
                                          ir_if *f2BA4 = new(mem_ctx) ir_if(operand(r2BA5).val);
                                          exec_list *const f2BA4_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2BA4->then_instructions;

                                             body.emit(assign(r2BA3, r2B77, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2BA4->else_instructions;

                                             ir_expression *const r2BA6 = nequal(r2B77, body.constant(0u));
                                             ir_expression *const r2BA7 = expr(ir_unop_b2i, r2BA6);
                                             body.emit(assign(r2BA3, expr(ir_unop_i2u, r2BA7), 0x01));


                                          body.instructions = f2BA4_parent_instructions;
                                          body.emit(f2BA4);

                                          /* END IF */

                                          body.emit(assign(r2B93, r2BA3, 0x01));

                                          body.emit(assign(r2B94, body.constant(0u), 0x01));


                                       body.instructions = f2BA0_parent_instructions;
                                       body.emit(f2BA0);

                                       /* END IF */


                                    body.instructions = f2B9E_parent_instructions;
                                    body.emit(f2B9E);

                                    /* END IF */

                                    body.emit(assign(r2B95, body.constant(0u), 0x01));


                                 body.instructions = f2B9A_parent_instructions;
                                 body.emit(f2B9A);

                                 /* END IF */

                                 ir_expression *const r2BA8 = nequal(r2B91, body.constant(0u));
                                 ir_expression *const r2BA9 = expr(ir_unop_b2i, r2BA8);
                                 ir_expression *const r2BAA = expr(ir_unop_i2u, r2BA9);
                                 body.emit(assign(r2B93, bit_or(r2B93, r2BAA), 0x01));


                              body.instructions = f2B98_parent_instructions;
                              body.emit(f2B98);

                              /* END IF */

                              body.emit(assign(r2B7B, r2B95, 0x01));

                              body.emit(assign(r2B7C, r2B94, 0x01));

                              body.emit(assign(r2B7D, r2B93, 0x01));

                              body.emit(assign(r2B7A, body.constant(int(0)), 0x01));

                              body.emit(assign(r2B80, less(r2B93, body.constant(0u)), 0x01));


                           body.instructions = f2B8F_parent_instructions;
                           body.emit(f2B8F);

                           /* END IF */


                        body.instructions = f2B8C_parent_instructions;
                        body.emit(f2B8C);

                        /* END IF */


                     body.instructions = f2B82_parent_instructions;
                     body.emit(f2B82);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f2BAB = new(mem_ctx) ir_if(operand(r2B7E).val);
                     exec_list *const f2BAB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2BAB->then_instructions;

                        /* IF CONDITION */
                        ir_if *f2BAC = new(mem_ctx) ir_if(operand(r2B80).val);
                        exec_list *const f2BAC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2BAC->then_instructions;

                           ir_variable *const r2BAD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r2BAD, add(r2B7C, body.constant(1u)), 0x01));

                           ir_expression *const r2BAE = less(r2BAD, r2B7C);
                           ir_expression *const r2BAF = expr(ir_unop_b2i, r2BAE);
                           ir_expression *const r2BB0 = expr(ir_unop_i2u, r2BAF);
                           body.emit(assign(r2B7B, add(r2B7B, r2BB0), 0x01));

                           ir_expression *const r2BB1 = equal(r2B7D, body.constant(0u));
                           ir_expression *const r2BB2 = expr(ir_unop_b2i, r2BB1);
                           ir_expression *const r2BB3 = expr(ir_unop_i2u, r2BB2);
                           ir_expression *const r2BB4 = add(r2B7D, r2BB3);
                           ir_expression *const r2BB5 = bit_and(r2BB4, body.constant(1u));
                           ir_expression *const r2BB6 = expr(ir_unop_bit_not, r2BB5);
                           body.emit(assign(r2B7C, bit_and(r2BAD, r2BB6), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2BAC->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2BB8 = bit_or(r2B7B, r2B7C);
                           ir_expression *const r2BB9 = equal(r2BB8, body.constant(0u));
                           ir_if *f2BB7 = new(mem_ctx) ir_if(operand(r2BB9).val);
                           exec_list *const f2BB7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2BB7->then_instructions;

                              body.emit(assign(r2B7A, body.constant(int(0)), 0x01));


                           body.instructions = f2BB7_parent_instructions;
                           body.emit(f2BB7);

                           /* END IF */


                        body.instructions = f2BAC_parent_instructions;
                        body.emit(f2BAC);

                        /* END IF */

                        ir_variable *const r2BBA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r2BBA);
                        ir_expression *const r2BBB = lshift(r2743, body.constant(int(31)));
                        ir_expression *const r2BBC = expr(ir_unop_i2u, r2B7A);
                        ir_expression *const r2BBD = lshift(r2BBC, body.constant(int(20)));
                        ir_expression *const r2BBE = add(r2BBB, r2BBD);
                        body.emit(assign(r2BBA, add(r2BBE, r2B7B), 0x02));

                        body.emit(assign(r2BBA, r2B7C, 0x01));

                        body.emit(assign(r2B7F, r2BBA, 0x03));

                        body.emit(assign(r2B7E, body.constant(false), 0x01));


                     body.instructions = f2BAB_parent_instructions;
                     body.emit(f2BAB);

                     /* END IF */

                     body.emit(assign(r2B02, r2B7F, 0x03));

                     body.emit(assign(r2B01, body.constant(false), 0x01));


                  body.instructions = f2B71_parent_instructions;
                  body.emit(f2B71);

                  /* END IF */


               body.instructions = f2B59_parent_instructions;
               body.emit(f2B59);

               /* END IF */


            body.instructions = f2B3B_parent_instructions;
            body.emit(f2B3B);

            /* END IF */


         body.instructions = f2B13_parent_instructions;
         body.emit(f2B13);

         /* END IF */

         /* IF CONDITION */
         ir_if *f2BBF = new(mem_ctx) ir_if(operand(r2B01).val);
         exec_list *const f2BBF_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2BBF->then_instructions;

            body.emit(assign(r2B06, bit_or(r2B06, body.constant(1048576u)), 0x01));

            ir_variable *const r2BC0 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r2BC1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r2BC1, add(r2B07, r2B05), 0x01));

            ir_expression *const r2BC2 = add(r2B06, r2B04);
            ir_expression *const r2BC3 = less(r2BC1, r2B07);
            ir_expression *const r2BC4 = expr(ir_unop_b2i, r2BC3);
            ir_expression *const r2BC5 = expr(ir_unop_i2u, r2BC4);
            body.emit(assign(r2BC0, add(r2BC2, r2BC5), 0x01));

            body.emit(assign(r2B0A, r2BC0, 0x01));

            body.emit(assign(r2B08, add(r2B08, body.constant(int(-1))), 0x01));

            /* IF CONDITION */
            ir_expression *const r2BC7 = less(r2BC0, body.constant(2097152u));
            ir_if *f2BC6 = new(mem_ctx) ir_if(operand(r2BC7).val);
            exec_list *const f2BC6_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2BC6->then_instructions;

               ir_variable *const r2BC8 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2BC8, r2B08, 0x01));

               ir_variable *const r2BC9 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2BC9, r2BC0, 0x01));

               ir_variable *const r2BCA = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2BCA, r2BC1, 0x01));

               ir_variable *const r2BCB = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r2BCB, r2B09, 0x01));

               ir_variable *const r2BCC = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r2BCC, body.constant(true), 0x01));

               ir_variable *const r2BCD = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2BCE = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2BCE);
               ir_expression *const r2BCF = expr(ir_unop_u2i, r2B09);
               body.emit(assign(r2BCE, less(r2BCF, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2BD1 = lequal(body.constant(int(2045)), r2B08);
               ir_if *f2BD0 = new(mem_ctx) ir_if(operand(r2BD1).val);
               exec_list *const f2BD0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2BD0->then_instructions;

                  ir_variable *const r2BD2 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2BD4 = less(body.constant(int(2045)), r2B08);
                  ir_if *f2BD3 = new(mem_ctx) ir_if(operand(r2BD4).val);
                  exec_list *const f2BD3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2BD3->then_instructions;

                     body.emit(assign(r2BD2, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2BD3->else_instructions;

                     ir_variable *const r2BD5 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2BD7 = equal(r2B08, body.constant(int(2045)));
                     ir_if *f2BD6 = new(mem_ctx) ir_if(operand(r2BD7).val);
                     exec_list *const f2BD6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2BD6->then_instructions;

                        ir_expression *const r2BD8 = equal(body.constant(2097151u), r2BC0);
                        ir_expression *const r2BD9 = equal(body.constant(4294967295u), r2BC1);
                        body.emit(assign(r2BD5, logic_and(r2BD8, r2BD9), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2BD6->else_instructions;

                        body.emit(assign(r2BD5, body.constant(false), 0x01));


                     body.instructions = f2BD6_parent_instructions;
                     body.emit(f2BD6);

                     /* END IF */

                     body.emit(assign(r2BD2, logic_and(r2BD5, r2BCE), 0x01));


                  body.instructions = f2BD3_parent_instructions;
                  body.emit(f2BD3);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2BDA = new(mem_ctx) ir_if(operand(r2BD2).val);
                  exec_list *const f2BDA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2BDA->then_instructions;

                     ir_variable *const r2BDB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2BDB);
                     ir_expression *const r2BDC = lshift(r2743, body.constant(int(31)));
                     body.emit(assign(r2BDB, add(r2BDC, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r2BDB, body.constant(0u), 0x01));

                     body.emit(assign(r2BCD, r2BDB, 0x03));

                     body.emit(assign(r2BCC, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2BDA->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2BDE = less(r2B08, body.constant(int(0)));
                     ir_if *f2BDD = new(mem_ctx) ir_if(operand(r2BDE).val);
                     exec_list *const f2BDD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2BDD->then_instructions;

                        ir_variable *const r2BDF = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2BDF, r2B09, 0x01));

                        ir_variable *const r2BE0 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2BE0, neg(r2B08), 0x01));

                        ir_variable *const r2BE1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2BE1);
                        ir_variable *const r2BE2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2BE2);
                        ir_variable *const r2BE3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2BE3);
                        ir_variable *const r2BE4 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2BE5 = neg(r2BE0);
                        body.emit(assign(r2BE4, bit_and(r2BE5, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2BE7 = equal(r2BE0, body.constant(int(0)));
                        ir_if *f2BE6 = new(mem_ctx) ir_if(operand(r2BE7).val);
                        exec_list *const f2BE6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2BE6->then_instructions;

                           body.emit(assign(r2BE1, r2B09, 0x01));

                           body.emit(assign(r2BE2, r2BC1, 0x01));

                           body.emit(assign(r2BE3, r2BC0, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2BE6->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2BE9 = less(r2BE0, body.constant(int(32)));
                           ir_if *f2BE8 = new(mem_ctx) ir_if(operand(r2BE9).val);
                           exec_list *const f2BE8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2BE8->then_instructions;

                              body.emit(assign(r2BE1, lshift(r2BC1, r2BE4), 0x01));

                              ir_expression *const r2BEA = lshift(r2BC0, r2BE4);
                              ir_expression *const r2BEB = rshift(r2BC1, r2BE0);
                              body.emit(assign(r2BE2, bit_or(r2BEA, r2BEB), 0x01));

                              body.emit(assign(r2BE3, rshift(r2BC0, r2BE0), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2BE8->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2BED = equal(r2BE0, body.constant(int(32)));
                              ir_if *f2BEC = new(mem_ctx) ir_if(operand(r2BED).val);
                              exec_list *const f2BEC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2BEC->then_instructions;

                                 body.emit(assign(r2BE1, r2BC1, 0x01));

                                 body.emit(assign(r2BE2, r2BC0, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2BEC->else_instructions;

                                 body.emit(assign(r2BDF, bit_or(r2B09, r2BC1), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2BEF = less(r2BE0, body.constant(int(64)));
                                 ir_if *f2BEE = new(mem_ctx) ir_if(operand(r2BEF).val);
                                 exec_list *const f2BEE_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2BEE->then_instructions;

                                    body.emit(assign(r2BE1, lshift(r2BC0, r2BE4), 0x01));

                                    ir_expression *const r2BF0 = bit_and(r2BE0, body.constant(int(31)));
                                    body.emit(assign(r2BE2, rshift(r2BC0, r2BF0), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2BEE->else_instructions;

                                    ir_variable *const r2BF1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2BF3 = equal(r2BE0, body.constant(int(64)));
                                    ir_if *f2BF2 = new(mem_ctx) ir_if(operand(r2BF3).val);
                                    exec_list *const f2BF2_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2BF2->then_instructions;

                                       body.emit(assign(r2BF1, r2BC0, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2BF2->else_instructions;

                                       ir_expression *const r2BF4 = nequal(r2BC0, body.constant(0u));
                                       ir_expression *const r2BF5 = expr(ir_unop_b2i, r2BF4);
                                       body.emit(assign(r2BF1, expr(ir_unop_i2u, r2BF5), 0x01));


                                    body.instructions = f2BF2_parent_instructions;
                                    body.emit(f2BF2);

                                    /* END IF */

                                    body.emit(assign(r2BE1, r2BF1, 0x01));

                                    body.emit(assign(r2BE2, body.constant(0u), 0x01));


                                 body.instructions = f2BEE_parent_instructions;
                                 body.emit(f2BEE);

                                 /* END IF */


                              body.instructions = f2BEC_parent_instructions;
                              body.emit(f2BEC);

                              /* END IF */

                              body.emit(assign(r2BE3, body.constant(0u), 0x01));


                           body.instructions = f2BE8_parent_instructions;
                           body.emit(f2BE8);

                           /* END IF */

                           ir_expression *const r2BF6 = nequal(r2BDF, body.constant(0u));
                           ir_expression *const r2BF7 = expr(ir_unop_b2i, r2BF6);
                           ir_expression *const r2BF8 = expr(ir_unop_i2u, r2BF7);
                           body.emit(assign(r2BE1, bit_or(r2BE1, r2BF8), 0x01));


                        body.instructions = f2BE6_parent_instructions;
                        body.emit(f2BE6);

                        /* END IF */

                        body.emit(assign(r2BC9, r2BE3, 0x01));

                        body.emit(assign(r2BCA, r2BE2, 0x01));

                        body.emit(assign(r2BCB, r2BE1, 0x01));

                        body.emit(assign(r2BC8, body.constant(int(0)), 0x01));

                        body.emit(assign(r2BCE, less(r2BE1, body.constant(0u)), 0x01));


                     body.instructions = f2BDD_parent_instructions;
                     body.emit(f2BDD);

                     /* END IF */


                  body.instructions = f2BDA_parent_instructions;
                  body.emit(f2BDA);

                  /* END IF */


               body.instructions = f2BD0_parent_instructions;
               body.emit(f2BD0);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2BF9 = new(mem_ctx) ir_if(operand(r2BCC).val);
               exec_list *const f2BF9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2BF9->then_instructions;

                  /* IF CONDITION */
                  ir_if *f2BFA = new(mem_ctx) ir_if(operand(r2BCE).val);
                  exec_list *const f2BFA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2BFA->then_instructions;

                     ir_variable *const r2BFB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r2BFB, add(r2BCA, body.constant(1u)), 0x01));

                     ir_expression *const r2BFC = less(r2BFB, r2BCA);
                     ir_expression *const r2BFD = expr(ir_unop_b2i, r2BFC);
                     ir_expression *const r2BFE = expr(ir_unop_i2u, r2BFD);
                     body.emit(assign(r2BC9, add(r2BC9, r2BFE), 0x01));

                     ir_expression *const r2BFF = equal(r2BCB, body.constant(0u));
                     ir_expression *const r2C00 = expr(ir_unop_b2i, r2BFF);
                     ir_expression *const r2C01 = expr(ir_unop_i2u, r2C00);
                     ir_expression *const r2C02 = add(r2BCB, r2C01);
                     ir_expression *const r2C03 = bit_and(r2C02, body.constant(1u));
                     ir_expression *const r2C04 = expr(ir_unop_bit_not, r2C03);
                     body.emit(assign(r2BCA, bit_and(r2BFB, r2C04), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2BFA->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2C06 = bit_or(r2BC9, r2BCA);
                     ir_expression *const r2C07 = equal(r2C06, body.constant(0u));
                     ir_if *f2C05 = new(mem_ctx) ir_if(operand(r2C07).val);
                     exec_list *const f2C05_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2C05->then_instructions;

                        body.emit(assign(r2BC8, body.constant(int(0)), 0x01));


                     body.instructions = f2C05_parent_instructions;
                     body.emit(f2C05);

                     /* END IF */


                  body.instructions = f2BFA_parent_instructions;
                  body.emit(f2BFA);

                  /* END IF */

                  ir_variable *const r2C08 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2C08);
                  ir_expression *const r2C09 = lshift(r2743, body.constant(int(31)));
                  ir_expression *const r2C0A = expr(ir_unop_i2u, r2BC8);
                  ir_expression *const r2C0B = lshift(r2C0A, body.constant(int(20)));
                  ir_expression *const r2C0C = add(r2C09, r2C0B);
                  body.emit(assign(r2C08, add(r2C0C, r2BC9), 0x02));

                  body.emit(assign(r2C08, r2BCA, 0x01));

                  body.emit(assign(r2BCD, r2C08, 0x03));

                  body.emit(assign(r2BCC, body.constant(false), 0x01));


               body.instructions = f2BF9_parent_instructions;
               body.emit(f2BF9);

               /* END IF */

               body.emit(assign(r2B02, r2BCD, 0x03));

               body.emit(assign(r2B01, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2BC6->else_instructions;

               body.emit(assign(r2B08, add(r2B08, body.constant(int(1))), 0x01));

               ir_variable *const r2C0D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r2C0D);
               ir_variable *const r2C0E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2C0E);
               ir_variable *const r2C0F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2C0F);
               body.emit(assign(r2C0D, lshift(r2BC1, body.constant(int(31))), 0x01));

               ir_expression *const r2C10 = lshift(r2BC0, body.constant(int(31)));
               ir_expression *const r2C11 = rshift(r2BC1, body.constant(int(1)));
               body.emit(assign(r2C0E, bit_or(r2C10, r2C11), 0x01));

               body.emit(assign(r2C0F, rshift(r2BC0, body.constant(int(1))), 0x01));

               ir_expression *const r2C12 = nequal(r2B09, body.constant(0u));
               ir_expression *const r2C13 = expr(ir_unop_b2i, r2C12);
               ir_expression *const r2C14 = expr(ir_unop_i2u, r2C13);
               body.emit(assign(r2C0D, bit_or(r2C0D, r2C14), 0x01));

               body.emit(assign(r2B0A, r2C0F, 0x01));

               body.emit(assign(r2B09, r2C0D, 0x01));

               ir_variable *const r2C15 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2C15, r2B08, 0x01));

               ir_variable *const r2C16 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2C16, r2C0F, 0x01));

               ir_variable *const r2C17 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2C17, r2C0E, 0x01));

               ir_variable *const r2C18 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r2C18, r2C0D, 0x01));

               ir_variable *const r2C19 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r2C19, body.constant(true), 0x01));

               ir_variable *const r2C1A = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2C1B = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2C1B);
               ir_expression *const r2C1C = expr(ir_unop_u2i, r2C0D);
               body.emit(assign(r2C1B, less(r2C1C, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2C1E = lequal(body.constant(int(2045)), r2B08);
               ir_if *f2C1D = new(mem_ctx) ir_if(operand(r2C1E).val);
               exec_list *const f2C1D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2C1D->then_instructions;

                  ir_variable *const r2C1F = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2C21 = less(body.constant(int(2045)), r2B08);
                  ir_if *f2C20 = new(mem_ctx) ir_if(operand(r2C21).val);
                  exec_list *const f2C20_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2C20->then_instructions;

                     body.emit(assign(r2C1F, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2C20->else_instructions;

                     ir_variable *const r2C22 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2C24 = equal(r2B08, body.constant(int(2045)));
                     ir_if *f2C23 = new(mem_ctx) ir_if(operand(r2C24).val);
                     exec_list *const f2C23_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2C23->then_instructions;

                        ir_expression *const r2C25 = equal(body.constant(2097151u), r2C0F);
                        ir_expression *const r2C26 = equal(body.constant(4294967295u), r2C0E);
                        body.emit(assign(r2C22, logic_and(r2C25, r2C26), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2C23->else_instructions;

                        body.emit(assign(r2C22, body.constant(false), 0x01));


                     body.instructions = f2C23_parent_instructions;
                     body.emit(f2C23);

                     /* END IF */

                     body.emit(assign(r2C1F, logic_and(r2C22, r2C1B), 0x01));


                  body.instructions = f2C20_parent_instructions;
                  body.emit(f2C20);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2C27 = new(mem_ctx) ir_if(operand(r2C1F).val);
                  exec_list *const f2C27_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2C27->then_instructions;

                     ir_variable *const r2C28 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2C28);
                     ir_expression *const r2C29 = lshift(r2743, body.constant(int(31)));
                     body.emit(assign(r2C28, add(r2C29, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r2C28, body.constant(0u), 0x01));

                     body.emit(assign(r2C1A, r2C28, 0x03));

                     body.emit(assign(r2C19, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2C27->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2C2B = less(r2B08, body.constant(int(0)));
                     ir_if *f2C2A = new(mem_ctx) ir_if(operand(r2C2B).val);
                     exec_list *const f2C2A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2C2A->then_instructions;

                        ir_variable *const r2C2C = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2C2C, r2C0D, 0x01));

                        ir_variable *const r2C2D = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2C2D, neg(r2B08), 0x01));

                        ir_variable *const r2C2E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2C2E);
                        ir_variable *const r2C2F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2C2F);
                        ir_variable *const r2C30 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2C30);
                        ir_variable *const r2C31 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2C32 = neg(r2C2D);
                        body.emit(assign(r2C31, bit_and(r2C32, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2C34 = equal(r2C2D, body.constant(int(0)));
                        ir_if *f2C33 = new(mem_ctx) ir_if(operand(r2C34).val);
                        exec_list *const f2C33_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2C33->then_instructions;

                           body.emit(assign(r2C2E, r2C0D, 0x01));

                           body.emit(assign(r2C2F, r2C0E, 0x01));

                           body.emit(assign(r2C30, r2C0F, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2C33->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2C36 = less(r2C2D, body.constant(int(32)));
                           ir_if *f2C35 = new(mem_ctx) ir_if(operand(r2C36).val);
                           exec_list *const f2C35_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2C35->then_instructions;

                              body.emit(assign(r2C2E, lshift(r2C0E, r2C31), 0x01));

                              ir_expression *const r2C37 = lshift(r2C0F, r2C31);
                              ir_expression *const r2C38 = rshift(r2C0E, r2C2D);
                              body.emit(assign(r2C2F, bit_or(r2C37, r2C38), 0x01));

                              body.emit(assign(r2C30, rshift(r2C0F, r2C2D), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2C35->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2C3A = equal(r2C2D, body.constant(int(32)));
                              ir_if *f2C39 = new(mem_ctx) ir_if(operand(r2C3A).val);
                              exec_list *const f2C39_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2C39->then_instructions;

                                 body.emit(assign(r2C2E, r2C0E, 0x01));

                                 body.emit(assign(r2C2F, r2C0F, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2C39->else_instructions;

                                 body.emit(assign(r2C2C, bit_or(r2C0D, r2C0E), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2C3C = less(r2C2D, body.constant(int(64)));
                                 ir_if *f2C3B = new(mem_ctx) ir_if(operand(r2C3C).val);
                                 exec_list *const f2C3B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2C3B->then_instructions;

                                    body.emit(assign(r2C2E, lshift(r2C0F, r2C31), 0x01));

                                    ir_expression *const r2C3D = bit_and(r2C2D, body.constant(int(31)));
                                    body.emit(assign(r2C2F, rshift(r2C0F, r2C3D), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2C3B->else_instructions;

                                    ir_variable *const r2C3E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2C40 = equal(r2C2D, body.constant(int(64)));
                                    ir_if *f2C3F = new(mem_ctx) ir_if(operand(r2C40).val);
                                    exec_list *const f2C3F_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2C3F->then_instructions;

                                       body.emit(assign(r2C3E, r2C0F, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2C3F->else_instructions;

                                       ir_expression *const r2C41 = nequal(r2C0F, body.constant(0u));
                                       ir_expression *const r2C42 = expr(ir_unop_b2i, r2C41);
                                       body.emit(assign(r2C3E, expr(ir_unop_i2u, r2C42), 0x01));


                                    body.instructions = f2C3F_parent_instructions;
                                    body.emit(f2C3F);

                                    /* END IF */

                                    body.emit(assign(r2C2E, r2C3E, 0x01));

                                    body.emit(assign(r2C2F, body.constant(0u), 0x01));


                                 body.instructions = f2C3B_parent_instructions;
                                 body.emit(f2C3B);

                                 /* END IF */


                              body.instructions = f2C39_parent_instructions;
                              body.emit(f2C39);

                              /* END IF */

                              body.emit(assign(r2C30, body.constant(0u), 0x01));


                           body.instructions = f2C35_parent_instructions;
                           body.emit(f2C35);

                           /* END IF */

                           ir_expression *const r2C43 = nequal(r2C2C, body.constant(0u));
                           ir_expression *const r2C44 = expr(ir_unop_b2i, r2C43);
                           ir_expression *const r2C45 = expr(ir_unop_i2u, r2C44);
                           body.emit(assign(r2C2E, bit_or(r2C2E, r2C45), 0x01));


                        body.instructions = f2C33_parent_instructions;
                        body.emit(f2C33);

                        /* END IF */

                        body.emit(assign(r2C16, r2C30, 0x01));

                        body.emit(assign(r2C17, r2C2F, 0x01));

                        body.emit(assign(r2C18, r2C2E, 0x01));

                        body.emit(assign(r2C15, body.constant(int(0)), 0x01));

                        body.emit(assign(r2C1B, less(r2C2E, body.constant(0u)), 0x01));


                     body.instructions = f2C2A_parent_instructions;
                     body.emit(f2C2A);

                     /* END IF */


                  body.instructions = f2C27_parent_instructions;
                  body.emit(f2C27);

                  /* END IF */


               body.instructions = f2C1D_parent_instructions;
               body.emit(f2C1D);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2C46 = new(mem_ctx) ir_if(operand(r2C19).val);
               exec_list *const f2C46_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2C46->then_instructions;

                  /* IF CONDITION */
                  ir_if *f2C47 = new(mem_ctx) ir_if(operand(r2C1B).val);
                  exec_list *const f2C47_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2C47->then_instructions;

                     ir_variable *const r2C48 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r2C48, add(r2C17, body.constant(1u)), 0x01));

                     ir_expression *const r2C49 = less(r2C48, r2C17);
                     ir_expression *const r2C4A = expr(ir_unop_b2i, r2C49);
                     ir_expression *const r2C4B = expr(ir_unop_i2u, r2C4A);
                     body.emit(assign(r2C16, add(r2C16, r2C4B), 0x01));

                     ir_expression *const r2C4C = equal(r2C18, body.constant(0u));
                     ir_expression *const r2C4D = expr(ir_unop_b2i, r2C4C);
                     ir_expression *const r2C4E = expr(ir_unop_i2u, r2C4D);
                     ir_expression *const r2C4F = add(r2C18, r2C4E);
                     ir_expression *const r2C50 = bit_and(r2C4F, body.constant(1u));
                     ir_expression *const r2C51 = expr(ir_unop_bit_not, r2C50);
                     body.emit(assign(r2C17, bit_and(r2C48, r2C51), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2C47->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2C53 = bit_or(r2C16, r2C17);
                     ir_expression *const r2C54 = equal(r2C53, body.constant(0u));
                     ir_if *f2C52 = new(mem_ctx) ir_if(operand(r2C54).val);
                     exec_list *const f2C52_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2C52->then_instructions;

                        body.emit(assign(r2C15, body.constant(int(0)), 0x01));


                     body.instructions = f2C52_parent_instructions;
                     body.emit(f2C52);

                     /* END IF */


                  body.instructions = f2C47_parent_instructions;
                  body.emit(f2C47);

                  /* END IF */

                  ir_variable *const r2C55 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2C55);
                  ir_expression *const r2C56 = lshift(r2743, body.constant(int(31)));
                  ir_expression *const r2C57 = expr(ir_unop_i2u, r2C15);
                  ir_expression *const r2C58 = lshift(r2C57, body.constant(int(20)));
                  ir_expression *const r2C59 = add(r2C56, r2C58);
                  body.emit(assign(r2C55, add(r2C59, r2C16), 0x02));

                  body.emit(assign(r2C55, r2C17, 0x01));

                  body.emit(assign(r2C1A, r2C55, 0x03));

                  body.emit(assign(r2C19, body.constant(false), 0x01));


               body.instructions = f2C46_parent_instructions;
               body.emit(f2C46);

               /* END IF */

               body.emit(assign(r2B02, r2C1A, 0x03));

               body.emit(assign(r2B01, body.constant(false), 0x01));


            body.instructions = f2BC6_parent_instructions;
            body.emit(f2BC6);

            /* END IF */


         body.instructions = f2BBF_parent_instructions;
         body.emit(f2BBF);

         /* END IF */

         body.emit(assign(r2742, r2B02, 0x03));


      body.instructions = f2744_parent_instructions;
      body.emit(f2744);

      /* END IF */

      body.emit(assign(r2740, r2742, 0x03));


   body.instructions = f2741_parent_instructions;
   body.emit(f2741);

   /* END IF */

   ir_variable *const r2C5A = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r2C5B = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r2C5B, rshift(swizzle_y(r270C), body.constant(int(31))), 0x01));

   ir_variable *const r2C5C = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r2C5C, rshift(swizzle_y(r2740), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r2C5E = equal(r2C5B, r2C5C);
   ir_if *f2C5D = new(mem_ctx) ir_if(operand(r2C5E).val);
   exec_list *const f2C5D_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f2C5D->then_instructions;

      ir_variable *const r2C5F = body.make_temp(glsl_type::uint_type, "zSign");
      body.emit(assign(r2C5F, r2C5B, 0x01));

      ir_variable *const r2C60 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r2C61 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r2C61);
      ir_variable *const r2C62 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
      body.emit(r2C62);
      ir_variable *const r2C63 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
      body.emit(r2C63);
      ir_variable *const r2C64 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
      body.emit(r2C64);
      ir_variable *const r2C65 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
      body.emit(r2C65);
      ir_variable *const r2C66 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
      body.emit(r2C66);
      ir_variable *const r2C67 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
      body.emit(r2C67);
      ir_variable *const r2C68 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r2C68);
      ir_variable *const r2C69 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r2C6A = rshift(swizzle_y(r270C), body.constant(int(20)));
      ir_expression *const r2C6B = bit_and(r2C6A, body.constant(2047u));
      body.emit(assign(r2C69, expr(ir_unop_u2i, r2C6B), 0x01));

      body.emit(assign(r2C63, r2C69, 0x01));

      ir_variable *const r2C6C = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r2C6D = rshift(swizzle_y(r2740), body.constant(int(20)));
      ir_expression *const r2C6E = bit_and(r2C6D, body.constant(2047u));
      body.emit(assign(r2C6C, expr(ir_unop_u2i, r2C6E), 0x01));

      body.emit(assign(r2C62, r2C6C, 0x01));

      body.emit(assign(r2C61, sub(r2C69, r2C6C), 0x01));

      ir_variable *const r2C6F = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r2C6F, lshift(swizzle_x(r270C), body.constant(int(10))), 0x01));

      ir_variable *const r2C70 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r2C71 = bit_and(swizzle_y(r270C), body.constant(1048575u));
      ir_expression *const r2C72 = lshift(r2C71, body.constant(int(10)));
      ir_expression *const r2C73 = rshift(swizzle_x(r270C), body.constant(int(22)));
      body.emit(assign(r2C70, bit_or(r2C72, r2C73), 0x01));

      body.emit(assign(r2C66, r2C70, 0x01));

      body.emit(assign(r2C67, r2C6F, 0x01));

      ir_variable *const r2C74 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r2C74, lshift(swizzle_x(r2740), body.constant(int(10))), 0x01));

      ir_variable *const r2C75 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r2C76 = bit_and(swizzle_y(r2740), body.constant(1048575u));
      ir_expression *const r2C77 = lshift(r2C76, body.constant(int(10)));
      ir_expression *const r2C78 = rshift(swizzle_x(r2740), body.constant(int(22)));
      body.emit(assign(r2C75, bit_or(r2C77, r2C78), 0x01));

      body.emit(assign(r2C64, r2C75, 0x01));

      body.emit(assign(r2C65, r2C74, 0x01));

      /* IF CONDITION */
      ir_expression *const r2C7A = less(body.constant(int(0)), r2C61);
      ir_if *f2C79 = new(mem_ctx) ir_if(operand(r2C7A).val);
      exec_list *const f2C79_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f2C79->then_instructions;

         /* IF CONDITION */
         ir_expression *const r2C7C = equal(r2C69, body.constant(int(2047)));
         ir_if *f2C7B = new(mem_ctx) ir_if(operand(r2C7C).val);
         exec_list *const f2C7B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2C7B->then_instructions;

            /* IF CONDITION */
            ir_expression *const r2C7E = bit_or(r2C70, r2C6F);
            ir_expression *const r2C7F = nequal(r2C7E, body.constant(0u));
            ir_if *f2C7D = new(mem_ctx) ir_if(operand(r2C7F).val);
            exec_list *const f2C7D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2C7D->then_instructions;

               ir_variable *const r2C80 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r2C80, swizzle_x(r270C), 0x01));

               ir_variable *const r2C81 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r2C81, swizzle_x(r2740), 0x01));

               ir_variable *const r2C82 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2C83 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r2C84 = rshift(swizzle_y(r270C), body.constant(int(19)));
               ir_expression *const r2C85 = bit_and(r2C84, body.constant(4095u));
               ir_expression *const r2C86 = equal(r2C85, body.constant(4094u));
               ir_expression *const r2C87 = nequal(swizzle_x(r270C), body.constant(0u));
               ir_expression *const r2C88 = bit_and(swizzle_y(r270C), body.constant(524287u));
               ir_expression *const r2C89 = nequal(r2C88, body.constant(0u));
               ir_expression *const r2C8A = logic_or(r2C87, r2C89);
               body.emit(assign(r2C83, logic_and(r2C86, r2C8A), 0x01));

               ir_variable *const r2C8B = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r2C8C = lshift(swizzle_y(r2740), body.constant(int(1)));
               ir_expression *const r2C8D = lequal(body.constant(4292870144u), r2C8C);
               ir_expression *const r2C8E = nequal(swizzle_x(r2740), body.constant(0u));
               ir_expression *const r2C8F = bit_and(swizzle_y(r2740), body.constant(1048575u));
               ir_expression *const r2C90 = nequal(r2C8F, body.constant(0u));
               ir_expression *const r2C91 = logic_or(r2C8E, r2C90);
               body.emit(assign(r2C8B, logic_and(r2C8D, r2C91), 0x01));

               body.emit(assign(r2C80, bit_or(swizzle_y(r270C), body.constant(524288u)), 0x02));

               body.emit(assign(r2C81, bit_or(swizzle_y(r2740), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r2C93 = lshift(swizzle_y(r270C), body.constant(int(1)));
               ir_expression *const r2C94 = lequal(body.constant(4292870144u), r2C93);
               ir_expression *const r2C95 = nequal(swizzle_x(r270C), body.constant(0u));
               ir_expression *const r2C96 = bit_and(swizzle_y(r270C), body.constant(1048575u));
               ir_expression *const r2C97 = nequal(r2C96, body.constant(0u));
               ir_expression *const r2C98 = logic_or(r2C95, r2C97);
               ir_expression *const r2C99 = logic_and(r2C94, r2C98);
               ir_if *f2C92 = new(mem_ctx) ir_if(operand(r2C99).val);
               exec_list *const f2C92_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2C92->then_instructions;

                  ir_variable *const r2C9A = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2C9C = logic_and(r2C83, r2C8B);
                  ir_if *f2C9B = new(mem_ctx) ir_if(operand(r2C9C).val);
                  exec_list *const f2C9B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2C9B->then_instructions;

                     body.emit(assign(r2C9A, r2C81, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2C9B->else_instructions;

                     body.emit(assign(r2C9A, r2C80, 0x03));


                  body.instructions = f2C9B_parent_instructions;
                  body.emit(f2C9B);

                  /* END IF */

                  body.emit(assign(r2C82, r2C9A, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2C92->else_instructions;

                  body.emit(assign(r2C82, r2C81, 0x03));


               body.instructions = f2C92_parent_instructions;
               body.emit(f2C92);

               /* END IF */

               body.emit(assign(r2C60, r2C82, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2C7D->else_instructions;

               body.emit(assign(r2C60, r270C, 0x03));


            body.instructions = f2C7D_parent_instructions;
            body.emit(f2C7D);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2C7B->else_instructions;

            /* IF CONDITION */
            ir_expression *const r2C9E = equal(r2C6C, body.constant(int(0)));
            ir_if *f2C9D = new(mem_ctx) ir_if(operand(r2C9E).val);
            exec_list *const f2C9D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2C9D->then_instructions;

               body.emit(assign(r2C61, add(r2C61, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2C9D->else_instructions;

               body.emit(assign(r2C64, bit_or(r2C75, body.constant(1073741824u)), 0x01));


            body.instructions = f2C9D_parent_instructions;
            body.emit(f2C9D);

            /* END IF */

            ir_variable *const r2C9F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r2C9F);
            ir_variable *const r2CA0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r2CA0);
            ir_variable *const r2CA1 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r2CA2 = neg(r2C61);
            body.emit(assign(r2CA1, bit_and(r2CA2, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r2CA4 = equal(r2C61, body.constant(int(0)));
            ir_if *f2CA3 = new(mem_ctx) ir_if(operand(r2CA4).val);
            exec_list *const f2CA3_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2CA3->then_instructions;

               body.emit(assign(r2C9F, r2C74, 0x01));

               body.emit(assign(r2CA0, r2C64, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2CA3->else_instructions;

               /* IF CONDITION */
               ir_expression *const r2CA6 = less(r2C61, body.constant(int(32)));
               ir_if *f2CA5 = new(mem_ctx) ir_if(operand(r2CA6).val);
               exec_list *const f2CA5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2CA5->then_instructions;

                  ir_expression *const r2CA7 = lshift(r2C64, r2CA1);
                  ir_expression *const r2CA8 = rshift(r2C74, r2C61);
                  ir_expression *const r2CA9 = bit_or(r2CA7, r2CA8);
                  ir_expression *const r2CAA = lshift(r2C74, r2CA1);
                  ir_expression *const r2CAB = nequal(r2CAA, body.constant(0u));
                  ir_expression *const r2CAC = expr(ir_unop_b2i, r2CAB);
                  ir_expression *const r2CAD = expr(ir_unop_i2u, r2CAC);
                  body.emit(assign(r2C9F, bit_or(r2CA9, r2CAD), 0x01));

                  body.emit(assign(r2CA0, rshift(r2C64, r2C61), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2CA5->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2CAF = equal(r2C61, body.constant(int(32)));
                  ir_if *f2CAE = new(mem_ctx) ir_if(operand(r2CAF).val);
                  exec_list *const f2CAE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2CAE->then_instructions;

                     ir_expression *const r2CB0 = nequal(r2C74, body.constant(0u));
                     ir_expression *const r2CB1 = expr(ir_unop_b2i, r2CB0);
                     ir_expression *const r2CB2 = expr(ir_unop_i2u, r2CB1);
                     body.emit(assign(r2C9F, bit_or(r2C64, r2CB2), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2CAE->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2CB4 = less(r2C61, body.constant(int(64)));
                     ir_if *f2CB3 = new(mem_ctx) ir_if(operand(r2CB4).val);
                     exec_list *const f2CB3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2CB3->then_instructions;

                        ir_expression *const r2CB5 = bit_and(r2C61, body.constant(int(31)));
                        ir_expression *const r2CB6 = rshift(r2C64, r2CB5);
                        ir_expression *const r2CB7 = lshift(r2C64, r2CA1);
                        ir_expression *const r2CB8 = bit_or(r2CB7, r2C74);
                        ir_expression *const r2CB9 = nequal(r2CB8, body.constant(0u));
                        ir_expression *const r2CBA = expr(ir_unop_b2i, r2CB9);
                        ir_expression *const r2CBB = expr(ir_unop_i2u, r2CBA);
                        body.emit(assign(r2C9F, bit_or(r2CB6, r2CBB), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2CB3->else_instructions;

                        ir_expression *const r2CBC = bit_or(r2C64, r2C74);
                        ir_expression *const r2CBD = nequal(r2CBC, body.constant(0u));
                        ir_expression *const r2CBE = expr(ir_unop_b2i, r2CBD);
                        body.emit(assign(r2C9F, expr(ir_unop_i2u, r2CBE), 0x01));


                     body.instructions = f2CB3_parent_instructions;
                     body.emit(f2CB3);

                     /* END IF */


                  body.instructions = f2CAE_parent_instructions;
                  body.emit(f2CAE);

                  /* END IF */

                  body.emit(assign(r2CA0, body.constant(0u), 0x01));


               body.instructions = f2CA5_parent_instructions;
               body.emit(f2CA5);

               /* END IF */


            body.instructions = f2CA3_parent_instructions;
            body.emit(f2CA3);

            /* END IF */

            body.emit(assign(r2C64, r2CA0, 0x01));

            body.emit(assign(r2C65, r2C9F, 0x01));

            body.emit(assign(r2C66, bit_or(r2C70, body.constant(1073741824u)), 0x01));

            ir_variable *const r2CBF = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r2CC0 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r2CC0, sub(r2C6F, r2C9F), 0x01));

            ir_expression *const r2CC1 = sub(r2C66, r2CA0);
            ir_expression *const r2CC2 = less(r2C6F, r2C9F);
            ir_expression *const r2CC3 = expr(ir_unop_b2i, r2CC2);
            ir_expression *const r2CC4 = expr(ir_unop_i2u, r2CC3);
            body.emit(assign(r2CBF, sub(r2CC1, r2CC4), 0x01));

            body.emit(assign(r2C68, add(r2C69, body.constant(int(-1))), 0x01));

            ir_variable *const r2CC5 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r2CC5, add(r2C68, body.constant(int(-10))), 0x01));

            ir_variable *const r2CC6 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r2CC6, r2CBF, 0x01));

            ir_variable *const r2CC7 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r2CC7, r2CC0, 0x01));

            ir_variable *const r2CC8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
            body.emit(r2CC8);
            ir_variable *const r2CC9 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r2CC9);
            /* IF CONDITION */
            ir_expression *const r2CCB = equal(r2CBF, body.constant(0u));
            ir_if *f2CCA = new(mem_ctx) ir_if(operand(r2CCB).val);
            exec_list *const f2CCA_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2CCA->then_instructions;

               body.emit(assign(r2CC6, r2CC0, 0x01));

               body.emit(assign(r2CC7, body.constant(0u), 0x01));

               body.emit(assign(r2CC5, add(r2CC5, body.constant(int(-32))), 0x01));


            body.instructions = f2CCA_parent_instructions;
            body.emit(f2CCA);

            /* END IF */

            ir_variable *const r2CCC = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r2CCC, r2CC6, 0x01));

            ir_variable *const r2CCD = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r2CCE = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r2CCE);
            /* IF CONDITION */
            ir_expression *const r2CD0 = equal(r2CC6, body.constant(0u));
            ir_if *f2CCF = new(mem_ctx) ir_if(operand(r2CD0).val);
            exec_list *const f2CCF_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2CCF->then_instructions;

               body.emit(assign(r2CCD, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2CCF->else_instructions;

               body.emit(assign(r2CCE, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r2CD2 = bit_and(r2CC6, body.constant(4294901760u));
               ir_expression *const r2CD3 = equal(r2CD2, body.constant(0u));
               ir_if *f2CD1 = new(mem_ctx) ir_if(operand(r2CD3).val);
               exec_list *const f2CD1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2CD1->then_instructions;

                  body.emit(assign(r2CCE, body.constant(int(16)), 0x01));

                  body.emit(assign(r2CCC, lshift(r2CC6, body.constant(int(16))), 0x01));


               body.instructions = f2CD1_parent_instructions;
               body.emit(f2CD1);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r2CD5 = bit_and(r2CCC, body.constant(4278190080u));
               ir_expression *const r2CD6 = equal(r2CD5, body.constant(0u));
               ir_if *f2CD4 = new(mem_ctx) ir_if(operand(r2CD6).val);
               exec_list *const f2CD4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2CD4->then_instructions;

                  body.emit(assign(r2CCE, add(r2CCE, body.constant(int(8))), 0x01));

                  body.emit(assign(r2CCC, lshift(r2CCC, body.constant(int(8))), 0x01));


               body.instructions = f2CD4_parent_instructions;
               body.emit(f2CD4);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r2CD8 = bit_and(r2CCC, body.constant(4026531840u));
               ir_expression *const r2CD9 = equal(r2CD8, body.constant(0u));
               ir_if *f2CD7 = new(mem_ctx) ir_if(operand(r2CD9).val);
               exec_list *const f2CD7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2CD7->then_instructions;

                  body.emit(assign(r2CCE, add(r2CCE, body.constant(int(4))), 0x01));

                  body.emit(assign(r2CCC, lshift(r2CCC, body.constant(int(4))), 0x01));


               body.instructions = f2CD7_parent_instructions;
               body.emit(f2CD7);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r2CDB = bit_and(r2CCC, body.constant(3221225472u));
               ir_expression *const r2CDC = equal(r2CDB, body.constant(0u));
               ir_if *f2CDA = new(mem_ctx) ir_if(operand(r2CDC).val);
               exec_list *const f2CDA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2CDA->then_instructions;

                  body.emit(assign(r2CCE, add(r2CCE, body.constant(int(2))), 0x01));

                  body.emit(assign(r2CCC, lshift(r2CCC, body.constant(int(2))), 0x01));


               body.instructions = f2CDA_parent_instructions;
               body.emit(f2CDA);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r2CDE = bit_and(r2CCC, body.constant(2147483648u));
               ir_expression *const r2CDF = equal(r2CDE, body.constant(0u));
               ir_if *f2CDD = new(mem_ctx) ir_if(operand(r2CDF).val);
               exec_list *const f2CDD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2CDD->then_instructions;

                  body.emit(assign(r2CCE, add(r2CCE, body.constant(int(1))), 0x01));


               body.instructions = f2CDD_parent_instructions;
               body.emit(f2CDD);

               /* END IF */

               body.emit(assign(r2CCD, r2CCE, 0x01));


            body.instructions = f2CCF_parent_instructions;
            body.emit(f2CCF);

            /* END IF */

            body.emit(assign(r2CC9, add(r2CCD, body.constant(int(-11))), 0x01));

            /* IF CONDITION */
            ir_expression *const r2CE1 = lequal(body.constant(int(0)), r2CC9);
            ir_if *f2CE0 = new(mem_ctx) ir_if(operand(r2CE1).val);
            exec_list *const f2CE0_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2CE0->then_instructions;

               body.emit(assign(r2CC8, body.constant(0u), 0x01));

               ir_variable *const r2CE2 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r2CE2, lshift(r2CC7, r2CC9), 0x01));

               ir_variable *const r2CE3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r2CE5 = equal(r2CC9, body.constant(int(0)));
               ir_if *f2CE4 = new(mem_ctx) ir_if(operand(r2CE5).val);
               exec_list *const f2CE4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2CE4->then_instructions;

                  body.emit(assign(r2CE3, r2CC6, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2CE4->else_instructions;

                  ir_expression *const r2CE6 = lshift(r2CC6, r2CC9);
                  ir_expression *const r2CE7 = neg(r2CC9);
                  ir_expression *const r2CE8 = bit_and(r2CE7, body.constant(int(31)));
                  ir_expression *const r2CE9 = rshift(r2CC7, r2CE8);
                  body.emit(assign(r2CE3, bit_or(r2CE6, r2CE9), 0x01));


               body.instructions = f2CE4_parent_instructions;
               body.emit(f2CE4);

               /* END IF */

               body.emit(assign(r2CC6, r2CE3, 0x01));

               body.emit(assign(r2CC7, r2CE2, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2CE0->else_instructions;

               ir_variable *const r2CEA = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r2CEA, body.constant(0u), 0x01));

               ir_variable *const r2CEB = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r2CEB, neg(r2CC9), 0x01));

               ir_variable *const r2CEC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r2CEC);
               ir_variable *const r2CED = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2CED);
               ir_variable *const r2CEE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2CEE);
               ir_variable *const r2CEF = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2CF0 = neg(r2CEB);
               body.emit(assign(r2CEF, bit_and(r2CF0, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2CF2 = equal(r2CEB, body.constant(int(0)));
               ir_if *f2CF1 = new(mem_ctx) ir_if(operand(r2CF2).val);
               exec_list *const f2CF1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2CF1->then_instructions;

                  body.emit(assign(r2CEC, r2CEA, 0x01));

                  body.emit(assign(r2CED, r2CC7, 0x01));

                  body.emit(assign(r2CEE, r2CC6, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2CF1->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2CF4 = less(r2CEB, body.constant(int(32)));
                  ir_if *f2CF3 = new(mem_ctx) ir_if(operand(r2CF4).val);
                  exec_list *const f2CF3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2CF3->then_instructions;

                     body.emit(assign(r2CEC, lshift(r2CC7, r2CEF), 0x01));

                     ir_expression *const r2CF5 = lshift(r2CC6, r2CEF);
                     ir_expression *const r2CF6 = rshift(r2CC7, r2CEB);
                     body.emit(assign(r2CED, bit_or(r2CF5, r2CF6), 0x01));

                     body.emit(assign(r2CEE, rshift(r2CC6, r2CEB), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2CF3->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2CF8 = equal(r2CEB, body.constant(int(32)));
                     ir_if *f2CF7 = new(mem_ctx) ir_if(operand(r2CF8).val);
                     exec_list *const f2CF7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2CF7->then_instructions;

                        body.emit(assign(r2CEC, r2CC7, 0x01));

                        body.emit(assign(r2CED, r2CC6, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2CF7->else_instructions;

                        body.emit(assign(r2CEA, bit_or(body.constant(0u), r2CC7), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2CFA = less(r2CEB, body.constant(int(64)));
                        ir_if *f2CF9 = new(mem_ctx) ir_if(operand(r2CFA).val);
                        exec_list *const f2CF9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2CF9->then_instructions;

                           body.emit(assign(r2CEC, lshift(r2CC6, r2CEF), 0x01));

                           ir_expression *const r2CFB = bit_and(r2CEB, body.constant(int(31)));
                           body.emit(assign(r2CED, rshift(r2CC6, r2CFB), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2CF9->else_instructions;

                           ir_variable *const r2CFC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2CFE = equal(r2CEB, body.constant(int(64)));
                           ir_if *f2CFD = new(mem_ctx) ir_if(operand(r2CFE).val);
                           exec_list *const f2CFD_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2CFD->then_instructions;

                              body.emit(assign(r2CFC, r2CC6, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2CFD->else_instructions;

                              ir_expression *const r2CFF = nequal(r2CC6, body.constant(0u));
                              ir_expression *const r2D00 = expr(ir_unop_b2i, r2CFF);
                              body.emit(assign(r2CFC, expr(ir_unop_i2u, r2D00), 0x01));


                           body.instructions = f2CFD_parent_instructions;
                           body.emit(f2CFD);

                           /* END IF */

                           body.emit(assign(r2CEC, r2CFC, 0x01));

                           body.emit(assign(r2CED, body.constant(0u), 0x01));


                        body.instructions = f2CF9_parent_instructions;
                        body.emit(f2CF9);

                        /* END IF */


                     body.instructions = f2CF7_parent_instructions;
                     body.emit(f2CF7);

                     /* END IF */

                     body.emit(assign(r2CEE, body.constant(0u), 0x01));


                  body.instructions = f2CF3_parent_instructions;
                  body.emit(f2CF3);

                  /* END IF */

                  ir_expression *const r2D01 = nequal(r2CEA, body.constant(0u));
                  ir_expression *const r2D02 = expr(ir_unop_b2i, r2D01);
                  ir_expression *const r2D03 = expr(ir_unop_i2u, r2D02);
                  body.emit(assign(r2CEC, bit_or(r2CEC, r2D03), 0x01));


               body.instructions = f2CF1_parent_instructions;
               body.emit(f2CF1);

               /* END IF */

               body.emit(assign(r2CC6, r2CEE, 0x01));

               body.emit(assign(r2CC7, r2CED, 0x01));

               body.emit(assign(r2CC8, r2CEC, 0x01));


            body.instructions = f2CE0_parent_instructions;
            body.emit(f2CE0);

            /* END IF */

            body.emit(assign(r2CC5, sub(r2CC5, r2CC9), 0x01));

            ir_variable *const r2D04 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r2D04, r2CC5, 0x01));

            ir_variable *const r2D05 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r2D05, r2CC6, 0x01));

            ir_variable *const r2D06 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r2D06, r2CC7, 0x01));

            ir_variable *const r2D07 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r2D07, r2CC8, 0x01));

            ir_variable *const r2D08 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r2D08, body.constant(true), 0x01));

            ir_variable *const r2D09 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r2D0A = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r2D0A);
            ir_expression *const r2D0B = expr(ir_unop_u2i, r2CC8);
            body.emit(assign(r2D0A, less(r2D0B, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r2D0D = lequal(body.constant(int(2045)), r2CC5);
            ir_if *f2D0C = new(mem_ctx) ir_if(operand(r2D0D).val);
            exec_list *const f2D0C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2D0C->then_instructions;

               ir_variable *const r2D0E = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r2D10 = less(body.constant(int(2045)), r2CC5);
               ir_if *f2D0F = new(mem_ctx) ir_if(operand(r2D10).val);
               exec_list *const f2D0F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2D0F->then_instructions;

                  body.emit(assign(r2D0E, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2D0F->else_instructions;

                  ir_variable *const r2D11 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2D13 = equal(r2CC5, body.constant(int(2045)));
                  ir_if *f2D12 = new(mem_ctx) ir_if(operand(r2D13).val);
                  exec_list *const f2D12_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2D12->then_instructions;

                     ir_expression *const r2D14 = equal(body.constant(2097151u), r2CC6);
                     ir_expression *const r2D15 = equal(body.constant(4294967295u), r2CC7);
                     body.emit(assign(r2D11, logic_and(r2D14, r2D15), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2D12->else_instructions;

                     body.emit(assign(r2D11, body.constant(false), 0x01));


                  body.instructions = f2D12_parent_instructions;
                  body.emit(f2D12);

                  /* END IF */

                  body.emit(assign(r2D0E, logic_and(r2D11, r2D0A), 0x01));


               body.instructions = f2D0F_parent_instructions;
               body.emit(f2D0F);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2D16 = new(mem_ctx) ir_if(operand(r2D0E).val);
               exec_list *const f2D16_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2D16->then_instructions;

                  ir_variable *const r2D17 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2D17);
                  ir_expression *const r2D18 = lshift(r2C5B, body.constant(int(31)));
                  body.emit(assign(r2D17, add(r2D18, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r2D17, body.constant(0u), 0x01));

                  body.emit(assign(r2D09, r2D17, 0x03));

                  body.emit(assign(r2D08, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2D16->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2D1A = less(r2CC5, body.constant(int(0)));
                  ir_if *f2D19 = new(mem_ctx) ir_if(operand(r2D1A).val);
                  exec_list *const f2D19_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2D19->then_instructions;

                     ir_variable *const r2D1B = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r2D1B, r2CC8, 0x01));

                     ir_variable *const r2D1C = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r2D1C, neg(r2CC5), 0x01));

                     ir_variable *const r2D1D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r2D1D);
                     ir_variable *const r2D1E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r2D1E);
                     ir_variable *const r2D1F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r2D1F);
                     ir_variable *const r2D20 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r2D21 = neg(r2D1C);
                     body.emit(assign(r2D20, bit_and(r2D21, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2D23 = equal(r2D1C, body.constant(int(0)));
                     ir_if *f2D22 = new(mem_ctx) ir_if(operand(r2D23).val);
                     exec_list *const f2D22_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2D22->then_instructions;

                        body.emit(assign(r2D1D, r2CC8, 0x01));

                        body.emit(assign(r2D1E, r2CC7, 0x01));

                        body.emit(assign(r2D1F, r2CC6, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2D22->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2D25 = less(r2D1C, body.constant(int(32)));
                        ir_if *f2D24 = new(mem_ctx) ir_if(operand(r2D25).val);
                        exec_list *const f2D24_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2D24->then_instructions;

                           body.emit(assign(r2D1D, lshift(r2CC7, r2D20), 0x01));

                           ir_expression *const r2D26 = lshift(r2CC6, r2D20);
                           ir_expression *const r2D27 = rshift(r2CC7, r2D1C);
                           body.emit(assign(r2D1E, bit_or(r2D26, r2D27), 0x01));

                           body.emit(assign(r2D1F, rshift(r2CC6, r2D1C), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2D24->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2D29 = equal(r2D1C, body.constant(int(32)));
                           ir_if *f2D28 = new(mem_ctx) ir_if(operand(r2D29).val);
                           exec_list *const f2D28_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2D28->then_instructions;

                              body.emit(assign(r2D1D, r2CC7, 0x01));

                              body.emit(assign(r2D1E, r2CC6, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2D28->else_instructions;

                              body.emit(assign(r2D1B, bit_or(r2CC8, r2CC7), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2D2B = less(r2D1C, body.constant(int(64)));
                              ir_if *f2D2A = new(mem_ctx) ir_if(operand(r2D2B).val);
                              exec_list *const f2D2A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2D2A->then_instructions;

                                 body.emit(assign(r2D1D, lshift(r2CC6, r2D20), 0x01));

                                 ir_expression *const r2D2C = bit_and(r2D1C, body.constant(int(31)));
                                 body.emit(assign(r2D1E, rshift(r2CC6, r2D2C), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2D2A->else_instructions;

                                 ir_variable *const r2D2D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2D2F = equal(r2D1C, body.constant(int(64)));
                                 ir_if *f2D2E = new(mem_ctx) ir_if(operand(r2D2F).val);
                                 exec_list *const f2D2E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2D2E->then_instructions;

                                    body.emit(assign(r2D2D, r2CC6, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2D2E->else_instructions;

                                    ir_expression *const r2D30 = nequal(r2CC6, body.constant(0u));
                                    ir_expression *const r2D31 = expr(ir_unop_b2i, r2D30);
                                    body.emit(assign(r2D2D, expr(ir_unop_i2u, r2D31), 0x01));


                                 body.instructions = f2D2E_parent_instructions;
                                 body.emit(f2D2E);

                                 /* END IF */

                                 body.emit(assign(r2D1D, r2D2D, 0x01));

                                 body.emit(assign(r2D1E, body.constant(0u), 0x01));


                              body.instructions = f2D2A_parent_instructions;
                              body.emit(f2D2A);

                              /* END IF */


                           body.instructions = f2D28_parent_instructions;
                           body.emit(f2D28);

                           /* END IF */

                           body.emit(assign(r2D1F, body.constant(0u), 0x01));


                        body.instructions = f2D24_parent_instructions;
                        body.emit(f2D24);

                        /* END IF */

                        ir_expression *const r2D32 = nequal(r2D1B, body.constant(0u));
                        ir_expression *const r2D33 = expr(ir_unop_b2i, r2D32);
                        ir_expression *const r2D34 = expr(ir_unop_i2u, r2D33);
                        body.emit(assign(r2D1D, bit_or(r2D1D, r2D34), 0x01));


                     body.instructions = f2D22_parent_instructions;
                     body.emit(f2D22);

                     /* END IF */

                     body.emit(assign(r2D05, r2D1F, 0x01));

                     body.emit(assign(r2D06, r2D1E, 0x01));

                     body.emit(assign(r2D07, r2D1D, 0x01));

                     body.emit(assign(r2D04, body.constant(int(0)), 0x01));

                     body.emit(assign(r2D0A, less(r2D1D, body.constant(0u)), 0x01));


                  body.instructions = f2D19_parent_instructions;
                  body.emit(f2D19);

                  /* END IF */


               body.instructions = f2D16_parent_instructions;
               body.emit(f2D16);

               /* END IF */


            body.instructions = f2D0C_parent_instructions;
            body.emit(f2D0C);

            /* END IF */

            /* IF CONDITION */
            ir_if *f2D35 = new(mem_ctx) ir_if(operand(r2D08).val);
            exec_list *const f2D35_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2D35->then_instructions;

               /* IF CONDITION */
               ir_if *f2D36 = new(mem_ctx) ir_if(operand(r2D0A).val);
               exec_list *const f2D36_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2D36->then_instructions;

                  ir_variable *const r2D37 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2D37, add(r2D06, body.constant(1u)), 0x01));

                  ir_expression *const r2D38 = less(r2D37, r2D06);
                  ir_expression *const r2D39 = expr(ir_unop_b2i, r2D38);
                  ir_expression *const r2D3A = expr(ir_unop_i2u, r2D39);
                  body.emit(assign(r2D05, add(r2D05, r2D3A), 0x01));

                  ir_expression *const r2D3B = equal(r2D07, body.constant(0u));
                  ir_expression *const r2D3C = expr(ir_unop_b2i, r2D3B);
                  ir_expression *const r2D3D = expr(ir_unop_i2u, r2D3C);
                  ir_expression *const r2D3E = add(r2D07, r2D3D);
                  ir_expression *const r2D3F = bit_and(r2D3E, body.constant(1u));
                  ir_expression *const r2D40 = expr(ir_unop_bit_not, r2D3F);
                  body.emit(assign(r2D06, bit_and(r2D37, r2D40), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2D36->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2D42 = bit_or(r2D05, r2D06);
                  ir_expression *const r2D43 = equal(r2D42, body.constant(0u));
                  ir_if *f2D41 = new(mem_ctx) ir_if(operand(r2D43).val);
                  exec_list *const f2D41_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2D41->then_instructions;

                     body.emit(assign(r2D04, body.constant(int(0)), 0x01));


                  body.instructions = f2D41_parent_instructions;
                  body.emit(f2D41);

                  /* END IF */


               body.instructions = f2D36_parent_instructions;
               body.emit(f2D36);

               /* END IF */

               ir_variable *const r2D44 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r2D44);
               ir_expression *const r2D45 = lshift(r2C5B, body.constant(int(31)));
               ir_expression *const r2D46 = expr(ir_unop_i2u, r2D04);
               ir_expression *const r2D47 = lshift(r2D46, body.constant(int(20)));
               ir_expression *const r2D48 = add(r2D45, r2D47);
               body.emit(assign(r2D44, add(r2D48, r2D05), 0x02));

               body.emit(assign(r2D44, r2D06, 0x01));

               body.emit(assign(r2D09, r2D44, 0x03));

               body.emit(assign(r2D08, body.constant(false), 0x01));


            body.instructions = f2D35_parent_instructions;
            body.emit(f2D35);

            /* END IF */

            body.emit(assign(r2C60, r2D09, 0x03));


         body.instructions = f2C7B_parent_instructions;
         body.emit(f2C7B);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f2C79->else_instructions;

         /* IF CONDITION */
         ir_expression *const r2D4A = less(r2C61, body.constant(int(0)));
         ir_if *f2D49 = new(mem_ctx) ir_if(operand(r2D4A).val);
         exec_list *const f2D49_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2D49->then_instructions;

            /* IF CONDITION */
            ir_expression *const r2D4C = equal(r2C6C, body.constant(int(2047)));
            ir_if *f2D4B = new(mem_ctx) ir_if(operand(r2D4C).val);
            exec_list *const f2D4B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2D4B->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2D4E = bit_or(r2C64, r2C65);
               ir_expression *const r2D4F = nequal(r2D4E, body.constant(0u));
               ir_if *f2D4D = new(mem_ctx) ir_if(operand(r2D4F).val);
               exec_list *const f2D4D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2D4D->then_instructions;

                  ir_variable *const r2D50 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r2D50, swizzle_x(r270C), 0x01));

                  ir_variable *const r2D51 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r2D51, swizzle_x(r2740), 0x01));

                  ir_variable *const r2D52 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r2D53 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r2D54 = rshift(swizzle_y(r270C), body.constant(int(19)));
                  ir_expression *const r2D55 = bit_and(r2D54, body.constant(4095u));
                  ir_expression *const r2D56 = equal(r2D55, body.constant(4094u));
                  ir_expression *const r2D57 = nequal(swizzle_x(r270C), body.constant(0u));
                  ir_expression *const r2D58 = bit_and(swizzle_y(r270C), body.constant(524287u));
                  ir_expression *const r2D59 = nequal(r2D58, body.constant(0u));
                  ir_expression *const r2D5A = logic_or(r2D57, r2D59);
                  body.emit(assign(r2D53, logic_and(r2D56, r2D5A), 0x01));

                  ir_variable *const r2D5B = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r2D5C = lshift(swizzle_y(r2740), body.constant(int(1)));
                  ir_expression *const r2D5D = lequal(body.constant(4292870144u), r2D5C);
                  ir_expression *const r2D5E = nequal(swizzle_x(r2740), body.constant(0u));
                  ir_expression *const r2D5F = bit_and(swizzle_y(r2740), body.constant(1048575u));
                  ir_expression *const r2D60 = nequal(r2D5F, body.constant(0u));
                  ir_expression *const r2D61 = logic_or(r2D5E, r2D60);
                  body.emit(assign(r2D5B, logic_and(r2D5D, r2D61), 0x01));

                  body.emit(assign(r2D50, bit_or(swizzle_y(r270C), body.constant(524288u)), 0x02));

                  body.emit(assign(r2D51, bit_or(swizzle_y(r2740), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r2D63 = lshift(swizzle_y(r270C), body.constant(int(1)));
                  ir_expression *const r2D64 = lequal(body.constant(4292870144u), r2D63);
                  ir_expression *const r2D65 = nequal(swizzle_x(r270C), body.constant(0u));
                  ir_expression *const r2D66 = bit_and(swizzle_y(r270C), body.constant(1048575u));
                  ir_expression *const r2D67 = nequal(r2D66, body.constant(0u));
                  ir_expression *const r2D68 = logic_or(r2D65, r2D67);
                  ir_expression *const r2D69 = logic_and(r2D64, r2D68);
                  ir_if *f2D62 = new(mem_ctx) ir_if(operand(r2D69).val);
                  exec_list *const f2D62_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2D62->then_instructions;

                     ir_variable *const r2D6A = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2D6C = logic_and(r2D53, r2D5B);
                     ir_if *f2D6B = new(mem_ctx) ir_if(operand(r2D6C).val);
                     exec_list *const f2D6B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2D6B->then_instructions;

                        body.emit(assign(r2D6A, r2D51, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2D6B->else_instructions;

                        body.emit(assign(r2D6A, r2D50, 0x03));


                     body.instructions = f2D6B_parent_instructions;
                     body.emit(f2D6B);

                     /* END IF */

                     body.emit(assign(r2D52, r2D6A, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2D62->else_instructions;

                     body.emit(assign(r2D52, r2D51, 0x03));


                  body.instructions = f2D62_parent_instructions;
                  body.emit(f2D62);

                  /* END IF */

                  body.emit(assign(r2C60, r2D52, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2D4D->else_instructions;

                  ir_variable *const r2D6D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2D6D);
                  ir_expression *const r2D6E = bit_xor(r2C5B, body.constant(1u));
                  ir_expression *const r2D6F = lshift(r2D6E, body.constant(int(31)));
                  body.emit(assign(r2D6D, add(r2D6F, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r2D6D, body.constant(0u), 0x01));

                  body.emit(assign(r2C60, r2D6D, 0x03));


               body.instructions = f2D4D_parent_instructions;
               body.emit(f2D4D);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2D4B->else_instructions;

               /* IF CONDITION */
               ir_expression *const r2D71 = equal(r2C69, body.constant(int(0)));
               ir_if *f2D70 = new(mem_ctx) ir_if(operand(r2D71).val);
               exec_list *const f2D70_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2D70->then_instructions;

                  body.emit(assign(r2C61, add(r2C61, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2D70->else_instructions;

                  body.emit(assign(r2C66, bit_or(r2C66, body.constant(1073741824u)), 0x01));


               body.instructions = f2D70_parent_instructions;
               body.emit(f2D70);

               /* END IF */

               ir_variable *const r2D72 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r2D72, neg(r2C61), 0x01));

               ir_variable *const r2D73 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2D73);
               ir_variable *const r2D74 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2D74);
               ir_variable *const r2D75 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2D76 = neg(r2D72);
               body.emit(assign(r2D75, bit_and(r2D76, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2D78 = equal(r2D72, body.constant(int(0)));
               ir_if *f2D77 = new(mem_ctx) ir_if(operand(r2D78).val);
               exec_list *const f2D77_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2D77->then_instructions;

                  body.emit(assign(r2D73, r2C6F, 0x01));

                  body.emit(assign(r2D74, r2C66, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2D77->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2D7A = less(r2D72, body.constant(int(32)));
                  ir_if *f2D79 = new(mem_ctx) ir_if(operand(r2D7A).val);
                  exec_list *const f2D79_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2D79->then_instructions;

                     ir_expression *const r2D7B = lshift(r2C66, r2D75);
                     ir_expression *const r2D7C = rshift(r2C6F, r2D72);
                     ir_expression *const r2D7D = bit_or(r2D7B, r2D7C);
                     ir_expression *const r2D7E = lshift(r2C6F, r2D75);
                     ir_expression *const r2D7F = nequal(r2D7E, body.constant(0u));
                     ir_expression *const r2D80 = expr(ir_unop_b2i, r2D7F);
                     ir_expression *const r2D81 = expr(ir_unop_i2u, r2D80);
                     body.emit(assign(r2D73, bit_or(r2D7D, r2D81), 0x01));

                     body.emit(assign(r2D74, rshift(r2C66, r2D72), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2D79->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2D83 = equal(r2D72, body.constant(int(32)));
                     ir_if *f2D82 = new(mem_ctx) ir_if(operand(r2D83).val);
                     exec_list *const f2D82_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2D82->then_instructions;

                        ir_expression *const r2D84 = nequal(r2C6F, body.constant(0u));
                        ir_expression *const r2D85 = expr(ir_unop_b2i, r2D84);
                        ir_expression *const r2D86 = expr(ir_unop_i2u, r2D85);
                        body.emit(assign(r2D73, bit_or(r2C66, r2D86), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2D82->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2D88 = less(r2D72, body.constant(int(64)));
                        ir_if *f2D87 = new(mem_ctx) ir_if(operand(r2D88).val);
                        exec_list *const f2D87_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2D87->then_instructions;

                           ir_expression *const r2D89 = bit_and(r2D72, body.constant(int(31)));
                           ir_expression *const r2D8A = rshift(r2C66, r2D89);
                           ir_expression *const r2D8B = lshift(r2C66, r2D75);
                           ir_expression *const r2D8C = bit_or(r2D8B, r2C6F);
                           ir_expression *const r2D8D = nequal(r2D8C, body.constant(0u));
                           ir_expression *const r2D8E = expr(ir_unop_b2i, r2D8D);
                           ir_expression *const r2D8F = expr(ir_unop_i2u, r2D8E);
                           body.emit(assign(r2D73, bit_or(r2D8A, r2D8F), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2D87->else_instructions;

                           ir_expression *const r2D90 = bit_or(r2C66, r2C6F);
                           ir_expression *const r2D91 = nequal(r2D90, body.constant(0u));
                           ir_expression *const r2D92 = expr(ir_unop_b2i, r2D91);
                           body.emit(assign(r2D73, expr(ir_unop_i2u, r2D92), 0x01));


                        body.instructions = f2D87_parent_instructions;
                        body.emit(f2D87);

                        /* END IF */


                     body.instructions = f2D82_parent_instructions;
                     body.emit(f2D82);

                     /* END IF */

                     body.emit(assign(r2D74, body.constant(0u), 0x01));


                  body.instructions = f2D79_parent_instructions;
                  body.emit(f2D79);

                  /* END IF */


               body.instructions = f2D77_parent_instructions;
               body.emit(f2D77);

               /* END IF */

               body.emit(assign(r2C66, r2D74, 0x01));

               body.emit(assign(r2C67, r2D73, 0x01));

               body.emit(assign(r2C64, bit_or(r2C64, body.constant(1073741824u)), 0x01));

               ir_variable *const r2D93 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r2D94 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r2D94, sub(r2C65, r2D73), 0x01));

               ir_expression *const r2D95 = sub(r2C64, r2D74);
               ir_expression *const r2D96 = less(r2C65, r2D73);
               ir_expression *const r2D97 = expr(ir_unop_b2i, r2D96);
               ir_expression *const r2D98 = expr(ir_unop_i2u, r2D97);
               body.emit(assign(r2D93, sub(r2D95, r2D98), 0x01));

               body.emit(assign(r2C5F, bit_xor(r2C5B, body.constant(1u)), 0x01));

               body.emit(assign(r2C68, add(r2C6C, body.constant(int(-1))), 0x01));

               ir_variable *const r2D99 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2D99, add(r2C68, body.constant(int(-10))), 0x01));

               ir_variable *const r2D9A = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2D9A, r2D93, 0x01));

               ir_variable *const r2D9B = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2D9B, r2D94, 0x01));

               ir_variable *const r2D9C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r2D9C);
               ir_variable *const r2D9D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r2D9D);
               /* IF CONDITION */
               ir_expression *const r2D9F = equal(r2D93, body.constant(0u));
               ir_if *f2D9E = new(mem_ctx) ir_if(operand(r2D9F).val);
               exec_list *const f2D9E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2D9E->then_instructions;

                  body.emit(assign(r2D9A, r2D94, 0x01));

                  body.emit(assign(r2D9B, body.constant(0u), 0x01));

                  body.emit(assign(r2D99, add(r2D99, body.constant(int(-32))), 0x01));


               body.instructions = f2D9E_parent_instructions;
               body.emit(f2D9E);

               /* END IF */

               ir_variable *const r2DA0 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r2DA0, r2D9A, 0x01));

               ir_variable *const r2DA1 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r2DA2 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r2DA2);
               /* IF CONDITION */
               ir_expression *const r2DA4 = equal(r2D9A, body.constant(0u));
               ir_if *f2DA3 = new(mem_ctx) ir_if(operand(r2DA4).val);
               exec_list *const f2DA3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2DA3->then_instructions;

                  body.emit(assign(r2DA1, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2DA3->else_instructions;

                  body.emit(assign(r2DA2, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2DA6 = bit_and(r2D9A, body.constant(4294901760u));
                  ir_expression *const r2DA7 = equal(r2DA6, body.constant(0u));
                  ir_if *f2DA5 = new(mem_ctx) ir_if(operand(r2DA7).val);
                  exec_list *const f2DA5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2DA5->then_instructions;

                     body.emit(assign(r2DA2, body.constant(int(16)), 0x01));

                     body.emit(assign(r2DA0, lshift(r2D9A, body.constant(int(16))), 0x01));


                  body.instructions = f2DA5_parent_instructions;
                  body.emit(f2DA5);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2DA9 = bit_and(r2DA0, body.constant(4278190080u));
                  ir_expression *const r2DAA = equal(r2DA9, body.constant(0u));
                  ir_if *f2DA8 = new(mem_ctx) ir_if(operand(r2DAA).val);
                  exec_list *const f2DA8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2DA8->then_instructions;

                     body.emit(assign(r2DA2, add(r2DA2, body.constant(int(8))), 0x01));

                     body.emit(assign(r2DA0, lshift(r2DA0, body.constant(int(8))), 0x01));


                  body.instructions = f2DA8_parent_instructions;
                  body.emit(f2DA8);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2DAC = bit_and(r2DA0, body.constant(4026531840u));
                  ir_expression *const r2DAD = equal(r2DAC, body.constant(0u));
                  ir_if *f2DAB = new(mem_ctx) ir_if(operand(r2DAD).val);
                  exec_list *const f2DAB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2DAB->then_instructions;

                     body.emit(assign(r2DA2, add(r2DA2, body.constant(int(4))), 0x01));

                     body.emit(assign(r2DA0, lshift(r2DA0, body.constant(int(4))), 0x01));


                  body.instructions = f2DAB_parent_instructions;
                  body.emit(f2DAB);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2DAF = bit_and(r2DA0, body.constant(3221225472u));
                  ir_expression *const r2DB0 = equal(r2DAF, body.constant(0u));
                  ir_if *f2DAE = new(mem_ctx) ir_if(operand(r2DB0).val);
                  exec_list *const f2DAE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2DAE->then_instructions;

                     body.emit(assign(r2DA2, add(r2DA2, body.constant(int(2))), 0x01));

                     body.emit(assign(r2DA0, lshift(r2DA0, body.constant(int(2))), 0x01));


                  body.instructions = f2DAE_parent_instructions;
                  body.emit(f2DAE);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2DB2 = bit_and(r2DA0, body.constant(2147483648u));
                  ir_expression *const r2DB3 = equal(r2DB2, body.constant(0u));
                  ir_if *f2DB1 = new(mem_ctx) ir_if(operand(r2DB3).val);
                  exec_list *const f2DB1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2DB1->then_instructions;

                     body.emit(assign(r2DA2, add(r2DA2, body.constant(int(1))), 0x01));


                  body.instructions = f2DB1_parent_instructions;
                  body.emit(f2DB1);

                  /* END IF */

                  body.emit(assign(r2DA1, r2DA2, 0x01));


               body.instructions = f2DA3_parent_instructions;
               body.emit(f2DA3);

               /* END IF */

               body.emit(assign(r2D9D, add(r2DA1, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2DB5 = lequal(body.constant(int(0)), r2D9D);
               ir_if *f2DB4 = new(mem_ctx) ir_if(operand(r2DB5).val);
               exec_list *const f2DB4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2DB4->then_instructions;

                  body.emit(assign(r2D9C, body.constant(0u), 0x01));

                  ir_variable *const r2DB6 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r2DB6, lshift(r2D9B, r2D9D), 0x01));

                  ir_variable *const r2DB7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2DB9 = equal(r2D9D, body.constant(int(0)));
                  ir_if *f2DB8 = new(mem_ctx) ir_if(operand(r2DB9).val);
                  exec_list *const f2DB8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2DB8->then_instructions;

                     body.emit(assign(r2DB7, r2D9A, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2DB8->else_instructions;

                     ir_expression *const r2DBA = lshift(r2D9A, r2D9D);
                     ir_expression *const r2DBB = neg(r2D9D);
                     ir_expression *const r2DBC = bit_and(r2DBB, body.constant(int(31)));
                     ir_expression *const r2DBD = rshift(r2D9B, r2DBC);
                     body.emit(assign(r2DB7, bit_or(r2DBA, r2DBD), 0x01));


                  body.instructions = f2DB8_parent_instructions;
                  body.emit(f2DB8);

                  /* END IF */

                  body.emit(assign(r2D9A, r2DB7, 0x01));

                  body.emit(assign(r2D9B, r2DB6, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2DB4->else_instructions;

                  ir_variable *const r2DBE = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r2DBE, body.constant(0u), 0x01));

                  ir_variable *const r2DBF = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r2DBF, neg(r2D9D), 0x01));

                  ir_variable *const r2DC0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r2DC0);
                  ir_variable *const r2DC1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r2DC1);
                  ir_variable *const r2DC2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r2DC2);
                  ir_variable *const r2DC3 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r2DC4 = neg(r2DBF);
                  body.emit(assign(r2DC3, bit_and(r2DC4, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2DC6 = equal(r2DBF, body.constant(int(0)));
                  ir_if *f2DC5 = new(mem_ctx) ir_if(operand(r2DC6).val);
                  exec_list *const f2DC5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2DC5->then_instructions;

                     body.emit(assign(r2DC0, r2DBE, 0x01));

                     body.emit(assign(r2DC1, r2D9B, 0x01));

                     body.emit(assign(r2DC2, r2D9A, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2DC5->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2DC8 = less(r2DBF, body.constant(int(32)));
                     ir_if *f2DC7 = new(mem_ctx) ir_if(operand(r2DC8).val);
                     exec_list *const f2DC7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2DC7->then_instructions;

                        body.emit(assign(r2DC0, lshift(r2D9B, r2DC3), 0x01));

                        ir_expression *const r2DC9 = lshift(r2D9A, r2DC3);
                        ir_expression *const r2DCA = rshift(r2D9B, r2DBF);
                        body.emit(assign(r2DC1, bit_or(r2DC9, r2DCA), 0x01));

                        body.emit(assign(r2DC2, rshift(r2D9A, r2DBF), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2DC7->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2DCC = equal(r2DBF, body.constant(int(32)));
                        ir_if *f2DCB = new(mem_ctx) ir_if(operand(r2DCC).val);
                        exec_list *const f2DCB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2DCB->then_instructions;

                           body.emit(assign(r2DC0, r2D9B, 0x01));

                           body.emit(assign(r2DC1, r2D9A, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2DCB->else_instructions;

                           body.emit(assign(r2DBE, bit_or(body.constant(0u), r2D9B), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2DCE = less(r2DBF, body.constant(int(64)));
                           ir_if *f2DCD = new(mem_ctx) ir_if(operand(r2DCE).val);
                           exec_list *const f2DCD_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2DCD->then_instructions;

                              body.emit(assign(r2DC0, lshift(r2D9A, r2DC3), 0x01));

                              ir_expression *const r2DCF = bit_and(r2DBF, body.constant(int(31)));
                              body.emit(assign(r2DC1, rshift(r2D9A, r2DCF), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2DCD->else_instructions;

                              ir_variable *const r2DD0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2DD2 = equal(r2DBF, body.constant(int(64)));
                              ir_if *f2DD1 = new(mem_ctx) ir_if(operand(r2DD2).val);
                              exec_list *const f2DD1_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2DD1->then_instructions;

                                 body.emit(assign(r2DD0, r2D9A, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2DD1->else_instructions;

                                 ir_expression *const r2DD3 = nequal(r2D9A, body.constant(0u));
                                 ir_expression *const r2DD4 = expr(ir_unop_b2i, r2DD3);
                                 body.emit(assign(r2DD0, expr(ir_unop_i2u, r2DD4), 0x01));


                              body.instructions = f2DD1_parent_instructions;
                              body.emit(f2DD1);

                              /* END IF */

                              body.emit(assign(r2DC0, r2DD0, 0x01));

                              body.emit(assign(r2DC1, body.constant(0u), 0x01));


                           body.instructions = f2DCD_parent_instructions;
                           body.emit(f2DCD);

                           /* END IF */


                        body.instructions = f2DCB_parent_instructions;
                        body.emit(f2DCB);

                        /* END IF */

                        body.emit(assign(r2DC2, body.constant(0u), 0x01));


                     body.instructions = f2DC7_parent_instructions;
                     body.emit(f2DC7);

                     /* END IF */

                     ir_expression *const r2DD5 = nequal(r2DBE, body.constant(0u));
                     ir_expression *const r2DD6 = expr(ir_unop_b2i, r2DD5);
                     ir_expression *const r2DD7 = expr(ir_unop_i2u, r2DD6);
                     body.emit(assign(r2DC0, bit_or(r2DC0, r2DD7), 0x01));


                  body.instructions = f2DC5_parent_instructions;
                  body.emit(f2DC5);

                  /* END IF */

                  body.emit(assign(r2D9A, r2DC2, 0x01));

                  body.emit(assign(r2D9B, r2DC1, 0x01));

                  body.emit(assign(r2D9C, r2DC0, 0x01));


               body.instructions = f2DB4_parent_instructions;
               body.emit(f2DB4);

               /* END IF */

               body.emit(assign(r2D99, sub(r2D99, r2D9D), 0x01));

               ir_variable *const r2DD8 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2DD8, r2D99, 0x01));

               ir_variable *const r2DD9 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2DD9, r2D9A, 0x01));

               ir_variable *const r2DDA = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2DDA, r2D9B, 0x01));

               ir_variable *const r2DDB = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r2DDB, r2D9C, 0x01));

               ir_variable *const r2DDC = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r2DDC, body.constant(true), 0x01));

               ir_variable *const r2DDD = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2DDE = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2DDE);
               ir_expression *const r2DDF = expr(ir_unop_u2i, r2D9C);
               body.emit(assign(r2DDE, less(r2DDF, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2DE1 = lequal(body.constant(int(2045)), r2D99);
               ir_if *f2DE0 = new(mem_ctx) ir_if(operand(r2DE1).val);
               exec_list *const f2DE0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2DE0->then_instructions;

                  ir_variable *const r2DE2 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2DE4 = less(body.constant(int(2045)), r2D99);
                  ir_if *f2DE3 = new(mem_ctx) ir_if(operand(r2DE4).val);
                  exec_list *const f2DE3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2DE3->then_instructions;

                     body.emit(assign(r2DE2, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2DE3->else_instructions;

                     ir_variable *const r2DE5 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2DE7 = equal(r2D99, body.constant(int(2045)));
                     ir_if *f2DE6 = new(mem_ctx) ir_if(operand(r2DE7).val);
                     exec_list *const f2DE6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2DE6->then_instructions;

                        ir_expression *const r2DE8 = equal(body.constant(2097151u), r2D9A);
                        ir_expression *const r2DE9 = equal(body.constant(4294967295u), r2D9B);
                        body.emit(assign(r2DE5, logic_and(r2DE8, r2DE9), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2DE6->else_instructions;

                        body.emit(assign(r2DE5, body.constant(false), 0x01));


                     body.instructions = f2DE6_parent_instructions;
                     body.emit(f2DE6);

                     /* END IF */

                     body.emit(assign(r2DE2, logic_and(r2DE5, r2DDE), 0x01));


                  body.instructions = f2DE3_parent_instructions;
                  body.emit(f2DE3);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2DEA = new(mem_ctx) ir_if(operand(r2DE2).val);
                  exec_list *const f2DEA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2DEA->then_instructions;

                     ir_variable *const r2DEB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2DEB);
                     ir_expression *const r2DEC = lshift(r2C5F, body.constant(int(31)));
                     body.emit(assign(r2DEB, add(r2DEC, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r2DEB, body.constant(0u), 0x01));

                     body.emit(assign(r2DDD, r2DEB, 0x03));

                     body.emit(assign(r2DDC, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2DEA->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2DEE = less(r2D99, body.constant(int(0)));
                     ir_if *f2DED = new(mem_ctx) ir_if(operand(r2DEE).val);
                     exec_list *const f2DED_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2DED->then_instructions;

                        ir_variable *const r2DEF = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2DEF, r2D9C, 0x01));

                        ir_variable *const r2DF0 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2DF0, neg(r2D99), 0x01));

                        ir_variable *const r2DF1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2DF1);
                        ir_variable *const r2DF2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2DF2);
                        ir_variable *const r2DF3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2DF3);
                        ir_variable *const r2DF4 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2DF5 = neg(r2DF0);
                        body.emit(assign(r2DF4, bit_and(r2DF5, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2DF7 = equal(r2DF0, body.constant(int(0)));
                        ir_if *f2DF6 = new(mem_ctx) ir_if(operand(r2DF7).val);
                        exec_list *const f2DF6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2DF6->then_instructions;

                           body.emit(assign(r2DF1, r2D9C, 0x01));

                           body.emit(assign(r2DF2, r2D9B, 0x01));

                           body.emit(assign(r2DF3, r2D9A, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2DF6->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2DF9 = less(r2DF0, body.constant(int(32)));
                           ir_if *f2DF8 = new(mem_ctx) ir_if(operand(r2DF9).val);
                           exec_list *const f2DF8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2DF8->then_instructions;

                              body.emit(assign(r2DF1, lshift(r2D9B, r2DF4), 0x01));

                              ir_expression *const r2DFA = lshift(r2D9A, r2DF4);
                              ir_expression *const r2DFB = rshift(r2D9B, r2DF0);
                              body.emit(assign(r2DF2, bit_or(r2DFA, r2DFB), 0x01));

                              body.emit(assign(r2DF3, rshift(r2D9A, r2DF0), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2DF8->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2DFD = equal(r2DF0, body.constant(int(32)));
                              ir_if *f2DFC = new(mem_ctx) ir_if(operand(r2DFD).val);
                              exec_list *const f2DFC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2DFC->then_instructions;

                                 body.emit(assign(r2DF1, r2D9B, 0x01));

                                 body.emit(assign(r2DF2, r2D9A, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2DFC->else_instructions;

                                 body.emit(assign(r2DEF, bit_or(r2D9C, r2D9B), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2DFF = less(r2DF0, body.constant(int(64)));
                                 ir_if *f2DFE = new(mem_ctx) ir_if(operand(r2DFF).val);
                                 exec_list *const f2DFE_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2DFE->then_instructions;

                                    body.emit(assign(r2DF1, lshift(r2D9A, r2DF4), 0x01));

                                    ir_expression *const r2E00 = bit_and(r2DF0, body.constant(int(31)));
                                    body.emit(assign(r2DF2, rshift(r2D9A, r2E00), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2DFE->else_instructions;

                                    ir_variable *const r2E01 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2E03 = equal(r2DF0, body.constant(int(64)));
                                    ir_if *f2E02 = new(mem_ctx) ir_if(operand(r2E03).val);
                                    exec_list *const f2E02_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2E02->then_instructions;

                                       body.emit(assign(r2E01, r2D9A, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2E02->else_instructions;

                                       ir_expression *const r2E04 = nequal(r2D9A, body.constant(0u));
                                       ir_expression *const r2E05 = expr(ir_unop_b2i, r2E04);
                                       body.emit(assign(r2E01, expr(ir_unop_i2u, r2E05), 0x01));


                                    body.instructions = f2E02_parent_instructions;
                                    body.emit(f2E02);

                                    /* END IF */

                                    body.emit(assign(r2DF1, r2E01, 0x01));

                                    body.emit(assign(r2DF2, body.constant(0u), 0x01));


                                 body.instructions = f2DFE_parent_instructions;
                                 body.emit(f2DFE);

                                 /* END IF */


                              body.instructions = f2DFC_parent_instructions;
                              body.emit(f2DFC);

                              /* END IF */

                              body.emit(assign(r2DF3, body.constant(0u), 0x01));


                           body.instructions = f2DF8_parent_instructions;
                           body.emit(f2DF8);

                           /* END IF */

                           ir_expression *const r2E06 = nequal(r2DEF, body.constant(0u));
                           ir_expression *const r2E07 = expr(ir_unop_b2i, r2E06);
                           ir_expression *const r2E08 = expr(ir_unop_i2u, r2E07);
                           body.emit(assign(r2DF1, bit_or(r2DF1, r2E08), 0x01));


                        body.instructions = f2DF6_parent_instructions;
                        body.emit(f2DF6);

                        /* END IF */

                        body.emit(assign(r2DD9, r2DF3, 0x01));

                        body.emit(assign(r2DDA, r2DF2, 0x01));

                        body.emit(assign(r2DDB, r2DF1, 0x01));

                        body.emit(assign(r2DD8, body.constant(int(0)), 0x01));

                        body.emit(assign(r2DDE, less(r2DF1, body.constant(0u)), 0x01));


                     body.instructions = f2DED_parent_instructions;
                     body.emit(f2DED);

                     /* END IF */


                  body.instructions = f2DEA_parent_instructions;
                  body.emit(f2DEA);

                  /* END IF */


               body.instructions = f2DE0_parent_instructions;
               body.emit(f2DE0);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2E09 = new(mem_ctx) ir_if(operand(r2DDC).val);
               exec_list *const f2E09_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2E09->then_instructions;

                  /* IF CONDITION */
                  ir_if *f2E0A = new(mem_ctx) ir_if(operand(r2DDE).val);
                  exec_list *const f2E0A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2E0A->then_instructions;

                     ir_variable *const r2E0B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r2E0B, add(r2DDA, body.constant(1u)), 0x01));

                     ir_expression *const r2E0C = less(r2E0B, r2DDA);
                     ir_expression *const r2E0D = expr(ir_unop_b2i, r2E0C);
                     ir_expression *const r2E0E = expr(ir_unop_i2u, r2E0D);
                     body.emit(assign(r2DD9, add(r2DD9, r2E0E), 0x01));

                     ir_expression *const r2E0F = equal(r2DDB, body.constant(0u));
                     ir_expression *const r2E10 = expr(ir_unop_b2i, r2E0F);
                     ir_expression *const r2E11 = expr(ir_unop_i2u, r2E10);
                     ir_expression *const r2E12 = add(r2DDB, r2E11);
                     ir_expression *const r2E13 = bit_and(r2E12, body.constant(1u));
                     ir_expression *const r2E14 = expr(ir_unop_bit_not, r2E13);
                     body.emit(assign(r2DDA, bit_and(r2E0B, r2E14), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2E0A->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2E16 = bit_or(r2DD9, r2DDA);
                     ir_expression *const r2E17 = equal(r2E16, body.constant(0u));
                     ir_if *f2E15 = new(mem_ctx) ir_if(operand(r2E17).val);
                     exec_list *const f2E15_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E15->then_instructions;

                        body.emit(assign(r2DD8, body.constant(int(0)), 0x01));


                     body.instructions = f2E15_parent_instructions;
                     body.emit(f2E15);

                     /* END IF */


                  body.instructions = f2E0A_parent_instructions;
                  body.emit(f2E0A);

                  /* END IF */

                  ir_variable *const r2E18 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2E18);
                  ir_expression *const r2E19 = lshift(r2C5F, body.constant(int(31)));
                  ir_expression *const r2E1A = expr(ir_unop_i2u, r2DD8);
                  ir_expression *const r2E1B = lshift(r2E1A, body.constant(int(20)));
                  ir_expression *const r2E1C = add(r2E19, r2E1B);
                  body.emit(assign(r2E18, add(r2E1C, r2DD9), 0x02));

                  body.emit(assign(r2E18, r2DDA, 0x01));

                  body.emit(assign(r2DDD, r2E18, 0x03));

                  body.emit(assign(r2DDC, body.constant(false), 0x01));


               body.instructions = f2E09_parent_instructions;
               body.emit(f2E09);

               /* END IF */

               body.emit(assign(r2C60, r2DDD, 0x03));


            body.instructions = f2D4B_parent_instructions;
            body.emit(f2D4B);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2D49->else_instructions;

            /* IF CONDITION */
            ir_expression *const r2E1E = equal(r2C69, body.constant(int(2047)));
            ir_if *f2E1D = new(mem_ctx) ir_if(operand(r2E1E).val);
            exec_list *const f2E1D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2E1D->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2E20 = bit_or(r2C66, r2C67);
               ir_expression *const r2E21 = bit_or(r2C64, r2C65);
               ir_expression *const r2E22 = bit_or(r2E20, r2E21);
               ir_expression *const r2E23 = nequal(r2E22, body.constant(0u));
               ir_if *f2E1F = new(mem_ctx) ir_if(operand(r2E23).val);
               exec_list *const f2E1F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2E1F->then_instructions;

                  ir_variable *const r2E24 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r2E24, swizzle_x(r270C), 0x01));

                  ir_variable *const r2E25 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r2E25, swizzle_x(r2740), 0x01));

                  ir_variable *const r2E26 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r2E27 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r2E28 = rshift(swizzle_y(r270C), body.constant(int(19)));
                  ir_expression *const r2E29 = bit_and(r2E28, body.constant(4095u));
                  ir_expression *const r2E2A = equal(r2E29, body.constant(4094u));
                  ir_expression *const r2E2B = nequal(swizzle_x(r270C), body.constant(0u));
                  ir_expression *const r2E2C = bit_and(swizzle_y(r270C), body.constant(524287u));
                  ir_expression *const r2E2D = nequal(r2E2C, body.constant(0u));
                  ir_expression *const r2E2E = logic_or(r2E2B, r2E2D);
                  body.emit(assign(r2E27, logic_and(r2E2A, r2E2E), 0x01));

                  ir_variable *const r2E2F = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r2E30 = lshift(swizzle_y(r2740), body.constant(int(1)));
                  ir_expression *const r2E31 = lequal(body.constant(4292870144u), r2E30);
                  ir_expression *const r2E32 = nequal(swizzle_x(r2740), body.constant(0u));
                  ir_expression *const r2E33 = bit_and(swizzle_y(r2740), body.constant(1048575u));
                  ir_expression *const r2E34 = nequal(r2E33, body.constant(0u));
                  ir_expression *const r2E35 = logic_or(r2E32, r2E34);
                  body.emit(assign(r2E2F, logic_and(r2E31, r2E35), 0x01));

                  body.emit(assign(r2E24, bit_or(swizzle_y(r270C), body.constant(524288u)), 0x02));

                  body.emit(assign(r2E25, bit_or(swizzle_y(r2740), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r2E37 = lshift(swizzle_y(r270C), body.constant(int(1)));
                  ir_expression *const r2E38 = lequal(body.constant(4292870144u), r2E37);
                  ir_expression *const r2E39 = nequal(swizzle_x(r270C), body.constant(0u));
                  ir_expression *const r2E3A = bit_and(swizzle_y(r270C), body.constant(1048575u));
                  ir_expression *const r2E3B = nequal(r2E3A, body.constant(0u));
                  ir_expression *const r2E3C = logic_or(r2E39, r2E3B);
                  ir_expression *const r2E3D = logic_and(r2E38, r2E3C);
                  ir_if *f2E36 = new(mem_ctx) ir_if(operand(r2E3D).val);
                  exec_list *const f2E36_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2E36->then_instructions;

                     ir_variable *const r2E3E = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2E40 = logic_and(r2E27, r2E2F);
                     ir_if *f2E3F = new(mem_ctx) ir_if(operand(r2E40).val);
                     exec_list *const f2E3F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E3F->then_instructions;

                        body.emit(assign(r2E3E, r2E25, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2E3F->else_instructions;

                        body.emit(assign(r2E3E, r2E24, 0x03));


                     body.instructions = f2E3F_parent_instructions;
                     body.emit(f2E3F);

                     /* END IF */

                     body.emit(assign(r2E26, r2E3E, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2E36->else_instructions;

                     body.emit(assign(r2E26, r2E25, 0x03));


                  body.instructions = f2E36_parent_instructions;
                  body.emit(f2E36);

                  /* END IF */

                  body.emit(assign(r2C60, r2E26, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2E1F->else_instructions;

                  ir_constant_data r2E41_data;
                  memset(&r2E41_data, 0, sizeof(ir_constant_data));
                  r2E41_data.u[0] = 4294967295;
                  r2E41_data.u[1] = 4294967295;
                  ir_constant *const r2E41 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r2E41_data);
                  body.emit(assign(r2C60, r2E41, 0x03));


               body.instructions = f2E1F_parent_instructions;
               body.emit(f2E1F);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2E1D->else_instructions;

               /* IF CONDITION */
               ir_expression *const r2E43 = equal(r2C69, body.constant(int(0)));
               ir_if *f2E42 = new(mem_ctx) ir_if(operand(r2E43).val);
               exec_list *const f2E42_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2E42->then_instructions;

                  body.emit(assign(r2C63, body.constant(int(1)), 0x01));

                  body.emit(assign(r2C62, body.constant(int(1)), 0x01));


               body.instructions = f2E42_parent_instructions;
               body.emit(f2E42);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r2E45 = less(r2C64, r2C66);
               ir_if *f2E44 = new(mem_ctx) ir_if(operand(r2E45).val);
               exec_list *const f2E44_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2E44->then_instructions;

                  ir_variable *const r2E46 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r2E47 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r2E47, sub(r2C67, r2C65), 0x01));

                  ir_expression *const r2E48 = sub(r2C66, r2C64);
                  ir_expression *const r2E49 = less(r2C67, r2C65);
                  ir_expression *const r2E4A = expr(ir_unop_b2i, r2E49);
                  ir_expression *const r2E4B = expr(ir_unop_i2u, r2E4A);
                  body.emit(assign(r2E46, sub(r2E48, r2E4B), 0x01));

                  body.emit(assign(r2C68, add(r2C63, body.constant(int(-1))), 0x01));

                  ir_variable *const r2E4C = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r2E4C, add(r2C68, body.constant(int(-10))), 0x01));

                  ir_variable *const r2E4D = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r2E4D, r2E46, 0x01));

                  ir_variable *const r2E4E = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r2E4E, r2E47, 0x01));

                  ir_variable *const r2E4F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r2E4F);
                  ir_variable *const r2E50 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r2E50);
                  /* IF CONDITION */
                  ir_expression *const r2E52 = equal(r2E46, body.constant(0u));
                  ir_if *f2E51 = new(mem_ctx) ir_if(operand(r2E52).val);
                  exec_list *const f2E51_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2E51->then_instructions;

                     body.emit(assign(r2E4D, r2E47, 0x01));

                     body.emit(assign(r2E4E, body.constant(0u), 0x01));

                     body.emit(assign(r2E4C, add(r2E4C, body.constant(int(-32))), 0x01));


                  body.instructions = f2E51_parent_instructions;
                  body.emit(f2E51);

                  /* END IF */

                  ir_variable *const r2E53 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r2E53, r2E4D, 0x01));

                  ir_variable *const r2E54 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r2E55 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r2E55);
                  /* IF CONDITION */
                  ir_expression *const r2E57 = equal(r2E4D, body.constant(0u));
                  ir_if *f2E56 = new(mem_ctx) ir_if(operand(r2E57).val);
                  exec_list *const f2E56_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2E56->then_instructions;

                     body.emit(assign(r2E54, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2E56->else_instructions;

                     body.emit(assign(r2E55, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2E59 = bit_and(r2E4D, body.constant(4294901760u));
                     ir_expression *const r2E5A = equal(r2E59, body.constant(0u));
                     ir_if *f2E58 = new(mem_ctx) ir_if(operand(r2E5A).val);
                     exec_list *const f2E58_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E58->then_instructions;

                        body.emit(assign(r2E55, body.constant(int(16)), 0x01));

                        body.emit(assign(r2E53, lshift(r2E4D, body.constant(int(16))), 0x01));


                     body.instructions = f2E58_parent_instructions;
                     body.emit(f2E58);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r2E5C = bit_and(r2E53, body.constant(4278190080u));
                     ir_expression *const r2E5D = equal(r2E5C, body.constant(0u));
                     ir_if *f2E5B = new(mem_ctx) ir_if(operand(r2E5D).val);
                     exec_list *const f2E5B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E5B->then_instructions;

                        body.emit(assign(r2E55, add(r2E55, body.constant(int(8))), 0x01));

                        body.emit(assign(r2E53, lshift(r2E53, body.constant(int(8))), 0x01));


                     body.instructions = f2E5B_parent_instructions;
                     body.emit(f2E5B);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r2E5F = bit_and(r2E53, body.constant(4026531840u));
                     ir_expression *const r2E60 = equal(r2E5F, body.constant(0u));
                     ir_if *f2E5E = new(mem_ctx) ir_if(operand(r2E60).val);
                     exec_list *const f2E5E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E5E->then_instructions;

                        body.emit(assign(r2E55, add(r2E55, body.constant(int(4))), 0x01));

                        body.emit(assign(r2E53, lshift(r2E53, body.constant(int(4))), 0x01));


                     body.instructions = f2E5E_parent_instructions;
                     body.emit(f2E5E);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r2E62 = bit_and(r2E53, body.constant(3221225472u));
                     ir_expression *const r2E63 = equal(r2E62, body.constant(0u));
                     ir_if *f2E61 = new(mem_ctx) ir_if(operand(r2E63).val);
                     exec_list *const f2E61_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E61->then_instructions;

                        body.emit(assign(r2E55, add(r2E55, body.constant(int(2))), 0x01));

                        body.emit(assign(r2E53, lshift(r2E53, body.constant(int(2))), 0x01));


                     body.instructions = f2E61_parent_instructions;
                     body.emit(f2E61);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r2E65 = bit_and(r2E53, body.constant(2147483648u));
                     ir_expression *const r2E66 = equal(r2E65, body.constant(0u));
                     ir_if *f2E64 = new(mem_ctx) ir_if(operand(r2E66).val);
                     exec_list *const f2E64_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E64->then_instructions;

                        body.emit(assign(r2E55, add(r2E55, body.constant(int(1))), 0x01));


                     body.instructions = f2E64_parent_instructions;
                     body.emit(f2E64);

                     /* END IF */

                     body.emit(assign(r2E54, r2E55, 0x01));


                  body.instructions = f2E56_parent_instructions;
                  body.emit(f2E56);

                  /* END IF */

                  body.emit(assign(r2E50, add(r2E54, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2E68 = lequal(body.constant(int(0)), r2E50);
                  ir_if *f2E67 = new(mem_ctx) ir_if(operand(r2E68).val);
                  exec_list *const f2E67_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2E67->then_instructions;

                     body.emit(assign(r2E4F, body.constant(0u), 0x01));

                     ir_variable *const r2E69 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r2E69, lshift(r2E4E, r2E50), 0x01));

                     ir_variable *const r2E6A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2E6C = equal(r2E50, body.constant(int(0)));
                     ir_if *f2E6B = new(mem_ctx) ir_if(operand(r2E6C).val);
                     exec_list *const f2E6B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E6B->then_instructions;

                        body.emit(assign(r2E6A, r2E4D, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2E6B->else_instructions;

                        ir_expression *const r2E6D = lshift(r2E4D, r2E50);
                        ir_expression *const r2E6E = neg(r2E50);
                        ir_expression *const r2E6F = bit_and(r2E6E, body.constant(int(31)));
                        ir_expression *const r2E70 = rshift(r2E4E, r2E6F);
                        body.emit(assign(r2E6A, bit_or(r2E6D, r2E70), 0x01));


                     body.instructions = f2E6B_parent_instructions;
                     body.emit(f2E6B);

                     /* END IF */

                     body.emit(assign(r2E4D, r2E6A, 0x01));

                     body.emit(assign(r2E4E, r2E69, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2E67->else_instructions;

                     ir_variable *const r2E71 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r2E71, body.constant(0u), 0x01));

                     ir_variable *const r2E72 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r2E72, neg(r2E50), 0x01));

                     ir_variable *const r2E73 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r2E73);
                     ir_variable *const r2E74 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r2E74);
                     ir_variable *const r2E75 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r2E75);
                     ir_variable *const r2E76 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r2E77 = neg(r2E72);
                     body.emit(assign(r2E76, bit_and(r2E77, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2E79 = equal(r2E72, body.constant(int(0)));
                     ir_if *f2E78 = new(mem_ctx) ir_if(operand(r2E79).val);
                     exec_list *const f2E78_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E78->then_instructions;

                        body.emit(assign(r2E73, r2E71, 0x01));

                        body.emit(assign(r2E74, r2E4E, 0x01));

                        body.emit(assign(r2E75, r2E4D, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2E78->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2E7B = less(r2E72, body.constant(int(32)));
                        ir_if *f2E7A = new(mem_ctx) ir_if(operand(r2E7B).val);
                        exec_list *const f2E7A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2E7A->then_instructions;

                           body.emit(assign(r2E73, lshift(r2E4E, r2E76), 0x01));

                           ir_expression *const r2E7C = lshift(r2E4D, r2E76);
                           ir_expression *const r2E7D = rshift(r2E4E, r2E72);
                           body.emit(assign(r2E74, bit_or(r2E7C, r2E7D), 0x01));

                           body.emit(assign(r2E75, rshift(r2E4D, r2E72), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2E7A->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2E7F = equal(r2E72, body.constant(int(32)));
                           ir_if *f2E7E = new(mem_ctx) ir_if(operand(r2E7F).val);
                           exec_list *const f2E7E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2E7E->then_instructions;

                              body.emit(assign(r2E73, r2E4E, 0x01));

                              body.emit(assign(r2E74, r2E4D, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2E7E->else_instructions;

                              body.emit(assign(r2E71, bit_or(body.constant(0u), r2E4E), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2E81 = less(r2E72, body.constant(int(64)));
                              ir_if *f2E80 = new(mem_ctx) ir_if(operand(r2E81).val);
                              exec_list *const f2E80_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2E80->then_instructions;

                                 body.emit(assign(r2E73, lshift(r2E4D, r2E76), 0x01));

                                 ir_expression *const r2E82 = bit_and(r2E72, body.constant(int(31)));
                                 body.emit(assign(r2E74, rshift(r2E4D, r2E82), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2E80->else_instructions;

                                 ir_variable *const r2E83 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2E85 = equal(r2E72, body.constant(int(64)));
                                 ir_if *f2E84 = new(mem_ctx) ir_if(operand(r2E85).val);
                                 exec_list *const f2E84_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2E84->then_instructions;

                                    body.emit(assign(r2E83, r2E4D, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2E84->else_instructions;

                                    ir_expression *const r2E86 = nequal(r2E4D, body.constant(0u));
                                    ir_expression *const r2E87 = expr(ir_unop_b2i, r2E86);
                                    body.emit(assign(r2E83, expr(ir_unop_i2u, r2E87), 0x01));


                                 body.instructions = f2E84_parent_instructions;
                                 body.emit(f2E84);

                                 /* END IF */

                                 body.emit(assign(r2E73, r2E83, 0x01));

                                 body.emit(assign(r2E74, body.constant(0u), 0x01));


                              body.instructions = f2E80_parent_instructions;
                              body.emit(f2E80);

                              /* END IF */


                           body.instructions = f2E7E_parent_instructions;
                           body.emit(f2E7E);

                           /* END IF */

                           body.emit(assign(r2E75, body.constant(0u), 0x01));


                        body.instructions = f2E7A_parent_instructions;
                        body.emit(f2E7A);

                        /* END IF */

                        ir_expression *const r2E88 = nequal(r2E71, body.constant(0u));
                        ir_expression *const r2E89 = expr(ir_unop_b2i, r2E88);
                        ir_expression *const r2E8A = expr(ir_unop_i2u, r2E89);
                        body.emit(assign(r2E73, bit_or(r2E73, r2E8A), 0x01));


                     body.instructions = f2E78_parent_instructions;
                     body.emit(f2E78);

                     /* END IF */

                     body.emit(assign(r2E4D, r2E75, 0x01));

                     body.emit(assign(r2E4E, r2E74, 0x01));

                     body.emit(assign(r2E4F, r2E73, 0x01));


                  body.instructions = f2E67_parent_instructions;
                  body.emit(f2E67);

                  /* END IF */

                  body.emit(assign(r2E4C, sub(r2E4C, r2E50), 0x01));

                  ir_variable *const r2E8B = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r2E8B, r2E4C, 0x01));

                  ir_variable *const r2E8C = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r2E8C, r2E4D, 0x01));

                  ir_variable *const r2E8D = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r2E8D, r2E4E, 0x01));

                  ir_variable *const r2E8E = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r2E8E, r2E4F, 0x01));

                  ir_variable *const r2E8F = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r2E8F, body.constant(true), 0x01));

                  ir_variable *const r2E90 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r2E91 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r2E91);
                  ir_expression *const r2E92 = expr(ir_unop_u2i, r2E4F);
                  body.emit(assign(r2E91, less(r2E92, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2E94 = lequal(body.constant(int(2045)), r2E4C);
                  ir_if *f2E93 = new(mem_ctx) ir_if(operand(r2E94).val);
                  exec_list *const f2E93_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2E93->then_instructions;

                     ir_variable *const r2E95 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2E97 = less(body.constant(int(2045)), r2E4C);
                     ir_if *f2E96 = new(mem_ctx) ir_if(operand(r2E97).val);
                     exec_list *const f2E96_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E96->then_instructions;

                        body.emit(assign(r2E95, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2E96->else_instructions;

                        ir_variable *const r2E98 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2E9A = equal(r2E4C, body.constant(int(2045)));
                        ir_if *f2E99 = new(mem_ctx) ir_if(operand(r2E9A).val);
                        exec_list *const f2E99_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2E99->then_instructions;

                           ir_expression *const r2E9B = equal(body.constant(2097151u), r2E4D);
                           ir_expression *const r2E9C = equal(body.constant(4294967295u), r2E4E);
                           body.emit(assign(r2E98, logic_and(r2E9B, r2E9C), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2E99->else_instructions;

                           body.emit(assign(r2E98, body.constant(false), 0x01));


                        body.instructions = f2E99_parent_instructions;
                        body.emit(f2E99);

                        /* END IF */

                        body.emit(assign(r2E95, logic_and(r2E98, r2E91), 0x01));


                     body.instructions = f2E96_parent_instructions;
                     body.emit(f2E96);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f2E9D = new(mem_ctx) ir_if(operand(r2E95).val);
                     exec_list *const f2E9D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E9D->then_instructions;

                        ir_variable *const r2E9E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r2E9E);
                        ir_expression *const r2E9F = lshift(r2C5F, body.constant(int(31)));
                        body.emit(assign(r2E9E, add(r2E9F, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r2E9E, body.constant(0u), 0x01));

                        body.emit(assign(r2E90, r2E9E, 0x03));

                        body.emit(assign(r2E8F, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2E9D->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2EA1 = less(r2E4C, body.constant(int(0)));
                        ir_if *f2EA0 = new(mem_ctx) ir_if(operand(r2EA1).val);
                        exec_list *const f2EA0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2EA0->then_instructions;

                           ir_variable *const r2EA2 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r2EA2, r2E4F, 0x01));

                           ir_variable *const r2EA3 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r2EA3, neg(r2E4C), 0x01));

                           ir_variable *const r2EA4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r2EA4);
                           ir_variable *const r2EA5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r2EA5);
                           ir_variable *const r2EA6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r2EA6);
                           ir_variable *const r2EA7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r2EA8 = neg(r2EA3);
                           body.emit(assign(r2EA7, bit_and(r2EA8, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2EAA = equal(r2EA3, body.constant(int(0)));
                           ir_if *f2EA9 = new(mem_ctx) ir_if(operand(r2EAA).val);
                           exec_list *const f2EA9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2EA9->then_instructions;

                              body.emit(assign(r2EA4, r2E4F, 0x01));

                              body.emit(assign(r2EA5, r2E4E, 0x01));

                              body.emit(assign(r2EA6, r2E4D, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2EA9->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2EAC = less(r2EA3, body.constant(int(32)));
                              ir_if *f2EAB = new(mem_ctx) ir_if(operand(r2EAC).val);
                              exec_list *const f2EAB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2EAB->then_instructions;

                                 body.emit(assign(r2EA4, lshift(r2E4E, r2EA7), 0x01));

                                 ir_expression *const r2EAD = lshift(r2E4D, r2EA7);
                                 ir_expression *const r2EAE = rshift(r2E4E, r2EA3);
                                 body.emit(assign(r2EA5, bit_or(r2EAD, r2EAE), 0x01));

                                 body.emit(assign(r2EA6, rshift(r2E4D, r2EA3), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2EAB->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2EB0 = equal(r2EA3, body.constant(int(32)));
                                 ir_if *f2EAF = new(mem_ctx) ir_if(operand(r2EB0).val);
                                 exec_list *const f2EAF_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2EAF->then_instructions;

                                    body.emit(assign(r2EA4, r2E4E, 0x01));

                                    body.emit(assign(r2EA5, r2E4D, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2EAF->else_instructions;

                                    body.emit(assign(r2EA2, bit_or(r2E4F, r2E4E), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r2EB2 = less(r2EA3, body.constant(int(64)));
                                    ir_if *f2EB1 = new(mem_ctx) ir_if(operand(r2EB2).val);
                                    exec_list *const f2EB1_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2EB1->then_instructions;

                                       body.emit(assign(r2EA4, lshift(r2E4D, r2EA7), 0x01));

                                       ir_expression *const r2EB3 = bit_and(r2EA3, body.constant(int(31)));
                                       body.emit(assign(r2EA5, rshift(r2E4D, r2EB3), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2EB1->else_instructions;

                                       ir_variable *const r2EB4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r2EB6 = equal(r2EA3, body.constant(int(64)));
                                       ir_if *f2EB5 = new(mem_ctx) ir_if(operand(r2EB6).val);
                                       exec_list *const f2EB5_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2EB5->then_instructions;

                                          body.emit(assign(r2EB4, r2E4D, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2EB5->else_instructions;

                                          ir_expression *const r2EB7 = nequal(r2E4D, body.constant(0u));
                                          ir_expression *const r2EB8 = expr(ir_unop_b2i, r2EB7);
                                          body.emit(assign(r2EB4, expr(ir_unop_i2u, r2EB8), 0x01));


                                       body.instructions = f2EB5_parent_instructions;
                                       body.emit(f2EB5);

                                       /* END IF */

                                       body.emit(assign(r2EA4, r2EB4, 0x01));

                                       body.emit(assign(r2EA5, body.constant(0u), 0x01));


                                    body.instructions = f2EB1_parent_instructions;
                                    body.emit(f2EB1);

                                    /* END IF */


                                 body.instructions = f2EAF_parent_instructions;
                                 body.emit(f2EAF);

                                 /* END IF */

                                 body.emit(assign(r2EA6, body.constant(0u), 0x01));


                              body.instructions = f2EAB_parent_instructions;
                              body.emit(f2EAB);

                              /* END IF */

                              ir_expression *const r2EB9 = nequal(r2EA2, body.constant(0u));
                              ir_expression *const r2EBA = expr(ir_unop_b2i, r2EB9);
                              ir_expression *const r2EBB = expr(ir_unop_i2u, r2EBA);
                              body.emit(assign(r2EA4, bit_or(r2EA4, r2EBB), 0x01));


                           body.instructions = f2EA9_parent_instructions;
                           body.emit(f2EA9);

                           /* END IF */

                           body.emit(assign(r2E8C, r2EA6, 0x01));

                           body.emit(assign(r2E8D, r2EA5, 0x01));

                           body.emit(assign(r2E8E, r2EA4, 0x01));

                           body.emit(assign(r2E8B, body.constant(int(0)), 0x01));

                           body.emit(assign(r2E91, less(r2EA4, body.constant(0u)), 0x01));


                        body.instructions = f2EA0_parent_instructions;
                        body.emit(f2EA0);

                        /* END IF */


                     body.instructions = f2E9D_parent_instructions;
                     body.emit(f2E9D);

                     /* END IF */


                  body.instructions = f2E93_parent_instructions;
                  body.emit(f2E93);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2EBC = new(mem_ctx) ir_if(operand(r2E8F).val);
                  exec_list *const f2EBC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2EBC->then_instructions;

                     /* IF CONDITION */
                     ir_if *f2EBD = new(mem_ctx) ir_if(operand(r2E91).val);
                     exec_list *const f2EBD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2EBD->then_instructions;

                        ir_variable *const r2EBE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r2EBE, add(r2E8D, body.constant(1u)), 0x01));

                        ir_expression *const r2EBF = less(r2EBE, r2E8D);
                        ir_expression *const r2EC0 = expr(ir_unop_b2i, r2EBF);
                        ir_expression *const r2EC1 = expr(ir_unop_i2u, r2EC0);
                        body.emit(assign(r2E8C, add(r2E8C, r2EC1), 0x01));

                        ir_expression *const r2EC2 = equal(r2E8E, body.constant(0u));
                        ir_expression *const r2EC3 = expr(ir_unop_b2i, r2EC2);
                        ir_expression *const r2EC4 = expr(ir_unop_i2u, r2EC3);
                        ir_expression *const r2EC5 = add(r2E8E, r2EC4);
                        ir_expression *const r2EC6 = bit_and(r2EC5, body.constant(1u));
                        ir_expression *const r2EC7 = expr(ir_unop_bit_not, r2EC6);
                        body.emit(assign(r2E8D, bit_and(r2EBE, r2EC7), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2EBD->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2EC9 = bit_or(r2E8C, r2E8D);
                        ir_expression *const r2ECA = equal(r2EC9, body.constant(0u));
                        ir_if *f2EC8 = new(mem_ctx) ir_if(operand(r2ECA).val);
                        exec_list *const f2EC8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2EC8->then_instructions;

                           body.emit(assign(r2E8B, body.constant(int(0)), 0x01));


                        body.instructions = f2EC8_parent_instructions;
                        body.emit(f2EC8);

                        /* END IF */


                     body.instructions = f2EBD_parent_instructions;
                     body.emit(f2EBD);

                     /* END IF */

                     ir_variable *const r2ECB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2ECB);
                     ir_expression *const r2ECC = lshift(r2C5F, body.constant(int(31)));
                     ir_expression *const r2ECD = expr(ir_unop_i2u, r2E8B);
                     ir_expression *const r2ECE = lshift(r2ECD, body.constant(int(20)));
                     ir_expression *const r2ECF = add(r2ECC, r2ECE);
                     body.emit(assign(r2ECB, add(r2ECF, r2E8C), 0x02));

                     body.emit(assign(r2ECB, r2E8D, 0x01));

                     body.emit(assign(r2E90, r2ECB, 0x03));

                     body.emit(assign(r2E8F, body.constant(false), 0x01));


                  body.instructions = f2EBC_parent_instructions;
                  body.emit(f2EBC);

                  /* END IF */

                  body.emit(assign(r2C60, r2E90, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2E44->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2ED1 = less(r2C66, r2C64);
                  ir_if *f2ED0 = new(mem_ctx) ir_if(operand(r2ED1).val);
                  exec_list *const f2ED0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2ED0->then_instructions;

                     ir_variable *const r2ED2 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r2ED3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r2ED3, sub(r2C65, r2C67), 0x01));

                     ir_expression *const r2ED4 = sub(r2C64, r2C66);
                     ir_expression *const r2ED5 = less(r2C65, r2C67);
                     ir_expression *const r2ED6 = expr(ir_unop_b2i, r2ED5);
                     ir_expression *const r2ED7 = expr(ir_unop_i2u, r2ED6);
                     body.emit(assign(r2ED2, sub(r2ED4, r2ED7), 0x01));

                     body.emit(assign(r2C5F, bit_xor(r2C5F, body.constant(1u)), 0x01));

                     body.emit(assign(r2C68, add(r2C62, body.constant(int(-1))), 0x01));

                     ir_variable *const r2ED8 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r2ED8, add(r2C68, body.constant(int(-10))), 0x01));

                     ir_variable *const r2ED9 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r2ED9, r2ED2, 0x01));

                     ir_variable *const r2EDA = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r2EDA, r2ED3, 0x01));

                     ir_variable *const r2EDB = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r2EDB);
                     ir_variable *const r2EDC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r2EDC);
                     /* IF CONDITION */
                     ir_expression *const r2EDE = equal(r2ED2, body.constant(0u));
                     ir_if *f2EDD = new(mem_ctx) ir_if(operand(r2EDE).val);
                     exec_list *const f2EDD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2EDD->then_instructions;

                        body.emit(assign(r2ED9, r2ED3, 0x01));

                        body.emit(assign(r2EDA, body.constant(0u), 0x01));

                        body.emit(assign(r2ED8, add(r2ED8, body.constant(int(-32))), 0x01));


                     body.instructions = f2EDD_parent_instructions;
                     body.emit(f2EDD);

                     /* END IF */

                     ir_variable *const r2EDF = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r2EDF, r2ED9, 0x01));

                     ir_variable *const r2EE0 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r2EE1 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r2EE1);
                     /* IF CONDITION */
                     ir_expression *const r2EE3 = equal(r2ED9, body.constant(0u));
                     ir_if *f2EE2 = new(mem_ctx) ir_if(operand(r2EE3).val);
                     exec_list *const f2EE2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2EE2->then_instructions;

                        body.emit(assign(r2EE0, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2EE2->else_instructions;

                        body.emit(assign(r2EE1, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2EE5 = bit_and(r2ED9, body.constant(4294901760u));
                        ir_expression *const r2EE6 = equal(r2EE5, body.constant(0u));
                        ir_if *f2EE4 = new(mem_ctx) ir_if(operand(r2EE6).val);
                        exec_list *const f2EE4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2EE4->then_instructions;

                           body.emit(assign(r2EE1, body.constant(int(16)), 0x01));

                           body.emit(assign(r2EDF, lshift(r2ED9, body.constant(int(16))), 0x01));


                        body.instructions = f2EE4_parent_instructions;
                        body.emit(f2EE4);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2EE8 = bit_and(r2EDF, body.constant(4278190080u));
                        ir_expression *const r2EE9 = equal(r2EE8, body.constant(0u));
                        ir_if *f2EE7 = new(mem_ctx) ir_if(operand(r2EE9).val);
                        exec_list *const f2EE7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2EE7->then_instructions;

                           body.emit(assign(r2EE1, add(r2EE1, body.constant(int(8))), 0x01));

                           body.emit(assign(r2EDF, lshift(r2EDF, body.constant(int(8))), 0x01));


                        body.instructions = f2EE7_parent_instructions;
                        body.emit(f2EE7);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2EEB = bit_and(r2EDF, body.constant(4026531840u));
                        ir_expression *const r2EEC = equal(r2EEB, body.constant(0u));
                        ir_if *f2EEA = new(mem_ctx) ir_if(operand(r2EEC).val);
                        exec_list *const f2EEA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2EEA->then_instructions;

                           body.emit(assign(r2EE1, add(r2EE1, body.constant(int(4))), 0x01));

                           body.emit(assign(r2EDF, lshift(r2EDF, body.constant(int(4))), 0x01));


                        body.instructions = f2EEA_parent_instructions;
                        body.emit(f2EEA);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2EEE = bit_and(r2EDF, body.constant(3221225472u));
                        ir_expression *const r2EEF = equal(r2EEE, body.constant(0u));
                        ir_if *f2EED = new(mem_ctx) ir_if(operand(r2EEF).val);
                        exec_list *const f2EED_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2EED->then_instructions;

                           body.emit(assign(r2EE1, add(r2EE1, body.constant(int(2))), 0x01));

                           body.emit(assign(r2EDF, lshift(r2EDF, body.constant(int(2))), 0x01));


                        body.instructions = f2EED_parent_instructions;
                        body.emit(f2EED);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2EF1 = bit_and(r2EDF, body.constant(2147483648u));
                        ir_expression *const r2EF2 = equal(r2EF1, body.constant(0u));
                        ir_if *f2EF0 = new(mem_ctx) ir_if(operand(r2EF2).val);
                        exec_list *const f2EF0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2EF0->then_instructions;

                           body.emit(assign(r2EE1, add(r2EE1, body.constant(int(1))), 0x01));


                        body.instructions = f2EF0_parent_instructions;
                        body.emit(f2EF0);

                        /* END IF */

                        body.emit(assign(r2EE0, r2EE1, 0x01));


                     body.instructions = f2EE2_parent_instructions;
                     body.emit(f2EE2);

                     /* END IF */

                     body.emit(assign(r2EDC, add(r2EE0, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2EF4 = lequal(body.constant(int(0)), r2EDC);
                     ir_if *f2EF3 = new(mem_ctx) ir_if(operand(r2EF4).val);
                     exec_list *const f2EF3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2EF3->then_instructions;

                        body.emit(assign(r2EDB, body.constant(0u), 0x01));

                        ir_variable *const r2EF5 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r2EF5, lshift(r2EDA, r2EDC), 0x01));

                        ir_variable *const r2EF6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2EF8 = equal(r2EDC, body.constant(int(0)));
                        ir_if *f2EF7 = new(mem_ctx) ir_if(operand(r2EF8).val);
                        exec_list *const f2EF7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2EF7->then_instructions;

                           body.emit(assign(r2EF6, r2ED9, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2EF7->else_instructions;

                           ir_expression *const r2EF9 = lshift(r2ED9, r2EDC);
                           ir_expression *const r2EFA = neg(r2EDC);
                           ir_expression *const r2EFB = bit_and(r2EFA, body.constant(int(31)));
                           ir_expression *const r2EFC = rshift(r2EDA, r2EFB);
                           body.emit(assign(r2EF6, bit_or(r2EF9, r2EFC), 0x01));


                        body.instructions = f2EF7_parent_instructions;
                        body.emit(f2EF7);

                        /* END IF */

                        body.emit(assign(r2ED9, r2EF6, 0x01));

                        body.emit(assign(r2EDA, r2EF5, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2EF3->else_instructions;

                        ir_variable *const r2EFD = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2EFD, body.constant(0u), 0x01));

                        ir_variable *const r2EFE = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2EFE, neg(r2EDC), 0x01));

                        ir_variable *const r2EFF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2EFF);
                        ir_variable *const r2F00 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2F00);
                        ir_variable *const r2F01 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2F01);
                        ir_variable *const r2F02 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2F03 = neg(r2EFE);
                        body.emit(assign(r2F02, bit_and(r2F03, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2F05 = equal(r2EFE, body.constant(int(0)));
                        ir_if *f2F04 = new(mem_ctx) ir_if(operand(r2F05).val);
                        exec_list *const f2F04_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2F04->then_instructions;

                           body.emit(assign(r2EFF, r2EFD, 0x01));

                           body.emit(assign(r2F00, r2EDA, 0x01));

                           body.emit(assign(r2F01, r2ED9, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2F04->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2F07 = less(r2EFE, body.constant(int(32)));
                           ir_if *f2F06 = new(mem_ctx) ir_if(operand(r2F07).val);
                           exec_list *const f2F06_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2F06->then_instructions;

                              body.emit(assign(r2EFF, lshift(r2EDA, r2F02), 0x01));

                              ir_expression *const r2F08 = lshift(r2ED9, r2F02);
                              ir_expression *const r2F09 = rshift(r2EDA, r2EFE);
                              body.emit(assign(r2F00, bit_or(r2F08, r2F09), 0x01));

                              body.emit(assign(r2F01, rshift(r2ED9, r2EFE), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2F06->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2F0B = equal(r2EFE, body.constant(int(32)));
                              ir_if *f2F0A = new(mem_ctx) ir_if(operand(r2F0B).val);
                              exec_list *const f2F0A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2F0A->then_instructions;

                                 body.emit(assign(r2EFF, r2EDA, 0x01));

                                 body.emit(assign(r2F00, r2ED9, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2F0A->else_instructions;

                                 body.emit(assign(r2EFD, bit_or(body.constant(0u), r2EDA), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2F0D = less(r2EFE, body.constant(int(64)));
                                 ir_if *f2F0C = new(mem_ctx) ir_if(operand(r2F0D).val);
                                 exec_list *const f2F0C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2F0C->then_instructions;

                                    body.emit(assign(r2EFF, lshift(r2ED9, r2F02), 0x01));

                                    ir_expression *const r2F0E = bit_and(r2EFE, body.constant(int(31)));
                                    body.emit(assign(r2F00, rshift(r2ED9, r2F0E), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2F0C->else_instructions;

                                    ir_variable *const r2F0F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2F11 = equal(r2EFE, body.constant(int(64)));
                                    ir_if *f2F10 = new(mem_ctx) ir_if(operand(r2F11).val);
                                    exec_list *const f2F10_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2F10->then_instructions;

                                       body.emit(assign(r2F0F, r2ED9, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2F10->else_instructions;

                                       ir_expression *const r2F12 = nequal(r2ED9, body.constant(0u));
                                       ir_expression *const r2F13 = expr(ir_unop_b2i, r2F12);
                                       body.emit(assign(r2F0F, expr(ir_unop_i2u, r2F13), 0x01));


                                    body.instructions = f2F10_parent_instructions;
                                    body.emit(f2F10);

                                    /* END IF */

                                    body.emit(assign(r2EFF, r2F0F, 0x01));

                                    body.emit(assign(r2F00, body.constant(0u), 0x01));


                                 body.instructions = f2F0C_parent_instructions;
                                 body.emit(f2F0C);

                                 /* END IF */


                              body.instructions = f2F0A_parent_instructions;
                              body.emit(f2F0A);

                              /* END IF */

                              body.emit(assign(r2F01, body.constant(0u), 0x01));


                           body.instructions = f2F06_parent_instructions;
                           body.emit(f2F06);

                           /* END IF */

                           ir_expression *const r2F14 = nequal(r2EFD, body.constant(0u));
                           ir_expression *const r2F15 = expr(ir_unop_b2i, r2F14);
                           ir_expression *const r2F16 = expr(ir_unop_i2u, r2F15);
                           body.emit(assign(r2EFF, bit_or(r2EFF, r2F16), 0x01));


                        body.instructions = f2F04_parent_instructions;
                        body.emit(f2F04);

                        /* END IF */

                        body.emit(assign(r2ED9, r2F01, 0x01));

                        body.emit(assign(r2EDA, r2F00, 0x01));

                        body.emit(assign(r2EDB, r2EFF, 0x01));


                     body.instructions = f2EF3_parent_instructions;
                     body.emit(f2EF3);

                     /* END IF */

                     body.emit(assign(r2ED8, sub(r2ED8, r2EDC), 0x01));

                     ir_variable *const r2F17 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r2F17, r2ED8, 0x01));

                     ir_variable *const r2F18 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r2F18, r2ED9, 0x01));

                     ir_variable *const r2F19 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r2F19, r2EDA, 0x01));

                     ir_variable *const r2F1A = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r2F1A, r2EDB, 0x01));

                     ir_variable *const r2F1B = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r2F1B, body.constant(true), 0x01));

                     ir_variable *const r2F1C = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r2F1D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r2F1D);
                     ir_expression *const r2F1E = expr(ir_unop_u2i, r2EDB);
                     body.emit(assign(r2F1D, less(r2F1E, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2F20 = lequal(body.constant(int(2045)), r2ED8);
                     ir_if *f2F1F = new(mem_ctx) ir_if(operand(r2F20).val);
                     exec_list *const f2F1F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2F1F->then_instructions;

                        ir_variable *const r2F21 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2F23 = less(body.constant(int(2045)), r2ED8);
                        ir_if *f2F22 = new(mem_ctx) ir_if(operand(r2F23).val);
                        exec_list *const f2F22_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2F22->then_instructions;

                           body.emit(assign(r2F21, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2F22->else_instructions;

                           ir_variable *const r2F24 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2F26 = equal(r2ED8, body.constant(int(2045)));
                           ir_if *f2F25 = new(mem_ctx) ir_if(operand(r2F26).val);
                           exec_list *const f2F25_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2F25->then_instructions;

                              ir_expression *const r2F27 = equal(body.constant(2097151u), r2ED9);
                              ir_expression *const r2F28 = equal(body.constant(4294967295u), r2EDA);
                              body.emit(assign(r2F24, logic_and(r2F27, r2F28), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2F25->else_instructions;

                              body.emit(assign(r2F24, body.constant(false), 0x01));


                           body.instructions = f2F25_parent_instructions;
                           body.emit(f2F25);

                           /* END IF */

                           body.emit(assign(r2F21, logic_and(r2F24, r2F1D), 0x01));


                        body.instructions = f2F22_parent_instructions;
                        body.emit(f2F22);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f2F29 = new(mem_ctx) ir_if(operand(r2F21).val);
                        exec_list *const f2F29_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2F29->then_instructions;

                           ir_variable *const r2F2A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r2F2A);
                           ir_expression *const r2F2B = lshift(r2C5F, body.constant(int(31)));
                           body.emit(assign(r2F2A, add(r2F2B, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r2F2A, body.constant(0u), 0x01));

                           body.emit(assign(r2F1C, r2F2A, 0x03));

                           body.emit(assign(r2F1B, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2F29->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2F2D = less(r2ED8, body.constant(int(0)));
                           ir_if *f2F2C = new(mem_ctx) ir_if(operand(r2F2D).val);
                           exec_list *const f2F2C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2F2C->then_instructions;

                              ir_variable *const r2F2E = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r2F2E, r2EDB, 0x01));

                              ir_variable *const r2F2F = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r2F2F, neg(r2ED8), 0x01));

                              ir_variable *const r2F30 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r2F30);
                              ir_variable *const r2F31 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r2F31);
                              ir_variable *const r2F32 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r2F32);
                              ir_variable *const r2F33 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r2F34 = neg(r2F2F);
                              body.emit(assign(r2F33, bit_and(r2F34, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2F36 = equal(r2F2F, body.constant(int(0)));
                              ir_if *f2F35 = new(mem_ctx) ir_if(operand(r2F36).val);
                              exec_list *const f2F35_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2F35->then_instructions;

                                 body.emit(assign(r2F30, r2EDB, 0x01));

                                 body.emit(assign(r2F31, r2EDA, 0x01));

                                 body.emit(assign(r2F32, r2ED9, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2F35->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2F38 = less(r2F2F, body.constant(int(32)));
                                 ir_if *f2F37 = new(mem_ctx) ir_if(operand(r2F38).val);
                                 exec_list *const f2F37_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2F37->then_instructions;

                                    body.emit(assign(r2F30, lshift(r2EDA, r2F33), 0x01));

                                    ir_expression *const r2F39 = lshift(r2ED9, r2F33);
                                    ir_expression *const r2F3A = rshift(r2EDA, r2F2F);
                                    body.emit(assign(r2F31, bit_or(r2F39, r2F3A), 0x01));

                                    body.emit(assign(r2F32, rshift(r2ED9, r2F2F), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2F37->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2F3C = equal(r2F2F, body.constant(int(32)));
                                    ir_if *f2F3B = new(mem_ctx) ir_if(operand(r2F3C).val);
                                    exec_list *const f2F3B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2F3B->then_instructions;

                                       body.emit(assign(r2F30, r2EDA, 0x01));

                                       body.emit(assign(r2F31, r2ED9, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2F3B->else_instructions;

                                       body.emit(assign(r2F2E, bit_or(r2EDB, r2EDA), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2F3E = less(r2F2F, body.constant(int(64)));
                                       ir_if *f2F3D = new(mem_ctx) ir_if(operand(r2F3E).val);
                                       exec_list *const f2F3D_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2F3D->then_instructions;

                                          body.emit(assign(r2F30, lshift(r2ED9, r2F33), 0x01));

                                          ir_expression *const r2F3F = bit_and(r2F2F, body.constant(int(31)));
                                          body.emit(assign(r2F31, rshift(r2ED9, r2F3F), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2F3D->else_instructions;

                                          ir_variable *const r2F40 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r2F42 = equal(r2F2F, body.constant(int(64)));
                                          ir_if *f2F41 = new(mem_ctx) ir_if(operand(r2F42).val);
                                          exec_list *const f2F41_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2F41->then_instructions;

                                             body.emit(assign(r2F40, r2ED9, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2F41->else_instructions;

                                             ir_expression *const r2F43 = nequal(r2ED9, body.constant(0u));
                                             ir_expression *const r2F44 = expr(ir_unop_b2i, r2F43);
                                             body.emit(assign(r2F40, expr(ir_unop_i2u, r2F44), 0x01));


                                          body.instructions = f2F41_parent_instructions;
                                          body.emit(f2F41);

                                          /* END IF */

                                          body.emit(assign(r2F30, r2F40, 0x01));

                                          body.emit(assign(r2F31, body.constant(0u), 0x01));


                                       body.instructions = f2F3D_parent_instructions;
                                       body.emit(f2F3D);

                                       /* END IF */


                                    body.instructions = f2F3B_parent_instructions;
                                    body.emit(f2F3B);

                                    /* END IF */

                                    body.emit(assign(r2F32, body.constant(0u), 0x01));


                                 body.instructions = f2F37_parent_instructions;
                                 body.emit(f2F37);

                                 /* END IF */

                                 ir_expression *const r2F45 = nequal(r2F2E, body.constant(0u));
                                 ir_expression *const r2F46 = expr(ir_unop_b2i, r2F45);
                                 ir_expression *const r2F47 = expr(ir_unop_i2u, r2F46);
                                 body.emit(assign(r2F30, bit_or(r2F30, r2F47), 0x01));


                              body.instructions = f2F35_parent_instructions;
                              body.emit(f2F35);

                              /* END IF */

                              body.emit(assign(r2F18, r2F32, 0x01));

                              body.emit(assign(r2F19, r2F31, 0x01));

                              body.emit(assign(r2F1A, r2F30, 0x01));

                              body.emit(assign(r2F17, body.constant(int(0)), 0x01));

                              body.emit(assign(r2F1D, less(r2F30, body.constant(0u)), 0x01));


                           body.instructions = f2F2C_parent_instructions;
                           body.emit(f2F2C);

                           /* END IF */


                        body.instructions = f2F29_parent_instructions;
                        body.emit(f2F29);

                        /* END IF */


                     body.instructions = f2F1F_parent_instructions;
                     body.emit(f2F1F);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f2F48 = new(mem_ctx) ir_if(operand(r2F1B).val);
                     exec_list *const f2F48_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2F48->then_instructions;

                        /* IF CONDITION */
                        ir_if *f2F49 = new(mem_ctx) ir_if(operand(r2F1D).val);
                        exec_list *const f2F49_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2F49->then_instructions;

                           ir_variable *const r2F4A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r2F4A, add(r2F19, body.constant(1u)), 0x01));

                           ir_expression *const r2F4B = less(r2F4A, r2F19);
                           ir_expression *const r2F4C = expr(ir_unop_b2i, r2F4B);
                           ir_expression *const r2F4D = expr(ir_unop_i2u, r2F4C);
                           body.emit(assign(r2F18, add(r2F18, r2F4D), 0x01));

                           ir_expression *const r2F4E = equal(r2F1A, body.constant(0u));
                           ir_expression *const r2F4F = expr(ir_unop_b2i, r2F4E);
                           ir_expression *const r2F50 = expr(ir_unop_i2u, r2F4F);
                           ir_expression *const r2F51 = add(r2F1A, r2F50);
                           ir_expression *const r2F52 = bit_and(r2F51, body.constant(1u));
                           ir_expression *const r2F53 = expr(ir_unop_bit_not, r2F52);
                           body.emit(assign(r2F19, bit_and(r2F4A, r2F53), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2F49->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2F55 = bit_or(r2F18, r2F19);
                           ir_expression *const r2F56 = equal(r2F55, body.constant(0u));
                           ir_if *f2F54 = new(mem_ctx) ir_if(operand(r2F56).val);
                           exec_list *const f2F54_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2F54->then_instructions;

                              body.emit(assign(r2F17, body.constant(int(0)), 0x01));


                           body.instructions = f2F54_parent_instructions;
                           body.emit(f2F54);

                           /* END IF */


                        body.instructions = f2F49_parent_instructions;
                        body.emit(f2F49);

                        /* END IF */

                        ir_variable *const r2F57 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r2F57);
                        ir_expression *const r2F58 = lshift(r2C5F, body.constant(int(31)));
                        ir_expression *const r2F59 = expr(ir_unop_i2u, r2F17);
                        ir_expression *const r2F5A = lshift(r2F59, body.constant(int(20)));
                        ir_expression *const r2F5B = add(r2F58, r2F5A);
                        body.emit(assign(r2F57, add(r2F5B, r2F18), 0x02));

                        body.emit(assign(r2F57, r2F19, 0x01));

                        body.emit(assign(r2F1C, r2F57, 0x03));

                        body.emit(assign(r2F1B, body.constant(false), 0x01));


                     body.instructions = f2F48_parent_instructions;
                     body.emit(f2F48);

                     /* END IF */

                     body.emit(assign(r2C60, r2F1C, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2ED0->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2F5D = less(r2C65, r2C67);
                     ir_if *f2F5C = new(mem_ctx) ir_if(operand(r2F5D).val);
                     exec_list *const f2F5C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2F5C->then_instructions;

                        ir_variable *const r2F5E = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r2F5F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r2F5F, sub(r2C67, r2C65), 0x01));

                        ir_expression *const r2F60 = sub(r2C66, r2C64);
                        ir_expression *const r2F61 = less(r2C67, r2C65);
                        ir_expression *const r2F62 = expr(ir_unop_b2i, r2F61);
                        ir_expression *const r2F63 = expr(ir_unop_i2u, r2F62);
                        body.emit(assign(r2F5E, sub(r2F60, r2F63), 0x01));

                        body.emit(assign(r2C68, add(r2C63, body.constant(int(-1))), 0x01));

                        ir_variable *const r2F64 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r2F64, add(r2C68, body.constant(int(-10))), 0x01));

                        ir_variable *const r2F65 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r2F65, r2F5E, 0x01));

                        ir_variable *const r2F66 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r2F66, r2F5F, 0x01));

                        ir_variable *const r2F67 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r2F67);
                        ir_variable *const r2F68 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r2F68);
                        /* IF CONDITION */
                        ir_expression *const r2F6A = equal(r2F5E, body.constant(0u));
                        ir_if *f2F69 = new(mem_ctx) ir_if(operand(r2F6A).val);
                        exec_list *const f2F69_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2F69->then_instructions;

                           body.emit(assign(r2F65, r2F5F, 0x01));

                           body.emit(assign(r2F66, body.constant(0u), 0x01));

                           body.emit(assign(r2F64, add(r2F64, body.constant(int(-32))), 0x01));


                        body.instructions = f2F69_parent_instructions;
                        body.emit(f2F69);

                        /* END IF */

                        ir_variable *const r2F6B = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r2F6B, r2F65, 0x01));

                        ir_variable *const r2F6C = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r2F6D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r2F6D);
                        /* IF CONDITION */
                        ir_expression *const r2F6F = equal(r2F65, body.constant(0u));
                        ir_if *f2F6E = new(mem_ctx) ir_if(operand(r2F6F).val);
                        exec_list *const f2F6E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2F6E->then_instructions;

                           body.emit(assign(r2F6C, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2F6E->else_instructions;

                           body.emit(assign(r2F6D, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2F71 = bit_and(r2F65, body.constant(4294901760u));
                           ir_expression *const r2F72 = equal(r2F71, body.constant(0u));
                           ir_if *f2F70 = new(mem_ctx) ir_if(operand(r2F72).val);
                           exec_list *const f2F70_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2F70->then_instructions;

                              body.emit(assign(r2F6D, body.constant(int(16)), 0x01));

                              body.emit(assign(r2F6B, lshift(r2F65, body.constant(int(16))), 0x01));


                           body.instructions = f2F70_parent_instructions;
                           body.emit(f2F70);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2F74 = bit_and(r2F6B, body.constant(4278190080u));
                           ir_expression *const r2F75 = equal(r2F74, body.constant(0u));
                           ir_if *f2F73 = new(mem_ctx) ir_if(operand(r2F75).val);
                           exec_list *const f2F73_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2F73->then_instructions;

                              body.emit(assign(r2F6D, add(r2F6D, body.constant(int(8))), 0x01));

                              body.emit(assign(r2F6B, lshift(r2F6B, body.constant(int(8))), 0x01));


                           body.instructions = f2F73_parent_instructions;
                           body.emit(f2F73);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2F77 = bit_and(r2F6B, body.constant(4026531840u));
                           ir_expression *const r2F78 = equal(r2F77, body.constant(0u));
                           ir_if *f2F76 = new(mem_ctx) ir_if(operand(r2F78).val);
                           exec_list *const f2F76_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2F76->then_instructions;

                              body.emit(assign(r2F6D, add(r2F6D, body.constant(int(4))), 0x01));

                              body.emit(assign(r2F6B, lshift(r2F6B, body.constant(int(4))), 0x01));


                           body.instructions = f2F76_parent_instructions;
                           body.emit(f2F76);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2F7A = bit_and(r2F6B, body.constant(3221225472u));
                           ir_expression *const r2F7B = equal(r2F7A, body.constant(0u));
                           ir_if *f2F79 = new(mem_ctx) ir_if(operand(r2F7B).val);
                           exec_list *const f2F79_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2F79->then_instructions;

                              body.emit(assign(r2F6D, add(r2F6D, body.constant(int(2))), 0x01));

                              body.emit(assign(r2F6B, lshift(r2F6B, body.constant(int(2))), 0x01));


                           body.instructions = f2F79_parent_instructions;
                           body.emit(f2F79);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2F7D = bit_and(r2F6B, body.constant(2147483648u));
                           ir_expression *const r2F7E = equal(r2F7D, body.constant(0u));
                           ir_if *f2F7C = new(mem_ctx) ir_if(operand(r2F7E).val);
                           exec_list *const f2F7C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2F7C->then_instructions;

                              body.emit(assign(r2F6D, add(r2F6D, body.constant(int(1))), 0x01));


                           body.instructions = f2F7C_parent_instructions;
                           body.emit(f2F7C);

                           /* END IF */

                           body.emit(assign(r2F6C, r2F6D, 0x01));


                        body.instructions = f2F6E_parent_instructions;
                        body.emit(f2F6E);

                        /* END IF */

                        body.emit(assign(r2F68, add(r2F6C, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2F80 = lequal(body.constant(int(0)), r2F68);
                        ir_if *f2F7F = new(mem_ctx) ir_if(operand(r2F80).val);
                        exec_list *const f2F7F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2F7F->then_instructions;

                           body.emit(assign(r2F67, body.constant(0u), 0x01));

                           ir_variable *const r2F81 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r2F81, lshift(r2F66, r2F68), 0x01));

                           ir_variable *const r2F82 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2F84 = equal(r2F68, body.constant(int(0)));
                           ir_if *f2F83 = new(mem_ctx) ir_if(operand(r2F84).val);
                           exec_list *const f2F83_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2F83->then_instructions;

                              body.emit(assign(r2F82, r2F65, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2F83->else_instructions;

                              ir_expression *const r2F85 = lshift(r2F65, r2F68);
                              ir_expression *const r2F86 = neg(r2F68);
                              ir_expression *const r2F87 = bit_and(r2F86, body.constant(int(31)));
                              ir_expression *const r2F88 = rshift(r2F66, r2F87);
                              body.emit(assign(r2F82, bit_or(r2F85, r2F88), 0x01));


                           body.instructions = f2F83_parent_instructions;
                           body.emit(f2F83);

                           /* END IF */

                           body.emit(assign(r2F65, r2F82, 0x01));

                           body.emit(assign(r2F66, r2F81, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2F7F->else_instructions;

                           ir_variable *const r2F89 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r2F89, body.constant(0u), 0x01));

                           ir_variable *const r2F8A = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r2F8A, neg(r2F68), 0x01));

                           ir_variable *const r2F8B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r2F8B);
                           ir_variable *const r2F8C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r2F8C);
                           ir_variable *const r2F8D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r2F8D);
                           ir_variable *const r2F8E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r2F8F = neg(r2F8A);
                           body.emit(assign(r2F8E, bit_and(r2F8F, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2F91 = equal(r2F8A, body.constant(int(0)));
                           ir_if *f2F90 = new(mem_ctx) ir_if(operand(r2F91).val);
                           exec_list *const f2F90_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2F90->then_instructions;

                              body.emit(assign(r2F8B, r2F89, 0x01));

                              body.emit(assign(r2F8C, r2F66, 0x01));

                              body.emit(assign(r2F8D, r2F65, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2F90->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2F93 = less(r2F8A, body.constant(int(32)));
                              ir_if *f2F92 = new(mem_ctx) ir_if(operand(r2F93).val);
                              exec_list *const f2F92_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2F92->then_instructions;

                                 body.emit(assign(r2F8B, lshift(r2F66, r2F8E), 0x01));

                                 ir_expression *const r2F94 = lshift(r2F65, r2F8E);
                                 ir_expression *const r2F95 = rshift(r2F66, r2F8A);
                                 body.emit(assign(r2F8C, bit_or(r2F94, r2F95), 0x01));

                                 body.emit(assign(r2F8D, rshift(r2F65, r2F8A), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2F92->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2F97 = equal(r2F8A, body.constant(int(32)));
                                 ir_if *f2F96 = new(mem_ctx) ir_if(operand(r2F97).val);
                                 exec_list *const f2F96_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2F96->then_instructions;

                                    body.emit(assign(r2F8B, r2F66, 0x01));

                                    body.emit(assign(r2F8C, r2F65, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2F96->else_instructions;

                                    body.emit(assign(r2F89, bit_or(body.constant(0u), r2F66), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r2F99 = less(r2F8A, body.constant(int(64)));
                                    ir_if *f2F98 = new(mem_ctx) ir_if(operand(r2F99).val);
                                    exec_list *const f2F98_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2F98->then_instructions;

                                       body.emit(assign(r2F8B, lshift(r2F65, r2F8E), 0x01));

                                       ir_expression *const r2F9A = bit_and(r2F8A, body.constant(int(31)));
                                       body.emit(assign(r2F8C, rshift(r2F65, r2F9A), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2F98->else_instructions;

                                       ir_variable *const r2F9B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r2F9D = equal(r2F8A, body.constant(int(64)));
                                       ir_if *f2F9C = new(mem_ctx) ir_if(operand(r2F9D).val);
                                       exec_list *const f2F9C_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2F9C->then_instructions;

                                          body.emit(assign(r2F9B, r2F65, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2F9C->else_instructions;

                                          ir_expression *const r2F9E = nequal(r2F65, body.constant(0u));
                                          ir_expression *const r2F9F = expr(ir_unop_b2i, r2F9E);
                                          body.emit(assign(r2F9B, expr(ir_unop_i2u, r2F9F), 0x01));


                                       body.instructions = f2F9C_parent_instructions;
                                       body.emit(f2F9C);

                                       /* END IF */

                                       body.emit(assign(r2F8B, r2F9B, 0x01));

                                       body.emit(assign(r2F8C, body.constant(0u), 0x01));


                                    body.instructions = f2F98_parent_instructions;
                                    body.emit(f2F98);

                                    /* END IF */


                                 body.instructions = f2F96_parent_instructions;
                                 body.emit(f2F96);

                                 /* END IF */

                                 body.emit(assign(r2F8D, body.constant(0u), 0x01));


                              body.instructions = f2F92_parent_instructions;
                              body.emit(f2F92);

                              /* END IF */

                              ir_expression *const r2FA0 = nequal(r2F89, body.constant(0u));
                              ir_expression *const r2FA1 = expr(ir_unop_b2i, r2FA0);
                              ir_expression *const r2FA2 = expr(ir_unop_i2u, r2FA1);
                              body.emit(assign(r2F8B, bit_or(r2F8B, r2FA2), 0x01));


                           body.instructions = f2F90_parent_instructions;
                           body.emit(f2F90);

                           /* END IF */

                           body.emit(assign(r2F65, r2F8D, 0x01));

                           body.emit(assign(r2F66, r2F8C, 0x01));

                           body.emit(assign(r2F67, r2F8B, 0x01));


                        body.instructions = f2F7F_parent_instructions;
                        body.emit(f2F7F);

                        /* END IF */

                        body.emit(assign(r2F64, sub(r2F64, r2F68), 0x01));

                        ir_variable *const r2FA3 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r2FA3, r2F64, 0x01));

                        ir_variable *const r2FA4 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r2FA4, r2F65, 0x01));

                        ir_variable *const r2FA5 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r2FA5, r2F66, 0x01));

                        ir_variable *const r2FA6 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r2FA6, r2F67, 0x01));

                        ir_variable *const r2FA7 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r2FA7, body.constant(true), 0x01));

                        ir_variable *const r2FA8 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r2FA9 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r2FA9);
                        ir_expression *const r2FAA = expr(ir_unop_u2i, r2F67);
                        body.emit(assign(r2FA9, less(r2FAA, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2FAC = lequal(body.constant(int(2045)), r2F64);
                        ir_if *f2FAB = new(mem_ctx) ir_if(operand(r2FAC).val);
                        exec_list *const f2FAB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2FAB->then_instructions;

                           ir_variable *const r2FAD = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2FAF = less(body.constant(int(2045)), r2F64);
                           ir_if *f2FAE = new(mem_ctx) ir_if(operand(r2FAF).val);
                           exec_list *const f2FAE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2FAE->then_instructions;

                              body.emit(assign(r2FAD, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2FAE->else_instructions;

                              ir_variable *const r2FB0 = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2FB2 = equal(r2F64, body.constant(int(2045)));
                              ir_if *f2FB1 = new(mem_ctx) ir_if(operand(r2FB2).val);
                              exec_list *const f2FB1_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2FB1->then_instructions;

                                 ir_expression *const r2FB3 = equal(body.constant(2097151u), r2F65);
                                 ir_expression *const r2FB4 = equal(body.constant(4294967295u), r2F66);
                                 body.emit(assign(r2FB0, logic_and(r2FB3, r2FB4), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2FB1->else_instructions;

                                 body.emit(assign(r2FB0, body.constant(false), 0x01));


                              body.instructions = f2FB1_parent_instructions;
                              body.emit(f2FB1);

                              /* END IF */

                              body.emit(assign(r2FAD, logic_and(r2FB0, r2FA9), 0x01));


                           body.instructions = f2FAE_parent_instructions;
                           body.emit(f2FAE);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f2FB5 = new(mem_ctx) ir_if(operand(r2FAD).val);
                           exec_list *const f2FB5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2FB5->then_instructions;

                              ir_variable *const r2FB6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r2FB6);
                              ir_expression *const r2FB7 = lshift(r2C5F, body.constant(int(31)));
                              body.emit(assign(r2FB6, add(r2FB7, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r2FB6, body.constant(0u), 0x01));

                              body.emit(assign(r2FA8, r2FB6, 0x03));

                              body.emit(assign(r2FA7, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2FB5->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2FB9 = less(r2F64, body.constant(int(0)));
                              ir_if *f2FB8 = new(mem_ctx) ir_if(operand(r2FB9).val);
                              exec_list *const f2FB8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2FB8->then_instructions;

                                 ir_variable *const r2FBA = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r2FBA, r2F67, 0x01));

                                 ir_variable *const r2FBB = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r2FBB, neg(r2F64), 0x01));

                                 ir_variable *const r2FBC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r2FBC);
                                 ir_variable *const r2FBD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r2FBD);
                                 ir_variable *const r2FBE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r2FBE);
                                 ir_variable *const r2FBF = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r2FC0 = neg(r2FBB);
                                 body.emit(assign(r2FBF, bit_and(r2FC0, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2FC2 = equal(r2FBB, body.constant(int(0)));
                                 ir_if *f2FC1 = new(mem_ctx) ir_if(operand(r2FC2).val);
                                 exec_list *const f2FC1_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2FC1->then_instructions;

                                    body.emit(assign(r2FBC, r2F67, 0x01));

                                    body.emit(assign(r2FBD, r2F66, 0x01));

                                    body.emit(assign(r2FBE, r2F65, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2FC1->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2FC4 = less(r2FBB, body.constant(int(32)));
                                    ir_if *f2FC3 = new(mem_ctx) ir_if(operand(r2FC4).val);
                                    exec_list *const f2FC3_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2FC3->then_instructions;

                                       body.emit(assign(r2FBC, lshift(r2F66, r2FBF), 0x01));

                                       ir_expression *const r2FC5 = lshift(r2F65, r2FBF);
                                       ir_expression *const r2FC6 = rshift(r2F66, r2FBB);
                                       body.emit(assign(r2FBD, bit_or(r2FC5, r2FC6), 0x01));

                                       body.emit(assign(r2FBE, rshift(r2F65, r2FBB), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2FC3->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r2FC8 = equal(r2FBB, body.constant(int(32)));
                                       ir_if *f2FC7 = new(mem_ctx) ir_if(operand(r2FC8).val);
                                       exec_list *const f2FC7_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2FC7->then_instructions;

                                          body.emit(assign(r2FBC, r2F66, 0x01));

                                          body.emit(assign(r2FBD, r2F65, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2FC7->else_instructions;

                                          body.emit(assign(r2FBA, bit_or(r2F67, r2F66), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r2FCA = less(r2FBB, body.constant(int(64)));
                                          ir_if *f2FC9 = new(mem_ctx) ir_if(operand(r2FCA).val);
                                          exec_list *const f2FC9_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2FC9->then_instructions;

                                             body.emit(assign(r2FBC, lshift(r2F65, r2FBF), 0x01));

                                             ir_expression *const r2FCB = bit_and(r2FBB, body.constant(int(31)));
                                             body.emit(assign(r2FBD, rshift(r2F65, r2FCB), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2FC9->else_instructions;

                                             ir_variable *const r2FCC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r2FCE = equal(r2FBB, body.constant(int(64)));
                                             ir_if *f2FCD = new(mem_ctx) ir_if(operand(r2FCE).val);
                                             exec_list *const f2FCD_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2FCD->then_instructions;

                                                body.emit(assign(r2FCC, r2F65, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2FCD->else_instructions;

                                                ir_expression *const r2FCF = nequal(r2F65, body.constant(0u));
                                                ir_expression *const r2FD0 = expr(ir_unop_b2i, r2FCF);
                                                body.emit(assign(r2FCC, expr(ir_unop_i2u, r2FD0), 0x01));


                                             body.instructions = f2FCD_parent_instructions;
                                             body.emit(f2FCD);

                                             /* END IF */

                                             body.emit(assign(r2FBC, r2FCC, 0x01));

                                             body.emit(assign(r2FBD, body.constant(0u), 0x01));


                                          body.instructions = f2FC9_parent_instructions;
                                          body.emit(f2FC9);

                                          /* END IF */


                                       body.instructions = f2FC7_parent_instructions;
                                       body.emit(f2FC7);

                                       /* END IF */

                                       body.emit(assign(r2FBE, body.constant(0u), 0x01));


                                    body.instructions = f2FC3_parent_instructions;
                                    body.emit(f2FC3);

                                    /* END IF */

                                    ir_expression *const r2FD1 = nequal(r2FBA, body.constant(0u));
                                    ir_expression *const r2FD2 = expr(ir_unop_b2i, r2FD1);
                                    ir_expression *const r2FD3 = expr(ir_unop_i2u, r2FD2);
                                    body.emit(assign(r2FBC, bit_or(r2FBC, r2FD3), 0x01));


                                 body.instructions = f2FC1_parent_instructions;
                                 body.emit(f2FC1);

                                 /* END IF */

                                 body.emit(assign(r2FA4, r2FBE, 0x01));

                                 body.emit(assign(r2FA5, r2FBD, 0x01));

                                 body.emit(assign(r2FA6, r2FBC, 0x01));

                                 body.emit(assign(r2FA3, body.constant(int(0)), 0x01));

                                 body.emit(assign(r2FA9, less(r2FBC, body.constant(0u)), 0x01));


                              body.instructions = f2FB8_parent_instructions;
                              body.emit(f2FB8);

                              /* END IF */


                           body.instructions = f2FB5_parent_instructions;
                           body.emit(f2FB5);

                           /* END IF */


                        body.instructions = f2FAB_parent_instructions;
                        body.emit(f2FAB);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f2FD4 = new(mem_ctx) ir_if(operand(r2FA7).val);
                        exec_list *const f2FD4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2FD4->then_instructions;

                           /* IF CONDITION */
                           ir_if *f2FD5 = new(mem_ctx) ir_if(operand(r2FA9).val);
                           exec_list *const f2FD5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2FD5->then_instructions;

                              ir_variable *const r2FD6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r2FD6, add(r2FA5, body.constant(1u)), 0x01));

                              ir_expression *const r2FD7 = less(r2FD6, r2FA5);
                              ir_expression *const r2FD8 = expr(ir_unop_b2i, r2FD7);
                              ir_expression *const r2FD9 = expr(ir_unop_i2u, r2FD8);
                              body.emit(assign(r2FA4, add(r2FA4, r2FD9), 0x01));

                              ir_expression *const r2FDA = equal(r2FA6, body.constant(0u));
                              ir_expression *const r2FDB = expr(ir_unop_b2i, r2FDA);
                              ir_expression *const r2FDC = expr(ir_unop_i2u, r2FDB);
                              ir_expression *const r2FDD = add(r2FA6, r2FDC);
                              ir_expression *const r2FDE = bit_and(r2FDD, body.constant(1u));
                              ir_expression *const r2FDF = expr(ir_unop_bit_not, r2FDE);
                              body.emit(assign(r2FA5, bit_and(r2FD6, r2FDF), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2FD5->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2FE1 = bit_or(r2FA4, r2FA5);
                              ir_expression *const r2FE2 = equal(r2FE1, body.constant(0u));
                              ir_if *f2FE0 = new(mem_ctx) ir_if(operand(r2FE2).val);
                              exec_list *const f2FE0_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2FE0->then_instructions;

                                 body.emit(assign(r2FA3, body.constant(int(0)), 0x01));


                              body.instructions = f2FE0_parent_instructions;
                              body.emit(f2FE0);

                              /* END IF */


                           body.instructions = f2FD5_parent_instructions;
                           body.emit(f2FD5);

                           /* END IF */

                           ir_variable *const r2FE3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r2FE3);
                           ir_expression *const r2FE4 = lshift(r2C5F, body.constant(int(31)));
                           ir_expression *const r2FE5 = expr(ir_unop_i2u, r2FA3);
                           ir_expression *const r2FE6 = lshift(r2FE5, body.constant(int(20)));
                           ir_expression *const r2FE7 = add(r2FE4, r2FE6);
                           body.emit(assign(r2FE3, add(r2FE7, r2FA4), 0x02));

                           body.emit(assign(r2FE3, r2FA5, 0x01));

                           body.emit(assign(r2FA8, r2FE3, 0x03));

                           body.emit(assign(r2FA7, body.constant(false), 0x01));


                        body.instructions = f2FD4_parent_instructions;
                        body.emit(f2FD4);

                        /* END IF */

                        body.emit(assign(r2C60, r2FA8, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2F5C->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2FE9 = less(r2C67, r2C65);
                        ir_if *f2FE8 = new(mem_ctx) ir_if(operand(r2FE9).val);
                        exec_list *const f2FE8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2FE8->then_instructions;

                           ir_variable *const r2FEA = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r2FEB = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r2FEB, sub(r2C65, r2C67), 0x01));

                           ir_expression *const r2FEC = sub(r2C64, r2C66);
                           ir_expression *const r2FED = less(r2C65, r2C67);
                           ir_expression *const r2FEE = expr(ir_unop_b2i, r2FED);
                           ir_expression *const r2FEF = expr(ir_unop_i2u, r2FEE);
                           body.emit(assign(r2FEA, sub(r2FEC, r2FEF), 0x01));

                           body.emit(assign(r2C5F, bit_xor(r2C5F, body.constant(1u)), 0x01));

                           body.emit(assign(r2C68, add(r2C62, body.constant(int(-1))), 0x01));

                           ir_variable *const r2FF0 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r2FF0, add(r2C68, body.constant(int(-10))), 0x01));

                           ir_variable *const r2FF1 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r2FF1, r2FEA, 0x01));

                           ir_variable *const r2FF2 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r2FF2, r2FEB, 0x01));

                           ir_variable *const r2FF3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r2FF3);
                           ir_variable *const r2FF4 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r2FF4);
                           /* IF CONDITION */
                           ir_expression *const r2FF6 = equal(r2FEA, body.constant(0u));
                           ir_if *f2FF5 = new(mem_ctx) ir_if(operand(r2FF6).val);
                           exec_list *const f2FF5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2FF5->then_instructions;

                              body.emit(assign(r2FF1, r2FEB, 0x01));

                              body.emit(assign(r2FF2, body.constant(0u), 0x01));

                              body.emit(assign(r2FF0, add(r2FF0, body.constant(int(-32))), 0x01));


                           body.instructions = f2FF5_parent_instructions;
                           body.emit(f2FF5);

                           /* END IF */

                           ir_variable *const r2FF7 = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r2FF7, r2FF1, 0x01));

                           ir_variable *const r2FF8 = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r2FF9 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r2FF9);
                           /* IF CONDITION */
                           ir_expression *const r2FFB = equal(r2FF1, body.constant(0u));
                           ir_if *f2FFA = new(mem_ctx) ir_if(operand(r2FFB).val);
                           exec_list *const f2FFA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2FFA->then_instructions;

                              body.emit(assign(r2FF8, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2FFA->else_instructions;

                              body.emit(assign(r2FF9, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2FFD = bit_and(r2FF1, body.constant(4294901760u));
                              ir_expression *const r2FFE = equal(r2FFD, body.constant(0u));
                              ir_if *f2FFC = new(mem_ctx) ir_if(operand(r2FFE).val);
                              exec_list *const f2FFC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2FFC->then_instructions;

                                 body.emit(assign(r2FF9, body.constant(int(16)), 0x01));

                                 body.emit(assign(r2FF7, lshift(r2FF1, body.constant(int(16))), 0x01));


                              body.instructions = f2FFC_parent_instructions;
                              body.emit(f2FFC);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r3000 = bit_and(r2FF7, body.constant(4278190080u));
                              ir_expression *const r3001 = equal(r3000, body.constant(0u));
                              ir_if *f2FFF = new(mem_ctx) ir_if(operand(r3001).val);
                              exec_list *const f2FFF_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2FFF->then_instructions;

                                 body.emit(assign(r2FF9, add(r2FF9, body.constant(int(8))), 0x01));

                                 body.emit(assign(r2FF7, lshift(r2FF7, body.constant(int(8))), 0x01));


                              body.instructions = f2FFF_parent_instructions;
                              body.emit(f2FFF);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r3003 = bit_and(r2FF7, body.constant(4026531840u));
                              ir_expression *const r3004 = equal(r3003, body.constant(0u));
                              ir_if *f3002 = new(mem_ctx) ir_if(operand(r3004).val);
                              exec_list *const f3002_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3002->then_instructions;

                                 body.emit(assign(r2FF9, add(r2FF9, body.constant(int(4))), 0x01));

                                 body.emit(assign(r2FF7, lshift(r2FF7, body.constant(int(4))), 0x01));


                              body.instructions = f3002_parent_instructions;
                              body.emit(f3002);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r3006 = bit_and(r2FF7, body.constant(3221225472u));
                              ir_expression *const r3007 = equal(r3006, body.constant(0u));
                              ir_if *f3005 = new(mem_ctx) ir_if(operand(r3007).val);
                              exec_list *const f3005_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3005->then_instructions;

                                 body.emit(assign(r2FF9, add(r2FF9, body.constant(int(2))), 0x01));

                                 body.emit(assign(r2FF7, lshift(r2FF7, body.constant(int(2))), 0x01));


                              body.instructions = f3005_parent_instructions;
                              body.emit(f3005);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r3009 = bit_and(r2FF7, body.constant(2147483648u));
                              ir_expression *const r300A = equal(r3009, body.constant(0u));
                              ir_if *f3008 = new(mem_ctx) ir_if(operand(r300A).val);
                              exec_list *const f3008_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3008->then_instructions;

                                 body.emit(assign(r2FF9, add(r2FF9, body.constant(int(1))), 0x01));


                              body.instructions = f3008_parent_instructions;
                              body.emit(f3008);

                              /* END IF */

                              body.emit(assign(r2FF8, r2FF9, 0x01));


                           body.instructions = f2FFA_parent_instructions;
                           body.emit(f2FFA);

                           /* END IF */

                           body.emit(assign(r2FF4, add(r2FF8, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r300C = lequal(body.constant(int(0)), r2FF4);
                           ir_if *f300B = new(mem_ctx) ir_if(operand(r300C).val);
                           exec_list *const f300B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f300B->then_instructions;

                              body.emit(assign(r2FF3, body.constant(0u), 0x01));

                              ir_variable *const r300D = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r300D, lshift(r2FF2, r2FF4), 0x01));

                              ir_variable *const r300E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r3010 = equal(r2FF4, body.constant(int(0)));
                              ir_if *f300F = new(mem_ctx) ir_if(operand(r3010).val);
                              exec_list *const f300F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f300F->then_instructions;

                                 body.emit(assign(r300E, r2FF1, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f300F->else_instructions;

                                 ir_expression *const r3011 = lshift(r2FF1, r2FF4);
                                 ir_expression *const r3012 = neg(r2FF4);
                                 ir_expression *const r3013 = bit_and(r3012, body.constant(int(31)));
                                 ir_expression *const r3014 = rshift(r2FF2, r3013);
                                 body.emit(assign(r300E, bit_or(r3011, r3014), 0x01));


                              body.instructions = f300F_parent_instructions;
                              body.emit(f300F);

                              /* END IF */

                              body.emit(assign(r2FF1, r300E, 0x01));

                              body.emit(assign(r2FF2, r300D, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f300B->else_instructions;

                              ir_variable *const r3015 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r3015, body.constant(0u), 0x01));

                              ir_variable *const r3016 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r3016, neg(r2FF4), 0x01));

                              ir_variable *const r3017 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r3017);
                              ir_variable *const r3018 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r3018);
                              ir_variable *const r3019 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r3019);
                              ir_variable *const r301A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r301B = neg(r3016);
                              body.emit(assign(r301A, bit_and(r301B, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r301D = equal(r3016, body.constant(int(0)));
                              ir_if *f301C = new(mem_ctx) ir_if(operand(r301D).val);
                              exec_list *const f301C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f301C->then_instructions;

                                 body.emit(assign(r3017, r3015, 0x01));

                                 body.emit(assign(r3018, r2FF2, 0x01));

                                 body.emit(assign(r3019, r2FF1, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f301C->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r301F = less(r3016, body.constant(int(32)));
                                 ir_if *f301E = new(mem_ctx) ir_if(operand(r301F).val);
                                 exec_list *const f301E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f301E->then_instructions;

                                    body.emit(assign(r3017, lshift(r2FF2, r301A), 0x01));

                                    ir_expression *const r3020 = lshift(r2FF1, r301A);
                                    ir_expression *const r3021 = rshift(r2FF2, r3016);
                                    body.emit(assign(r3018, bit_or(r3020, r3021), 0x01));

                                    body.emit(assign(r3019, rshift(r2FF1, r3016), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f301E->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r3023 = equal(r3016, body.constant(int(32)));
                                    ir_if *f3022 = new(mem_ctx) ir_if(operand(r3023).val);
                                    exec_list *const f3022_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3022->then_instructions;

                                       body.emit(assign(r3017, r2FF2, 0x01));

                                       body.emit(assign(r3018, r2FF1, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3022->else_instructions;

                                       body.emit(assign(r3015, bit_or(body.constant(0u), r2FF2), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r3025 = less(r3016, body.constant(int(64)));
                                       ir_if *f3024 = new(mem_ctx) ir_if(operand(r3025).val);
                                       exec_list *const f3024_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3024->then_instructions;

                                          body.emit(assign(r3017, lshift(r2FF1, r301A), 0x01));

                                          ir_expression *const r3026 = bit_and(r3016, body.constant(int(31)));
                                          body.emit(assign(r3018, rshift(r2FF1, r3026), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3024->else_instructions;

                                          ir_variable *const r3027 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r3029 = equal(r3016, body.constant(int(64)));
                                          ir_if *f3028 = new(mem_ctx) ir_if(operand(r3029).val);
                                          exec_list *const f3028_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3028->then_instructions;

                                             body.emit(assign(r3027, r2FF1, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3028->else_instructions;

                                             ir_expression *const r302A = nequal(r2FF1, body.constant(0u));
                                             ir_expression *const r302B = expr(ir_unop_b2i, r302A);
                                             body.emit(assign(r3027, expr(ir_unop_i2u, r302B), 0x01));


                                          body.instructions = f3028_parent_instructions;
                                          body.emit(f3028);

                                          /* END IF */

                                          body.emit(assign(r3017, r3027, 0x01));

                                          body.emit(assign(r3018, body.constant(0u), 0x01));


                                       body.instructions = f3024_parent_instructions;
                                       body.emit(f3024);

                                       /* END IF */


                                    body.instructions = f3022_parent_instructions;
                                    body.emit(f3022);

                                    /* END IF */

                                    body.emit(assign(r3019, body.constant(0u), 0x01));


                                 body.instructions = f301E_parent_instructions;
                                 body.emit(f301E);

                                 /* END IF */

                                 ir_expression *const r302C = nequal(r3015, body.constant(0u));
                                 ir_expression *const r302D = expr(ir_unop_b2i, r302C);
                                 ir_expression *const r302E = expr(ir_unop_i2u, r302D);
                                 body.emit(assign(r3017, bit_or(r3017, r302E), 0x01));


                              body.instructions = f301C_parent_instructions;
                              body.emit(f301C);

                              /* END IF */

                              body.emit(assign(r2FF1, r3019, 0x01));

                              body.emit(assign(r2FF2, r3018, 0x01));

                              body.emit(assign(r2FF3, r3017, 0x01));


                           body.instructions = f300B_parent_instructions;
                           body.emit(f300B);

                           /* END IF */

                           body.emit(assign(r2FF0, sub(r2FF0, r2FF4), 0x01));

                           ir_variable *const r302F = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r302F, r2FF0, 0x01));

                           ir_variable *const r3030 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r3030, r2FF1, 0x01));

                           ir_variable *const r3031 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r3031, r2FF2, 0x01));

                           ir_variable *const r3032 = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r3032, r2FF3, 0x01));

                           ir_variable *const r3033 = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r3033, body.constant(true), 0x01));

                           ir_variable *const r3034 = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r3035 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r3035);
                           ir_expression *const r3036 = expr(ir_unop_u2i, r2FF3);
                           body.emit(assign(r3035, less(r3036, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3038 = lequal(body.constant(int(2045)), r2FF0);
                           ir_if *f3037 = new(mem_ctx) ir_if(operand(r3038).val);
                           exec_list *const f3037_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3037->then_instructions;

                              ir_variable *const r3039 = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r303B = less(body.constant(int(2045)), r2FF0);
                              ir_if *f303A = new(mem_ctx) ir_if(operand(r303B).val);
                              exec_list *const f303A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f303A->then_instructions;

                                 body.emit(assign(r3039, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f303A->else_instructions;

                                 ir_variable *const r303C = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r303E = equal(r2FF0, body.constant(int(2045)));
                                 ir_if *f303D = new(mem_ctx) ir_if(operand(r303E).val);
                                 exec_list *const f303D_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f303D->then_instructions;

                                    ir_expression *const r303F = equal(body.constant(2097151u), r2FF1);
                                    ir_expression *const r3040 = equal(body.constant(4294967295u), r2FF2);
                                    body.emit(assign(r303C, logic_and(r303F, r3040), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f303D->else_instructions;

                                    body.emit(assign(r303C, body.constant(false), 0x01));


                                 body.instructions = f303D_parent_instructions;
                                 body.emit(f303D);

                                 /* END IF */

                                 body.emit(assign(r3039, logic_and(r303C, r3035), 0x01));


                              body.instructions = f303A_parent_instructions;
                              body.emit(f303A);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f3041 = new(mem_ctx) ir_if(operand(r3039).val);
                              exec_list *const f3041_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3041->then_instructions;

                                 ir_variable *const r3042 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r3042);
                                 ir_expression *const r3043 = lshift(r2C5F, body.constant(int(31)));
                                 body.emit(assign(r3042, add(r3043, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r3042, body.constant(0u), 0x01));

                                 body.emit(assign(r3034, r3042, 0x03));

                                 body.emit(assign(r3033, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3041->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3045 = less(r2FF0, body.constant(int(0)));
                                 ir_if *f3044 = new(mem_ctx) ir_if(operand(r3045).val);
                                 exec_list *const f3044_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3044->then_instructions;

                                    ir_variable *const r3046 = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r3046, r2FF3, 0x01));

                                    ir_variable *const r3047 = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r3047, neg(r2FF0), 0x01));

                                    ir_variable *const r3048 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r3048);
                                    ir_variable *const r3049 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r3049);
                                    ir_variable *const r304A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r304A);
                                    ir_variable *const r304B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r304C = neg(r3047);
                                    body.emit(assign(r304B, bit_and(r304C, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r304E = equal(r3047, body.constant(int(0)));
                                    ir_if *f304D = new(mem_ctx) ir_if(operand(r304E).val);
                                    exec_list *const f304D_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f304D->then_instructions;

                                       body.emit(assign(r3048, r2FF3, 0x01));

                                       body.emit(assign(r3049, r2FF2, 0x01));

                                       body.emit(assign(r304A, r2FF1, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f304D->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r3050 = less(r3047, body.constant(int(32)));
                                       ir_if *f304F = new(mem_ctx) ir_if(operand(r3050).val);
                                       exec_list *const f304F_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f304F->then_instructions;

                                          body.emit(assign(r3048, lshift(r2FF2, r304B), 0x01));

                                          ir_expression *const r3051 = lshift(r2FF1, r304B);
                                          ir_expression *const r3052 = rshift(r2FF2, r3047);
                                          body.emit(assign(r3049, bit_or(r3051, r3052), 0x01));

                                          body.emit(assign(r304A, rshift(r2FF1, r3047), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f304F->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r3054 = equal(r3047, body.constant(int(32)));
                                          ir_if *f3053 = new(mem_ctx) ir_if(operand(r3054).val);
                                          exec_list *const f3053_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3053->then_instructions;

                                             body.emit(assign(r3048, r2FF2, 0x01));

                                             body.emit(assign(r3049, r2FF1, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3053->else_instructions;

                                             body.emit(assign(r3046, bit_or(r2FF3, r2FF2), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r3056 = less(r3047, body.constant(int(64)));
                                             ir_if *f3055 = new(mem_ctx) ir_if(operand(r3056).val);
                                             exec_list *const f3055_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f3055->then_instructions;

                                                body.emit(assign(r3048, lshift(r2FF1, r304B), 0x01));

                                                ir_expression *const r3057 = bit_and(r3047, body.constant(int(31)));
                                                body.emit(assign(r3049, rshift(r2FF1, r3057), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f3055->else_instructions;

                                                ir_variable *const r3058 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r305A = equal(r3047, body.constant(int(64)));
                                                ir_if *f3059 = new(mem_ctx) ir_if(operand(r305A).val);
                                                exec_list *const f3059_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f3059->then_instructions;

                                                   body.emit(assign(r3058, r2FF1, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f3059->else_instructions;

                                                   ir_expression *const r305B = nequal(r2FF1, body.constant(0u));
                                                   ir_expression *const r305C = expr(ir_unop_b2i, r305B);
                                                   body.emit(assign(r3058, expr(ir_unop_i2u, r305C), 0x01));


                                                body.instructions = f3059_parent_instructions;
                                                body.emit(f3059);

                                                /* END IF */

                                                body.emit(assign(r3048, r3058, 0x01));

                                                body.emit(assign(r3049, body.constant(0u), 0x01));


                                             body.instructions = f3055_parent_instructions;
                                             body.emit(f3055);

                                             /* END IF */


                                          body.instructions = f3053_parent_instructions;
                                          body.emit(f3053);

                                          /* END IF */

                                          body.emit(assign(r304A, body.constant(0u), 0x01));


                                       body.instructions = f304F_parent_instructions;
                                       body.emit(f304F);

                                       /* END IF */

                                       ir_expression *const r305D = nequal(r3046, body.constant(0u));
                                       ir_expression *const r305E = expr(ir_unop_b2i, r305D);
                                       ir_expression *const r305F = expr(ir_unop_i2u, r305E);
                                       body.emit(assign(r3048, bit_or(r3048, r305F), 0x01));


                                    body.instructions = f304D_parent_instructions;
                                    body.emit(f304D);

                                    /* END IF */

                                    body.emit(assign(r3030, r304A, 0x01));

                                    body.emit(assign(r3031, r3049, 0x01));

                                    body.emit(assign(r3032, r3048, 0x01));

                                    body.emit(assign(r302F, body.constant(int(0)), 0x01));

                                    body.emit(assign(r3035, less(r3048, body.constant(0u)), 0x01));


                                 body.instructions = f3044_parent_instructions;
                                 body.emit(f3044);

                                 /* END IF */


                              body.instructions = f3041_parent_instructions;
                              body.emit(f3041);

                              /* END IF */


                           body.instructions = f3037_parent_instructions;
                           body.emit(f3037);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f3060 = new(mem_ctx) ir_if(operand(r3033).val);
                           exec_list *const f3060_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3060->then_instructions;

                              /* IF CONDITION */
                              ir_if *f3061 = new(mem_ctx) ir_if(operand(r3035).val);
                              exec_list *const f3061_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3061->then_instructions;

                                 ir_variable *const r3062 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r3062, add(r3031, body.constant(1u)), 0x01));

                                 ir_expression *const r3063 = less(r3062, r3031);
                                 ir_expression *const r3064 = expr(ir_unop_b2i, r3063);
                                 ir_expression *const r3065 = expr(ir_unop_i2u, r3064);
                                 body.emit(assign(r3030, add(r3030, r3065), 0x01));

                                 ir_expression *const r3066 = equal(r3032, body.constant(0u));
                                 ir_expression *const r3067 = expr(ir_unop_b2i, r3066);
                                 ir_expression *const r3068 = expr(ir_unop_i2u, r3067);
                                 ir_expression *const r3069 = add(r3032, r3068);
                                 ir_expression *const r306A = bit_and(r3069, body.constant(1u));
                                 ir_expression *const r306B = expr(ir_unop_bit_not, r306A);
                                 body.emit(assign(r3031, bit_and(r3062, r306B), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3061->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r306D = bit_or(r3030, r3031);
                                 ir_expression *const r306E = equal(r306D, body.constant(0u));
                                 ir_if *f306C = new(mem_ctx) ir_if(operand(r306E).val);
                                 exec_list *const f306C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f306C->then_instructions;

                                    body.emit(assign(r302F, body.constant(int(0)), 0x01));


                                 body.instructions = f306C_parent_instructions;
                                 body.emit(f306C);

                                 /* END IF */


                              body.instructions = f3061_parent_instructions;
                              body.emit(f3061);

                              /* END IF */

                              ir_variable *const r306F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r306F);
                              ir_expression *const r3070 = lshift(r2C5F, body.constant(int(31)));
                              ir_expression *const r3071 = expr(ir_unop_i2u, r302F);
                              ir_expression *const r3072 = lshift(r3071, body.constant(int(20)));
                              ir_expression *const r3073 = add(r3070, r3072);
                              body.emit(assign(r306F, add(r3073, r3030), 0x02));

                              body.emit(assign(r306F, r3031, 0x01));

                              body.emit(assign(r3034, r306F, 0x03));

                              body.emit(assign(r3033, body.constant(false), 0x01));


                           body.instructions = f3060_parent_instructions;
                           body.emit(f3060);

                           /* END IF */

                           body.emit(assign(r2C60, r3034, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2FE8->else_instructions;

                           ir_variable *const r3074 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r3074);
                           body.emit(assign(r3074, body.constant(0u), 0x02));

                           body.emit(assign(r3074, body.constant(0u), 0x01));

                           body.emit(assign(r2C60, r3074, 0x03));


                        body.instructions = f2FE8_parent_instructions;
                        body.emit(f2FE8);

                        /* END IF */


                     body.instructions = f2F5C_parent_instructions;
                     body.emit(f2F5C);

                     /* END IF */


                  body.instructions = f2ED0_parent_instructions;
                  body.emit(f2ED0);

                  /* END IF */


               body.instructions = f2E44_parent_instructions;
               body.emit(f2E44);

               /* END IF */


            body.instructions = f2E1D_parent_instructions;
            body.emit(f2E1D);

            /* END IF */


         body.instructions = f2D49_parent_instructions;
         body.emit(f2D49);

         /* END IF */


      body.instructions = f2C79_parent_instructions;
      body.emit(f2C79);

      /* END IF */

      body.emit(assign(r2C5A, r2C60, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f2C5D->else_instructions;

      ir_variable *const r3075 = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r3075, body.constant(true), 0x01));

      ir_variable *const r3076 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r3077 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r3077);
      ir_variable *const r3078 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
      body.emit(r3078);
      ir_variable *const r3079 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
      body.emit(r3079);
      ir_variable *const r307A = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
      body.emit(r307A);
      ir_variable *const r307B = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
      body.emit(r307B);
      ir_variable *const r307C = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r307C);
      ir_variable *const r307D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
      body.emit(r307D);
      ir_variable *const r307E = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
      body.emit(r307E);
      body.emit(assign(r307E, body.constant(0u), 0x01));

      body.emit(assign(r307D, body.constant(0u), 0x01));

      ir_variable *const r307F = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
      body.emit(assign(r307F, swizzle_x(r270C), 0x01));

      body.emit(assign(r307B, r307F, 0x01));

      ir_variable *const r3080 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
      body.emit(assign(r3080, bit_and(swizzle_y(r270C), body.constant(1048575u)), 0x01));

      body.emit(assign(r307A, r3080, 0x01));

      ir_variable *const r3081 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
      body.emit(assign(r3081, swizzle_x(r2740), 0x01));

      body.emit(assign(r3079, r3081, 0x01));

      ir_variable *const r3082 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
      body.emit(assign(r3082, bit_and(swizzle_y(r2740), body.constant(1048575u)), 0x01));

      body.emit(assign(r3078, r3082, 0x01));

      ir_variable *const r3083 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r3084 = rshift(swizzle_y(r270C), body.constant(int(20)));
      ir_expression *const r3085 = bit_and(r3084, body.constant(2047u));
      body.emit(assign(r3083, expr(ir_unop_u2i, r3085), 0x01));

      ir_variable *const r3086 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r3087 = rshift(swizzle_y(r2740), body.constant(int(20)));
      ir_expression *const r3088 = bit_and(r3087, body.constant(2047u));
      body.emit(assign(r3086, expr(ir_unop_u2i, r3088), 0x01));

      ir_variable *const r3089 = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r3089, sub(r3083, r3086), 0x01));

      body.emit(assign(r3077, r3089, 0x01));

      /* IF CONDITION */
      ir_expression *const r308B = less(body.constant(int(0)), r3089);
      ir_if *f308A = new(mem_ctx) ir_if(operand(r308B).val);
      exec_list *const f308A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f308A->then_instructions;

         /* IF CONDITION */
         ir_expression *const r308D = equal(r3083, body.constant(int(2047)));
         ir_if *f308C = new(mem_ctx) ir_if(operand(r308D).val);
         exec_list *const f308C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f308C->then_instructions;

            /* IF CONDITION */
            ir_expression *const r308F = bit_or(r3080, swizzle_x(r270C));
            ir_expression *const r3090 = nequal(r308F, body.constant(0u));
            ir_if *f308E = new(mem_ctx) ir_if(operand(r3090).val);
            exec_list *const f308E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f308E->then_instructions;

               ir_variable *const r3091 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r3091, swizzle_x(r270C), 0x01));

               ir_variable *const r3092 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r3092, swizzle_x(r2740), 0x01));

               ir_variable *const r3093 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r3094 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r3095 = rshift(swizzle_y(r270C), body.constant(int(19)));
               ir_expression *const r3096 = bit_and(r3095, body.constant(4095u));
               ir_expression *const r3097 = equal(r3096, body.constant(4094u));
               ir_expression *const r3098 = nequal(swizzle_x(r270C), body.constant(0u));
               ir_expression *const r3099 = bit_and(swizzle_y(r270C), body.constant(524287u));
               ir_expression *const r309A = nequal(r3099, body.constant(0u));
               ir_expression *const r309B = logic_or(r3098, r309A);
               body.emit(assign(r3094, logic_and(r3097, r309B), 0x01));

               ir_variable *const r309C = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r309D = lshift(swizzle_y(r2740), body.constant(int(1)));
               ir_expression *const r309E = lequal(body.constant(4292870144u), r309D);
               ir_expression *const r309F = nequal(swizzle_x(r2740), body.constant(0u));
               ir_expression *const r30A0 = bit_and(swizzle_y(r2740), body.constant(1048575u));
               ir_expression *const r30A1 = nequal(r30A0, body.constant(0u));
               ir_expression *const r30A2 = logic_or(r309F, r30A1);
               body.emit(assign(r309C, logic_and(r309E, r30A2), 0x01));

               body.emit(assign(r3091, bit_or(swizzle_y(r270C), body.constant(524288u)), 0x02));

               body.emit(assign(r3092, bit_or(swizzle_y(r2740), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r30A4 = lshift(swizzle_y(r270C), body.constant(int(1)));
               ir_expression *const r30A5 = lequal(body.constant(4292870144u), r30A4);
               ir_expression *const r30A6 = nequal(swizzle_x(r270C), body.constant(0u));
               ir_expression *const r30A7 = bit_and(swizzle_y(r270C), body.constant(1048575u));
               ir_expression *const r30A8 = nequal(r30A7, body.constant(0u));
               ir_expression *const r30A9 = logic_or(r30A6, r30A8);
               ir_expression *const r30AA = logic_and(r30A5, r30A9);
               ir_if *f30A3 = new(mem_ctx) ir_if(operand(r30AA).val);
               exec_list *const f30A3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f30A3->then_instructions;

                  ir_variable *const r30AB = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r30AD = logic_and(r3094, r309C);
                  ir_if *f30AC = new(mem_ctx) ir_if(operand(r30AD).val);
                  exec_list *const f30AC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f30AC->then_instructions;

                     body.emit(assign(r30AB, r3092, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f30AC->else_instructions;

                     body.emit(assign(r30AB, r3091, 0x03));


                  body.instructions = f30AC_parent_instructions;
                  body.emit(f30AC);

                  /* END IF */

                  body.emit(assign(r3093, r30AB, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f30A3->else_instructions;

                  body.emit(assign(r3093, r3092, 0x03));


               body.instructions = f30A3_parent_instructions;
               body.emit(f30A3);

               /* END IF */

               body.emit(assign(r3076, r3093, 0x03));

               body.emit(assign(r3075, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f308E->else_instructions;

               body.emit(assign(r3076, r270C, 0x03));

               body.emit(assign(r3075, body.constant(false), 0x01));


            body.instructions = f308E_parent_instructions;
            body.emit(f308E);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f308C->else_instructions;

            /* IF CONDITION */
            ir_expression *const r30AF = equal(r3086, body.constant(int(0)));
            ir_if *f30AE = new(mem_ctx) ir_if(operand(r30AF).val);
            exec_list *const f30AE_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f30AE->then_instructions;

               body.emit(assign(r3077, add(r3089, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f30AE->else_instructions;

               body.emit(assign(r3078, bit_or(r3082, body.constant(1048576u)), 0x01));


            body.instructions = f30AE_parent_instructions;
            body.emit(f30AE);

            /* END IF */

            ir_variable *const r30B0 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r30B0, body.constant(0u), 0x01));

            ir_variable *const r30B1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r30B1);
            ir_variable *const r30B2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r30B2);
            ir_variable *const r30B3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r30B3);
            ir_variable *const r30B4 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r30B5 = neg(r3077);
            body.emit(assign(r30B4, bit_and(r30B5, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r30B7 = equal(r3077, body.constant(int(0)));
            ir_if *f30B6 = new(mem_ctx) ir_if(operand(r30B7).val);
            exec_list *const f30B6_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f30B6->then_instructions;

               body.emit(assign(r30B1, r30B0, 0x01));

               body.emit(assign(r30B2, r3081, 0x01));

               body.emit(assign(r30B3, r3078, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f30B6->else_instructions;

               /* IF CONDITION */
               ir_expression *const r30B9 = less(r3077, body.constant(int(32)));
               ir_if *f30B8 = new(mem_ctx) ir_if(operand(r30B9).val);
               exec_list *const f30B8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f30B8->then_instructions;

                  body.emit(assign(r30B1, lshift(swizzle_x(r2740), r30B4), 0x01));

                  ir_expression *const r30BA = lshift(r3078, r30B4);
                  ir_expression *const r30BB = rshift(swizzle_x(r2740), r3077);
                  body.emit(assign(r30B2, bit_or(r30BA, r30BB), 0x01));

                  body.emit(assign(r30B3, rshift(r3078, r3077), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f30B8->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r30BD = equal(r3077, body.constant(int(32)));
                  ir_if *f30BC = new(mem_ctx) ir_if(operand(r30BD).val);
                  exec_list *const f30BC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f30BC->then_instructions;

                     body.emit(assign(r30B1, r3081, 0x01));

                     body.emit(assign(r30B2, r3078, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f30BC->else_instructions;

                     body.emit(assign(r30B0, bit_or(body.constant(0u), swizzle_x(r2740)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r30BF = less(r3077, body.constant(int(64)));
                     ir_if *f30BE = new(mem_ctx) ir_if(operand(r30BF).val);
                     exec_list *const f30BE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f30BE->then_instructions;

                        body.emit(assign(r30B1, lshift(r3078, r30B4), 0x01));

                        ir_expression *const r30C0 = bit_and(r3077, body.constant(int(31)));
                        body.emit(assign(r30B2, rshift(r3078, r30C0), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f30BE->else_instructions;

                        ir_variable *const r30C1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r30C3 = equal(r3077, body.constant(int(64)));
                        ir_if *f30C2 = new(mem_ctx) ir_if(operand(r30C3).val);
                        exec_list *const f30C2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f30C2->then_instructions;

                           body.emit(assign(r30C1, r3078, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f30C2->else_instructions;

                           ir_expression *const r30C4 = nequal(r3078, body.constant(0u));
                           ir_expression *const r30C5 = expr(ir_unop_b2i, r30C4);
                           body.emit(assign(r30C1, expr(ir_unop_i2u, r30C5), 0x01));


                        body.instructions = f30C2_parent_instructions;
                        body.emit(f30C2);

                        /* END IF */

                        body.emit(assign(r30B1, r30C1, 0x01));

                        body.emit(assign(r30B2, body.constant(0u), 0x01));


                     body.instructions = f30BE_parent_instructions;
                     body.emit(f30BE);

                     /* END IF */


                  body.instructions = f30BC_parent_instructions;
                  body.emit(f30BC);

                  /* END IF */

                  body.emit(assign(r30B3, body.constant(0u), 0x01));


               body.instructions = f30B8_parent_instructions;
               body.emit(f30B8);

               /* END IF */

               ir_expression *const r30C6 = nequal(r30B0, body.constant(0u));
               ir_expression *const r30C7 = expr(ir_unop_b2i, r30C6);
               ir_expression *const r30C8 = expr(ir_unop_i2u, r30C7);
               body.emit(assign(r30B1, bit_or(r30B1, r30C8), 0x01));


            body.instructions = f30B6_parent_instructions;
            body.emit(f30B6);

            /* END IF */

            body.emit(assign(r3078, r30B3, 0x01));

            body.emit(assign(r3079, r30B2, 0x01));

            body.emit(assign(r307D, r30B1, 0x01));

            body.emit(assign(r307C, r3083, 0x01));


         body.instructions = f308C_parent_instructions;
         body.emit(f308C);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f308A->else_instructions;

         /* IF CONDITION */
         ir_expression *const r30CA = less(r3077, body.constant(int(0)));
         ir_if *f30C9 = new(mem_ctx) ir_if(operand(r30CA).val);
         exec_list *const f30C9_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f30C9->then_instructions;

            /* IF CONDITION */
            ir_expression *const r30CC = equal(r3086, body.constant(int(2047)));
            ir_if *f30CB = new(mem_ctx) ir_if(operand(r30CC).val);
            exec_list *const f30CB_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f30CB->then_instructions;

               /* IF CONDITION */
               ir_expression *const r30CE = bit_or(r3078, r3079);
               ir_expression *const r30CF = nequal(r30CE, body.constant(0u));
               ir_if *f30CD = new(mem_ctx) ir_if(operand(r30CF).val);
               exec_list *const f30CD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f30CD->then_instructions;

                  ir_variable *const r30D0 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r30D0, swizzle_x(r270C), 0x01));

                  ir_variable *const r30D1 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r30D1, swizzle_x(r2740), 0x01));

                  ir_variable *const r30D2 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r30D3 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r30D4 = rshift(swizzle_y(r270C), body.constant(int(19)));
                  ir_expression *const r30D5 = bit_and(r30D4, body.constant(4095u));
                  ir_expression *const r30D6 = equal(r30D5, body.constant(4094u));
                  ir_expression *const r30D7 = nequal(swizzle_x(r270C), body.constant(0u));
                  ir_expression *const r30D8 = bit_and(swizzle_y(r270C), body.constant(524287u));
                  ir_expression *const r30D9 = nequal(r30D8, body.constant(0u));
                  ir_expression *const r30DA = logic_or(r30D7, r30D9);
                  body.emit(assign(r30D3, logic_and(r30D6, r30DA), 0x01));

                  ir_variable *const r30DB = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r30DC = lshift(swizzle_y(r2740), body.constant(int(1)));
                  ir_expression *const r30DD = lequal(body.constant(4292870144u), r30DC);
                  ir_expression *const r30DE = nequal(swizzle_x(r2740), body.constant(0u));
                  ir_expression *const r30DF = bit_and(swizzle_y(r2740), body.constant(1048575u));
                  ir_expression *const r30E0 = nequal(r30DF, body.constant(0u));
                  ir_expression *const r30E1 = logic_or(r30DE, r30E0);
                  body.emit(assign(r30DB, logic_and(r30DD, r30E1), 0x01));

                  body.emit(assign(r30D0, bit_or(swizzle_y(r270C), body.constant(524288u)), 0x02));

                  body.emit(assign(r30D1, bit_or(swizzle_y(r2740), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r30E3 = lshift(swizzle_y(r270C), body.constant(int(1)));
                  ir_expression *const r30E4 = lequal(body.constant(4292870144u), r30E3);
                  ir_expression *const r30E5 = nequal(swizzle_x(r270C), body.constant(0u));
                  ir_expression *const r30E6 = bit_and(swizzle_y(r270C), body.constant(1048575u));
                  ir_expression *const r30E7 = nequal(r30E6, body.constant(0u));
                  ir_expression *const r30E8 = logic_or(r30E5, r30E7);
                  ir_expression *const r30E9 = logic_and(r30E4, r30E8);
                  ir_if *f30E2 = new(mem_ctx) ir_if(operand(r30E9).val);
                  exec_list *const f30E2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f30E2->then_instructions;

                     ir_variable *const r30EA = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r30EC = logic_and(r30D3, r30DB);
                     ir_if *f30EB = new(mem_ctx) ir_if(operand(r30EC).val);
                     exec_list *const f30EB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f30EB->then_instructions;

                        body.emit(assign(r30EA, r30D1, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f30EB->else_instructions;

                        body.emit(assign(r30EA, r30D0, 0x03));


                     body.instructions = f30EB_parent_instructions;
                     body.emit(f30EB);

                     /* END IF */

                     body.emit(assign(r30D2, r30EA, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f30E2->else_instructions;

                     body.emit(assign(r30D2, r30D1, 0x03));


                  body.instructions = f30E2_parent_instructions;
                  body.emit(f30E2);

                  /* END IF */

                  body.emit(assign(r3076, r30D2, 0x03));

                  body.emit(assign(r3075, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f30CD->else_instructions;

                  ir_variable *const r30ED = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r30ED);
                  ir_expression *const r30EE = lshift(r2C5B, body.constant(int(31)));
                  body.emit(assign(r30ED, add(r30EE, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r30ED, body.constant(0u), 0x01));

                  body.emit(assign(r3076, r30ED, 0x03));

                  body.emit(assign(r3075, body.constant(false), 0x01));


               body.instructions = f30CD_parent_instructions;
               body.emit(f30CD);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f30CB->else_instructions;

               /* IF CONDITION */
               ir_expression *const r30F0 = equal(r3083, body.constant(int(0)));
               ir_if *f30EF = new(mem_ctx) ir_if(operand(r30F0).val);
               exec_list *const f30EF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f30EF->then_instructions;

                  body.emit(assign(r3077, add(r3077, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f30EF->else_instructions;

                  body.emit(assign(r307A, bit_or(r3080, body.constant(1048576u)), 0x01));


               body.instructions = f30EF_parent_instructions;
               body.emit(f30EF);

               /* END IF */

               ir_variable *const r30F1 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r30F1, body.constant(0u), 0x01));

               ir_variable *const r30F2 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r30F2, neg(r3077), 0x01));

               ir_variable *const r30F3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r30F3);
               ir_variable *const r30F4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r30F4);
               ir_variable *const r30F5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r30F5);
               ir_variable *const r30F6 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r30F7 = neg(r30F2);
               body.emit(assign(r30F6, bit_and(r30F7, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r30F9 = equal(r30F2, body.constant(int(0)));
               ir_if *f30F8 = new(mem_ctx) ir_if(operand(r30F9).val);
               exec_list *const f30F8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f30F8->then_instructions;

                  body.emit(assign(r30F3, r30F1, 0x01));

                  body.emit(assign(r30F4, r307F, 0x01));

                  body.emit(assign(r30F5, r307A, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f30F8->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r30FB = less(r30F2, body.constant(int(32)));
                  ir_if *f30FA = new(mem_ctx) ir_if(operand(r30FB).val);
                  exec_list *const f30FA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f30FA->then_instructions;

                     body.emit(assign(r30F3, lshift(swizzle_x(r270C), r30F6), 0x01));

                     ir_expression *const r30FC = lshift(r307A, r30F6);
                     ir_expression *const r30FD = rshift(swizzle_x(r270C), r30F2);
                     body.emit(assign(r30F4, bit_or(r30FC, r30FD), 0x01));

                     body.emit(assign(r30F5, rshift(r307A, r30F2), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f30FA->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r30FF = equal(r30F2, body.constant(int(32)));
                     ir_if *f30FE = new(mem_ctx) ir_if(operand(r30FF).val);
                     exec_list *const f30FE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f30FE->then_instructions;

                        body.emit(assign(r30F3, r307F, 0x01));

                        body.emit(assign(r30F4, r307A, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f30FE->else_instructions;

                        body.emit(assign(r30F1, bit_or(body.constant(0u), swizzle_x(r270C)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3101 = less(r30F2, body.constant(int(64)));
                        ir_if *f3100 = new(mem_ctx) ir_if(operand(r3101).val);
                        exec_list *const f3100_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3100->then_instructions;

                           body.emit(assign(r30F3, lshift(r307A, r30F6), 0x01));

                           ir_expression *const r3102 = bit_and(r30F2, body.constant(int(31)));
                           body.emit(assign(r30F4, rshift(r307A, r3102), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3100->else_instructions;

                           ir_variable *const r3103 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r3105 = equal(r30F2, body.constant(int(64)));
                           ir_if *f3104 = new(mem_ctx) ir_if(operand(r3105).val);
                           exec_list *const f3104_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3104->then_instructions;

                              body.emit(assign(r3103, r307A, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3104->else_instructions;

                              ir_expression *const r3106 = nequal(r307A, body.constant(0u));
                              ir_expression *const r3107 = expr(ir_unop_b2i, r3106);
                              body.emit(assign(r3103, expr(ir_unop_i2u, r3107), 0x01));


                           body.instructions = f3104_parent_instructions;
                           body.emit(f3104);

                           /* END IF */

                           body.emit(assign(r30F3, r3103, 0x01));

                           body.emit(assign(r30F4, body.constant(0u), 0x01));


                        body.instructions = f3100_parent_instructions;
                        body.emit(f3100);

                        /* END IF */


                     body.instructions = f30FE_parent_instructions;
                     body.emit(f30FE);

                     /* END IF */

                     body.emit(assign(r30F5, body.constant(0u), 0x01));


                  body.instructions = f30FA_parent_instructions;
                  body.emit(f30FA);

                  /* END IF */

                  ir_expression *const r3108 = nequal(r30F1, body.constant(0u));
                  ir_expression *const r3109 = expr(ir_unop_b2i, r3108);
                  ir_expression *const r310A = expr(ir_unop_i2u, r3109);
                  body.emit(assign(r30F3, bit_or(r30F3, r310A), 0x01));


               body.instructions = f30F8_parent_instructions;
               body.emit(f30F8);

               /* END IF */

               body.emit(assign(r307A, r30F5, 0x01));

               body.emit(assign(r307B, r30F4, 0x01));

               body.emit(assign(r307D, r30F3, 0x01));

               body.emit(assign(r307C, r3086, 0x01));


            body.instructions = f30CB_parent_instructions;
            body.emit(f30CB);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f30C9->else_instructions;

            /* IF CONDITION */
            ir_expression *const r310C = equal(r3083, body.constant(int(2047)));
            ir_if *f310B = new(mem_ctx) ir_if(operand(r310C).val);
            exec_list *const f310B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f310B->then_instructions;

               /* IF CONDITION */
               ir_expression *const r310E = bit_or(r307A, r307B);
               ir_expression *const r310F = bit_or(r3078, r3079);
               ir_expression *const r3110 = bit_or(r310E, r310F);
               ir_expression *const r3111 = nequal(r3110, body.constant(0u));
               ir_if *f310D = new(mem_ctx) ir_if(operand(r3111).val);
               exec_list *const f310D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f310D->then_instructions;

                  ir_variable *const r3112 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r3112, swizzle_x(r270C), 0x01));

                  ir_variable *const r3113 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r3113, swizzle_x(r2740), 0x01));

                  ir_variable *const r3114 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r3115 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r3116 = rshift(swizzle_y(r270C), body.constant(int(19)));
                  ir_expression *const r3117 = bit_and(r3116, body.constant(4095u));
                  ir_expression *const r3118 = equal(r3117, body.constant(4094u));
                  ir_expression *const r3119 = nequal(swizzle_x(r270C), body.constant(0u));
                  ir_expression *const r311A = bit_and(swizzle_y(r270C), body.constant(524287u));
                  ir_expression *const r311B = nequal(r311A, body.constant(0u));
                  ir_expression *const r311C = logic_or(r3119, r311B);
                  body.emit(assign(r3115, logic_and(r3118, r311C), 0x01));

                  ir_variable *const r311D = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r311E = lshift(swizzle_y(r2740), body.constant(int(1)));
                  ir_expression *const r311F = lequal(body.constant(4292870144u), r311E);
                  ir_expression *const r3120 = nequal(swizzle_x(r2740), body.constant(0u));
                  ir_expression *const r3121 = bit_and(swizzle_y(r2740), body.constant(1048575u));
                  ir_expression *const r3122 = nequal(r3121, body.constant(0u));
                  ir_expression *const r3123 = logic_or(r3120, r3122);
                  body.emit(assign(r311D, logic_and(r311F, r3123), 0x01));

                  body.emit(assign(r3112, bit_or(swizzle_y(r270C), body.constant(524288u)), 0x02));

                  body.emit(assign(r3113, bit_or(swizzle_y(r2740), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r3125 = lshift(swizzle_y(r270C), body.constant(int(1)));
                  ir_expression *const r3126 = lequal(body.constant(4292870144u), r3125);
                  ir_expression *const r3127 = nequal(swizzle_x(r270C), body.constant(0u));
                  ir_expression *const r3128 = bit_and(swizzle_y(r270C), body.constant(1048575u));
                  ir_expression *const r3129 = nequal(r3128, body.constant(0u));
                  ir_expression *const r312A = logic_or(r3127, r3129);
                  ir_expression *const r312B = logic_and(r3126, r312A);
                  ir_if *f3124 = new(mem_ctx) ir_if(operand(r312B).val);
                  exec_list *const f3124_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3124->then_instructions;

                     ir_variable *const r312C = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r312E = logic_and(r3115, r311D);
                     ir_if *f312D = new(mem_ctx) ir_if(operand(r312E).val);
                     exec_list *const f312D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f312D->then_instructions;

                        body.emit(assign(r312C, r3113, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f312D->else_instructions;

                        body.emit(assign(r312C, r3112, 0x03));


                     body.instructions = f312D_parent_instructions;
                     body.emit(f312D);

                     /* END IF */

                     body.emit(assign(r3114, r312C, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3124->else_instructions;

                     body.emit(assign(r3114, r3113, 0x03));


                  body.instructions = f3124_parent_instructions;
                  body.emit(f3124);

                  /* END IF */

                  body.emit(assign(r3076, r3114, 0x03));

                  body.emit(assign(r3075, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f310D->else_instructions;

                  body.emit(assign(r3076, r270C, 0x03));

                  body.emit(assign(r3075, body.constant(false), 0x01));


               body.instructions = f310D_parent_instructions;
               body.emit(f310D);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f310B->else_instructions;

               ir_variable *const r312F = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r3130 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3130, add(r307B, r3079), 0x01));

               ir_expression *const r3131 = add(r307A, r3078);
               ir_expression *const r3132 = less(r3130, r307B);
               ir_expression *const r3133 = expr(ir_unop_b2i, r3132);
               ir_expression *const r3134 = expr(ir_unop_i2u, r3133);
               body.emit(assign(r312F, add(r3131, r3134), 0x01));

               body.emit(assign(r307E, r312F, 0x01));

               /* IF CONDITION */
               ir_expression *const r3136 = equal(r3083, body.constant(int(0)));
               ir_if *f3135 = new(mem_ctx) ir_if(operand(r3136).val);
               exec_list *const f3135_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3135->then_instructions;

                  ir_variable *const r3137 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3137);
                  ir_expression *const r3138 = lshift(r2C5B, body.constant(int(31)));
                  body.emit(assign(r3137, add(r3138, r312F), 0x02));

                  body.emit(assign(r3137, r3130, 0x01));

                  body.emit(assign(r3076, r3137, 0x03));

                  body.emit(assign(r3075, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3135->else_instructions;

                  body.emit(assign(r307E, bit_or(r312F, body.constant(2097152u)), 0x01));

                  body.emit(assign(r307C, r3083, 0x01));

                  ir_variable *const r3139 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r3139);
                  ir_variable *const r313A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r313A);
                  ir_variable *const r313B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r313B);
                  body.emit(assign(r3139, lshift(r3130, body.constant(int(31))), 0x01));

                  ir_expression *const r313C = lshift(r307E, body.constant(int(31)));
                  ir_expression *const r313D = rshift(r3130, body.constant(int(1)));
                  body.emit(assign(r313A, bit_or(r313C, r313D), 0x01));

                  body.emit(assign(r313B, rshift(r307E, body.constant(int(1))), 0x01));

                  body.emit(assign(r3139, bit_or(r3139, body.constant(0u)), 0x01));

                  body.emit(assign(r307E, r313B, 0x01));

                  body.emit(assign(r307D, r3139, 0x01));

                  ir_variable *const r313E = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r313E, r3083, 0x01));

                  ir_variable *const r313F = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r313F, r313B, 0x01));

                  ir_variable *const r3140 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r3140, r313A, 0x01));

                  ir_variable *const r3141 = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r3141, r3139, 0x01));

                  ir_variable *const r3142 = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r3142, body.constant(true), 0x01));

                  ir_variable *const r3143 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r3144 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r3144);
                  ir_expression *const r3145 = expr(ir_unop_u2i, r3139);
                  body.emit(assign(r3144, less(r3145, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3147 = lequal(body.constant(int(2045)), r3083);
                  ir_if *f3146 = new(mem_ctx) ir_if(operand(r3147).val);
                  exec_list *const f3146_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3146->then_instructions;

                     ir_variable *const r3148 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r314A = less(body.constant(int(2045)), r3083);
                     ir_if *f3149 = new(mem_ctx) ir_if(operand(r314A).val);
                     exec_list *const f3149_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3149->then_instructions;

                        body.emit(assign(r3148, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3149->else_instructions;

                        ir_variable *const r314B = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r314D = equal(r3083, body.constant(int(2045)));
                        ir_if *f314C = new(mem_ctx) ir_if(operand(r314D).val);
                        exec_list *const f314C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f314C->then_instructions;

                           ir_expression *const r314E = equal(body.constant(2097151u), r313B);
                           ir_expression *const r314F = equal(body.constant(4294967295u), r313A);
                           body.emit(assign(r314B, logic_and(r314E, r314F), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f314C->else_instructions;

                           body.emit(assign(r314B, body.constant(false), 0x01));


                        body.instructions = f314C_parent_instructions;
                        body.emit(f314C);

                        /* END IF */

                        body.emit(assign(r3148, logic_and(r314B, r3144), 0x01));


                     body.instructions = f3149_parent_instructions;
                     body.emit(f3149);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f3150 = new(mem_ctx) ir_if(operand(r3148).val);
                     exec_list *const f3150_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3150->then_instructions;

                        ir_variable *const r3151 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r3151);
                        ir_expression *const r3152 = lshift(r2C5B, body.constant(int(31)));
                        body.emit(assign(r3151, add(r3152, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r3151, body.constant(0u), 0x01));

                        body.emit(assign(r3143, r3151, 0x03));

                        body.emit(assign(r3142, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3150->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3154 = less(r3083, body.constant(int(0)));
                        ir_if *f3153 = new(mem_ctx) ir_if(operand(r3154).val);
                        exec_list *const f3153_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3153->then_instructions;

                           ir_variable *const r3155 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r3155, r3139, 0x01));

                           ir_variable *const r3156 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r3156, neg(r3083), 0x01));

                           ir_variable *const r3157 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r3157);
                           ir_variable *const r3158 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r3158);
                           ir_variable *const r3159 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r3159);
                           ir_variable *const r315A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r315B = neg(r3156);
                           body.emit(assign(r315A, bit_and(r315B, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r315D = equal(r3156, body.constant(int(0)));
                           ir_if *f315C = new(mem_ctx) ir_if(operand(r315D).val);
                           exec_list *const f315C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f315C->then_instructions;

                              body.emit(assign(r3157, r3139, 0x01));

                              body.emit(assign(r3158, r313A, 0x01));

                              body.emit(assign(r3159, r313B, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f315C->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r315F = less(r3156, body.constant(int(32)));
                              ir_if *f315E = new(mem_ctx) ir_if(operand(r315F).val);
                              exec_list *const f315E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f315E->then_instructions;

                                 body.emit(assign(r3157, lshift(r313A, r315A), 0x01));

                                 ir_expression *const r3160 = lshift(r313B, r315A);
                                 ir_expression *const r3161 = rshift(r313A, r3156);
                                 body.emit(assign(r3158, bit_or(r3160, r3161), 0x01));

                                 body.emit(assign(r3159, rshift(r313B, r3156), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f315E->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3163 = equal(r3156, body.constant(int(32)));
                                 ir_if *f3162 = new(mem_ctx) ir_if(operand(r3163).val);
                                 exec_list *const f3162_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3162->then_instructions;

                                    body.emit(assign(r3157, r313A, 0x01));

                                    body.emit(assign(r3158, r313B, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3162->else_instructions;

                                    body.emit(assign(r3155, bit_or(r3139, r313A), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r3165 = less(r3156, body.constant(int(64)));
                                    ir_if *f3164 = new(mem_ctx) ir_if(operand(r3165).val);
                                    exec_list *const f3164_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3164->then_instructions;

                                       body.emit(assign(r3157, lshift(r313B, r315A), 0x01));

                                       ir_expression *const r3166 = bit_and(r3156, body.constant(int(31)));
                                       body.emit(assign(r3158, rshift(r313B, r3166), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3164->else_instructions;

                                       ir_variable *const r3167 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r3169 = equal(r3156, body.constant(int(64)));
                                       ir_if *f3168 = new(mem_ctx) ir_if(operand(r3169).val);
                                       exec_list *const f3168_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3168->then_instructions;

                                          body.emit(assign(r3167, r313B, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3168->else_instructions;

                                          ir_expression *const r316A = nequal(r313B, body.constant(0u));
                                          ir_expression *const r316B = expr(ir_unop_b2i, r316A);
                                          body.emit(assign(r3167, expr(ir_unop_i2u, r316B), 0x01));


                                       body.instructions = f3168_parent_instructions;
                                       body.emit(f3168);

                                       /* END IF */

                                       body.emit(assign(r3157, r3167, 0x01));

                                       body.emit(assign(r3158, body.constant(0u), 0x01));


                                    body.instructions = f3164_parent_instructions;
                                    body.emit(f3164);

                                    /* END IF */


                                 body.instructions = f3162_parent_instructions;
                                 body.emit(f3162);

                                 /* END IF */

                                 body.emit(assign(r3159, body.constant(0u), 0x01));


                              body.instructions = f315E_parent_instructions;
                              body.emit(f315E);

                              /* END IF */

                              ir_expression *const r316C = nequal(r3155, body.constant(0u));
                              ir_expression *const r316D = expr(ir_unop_b2i, r316C);
                              ir_expression *const r316E = expr(ir_unop_i2u, r316D);
                              body.emit(assign(r3157, bit_or(r3157, r316E), 0x01));


                           body.instructions = f315C_parent_instructions;
                           body.emit(f315C);

                           /* END IF */

                           body.emit(assign(r313F, r3159, 0x01));

                           body.emit(assign(r3140, r3158, 0x01));

                           body.emit(assign(r3141, r3157, 0x01));

                           body.emit(assign(r313E, body.constant(int(0)), 0x01));

                           body.emit(assign(r3144, less(r3157, body.constant(0u)), 0x01));


                        body.instructions = f3153_parent_instructions;
                        body.emit(f3153);

                        /* END IF */


                     body.instructions = f3150_parent_instructions;
                     body.emit(f3150);

                     /* END IF */


                  body.instructions = f3146_parent_instructions;
                  body.emit(f3146);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f316F = new(mem_ctx) ir_if(operand(r3142).val);
                  exec_list *const f316F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f316F->then_instructions;

                     /* IF CONDITION */
                     ir_if *f3170 = new(mem_ctx) ir_if(operand(r3144).val);
                     exec_list *const f3170_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3170->then_instructions;

                        ir_variable *const r3171 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r3171, add(r3140, body.constant(1u)), 0x01));

                        ir_expression *const r3172 = less(r3171, r3140);
                        ir_expression *const r3173 = expr(ir_unop_b2i, r3172);
                        ir_expression *const r3174 = expr(ir_unop_i2u, r3173);
                        body.emit(assign(r313F, add(r313F, r3174), 0x01));

                        ir_expression *const r3175 = equal(r3141, body.constant(0u));
                        ir_expression *const r3176 = expr(ir_unop_b2i, r3175);
                        ir_expression *const r3177 = expr(ir_unop_i2u, r3176);
                        ir_expression *const r3178 = add(r3141, r3177);
                        ir_expression *const r3179 = bit_and(r3178, body.constant(1u));
                        ir_expression *const r317A = expr(ir_unop_bit_not, r3179);
                        body.emit(assign(r3140, bit_and(r3171, r317A), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3170->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r317C = bit_or(r313F, r3140);
                        ir_expression *const r317D = equal(r317C, body.constant(0u));
                        ir_if *f317B = new(mem_ctx) ir_if(operand(r317D).val);
                        exec_list *const f317B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f317B->then_instructions;

                           body.emit(assign(r313E, body.constant(int(0)), 0x01));


                        body.instructions = f317B_parent_instructions;
                        body.emit(f317B);

                        /* END IF */


                     body.instructions = f3170_parent_instructions;
                     body.emit(f3170);

                     /* END IF */

                     ir_variable *const r317E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r317E);
                     ir_expression *const r317F = lshift(r2C5B, body.constant(int(31)));
                     ir_expression *const r3180 = expr(ir_unop_i2u, r313E);
                     ir_expression *const r3181 = lshift(r3180, body.constant(int(20)));
                     ir_expression *const r3182 = add(r317F, r3181);
                     body.emit(assign(r317E, add(r3182, r313F), 0x02));

                     body.emit(assign(r317E, r3140, 0x01));

                     body.emit(assign(r3143, r317E, 0x03));

                     body.emit(assign(r3142, body.constant(false), 0x01));


                  body.instructions = f316F_parent_instructions;
                  body.emit(f316F);

                  /* END IF */

                  body.emit(assign(r3076, r3143, 0x03));

                  body.emit(assign(r3075, body.constant(false), 0x01));


               body.instructions = f3135_parent_instructions;
               body.emit(f3135);

               /* END IF */


            body.instructions = f310B_parent_instructions;
            body.emit(f310B);

            /* END IF */


         body.instructions = f30C9_parent_instructions;
         body.emit(f30C9);

         /* END IF */


      body.instructions = f308A_parent_instructions;
      body.emit(f308A);

      /* END IF */

      /* IF CONDITION */
      ir_if *f3183 = new(mem_ctx) ir_if(operand(r3075).val);
      exec_list *const f3183_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f3183->then_instructions;

         body.emit(assign(r307A, bit_or(r307A, body.constant(1048576u)), 0x01));

         ir_variable *const r3184 = body.make_temp(glsl_type::uint_type, "z0Ptr");
         ir_variable *const r3185 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r3185, add(r307B, r3079), 0x01));

         ir_expression *const r3186 = add(r307A, r3078);
         ir_expression *const r3187 = less(r3185, r307B);
         ir_expression *const r3188 = expr(ir_unop_b2i, r3187);
         ir_expression *const r3189 = expr(ir_unop_i2u, r3188);
         body.emit(assign(r3184, add(r3186, r3189), 0x01));

         body.emit(assign(r307E, r3184, 0x01));

         body.emit(assign(r307C, add(r307C, body.constant(int(-1))), 0x01));

         /* IF CONDITION */
         ir_expression *const r318B = less(r3184, body.constant(2097152u));
         ir_if *f318A = new(mem_ctx) ir_if(operand(r318B).val);
         exec_list *const f318A_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f318A->then_instructions;

            ir_variable *const r318C = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r318C, r307C, 0x01));

            ir_variable *const r318D = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r318D, r3184, 0x01));

            ir_variable *const r318E = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r318E, r3185, 0x01));

            ir_variable *const r318F = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r318F, r307D, 0x01));

            ir_variable *const r3190 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r3190, body.constant(true), 0x01));

            ir_variable *const r3191 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r3192 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r3192);
            ir_expression *const r3193 = expr(ir_unop_u2i, r307D);
            body.emit(assign(r3192, less(r3193, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r3195 = lequal(body.constant(int(2045)), r307C);
            ir_if *f3194 = new(mem_ctx) ir_if(operand(r3195).val);
            exec_list *const f3194_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3194->then_instructions;

               ir_variable *const r3196 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r3198 = less(body.constant(int(2045)), r307C);
               ir_if *f3197 = new(mem_ctx) ir_if(operand(r3198).val);
               exec_list *const f3197_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3197->then_instructions;

                  body.emit(assign(r3196, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3197->else_instructions;

                  ir_variable *const r3199 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r319B = equal(r307C, body.constant(int(2045)));
                  ir_if *f319A = new(mem_ctx) ir_if(operand(r319B).val);
                  exec_list *const f319A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f319A->then_instructions;

                     ir_expression *const r319C = equal(body.constant(2097151u), r3184);
                     ir_expression *const r319D = equal(body.constant(4294967295u), r3185);
                     body.emit(assign(r3199, logic_and(r319C, r319D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f319A->else_instructions;

                     body.emit(assign(r3199, body.constant(false), 0x01));


                  body.instructions = f319A_parent_instructions;
                  body.emit(f319A);

                  /* END IF */

                  body.emit(assign(r3196, logic_and(r3199, r3192), 0x01));


               body.instructions = f3197_parent_instructions;
               body.emit(f3197);

               /* END IF */

               /* IF CONDITION */
               ir_if *f319E = new(mem_ctx) ir_if(operand(r3196).val);
               exec_list *const f319E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f319E->then_instructions;

                  ir_variable *const r319F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r319F);
                  ir_expression *const r31A0 = lshift(r2C5B, body.constant(int(31)));
                  body.emit(assign(r319F, add(r31A0, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r319F, body.constant(0u), 0x01));

                  body.emit(assign(r3191, r319F, 0x03));

                  body.emit(assign(r3190, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f319E->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r31A2 = less(r307C, body.constant(int(0)));
                  ir_if *f31A1 = new(mem_ctx) ir_if(operand(r31A2).val);
                  exec_list *const f31A1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f31A1->then_instructions;

                     ir_variable *const r31A3 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r31A3, r307D, 0x01));

                     ir_variable *const r31A4 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r31A4, neg(r307C), 0x01));

                     ir_variable *const r31A5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r31A5);
                     ir_variable *const r31A6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r31A6);
                     ir_variable *const r31A7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r31A7);
                     ir_variable *const r31A8 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r31A9 = neg(r31A4);
                     body.emit(assign(r31A8, bit_and(r31A9, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r31AB = equal(r31A4, body.constant(int(0)));
                     ir_if *f31AA = new(mem_ctx) ir_if(operand(r31AB).val);
                     exec_list *const f31AA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f31AA->then_instructions;

                        body.emit(assign(r31A5, r307D, 0x01));

                        body.emit(assign(r31A6, r3185, 0x01));

                        body.emit(assign(r31A7, r3184, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f31AA->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r31AD = less(r31A4, body.constant(int(32)));
                        ir_if *f31AC = new(mem_ctx) ir_if(operand(r31AD).val);
                        exec_list *const f31AC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f31AC->then_instructions;

                           body.emit(assign(r31A5, lshift(r3185, r31A8), 0x01));

                           ir_expression *const r31AE = lshift(r3184, r31A8);
                           ir_expression *const r31AF = rshift(r3185, r31A4);
                           body.emit(assign(r31A6, bit_or(r31AE, r31AF), 0x01));

                           body.emit(assign(r31A7, rshift(r3184, r31A4), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f31AC->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r31B1 = equal(r31A4, body.constant(int(32)));
                           ir_if *f31B0 = new(mem_ctx) ir_if(operand(r31B1).val);
                           exec_list *const f31B0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f31B0->then_instructions;

                              body.emit(assign(r31A5, r3185, 0x01));

                              body.emit(assign(r31A6, r3184, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f31B0->else_instructions;

                              body.emit(assign(r31A3, bit_or(r307D, r3185), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r31B3 = less(r31A4, body.constant(int(64)));
                              ir_if *f31B2 = new(mem_ctx) ir_if(operand(r31B3).val);
                              exec_list *const f31B2_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f31B2->then_instructions;

                                 body.emit(assign(r31A5, lshift(r3184, r31A8), 0x01));

                                 ir_expression *const r31B4 = bit_and(r31A4, body.constant(int(31)));
                                 body.emit(assign(r31A6, rshift(r3184, r31B4), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f31B2->else_instructions;

                                 ir_variable *const r31B5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r31B7 = equal(r31A4, body.constant(int(64)));
                                 ir_if *f31B6 = new(mem_ctx) ir_if(operand(r31B7).val);
                                 exec_list *const f31B6_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f31B6->then_instructions;

                                    body.emit(assign(r31B5, r3184, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f31B6->else_instructions;

                                    ir_expression *const r31B8 = nequal(r3184, body.constant(0u));
                                    ir_expression *const r31B9 = expr(ir_unop_b2i, r31B8);
                                    body.emit(assign(r31B5, expr(ir_unop_i2u, r31B9), 0x01));


                                 body.instructions = f31B6_parent_instructions;
                                 body.emit(f31B6);

                                 /* END IF */

                                 body.emit(assign(r31A5, r31B5, 0x01));

                                 body.emit(assign(r31A6, body.constant(0u), 0x01));


                              body.instructions = f31B2_parent_instructions;
                              body.emit(f31B2);

                              /* END IF */


                           body.instructions = f31B0_parent_instructions;
                           body.emit(f31B0);

                           /* END IF */

                           body.emit(assign(r31A7, body.constant(0u), 0x01));


                        body.instructions = f31AC_parent_instructions;
                        body.emit(f31AC);

                        /* END IF */

                        ir_expression *const r31BA = nequal(r31A3, body.constant(0u));
                        ir_expression *const r31BB = expr(ir_unop_b2i, r31BA);
                        ir_expression *const r31BC = expr(ir_unop_i2u, r31BB);
                        body.emit(assign(r31A5, bit_or(r31A5, r31BC), 0x01));


                     body.instructions = f31AA_parent_instructions;
                     body.emit(f31AA);

                     /* END IF */

                     body.emit(assign(r318D, r31A7, 0x01));

                     body.emit(assign(r318E, r31A6, 0x01));

                     body.emit(assign(r318F, r31A5, 0x01));

                     body.emit(assign(r318C, body.constant(int(0)), 0x01));

                     body.emit(assign(r3192, less(r31A5, body.constant(0u)), 0x01));


                  body.instructions = f31A1_parent_instructions;
                  body.emit(f31A1);

                  /* END IF */


               body.instructions = f319E_parent_instructions;
               body.emit(f319E);

               /* END IF */


            body.instructions = f3194_parent_instructions;
            body.emit(f3194);

            /* END IF */

            /* IF CONDITION */
            ir_if *f31BD = new(mem_ctx) ir_if(operand(r3190).val);
            exec_list *const f31BD_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f31BD->then_instructions;

               /* IF CONDITION */
               ir_if *f31BE = new(mem_ctx) ir_if(operand(r3192).val);
               exec_list *const f31BE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f31BE->then_instructions;

                  ir_variable *const r31BF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r31BF, add(r318E, body.constant(1u)), 0x01));

                  ir_expression *const r31C0 = less(r31BF, r318E);
                  ir_expression *const r31C1 = expr(ir_unop_b2i, r31C0);
                  ir_expression *const r31C2 = expr(ir_unop_i2u, r31C1);
                  body.emit(assign(r318D, add(r318D, r31C2), 0x01));

                  ir_expression *const r31C3 = equal(r318F, body.constant(0u));
                  ir_expression *const r31C4 = expr(ir_unop_b2i, r31C3);
                  ir_expression *const r31C5 = expr(ir_unop_i2u, r31C4);
                  ir_expression *const r31C6 = add(r318F, r31C5);
                  ir_expression *const r31C7 = bit_and(r31C6, body.constant(1u));
                  ir_expression *const r31C8 = expr(ir_unop_bit_not, r31C7);
                  body.emit(assign(r318E, bit_and(r31BF, r31C8), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f31BE->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r31CA = bit_or(r318D, r318E);
                  ir_expression *const r31CB = equal(r31CA, body.constant(0u));
                  ir_if *f31C9 = new(mem_ctx) ir_if(operand(r31CB).val);
                  exec_list *const f31C9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f31C9->then_instructions;

                     body.emit(assign(r318C, body.constant(int(0)), 0x01));


                  body.instructions = f31C9_parent_instructions;
                  body.emit(f31C9);

                  /* END IF */


               body.instructions = f31BE_parent_instructions;
               body.emit(f31BE);

               /* END IF */

               ir_variable *const r31CC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r31CC);
               ir_expression *const r31CD = lshift(r2C5B, body.constant(int(31)));
               ir_expression *const r31CE = expr(ir_unop_i2u, r318C);
               ir_expression *const r31CF = lshift(r31CE, body.constant(int(20)));
               ir_expression *const r31D0 = add(r31CD, r31CF);
               body.emit(assign(r31CC, add(r31D0, r318D), 0x02));

               body.emit(assign(r31CC, r318E, 0x01));

               body.emit(assign(r3191, r31CC, 0x03));

               body.emit(assign(r3190, body.constant(false), 0x01));


            body.instructions = f31BD_parent_instructions;
            body.emit(f31BD);

            /* END IF */

            body.emit(assign(r3076, r3191, 0x03));

            body.emit(assign(r3075, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f318A->else_instructions;

            body.emit(assign(r307C, add(r307C, body.constant(int(1))), 0x01));

            ir_variable *const r31D1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r31D1);
            ir_variable *const r31D2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r31D2);
            ir_variable *const r31D3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r31D3);
            body.emit(assign(r31D1, lshift(r3185, body.constant(int(31))), 0x01));

            ir_expression *const r31D4 = lshift(r3184, body.constant(int(31)));
            ir_expression *const r31D5 = rshift(r3185, body.constant(int(1)));
            body.emit(assign(r31D2, bit_or(r31D4, r31D5), 0x01));

            body.emit(assign(r31D3, rshift(r3184, body.constant(int(1))), 0x01));

            ir_expression *const r31D6 = nequal(r307D, body.constant(0u));
            ir_expression *const r31D7 = expr(ir_unop_b2i, r31D6);
            ir_expression *const r31D8 = expr(ir_unop_i2u, r31D7);
            body.emit(assign(r31D1, bit_or(r31D1, r31D8), 0x01));

            body.emit(assign(r307E, r31D3, 0x01));

            body.emit(assign(r307D, r31D1, 0x01));

            ir_variable *const r31D9 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r31D9, r307C, 0x01));

            ir_variable *const r31DA = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r31DA, r31D3, 0x01));

            ir_variable *const r31DB = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r31DB, r31D2, 0x01));

            ir_variable *const r31DC = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r31DC, r31D1, 0x01));

            ir_variable *const r31DD = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r31DD, body.constant(true), 0x01));

            ir_variable *const r31DE = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r31DF = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r31DF);
            ir_expression *const r31E0 = expr(ir_unop_u2i, r31D1);
            body.emit(assign(r31DF, less(r31E0, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r31E2 = lequal(body.constant(int(2045)), r307C);
            ir_if *f31E1 = new(mem_ctx) ir_if(operand(r31E2).val);
            exec_list *const f31E1_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f31E1->then_instructions;

               ir_variable *const r31E3 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r31E5 = less(body.constant(int(2045)), r307C);
               ir_if *f31E4 = new(mem_ctx) ir_if(operand(r31E5).val);
               exec_list *const f31E4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f31E4->then_instructions;

                  body.emit(assign(r31E3, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f31E4->else_instructions;

                  ir_variable *const r31E6 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r31E8 = equal(r307C, body.constant(int(2045)));
                  ir_if *f31E7 = new(mem_ctx) ir_if(operand(r31E8).val);
                  exec_list *const f31E7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f31E7->then_instructions;

                     ir_expression *const r31E9 = equal(body.constant(2097151u), r31D3);
                     ir_expression *const r31EA = equal(body.constant(4294967295u), r31D2);
                     body.emit(assign(r31E6, logic_and(r31E9, r31EA), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f31E7->else_instructions;

                     body.emit(assign(r31E6, body.constant(false), 0x01));


                  body.instructions = f31E7_parent_instructions;
                  body.emit(f31E7);

                  /* END IF */

                  body.emit(assign(r31E3, logic_and(r31E6, r31DF), 0x01));


               body.instructions = f31E4_parent_instructions;
               body.emit(f31E4);

               /* END IF */

               /* IF CONDITION */
               ir_if *f31EB = new(mem_ctx) ir_if(operand(r31E3).val);
               exec_list *const f31EB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f31EB->then_instructions;

                  ir_variable *const r31EC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r31EC);
                  ir_expression *const r31ED = lshift(r2C5B, body.constant(int(31)));
                  body.emit(assign(r31EC, add(r31ED, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r31EC, body.constant(0u), 0x01));

                  body.emit(assign(r31DE, r31EC, 0x03));

                  body.emit(assign(r31DD, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f31EB->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r31EF = less(r307C, body.constant(int(0)));
                  ir_if *f31EE = new(mem_ctx) ir_if(operand(r31EF).val);
                  exec_list *const f31EE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f31EE->then_instructions;

                     ir_variable *const r31F0 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r31F0, r31D1, 0x01));

                     ir_variable *const r31F1 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r31F1, neg(r307C), 0x01));

                     ir_variable *const r31F2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r31F2);
                     ir_variable *const r31F3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r31F3);
                     ir_variable *const r31F4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r31F4);
                     ir_variable *const r31F5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r31F6 = neg(r31F1);
                     body.emit(assign(r31F5, bit_and(r31F6, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r31F8 = equal(r31F1, body.constant(int(0)));
                     ir_if *f31F7 = new(mem_ctx) ir_if(operand(r31F8).val);
                     exec_list *const f31F7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f31F7->then_instructions;

                        body.emit(assign(r31F2, r31D1, 0x01));

                        body.emit(assign(r31F3, r31D2, 0x01));

                        body.emit(assign(r31F4, r31D3, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f31F7->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r31FA = less(r31F1, body.constant(int(32)));
                        ir_if *f31F9 = new(mem_ctx) ir_if(operand(r31FA).val);
                        exec_list *const f31F9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f31F9->then_instructions;

                           body.emit(assign(r31F2, lshift(r31D2, r31F5), 0x01));

                           ir_expression *const r31FB = lshift(r31D3, r31F5);
                           ir_expression *const r31FC = rshift(r31D2, r31F1);
                           body.emit(assign(r31F3, bit_or(r31FB, r31FC), 0x01));

                           body.emit(assign(r31F4, rshift(r31D3, r31F1), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f31F9->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r31FE = equal(r31F1, body.constant(int(32)));
                           ir_if *f31FD = new(mem_ctx) ir_if(operand(r31FE).val);
                           exec_list *const f31FD_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f31FD->then_instructions;

                              body.emit(assign(r31F2, r31D2, 0x01));

                              body.emit(assign(r31F3, r31D3, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f31FD->else_instructions;

                              body.emit(assign(r31F0, bit_or(r31D1, r31D2), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3200 = less(r31F1, body.constant(int(64)));
                              ir_if *f31FF = new(mem_ctx) ir_if(operand(r3200).val);
                              exec_list *const f31FF_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f31FF->then_instructions;

                                 body.emit(assign(r31F2, lshift(r31D3, r31F5), 0x01));

                                 ir_expression *const r3201 = bit_and(r31F1, body.constant(int(31)));
                                 body.emit(assign(r31F3, rshift(r31D3, r3201), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f31FF->else_instructions;

                                 ir_variable *const r3202 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r3204 = equal(r31F1, body.constant(int(64)));
                                 ir_if *f3203 = new(mem_ctx) ir_if(operand(r3204).val);
                                 exec_list *const f3203_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3203->then_instructions;

                                    body.emit(assign(r3202, r31D3, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3203->else_instructions;

                                    ir_expression *const r3205 = nequal(r31D3, body.constant(0u));
                                    ir_expression *const r3206 = expr(ir_unop_b2i, r3205);
                                    body.emit(assign(r3202, expr(ir_unop_i2u, r3206), 0x01));


                                 body.instructions = f3203_parent_instructions;
                                 body.emit(f3203);

                                 /* END IF */

                                 body.emit(assign(r31F2, r3202, 0x01));

                                 body.emit(assign(r31F3, body.constant(0u), 0x01));


                              body.instructions = f31FF_parent_instructions;
                              body.emit(f31FF);

                              /* END IF */


                           body.instructions = f31FD_parent_instructions;
                           body.emit(f31FD);

                           /* END IF */

                           body.emit(assign(r31F4, body.constant(0u), 0x01));


                        body.instructions = f31F9_parent_instructions;
                        body.emit(f31F9);

                        /* END IF */

                        ir_expression *const r3207 = nequal(r31F0, body.constant(0u));
                        ir_expression *const r3208 = expr(ir_unop_b2i, r3207);
                        ir_expression *const r3209 = expr(ir_unop_i2u, r3208);
                        body.emit(assign(r31F2, bit_or(r31F2, r3209), 0x01));


                     body.instructions = f31F7_parent_instructions;
                     body.emit(f31F7);

                     /* END IF */

                     body.emit(assign(r31DA, r31F4, 0x01));

                     body.emit(assign(r31DB, r31F3, 0x01));

                     body.emit(assign(r31DC, r31F2, 0x01));

                     body.emit(assign(r31D9, body.constant(int(0)), 0x01));

                     body.emit(assign(r31DF, less(r31F2, body.constant(0u)), 0x01));


                  body.instructions = f31EE_parent_instructions;
                  body.emit(f31EE);

                  /* END IF */


               body.instructions = f31EB_parent_instructions;
               body.emit(f31EB);

               /* END IF */


            body.instructions = f31E1_parent_instructions;
            body.emit(f31E1);

            /* END IF */

            /* IF CONDITION */
            ir_if *f320A = new(mem_ctx) ir_if(operand(r31DD).val);
            exec_list *const f320A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f320A->then_instructions;

               /* IF CONDITION */
               ir_if *f320B = new(mem_ctx) ir_if(operand(r31DF).val);
               exec_list *const f320B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f320B->then_instructions;

                  ir_variable *const r320C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r320C, add(r31DB, body.constant(1u)), 0x01));

                  ir_expression *const r320D = less(r320C, r31DB);
                  ir_expression *const r320E = expr(ir_unop_b2i, r320D);
                  ir_expression *const r320F = expr(ir_unop_i2u, r320E);
                  body.emit(assign(r31DA, add(r31DA, r320F), 0x01));

                  ir_expression *const r3210 = equal(r31DC, body.constant(0u));
                  ir_expression *const r3211 = expr(ir_unop_b2i, r3210);
                  ir_expression *const r3212 = expr(ir_unop_i2u, r3211);
                  ir_expression *const r3213 = add(r31DC, r3212);
                  ir_expression *const r3214 = bit_and(r3213, body.constant(1u));
                  ir_expression *const r3215 = expr(ir_unop_bit_not, r3214);
                  body.emit(assign(r31DB, bit_and(r320C, r3215), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f320B->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3217 = bit_or(r31DA, r31DB);
                  ir_expression *const r3218 = equal(r3217, body.constant(0u));
                  ir_if *f3216 = new(mem_ctx) ir_if(operand(r3218).val);
                  exec_list *const f3216_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3216->then_instructions;

                     body.emit(assign(r31D9, body.constant(int(0)), 0x01));


                  body.instructions = f3216_parent_instructions;
                  body.emit(f3216);

                  /* END IF */


               body.instructions = f320B_parent_instructions;
               body.emit(f320B);

               /* END IF */

               ir_variable *const r3219 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r3219);
               ir_expression *const r321A = lshift(r2C5B, body.constant(int(31)));
               ir_expression *const r321B = expr(ir_unop_i2u, r31D9);
               ir_expression *const r321C = lshift(r321B, body.constant(int(20)));
               ir_expression *const r321D = add(r321A, r321C);
               body.emit(assign(r3219, add(r321D, r31DA), 0x02));

               body.emit(assign(r3219, r31DB, 0x01));

               body.emit(assign(r31DE, r3219, 0x03));

               body.emit(assign(r31DD, body.constant(false), 0x01));


            body.instructions = f320A_parent_instructions;
            body.emit(f320A);

            /* END IF */

            body.emit(assign(r3076, r31DE, 0x03));

            body.emit(assign(r3075, body.constant(false), 0x01));


         body.instructions = f318A_parent_instructions;
         body.emit(f318A);

         /* END IF */


      body.instructions = f3183_parent_instructions;
      body.emit(f3183);

      /* END IF */

      body.emit(assign(r2C5A, r3076, 0x03));


   body.instructions = f2C5D_parent_instructions;
   body.emit(f2C5D);

   /* END IF */

   body.emit(ret(r2C5A));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fmod64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r321E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "x", ir_var_function_in);
   sig_parameters.push_tail(r321E);
   ir_variable *const r321F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "y", ir_var_function_in);
   sig_parameters.push_tail(r321F);
   ir_variable *const r3220 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r3220, body.constant(true), 0x01));

   ir_variable *const r3221 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r3222 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_auto);
   body.emit(r3222);
   ir_variable *const r3223 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
   body.emit(r3223);
   ir_variable *const r3224 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r3224);
   ir_variable *const r3225 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
   body.emit(r3225);
   ir_variable *const r3226 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
   body.emit(r3226);
   ir_variable *const r3227 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r3227);
   ir_variable *const r3228 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
   body.emit(r3228);
   ir_variable *const r3229 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem3", ir_var_auto);
   body.emit(r3229);
   ir_variable *const r322A = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem2", ir_var_auto);
   body.emit(r322A);
   ir_variable *const r322B = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
   body.emit(r322B);
   ir_variable *const r322C = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
   body.emit(r322C);
   ir_variable *const r322D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r322D);
   ir_variable *const r322E = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r322E);
   ir_variable *const r322F = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r322F);
   body.emit(assign(r322E, body.constant(0u), 0x01));

   body.emit(assign(r322D, body.constant(0u), 0x01));

   body.emit(assign(r322C, body.constant(0u), 0x01));

   body.emit(assign(r322B, body.constant(0u), 0x01));

   body.emit(assign(r322A, body.constant(0u), 0x01));

   body.emit(assign(r3229, body.constant(0u), 0x01));

   ir_variable *const r3230 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r3230, swizzle_x(r321E), 0x01));

   body.emit(assign(r3228, r3230, 0x01));

   ir_variable *const r3231 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r3231, bit_and(swizzle_y(r321E), body.constant(1048575u)), 0x01));

   body.emit(assign(r3227, r3231, 0x01));

   ir_variable *const r3232 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r3232, swizzle_x(r321F), 0x01));

   body.emit(assign(r3226, r3232, 0x01));

   ir_variable *const r3233 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r3233, bit_and(swizzle_y(r321F), body.constant(1048575u)), 0x01));

   body.emit(assign(r3225, r3233, 0x01));

   ir_variable *const r3234 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r3235 = rshift(swizzle_y(r321E), body.constant(int(20)));
   ir_expression *const r3236 = bit_and(r3235, body.constant(2047u));
   body.emit(assign(r3234, expr(ir_unop_u2i, r3236), 0x01));

   body.emit(assign(r3224, r3234, 0x01));

   ir_variable *const r3237 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r3238 = rshift(swizzle_y(r321F), body.constant(int(20)));
   ir_expression *const r3239 = bit_and(r3238, body.constant(2047u));
   body.emit(assign(r3237, expr(ir_unop_u2i, r3239), 0x01));

   body.emit(assign(r3223, r3237, 0x01));

   ir_expression *const r323A = rshift(swizzle_y(r321E), body.constant(int(31)));
   ir_expression *const r323B = rshift(swizzle_y(r321F), body.constant(int(31)));
   body.emit(assign(r3222, bit_xor(r323A, r323B), 0x01));

   /* IF CONDITION */
   ir_expression *const r323D = equal(r3234, body.constant(int(2047)));
   ir_if *f323C = new(mem_ctx) ir_if(operand(r323D).val);
   exec_list *const f323C_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f323C->then_instructions;

      /* IF CONDITION */
      ir_expression *const r323F = bit_or(r3231, swizzle_x(r321E));
      ir_expression *const r3240 = nequal(r323F, body.constant(0u));
      ir_if *f323E = new(mem_ctx) ir_if(operand(r3240).val);
      exec_list *const f323E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f323E->then_instructions;

         ir_variable *const r3241 = body.make_temp(glsl_type::uvec2_type, "a");
         body.emit(assign(r3241, swizzle_x(r321E), 0x01));

         ir_variable *const r3242 = body.make_temp(glsl_type::uvec2_type, "b");
         body.emit(assign(r3242, swizzle_x(r321F), 0x01));

         ir_variable *const r3243 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r3244 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
         ir_expression *const r3245 = rshift(swizzle_y(r321E), body.constant(int(19)));
         ir_expression *const r3246 = bit_and(r3245, body.constant(4095u));
         ir_expression *const r3247 = equal(r3246, body.constant(4094u));
         ir_expression *const r3248 = nequal(swizzle_x(r321E), body.constant(0u));
         ir_expression *const r3249 = bit_and(swizzle_y(r321E), body.constant(524287u));
         ir_expression *const r324A = nequal(r3249, body.constant(0u));
         ir_expression *const r324B = logic_or(r3248, r324A);
         body.emit(assign(r3244, logic_and(r3247, r324B), 0x01));

         ir_variable *const r324C = body.make_temp(glsl_type::bool_type, "is_nan_retval");
         ir_expression *const r324D = lshift(swizzle_y(r321F), body.constant(int(1)));
         ir_expression *const r324E = lequal(body.constant(4292870144u), r324D);
         ir_expression *const r324F = nequal(swizzle_x(r321F), body.constant(0u));
         ir_expression *const r3250 = bit_and(swizzle_y(r321F), body.constant(1048575u));
         ir_expression *const r3251 = nequal(r3250, body.constant(0u));
         ir_expression *const r3252 = logic_or(r324F, r3251);
         body.emit(assign(r324C, logic_and(r324E, r3252), 0x01));

         body.emit(assign(r3241, bit_or(swizzle_y(r321E), body.constant(524288u)), 0x02));

         body.emit(assign(r3242, bit_or(swizzle_y(r321F), body.constant(524288u)), 0x02));

         /* IF CONDITION */
         ir_expression *const r3254 = lshift(swizzle_y(r321E), body.constant(int(1)));
         ir_expression *const r3255 = lequal(body.constant(4292870144u), r3254);
         ir_expression *const r3256 = nequal(swizzle_x(r321E), body.constant(0u));
         ir_expression *const r3257 = bit_and(swizzle_y(r321E), body.constant(1048575u));
         ir_expression *const r3258 = nequal(r3257, body.constant(0u));
         ir_expression *const r3259 = logic_or(r3256, r3258);
         ir_expression *const r325A = logic_and(r3255, r3259);
         ir_if *f3253 = new(mem_ctx) ir_if(operand(r325A).val);
         exec_list *const f3253_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3253->then_instructions;

            ir_variable *const r325B = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r325D = logic_and(r3244, r324C);
            ir_if *f325C = new(mem_ctx) ir_if(operand(r325D).val);
            exec_list *const f325C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f325C->then_instructions;

               body.emit(assign(r325B, r3242, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f325C->else_instructions;

               body.emit(assign(r325B, r3241, 0x03));


            body.instructions = f325C_parent_instructions;
            body.emit(f325C);

            /* END IF */

            body.emit(assign(r3243, r325B, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3253->else_instructions;

            body.emit(assign(r3243, r3242, 0x03));


         body.instructions = f3253_parent_instructions;
         body.emit(f3253);

         /* END IF */

         body.emit(assign(r3221, r3243, 0x03));

         body.emit(assign(r3220, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f323E->else_instructions;

         /* IF CONDITION */
         ir_expression *const r325F = equal(r3237, body.constant(int(2047)));
         ir_if *f325E = new(mem_ctx) ir_if(operand(r325F).val);
         exec_list *const f325E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f325E->then_instructions;

            /* IF CONDITION */
            ir_expression *const r3261 = bit_or(r3233, swizzle_x(r321F));
            ir_expression *const r3262 = nequal(r3261, body.constant(0u));
            ir_if *f3260 = new(mem_ctx) ir_if(operand(r3262).val);
            exec_list *const f3260_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3260->then_instructions;

               ir_variable *const r3263 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r3263, swizzle_x(r321E), 0x01));

               ir_variable *const r3264 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r3264, swizzle_x(r321F), 0x01));

               ir_variable *const r3265 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r3266 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r3267 = rshift(swizzle_y(r321E), body.constant(int(19)));
               ir_expression *const r3268 = bit_and(r3267, body.constant(4095u));
               ir_expression *const r3269 = equal(r3268, body.constant(4094u));
               ir_expression *const r326A = nequal(swizzle_x(r321E), body.constant(0u));
               ir_expression *const r326B = bit_and(swizzle_y(r321E), body.constant(524287u));
               ir_expression *const r326C = nequal(r326B, body.constant(0u));
               ir_expression *const r326D = logic_or(r326A, r326C);
               body.emit(assign(r3266, logic_and(r3269, r326D), 0x01));

               ir_variable *const r326E = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r326F = lshift(swizzle_y(r321F), body.constant(int(1)));
               ir_expression *const r3270 = lequal(body.constant(4292870144u), r326F);
               ir_expression *const r3271 = nequal(swizzle_x(r321F), body.constant(0u));
               ir_expression *const r3272 = bit_and(swizzle_y(r321F), body.constant(1048575u));
               ir_expression *const r3273 = nequal(r3272, body.constant(0u));
               ir_expression *const r3274 = logic_or(r3271, r3273);
               body.emit(assign(r326E, logic_and(r3270, r3274), 0x01));

               body.emit(assign(r3263, bit_or(swizzle_y(r321E), body.constant(524288u)), 0x02));

               body.emit(assign(r3264, bit_or(swizzle_y(r321F), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r3276 = lshift(swizzle_y(r321E), body.constant(int(1)));
               ir_expression *const r3277 = lequal(body.constant(4292870144u), r3276);
               ir_expression *const r3278 = nequal(swizzle_x(r321E), body.constant(0u));
               ir_expression *const r3279 = bit_and(swizzle_y(r321E), body.constant(1048575u));
               ir_expression *const r327A = nequal(r3279, body.constant(0u));
               ir_expression *const r327B = logic_or(r3278, r327A);
               ir_expression *const r327C = logic_and(r3277, r327B);
               ir_if *f3275 = new(mem_ctx) ir_if(operand(r327C).val);
               exec_list *const f3275_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3275->then_instructions;

                  ir_variable *const r327D = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r327F = logic_and(r3266, r326E);
                  ir_if *f327E = new(mem_ctx) ir_if(operand(r327F).val);
                  exec_list *const f327E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f327E->then_instructions;

                     body.emit(assign(r327D, r3264, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f327E->else_instructions;

                     body.emit(assign(r327D, r3263, 0x03));


                  body.instructions = f327E_parent_instructions;
                  body.emit(f327E);

                  /* END IF */

                  body.emit(assign(r3265, r327D, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3275->else_instructions;

                  body.emit(assign(r3265, r3264, 0x03));


               body.instructions = f3275_parent_instructions;
               body.emit(f3275);

               /* END IF */

               body.emit(assign(r3221, r3265, 0x03));

               body.emit(assign(r3220, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3260->else_instructions;

               ir_constant_data r3280_data;
               memset(&r3280_data, 0, sizeof(ir_constant_data));
               r3280_data.u[0] = 4294967295;
               r3280_data.u[1] = 4294967295;
               ir_constant *const r3280 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r3280_data);
               body.emit(assign(r3221, r3280, 0x03));

               body.emit(assign(r3220, body.constant(false), 0x01));


            body.instructions = f3260_parent_instructions;
            body.emit(f3260);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f325E->else_instructions;

            ir_variable *const r3281 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r3281);
            ir_expression *const r3282 = lshift(r3222, body.constant(int(31)));
            body.emit(assign(r3281, add(r3282, body.constant(2146435072u)), 0x02));

            body.emit(assign(r3281, body.constant(0u), 0x01));

            body.emit(assign(r3221, r3281, 0x03));

            body.emit(assign(r3220, body.constant(false), 0x01));


         body.instructions = f325E_parent_instructions;
         body.emit(f325E);

         /* END IF */


      body.instructions = f323E_parent_instructions;
      body.emit(f323E);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f323C->else_instructions;

      /* IF CONDITION */
      ir_expression *const r3284 = equal(r3237, body.constant(int(2047)));
      ir_if *f3283 = new(mem_ctx) ir_if(operand(r3284).val);
      exec_list *const f3283_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f3283->then_instructions;

         /* IF CONDITION */
         ir_expression *const r3286 = bit_or(r3233, swizzle_x(r321F));
         ir_expression *const r3287 = nequal(r3286, body.constant(0u));
         ir_if *f3285 = new(mem_ctx) ir_if(operand(r3287).val);
         exec_list *const f3285_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3285->then_instructions;

            ir_variable *const r3288 = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r3288, swizzle_x(r321E), 0x01));

            ir_variable *const r3289 = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r3289, swizzle_x(r321F), 0x01));

            ir_variable *const r328A = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r328B = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r328C = rshift(swizzle_y(r321E), body.constant(int(19)));
            ir_expression *const r328D = bit_and(r328C, body.constant(4095u));
            ir_expression *const r328E = equal(r328D, body.constant(4094u));
            ir_expression *const r328F = nequal(swizzle_x(r321E), body.constant(0u));
            ir_expression *const r3290 = bit_and(swizzle_y(r321E), body.constant(524287u));
            ir_expression *const r3291 = nequal(r3290, body.constant(0u));
            ir_expression *const r3292 = logic_or(r328F, r3291);
            body.emit(assign(r328B, logic_and(r328E, r3292), 0x01));

            ir_variable *const r3293 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r3294 = lshift(swizzle_y(r321F), body.constant(int(1)));
            ir_expression *const r3295 = lequal(body.constant(4292870144u), r3294);
            ir_expression *const r3296 = nequal(swizzle_x(r321F), body.constant(0u));
            ir_expression *const r3297 = bit_and(swizzle_y(r321F), body.constant(1048575u));
            ir_expression *const r3298 = nequal(r3297, body.constant(0u));
            ir_expression *const r3299 = logic_or(r3296, r3298);
            body.emit(assign(r3293, logic_and(r3295, r3299), 0x01));

            body.emit(assign(r3288, bit_or(swizzle_y(r321E), body.constant(524288u)), 0x02));

            body.emit(assign(r3289, bit_or(swizzle_y(r321F), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r329B = lshift(swizzle_y(r321E), body.constant(int(1)));
            ir_expression *const r329C = lequal(body.constant(4292870144u), r329B);
            ir_expression *const r329D = nequal(swizzle_x(r321E), body.constant(0u));
            ir_expression *const r329E = bit_and(swizzle_y(r321E), body.constant(1048575u));
            ir_expression *const r329F = nequal(r329E, body.constant(0u));
            ir_expression *const r32A0 = logic_or(r329D, r329F);
            ir_expression *const r32A1 = logic_and(r329C, r32A0);
            ir_if *f329A = new(mem_ctx) ir_if(operand(r32A1).val);
            exec_list *const f329A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f329A->then_instructions;

               ir_variable *const r32A2 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r32A4 = logic_and(r328B, r3293);
               ir_if *f32A3 = new(mem_ctx) ir_if(operand(r32A4).val);
               exec_list *const f32A3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f32A3->then_instructions;

                  body.emit(assign(r32A2, r3289, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f32A3->else_instructions;

                  body.emit(assign(r32A2, r3288, 0x03));


               body.instructions = f32A3_parent_instructions;
               body.emit(f32A3);

               /* END IF */

               body.emit(assign(r328A, r32A2, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f329A->else_instructions;

               body.emit(assign(r328A, r3289, 0x03));


            body.instructions = f329A_parent_instructions;
            body.emit(f329A);

            /* END IF */

            body.emit(assign(r3221, r328A, 0x03));

            body.emit(assign(r3220, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3285->else_instructions;

            ir_variable *const r32A5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r32A5);
            body.emit(assign(r32A5, lshift(r3222, body.constant(int(31))), 0x02));

            body.emit(assign(r32A5, body.constant(0u), 0x01));

            body.emit(assign(r3221, r32A5, 0x03));

            body.emit(assign(r3220, body.constant(false), 0x01));


         body.instructions = f3285_parent_instructions;
         body.emit(f3285);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f3283->else_instructions;

         /* IF CONDITION */
         ir_expression *const r32A7 = equal(r3237, body.constant(int(0)));
         ir_if *f32A6 = new(mem_ctx) ir_if(operand(r32A7).val);
         exec_list *const f32A6_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f32A6->then_instructions;

            /* IF CONDITION */
            ir_expression *const r32A9 = bit_or(r3233, swizzle_x(r321F));
            ir_expression *const r32AA = equal(r32A9, body.constant(0u));
            ir_if *f32A8 = new(mem_ctx) ir_if(operand(r32AA).val);
            exec_list *const f32A8_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f32A8->then_instructions;

               /* IF CONDITION */
               ir_expression *const r32AC = expr(ir_unop_i2u, r3234);
               ir_expression *const r32AD = bit_or(r32AC, r3231);
               ir_expression *const r32AE = bit_or(r32AD, swizzle_x(r321E));
               ir_expression *const r32AF = equal(r32AE, body.constant(0u));
               ir_if *f32AB = new(mem_ctx) ir_if(operand(r32AF).val);
               exec_list *const f32AB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f32AB->then_instructions;

                  ir_constant_data r32B0_data;
                  memset(&r32B0_data, 0, sizeof(ir_constant_data));
                  r32B0_data.u[0] = 4294967295;
                  r32B0_data.u[1] = 4294967295;
                  ir_constant *const r32B0 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r32B0_data);
                  body.emit(assign(r3221, r32B0, 0x03));

                  body.emit(assign(r3220, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f32AB->else_instructions;

                  ir_variable *const r32B1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r32B1);
                  ir_expression *const r32B2 = lshift(r3222, body.constant(int(31)));
                  body.emit(assign(r32B1, add(r32B2, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r32B1, body.constant(0u), 0x01));

                  body.emit(assign(r3221, r32B1, 0x03));

                  body.emit(assign(r3220, body.constant(false), 0x01));


               body.instructions = f32AB_parent_instructions;
               body.emit(f32AB);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f32A8->else_instructions;

               ir_variable *const r32B3 = body.make_temp(glsl_type::int_type, "zExpPtr");
               body.emit(assign(r32B3, r3237, 0x01));

               ir_variable *const r32B4 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
               body.emit(assign(r32B4, r3233, 0x01));

               ir_variable *const r32B5 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
               body.emit(assign(r32B5, r3232, 0x01));

               ir_variable *const r32B6 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r32B6);
               /* IF CONDITION */
               ir_expression *const r32B8 = equal(r3233, body.constant(0u));
               ir_if *f32B7 = new(mem_ctx) ir_if(operand(r32B8).val);
               exec_list *const f32B7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f32B7->then_instructions;

                  ir_variable *const r32B9 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r32B9, r3232, 0x01));

                  ir_variable *const r32BA = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r32BB = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r32BB);
                  /* IF CONDITION */
                  ir_expression *const r32BD = equal(swizzle_x(r321F), body.constant(0u));
                  ir_if *f32BC = new(mem_ctx) ir_if(operand(r32BD).val);
                  exec_list *const f32BC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f32BC->then_instructions;

                     body.emit(assign(r32BA, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f32BC->else_instructions;

                     body.emit(assign(r32BB, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r32BF = bit_and(swizzle_x(r321F), body.constant(4294901760u));
                     ir_expression *const r32C0 = equal(r32BF, body.constant(0u));
                     ir_if *f32BE = new(mem_ctx) ir_if(operand(r32C0).val);
                     exec_list *const f32BE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32BE->then_instructions;

                        body.emit(assign(r32BB, body.constant(int(16)), 0x01));

                        body.emit(assign(r32B9, lshift(swizzle_x(r321F), body.constant(int(16))), 0x01));


                     body.instructions = f32BE_parent_instructions;
                     body.emit(f32BE);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r32C2 = bit_and(r32B9, body.constant(4278190080u));
                     ir_expression *const r32C3 = equal(r32C2, body.constant(0u));
                     ir_if *f32C1 = new(mem_ctx) ir_if(operand(r32C3).val);
                     exec_list *const f32C1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32C1->then_instructions;

                        body.emit(assign(r32BB, add(r32BB, body.constant(int(8))), 0x01));

                        body.emit(assign(r32B9, lshift(r32B9, body.constant(int(8))), 0x01));


                     body.instructions = f32C1_parent_instructions;
                     body.emit(f32C1);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r32C5 = bit_and(r32B9, body.constant(4026531840u));
                     ir_expression *const r32C6 = equal(r32C5, body.constant(0u));
                     ir_if *f32C4 = new(mem_ctx) ir_if(operand(r32C6).val);
                     exec_list *const f32C4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32C4->then_instructions;

                        body.emit(assign(r32BB, add(r32BB, body.constant(int(4))), 0x01));

                        body.emit(assign(r32B9, lshift(r32B9, body.constant(int(4))), 0x01));


                     body.instructions = f32C4_parent_instructions;
                     body.emit(f32C4);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r32C8 = bit_and(r32B9, body.constant(3221225472u));
                     ir_expression *const r32C9 = equal(r32C8, body.constant(0u));
                     ir_if *f32C7 = new(mem_ctx) ir_if(operand(r32C9).val);
                     exec_list *const f32C7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32C7->then_instructions;

                        body.emit(assign(r32BB, add(r32BB, body.constant(int(2))), 0x01));

                        body.emit(assign(r32B9, lshift(r32B9, body.constant(int(2))), 0x01));


                     body.instructions = f32C7_parent_instructions;
                     body.emit(f32C7);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r32CB = bit_and(r32B9, body.constant(2147483648u));
                     ir_expression *const r32CC = equal(r32CB, body.constant(0u));
                     ir_if *f32CA = new(mem_ctx) ir_if(operand(r32CC).val);
                     exec_list *const f32CA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32CA->then_instructions;

                        body.emit(assign(r32BB, add(r32BB, body.constant(int(1))), 0x01));


                     body.instructions = f32CA_parent_instructions;
                     body.emit(f32CA);

                     /* END IF */

                     body.emit(assign(r32BA, r32BB, 0x01));


                  body.instructions = f32BC_parent_instructions;
                  body.emit(f32BC);

                  /* END IF */

                  body.emit(assign(r32B6, add(r32BA, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r32CE = less(r32B6, body.constant(int(0)));
                  ir_if *f32CD = new(mem_ctx) ir_if(operand(r32CE).val);
                  exec_list *const f32CD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f32CD->then_instructions;

                     ir_expression *const r32CF = neg(r32B6);
                     body.emit(assign(r32B4, rshift(swizzle_x(r321F), r32CF), 0x01));

                     ir_expression *const r32D0 = bit_and(r32B6, body.constant(int(31)));
                     body.emit(assign(r32B5, lshift(swizzle_x(r321F), r32D0), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f32CD->else_instructions;

                     body.emit(assign(r32B4, lshift(swizzle_x(r321F), r32B6), 0x01));

                     body.emit(assign(r32B5, body.constant(0u), 0x01));


                  body.instructions = f32CD_parent_instructions;
                  body.emit(f32CD);

                  /* END IF */

                  body.emit(assign(r32B3, sub(body.constant(int(-31)), r32B6), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f32B7->else_instructions;

                  ir_variable *const r32D1 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r32D1, r3233, 0x01));

                  ir_variable *const r32D2 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r32D3 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r32D3);
                  /* IF CONDITION */
                  ir_expression *const r32D5 = equal(r3233, body.constant(0u));
                  ir_if *f32D4 = new(mem_ctx) ir_if(operand(r32D5).val);
                  exec_list *const f32D4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f32D4->then_instructions;

                     body.emit(assign(r32D2, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f32D4->else_instructions;

                     body.emit(assign(r32D3, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r32D7 = bit_and(r3233, body.constant(4294901760u));
                     ir_expression *const r32D8 = equal(r32D7, body.constant(0u));
                     ir_if *f32D6 = new(mem_ctx) ir_if(operand(r32D8).val);
                     exec_list *const f32D6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32D6->then_instructions;

                        body.emit(assign(r32D3, body.constant(int(16)), 0x01));

                        body.emit(assign(r32D1, lshift(r3233, body.constant(int(16))), 0x01));


                     body.instructions = f32D6_parent_instructions;
                     body.emit(f32D6);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r32DA = bit_and(r32D1, body.constant(4278190080u));
                     ir_expression *const r32DB = equal(r32DA, body.constant(0u));
                     ir_if *f32D9 = new(mem_ctx) ir_if(operand(r32DB).val);
                     exec_list *const f32D9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32D9->then_instructions;

                        body.emit(assign(r32D3, add(r32D3, body.constant(int(8))), 0x01));

                        body.emit(assign(r32D1, lshift(r32D1, body.constant(int(8))), 0x01));


                     body.instructions = f32D9_parent_instructions;
                     body.emit(f32D9);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r32DD = bit_and(r32D1, body.constant(4026531840u));
                     ir_expression *const r32DE = equal(r32DD, body.constant(0u));
                     ir_if *f32DC = new(mem_ctx) ir_if(operand(r32DE).val);
                     exec_list *const f32DC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32DC->then_instructions;

                        body.emit(assign(r32D3, add(r32D3, body.constant(int(4))), 0x01));

                        body.emit(assign(r32D1, lshift(r32D1, body.constant(int(4))), 0x01));


                     body.instructions = f32DC_parent_instructions;
                     body.emit(f32DC);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r32E0 = bit_and(r32D1, body.constant(3221225472u));
                     ir_expression *const r32E1 = equal(r32E0, body.constant(0u));
                     ir_if *f32DF = new(mem_ctx) ir_if(operand(r32E1).val);
                     exec_list *const f32DF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32DF->then_instructions;

                        body.emit(assign(r32D3, add(r32D3, body.constant(int(2))), 0x01));

                        body.emit(assign(r32D1, lshift(r32D1, body.constant(int(2))), 0x01));


                     body.instructions = f32DF_parent_instructions;
                     body.emit(f32DF);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r32E3 = bit_and(r32D1, body.constant(2147483648u));
                     ir_expression *const r32E4 = equal(r32E3, body.constant(0u));
                     ir_if *f32E2 = new(mem_ctx) ir_if(operand(r32E4).val);
                     exec_list *const f32E2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32E2->then_instructions;

                        body.emit(assign(r32D3, add(r32D3, body.constant(int(1))), 0x01));


                     body.instructions = f32E2_parent_instructions;
                     body.emit(f32E2);

                     /* END IF */

                     body.emit(assign(r32D2, r32D3, 0x01));


                  body.instructions = f32D4_parent_instructions;
                  body.emit(f32D4);

                  /* END IF */

                  body.emit(assign(r32B6, add(r32D2, body.constant(int(-11))), 0x01));

                  ir_variable *const r32E5 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r32E5, lshift(swizzle_x(r321F), r32B6), 0x01));

                  ir_variable *const r32E6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r32E8 = equal(r32B6, body.constant(int(0)));
                  ir_if *f32E7 = new(mem_ctx) ir_if(operand(r32E8).val);
                  exec_list *const f32E7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f32E7->then_instructions;

                     body.emit(assign(r32E6, r3233, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f32E7->else_instructions;

                     ir_expression *const r32E9 = lshift(r3233, r32B6);
                     ir_expression *const r32EA = neg(r32B6);
                     ir_expression *const r32EB = bit_and(r32EA, body.constant(int(31)));
                     ir_expression *const r32EC = rshift(swizzle_x(r321F), r32EB);
                     body.emit(assign(r32E6, bit_or(r32E9, r32EC), 0x01));


                  body.instructions = f32E7_parent_instructions;
                  body.emit(f32E7);

                  /* END IF */

                  body.emit(assign(r32B4, r32E6, 0x01));

                  body.emit(assign(r32B5, r32E5, 0x01));

                  body.emit(assign(r32B3, sub(body.constant(int(1)), r32B6), 0x01));


               body.instructions = f32B7_parent_instructions;
               body.emit(f32B7);

               /* END IF */

               body.emit(assign(r3223, r32B3, 0x01));

               body.emit(assign(r3225, r32B4, 0x01));

               body.emit(assign(r3226, r32B5, 0x01));


            body.instructions = f32A8_parent_instructions;
            body.emit(f32A8);

            /* END IF */


         body.instructions = f32A6_parent_instructions;
         body.emit(f32A6);

         /* END IF */

         /* IF CONDITION */
         ir_if *f32ED = new(mem_ctx) ir_if(operand(r3220).val);
         exec_list *const f32ED_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f32ED->then_instructions;

            /* IF CONDITION */
            ir_expression *const r32EF = equal(r3234, body.constant(int(0)));
            ir_if *f32EE = new(mem_ctx) ir_if(operand(r32EF).val);
            exec_list *const f32EE_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f32EE->then_instructions;

               /* IF CONDITION */
               ir_expression *const r32F1 = bit_or(r3231, swizzle_x(r321E));
               ir_expression *const r32F2 = equal(r32F1, body.constant(0u));
               ir_if *f32F0 = new(mem_ctx) ir_if(operand(r32F2).val);
               exec_list *const f32F0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f32F0->then_instructions;

                  ir_variable *const r32F3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r32F3);
                  body.emit(assign(r32F3, lshift(r3222, body.constant(int(31))), 0x02));

                  body.emit(assign(r32F3, body.constant(0u), 0x01));

                  body.emit(assign(r3221, r32F3, 0x03));

                  body.emit(assign(r3220, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f32F0->else_instructions;

                  ir_variable *const r32F4 = body.make_temp(glsl_type::int_type, "zExpPtr");
                  body.emit(assign(r32F4, r3234, 0x01));

                  ir_variable *const r32F5 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
                  body.emit(assign(r32F5, r3231, 0x01));

                  ir_variable *const r32F6 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
                  body.emit(assign(r32F6, r3230, 0x01));

                  ir_variable *const r32F7 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r32F7);
                  /* IF CONDITION */
                  ir_expression *const r32F9 = equal(r3231, body.constant(0u));
                  ir_if *f32F8 = new(mem_ctx) ir_if(operand(r32F9).val);
                  exec_list *const f32F8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f32F8->then_instructions;

                     ir_variable *const r32FA = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r32FA, r3230, 0x01));

                     ir_variable *const r32FB = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r32FC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r32FC);
                     /* IF CONDITION */
                     ir_expression *const r32FE = equal(swizzle_x(r321E), body.constant(0u));
                     ir_if *f32FD = new(mem_ctx) ir_if(operand(r32FE).val);
                     exec_list *const f32FD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32FD->then_instructions;

                        body.emit(assign(r32FB, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f32FD->else_instructions;

                        body.emit(assign(r32FC, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3300 = bit_and(swizzle_x(r321E), body.constant(4294901760u));
                        ir_expression *const r3301 = equal(r3300, body.constant(0u));
                        ir_if *f32FF = new(mem_ctx) ir_if(operand(r3301).val);
                        exec_list *const f32FF_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f32FF->then_instructions;

                           body.emit(assign(r32FC, body.constant(int(16)), 0x01));

                           body.emit(assign(r32FA, lshift(swizzle_x(r321E), body.constant(int(16))), 0x01));


                        body.instructions = f32FF_parent_instructions;
                        body.emit(f32FF);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3303 = bit_and(r32FA, body.constant(4278190080u));
                        ir_expression *const r3304 = equal(r3303, body.constant(0u));
                        ir_if *f3302 = new(mem_ctx) ir_if(operand(r3304).val);
                        exec_list *const f3302_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3302->then_instructions;

                           body.emit(assign(r32FC, add(r32FC, body.constant(int(8))), 0x01));

                           body.emit(assign(r32FA, lshift(r32FA, body.constant(int(8))), 0x01));


                        body.instructions = f3302_parent_instructions;
                        body.emit(f3302);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3306 = bit_and(r32FA, body.constant(4026531840u));
                        ir_expression *const r3307 = equal(r3306, body.constant(0u));
                        ir_if *f3305 = new(mem_ctx) ir_if(operand(r3307).val);
                        exec_list *const f3305_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3305->then_instructions;

                           body.emit(assign(r32FC, add(r32FC, body.constant(int(4))), 0x01));

                           body.emit(assign(r32FA, lshift(r32FA, body.constant(int(4))), 0x01));


                        body.instructions = f3305_parent_instructions;
                        body.emit(f3305);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3309 = bit_and(r32FA, body.constant(3221225472u));
                        ir_expression *const r330A = equal(r3309, body.constant(0u));
                        ir_if *f3308 = new(mem_ctx) ir_if(operand(r330A).val);
                        exec_list *const f3308_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3308->then_instructions;

                           body.emit(assign(r32FC, add(r32FC, body.constant(int(2))), 0x01));

                           body.emit(assign(r32FA, lshift(r32FA, body.constant(int(2))), 0x01));


                        body.instructions = f3308_parent_instructions;
                        body.emit(f3308);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r330C = bit_and(r32FA, body.constant(2147483648u));
                        ir_expression *const r330D = equal(r330C, body.constant(0u));
                        ir_if *f330B = new(mem_ctx) ir_if(operand(r330D).val);
                        exec_list *const f330B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f330B->then_instructions;

                           body.emit(assign(r32FC, add(r32FC, body.constant(int(1))), 0x01));


                        body.instructions = f330B_parent_instructions;
                        body.emit(f330B);

                        /* END IF */

                        body.emit(assign(r32FB, r32FC, 0x01));


                     body.instructions = f32FD_parent_instructions;
                     body.emit(f32FD);

                     /* END IF */

                     body.emit(assign(r32F7, add(r32FB, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r330F = less(r32F7, body.constant(int(0)));
                     ir_if *f330E = new(mem_ctx) ir_if(operand(r330F).val);
                     exec_list *const f330E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f330E->then_instructions;

                        ir_expression *const r3310 = neg(r32F7);
                        body.emit(assign(r32F5, rshift(swizzle_x(r321E), r3310), 0x01));

                        ir_expression *const r3311 = bit_and(r32F7, body.constant(int(31)));
                        body.emit(assign(r32F6, lshift(swizzle_x(r321E), r3311), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f330E->else_instructions;

                        body.emit(assign(r32F5, lshift(swizzle_x(r321E), r32F7), 0x01));

                        body.emit(assign(r32F6, body.constant(0u), 0x01));


                     body.instructions = f330E_parent_instructions;
                     body.emit(f330E);

                     /* END IF */

                     body.emit(assign(r32F4, sub(body.constant(int(-31)), r32F7), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f32F8->else_instructions;

                     ir_variable *const r3312 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r3312, r3231, 0x01));

                     ir_variable *const r3313 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r3314 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r3314);
                     /* IF CONDITION */
                     ir_expression *const r3316 = equal(r3231, body.constant(0u));
                     ir_if *f3315 = new(mem_ctx) ir_if(operand(r3316).val);
                     exec_list *const f3315_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3315->then_instructions;

                        body.emit(assign(r3313, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3315->else_instructions;

                        body.emit(assign(r3314, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3318 = bit_and(r3231, body.constant(4294901760u));
                        ir_expression *const r3319 = equal(r3318, body.constant(0u));
                        ir_if *f3317 = new(mem_ctx) ir_if(operand(r3319).val);
                        exec_list *const f3317_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3317->then_instructions;

                           body.emit(assign(r3314, body.constant(int(16)), 0x01));

                           body.emit(assign(r3312, lshift(r3231, body.constant(int(16))), 0x01));


                        body.instructions = f3317_parent_instructions;
                        body.emit(f3317);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r331B = bit_and(r3312, body.constant(4278190080u));
                        ir_expression *const r331C = equal(r331B, body.constant(0u));
                        ir_if *f331A = new(mem_ctx) ir_if(operand(r331C).val);
                        exec_list *const f331A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f331A->then_instructions;

                           body.emit(assign(r3314, add(r3314, body.constant(int(8))), 0x01));

                           body.emit(assign(r3312, lshift(r3312, body.constant(int(8))), 0x01));


                        body.instructions = f331A_parent_instructions;
                        body.emit(f331A);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r331E = bit_and(r3312, body.constant(4026531840u));
                        ir_expression *const r331F = equal(r331E, body.constant(0u));
                        ir_if *f331D = new(mem_ctx) ir_if(operand(r331F).val);
                        exec_list *const f331D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f331D->then_instructions;

                           body.emit(assign(r3314, add(r3314, body.constant(int(4))), 0x01));

                           body.emit(assign(r3312, lshift(r3312, body.constant(int(4))), 0x01));


                        body.instructions = f331D_parent_instructions;
                        body.emit(f331D);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3321 = bit_and(r3312, body.constant(3221225472u));
                        ir_expression *const r3322 = equal(r3321, body.constant(0u));
                        ir_if *f3320 = new(mem_ctx) ir_if(operand(r3322).val);
                        exec_list *const f3320_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3320->then_instructions;

                           body.emit(assign(r3314, add(r3314, body.constant(int(2))), 0x01));

                           body.emit(assign(r3312, lshift(r3312, body.constant(int(2))), 0x01));


                        body.instructions = f3320_parent_instructions;
                        body.emit(f3320);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3324 = bit_and(r3312, body.constant(2147483648u));
                        ir_expression *const r3325 = equal(r3324, body.constant(0u));
                        ir_if *f3323 = new(mem_ctx) ir_if(operand(r3325).val);
                        exec_list *const f3323_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3323->then_instructions;

                           body.emit(assign(r3314, add(r3314, body.constant(int(1))), 0x01));


                        body.instructions = f3323_parent_instructions;
                        body.emit(f3323);

                        /* END IF */

                        body.emit(assign(r3313, r3314, 0x01));


                     body.instructions = f3315_parent_instructions;
                     body.emit(f3315);

                     /* END IF */

                     body.emit(assign(r32F7, add(r3313, body.constant(int(-11))), 0x01));

                     ir_variable *const r3326 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r3326, lshift(swizzle_x(r321E), r32F7), 0x01));

                     ir_variable *const r3327 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3329 = equal(r32F7, body.constant(int(0)));
                     ir_if *f3328 = new(mem_ctx) ir_if(operand(r3329).val);
                     exec_list *const f3328_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3328->then_instructions;

                        body.emit(assign(r3327, r3231, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3328->else_instructions;

                        ir_expression *const r332A = lshift(r3231, r32F7);
                        ir_expression *const r332B = neg(r32F7);
                        ir_expression *const r332C = bit_and(r332B, body.constant(int(31)));
                        ir_expression *const r332D = rshift(swizzle_x(r321E), r332C);
                        body.emit(assign(r3327, bit_or(r332A, r332D), 0x01));


                     body.instructions = f3328_parent_instructions;
                     body.emit(f3328);

                     /* END IF */

                     body.emit(assign(r32F5, r3327, 0x01));

                     body.emit(assign(r32F6, r3326, 0x01));

                     body.emit(assign(r32F4, sub(body.constant(int(1)), r32F7), 0x01));


                  body.instructions = f32F8_parent_instructions;
                  body.emit(f32F8);

                  /* END IF */

                  body.emit(assign(r3224, r32F4, 0x01));

                  body.emit(assign(r3227, r32F5, 0x01));

                  body.emit(assign(r3228, r32F6, 0x01));


               body.instructions = f32F0_parent_instructions;
               body.emit(f32F0);

               /* END IF */


            body.instructions = f32EE_parent_instructions;
            body.emit(f32EE);

            /* END IF */

            /* IF CONDITION */
            ir_if *f332E = new(mem_ctx) ir_if(operand(r3220).val);
            exec_list *const f332E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f332E->then_instructions;

               ir_expression *const r332F = sub(r3224, r3223);
               body.emit(assign(r322F, add(r332F, body.constant(int(1021))), 0x01));

               ir_variable *const r3330 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r3330, lshift(r3228, body.constant(int(11))), 0x01));

               ir_variable *const r3331 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r3332 = bit_or(r3227, body.constant(1048576u));
               ir_expression *const r3333 = lshift(r3332, body.constant(int(11)));
               ir_expression *const r3334 = rshift(r3228, body.constant(int(21)));
               body.emit(assign(r3331, bit_or(r3333, r3334), 0x01));

               body.emit(assign(r3227, r3331, 0x01));

               body.emit(assign(r3228, r3330, 0x01));

               ir_variable *const r3335 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r3335, lshift(r3226, body.constant(int(11))), 0x01));

               ir_variable *const r3336 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r3337 = bit_or(r3225, body.constant(1048576u));
               ir_expression *const r3338 = lshift(r3337, body.constant(int(11)));
               ir_expression *const r3339 = rshift(r3226, body.constant(int(21)));
               body.emit(assign(r3336, bit_or(r3338, r3339), 0x01));

               body.emit(assign(r3225, r3336, 0x01));

               body.emit(assign(r3226, r3335, 0x01));

               /* IF CONDITION */
               ir_expression *const r333B = less(r3336, r3331);
               ir_expression *const r333C = equal(r3336, r3331);
               ir_expression *const r333D = lequal(r3335, r3330);
               ir_expression *const r333E = logic_and(r333C, r333D);
               ir_expression *const r333F = logic_or(r333B, r333E);
               ir_if *f333A = new(mem_ctx) ir_if(operand(r333F).val);
               exec_list *const f333A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f333A->then_instructions;

                  body.emit(assign(r3227, rshift(r3331, body.constant(int(1))), 0x01));

                  ir_expression *const r3340 = lshift(r3331, body.constant(int(31)));
                  ir_expression *const r3341 = rshift(r3330, body.constant(int(1)));
                  body.emit(assign(r3228, bit_or(r3340, r3341), 0x01));

                  body.emit(assign(r322F, add(r322F, body.constant(int(1))), 0x01));


               body.instructions = f333A_parent_instructions;
               body.emit(f333A);

               /* END IF */

               ir_variable *const r3342 = body.make_temp(glsl_type::uint_type, "return_value");
               ir_variable *const r3343 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r3343);
               ir_variable *const r3344 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
               body.emit(r3344);
               ir_variable *const r3345 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
               body.emit(r3345);
               ir_variable *const r3346 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
               body.emit(r3346);
               body.emit(assign(r3345, body.constant(0u), 0x01));

               body.emit(assign(r3344, body.constant(0u), 0x01));

               /* IF CONDITION */
               ir_expression *const r3348 = lequal(r3336, r3227);
               ir_if *f3347 = new(mem_ctx) ir_if(operand(r3348).val);
               exec_list *const f3347_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3347->then_instructions;

                  body.emit(assign(r3342, body.constant(4294967295u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3347->else_instructions;

                  body.emit(assign(r3346, rshift(r3336, body.constant(int(16))), 0x01));

                  ir_variable *const r3349 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r334B = lshift(r3346, body.constant(int(16)));
                  ir_expression *const r334C = lequal(r334B, r3227);
                  ir_if *f334A = new(mem_ctx) ir_if(operand(r334C).val);
                  exec_list *const f334A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f334A->then_instructions;

                     body.emit(assign(r3349, body.constant(4294901760u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f334A->else_instructions;

                     ir_expression *const r334D = expr(ir_binop_div, r3227, r3346);
                     body.emit(assign(r3349, lshift(r334D, body.constant(int(16))), 0x01));


                  body.instructions = f334A_parent_instructions;
                  body.emit(f334A);

                  /* END IF */

                  body.emit(assign(r3343, r3349, 0x01));

                  ir_variable *const r334E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r334E);
                  ir_variable *const r334F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r334F);
                  ir_variable *const r3350 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r3350);
                  ir_variable *const r3351 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3351, bit_and(r3336, body.constant(65535u)), 0x01));

                  ir_variable *const r3352 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3352, rshift(r3336, body.constant(int(16))), 0x01));

                  ir_variable *const r3353 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3353, bit_and(r3349, body.constant(65535u)), 0x01));

                  ir_variable *const r3354 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3354, rshift(r3349, body.constant(int(16))), 0x01));

                  ir_variable *const r3355 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3355, mul(r3352, r3353), 0x01));

                  ir_expression *const r3356 = mul(r3351, r3354);
                  body.emit(assign(r334F, add(r3356, r3355), 0x01));

                  ir_expression *const r3357 = mul(r3352, r3354);
                  ir_expression *const r3358 = less(r334F, r3355);
                  ir_expression *const r3359 = expr(ir_unop_b2i, r3358);
                  ir_expression *const r335A = expr(ir_unop_i2u, r3359);
                  ir_expression *const r335B = lshift(r335A, body.constant(int(16)));
                  ir_expression *const r335C = rshift(r334F, body.constant(int(16)));
                  ir_expression *const r335D = add(r335B, r335C);
                  body.emit(assign(r334E, add(r3357, r335D), 0x01));

                  body.emit(assign(r334F, lshift(r334F, body.constant(int(16))), 0x01));

                  ir_expression *const r335E = mul(r3351, r3353);
                  body.emit(assign(r3350, add(r335E, r334F), 0x01));

                  ir_expression *const r335F = less(r3350, r334F);
                  ir_expression *const r3360 = expr(ir_unop_b2i, r335F);
                  ir_expression *const r3361 = expr(ir_unop_i2u, r3360);
                  body.emit(assign(r334E, add(r334E, r3361), 0x01));

                  ir_expression *const r3362 = sub(r3227, r334E);
                  ir_expression *const r3363 = less(r3228, r3350);
                  ir_expression *const r3364 = expr(ir_unop_b2i, r3363);
                  ir_expression *const r3365 = expr(ir_unop_i2u, r3364);
                  body.emit(assign(r3345, sub(r3362, r3365), 0x01));

                  body.emit(assign(r3344, sub(r3228, r3350), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f3366 = new(mem_ctx) ir_loop();
                  exec_list *const f3366_parent_instructions = body.instructions;

                     body.instructions = &f3366->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3368 = expr(ir_unop_u2i, r3345);
                     ir_expression *const r3369 = gequal(r3368, body.constant(int(0)));
                     ir_if *f3367 = new(mem_ctx) ir_if(operand(r3369).val);
                     exec_list *const f3367_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3367->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f3367_parent_instructions;
                     body.emit(f3367);

                     /* END IF */

                     body.emit(assign(r3343, add(r3343, body.constant(4294901760u)), 0x01));

                     ir_variable *const r336A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r336B = lshift(r3336, body.constant(int(16)));
                     body.emit(assign(r336A, add(r3344, r336B), 0x01));

                     ir_expression *const r336C = add(r3345, r3346);
                     ir_expression *const r336D = less(r336A, r3344);
                     ir_expression *const r336E = expr(ir_unop_b2i, r336D);
                     ir_expression *const r336F = expr(ir_unop_i2u, r336E);
                     body.emit(assign(r3345, add(r336C, r336F), 0x01));

                     body.emit(assign(r3344, r336A, 0x01));

                  /* LOOP END */

                  body.instructions = f3366_parent_instructions;
                  body.emit(f3366);

                  ir_expression *const r3370 = lshift(r3345, body.constant(int(16)));
                  ir_expression *const r3371 = rshift(r3344, body.constant(int(16)));
                  body.emit(assign(r3345, bit_or(r3370, r3371), 0x01));

                  ir_variable *const r3372 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3374 = lshift(r3346, body.constant(int(16)));
                  ir_expression *const r3375 = lequal(r3374, r3345);
                  ir_if *f3373 = new(mem_ctx) ir_if(operand(r3375).val);
                  exec_list *const f3373_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3373->then_instructions;

                     body.emit(assign(r3372, body.constant(65535u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3373->else_instructions;

                     body.emit(assign(r3372, expr(ir_binop_div, r3345, r3346), 0x01));


                  body.instructions = f3373_parent_instructions;
                  body.emit(f3373);

                  /* END IF */

                  body.emit(assign(r3343, bit_or(r3343, r3372), 0x01));

                  body.emit(assign(r3342, r3343, 0x01));


               body.instructions = f3347_parent_instructions;
               body.emit(f3347);

               /* END IF */

               body.emit(assign(r322E, r3342, 0x01));

               ir_variable *const r3376 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3376);
               ir_variable *const r3377 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r3377);
               ir_variable *const r3378 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3378);
               ir_variable *const r3379 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3379, bit_and(r3335, body.constant(65535u)), 0x01));

               ir_variable *const r337A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r337A, rshift(r3335, body.constant(int(16))), 0x01));

               ir_variable *const r337B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r337B, bit_and(r3342, body.constant(65535u)), 0x01));

               ir_variable *const r337C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r337C, rshift(r3342, body.constant(int(16))), 0x01));

               ir_variable *const r337D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r337D, mul(r337A, r337B), 0x01));

               ir_expression *const r337E = mul(r3379, r337C);
               body.emit(assign(r3377, add(r337E, r337D), 0x01));

               ir_expression *const r337F = mul(r337A, r337C);
               ir_expression *const r3380 = less(r3377, r337D);
               ir_expression *const r3381 = expr(ir_unop_b2i, r3380);
               ir_expression *const r3382 = expr(ir_unop_i2u, r3381);
               ir_expression *const r3383 = lshift(r3382, body.constant(int(16)));
               ir_expression *const r3384 = rshift(r3377, body.constant(int(16)));
               ir_expression *const r3385 = add(r3383, r3384);
               body.emit(assign(r3376, add(r337F, r3385), 0x01));

               body.emit(assign(r3377, lshift(r3377, body.constant(int(16))), 0x01));

               ir_expression *const r3386 = mul(r3379, r337B);
               body.emit(assign(r3378, add(r3386, r3377), 0x01));

               ir_expression *const r3387 = less(r3378, r3377);
               ir_expression *const r3388 = expr(ir_unop_b2i, r3387);
               ir_expression *const r3389 = expr(ir_unop_i2u, r3388);
               body.emit(assign(r3376, add(r3376, r3389), 0x01));

               ir_variable *const r338A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r338A);
               ir_variable *const r338B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r338B);
               ir_variable *const r338C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r338C);
               ir_variable *const r338D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r338D, bit_and(r3336, body.constant(65535u)), 0x01));

               ir_variable *const r338E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r338E, rshift(r3336, body.constant(int(16))), 0x01));

               ir_variable *const r338F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r338F, bit_and(r3342, body.constant(65535u)), 0x01));

               ir_variable *const r3390 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3390, rshift(r3342, body.constant(int(16))), 0x01));

               ir_variable *const r3391 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3391, mul(r338E, r338F), 0x01));

               ir_expression *const r3392 = mul(r338D, r3390);
               body.emit(assign(r338B, add(r3392, r3391), 0x01));

               ir_expression *const r3393 = mul(r338E, r3390);
               ir_expression *const r3394 = less(r338B, r3391);
               ir_expression *const r3395 = expr(ir_unop_b2i, r3394);
               ir_expression *const r3396 = expr(ir_unop_i2u, r3395);
               ir_expression *const r3397 = lshift(r3396, body.constant(int(16)));
               ir_expression *const r3398 = rshift(r338B, body.constant(int(16)));
               ir_expression *const r3399 = add(r3397, r3398);
               body.emit(assign(r338A, add(r3393, r3399), 0x01));

               body.emit(assign(r338B, lshift(r338B, body.constant(int(16))), 0x01));

               ir_expression *const r339A = mul(r338D, r338F);
               body.emit(assign(r338C, add(r339A, r338B), 0x01));

               ir_expression *const r339B = less(r338C, r338B);
               ir_expression *const r339C = expr(ir_unop_b2i, r339B);
               ir_expression *const r339D = expr(ir_unop_i2u, r339C);
               body.emit(assign(r338A, add(r338A, r339D), 0x01));

               ir_variable *const r339E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r339E, add(r338C, r3376), 0x01));

               ir_variable *const r339F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r339F);
               ir_variable *const r33A0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r33A1 = less(body.constant(0u), r3378);
               ir_expression *const r33A2 = expr(ir_unop_b2i, r33A1);
               body.emit(assign(r33A0, expr(ir_unop_i2u, r33A2), 0x01));

               ir_variable *const r33A3 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r33A3, sub(r3228, r339E), 0x01));

               ir_expression *const r33A4 = less(r339E, r338C);
               ir_expression *const r33A5 = expr(ir_unop_b2i, r33A4);
               ir_expression *const r33A6 = expr(ir_unop_i2u, r33A5);
               ir_expression *const r33A7 = add(r338A, r33A6);
               ir_expression *const r33A8 = sub(r3227, r33A7);
               ir_expression *const r33A9 = less(r33A3, r33A0);
               ir_expression *const r33AA = expr(ir_unop_b2i, r33A9);
               ir_expression *const r33AB = expr(ir_unop_i2u, r33AA);
               body.emit(assign(r339F, sub(r33A8, r33AB), 0x01));

               ir_expression *const r33AC = less(r3228, r339E);
               ir_expression *const r33AD = expr(ir_unop_b2i, r33AC);
               ir_expression *const r33AE = expr(ir_unop_i2u, r33AD);
               body.emit(assign(r339F, sub(r339F, r33AE), 0x01));

               body.emit(assign(r322C, r339F, 0x01));

               body.emit(assign(r322B, sub(r33A3, r33A0), 0x01));

               body.emit(assign(r322A, neg(r3378), 0x01));

               /* LOOP BEGIN */
               ir_loop *f33AF = new(mem_ctx) ir_loop();
               exec_list *const f33AF_parent_instructions = body.instructions;

                  body.instructions = &f33AF->body_instructions;

                  /* IF CONDITION */
                  ir_expression *const r33B1 = expr(ir_unop_u2i, r322C);
                  ir_expression *const r33B2 = gequal(r33B1, body.constant(int(0)));
                  ir_if *f33B0 = new(mem_ctx) ir_if(operand(r33B2).val);
                  exec_list *const f33B0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f33B0->then_instructions;

                     body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                  body.instructions = f33B0_parent_instructions;
                  body.emit(f33B0);

                  /* END IF */

                  body.emit(assign(r322E, add(r322E, body.constant(4294967295u)), 0x01));

                  ir_variable *const r33B3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r33B3);
                  ir_variable *const r33B4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r33B4);
                  ir_variable *const r33B5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r33B5, add(r322A, r3335), 0x01));

                  ir_variable *const r33B6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  ir_expression *const r33B7 = less(r33B5, r322A);
                  ir_expression *const r33B8 = expr(ir_unop_b2i, r33B7);
                  body.emit(assign(r33B6, expr(ir_unop_i2u, r33B8), 0x01));

                  ir_variable *const r33B9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r33B9, add(r322B, r3336), 0x01));

                  body.emit(assign(r33B4, add(r33B9, r33B6), 0x01));

                  ir_expression *const r33BA = less(r33B4, r33B6);
                  ir_expression *const r33BB = expr(ir_unop_b2i, r33BA);
                  ir_expression *const r33BC = expr(ir_unop_i2u, r33BB);
                  body.emit(assign(r33B3, add(r322C, r33BC), 0x01));

                  ir_expression *const r33BD = less(r33B9, r322B);
                  ir_expression *const r33BE = expr(ir_unop_b2i, r33BD);
                  ir_expression *const r33BF = expr(ir_unop_i2u, r33BE);
                  body.emit(assign(r33B3, add(r33B3, r33BF), 0x01));

                  body.emit(assign(r322C, r33B3, 0x01));

                  body.emit(assign(r322B, r33B4, 0x01));

                  body.emit(assign(r322A, r33B5, 0x01));

               /* LOOP END */

               body.instructions = f33AF_parent_instructions;
               body.emit(f33AF);

               ir_variable *const r33C0 = body.make_temp(glsl_type::uint_type, "return_value");
               ir_variable *const r33C1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r33C1);
               ir_variable *const r33C2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
               body.emit(r33C2);
               ir_variable *const r33C3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
               body.emit(r33C3);
               ir_variable *const r33C4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
               body.emit(r33C4);
               body.emit(assign(r33C3, body.constant(0u), 0x01));

               body.emit(assign(r33C2, body.constant(0u), 0x01));

               /* IF CONDITION */
               ir_expression *const r33C6 = lequal(r3336, r322B);
               ir_if *f33C5 = new(mem_ctx) ir_if(operand(r33C6).val);
               exec_list *const f33C5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f33C5->then_instructions;

                  body.emit(assign(r33C0, body.constant(4294967295u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f33C5->else_instructions;

                  body.emit(assign(r33C4, rshift(r3336, body.constant(int(16))), 0x01));

                  ir_variable *const r33C7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r33C9 = lshift(r33C4, body.constant(int(16)));
                  ir_expression *const r33CA = lequal(r33C9, r322B);
                  ir_if *f33C8 = new(mem_ctx) ir_if(operand(r33CA).val);
                  exec_list *const f33C8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f33C8->then_instructions;

                     body.emit(assign(r33C7, body.constant(4294901760u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f33C8->else_instructions;

                     ir_expression *const r33CB = expr(ir_binop_div, r322B, r33C4);
                     body.emit(assign(r33C7, lshift(r33CB, body.constant(int(16))), 0x01));


                  body.instructions = f33C8_parent_instructions;
                  body.emit(f33C8);

                  /* END IF */

                  body.emit(assign(r33C1, r33C7, 0x01));

                  ir_variable *const r33CC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r33CC);
                  ir_variable *const r33CD = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r33CD);
                  ir_variable *const r33CE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r33CE);
                  ir_variable *const r33CF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r33CF, bit_and(r3336, body.constant(65535u)), 0x01));

                  ir_variable *const r33D0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r33D0, rshift(r3336, body.constant(int(16))), 0x01));

                  ir_variable *const r33D1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r33D1, bit_and(r33C7, body.constant(65535u)), 0x01));

                  ir_variable *const r33D2 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r33D2, rshift(r33C7, body.constant(int(16))), 0x01));

                  ir_variable *const r33D3 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r33D3, mul(r33D0, r33D1), 0x01));

                  ir_expression *const r33D4 = mul(r33CF, r33D2);
                  body.emit(assign(r33CD, add(r33D4, r33D3), 0x01));

                  ir_expression *const r33D5 = mul(r33D0, r33D2);
                  ir_expression *const r33D6 = less(r33CD, r33D3);
                  ir_expression *const r33D7 = expr(ir_unop_b2i, r33D6);
                  ir_expression *const r33D8 = expr(ir_unop_i2u, r33D7);
                  ir_expression *const r33D9 = lshift(r33D8, body.constant(int(16)));
                  ir_expression *const r33DA = rshift(r33CD, body.constant(int(16)));
                  ir_expression *const r33DB = add(r33D9, r33DA);
                  body.emit(assign(r33CC, add(r33D5, r33DB), 0x01));

                  body.emit(assign(r33CD, lshift(r33CD, body.constant(int(16))), 0x01));

                  ir_expression *const r33DC = mul(r33CF, r33D1);
                  body.emit(assign(r33CE, add(r33DC, r33CD), 0x01));

                  ir_expression *const r33DD = less(r33CE, r33CD);
                  ir_expression *const r33DE = expr(ir_unop_b2i, r33DD);
                  ir_expression *const r33DF = expr(ir_unop_i2u, r33DE);
                  body.emit(assign(r33CC, add(r33CC, r33DF), 0x01));

                  ir_expression *const r33E0 = sub(r322B, r33CC);
                  ir_expression *const r33E1 = less(r322A, r33CE);
                  ir_expression *const r33E2 = expr(ir_unop_b2i, r33E1);
                  ir_expression *const r33E3 = expr(ir_unop_i2u, r33E2);
                  body.emit(assign(r33C3, sub(r33E0, r33E3), 0x01));

                  body.emit(assign(r33C2, sub(r322A, r33CE), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f33E4 = new(mem_ctx) ir_loop();
                  exec_list *const f33E4_parent_instructions = body.instructions;

                     body.instructions = &f33E4->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r33E6 = expr(ir_unop_u2i, r33C3);
                     ir_expression *const r33E7 = gequal(r33E6, body.constant(int(0)));
                     ir_if *f33E5 = new(mem_ctx) ir_if(operand(r33E7).val);
                     exec_list *const f33E5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f33E5->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f33E5_parent_instructions;
                     body.emit(f33E5);

                     /* END IF */

                     body.emit(assign(r33C1, add(r33C1, body.constant(4294901760u)), 0x01));

                     ir_variable *const r33E8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r33E9 = lshift(r3336, body.constant(int(16)));
                     body.emit(assign(r33E8, add(r33C2, r33E9), 0x01));

                     ir_expression *const r33EA = add(r33C3, r33C4);
                     ir_expression *const r33EB = less(r33E8, r33C2);
                     ir_expression *const r33EC = expr(ir_unop_b2i, r33EB);
                     ir_expression *const r33ED = expr(ir_unop_i2u, r33EC);
                     body.emit(assign(r33C3, add(r33EA, r33ED), 0x01));

                     body.emit(assign(r33C2, r33E8, 0x01));

                  /* LOOP END */

                  body.instructions = f33E4_parent_instructions;
                  body.emit(f33E4);

                  ir_expression *const r33EE = lshift(r33C3, body.constant(int(16)));
                  ir_expression *const r33EF = rshift(r33C2, body.constant(int(16)));
                  body.emit(assign(r33C3, bit_or(r33EE, r33EF), 0x01));

                  ir_variable *const r33F0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r33F2 = lshift(r33C4, body.constant(int(16)));
                  ir_expression *const r33F3 = lequal(r33F2, r33C3);
                  ir_if *f33F1 = new(mem_ctx) ir_if(operand(r33F3).val);
                  exec_list *const f33F1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f33F1->then_instructions;

                     body.emit(assign(r33F0, body.constant(65535u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f33F1->else_instructions;

                     body.emit(assign(r33F0, expr(ir_binop_div, r33C3, r33C4), 0x01));


                  body.instructions = f33F1_parent_instructions;
                  body.emit(f33F1);

                  /* END IF */

                  body.emit(assign(r33C1, bit_or(r33C1, r33F0), 0x01));

                  body.emit(assign(r33C0, r33C1, 0x01));


               body.instructions = f33C5_parent_instructions;
               body.emit(f33C5);

               /* END IF */

               body.emit(assign(r322D, r33C0, 0x01));

               /* IF CONDITION */
               ir_expression *const r33F5 = bit_and(r33C0, body.constant(1023u));
               ir_expression *const r33F6 = lequal(r33F5, body.constant(4u));
               ir_if *f33F4 = new(mem_ctx) ir_if(operand(r33F6).val);
               exec_list *const f33F4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f33F4->then_instructions;

                  ir_variable *const r33F7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r33F7);
                  ir_variable *const r33F8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r33F8);
                  ir_variable *const r33F9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r33F9);
                  ir_variable *const r33FA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r33FA, bit_and(r3335, body.constant(65535u)), 0x01));

                  ir_variable *const r33FB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r33FB, rshift(r3335, body.constant(int(16))), 0x01));

                  ir_variable *const r33FC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r33FC, bit_and(r33C0, body.constant(65535u)), 0x01));

                  ir_variable *const r33FD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r33FD, rshift(r33C0, body.constant(int(16))), 0x01));

                  ir_variable *const r33FE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r33FE, mul(r33FB, r33FC), 0x01));

                  ir_expression *const r33FF = mul(r33FA, r33FD);
                  body.emit(assign(r33F8, add(r33FF, r33FE), 0x01));

                  ir_expression *const r3400 = mul(r33FB, r33FD);
                  ir_expression *const r3401 = less(r33F8, r33FE);
                  ir_expression *const r3402 = expr(ir_unop_b2i, r3401);
                  ir_expression *const r3403 = expr(ir_unop_i2u, r3402);
                  ir_expression *const r3404 = lshift(r3403, body.constant(int(16)));
                  ir_expression *const r3405 = rshift(r33F8, body.constant(int(16)));
                  ir_expression *const r3406 = add(r3404, r3405);
                  body.emit(assign(r33F7, add(r3400, r3406), 0x01));

                  body.emit(assign(r33F8, lshift(r33F8, body.constant(int(16))), 0x01));

                  ir_expression *const r3407 = mul(r33FA, r33FC);
                  body.emit(assign(r33F9, add(r3407, r33F8), 0x01));

                  ir_expression *const r3408 = less(r33F9, r33F8);
                  ir_expression *const r3409 = expr(ir_unop_b2i, r3408);
                  ir_expression *const r340A = expr(ir_unop_i2u, r3409);
                  body.emit(assign(r33F7, add(r33F7, r340A), 0x01));

                  ir_variable *const r340B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r340B);
                  ir_variable *const r340C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r340C);
                  ir_variable *const r340D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r340D);
                  ir_variable *const r340E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r340E, bit_and(r3336, body.constant(65535u)), 0x01));

                  ir_variable *const r340F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r340F, rshift(r3336, body.constant(int(16))), 0x01));

                  ir_variable *const r3410 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3410, bit_and(r33C0, body.constant(65535u)), 0x01));

                  ir_variable *const r3411 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3411, rshift(r33C0, body.constant(int(16))), 0x01));

                  ir_variable *const r3412 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3412, mul(r340F, r3410), 0x01));

                  ir_expression *const r3413 = mul(r340E, r3411);
                  body.emit(assign(r340C, add(r3413, r3412), 0x01));

                  ir_expression *const r3414 = mul(r340F, r3411);
                  ir_expression *const r3415 = less(r340C, r3412);
                  ir_expression *const r3416 = expr(ir_unop_b2i, r3415);
                  ir_expression *const r3417 = expr(ir_unop_i2u, r3416);
                  ir_expression *const r3418 = lshift(r3417, body.constant(int(16)));
                  ir_expression *const r3419 = rshift(r340C, body.constant(int(16)));
                  ir_expression *const r341A = add(r3418, r3419);
                  body.emit(assign(r340B, add(r3414, r341A), 0x01));

                  body.emit(assign(r340C, lshift(r340C, body.constant(int(16))), 0x01));

                  ir_expression *const r341B = mul(r340E, r3410);
                  body.emit(assign(r340D, add(r341B, r340C), 0x01));

                  ir_expression *const r341C = less(r340D, r340C);
                  ir_expression *const r341D = expr(ir_unop_b2i, r341C);
                  ir_expression *const r341E = expr(ir_unop_i2u, r341D);
                  body.emit(assign(r340B, add(r340B, r341E), 0x01));

                  ir_variable *const r341F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r341F, add(r340D, r33F7), 0x01));

                  ir_variable *const r3420 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r3420);
                  ir_variable *const r3421 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  ir_expression *const r3422 = less(body.constant(0u), r33F9);
                  ir_expression *const r3423 = expr(ir_unop_b2i, r3422);
                  body.emit(assign(r3421, expr(ir_unop_i2u, r3423), 0x01));

                  ir_variable *const r3424 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3424, sub(r322A, r341F), 0x01));

                  ir_expression *const r3425 = less(r341F, r340D);
                  ir_expression *const r3426 = expr(ir_unop_b2i, r3425);
                  ir_expression *const r3427 = expr(ir_unop_i2u, r3426);
                  ir_expression *const r3428 = add(r340B, r3427);
                  ir_expression *const r3429 = sub(r322B, r3428);
                  ir_expression *const r342A = less(r3424, r3421);
                  ir_expression *const r342B = expr(ir_unop_b2i, r342A);
                  ir_expression *const r342C = expr(ir_unop_i2u, r342B);
                  body.emit(assign(r3420, sub(r3429, r342C), 0x01));

                  ir_expression *const r342D = less(r322A, r341F);
                  ir_expression *const r342E = expr(ir_unop_b2i, r342D);
                  ir_expression *const r342F = expr(ir_unop_i2u, r342E);
                  body.emit(assign(r3420, sub(r3420, r342F), 0x01));

                  body.emit(assign(r322B, r3420, 0x01));

                  body.emit(assign(r322A, sub(r3424, r3421), 0x01));

                  body.emit(assign(r3229, neg(r33F9), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f3430 = new(mem_ctx) ir_loop();
                  exec_list *const f3430_parent_instructions = body.instructions;

                     body.instructions = &f3430->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3432 = expr(ir_unop_u2i, r322B);
                     ir_expression *const r3433 = gequal(r3432, body.constant(int(0)));
                     ir_if *f3431 = new(mem_ctx) ir_if(operand(r3433).val);
                     exec_list *const f3431_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3431->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f3431_parent_instructions;
                     body.emit(f3431);

                     /* END IF */

                     body.emit(assign(r322D, add(r322D, body.constant(4294967295u)), 0x01));

                     ir_variable *const r3434 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r3434);
                     ir_variable *const r3435 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r3435);
                     ir_variable *const r3436 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r3436, add(r3229, r3335), 0x01));

                     ir_variable *const r3437 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r3438 = less(r3436, r3229);
                     ir_expression *const r3439 = expr(ir_unop_b2i, r3438);
                     body.emit(assign(r3437, expr(ir_unop_i2u, r3439), 0x01));

                     ir_variable *const r343A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r343A, add(r322A, r3336), 0x01));

                     body.emit(assign(r3435, add(r343A, r3437), 0x01));

                     ir_expression *const r343B = less(r3435, r3437);
                     ir_expression *const r343C = expr(ir_unop_b2i, r343B);
                     ir_expression *const r343D = expr(ir_unop_i2u, r343C);
                     body.emit(assign(r3434, add(r322B, r343D), 0x01));

                     ir_expression *const r343E = less(r343A, r322A);
                     ir_expression *const r343F = expr(ir_unop_b2i, r343E);
                     ir_expression *const r3440 = expr(ir_unop_i2u, r343F);
                     body.emit(assign(r3434, add(r3434, r3440), 0x01));

                     body.emit(assign(r322B, r3434, 0x01));

                     body.emit(assign(r322A, r3435, 0x01));

                     body.emit(assign(r3229, r3436, 0x01));

                  /* LOOP END */

                  body.instructions = f3430_parent_instructions;
                  body.emit(f3430);

                  ir_expression *const r3441 = bit_or(r322B, r322A);
                  ir_expression *const r3442 = bit_or(r3441, r3229);
                  ir_expression *const r3443 = nequal(r3442, body.constant(0u));
                  ir_expression *const r3444 = expr(ir_unop_b2i, r3443);
                  ir_expression *const r3445 = expr(ir_unop_i2u, r3444);
                  body.emit(assign(r322D, bit_or(r322D, r3445), 0x01));


               body.instructions = f33F4_parent_instructions;
               body.emit(f33F4);

               /* END IF */

               ir_variable *const r3446 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r3446);
               ir_variable *const r3447 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3447);
               ir_variable *const r3448 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3448);
               body.emit(assign(r3446, lshift(r322D, body.constant(int(21))), 0x01));

               ir_expression *const r3449 = lshift(r322E, body.constant(int(21)));
               ir_expression *const r344A = rshift(r322D, body.constant(int(11)));
               body.emit(assign(r3447, bit_or(r3449, r344A), 0x01));

               body.emit(assign(r3448, rshift(r322E, body.constant(int(11))), 0x01));

               body.emit(assign(r3446, bit_or(r3446, body.constant(0u)), 0x01));

               body.emit(assign(r322E, r3448, 0x01));

               body.emit(assign(r322D, r3447, 0x01));

               ir_variable *const r344B = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r344B, r322F, 0x01));

               ir_variable *const r344C = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r344C, r3448, 0x01));

               ir_variable *const r344D = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r344D, r3447, 0x01));

               ir_variable *const r344E = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r344E, r3446, 0x01));

               ir_variable *const r344F = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r344F, body.constant(true), 0x01));

               ir_variable *const r3450 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r3451 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r3451);
               ir_expression *const r3452 = expr(ir_unop_u2i, r3446);
               body.emit(assign(r3451, less(r3452, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3454 = lequal(body.constant(int(2045)), r322F);
               ir_if *f3453 = new(mem_ctx) ir_if(operand(r3454).val);
               exec_list *const f3453_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3453->then_instructions;

                  ir_variable *const r3455 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3457 = less(body.constant(int(2045)), r322F);
                  ir_if *f3456 = new(mem_ctx) ir_if(operand(r3457).val);
                  exec_list *const f3456_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3456->then_instructions;

                     body.emit(assign(r3455, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3456->else_instructions;

                     ir_variable *const r3458 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r345A = equal(r322F, body.constant(int(2045)));
                     ir_if *f3459 = new(mem_ctx) ir_if(operand(r345A).val);
                     exec_list *const f3459_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3459->then_instructions;

                        ir_expression *const r345B = equal(body.constant(2097151u), r3448);
                        ir_expression *const r345C = equal(body.constant(4294967295u), r3447);
                        body.emit(assign(r3458, logic_and(r345B, r345C), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3459->else_instructions;

                        body.emit(assign(r3458, body.constant(false), 0x01));


                     body.instructions = f3459_parent_instructions;
                     body.emit(f3459);

                     /* END IF */

                     body.emit(assign(r3455, logic_and(r3458, r3451), 0x01));


                  body.instructions = f3456_parent_instructions;
                  body.emit(f3456);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f345D = new(mem_ctx) ir_if(operand(r3455).val);
                  exec_list *const f345D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f345D->then_instructions;

                     ir_variable *const r345E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r345E);
                     ir_expression *const r345F = lshift(r3222, body.constant(int(31)));
                     body.emit(assign(r345E, add(r345F, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r345E, body.constant(0u), 0x01));

                     body.emit(assign(r3450, r345E, 0x03));

                     body.emit(assign(r344F, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f345D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3461 = less(r322F, body.constant(int(0)));
                     ir_if *f3460 = new(mem_ctx) ir_if(operand(r3461).val);
                     exec_list *const f3460_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3460->then_instructions;

                        ir_variable *const r3462 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r3462, r3446, 0x01));

                        ir_variable *const r3463 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r3463, neg(r322F), 0x01));

                        ir_variable *const r3464 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r3464);
                        ir_variable *const r3465 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r3465);
                        ir_variable *const r3466 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r3466);
                        ir_variable *const r3467 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r3468 = neg(r3463);
                        body.emit(assign(r3467, bit_and(r3468, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r346A = equal(r3463, body.constant(int(0)));
                        ir_if *f3469 = new(mem_ctx) ir_if(operand(r346A).val);
                        exec_list *const f3469_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3469->then_instructions;

                           body.emit(assign(r3464, r3446, 0x01));

                           body.emit(assign(r3465, r3447, 0x01));

                           body.emit(assign(r3466, r3448, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3469->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r346C = less(r3463, body.constant(int(32)));
                           ir_if *f346B = new(mem_ctx) ir_if(operand(r346C).val);
                           exec_list *const f346B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f346B->then_instructions;

                              body.emit(assign(r3464, lshift(r3447, r3467), 0x01));

                              ir_expression *const r346D = lshift(r3448, r3467);
                              ir_expression *const r346E = rshift(r3447, r3463);
                              body.emit(assign(r3465, bit_or(r346D, r346E), 0x01));

                              body.emit(assign(r3466, rshift(r3448, r3463), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f346B->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3470 = equal(r3463, body.constant(int(32)));
                              ir_if *f346F = new(mem_ctx) ir_if(operand(r3470).val);
                              exec_list *const f346F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f346F->then_instructions;

                                 body.emit(assign(r3464, r3447, 0x01));

                                 body.emit(assign(r3465, r3448, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f346F->else_instructions;

                                 body.emit(assign(r3462, bit_or(r3446, r3447), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3472 = less(r3463, body.constant(int(64)));
                                 ir_if *f3471 = new(mem_ctx) ir_if(operand(r3472).val);
                                 exec_list *const f3471_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3471->then_instructions;

                                    body.emit(assign(r3464, lshift(r3448, r3467), 0x01));

                                    ir_expression *const r3473 = bit_and(r3463, body.constant(int(31)));
                                    body.emit(assign(r3465, rshift(r3448, r3473), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3471->else_instructions;

                                    ir_variable *const r3474 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r3476 = equal(r3463, body.constant(int(64)));
                                    ir_if *f3475 = new(mem_ctx) ir_if(operand(r3476).val);
                                    exec_list *const f3475_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3475->then_instructions;

                                       body.emit(assign(r3474, r3448, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3475->else_instructions;

                                       ir_expression *const r3477 = nequal(r3448, body.constant(0u));
                                       ir_expression *const r3478 = expr(ir_unop_b2i, r3477);
                                       body.emit(assign(r3474, expr(ir_unop_i2u, r3478), 0x01));


                                    body.instructions = f3475_parent_instructions;
                                    body.emit(f3475);

                                    /* END IF */

                                    body.emit(assign(r3464, r3474, 0x01));

                                    body.emit(assign(r3465, body.constant(0u), 0x01));


                                 body.instructions = f3471_parent_instructions;
                                 body.emit(f3471);

                                 /* END IF */


                              body.instructions = f346F_parent_instructions;
                              body.emit(f346F);

                              /* END IF */

                              body.emit(assign(r3466, body.constant(0u), 0x01));


                           body.instructions = f346B_parent_instructions;
                           body.emit(f346B);

                           /* END IF */

                           ir_expression *const r3479 = nequal(r3462, body.constant(0u));
                           ir_expression *const r347A = expr(ir_unop_b2i, r3479);
                           ir_expression *const r347B = expr(ir_unop_i2u, r347A);
                           body.emit(assign(r3464, bit_or(r3464, r347B), 0x01));


                        body.instructions = f3469_parent_instructions;
                        body.emit(f3469);

                        /* END IF */

                        body.emit(assign(r344C, r3466, 0x01));

                        body.emit(assign(r344D, r3465, 0x01));

                        body.emit(assign(r344E, r3464, 0x01));

                        body.emit(assign(r344B, body.constant(int(0)), 0x01));

                        body.emit(assign(r3451, less(r3464, body.constant(0u)), 0x01));


                     body.instructions = f3460_parent_instructions;
                     body.emit(f3460);

                     /* END IF */


                  body.instructions = f345D_parent_instructions;
                  body.emit(f345D);

                  /* END IF */


               body.instructions = f3453_parent_instructions;
               body.emit(f3453);

               /* END IF */

               /* IF CONDITION */
               ir_if *f347C = new(mem_ctx) ir_if(operand(r344F).val);
               exec_list *const f347C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f347C->then_instructions;

                  /* IF CONDITION */
                  ir_if *f347D = new(mem_ctx) ir_if(operand(r3451).val);
                  exec_list *const f347D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f347D->then_instructions;

                     ir_variable *const r347E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r347E, add(r344D, body.constant(1u)), 0x01));

                     ir_expression *const r347F = less(r347E, r344D);
                     ir_expression *const r3480 = expr(ir_unop_b2i, r347F);
                     ir_expression *const r3481 = expr(ir_unop_i2u, r3480);
                     body.emit(assign(r344C, add(r344C, r3481), 0x01));

                     ir_expression *const r3482 = equal(r344E, body.constant(0u));
                     ir_expression *const r3483 = expr(ir_unop_b2i, r3482);
                     ir_expression *const r3484 = expr(ir_unop_i2u, r3483);
                     ir_expression *const r3485 = add(r344E, r3484);
                     ir_expression *const r3486 = bit_and(r3485, body.constant(1u));
                     ir_expression *const r3487 = expr(ir_unop_bit_not, r3486);
                     body.emit(assign(r344D, bit_and(r347E, r3487), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f347D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3489 = bit_or(r344C, r344D);
                     ir_expression *const r348A = equal(r3489, body.constant(0u));
                     ir_if *f3488 = new(mem_ctx) ir_if(operand(r348A).val);
                     exec_list *const f3488_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3488->then_instructions;

                        body.emit(assign(r344B, body.constant(int(0)), 0x01));


                     body.instructions = f3488_parent_instructions;
                     body.emit(f3488);

                     /* END IF */


                  body.instructions = f347D_parent_instructions;
                  body.emit(f347D);

                  /* END IF */

                  ir_variable *const r348B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r348B);
                  ir_expression *const r348C = lshift(r3222, body.constant(int(31)));
                  ir_expression *const r348D = expr(ir_unop_i2u, r344B);
                  ir_expression *const r348E = lshift(r348D, body.constant(int(20)));
                  ir_expression *const r348F = add(r348C, r348E);
                  body.emit(assign(r348B, add(r348F, r344C), 0x02));

                  body.emit(assign(r348B, r344D, 0x01));

                  body.emit(assign(r3450, r348B, 0x03));

                  body.emit(assign(r344F, body.constant(false), 0x01));


               body.instructions = f347C_parent_instructions;
               body.emit(f347C);

               /* END IF */

               body.emit(assign(r3221, r3450, 0x03));

               body.emit(assign(r3220, body.constant(false), 0x01));


            body.instructions = f332E_parent_instructions;
            body.emit(f332E);

            /* END IF */


         body.instructions = f32ED_parent_instructions;
         body.emit(f32ED);

         /* END IF */


      body.instructions = f3283_parent_instructions;
      body.emit(f3283);

      /* END IF */


   body.instructions = f323C_parent_instructions;
   body.emit(f323C);

   /* END IF */

   ir_variable *const r3490 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r3491 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r3492 = rshift(swizzle_y(r3221), body.constant(int(20)));
   ir_expression *const r3493 = bit_and(r3492, body.constant(2047u));
   ir_expression *const r3494 = expr(ir_unop_u2i, r3493);
   body.emit(assign(r3491, add(r3494, body.constant(int(-1023))), 0x01));

   /* IF CONDITION */
   ir_expression *const r3496 = less(r3491, body.constant(int(0)));
   ir_if *f3495 = new(mem_ctx) ir_if(operand(r3496).val);
   exec_list *const f3495_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f3495->then_instructions;

      body.emit(assign(r3490, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f3495->else_instructions;

      /* IF CONDITION */
      ir_expression *const r3498 = greater(r3491, body.constant(int(52)));
      ir_if *f3497 = new(mem_ctx) ir_if(operand(r3498).val);
      exec_list *const f3497_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f3497->then_instructions;

         body.emit(assign(r3490, r3221, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f3497->else_instructions;

         ir_variable *const r3499 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r3499, sub(body.constant(int(52)), r3491), 0x01));

         ir_variable *const r349A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r349C = gequal(r3499, body.constant(int(32)));
         ir_if *f349B = new(mem_ctx) ir_if(operand(r349C).val);
         exec_list *const f349B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f349B->then_instructions;

            body.emit(assign(r349A, body.constant(0u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f349B->else_instructions;

            body.emit(assign(r349A, lshift(body.constant(4294967295u), r3499), 0x01));


         body.instructions = f349B_parent_instructions;
         body.emit(f349B);

         /* END IF */

         ir_variable *const r349D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r349F = less(r3499, body.constant(int(33)));
         ir_if *f349E = new(mem_ctx) ir_if(operand(r349F).val);
         exec_list *const f349E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f349E->then_instructions;

            body.emit(assign(r349D, body.constant(4294967295u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f349E->else_instructions;

            ir_expression *const r34A0 = add(r3499, body.constant(int(-32)));
            body.emit(assign(r349D, lshift(body.constant(4294967295u), r34A0), 0x01));


         body.instructions = f349E_parent_instructions;
         body.emit(f349E);

         /* END IF */

         ir_variable *const r34A1 = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
         body.emit(assign(r34A1, bit_and(r349A, swizzle_x(r3221)), 0x01));

         body.emit(assign(r34A1, bit_and(r349D, swizzle_y(r3221)), 0x02));

         body.emit(assign(r3490, r34A1, 0x03));


      body.instructions = f3497_parent_instructions;
      body.emit(f3497);

      /* END IF */


   body.instructions = f3495_parent_instructions;
   body.emit(f3495);

   /* END IF */

   ir_variable *const r34A2 = body.make_temp(glsl_type::bool_type, "assignment_tmp");
   ir_expression *const r34A3 = rshift(swizzle_y(r3221), body.constant(int(31)));
   ir_expression *const r34A4 = expr(ir_unop_u2i, r34A3);
   body.emit(assign(r34A2, expr(ir_unop_i2b, r34A4), 0x01));

   ir_variable *const r34A5 = body.make_temp(glsl_type::bool_type, "or_tmp");
   /* IF CONDITION */
   ir_expression *const r34A7 = expr(ir_unop_logic_not, r34A2);
   ir_if *f34A6 = new(mem_ctx) ir_if(operand(r34A7).val);
   exec_list *const f34A6_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f34A6->then_instructions;

      body.emit(assign(r34A5, body.constant(true), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f34A6->else_instructions;

      ir_variable *const r34A8 = body.make_temp(glsl_type::bool_type, "return_value");
      ir_variable *const r34A9 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
      body.emit(r34A9);
      ir_variable *const r34AA = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
      body.emit(r34AA);
      ir_expression *const r34AB = rshift(swizzle_y(r3221), body.constant(int(20)));
      ir_expression *const r34AC = bit_and(r34AB, body.constant(2047u));
      ir_expression *const r34AD = expr(ir_unop_u2i, r34AC);
      ir_expression *const r34AE = equal(r34AD, body.constant(int(2047)));
      ir_expression *const r34AF = bit_and(swizzle_y(r3221), body.constant(1048575u));
      ir_expression *const r34B0 = bit_or(r34AF, swizzle_x(r3221));
      ir_expression *const r34B1 = nequal(r34B0, body.constant(0u));
      body.emit(assign(r34AA, logic_and(r34AE, r34B1), 0x01));

      ir_expression *const r34B2 = rshift(swizzle_y(r3490), body.constant(int(20)));
      ir_expression *const r34B3 = bit_and(r34B2, body.constant(2047u));
      ir_expression *const r34B4 = expr(ir_unop_u2i, r34B3);
      ir_expression *const r34B5 = equal(r34B4, body.constant(int(2047)));
      ir_expression *const r34B6 = bit_and(swizzle_y(r3490), body.constant(1048575u));
      ir_expression *const r34B7 = bit_or(r34B6, swizzle_x(r3490));
      ir_expression *const r34B8 = nequal(r34B7, body.constant(0u));
      body.emit(assign(r34A9, logic_and(r34B5, r34B8), 0x01));

      /* IF CONDITION */
      ir_expression *const r34BA = logic_or(r34AA, r34A9);
      ir_if *f34B9 = new(mem_ctx) ir_if(operand(r34BA).val);
      exec_list *const f34B9_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f34B9->then_instructions;

         body.emit(assign(r34A8, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f34B9->else_instructions;

         ir_expression *const r34BB = equal(swizzle_x(r3221), swizzle_x(r3490));
         ir_expression *const r34BC = equal(swizzle_y(r3221), swizzle_y(r3490));
         ir_expression *const r34BD = equal(swizzle_x(r3221), body.constant(0u));
         ir_expression *const r34BE = bit_or(swizzle_y(r3221), swizzle_y(r3490));
         ir_expression *const r34BF = lshift(r34BE, body.constant(int(1)));
         ir_expression *const r34C0 = equal(r34BF, body.constant(0u));
         ir_expression *const r34C1 = logic_and(r34BD, r34C0);
         ir_expression *const r34C2 = logic_or(r34BC, r34C1);
         body.emit(assign(r34A8, logic_and(r34BB, r34C2), 0x01));


      body.instructions = f34B9_parent_instructions;
      body.emit(f34B9);

      /* END IF */

      body.emit(assign(r34A5, r34A8, 0x01));


   body.instructions = f34A6_parent_instructions;
   body.emit(f34A6);

   /* END IF */

   ir_variable *const r34C3 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
   /* IF CONDITION */
   ir_if *f34C4 = new(mem_ctx) ir_if(operand(r34A5).val);
   exec_list *const f34C4_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f34C4->then_instructions;

      body.emit(assign(r34C3, r3490, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f34C4->else_instructions;

      ir_variable *const r34C5 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r34C6 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r34C6, rshift(swizzle_y(r3490), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r34C8 = equal(r34C6, body.constant(0u));
      ir_if *f34C7 = new(mem_ctx) ir_if(operand(r34C8).val);
      exec_list *const f34C7_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f34C7->then_instructions;

         ir_variable *const r34C9 = body.make_temp(glsl_type::uint_type, "zSign");
         body.emit(assign(r34C9, r34C6, 0x01));

         ir_variable *const r34CA = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r34CB = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r34CB);
         ir_variable *const r34CC = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
         body.emit(r34CC);
         ir_variable *const r34CD = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
         body.emit(r34CD);
         ir_variable *const r34CE = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r34CE);
         ir_variable *const r34CF = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r34CF);
         ir_variable *const r34D0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r34D0);
         ir_variable *const r34D1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r34D1);
         ir_variable *const r34D2 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r34D2);
         ir_variable *const r34D3 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r34D3, body.constant(0u), 0x01));

         ir_variable *const r34D4 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r34D5 = rshift(swizzle_y(r3490), body.constant(int(20)));
         ir_expression *const r34D6 = bit_and(r34D5, body.constant(2047u));
         body.emit(assign(r34D4, expr(ir_unop_u2i, r34D6), 0x01));

         body.emit(assign(r34CD, r34D4, 0x01));

         body.emit(assign(r34CC, body.constant(int(1023)), 0x01));

         body.emit(assign(r34CB, add(r34D4, body.constant(int(-1023))), 0x01));

         ir_variable *const r34D7 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r34D7, lshift(swizzle_x(r3490), body.constant(int(10))), 0x01));

         ir_variable *const r34D8 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         ir_expression *const r34D9 = bit_and(swizzle_y(r3490), body.constant(1048575u));
         ir_expression *const r34DA = lshift(r34D9, body.constant(int(10)));
         ir_expression *const r34DB = rshift(swizzle_x(r3490), body.constant(int(22)));
         body.emit(assign(r34D8, bit_or(r34DA, r34DB), 0x01));

         body.emit(assign(r34D0, r34D8, 0x01));

         body.emit(assign(r34D1, r34D7, 0x01));

         ir_variable *const r34DC = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r34DC, body.constant(0u), 0x01));

         ir_variable *const r34DD = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         body.emit(assign(r34DD, body.constant(0u), 0x01));

         body.emit(assign(r34CE, r34DD, 0x01));

         body.emit(assign(r34CF, body.constant(0u), 0x01));

         /* IF CONDITION */
         ir_expression *const r34DF = less(body.constant(int(0)), r34CB);
         ir_if *f34DE = new(mem_ctx) ir_if(operand(r34DF).val);
         exec_list *const f34DE_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f34DE->then_instructions;

            /* IF CONDITION */
            ir_expression *const r34E1 = equal(r34D4, body.constant(int(2047)));
            ir_if *f34E0 = new(mem_ctx) ir_if(operand(r34E1).val);
            exec_list *const f34E0_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f34E0->then_instructions;

               /* IF CONDITION */
               ir_expression *const r34E3 = bit_or(r34D8, r34D7);
               ir_expression *const r34E4 = nequal(r34E3, body.constant(0u));
               ir_if *f34E2 = new(mem_ctx) ir_if(operand(r34E4).val);
               exec_list *const f34E2_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f34E2->then_instructions;

                  ir_variable *const r34E5 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r34E5, swizzle_x(r3490), 0x01));

                  ir_variable *const r34E6 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r34E6, body.constant(0u), 0x01));

                  ir_variable *const r34E7 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r34E5, bit_or(swizzle_y(r3490), body.constant(524288u)), 0x02));

                  body.emit(assign(r34E6, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r34E9 = lshift(swizzle_y(r3490), body.constant(int(1)));
                  ir_expression *const r34EA = lequal(body.constant(4292870144u), r34E9);
                  ir_expression *const r34EB = nequal(swizzle_x(r3490), body.constant(0u));
                  ir_expression *const r34EC = bit_and(swizzle_y(r3490), body.constant(1048575u));
                  ir_expression *const r34ED = nequal(r34EC, body.constant(0u));
                  ir_expression *const r34EE = logic_or(r34EB, r34ED);
                  ir_expression *const r34EF = logic_and(r34EA, r34EE);
                  ir_if *f34E8 = new(mem_ctx) ir_if(operand(r34EF).val);
                  exec_list *const f34E8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f34E8->then_instructions;

                     body.emit(assign(r34E7, r34E5, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f34E8->else_instructions;

                     body.emit(assign(r34E7, r34E6, 0x03));


                  body.instructions = f34E8_parent_instructions;
                  body.emit(f34E8);

                  /* END IF */

                  body.emit(assign(r34CA, r34E7, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f34E2->else_instructions;

                  body.emit(assign(r34CA, r3490, 0x03));


               body.instructions = f34E2_parent_instructions;
               body.emit(f34E2);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f34E0->else_instructions;

               body.emit(assign(r34CE, body.constant(1073741824u), 0x01));

               ir_variable *const r34F0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r34F0);
               ir_variable *const r34F1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r34F1);
               ir_variable *const r34F2 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r34F3 = neg(r34CB);
               body.emit(assign(r34F2, bit_and(r34F3, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r34F5 = equal(r34CB, body.constant(int(0)));
               ir_if *f34F4 = new(mem_ctx) ir_if(operand(r34F5).val);
               exec_list *const f34F4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f34F4->then_instructions;

                  body.emit(assign(r34F0, body.constant(0u), 0x01));

                  body.emit(assign(r34F1, r34CE, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f34F4->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r34F7 = less(r34CB, body.constant(int(32)));
                  ir_if *f34F6 = new(mem_ctx) ir_if(operand(r34F7).val);
                  exec_list *const f34F6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f34F6->then_instructions;

                     ir_expression *const r34F8 = lshift(body.constant(1073741824u), r34F2);
                     ir_expression *const r34F9 = bit_or(r34F8, body.constant(0u));
                     body.emit(assign(r34F0, bit_or(r34F9, body.constant(0u)), 0x01));

                     body.emit(assign(r34F1, rshift(body.constant(1073741824u), r34CB), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f34F6->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r34FB = equal(r34CB, body.constant(int(32)));
                     ir_if *f34FA = new(mem_ctx) ir_if(operand(r34FB).val);
                     exec_list *const f34FA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f34FA->then_instructions;

                        body.emit(assign(r34F0, body.constant(1073741824u), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f34FA->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r34FD = less(r34CB, body.constant(int(64)));
                        ir_if *f34FC = new(mem_ctx) ir_if(operand(r34FD).val);
                        exec_list *const f34FC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f34FC->then_instructions;

                           ir_expression *const r34FE = bit_and(r34CB, body.constant(int(31)));
                           ir_expression *const r34FF = rshift(body.constant(1073741824u), r34FE);
                           ir_expression *const r3500 = lshift(body.constant(1073741824u), r34F2);
                           ir_expression *const r3501 = bit_or(r3500, body.constant(0u));
                           ir_expression *const r3502 = nequal(r3501, body.constant(0u));
                           ir_expression *const r3503 = expr(ir_unop_b2i, r3502);
                           ir_expression *const r3504 = expr(ir_unop_i2u, r3503);
                           body.emit(assign(r34F0, bit_or(r34FF, r3504), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f34FC->else_instructions;

                           body.emit(assign(r34F0, body.constant(1u), 0x01));


                        body.instructions = f34FC_parent_instructions;
                        body.emit(f34FC);

                        /* END IF */


                     body.instructions = f34FA_parent_instructions;
                     body.emit(f34FA);

                     /* END IF */

                     body.emit(assign(r34F1, body.constant(0u), 0x01));


                  body.instructions = f34F6_parent_instructions;
                  body.emit(f34F6);

                  /* END IF */


               body.instructions = f34F4_parent_instructions;
               body.emit(f34F4);

               /* END IF */

               body.emit(assign(r34CE, r34F1, 0x01));

               body.emit(assign(r34CF, r34F0, 0x01));

               body.emit(assign(r34D0, bit_or(r34D8, body.constant(1073741824u)), 0x01));

               ir_variable *const r3505 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r3506 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r3506, sub(r34D7, r34F0), 0x01));

               ir_expression *const r3507 = sub(r34D0, r34F1);
               ir_expression *const r3508 = less(r34D7, r34F0);
               ir_expression *const r3509 = expr(ir_unop_b2i, r3508);
               ir_expression *const r350A = expr(ir_unop_i2u, r3509);
               body.emit(assign(r3505, sub(r3507, r350A), 0x01));

               body.emit(assign(r34D2, add(r34D4, body.constant(int(-1))), 0x01));

               ir_variable *const r350B = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r350B, add(r34D2, body.constant(int(-10))), 0x01));

               ir_variable *const r350C = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r350C, r3505, 0x01));

               ir_variable *const r350D = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r350D, r3506, 0x01));

               ir_variable *const r350E = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r350E);
               ir_variable *const r350F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r350F);
               /* IF CONDITION */
               ir_expression *const r3511 = equal(r3505, body.constant(0u));
               ir_if *f3510 = new(mem_ctx) ir_if(operand(r3511).val);
               exec_list *const f3510_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3510->then_instructions;

                  body.emit(assign(r350C, r3506, 0x01));

                  body.emit(assign(r350D, body.constant(0u), 0x01));

                  body.emit(assign(r350B, add(r350B, body.constant(int(-32))), 0x01));


               body.instructions = f3510_parent_instructions;
               body.emit(f3510);

               /* END IF */

               ir_variable *const r3512 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r3512, r350C, 0x01));

               ir_variable *const r3513 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r3514 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r3514);
               /* IF CONDITION */
               ir_expression *const r3516 = equal(r350C, body.constant(0u));
               ir_if *f3515 = new(mem_ctx) ir_if(operand(r3516).val);
               exec_list *const f3515_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3515->then_instructions;

                  body.emit(assign(r3513, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3515->else_instructions;

                  body.emit(assign(r3514, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3518 = bit_and(r350C, body.constant(4294901760u));
                  ir_expression *const r3519 = equal(r3518, body.constant(0u));
                  ir_if *f3517 = new(mem_ctx) ir_if(operand(r3519).val);
                  exec_list *const f3517_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3517->then_instructions;

                     body.emit(assign(r3514, body.constant(int(16)), 0x01));

                     body.emit(assign(r3512, lshift(r350C, body.constant(int(16))), 0x01));


                  body.instructions = f3517_parent_instructions;
                  body.emit(f3517);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r351B = bit_and(r3512, body.constant(4278190080u));
                  ir_expression *const r351C = equal(r351B, body.constant(0u));
                  ir_if *f351A = new(mem_ctx) ir_if(operand(r351C).val);
                  exec_list *const f351A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f351A->then_instructions;

                     body.emit(assign(r3514, add(r3514, body.constant(int(8))), 0x01));

                     body.emit(assign(r3512, lshift(r3512, body.constant(int(8))), 0x01));


                  body.instructions = f351A_parent_instructions;
                  body.emit(f351A);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r351E = bit_and(r3512, body.constant(4026531840u));
                  ir_expression *const r351F = equal(r351E, body.constant(0u));
                  ir_if *f351D = new(mem_ctx) ir_if(operand(r351F).val);
                  exec_list *const f351D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f351D->then_instructions;

                     body.emit(assign(r3514, add(r3514, body.constant(int(4))), 0x01));

                     body.emit(assign(r3512, lshift(r3512, body.constant(int(4))), 0x01));


                  body.instructions = f351D_parent_instructions;
                  body.emit(f351D);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r3521 = bit_and(r3512, body.constant(3221225472u));
                  ir_expression *const r3522 = equal(r3521, body.constant(0u));
                  ir_if *f3520 = new(mem_ctx) ir_if(operand(r3522).val);
                  exec_list *const f3520_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3520->then_instructions;

                     body.emit(assign(r3514, add(r3514, body.constant(int(2))), 0x01));

                     body.emit(assign(r3512, lshift(r3512, body.constant(int(2))), 0x01));


                  body.instructions = f3520_parent_instructions;
                  body.emit(f3520);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r3524 = bit_and(r3512, body.constant(2147483648u));
                  ir_expression *const r3525 = equal(r3524, body.constant(0u));
                  ir_if *f3523 = new(mem_ctx) ir_if(operand(r3525).val);
                  exec_list *const f3523_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3523->then_instructions;

                     body.emit(assign(r3514, add(r3514, body.constant(int(1))), 0x01));


                  body.instructions = f3523_parent_instructions;
                  body.emit(f3523);

                  /* END IF */

                  body.emit(assign(r3513, r3514, 0x01));


               body.instructions = f3515_parent_instructions;
               body.emit(f3515);

               /* END IF */

               body.emit(assign(r350F, add(r3513, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3527 = lequal(body.constant(int(0)), r350F);
               ir_if *f3526 = new(mem_ctx) ir_if(operand(r3527).val);
               exec_list *const f3526_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3526->then_instructions;

                  body.emit(assign(r350E, body.constant(0u), 0x01));

                  ir_variable *const r3528 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r3528, lshift(r350D, r350F), 0x01));

                  ir_variable *const r3529 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r352B = equal(r350F, body.constant(int(0)));
                  ir_if *f352A = new(mem_ctx) ir_if(operand(r352B).val);
                  exec_list *const f352A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f352A->then_instructions;

                     body.emit(assign(r3529, r350C, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f352A->else_instructions;

                     ir_expression *const r352C = lshift(r350C, r350F);
                     ir_expression *const r352D = neg(r350F);
                     ir_expression *const r352E = bit_and(r352D, body.constant(int(31)));
                     ir_expression *const r352F = rshift(r350D, r352E);
                     body.emit(assign(r3529, bit_or(r352C, r352F), 0x01));


                  body.instructions = f352A_parent_instructions;
                  body.emit(f352A);

                  /* END IF */

                  body.emit(assign(r350C, r3529, 0x01));

                  body.emit(assign(r350D, r3528, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3526->else_instructions;

                  ir_variable *const r3530 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r3530, body.constant(0u), 0x01));

                  ir_variable *const r3531 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r3531, neg(r350F), 0x01));

                  ir_variable *const r3532 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r3532);
                  ir_variable *const r3533 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r3533);
                  ir_variable *const r3534 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r3534);
                  ir_variable *const r3535 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r3536 = neg(r3531);
                  body.emit(assign(r3535, bit_and(r3536, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3538 = equal(r3531, body.constant(int(0)));
                  ir_if *f3537 = new(mem_ctx) ir_if(operand(r3538).val);
                  exec_list *const f3537_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3537->then_instructions;

                     body.emit(assign(r3532, r3530, 0x01));

                     body.emit(assign(r3533, r350D, 0x01));

                     body.emit(assign(r3534, r350C, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3537->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r353A = less(r3531, body.constant(int(32)));
                     ir_if *f3539 = new(mem_ctx) ir_if(operand(r353A).val);
                     exec_list *const f3539_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3539->then_instructions;

                        body.emit(assign(r3532, lshift(r350D, r3535), 0x01));

                        ir_expression *const r353B = lshift(r350C, r3535);
                        ir_expression *const r353C = rshift(r350D, r3531);
                        body.emit(assign(r3533, bit_or(r353B, r353C), 0x01));

                        body.emit(assign(r3534, rshift(r350C, r3531), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3539->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r353E = equal(r3531, body.constant(int(32)));
                        ir_if *f353D = new(mem_ctx) ir_if(operand(r353E).val);
                        exec_list *const f353D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f353D->then_instructions;

                           body.emit(assign(r3532, r350D, 0x01));

                           body.emit(assign(r3533, r350C, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f353D->else_instructions;

                           body.emit(assign(r3530, bit_or(body.constant(0u), r350D), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3540 = less(r3531, body.constant(int(64)));
                           ir_if *f353F = new(mem_ctx) ir_if(operand(r3540).val);
                           exec_list *const f353F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f353F->then_instructions;

                              body.emit(assign(r3532, lshift(r350C, r3535), 0x01));

                              ir_expression *const r3541 = bit_and(r3531, body.constant(int(31)));
                              body.emit(assign(r3533, rshift(r350C, r3541), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f353F->else_instructions;

                              ir_variable *const r3542 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r3544 = equal(r3531, body.constant(int(64)));
                              ir_if *f3543 = new(mem_ctx) ir_if(operand(r3544).val);
                              exec_list *const f3543_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3543->then_instructions;

                                 body.emit(assign(r3542, r350C, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3543->else_instructions;

                                 ir_expression *const r3545 = nequal(r350C, body.constant(0u));
                                 ir_expression *const r3546 = expr(ir_unop_b2i, r3545);
                                 body.emit(assign(r3542, expr(ir_unop_i2u, r3546), 0x01));


                              body.instructions = f3543_parent_instructions;
                              body.emit(f3543);

                              /* END IF */

                              body.emit(assign(r3532, r3542, 0x01));

                              body.emit(assign(r3533, body.constant(0u), 0x01));


                           body.instructions = f353F_parent_instructions;
                           body.emit(f353F);

                           /* END IF */


                        body.instructions = f353D_parent_instructions;
                        body.emit(f353D);

                        /* END IF */

                        body.emit(assign(r3534, body.constant(0u), 0x01));


                     body.instructions = f3539_parent_instructions;
                     body.emit(f3539);

                     /* END IF */

                     ir_expression *const r3547 = nequal(r3530, body.constant(0u));
                     ir_expression *const r3548 = expr(ir_unop_b2i, r3547);
                     ir_expression *const r3549 = expr(ir_unop_i2u, r3548);
                     body.emit(assign(r3532, bit_or(r3532, r3549), 0x01));


                  body.instructions = f3537_parent_instructions;
                  body.emit(f3537);

                  /* END IF */

                  body.emit(assign(r350C, r3534, 0x01));

                  body.emit(assign(r350D, r3533, 0x01));

                  body.emit(assign(r350E, r3532, 0x01));


               body.instructions = f3526_parent_instructions;
               body.emit(f3526);

               /* END IF */

               body.emit(assign(r350B, sub(r350B, r350F), 0x01));

               ir_variable *const r354A = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r354A, r350B, 0x01));

               ir_variable *const r354B = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r354B, r350C, 0x01));

               ir_variable *const r354C = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r354C, r350D, 0x01));

               ir_variable *const r354D = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r354D, r350E, 0x01));

               ir_variable *const r354E = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r354E, body.constant(true), 0x01));

               ir_variable *const r354F = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r3550 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r3550);
               ir_expression *const r3551 = expr(ir_unop_u2i, r350E);
               body.emit(assign(r3550, less(r3551, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3553 = lequal(body.constant(int(2045)), r350B);
               ir_if *f3552 = new(mem_ctx) ir_if(operand(r3553).val);
               exec_list *const f3552_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3552->then_instructions;

                  ir_variable *const r3554 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3556 = less(body.constant(int(2045)), r350B);
                  ir_if *f3555 = new(mem_ctx) ir_if(operand(r3556).val);
                  exec_list *const f3555_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3555->then_instructions;

                     body.emit(assign(r3554, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3555->else_instructions;

                     ir_variable *const r3557 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3559 = equal(r350B, body.constant(int(2045)));
                     ir_if *f3558 = new(mem_ctx) ir_if(operand(r3559).val);
                     exec_list *const f3558_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3558->then_instructions;

                        ir_expression *const r355A = equal(body.constant(2097151u), r350C);
                        ir_expression *const r355B = equal(body.constant(4294967295u), r350D);
                        body.emit(assign(r3557, logic_and(r355A, r355B), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3558->else_instructions;

                        body.emit(assign(r3557, body.constant(false), 0x01));


                     body.instructions = f3558_parent_instructions;
                     body.emit(f3558);

                     /* END IF */

                     body.emit(assign(r3554, logic_and(r3557, r3550), 0x01));


                  body.instructions = f3555_parent_instructions;
                  body.emit(f3555);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f355C = new(mem_ctx) ir_if(operand(r3554).val);
                  exec_list *const f355C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f355C->then_instructions;

                     ir_variable *const r355D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r355D);
                     ir_expression *const r355E = lshift(r34C6, body.constant(int(31)));
                     body.emit(assign(r355D, add(r355E, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r355D, body.constant(0u), 0x01));

                     body.emit(assign(r354F, r355D, 0x03));

                     body.emit(assign(r354E, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f355C->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3560 = less(r350B, body.constant(int(0)));
                     ir_if *f355F = new(mem_ctx) ir_if(operand(r3560).val);
                     exec_list *const f355F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f355F->then_instructions;

                        ir_variable *const r3561 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r3561, r350E, 0x01));

                        ir_variable *const r3562 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r3562, neg(r350B), 0x01));

                        ir_variable *const r3563 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r3563);
                        ir_variable *const r3564 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r3564);
                        ir_variable *const r3565 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r3565);
                        ir_variable *const r3566 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r3567 = neg(r3562);
                        body.emit(assign(r3566, bit_and(r3567, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3569 = equal(r3562, body.constant(int(0)));
                        ir_if *f3568 = new(mem_ctx) ir_if(operand(r3569).val);
                        exec_list *const f3568_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3568->then_instructions;

                           body.emit(assign(r3563, r350E, 0x01));

                           body.emit(assign(r3564, r350D, 0x01));

                           body.emit(assign(r3565, r350C, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3568->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r356B = less(r3562, body.constant(int(32)));
                           ir_if *f356A = new(mem_ctx) ir_if(operand(r356B).val);
                           exec_list *const f356A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f356A->then_instructions;

                              body.emit(assign(r3563, lshift(r350D, r3566), 0x01));

                              ir_expression *const r356C = lshift(r350C, r3566);
                              ir_expression *const r356D = rshift(r350D, r3562);
                              body.emit(assign(r3564, bit_or(r356C, r356D), 0x01));

                              body.emit(assign(r3565, rshift(r350C, r3562), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f356A->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r356F = equal(r3562, body.constant(int(32)));
                              ir_if *f356E = new(mem_ctx) ir_if(operand(r356F).val);
                              exec_list *const f356E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f356E->then_instructions;

                                 body.emit(assign(r3563, r350D, 0x01));

                                 body.emit(assign(r3564, r350C, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f356E->else_instructions;

                                 body.emit(assign(r3561, bit_or(r350E, r350D), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3571 = less(r3562, body.constant(int(64)));
                                 ir_if *f3570 = new(mem_ctx) ir_if(operand(r3571).val);
                                 exec_list *const f3570_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3570->then_instructions;

                                    body.emit(assign(r3563, lshift(r350C, r3566), 0x01));

                                    ir_expression *const r3572 = bit_and(r3562, body.constant(int(31)));
                                    body.emit(assign(r3564, rshift(r350C, r3572), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3570->else_instructions;

                                    ir_variable *const r3573 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r3575 = equal(r3562, body.constant(int(64)));
                                    ir_if *f3574 = new(mem_ctx) ir_if(operand(r3575).val);
                                    exec_list *const f3574_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3574->then_instructions;

                                       body.emit(assign(r3573, r350C, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3574->else_instructions;

                                       ir_expression *const r3576 = nequal(r350C, body.constant(0u));
                                       ir_expression *const r3577 = expr(ir_unop_b2i, r3576);
                                       body.emit(assign(r3573, expr(ir_unop_i2u, r3577), 0x01));


                                    body.instructions = f3574_parent_instructions;
                                    body.emit(f3574);

                                    /* END IF */

                                    body.emit(assign(r3563, r3573, 0x01));

                                    body.emit(assign(r3564, body.constant(0u), 0x01));


                                 body.instructions = f3570_parent_instructions;
                                 body.emit(f3570);

                                 /* END IF */


                              body.instructions = f356E_parent_instructions;
                              body.emit(f356E);

                              /* END IF */

                              body.emit(assign(r3565, body.constant(0u), 0x01));


                           body.instructions = f356A_parent_instructions;
                           body.emit(f356A);

                           /* END IF */

                           ir_expression *const r3578 = nequal(r3561, body.constant(0u));
                           ir_expression *const r3579 = expr(ir_unop_b2i, r3578);
                           ir_expression *const r357A = expr(ir_unop_i2u, r3579);
                           body.emit(assign(r3563, bit_or(r3563, r357A), 0x01));


                        body.instructions = f3568_parent_instructions;
                        body.emit(f3568);

                        /* END IF */

                        body.emit(assign(r354B, r3565, 0x01));

                        body.emit(assign(r354C, r3564, 0x01));

                        body.emit(assign(r354D, r3563, 0x01));

                        body.emit(assign(r354A, body.constant(int(0)), 0x01));

                        body.emit(assign(r3550, less(r3563, body.constant(0u)), 0x01));


                     body.instructions = f355F_parent_instructions;
                     body.emit(f355F);

                     /* END IF */


                  body.instructions = f355C_parent_instructions;
                  body.emit(f355C);

                  /* END IF */


               body.instructions = f3552_parent_instructions;
               body.emit(f3552);

               /* END IF */

               /* IF CONDITION */
               ir_if *f357B = new(mem_ctx) ir_if(operand(r354E).val);
               exec_list *const f357B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f357B->then_instructions;

                  /* IF CONDITION */
                  ir_if *f357C = new(mem_ctx) ir_if(operand(r3550).val);
                  exec_list *const f357C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f357C->then_instructions;

                     ir_variable *const r357D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r357D, add(r354C, body.constant(1u)), 0x01));

                     ir_expression *const r357E = less(r357D, r354C);
                     ir_expression *const r357F = expr(ir_unop_b2i, r357E);
                     ir_expression *const r3580 = expr(ir_unop_i2u, r357F);
                     body.emit(assign(r354B, add(r354B, r3580), 0x01));

                     ir_expression *const r3581 = equal(r354D, body.constant(0u));
                     ir_expression *const r3582 = expr(ir_unop_b2i, r3581);
                     ir_expression *const r3583 = expr(ir_unop_i2u, r3582);
                     ir_expression *const r3584 = add(r354D, r3583);
                     ir_expression *const r3585 = bit_and(r3584, body.constant(1u));
                     ir_expression *const r3586 = expr(ir_unop_bit_not, r3585);
                     body.emit(assign(r354C, bit_and(r357D, r3586), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f357C->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3588 = bit_or(r354B, r354C);
                     ir_expression *const r3589 = equal(r3588, body.constant(0u));
                     ir_if *f3587 = new(mem_ctx) ir_if(operand(r3589).val);
                     exec_list *const f3587_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3587->then_instructions;

                        body.emit(assign(r354A, body.constant(int(0)), 0x01));


                     body.instructions = f3587_parent_instructions;
                     body.emit(f3587);

                     /* END IF */


                  body.instructions = f357C_parent_instructions;
                  body.emit(f357C);

                  /* END IF */

                  ir_variable *const r358A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r358A);
                  ir_expression *const r358B = lshift(r34C6, body.constant(int(31)));
                  ir_expression *const r358C = expr(ir_unop_i2u, r354A);
                  ir_expression *const r358D = lshift(r358C, body.constant(int(20)));
                  ir_expression *const r358E = add(r358B, r358D);
                  body.emit(assign(r358A, add(r358E, r354B), 0x02));

                  body.emit(assign(r358A, r354C, 0x01));

                  body.emit(assign(r354F, r358A, 0x03));

                  body.emit(assign(r354E, body.constant(false), 0x01));


               body.instructions = f357B_parent_instructions;
               body.emit(f357B);

               /* END IF */

               body.emit(assign(r34CA, r354F, 0x03));


            body.instructions = f34E0_parent_instructions;
            body.emit(f34E0);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f34DE->else_instructions;

            /* IF CONDITION */
            ir_expression *const r3590 = less(r34CB, body.constant(int(0)));
            ir_if *f358F = new(mem_ctx) ir_if(operand(r3590).val);
            exec_list *const f358F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f358F->then_instructions;

               /* IF CONDITION */
               ir_expression *const r3592 = equal(r34D4, body.constant(int(0)));
               ir_if *f3591 = new(mem_ctx) ir_if(operand(r3592).val);
               exec_list *const f3591_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3591->then_instructions;

                  body.emit(assign(r34CB, add(r34CB, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3591->else_instructions;

                  body.emit(assign(r34D0, bit_or(r34D0, body.constant(1073741824u)), 0x01));


               body.instructions = f3591_parent_instructions;
               body.emit(f3591);

               /* END IF */

               ir_variable *const r3593 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r3593, neg(r34CB), 0x01));

               ir_variable *const r3594 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3594);
               ir_variable *const r3595 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3595);
               ir_variable *const r3596 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r3597 = neg(r3593);
               body.emit(assign(r3596, bit_and(r3597, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3599 = equal(r3593, body.constant(int(0)));
               ir_if *f3598 = new(mem_ctx) ir_if(operand(r3599).val);
               exec_list *const f3598_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3598->then_instructions;

                  body.emit(assign(r3594, r34D7, 0x01));

                  body.emit(assign(r3595, r34D0, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3598->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r359B = less(r3593, body.constant(int(32)));
                  ir_if *f359A = new(mem_ctx) ir_if(operand(r359B).val);
                  exec_list *const f359A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f359A->then_instructions;

                     ir_expression *const r359C = lshift(r34D0, r3596);
                     ir_expression *const r359D = rshift(r34D7, r3593);
                     ir_expression *const r359E = bit_or(r359C, r359D);
                     ir_expression *const r359F = lshift(r34D7, r3596);
                     ir_expression *const r35A0 = nequal(r359F, body.constant(0u));
                     ir_expression *const r35A1 = expr(ir_unop_b2i, r35A0);
                     ir_expression *const r35A2 = expr(ir_unop_i2u, r35A1);
                     body.emit(assign(r3594, bit_or(r359E, r35A2), 0x01));

                     body.emit(assign(r3595, rshift(r34D0, r3593), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f359A->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r35A4 = equal(r3593, body.constant(int(32)));
                     ir_if *f35A3 = new(mem_ctx) ir_if(operand(r35A4).val);
                     exec_list *const f35A3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f35A3->then_instructions;

                        ir_expression *const r35A5 = nequal(r34D7, body.constant(0u));
                        ir_expression *const r35A6 = expr(ir_unop_b2i, r35A5);
                        ir_expression *const r35A7 = expr(ir_unop_i2u, r35A6);
                        body.emit(assign(r3594, bit_or(r34D0, r35A7), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f35A3->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r35A9 = less(r3593, body.constant(int(64)));
                        ir_if *f35A8 = new(mem_ctx) ir_if(operand(r35A9).val);
                        exec_list *const f35A8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f35A8->then_instructions;

                           ir_expression *const r35AA = bit_and(r3593, body.constant(int(31)));
                           ir_expression *const r35AB = rshift(r34D0, r35AA);
                           ir_expression *const r35AC = lshift(r34D0, r3596);
                           ir_expression *const r35AD = bit_or(r35AC, r34D7);
                           ir_expression *const r35AE = nequal(r35AD, body.constant(0u));
                           ir_expression *const r35AF = expr(ir_unop_b2i, r35AE);
                           ir_expression *const r35B0 = expr(ir_unop_i2u, r35AF);
                           body.emit(assign(r3594, bit_or(r35AB, r35B0), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f35A8->else_instructions;

                           ir_expression *const r35B1 = bit_or(r34D0, r34D7);
                           ir_expression *const r35B2 = nequal(r35B1, body.constant(0u));
                           ir_expression *const r35B3 = expr(ir_unop_b2i, r35B2);
                           body.emit(assign(r3594, expr(ir_unop_i2u, r35B3), 0x01));


                        body.instructions = f35A8_parent_instructions;
                        body.emit(f35A8);

                        /* END IF */


                     body.instructions = f35A3_parent_instructions;
                     body.emit(f35A3);

                     /* END IF */

                     body.emit(assign(r3595, body.constant(0u), 0x01));


                  body.instructions = f359A_parent_instructions;
                  body.emit(f359A);

                  /* END IF */


               body.instructions = f3598_parent_instructions;
               body.emit(f3598);

               /* END IF */

               body.emit(assign(r34D0, r3595, 0x01));

               body.emit(assign(r34D1, r3594, 0x01));

               body.emit(assign(r34CE, bit_or(r34CE, body.constant(1073741824u)), 0x01));

               ir_variable *const r35B4 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r35B5 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r35B5, sub(r34CF, r3594), 0x01));

               ir_expression *const r35B6 = sub(r34CE, r3595);
               ir_expression *const r35B7 = less(r34CF, r3594);
               ir_expression *const r35B8 = expr(ir_unop_b2i, r35B7);
               ir_expression *const r35B9 = expr(ir_unop_i2u, r35B8);
               body.emit(assign(r35B4, sub(r35B6, r35B9), 0x01));

               body.emit(assign(r34C9, bit_xor(r34C6, body.constant(1u)), 0x01));

               body.emit(assign(r34D2, body.constant(int(1022)), 0x01));

               ir_variable *const r35BA = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r35BA, body.constant(int(1012)), 0x01));

               ir_variable *const r35BB = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r35BB, r35B4, 0x01));

               ir_variable *const r35BC = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r35BC, r35B5, 0x01));

               ir_variable *const r35BD = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r35BD);
               ir_variable *const r35BE = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r35BE);
               /* IF CONDITION */
               ir_expression *const r35C0 = equal(r35B4, body.constant(0u));
               ir_if *f35BF = new(mem_ctx) ir_if(operand(r35C0).val);
               exec_list *const f35BF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f35BF->then_instructions;

                  body.emit(assign(r35BB, r35B5, 0x01));

                  body.emit(assign(r35BC, body.constant(0u), 0x01));

                  body.emit(assign(r35BA, body.constant(int(980)), 0x01));


               body.instructions = f35BF_parent_instructions;
               body.emit(f35BF);

               /* END IF */

               ir_variable *const r35C1 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r35C1, r35BB, 0x01));

               ir_variable *const r35C2 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r35C3 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r35C3);
               /* IF CONDITION */
               ir_expression *const r35C5 = equal(r35BB, body.constant(0u));
               ir_if *f35C4 = new(mem_ctx) ir_if(operand(r35C5).val);
               exec_list *const f35C4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f35C4->then_instructions;

                  body.emit(assign(r35C2, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f35C4->else_instructions;

                  body.emit(assign(r35C3, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r35C7 = bit_and(r35BB, body.constant(4294901760u));
                  ir_expression *const r35C8 = equal(r35C7, body.constant(0u));
                  ir_if *f35C6 = new(mem_ctx) ir_if(operand(r35C8).val);
                  exec_list *const f35C6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f35C6->then_instructions;

                     body.emit(assign(r35C3, body.constant(int(16)), 0x01));

                     body.emit(assign(r35C1, lshift(r35BB, body.constant(int(16))), 0x01));


                  body.instructions = f35C6_parent_instructions;
                  body.emit(f35C6);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r35CA = bit_and(r35C1, body.constant(4278190080u));
                  ir_expression *const r35CB = equal(r35CA, body.constant(0u));
                  ir_if *f35C9 = new(mem_ctx) ir_if(operand(r35CB).val);
                  exec_list *const f35C9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f35C9->then_instructions;

                     body.emit(assign(r35C3, add(r35C3, body.constant(int(8))), 0x01));

                     body.emit(assign(r35C1, lshift(r35C1, body.constant(int(8))), 0x01));


                  body.instructions = f35C9_parent_instructions;
                  body.emit(f35C9);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r35CD = bit_and(r35C1, body.constant(4026531840u));
                  ir_expression *const r35CE = equal(r35CD, body.constant(0u));
                  ir_if *f35CC = new(mem_ctx) ir_if(operand(r35CE).val);
                  exec_list *const f35CC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f35CC->then_instructions;

                     body.emit(assign(r35C3, add(r35C3, body.constant(int(4))), 0x01));

                     body.emit(assign(r35C1, lshift(r35C1, body.constant(int(4))), 0x01));


                  body.instructions = f35CC_parent_instructions;
                  body.emit(f35CC);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r35D0 = bit_and(r35C1, body.constant(3221225472u));
                  ir_expression *const r35D1 = equal(r35D0, body.constant(0u));
                  ir_if *f35CF = new(mem_ctx) ir_if(operand(r35D1).val);
                  exec_list *const f35CF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f35CF->then_instructions;

                     body.emit(assign(r35C3, add(r35C3, body.constant(int(2))), 0x01));

                     body.emit(assign(r35C1, lshift(r35C1, body.constant(int(2))), 0x01));


                  body.instructions = f35CF_parent_instructions;
                  body.emit(f35CF);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r35D3 = bit_and(r35C1, body.constant(2147483648u));
                  ir_expression *const r35D4 = equal(r35D3, body.constant(0u));
                  ir_if *f35D2 = new(mem_ctx) ir_if(operand(r35D4).val);
                  exec_list *const f35D2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f35D2->then_instructions;

                     body.emit(assign(r35C3, add(r35C3, body.constant(int(1))), 0x01));


                  body.instructions = f35D2_parent_instructions;
                  body.emit(f35D2);

                  /* END IF */

                  body.emit(assign(r35C2, r35C3, 0x01));


               body.instructions = f35C4_parent_instructions;
               body.emit(f35C4);

               /* END IF */

               body.emit(assign(r35BE, add(r35C2, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r35D6 = lequal(body.constant(int(0)), r35BE);
               ir_if *f35D5 = new(mem_ctx) ir_if(operand(r35D6).val);
               exec_list *const f35D5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f35D5->then_instructions;

                  body.emit(assign(r35BD, body.constant(0u), 0x01));

                  ir_variable *const r35D7 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r35D7, lshift(r35BC, r35BE), 0x01));

                  ir_variable *const r35D8 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r35DA = equal(r35BE, body.constant(int(0)));
                  ir_if *f35D9 = new(mem_ctx) ir_if(operand(r35DA).val);
                  exec_list *const f35D9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f35D9->then_instructions;

                     body.emit(assign(r35D8, r35BB, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f35D9->else_instructions;

                     ir_expression *const r35DB = lshift(r35BB, r35BE);
                     ir_expression *const r35DC = neg(r35BE);
                     ir_expression *const r35DD = bit_and(r35DC, body.constant(int(31)));
                     ir_expression *const r35DE = rshift(r35BC, r35DD);
                     body.emit(assign(r35D8, bit_or(r35DB, r35DE), 0x01));


                  body.instructions = f35D9_parent_instructions;
                  body.emit(f35D9);

                  /* END IF */

                  body.emit(assign(r35BB, r35D8, 0x01));

                  body.emit(assign(r35BC, r35D7, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f35D5->else_instructions;

                  ir_variable *const r35DF = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r35DF, body.constant(0u), 0x01));

                  ir_variable *const r35E0 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r35E0, neg(r35BE), 0x01));

                  ir_variable *const r35E1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r35E1);
                  ir_variable *const r35E2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r35E2);
                  ir_variable *const r35E3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r35E3);
                  ir_variable *const r35E4 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r35E5 = neg(r35E0);
                  body.emit(assign(r35E4, bit_and(r35E5, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r35E7 = equal(r35E0, body.constant(int(0)));
                  ir_if *f35E6 = new(mem_ctx) ir_if(operand(r35E7).val);
                  exec_list *const f35E6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f35E6->then_instructions;

                     body.emit(assign(r35E1, r35DF, 0x01));

                     body.emit(assign(r35E2, r35BC, 0x01));

                     body.emit(assign(r35E3, r35BB, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f35E6->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r35E9 = less(r35E0, body.constant(int(32)));
                     ir_if *f35E8 = new(mem_ctx) ir_if(operand(r35E9).val);
                     exec_list *const f35E8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f35E8->then_instructions;

                        body.emit(assign(r35E1, lshift(r35BC, r35E4), 0x01));

                        ir_expression *const r35EA = lshift(r35BB, r35E4);
                        ir_expression *const r35EB = rshift(r35BC, r35E0);
                        body.emit(assign(r35E2, bit_or(r35EA, r35EB), 0x01));

                        body.emit(assign(r35E3, rshift(r35BB, r35E0), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f35E8->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r35ED = equal(r35E0, body.constant(int(32)));
                        ir_if *f35EC = new(mem_ctx) ir_if(operand(r35ED).val);
                        exec_list *const f35EC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f35EC->then_instructions;

                           body.emit(assign(r35E1, r35BC, 0x01));

                           body.emit(assign(r35E2, r35BB, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f35EC->else_instructions;

                           body.emit(assign(r35DF, bit_or(body.constant(0u), r35BC), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r35EF = less(r35E0, body.constant(int(64)));
                           ir_if *f35EE = new(mem_ctx) ir_if(operand(r35EF).val);
                           exec_list *const f35EE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f35EE->then_instructions;

                              body.emit(assign(r35E1, lshift(r35BB, r35E4), 0x01));

                              ir_expression *const r35F0 = bit_and(r35E0, body.constant(int(31)));
                              body.emit(assign(r35E2, rshift(r35BB, r35F0), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f35EE->else_instructions;

                              ir_variable *const r35F1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r35F3 = equal(r35E0, body.constant(int(64)));
                              ir_if *f35F2 = new(mem_ctx) ir_if(operand(r35F3).val);
                              exec_list *const f35F2_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f35F2->then_instructions;

                                 body.emit(assign(r35F1, r35BB, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f35F2->else_instructions;

                                 ir_expression *const r35F4 = nequal(r35BB, body.constant(0u));
                                 ir_expression *const r35F5 = expr(ir_unop_b2i, r35F4);
                                 body.emit(assign(r35F1, expr(ir_unop_i2u, r35F5), 0x01));


                              body.instructions = f35F2_parent_instructions;
                              body.emit(f35F2);

                              /* END IF */

                              body.emit(assign(r35E1, r35F1, 0x01));

                              body.emit(assign(r35E2, body.constant(0u), 0x01));


                           body.instructions = f35EE_parent_instructions;
                           body.emit(f35EE);

                           /* END IF */


                        body.instructions = f35EC_parent_instructions;
                        body.emit(f35EC);

                        /* END IF */

                        body.emit(assign(r35E3, body.constant(0u), 0x01));


                     body.instructions = f35E8_parent_instructions;
                     body.emit(f35E8);

                     /* END IF */

                     ir_expression *const r35F6 = nequal(r35DF, body.constant(0u));
                     ir_expression *const r35F7 = expr(ir_unop_b2i, r35F6);
                     ir_expression *const r35F8 = expr(ir_unop_i2u, r35F7);
                     body.emit(assign(r35E1, bit_or(r35E1, r35F8), 0x01));


                  body.instructions = f35E6_parent_instructions;
                  body.emit(f35E6);

                  /* END IF */

                  body.emit(assign(r35BB, r35E3, 0x01));

                  body.emit(assign(r35BC, r35E2, 0x01));

                  body.emit(assign(r35BD, r35E1, 0x01));


               body.instructions = f35D5_parent_instructions;
               body.emit(f35D5);

               /* END IF */

               body.emit(assign(r35BA, sub(r35BA, r35BE), 0x01));

               ir_variable *const r35F9 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r35F9, r35BA, 0x01));

               ir_variable *const r35FA = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r35FA, r35BB, 0x01));

               ir_variable *const r35FB = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r35FB, r35BC, 0x01));

               ir_variable *const r35FC = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r35FC, r35BD, 0x01));

               ir_variable *const r35FD = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r35FD, body.constant(true), 0x01));

               ir_variable *const r35FE = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r35FF = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r35FF);
               ir_expression *const r3600 = expr(ir_unop_u2i, r35BD);
               body.emit(assign(r35FF, less(r3600, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3602 = lequal(body.constant(int(2045)), r35BA);
               ir_if *f3601 = new(mem_ctx) ir_if(operand(r3602).val);
               exec_list *const f3601_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3601->then_instructions;

                  ir_variable *const r3603 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3605 = less(body.constant(int(2045)), r35BA);
                  ir_if *f3604 = new(mem_ctx) ir_if(operand(r3605).val);
                  exec_list *const f3604_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3604->then_instructions;

                     body.emit(assign(r3603, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3604->else_instructions;

                     ir_variable *const r3606 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3608 = equal(r35BA, body.constant(int(2045)));
                     ir_if *f3607 = new(mem_ctx) ir_if(operand(r3608).val);
                     exec_list *const f3607_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3607->then_instructions;

                        ir_expression *const r3609 = equal(body.constant(2097151u), r35BB);
                        ir_expression *const r360A = equal(body.constant(4294967295u), r35BC);
                        body.emit(assign(r3606, logic_and(r3609, r360A), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3607->else_instructions;

                        body.emit(assign(r3606, body.constant(false), 0x01));


                     body.instructions = f3607_parent_instructions;
                     body.emit(f3607);

                     /* END IF */

                     body.emit(assign(r3603, logic_and(r3606, r35FF), 0x01));


                  body.instructions = f3604_parent_instructions;
                  body.emit(f3604);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f360B = new(mem_ctx) ir_if(operand(r3603).val);
                  exec_list *const f360B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f360B->then_instructions;

                     ir_variable *const r360C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r360C);
                     ir_expression *const r360D = lshift(r34C9, body.constant(int(31)));
                     body.emit(assign(r360C, add(r360D, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r360C, body.constant(0u), 0x01));

                     body.emit(assign(r35FE, r360C, 0x03));

                     body.emit(assign(r35FD, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f360B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r360F = less(r35BA, body.constant(int(0)));
                     ir_if *f360E = new(mem_ctx) ir_if(operand(r360F).val);
                     exec_list *const f360E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f360E->then_instructions;

                        ir_variable *const r3610 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r3610, r35BD, 0x01));

                        ir_variable *const r3611 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r3611, neg(r35BA), 0x01));

                        ir_variable *const r3612 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r3612);
                        ir_variable *const r3613 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r3613);
                        ir_variable *const r3614 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r3614);
                        ir_variable *const r3615 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r3616 = neg(r3611);
                        body.emit(assign(r3615, bit_and(r3616, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3618 = equal(r3611, body.constant(int(0)));
                        ir_if *f3617 = new(mem_ctx) ir_if(operand(r3618).val);
                        exec_list *const f3617_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3617->then_instructions;

                           body.emit(assign(r3612, r35BD, 0x01));

                           body.emit(assign(r3613, r35BC, 0x01));

                           body.emit(assign(r3614, r35BB, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3617->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r361A = less(r3611, body.constant(int(32)));
                           ir_if *f3619 = new(mem_ctx) ir_if(operand(r361A).val);
                           exec_list *const f3619_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3619->then_instructions;

                              body.emit(assign(r3612, lshift(r35BC, r3615), 0x01));

                              ir_expression *const r361B = lshift(r35BB, r3615);
                              ir_expression *const r361C = rshift(r35BC, r3611);
                              body.emit(assign(r3613, bit_or(r361B, r361C), 0x01));

                              body.emit(assign(r3614, rshift(r35BB, r3611), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3619->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r361E = equal(r3611, body.constant(int(32)));
                              ir_if *f361D = new(mem_ctx) ir_if(operand(r361E).val);
                              exec_list *const f361D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f361D->then_instructions;

                                 body.emit(assign(r3612, r35BC, 0x01));

                                 body.emit(assign(r3613, r35BB, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f361D->else_instructions;

                                 body.emit(assign(r3610, bit_or(r35BD, r35BC), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3620 = less(r3611, body.constant(int(64)));
                                 ir_if *f361F = new(mem_ctx) ir_if(operand(r3620).val);
                                 exec_list *const f361F_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f361F->then_instructions;

                                    body.emit(assign(r3612, lshift(r35BB, r3615), 0x01));

                                    ir_expression *const r3621 = bit_and(r3611, body.constant(int(31)));
                                    body.emit(assign(r3613, rshift(r35BB, r3621), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f361F->else_instructions;

                                    ir_variable *const r3622 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r3624 = equal(r3611, body.constant(int(64)));
                                    ir_if *f3623 = new(mem_ctx) ir_if(operand(r3624).val);
                                    exec_list *const f3623_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3623->then_instructions;

                                       body.emit(assign(r3622, r35BB, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3623->else_instructions;

                                       ir_expression *const r3625 = nequal(r35BB, body.constant(0u));
                                       ir_expression *const r3626 = expr(ir_unop_b2i, r3625);
                                       body.emit(assign(r3622, expr(ir_unop_i2u, r3626), 0x01));


                                    body.instructions = f3623_parent_instructions;
                                    body.emit(f3623);

                                    /* END IF */

                                    body.emit(assign(r3612, r3622, 0x01));

                                    body.emit(assign(r3613, body.constant(0u), 0x01));


                                 body.instructions = f361F_parent_instructions;
                                 body.emit(f361F);

                                 /* END IF */


                              body.instructions = f361D_parent_instructions;
                              body.emit(f361D);

                              /* END IF */

                              body.emit(assign(r3614, body.constant(0u), 0x01));


                           body.instructions = f3619_parent_instructions;
                           body.emit(f3619);

                           /* END IF */

                           ir_expression *const r3627 = nequal(r3610, body.constant(0u));
                           ir_expression *const r3628 = expr(ir_unop_b2i, r3627);
                           ir_expression *const r3629 = expr(ir_unop_i2u, r3628);
                           body.emit(assign(r3612, bit_or(r3612, r3629), 0x01));


                        body.instructions = f3617_parent_instructions;
                        body.emit(f3617);

                        /* END IF */

                        body.emit(assign(r35FA, r3614, 0x01));

                        body.emit(assign(r35FB, r3613, 0x01));

                        body.emit(assign(r35FC, r3612, 0x01));

                        body.emit(assign(r35F9, body.constant(int(0)), 0x01));

                        body.emit(assign(r35FF, less(r3612, body.constant(0u)), 0x01));


                     body.instructions = f360E_parent_instructions;
                     body.emit(f360E);

                     /* END IF */


                  body.instructions = f360B_parent_instructions;
                  body.emit(f360B);

                  /* END IF */


               body.instructions = f3601_parent_instructions;
               body.emit(f3601);

               /* END IF */

               /* IF CONDITION */
               ir_if *f362A = new(mem_ctx) ir_if(operand(r35FD).val);
               exec_list *const f362A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f362A->then_instructions;

                  /* IF CONDITION */
                  ir_if *f362B = new(mem_ctx) ir_if(operand(r35FF).val);
                  exec_list *const f362B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f362B->then_instructions;

                     ir_variable *const r362C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r362C, add(r35FB, body.constant(1u)), 0x01));

                     ir_expression *const r362D = less(r362C, r35FB);
                     ir_expression *const r362E = expr(ir_unop_b2i, r362D);
                     ir_expression *const r362F = expr(ir_unop_i2u, r362E);
                     body.emit(assign(r35FA, add(r35FA, r362F), 0x01));

                     ir_expression *const r3630 = equal(r35FC, body.constant(0u));
                     ir_expression *const r3631 = expr(ir_unop_b2i, r3630);
                     ir_expression *const r3632 = expr(ir_unop_i2u, r3631);
                     ir_expression *const r3633 = add(r35FC, r3632);
                     ir_expression *const r3634 = bit_and(r3633, body.constant(1u));
                     ir_expression *const r3635 = expr(ir_unop_bit_not, r3634);
                     body.emit(assign(r35FB, bit_and(r362C, r3635), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f362B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3637 = bit_or(r35FA, r35FB);
                     ir_expression *const r3638 = equal(r3637, body.constant(0u));
                     ir_if *f3636 = new(mem_ctx) ir_if(operand(r3638).val);
                     exec_list *const f3636_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3636->then_instructions;

                        body.emit(assign(r35F9, body.constant(int(0)), 0x01));


                     body.instructions = f3636_parent_instructions;
                     body.emit(f3636);

                     /* END IF */


                  body.instructions = f362B_parent_instructions;
                  body.emit(f362B);

                  /* END IF */

                  ir_variable *const r3639 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3639);
                  ir_expression *const r363A = lshift(r34C9, body.constant(int(31)));
                  ir_expression *const r363B = expr(ir_unop_i2u, r35F9);
                  ir_expression *const r363C = lshift(r363B, body.constant(int(20)));
                  ir_expression *const r363D = add(r363A, r363C);
                  body.emit(assign(r3639, add(r363D, r35FA), 0x02));

                  body.emit(assign(r3639, r35FB, 0x01));

                  body.emit(assign(r35FE, r3639, 0x03));

                  body.emit(assign(r35FD, body.constant(false), 0x01));


               body.instructions = f362A_parent_instructions;
               body.emit(f362A);

               /* END IF */

               body.emit(assign(r34CA, r35FE, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f358F->else_instructions;

               /* IF CONDITION */
               ir_expression *const r363F = equal(r34D4, body.constant(int(2047)));
               ir_if *f363E = new(mem_ctx) ir_if(operand(r363F).val);
               exec_list *const f363E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f363E->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3641 = bit_or(r34D0, r34D1);
                  ir_expression *const r3642 = bit_or(r34CE, r34CF);
                  ir_expression *const r3643 = bit_or(r3641, r3642);
                  ir_expression *const r3644 = nequal(r3643, body.constant(0u));
                  ir_if *f3640 = new(mem_ctx) ir_if(operand(r3644).val);
                  exec_list *const f3640_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3640->then_instructions;

                     ir_variable *const r3645 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r3645, swizzle_x(r3490), 0x01));

                     ir_variable *const r3646 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r3646, body.constant(0u), 0x01));

                     ir_variable *const r3647 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r3645, bit_or(swizzle_y(r3490), body.constant(524288u)), 0x02));

                     body.emit(assign(r3646, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r3649 = lshift(swizzle_y(r3490), body.constant(int(1)));
                     ir_expression *const r364A = lequal(body.constant(4292870144u), r3649);
                     ir_expression *const r364B = nequal(swizzle_x(r3490), body.constant(0u));
                     ir_expression *const r364C = bit_and(swizzle_y(r3490), body.constant(1048575u));
                     ir_expression *const r364D = nequal(r364C, body.constant(0u));
                     ir_expression *const r364E = logic_or(r364B, r364D);
                     ir_expression *const r364F = logic_and(r364A, r364E);
                     ir_if *f3648 = new(mem_ctx) ir_if(operand(r364F).val);
                     exec_list *const f3648_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3648->then_instructions;

                        body.emit(assign(r3647, r3645, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3648->else_instructions;

                        body.emit(assign(r3647, r3646, 0x03));


                     body.instructions = f3648_parent_instructions;
                     body.emit(f3648);

                     /* END IF */

                     body.emit(assign(r34CA, r3647, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3640->else_instructions;

                     ir_constant_data r3650_data;
                     memset(&r3650_data, 0, sizeof(ir_constant_data));
                     r3650_data.u[0] = 4294967295;
                     r3650_data.u[1] = 4294967295;
                     ir_constant *const r3650 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r3650_data);
                     body.emit(assign(r34CA, r3650, 0x03));


                  body.instructions = f3640_parent_instructions;
                  body.emit(f3640);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f363E->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3652 = equal(r34D4, body.constant(int(0)));
                  ir_if *f3651 = new(mem_ctx) ir_if(operand(r3652).val);
                  exec_list *const f3651_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3651->then_instructions;

                     body.emit(assign(r34CD, body.constant(int(1)), 0x01));

                     body.emit(assign(r34CC, body.constant(int(1)), 0x01));


                  body.instructions = f3651_parent_instructions;
                  body.emit(f3651);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r3654 = less(r34CE, r34D0);
                  ir_if *f3653 = new(mem_ctx) ir_if(operand(r3654).val);
                  exec_list *const f3653_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3653->then_instructions;

                     ir_variable *const r3655 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r3656 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r3656, sub(r34D1, r34CF), 0x01));

                     ir_expression *const r3657 = sub(r34D0, r34CE);
                     ir_expression *const r3658 = less(r34D1, r34CF);
                     ir_expression *const r3659 = expr(ir_unop_b2i, r3658);
                     ir_expression *const r365A = expr(ir_unop_i2u, r3659);
                     body.emit(assign(r3655, sub(r3657, r365A), 0x01));

                     body.emit(assign(r34D2, add(r34CD, body.constant(int(-1))), 0x01));

                     ir_variable *const r365B = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r365B, add(r34D2, body.constant(int(-10))), 0x01));

                     ir_variable *const r365C = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r365C, r3655, 0x01));

                     ir_variable *const r365D = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r365D, r3656, 0x01));

                     ir_variable *const r365E = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r365E);
                     ir_variable *const r365F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r365F);
                     /* IF CONDITION */
                     ir_expression *const r3661 = equal(r3655, body.constant(0u));
                     ir_if *f3660 = new(mem_ctx) ir_if(operand(r3661).val);
                     exec_list *const f3660_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3660->then_instructions;

                        body.emit(assign(r365C, r3656, 0x01));

                        body.emit(assign(r365D, body.constant(0u), 0x01));

                        body.emit(assign(r365B, add(r365B, body.constant(int(-32))), 0x01));


                     body.instructions = f3660_parent_instructions;
                     body.emit(f3660);

                     /* END IF */

                     ir_variable *const r3662 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r3662, r365C, 0x01));

                     ir_variable *const r3663 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r3664 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r3664);
                     /* IF CONDITION */
                     ir_expression *const r3666 = equal(r365C, body.constant(0u));
                     ir_if *f3665 = new(mem_ctx) ir_if(operand(r3666).val);
                     exec_list *const f3665_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3665->then_instructions;

                        body.emit(assign(r3663, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3665->else_instructions;

                        body.emit(assign(r3664, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3668 = bit_and(r365C, body.constant(4294901760u));
                        ir_expression *const r3669 = equal(r3668, body.constant(0u));
                        ir_if *f3667 = new(mem_ctx) ir_if(operand(r3669).val);
                        exec_list *const f3667_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3667->then_instructions;

                           body.emit(assign(r3664, body.constant(int(16)), 0x01));

                           body.emit(assign(r3662, lshift(r365C, body.constant(int(16))), 0x01));


                        body.instructions = f3667_parent_instructions;
                        body.emit(f3667);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r366B = bit_and(r3662, body.constant(4278190080u));
                        ir_expression *const r366C = equal(r366B, body.constant(0u));
                        ir_if *f366A = new(mem_ctx) ir_if(operand(r366C).val);
                        exec_list *const f366A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f366A->then_instructions;

                           body.emit(assign(r3664, add(r3664, body.constant(int(8))), 0x01));

                           body.emit(assign(r3662, lshift(r3662, body.constant(int(8))), 0x01));


                        body.instructions = f366A_parent_instructions;
                        body.emit(f366A);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r366E = bit_and(r3662, body.constant(4026531840u));
                        ir_expression *const r366F = equal(r366E, body.constant(0u));
                        ir_if *f366D = new(mem_ctx) ir_if(operand(r366F).val);
                        exec_list *const f366D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f366D->then_instructions;

                           body.emit(assign(r3664, add(r3664, body.constant(int(4))), 0x01));

                           body.emit(assign(r3662, lshift(r3662, body.constant(int(4))), 0x01));


                        body.instructions = f366D_parent_instructions;
                        body.emit(f366D);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3671 = bit_and(r3662, body.constant(3221225472u));
                        ir_expression *const r3672 = equal(r3671, body.constant(0u));
                        ir_if *f3670 = new(mem_ctx) ir_if(operand(r3672).val);
                        exec_list *const f3670_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3670->then_instructions;

                           body.emit(assign(r3664, add(r3664, body.constant(int(2))), 0x01));

                           body.emit(assign(r3662, lshift(r3662, body.constant(int(2))), 0x01));


                        body.instructions = f3670_parent_instructions;
                        body.emit(f3670);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3674 = bit_and(r3662, body.constant(2147483648u));
                        ir_expression *const r3675 = equal(r3674, body.constant(0u));
                        ir_if *f3673 = new(mem_ctx) ir_if(operand(r3675).val);
                        exec_list *const f3673_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3673->then_instructions;

                           body.emit(assign(r3664, add(r3664, body.constant(int(1))), 0x01));


                        body.instructions = f3673_parent_instructions;
                        body.emit(f3673);

                        /* END IF */

                        body.emit(assign(r3663, r3664, 0x01));


                     body.instructions = f3665_parent_instructions;
                     body.emit(f3665);

                     /* END IF */

                     body.emit(assign(r365F, add(r3663, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3677 = lequal(body.constant(int(0)), r365F);
                     ir_if *f3676 = new(mem_ctx) ir_if(operand(r3677).val);
                     exec_list *const f3676_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3676->then_instructions;

                        body.emit(assign(r365E, body.constant(0u), 0x01));

                        ir_variable *const r3678 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r3678, lshift(r365D, r365F), 0x01));

                        ir_variable *const r3679 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r367B = equal(r365F, body.constant(int(0)));
                        ir_if *f367A = new(mem_ctx) ir_if(operand(r367B).val);
                        exec_list *const f367A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f367A->then_instructions;

                           body.emit(assign(r3679, r365C, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f367A->else_instructions;

                           ir_expression *const r367C = lshift(r365C, r365F);
                           ir_expression *const r367D = neg(r365F);
                           ir_expression *const r367E = bit_and(r367D, body.constant(int(31)));
                           ir_expression *const r367F = rshift(r365D, r367E);
                           body.emit(assign(r3679, bit_or(r367C, r367F), 0x01));


                        body.instructions = f367A_parent_instructions;
                        body.emit(f367A);

                        /* END IF */

                        body.emit(assign(r365C, r3679, 0x01));

                        body.emit(assign(r365D, r3678, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3676->else_instructions;

                        ir_variable *const r3680 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r3680, body.constant(0u), 0x01));

                        ir_variable *const r3681 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r3681, neg(r365F), 0x01));

                        ir_variable *const r3682 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r3682);
                        ir_variable *const r3683 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r3683);
                        ir_variable *const r3684 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r3684);
                        ir_variable *const r3685 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r3686 = neg(r3681);
                        body.emit(assign(r3685, bit_and(r3686, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3688 = equal(r3681, body.constant(int(0)));
                        ir_if *f3687 = new(mem_ctx) ir_if(operand(r3688).val);
                        exec_list *const f3687_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3687->then_instructions;

                           body.emit(assign(r3682, r3680, 0x01));

                           body.emit(assign(r3683, r365D, 0x01));

                           body.emit(assign(r3684, r365C, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3687->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r368A = less(r3681, body.constant(int(32)));
                           ir_if *f3689 = new(mem_ctx) ir_if(operand(r368A).val);
                           exec_list *const f3689_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3689->then_instructions;

                              body.emit(assign(r3682, lshift(r365D, r3685), 0x01));

                              ir_expression *const r368B = lshift(r365C, r3685);
                              ir_expression *const r368C = rshift(r365D, r3681);
                              body.emit(assign(r3683, bit_or(r368B, r368C), 0x01));

                              body.emit(assign(r3684, rshift(r365C, r3681), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3689->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r368E = equal(r3681, body.constant(int(32)));
                              ir_if *f368D = new(mem_ctx) ir_if(operand(r368E).val);
                              exec_list *const f368D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f368D->then_instructions;

                                 body.emit(assign(r3682, r365D, 0x01));

                                 body.emit(assign(r3683, r365C, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f368D->else_instructions;

                                 body.emit(assign(r3680, bit_or(body.constant(0u), r365D), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3690 = less(r3681, body.constant(int(64)));
                                 ir_if *f368F = new(mem_ctx) ir_if(operand(r3690).val);
                                 exec_list *const f368F_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f368F->then_instructions;

                                    body.emit(assign(r3682, lshift(r365C, r3685), 0x01));

                                    ir_expression *const r3691 = bit_and(r3681, body.constant(int(31)));
                                    body.emit(assign(r3683, rshift(r365C, r3691), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f368F->else_instructions;

                                    ir_variable *const r3692 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r3694 = equal(r3681, body.constant(int(64)));
                                    ir_if *f3693 = new(mem_ctx) ir_if(operand(r3694).val);
                                    exec_list *const f3693_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3693->then_instructions;

                                       body.emit(assign(r3692, r365C, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3693->else_instructions;

                                       ir_expression *const r3695 = nequal(r365C, body.constant(0u));
                                       ir_expression *const r3696 = expr(ir_unop_b2i, r3695);
                                       body.emit(assign(r3692, expr(ir_unop_i2u, r3696), 0x01));


                                    body.instructions = f3693_parent_instructions;
                                    body.emit(f3693);

                                    /* END IF */

                                    body.emit(assign(r3682, r3692, 0x01));

                                    body.emit(assign(r3683, body.constant(0u), 0x01));


                                 body.instructions = f368F_parent_instructions;
                                 body.emit(f368F);

                                 /* END IF */


                              body.instructions = f368D_parent_instructions;
                              body.emit(f368D);

                              /* END IF */

                              body.emit(assign(r3684, body.constant(0u), 0x01));


                           body.instructions = f3689_parent_instructions;
                           body.emit(f3689);

                           /* END IF */

                           ir_expression *const r3697 = nequal(r3680, body.constant(0u));
                           ir_expression *const r3698 = expr(ir_unop_b2i, r3697);
                           ir_expression *const r3699 = expr(ir_unop_i2u, r3698);
                           body.emit(assign(r3682, bit_or(r3682, r3699), 0x01));


                        body.instructions = f3687_parent_instructions;
                        body.emit(f3687);

                        /* END IF */

                        body.emit(assign(r365C, r3684, 0x01));

                        body.emit(assign(r365D, r3683, 0x01));

                        body.emit(assign(r365E, r3682, 0x01));


                     body.instructions = f3676_parent_instructions;
                     body.emit(f3676);

                     /* END IF */

                     body.emit(assign(r365B, sub(r365B, r365F), 0x01));

                     ir_variable *const r369A = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r369A, r365B, 0x01));

                     ir_variable *const r369B = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r369B, r365C, 0x01));

                     ir_variable *const r369C = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r369C, r365D, 0x01));

                     ir_variable *const r369D = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r369D, r365E, 0x01));

                     ir_variable *const r369E = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r369E, body.constant(true), 0x01));

                     ir_variable *const r369F = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r36A0 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r36A0);
                     ir_expression *const r36A1 = expr(ir_unop_u2i, r365E);
                     body.emit(assign(r36A0, less(r36A1, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r36A3 = lequal(body.constant(int(2045)), r365B);
                     ir_if *f36A2 = new(mem_ctx) ir_if(operand(r36A3).val);
                     exec_list *const f36A2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f36A2->then_instructions;

                        ir_variable *const r36A4 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r36A6 = less(body.constant(int(2045)), r365B);
                        ir_if *f36A5 = new(mem_ctx) ir_if(operand(r36A6).val);
                        exec_list *const f36A5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f36A5->then_instructions;

                           body.emit(assign(r36A4, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f36A5->else_instructions;

                           ir_variable *const r36A7 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r36A9 = equal(r365B, body.constant(int(2045)));
                           ir_if *f36A8 = new(mem_ctx) ir_if(operand(r36A9).val);
                           exec_list *const f36A8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f36A8->then_instructions;

                              ir_expression *const r36AA = equal(body.constant(2097151u), r365C);
                              ir_expression *const r36AB = equal(body.constant(4294967295u), r365D);
                              body.emit(assign(r36A7, logic_and(r36AA, r36AB), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f36A8->else_instructions;

                              body.emit(assign(r36A7, body.constant(false), 0x01));


                           body.instructions = f36A8_parent_instructions;
                           body.emit(f36A8);

                           /* END IF */

                           body.emit(assign(r36A4, logic_and(r36A7, r36A0), 0x01));


                        body.instructions = f36A5_parent_instructions;
                        body.emit(f36A5);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f36AC = new(mem_ctx) ir_if(operand(r36A4).val);
                        exec_list *const f36AC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f36AC->then_instructions;

                           ir_variable *const r36AD = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r36AD);
                           ir_expression *const r36AE = lshift(r34C9, body.constant(int(31)));
                           body.emit(assign(r36AD, add(r36AE, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r36AD, body.constant(0u), 0x01));

                           body.emit(assign(r369F, r36AD, 0x03));

                           body.emit(assign(r369E, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f36AC->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r36B0 = less(r365B, body.constant(int(0)));
                           ir_if *f36AF = new(mem_ctx) ir_if(operand(r36B0).val);
                           exec_list *const f36AF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f36AF->then_instructions;

                              ir_variable *const r36B1 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r36B1, r365E, 0x01));

                              ir_variable *const r36B2 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r36B2, neg(r365B), 0x01));

                              ir_variable *const r36B3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r36B3);
                              ir_variable *const r36B4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r36B4);
                              ir_variable *const r36B5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r36B5);
                              ir_variable *const r36B6 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r36B7 = neg(r36B2);
                              body.emit(assign(r36B6, bit_and(r36B7, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r36B9 = equal(r36B2, body.constant(int(0)));
                              ir_if *f36B8 = new(mem_ctx) ir_if(operand(r36B9).val);
                              exec_list *const f36B8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f36B8->then_instructions;

                                 body.emit(assign(r36B3, r365E, 0x01));

                                 body.emit(assign(r36B4, r365D, 0x01));

                                 body.emit(assign(r36B5, r365C, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f36B8->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r36BB = less(r36B2, body.constant(int(32)));
                                 ir_if *f36BA = new(mem_ctx) ir_if(operand(r36BB).val);
                                 exec_list *const f36BA_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f36BA->then_instructions;

                                    body.emit(assign(r36B3, lshift(r365D, r36B6), 0x01));

                                    ir_expression *const r36BC = lshift(r365C, r36B6);
                                    ir_expression *const r36BD = rshift(r365D, r36B2);
                                    body.emit(assign(r36B4, bit_or(r36BC, r36BD), 0x01));

                                    body.emit(assign(r36B5, rshift(r365C, r36B2), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f36BA->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r36BF = equal(r36B2, body.constant(int(32)));
                                    ir_if *f36BE = new(mem_ctx) ir_if(operand(r36BF).val);
                                    exec_list *const f36BE_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f36BE->then_instructions;

                                       body.emit(assign(r36B3, r365D, 0x01));

                                       body.emit(assign(r36B4, r365C, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f36BE->else_instructions;

                                       body.emit(assign(r36B1, bit_or(r365E, r365D), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r36C1 = less(r36B2, body.constant(int(64)));
                                       ir_if *f36C0 = new(mem_ctx) ir_if(operand(r36C1).val);
                                       exec_list *const f36C0_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f36C0->then_instructions;

                                          body.emit(assign(r36B3, lshift(r365C, r36B6), 0x01));

                                          ir_expression *const r36C2 = bit_and(r36B2, body.constant(int(31)));
                                          body.emit(assign(r36B4, rshift(r365C, r36C2), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f36C0->else_instructions;

                                          ir_variable *const r36C3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r36C5 = equal(r36B2, body.constant(int(64)));
                                          ir_if *f36C4 = new(mem_ctx) ir_if(operand(r36C5).val);
                                          exec_list *const f36C4_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f36C4->then_instructions;

                                             body.emit(assign(r36C3, r365C, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f36C4->else_instructions;

                                             ir_expression *const r36C6 = nequal(r365C, body.constant(0u));
                                             ir_expression *const r36C7 = expr(ir_unop_b2i, r36C6);
                                             body.emit(assign(r36C3, expr(ir_unop_i2u, r36C7), 0x01));


                                          body.instructions = f36C4_parent_instructions;
                                          body.emit(f36C4);

                                          /* END IF */

                                          body.emit(assign(r36B3, r36C3, 0x01));

                                          body.emit(assign(r36B4, body.constant(0u), 0x01));


                                       body.instructions = f36C0_parent_instructions;
                                       body.emit(f36C0);

                                       /* END IF */


                                    body.instructions = f36BE_parent_instructions;
                                    body.emit(f36BE);

                                    /* END IF */

                                    body.emit(assign(r36B5, body.constant(0u), 0x01));


                                 body.instructions = f36BA_parent_instructions;
                                 body.emit(f36BA);

                                 /* END IF */

                                 ir_expression *const r36C8 = nequal(r36B1, body.constant(0u));
                                 ir_expression *const r36C9 = expr(ir_unop_b2i, r36C8);
                                 ir_expression *const r36CA = expr(ir_unop_i2u, r36C9);
                                 body.emit(assign(r36B3, bit_or(r36B3, r36CA), 0x01));


                              body.instructions = f36B8_parent_instructions;
                              body.emit(f36B8);

                              /* END IF */

                              body.emit(assign(r369B, r36B5, 0x01));

                              body.emit(assign(r369C, r36B4, 0x01));

                              body.emit(assign(r369D, r36B3, 0x01));

                              body.emit(assign(r369A, body.constant(int(0)), 0x01));

                              body.emit(assign(r36A0, less(r36B3, body.constant(0u)), 0x01));


                           body.instructions = f36AF_parent_instructions;
                           body.emit(f36AF);

                           /* END IF */


                        body.instructions = f36AC_parent_instructions;
                        body.emit(f36AC);

                        /* END IF */


                     body.instructions = f36A2_parent_instructions;
                     body.emit(f36A2);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f36CB = new(mem_ctx) ir_if(operand(r369E).val);
                     exec_list *const f36CB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f36CB->then_instructions;

                        /* IF CONDITION */
                        ir_if *f36CC = new(mem_ctx) ir_if(operand(r36A0).val);
                        exec_list *const f36CC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f36CC->then_instructions;

                           ir_variable *const r36CD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r36CD, add(r369C, body.constant(1u)), 0x01));

                           ir_expression *const r36CE = less(r36CD, r369C);
                           ir_expression *const r36CF = expr(ir_unop_b2i, r36CE);
                           ir_expression *const r36D0 = expr(ir_unop_i2u, r36CF);
                           body.emit(assign(r369B, add(r369B, r36D0), 0x01));

                           ir_expression *const r36D1 = equal(r369D, body.constant(0u));
                           ir_expression *const r36D2 = expr(ir_unop_b2i, r36D1);
                           ir_expression *const r36D3 = expr(ir_unop_i2u, r36D2);
                           ir_expression *const r36D4 = add(r369D, r36D3);
                           ir_expression *const r36D5 = bit_and(r36D4, body.constant(1u));
                           ir_expression *const r36D6 = expr(ir_unop_bit_not, r36D5);
                           body.emit(assign(r369C, bit_and(r36CD, r36D6), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f36CC->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r36D8 = bit_or(r369B, r369C);
                           ir_expression *const r36D9 = equal(r36D8, body.constant(0u));
                           ir_if *f36D7 = new(mem_ctx) ir_if(operand(r36D9).val);
                           exec_list *const f36D7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f36D7->then_instructions;

                              body.emit(assign(r369A, body.constant(int(0)), 0x01));


                           body.instructions = f36D7_parent_instructions;
                           body.emit(f36D7);

                           /* END IF */


                        body.instructions = f36CC_parent_instructions;
                        body.emit(f36CC);

                        /* END IF */

                        ir_variable *const r36DA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r36DA);
                        ir_expression *const r36DB = lshift(r34C9, body.constant(int(31)));
                        ir_expression *const r36DC = expr(ir_unop_i2u, r369A);
                        ir_expression *const r36DD = lshift(r36DC, body.constant(int(20)));
                        ir_expression *const r36DE = add(r36DB, r36DD);
                        body.emit(assign(r36DA, add(r36DE, r369B), 0x02));

                        body.emit(assign(r36DA, r369C, 0x01));

                        body.emit(assign(r369F, r36DA, 0x03));

                        body.emit(assign(r369E, body.constant(false), 0x01));


                     body.instructions = f36CB_parent_instructions;
                     body.emit(f36CB);

                     /* END IF */

                     body.emit(assign(r34CA, r369F, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3653->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r36E0 = less(r34D0, r34CE);
                     ir_if *f36DF = new(mem_ctx) ir_if(operand(r36E0).val);
                     exec_list *const f36DF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f36DF->then_instructions;

                        ir_variable *const r36E1 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r36E2 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r36E2, sub(r34CF, r34D1), 0x01));

                        ir_expression *const r36E3 = sub(r34CE, r34D0);
                        ir_expression *const r36E4 = less(r34CF, r34D1);
                        ir_expression *const r36E5 = expr(ir_unop_b2i, r36E4);
                        ir_expression *const r36E6 = expr(ir_unop_i2u, r36E5);
                        body.emit(assign(r36E1, sub(r36E3, r36E6), 0x01));

                        body.emit(assign(r34C9, bit_xor(r34C9, body.constant(1u)), 0x01));

                        body.emit(assign(r34D2, add(r34CC, body.constant(int(-1))), 0x01));

                        ir_variable *const r36E7 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r36E7, add(r34D2, body.constant(int(-10))), 0x01));

                        ir_variable *const r36E8 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r36E8, r36E1, 0x01));

                        ir_variable *const r36E9 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r36E9, r36E2, 0x01));

                        ir_variable *const r36EA = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r36EA);
                        ir_variable *const r36EB = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r36EB);
                        /* IF CONDITION */
                        ir_expression *const r36ED = equal(r36E1, body.constant(0u));
                        ir_if *f36EC = new(mem_ctx) ir_if(operand(r36ED).val);
                        exec_list *const f36EC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f36EC->then_instructions;

                           body.emit(assign(r36E8, r36E2, 0x01));

                           body.emit(assign(r36E9, body.constant(0u), 0x01));

                           body.emit(assign(r36E7, add(r36E7, body.constant(int(-32))), 0x01));


                        body.instructions = f36EC_parent_instructions;
                        body.emit(f36EC);

                        /* END IF */

                        ir_variable *const r36EE = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r36EE, r36E8, 0x01));

                        ir_variable *const r36EF = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r36F0 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r36F0);
                        /* IF CONDITION */
                        ir_expression *const r36F2 = equal(r36E8, body.constant(0u));
                        ir_if *f36F1 = new(mem_ctx) ir_if(operand(r36F2).val);
                        exec_list *const f36F1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f36F1->then_instructions;

                           body.emit(assign(r36EF, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f36F1->else_instructions;

                           body.emit(assign(r36F0, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r36F4 = bit_and(r36E8, body.constant(4294901760u));
                           ir_expression *const r36F5 = equal(r36F4, body.constant(0u));
                           ir_if *f36F3 = new(mem_ctx) ir_if(operand(r36F5).val);
                           exec_list *const f36F3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f36F3->then_instructions;

                              body.emit(assign(r36F0, body.constant(int(16)), 0x01));

                              body.emit(assign(r36EE, lshift(r36E8, body.constant(int(16))), 0x01));


                           body.instructions = f36F3_parent_instructions;
                           body.emit(f36F3);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r36F7 = bit_and(r36EE, body.constant(4278190080u));
                           ir_expression *const r36F8 = equal(r36F7, body.constant(0u));
                           ir_if *f36F6 = new(mem_ctx) ir_if(operand(r36F8).val);
                           exec_list *const f36F6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f36F6->then_instructions;

                              body.emit(assign(r36F0, add(r36F0, body.constant(int(8))), 0x01));

                              body.emit(assign(r36EE, lshift(r36EE, body.constant(int(8))), 0x01));


                           body.instructions = f36F6_parent_instructions;
                           body.emit(f36F6);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r36FA = bit_and(r36EE, body.constant(4026531840u));
                           ir_expression *const r36FB = equal(r36FA, body.constant(0u));
                           ir_if *f36F9 = new(mem_ctx) ir_if(operand(r36FB).val);
                           exec_list *const f36F9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f36F9->then_instructions;

                              body.emit(assign(r36F0, add(r36F0, body.constant(int(4))), 0x01));

                              body.emit(assign(r36EE, lshift(r36EE, body.constant(int(4))), 0x01));


                           body.instructions = f36F9_parent_instructions;
                           body.emit(f36F9);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r36FD = bit_and(r36EE, body.constant(3221225472u));
                           ir_expression *const r36FE = equal(r36FD, body.constant(0u));
                           ir_if *f36FC = new(mem_ctx) ir_if(operand(r36FE).val);
                           exec_list *const f36FC_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f36FC->then_instructions;

                              body.emit(assign(r36F0, add(r36F0, body.constant(int(2))), 0x01));

                              body.emit(assign(r36EE, lshift(r36EE, body.constant(int(2))), 0x01));


                           body.instructions = f36FC_parent_instructions;
                           body.emit(f36FC);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r3700 = bit_and(r36EE, body.constant(2147483648u));
                           ir_expression *const r3701 = equal(r3700, body.constant(0u));
                           ir_if *f36FF = new(mem_ctx) ir_if(operand(r3701).val);
                           exec_list *const f36FF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f36FF->then_instructions;

                              body.emit(assign(r36F0, add(r36F0, body.constant(int(1))), 0x01));


                           body.instructions = f36FF_parent_instructions;
                           body.emit(f36FF);

                           /* END IF */

                           body.emit(assign(r36EF, r36F0, 0x01));


                        body.instructions = f36F1_parent_instructions;
                        body.emit(f36F1);

                        /* END IF */

                        body.emit(assign(r36EB, add(r36EF, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3703 = lequal(body.constant(int(0)), r36EB);
                        ir_if *f3702 = new(mem_ctx) ir_if(operand(r3703).val);
                        exec_list *const f3702_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3702->then_instructions;

                           body.emit(assign(r36EA, body.constant(0u), 0x01));

                           ir_variable *const r3704 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r3704, lshift(r36E9, r36EB), 0x01));

                           ir_variable *const r3705 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r3707 = equal(r36EB, body.constant(int(0)));
                           ir_if *f3706 = new(mem_ctx) ir_if(operand(r3707).val);
                           exec_list *const f3706_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3706->then_instructions;

                              body.emit(assign(r3705, r36E8, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3706->else_instructions;

                              ir_expression *const r3708 = lshift(r36E8, r36EB);
                              ir_expression *const r3709 = neg(r36EB);
                              ir_expression *const r370A = bit_and(r3709, body.constant(int(31)));
                              ir_expression *const r370B = rshift(r36E9, r370A);
                              body.emit(assign(r3705, bit_or(r3708, r370B), 0x01));


                           body.instructions = f3706_parent_instructions;
                           body.emit(f3706);

                           /* END IF */

                           body.emit(assign(r36E8, r3705, 0x01));

                           body.emit(assign(r36E9, r3704, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3702->else_instructions;

                           ir_variable *const r370C = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r370C, body.constant(0u), 0x01));

                           ir_variable *const r370D = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r370D, neg(r36EB), 0x01));

                           ir_variable *const r370E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r370E);
                           ir_variable *const r370F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r370F);
                           ir_variable *const r3710 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r3710);
                           ir_variable *const r3711 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r3712 = neg(r370D);
                           body.emit(assign(r3711, bit_and(r3712, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3714 = equal(r370D, body.constant(int(0)));
                           ir_if *f3713 = new(mem_ctx) ir_if(operand(r3714).val);
                           exec_list *const f3713_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3713->then_instructions;

                              body.emit(assign(r370E, r370C, 0x01));

                              body.emit(assign(r370F, r36E9, 0x01));

                              body.emit(assign(r3710, r36E8, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3713->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3716 = less(r370D, body.constant(int(32)));
                              ir_if *f3715 = new(mem_ctx) ir_if(operand(r3716).val);
                              exec_list *const f3715_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3715->then_instructions;

                                 body.emit(assign(r370E, lshift(r36E9, r3711), 0x01));

                                 ir_expression *const r3717 = lshift(r36E8, r3711);
                                 ir_expression *const r3718 = rshift(r36E9, r370D);
                                 body.emit(assign(r370F, bit_or(r3717, r3718), 0x01));

                                 body.emit(assign(r3710, rshift(r36E8, r370D), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3715->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r371A = equal(r370D, body.constant(int(32)));
                                 ir_if *f3719 = new(mem_ctx) ir_if(operand(r371A).val);
                                 exec_list *const f3719_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3719->then_instructions;

                                    body.emit(assign(r370E, r36E9, 0x01));

                                    body.emit(assign(r370F, r36E8, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3719->else_instructions;

                                    body.emit(assign(r370C, bit_or(body.constant(0u), r36E9), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r371C = less(r370D, body.constant(int(64)));
                                    ir_if *f371B = new(mem_ctx) ir_if(operand(r371C).val);
                                    exec_list *const f371B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f371B->then_instructions;

                                       body.emit(assign(r370E, lshift(r36E8, r3711), 0x01));

                                       ir_expression *const r371D = bit_and(r370D, body.constant(int(31)));
                                       body.emit(assign(r370F, rshift(r36E8, r371D), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f371B->else_instructions;

                                       ir_variable *const r371E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r3720 = equal(r370D, body.constant(int(64)));
                                       ir_if *f371F = new(mem_ctx) ir_if(operand(r3720).val);
                                       exec_list *const f371F_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f371F->then_instructions;

                                          body.emit(assign(r371E, r36E8, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f371F->else_instructions;

                                          ir_expression *const r3721 = nequal(r36E8, body.constant(0u));
                                          ir_expression *const r3722 = expr(ir_unop_b2i, r3721);
                                          body.emit(assign(r371E, expr(ir_unop_i2u, r3722), 0x01));


                                       body.instructions = f371F_parent_instructions;
                                       body.emit(f371F);

                                       /* END IF */

                                       body.emit(assign(r370E, r371E, 0x01));

                                       body.emit(assign(r370F, body.constant(0u), 0x01));


                                    body.instructions = f371B_parent_instructions;
                                    body.emit(f371B);

                                    /* END IF */


                                 body.instructions = f3719_parent_instructions;
                                 body.emit(f3719);

                                 /* END IF */

                                 body.emit(assign(r3710, body.constant(0u), 0x01));


                              body.instructions = f3715_parent_instructions;
                              body.emit(f3715);

                              /* END IF */

                              ir_expression *const r3723 = nequal(r370C, body.constant(0u));
                              ir_expression *const r3724 = expr(ir_unop_b2i, r3723);
                              ir_expression *const r3725 = expr(ir_unop_i2u, r3724);
                              body.emit(assign(r370E, bit_or(r370E, r3725), 0x01));


                           body.instructions = f3713_parent_instructions;
                           body.emit(f3713);

                           /* END IF */

                           body.emit(assign(r36E8, r3710, 0x01));

                           body.emit(assign(r36E9, r370F, 0x01));

                           body.emit(assign(r36EA, r370E, 0x01));


                        body.instructions = f3702_parent_instructions;
                        body.emit(f3702);

                        /* END IF */

                        body.emit(assign(r36E7, sub(r36E7, r36EB), 0x01));

                        ir_variable *const r3726 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r3726, r36E7, 0x01));

                        ir_variable *const r3727 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r3727, r36E8, 0x01));

                        ir_variable *const r3728 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r3728, r36E9, 0x01));

                        ir_variable *const r3729 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r3729, r36EA, 0x01));

                        ir_variable *const r372A = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r372A, body.constant(true), 0x01));

                        ir_variable *const r372B = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r372C = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r372C);
                        ir_expression *const r372D = expr(ir_unop_u2i, r36EA);
                        body.emit(assign(r372C, less(r372D, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r372F = lequal(body.constant(int(2045)), r36E7);
                        ir_if *f372E = new(mem_ctx) ir_if(operand(r372F).val);
                        exec_list *const f372E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f372E->then_instructions;

                           ir_variable *const r3730 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r3732 = less(body.constant(int(2045)), r36E7);
                           ir_if *f3731 = new(mem_ctx) ir_if(operand(r3732).val);
                           exec_list *const f3731_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3731->then_instructions;

                              body.emit(assign(r3730, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3731->else_instructions;

                              ir_variable *const r3733 = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r3735 = equal(r36E7, body.constant(int(2045)));
                              ir_if *f3734 = new(mem_ctx) ir_if(operand(r3735).val);
                              exec_list *const f3734_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3734->then_instructions;

                                 ir_expression *const r3736 = equal(body.constant(2097151u), r36E8);
                                 ir_expression *const r3737 = equal(body.constant(4294967295u), r36E9);
                                 body.emit(assign(r3733, logic_and(r3736, r3737), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3734->else_instructions;

                                 body.emit(assign(r3733, body.constant(false), 0x01));


                              body.instructions = f3734_parent_instructions;
                              body.emit(f3734);

                              /* END IF */

                              body.emit(assign(r3730, logic_and(r3733, r372C), 0x01));


                           body.instructions = f3731_parent_instructions;
                           body.emit(f3731);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f3738 = new(mem_ctx) ir_if(operand(r3730).val);
                           exec_list *const f3738_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3738->then_instructions;

                              ir_variable *const r3739 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r3739);
                              ir_expression *const r373A = lshift(r34C9, body.constant(int(31)));
                              body.emit(assign(r3739, add(r373A, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r3739, body.constant(0u), 0x01));

                              body.emit(assign(r372B, r3739, 0x03));

                              body.emit(assign(r372A, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3738->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r373C = less(r36E7, body.constant(int(0)));
                              ir_if *f373B = new(mem_ctx) ir_if(operand(r373C).val);
                              exec_list *const f373B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f373B->then_instructions;

                                 ir_variable *const r373D = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r373D, r36EA, 0x01));

                                 ir_variable *const r373E = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r373E, neg(r36E7), 0x01));

                                 ir_variable *const r373F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r373F);
                                 ir_variable *const r3740 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r3740);
                                 ir_variable *const r3741 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r3741);
                                 ir_variable *const r3742 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r3743 = neg(r373E);
                                 body.emit(assign(r3742, bit_and(r3743, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3745 = equal(r373E, body.constant(int(0)));
                                 ir_if *f3744 = new(mem_ctx) ir_if(operand(r3745).val);
                                 exec_list *const f3744_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3744->then_instructions;

                                    body.emit(assign(r373F, r36EA, 0x01));

                                    body.emit(assign(r3740, r36E9, 0x01));

                                    body.emit(assign(r3741, r36E8, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3744->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r3747 = less(r373E, body.constant(int(32)));
                                    ir_if *f3746 = new(mem_ctx) ir_if(operand(r3747).val);
                                    exec_list *const f3746_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3746->then_instructions;

                                       body.emit(assign(r373F, lshift(r36E9, r3742), 0x01));

                                       ir_expression *const r3748 = lshift(r36E8, r3742);
                                       ir_expression *const r3749 = rshift(r36E9, r373E);
                                       body.emit(assign(r3740, bit_or(r3748, r3749), 0x01));

                                       body.emit(assign(r3741, rshift(r36E8, r373E), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3746->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r374B = equal(r373E, body.constant(int(32)));
                                       ir_if *f374A = new(mem_ctx) ir_if(operand(r374B).val);
                                       exec_list *const f374A_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f374A->then_instructions;

                                          body.emit(assign(r373F, r36E9, 0x01));

                                          body.emit(assign(r3740, r36E8, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f374A->else_instructions;

                                          body.emit(assign(r373D, bit_or(r36EA, r36E9), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r374D = less(r373E, body.constant(int(64)));
                                          ir_if *f374C = new(mem_ctx) ir_if(operand(r374D).val);
                                          exec_list *const f374C_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f374C->then_instructions;

                                             body.emit(assign(r373F, lshift(r36E8, r3742), 0x01));

                                             ir_expression *const r374E = bit_and(r373E, body.constant(int(31)));
                                             body.emit(assign(r3740, rshift(r36E8, r374E), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f374C->else_instructions;

                                             ir_variable *const r374F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r3751 = equal(r373E, body.constant(int(64)));
                                             ir_if *f3750 = new(mem_ctx) ir_if(operand(r3751).val);
                                             exec_list *const f3750_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f3750->then_instructions;

                                                body.emit(assign(r374F, r36E8, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f3750->else_instructions;

                                                ir_expression *const r3752 = nequal(r36E8, body.constant(0u));
                                                ir_expression *const r3753 = expr(ir_unop_b2i, r3752);
                                                body.emit(assign(r374F, expr(ir_unop_i2u, r3753), 0x01));


                                             body.instructions = f3750_parent_instructions;
                                             body.emit(f3750);

                                             /* END IF */

                                             body.emit(assign(r373F, r374F, 0x01));

                                             body.emit(assign(r3740, body.constant(0u), 0x01));


                                          body.instructions = f374C_parent_instructions;
                                          body.emit(f374C);

                                          /* END IF */


                                       body.instructions = f374A_parent_instructions;
                                       body.emit(f374A);

                                       /* END IF */

                                       body.emit(assign(r3741, body.constant(0u), 0x01));


                                    body.instructions = f3746_parent_instructions;
                                    body.emit(f3746);

                                    /* END IF */

                                    ir_expression *const r3754 = nequal(r373D, body.constant(0u));
                                    ir_expression *const r3755 = expr(ir_unop_b2i, r3754);
                                    ir_expression *const r3756 = expr(ir_unop_i2u, r3755);
                                    body.emit(assign(r373F, bit_or(r373F, r3756), 0x01));


                                 body.instructions = f3744_parent_instructions;
                                 body.emit(f3744);

                                 /* END IF */

                                 body.emit(assign(r3727, r3741, 0x01));

                                 body.emit(assign(r3728, r3740, 0x01));

                                 body.emit(assign(r3729, r373F, 0x01));

                                 body.emit(assign(r3726, body.constant(int(0)), 0x01));

                                 body.emit(assign(r372C, less(r373F, body.constant(0u)), 0x01));


                              body.instructions = f373B_parent_instructions;
                              body.emit(f373B);

                              /* END IF */


                           body.instructions = f3738_parent_instructions;
                           body.emit(f3738);

                           /* END IF */


                        body.instructions = f372E_parent_instructions;
                        body.emit(f372E);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f3757 = new(mem_ctx) ir_if(operand(r372A).val);
                        exec_list *const f3757_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3757->then_instructions;

                           /* IF CONDITION */
                           ir_if *f3758 = new(mem_ctx) ir_if(operand(r372C).val);
                           exec_list *const f3758_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3758->then_instructions;

                              ir_variable *const r3759 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r3759, add(r3728, body.constant(1u)), 0x01));

                              ir_expression *const r375A = less(r3759, r3728);
                              ir_expression *const r375B = expr(ir_unop_b2i, r375A);
                              ir_expression *const r375C = expr(ir_unop_i2u, r375B);
                              body.emit(assign(r3727, add(r3727, r375C), 0x01));

                              ir_expression *const r375D = equal(r3729, body.constant(0u));
                              ir_expression *const r375E = expr(ir_unop_b2i, r375D);
                              ir_expression *const r375F = expr(ir_unop_i2u, r375E);
                              ir_expression *const r3760 = add(r3729, r375F);
                              ir_expression *const r3761 = bit_and(r3760, body.constant(1u));
                              ir_expression *const r3762 = expr(ir_unop_bit_not, r3761);
                              body.emit(assign(r3728, bit_and(r3759, r3762), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3758->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3764 = bit_or(r3727, r3728);
                              ir_expression *const r3765 = equal(r3764, body.constant(0u));
                              ir_if *f3763 = new(mem_ctx) ir_if(operand(r3765).val);
                              exec_list *const f3763_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3763->then_instructions;

                                 body.emit(assign(r3726, body.constant(int(0)), 0x01));


                              body.instructions = f3763_parent_instructions;
                              body.emit(f3763);

                              /* END IF */


                           body.instructions = f3758_parent_instructions;
                           body.emit(f3758);

                           /* END IF */

                           ir_variable *const r3766 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r3766);
                           ir_expression *const r3767 = lshift(r34C9, body.constant(int(31)));
                           ir_expression *const r3768 = expr(ir_unop_i2u, r3726);
                           ir_expression *const r3769 = lshift(r3768, body.constant(int(20)));
                           ir_expression *const r376A = add(r3767, r3769);
                           body.emit(assign(r3766, add(r376A, r3727), 0x02));

                           body.emit(assign(r3766, r3728, 0x01));

                           body.emit(assign(r372B, r3766, 0x03));

                           body.emit(assign(r372A, body.constant(false), 0x01));


                        body.instructions = f3757_parent_instructions;
                        body.emit(f3757);

                        /* END IF */

                        body.emit(assign(r34CA, r372B, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f36DF->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r376C = less(r34CF, r34D1);
                        ir_if *f376B = new(mem_ctx) ir_if(operand(r376C).val);
                        exec_list *const f376B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f376B->then_instructions;

                           ir_variable *const r376D = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r376E = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r376E, sub(r34D1, r34CF), 0x01));

                           ir_expression *const r376F = sub(r34D0, r34CE);
                           ir_expression *const r3770 = less(r34D1, r34CF);
                           ir_expression *const r3771 = expr(ir_unop_b2i, r3770);
                           ir_expression *const r3772 = expr(ir_unop_i2u, r3771);
                           body.emit(assign(r376D, sub(r376F, r3772), 0x01));

                           body.emit(assign(r34D2, add(r34CD, body.constant(int(-1))), 0x01));

                           ir_variable *const r3773 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r3773, add(r34D2, body.constant(int(-10))), 0x01));

                           ir_variable *const r3774 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r3774, r376D, 0x01));

                           ir_variable *const r3775 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r3775, r376E, 0x01));

                           ir_variable *const r3776 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r3776);
                           ir_variable *const r3777 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r3777);
                           /* IF CONDITION */
                           ir_expression *const r3779 = equal(r376D, body.constant(0u));
                           ir_if *f3778 = new(mem_ctx) ir_if(operand(r3779).val);
                           exec_list *const f3778_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3778->then_instructions;

                              body.emit(assign(r3774, r376E, 0x01));

                              body.emit(assign(r3775, body.constant(0u), 0x01));

                              body.emit(assign(r3773, add(r3773, body.constant(int(-32))), 0x01));


                           body.instructions = f3778_parent_instructions;
                           body.emit(f3778);

                           /* END IF */

                           ir_variable *const r377A = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r377A, r3774, 0x01));

                           ir_variable *const r377B = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r377C = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r377C);
                           /* IF CONDITION */
                           ir_expression *const r377E = equal(r3774, body.constant(0u));
                           ir_if *f377D = new(mem_ctx) ir_if(operand(r377E).val);
                           exec_list *const f377D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f377D->then_instructions;

                              body.emit(assign(r377B, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f377D->else_instructions;

                              body.emit(assign(r377C, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3780 = bit_and(r3774, body.constant(4294901760u));
                              ir_expression *const r3781 = equal(r3780, body.constant(0u));
                              ir_if *f377F = new(mem_ctx) ir_if(operand(r3781).val);
                              exec_list *const f377F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f377F->then_instructions;

                                 body.emit(assign(r377C, body.constant(int(16)), 0x01));

                                 body.emit(assign(r377A, lshift(r3774, body.constant(int(16))), 0x01));


                              body.instructions = f377F_parent_instructions;
                              body.emit(f377F);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r3783 = bit_and(r377A, body.constant(4278190080u));
                              ir_expression *const r3784 = equal(r3783, body.constant(0u));
                              ir_if *f3782 = new(mem_ctx) ir_if(operand(r3784).val);
                              exec_list *const f3782_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3782->then_instructions;

                                 body.emit(assign(r377C, add(r377C, body.constant(int(8))), 0x01));

                                 body.emit(assign(r377A, lshift(r377A, body.constant(int(8))), 0x01));


                              body.instructions = f3782_parent_instructions;
                              body.emit(f3782);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r3786 = bit_and(r377A, body.constant(4026531840u));
                              ir_expression *const r3787 = equal(r3786, body.constant(0u));
                              ir_if *f3785 = new(mem_ctx) ir_if(operand(r3787).val);
                              exec_list *const f3785_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3785->then_instructions;

                                 body.emit(assign(r377C, add(r377C, body.constant(int(4))), 0x01));

                                 body.emit(assign(r377A, lshift(r377A, body.constant(int(4))), 0x01));


                              body.instructions = f3785_parent_instructions;
                              body.emit(f3785);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r3789 = bit_and(r377A, body.constant(3221225472u));
                              ir_expression *const r378A = equal(r3789, body.constant(0u));
                              ir_if *f3788 = new(mem_ctx) ir_if(operand(r378A).val);
                              exec_list *const f3788_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3788->then_instructions;

                                 body.emit(assign(r377C, add(r377C, body.constant(int(2))), 0x01));

                                 body.emit(assign(r377A, lshift(r377A, body.constant(int(2))), 0x01));


                              body.instructions = f3788_parent_instructions;
                              body.emit(f3788);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r378C = bit_and(r377A, body.constant(2147483648u));
                              ir_expression *const r378D = equal(r378C, body.constant(0u));
                              ir_if *f378B = new(mem_ctx) ir_if(operand(r378D).val);
                              exec_list *const f378B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f378B->then_instructions;

                                 body.emit(assign(r377C, add(r377C, body.constant(int(1))), 0x01));


                              body.instructions = f378B_parent_instructions;
                              body.emit(f378B);

                              /* END IF */

                              body.emit(assign(r377B, r377C, 0x01));


                           body.instructions = f377D_parent_instructions;
                           body.emit(f377D);

                           /* END IF */

                           body.emit(assign(r3777, add(r377B, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r378F = lequal(body.constant(int(0)), r3777);
                           ir_if *f378E = new(mem_ctx) ir_if(operand(r378F).val);
                           exec_list *const f378E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f378E->then_instructions;

                              body.emit(assign(r3776, body.constant(0u), 0x01));

                              ir_variable *const r3790 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r3790, lshift(r3775, r3777), 0x01));

                              ir_variable *const r3791 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r3793 = equal(r3777, body.constant(int(0)));
                              ir_if *f3792 = new(mem_ctx) ir_if(operand(r3793).val);
                              exec_list *const f3792_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3792->then_instructions;

                                 body.emit(assign(r3791, r3774, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3792->else_instructions;

                                 ir_expression *const r3794 = lshift(r3774, r3777);
                                 ir_expression *const r3795 = neg(r3777);
                                 ir_expression *const r3796 = bit_and(r3795, body.constant(int(31)));
                                 ir_expression *const r3797 = rshift(r3775, r3796);
                                 body.emit(assign(r3791, bit_or(r3794, r3797), 0x01));


                              body.instructions = f3792_parent_instructions;
                              body.emit(f3792);

                              /* END IF */

                              body.emit(assign(r3774, r3791, 0x01));

                              body.emit(assign(r3775, r3790, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f378E->else_instructions;

                              ir_variable *const r3798 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r3798, body.constant(0u), 0x01));

                              ir_variable *const r3799 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r3799, neg(r3777), 0x01));

                              ir_variable *const r379A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r379A);
                              ir_variable *const r379B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r379B);
                              ir_variable *const r379C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r379C);
                              ir_variable *const r379D = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r379E = neg(r3799);
                              body.emit(assign(r379D, bit_and(r379E, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r37A0 = equal(r3799, body.constant(int(0)));
                              ir_if *f379F = new(mem_ctx) ir_if(operand(r37A0).val);
                              exec_list *const f379F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f379F->then_instructions;

                                 body.emit(assign(r379A, r3798, 0x01));

                                 body.emit(assign(r379B, r3775, 0x01));

                                 body.emit(assign(r379C, r3774, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f379F->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r37A2 = less(r3799, body.constant(int(32)));
                                 ir_if *f37A1 = new(mem_ctx) ir_if(operand(r37A2).val);
                                 exec_list *const f37A1_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f37A1->then_instructions;

                                    body.emit(assign(r379A, lshift(r3775, r379D), 0x01));

                                    ir_expression *const r37A3 = lshift(r3774, r379D);
                                    ir_expression *const r37A4 = rshift(r3775, r3799);
                                    body.emit(assign(r379B, bit_or(r37A3, r37A4), 0x01));

                                    body.emit(assign(r379C, rshift(r3774, r3799), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f37A1->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r37A6 = equal(r3799, body.constant(int(32)));
                                    ir_if *f37A5 = new(mem_ctx) ir_if(operand(r37A6).val);
                                    exec_list *const f37A5_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f37A5->then_instructions;

                                       body.emit(assign(r379A, r3775, 0x01));

                                       body.emit(assign(r379B, r3774, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f37A5->else_instructions;

                                       body.emit(assign(r3798, bit_or(body.constant(0u), r3775), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r37A8 = less(r3799, body.constant(int(64)));
                                       ir_if *f37A7 = new(mem_ctx) ir_if(operand(r37A8).val);
                                       exec_list *const f37A7_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f37A7->then_instructions;

                                          body.emit(assign(r379A, lshift(r3774, r379D), 0x01));

                                          ir_expression *const r37A9 = bit_and(r3799, body.constant(int(31)));
                                          body.emit(assign(r379B, rshift(r3774, r37A9), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f37A7->else_instructions;

                                          ir_variable *const r37AA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r37AC = equal(r3799, body.constant(int(64)));
                                          ir_if *f37AB = new(mem_ctx) ir_if(operand(r37AC).val);
                                          exec_list *const f37AB_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f37AB->then_instructions;

                                             body.emit(assign(r37AA, r3774, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f37AB->else_instructions;

                                             ir_expression *const r37AD = nequal(r3774, body.constant(0u));
                                             ir_expression *const r37AE = expr(ir_unop_b2i, r37AD);
                                             body.emit(assign(r37AA, expr(ir_unop_i2u, r37AE), 0x01));


                                          body.instructions = f37AB_parent_instructions;
                                          body.emit(f37AB);

                                          /* END IF */

                                          body.emit(assign(r379A, r37AA, 0x01));

                                          body.emit(assign(r379B, body.constant(0u), 0x01));


                                       body.instructions = f37A7_parent_instructions;
                                       body.emit(f37A7);

                                       /* END IF */


                                    body.instructions = f37A5_parent_instructions;
                                    body.emit(f37A5);

                                    /* END IF */

                                    body.emit(assign(r379C, body.constant(0u), 0x01));


                                 body.instructions = f37A1_parent_instructions;
                                 body.emit(f37A1);

                                 /* END IF */

                                 ir_expression *const r37AF = nequal(r3798, body.constant(0u));
                                 ir_expression *const r37B0 = expr(ir_unop_b2i, r37AF);
                                 ir_expression *const r37B1 = expr(ir_unop_i2u, r37B0);
                                 body.emit(assign(r379A, bit_or(r379A, r37B1), 0x01));


                              body.instructions = f379F_parent_instructions;
                              body.emit(f379F);

                              /* END IF */

                              body.emit(assign(r3774, r379C, 0x01));

                              body.emit(assign(r3775, r379B, 0x01));

                              body.emit(assign(r3776, r379A, 0x01));


                           body.instructions = f378E_parent_instructions;
                           body.emit(f378E);

                           /* END IF */

                           body.emit(assign(r3773, sub(r3773, r3777), 0x01));

                           ir_variable *const r37B2 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r37B2, r3773, 0x01));

                           ir_variable *const r37B3 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r37B3, r3774, 0x01));

                           ir_variable *const r37B4 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r37B4, r3775, 0x01));

                           ir_variable *const r37B5 = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r37B5, r3776, 0x01));

                           ir_variable *const r37B6 = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r37B6, body.constant(true), 0x01));

                           ir_variable *const r37B7 = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r37B8 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r37B8);
                           ir_expression *const r37B9 = expr(ir_unop_u2i, r3776);
                           body.emit(assign(r37B8, less(r37B9, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r37BB = lequal(body.constant(int(2045)), r3773);
                           ir_if *f37BA = new(mem_ctx) ir_if(operand(r37BB).val);
                           exec_list *const f37BA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f37BA->then_instructions;

                              ir_variable *const r37BC = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r37BE = less(body.constant(int(2045)), r3773);
                              ir_if *f37BD = new(mem_ctx) ir_if(operand(r37BE).val);
                              exec_list *const f37BD_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f37BD->then_instructions;

                                 body.emit(assign(r37BC, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f37BD->else_instructions;

                                 ir_variable *const r37BF = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r37C1 = equal(r3773, body.constant(int(2045)));
                                 ir_if *f37C0 = new(mem_ctx) ir_if(operand(r37C1).val);
                                 exec_list *const f37C0_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f37C0->then_instructions;

                                    ir_expression *const r37C2 = equal(body.constant(2097151u), r3774);
                                    ir_expression *const r37C3 = equal(body.constant(4294967295u), r3775);
                                    body.emit(assign(r37BF, logic_and(r37C2, r37C3), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f37C0->else_instructions;

                                    body.emit(assign(r37BF, body.constant(false), 0x01));


                                 body.instructions = f37C0_parent_instructions;
                                 body.emit(f37C0);

                                 /* END IF */

                                 body.emit(assign(r37BC, logic_and(r37BF, r37B8), 0x01));


                              body.instructions = f37BD_parent_instructions;
                              body.emit(f37BD);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f37C4 = new(mem_ctx) ir_if(operand(r37BC).val);
                              exec_list *const f37C4_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f37C4->then_instructions;

                                 ir_variable *const r37C5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r37C5);
                                 ir_expression *const r37C6 = lshift(r34C9, body.constant(int(31)));
                                 body.emit(assign(r37C5, add(r37C6, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r37C5, body.constant(0u), 0x01));

                                 body.emit(assign(r37B7, r37C5, 0x03));

                                 body.emit(assign(r37B6, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f37C4->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r37C8 = less(r3773, body.constant(int(0)));
                                 ir_if *f37C7 = new(mem_ctx) ir_if(operand(r37C8).val);
                                 exec_list *const f37C7_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f37C7->then_instructions;

                                    ir_variable *const r37C9 = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r37C9, r3776, 0x01));

                                    ir_variable *const r37CA = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r37CA, neg(r3773), 0x01));

                                    ir_variable *const r37CB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r37CB);
                                    ir_variable *const r37CC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r37CC);
                                    ir_variable *const r37CD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r37CD);
                                    ir_variable *const r37CE = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r37CF = neg(r37CA);
                                    body.emit(assign(r37CE, bit_and(r37CF, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r37D1 = equal(r37CA, body.constant(int(0)));
                                    ir_if *f37D0 = new(mem_ctx) ir_if(operand(r37D1).val);
                                    exec_list *const f37D0_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f37D0->then_instructions;

                                       body.emit(assign(r37CB, r3776, 0x01));

                                       body.emit(assign(r37CC, r3775, 0x01));

                                       body.emit(assign(r37CD, r3774, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f37D0->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r37D3 = less(r37CA, body.constant(int(32)));
                                       ir_if *f37D2 = new(mem_ctx) ir_if(operand(r37D3).val);
                                       exec_list *const f37D2_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f37D2->then_instructions;

                                          body.emit(assign(r37CB, lshift(r3775, r37CE), 0x01));

                                          ir_expression *const r37D4 = lshift(r3774, r37CE);
                                          ir_expression *const r37D5 = rshift(r3775, r37CA);
                                          body.emit(assign(r37CC, bit_or(r37D4, r37D5), 0x01));

                                          body.emit(assign(r37CD, rshift(r3774, r37CA), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f37D2->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r37D7 = equal(r37CA, body.constant(int(32)));
                                          ir_if *f37D6 = new(mem_ctx) ir_if(operand(r37D7).val);
                                          exec_list *const f37D6_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f37D6->then_instructions;

                                             body.emit(assign(r37CB, r3775, 0x01));

                                             body.emit(assign(r37CC, r3774, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f37D6->else_instructions;

                                             body.emit(assign(r37C9, bit_or(r3776, r3775), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r37D9 = less(r37CA, body.constant(int(64)));
                                             ir_if *f37D8 = new(mem_ctx) ir_if(operand(r37D9).val);
                                             exec_list *const f37D8_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f37D8->then_instructions;

                                                body.emit(assign(r37CB, lshift(r3774, r37CE), 0x01));

                                                ir_expression *const r37DA = bit_and(r37CA, body.constant(int(31)));
                                                body.emit(assign(r37CC, rshift(r3774, r37DA), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f37D8->else_instructions;

                                                ir_variable *const r37DB = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r37DD = equal(r37CA, body.constant(int(64)));
                                                ir_if *f37DC = new(mem_ctx) ir_if(operand(r37DD).val);
                                                exec_list *const f37DC_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f37DC->then_instructions;

                                                   body.emit(assign(r37DB, r3774, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f37DC->else_instructions;

                                                   ir_expression *const r37DE = nequal(r3774, body.constant(0u));
                                                   ir_expression *const r37DF = expr(ir_unop_b2i, r37DE);
                                                   body.emit(assign(r37DB, expr(ir_unop_i2u, r37DF), 0x01));


                                                body.instructions = f37DC_parent_instructions;
                                                body.emit(f37DC);

                                                /* END IF */

                                                body.emit(assign(r37CB, r37DB, 0x01));

                                                body.emit(assign(r37CC, body.constant(0u), 0x01));


                                             body.instructions = f37D8_parent_instructions;
                                             body.emit(f37D8);

                                             /* END IF */


                                          body.instructions = f37D6_parent_instructions;
                                          body.emit(f37D6);

                                          /* END IF */

                                          body.emit(assign(r37CD, body.constant(0u), 0x01));


                                       body.instructions = f37D2_parent_instructions;
                                       body.emit(f37D2);

                                       /* END IF */

                                       ir_expression *const r37E0 = nequal(r37C9, body.constant(0u));
                                       ir_expression *const r37E1 = expr(ir_unop_b2i, r37E0);
                                       ir_expression *const r37E2 = expr(ir_unop_i2u, r37E1);
                                       body.emit(assign(r37CB, bit_or(r37CB, r37E2), 0x01));


                                    body.instructions = f37D0_parent_instructions;
                                    body.emit(f37D0);

                                    /* END IF */

                                    body.emit(assign(r37B3, r37CD, 0x01));

                                    body.emit(assign(r37B4, r37CC, 0x01));

                                    body.emit(assign(r37B5, r37CB, 0x01));

                                    body.emit(assign(r37B2, body.constant(int(0)), 0x01));

                                    body.emit(assign(r37B8, less(r37CB, body.constant(0u)), 0x01));


                                 body.instructions = f37C7_parent_instructions;
                                 body.emit(f37C7);

                                 /* END IF */


                              body.instructions = f37C4_parent_instructions;
                              body.emit(f37C4);

                              /* END IF */


                           body.instructions = f37BA_parent_instructions;
                           body.emit(f37BA);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f37E3 = new(mem_ctx) ir_if(operand(r37B6).val);
                           exec_list *const f37E3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f37E3->then_instructions;

                              /* IF CONDITION */
                              ir_if *f37E4 = new(mem_ctx) ir_if(operand(r37B8).val);
                              exec_list *const f37E4_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f37E4->then_instructions;

                                 ir_variable *const r37E5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r37E5, add(r37B4, body.constant(1u)), 0x01));

                                 ir_expression *const r37E6 = less(r37E5, r37B4);
                                 ir_expression *const r37E7 = expr(ir_unop_b2i, r37E6);
                                 ir_expression *const r37E8 = expr(ir_unop_i2u, r37E7);
                                 body.emit(assign(r37B3, add(r37B3, r37E8), 0x01));

                                 ir_expression *const r37E9 = equal(r37B5, body.constant(0u));
                                 ir_expression *const r37EA = expr(ir_unop_b2i, r37E9);
                                 ir_expression *const r37EB = expr(ir_unop_i2u, r37EA);
                                 ir_expression *const r37EC = add(r37B5, r37EB);
                                 ir_expression *const r37ED = bit_and(r37EC, body.constant(1u));
                                 ir_expression *const r37EE = expr(ir_unop_bit_not, r37ED);
                                 body.emit(assign(r37B4, bit_and(r37E5, r37EE), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f37E4->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r37F0 = bit_or(r37B3, r37B4);
                                 ir_expression *const r37F1 = equal(r37F0, body.constant(0u));
                                 ir_if *f37EF = new(mem_ctx) ir_if(operand(r37F1).val);
                                 exec_list *const f37EF_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f37EF->then_instructions;

                                    body.emit(assign(r37B2, body.constant(int(0)), 0x01));


                                 body.instructions = f37EF_parent_instructions;
                                 body.emit(f37EF);

                                 /* END IF */


                              body.instructions = f37E4_parent_instructions;
                              body.emit(f37E4);

                              /* END IF */

                              ir_variable *const r37F2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r37F2);
                              ir_expression *const r37F3 = lshift(r34C9, body.constant(int(31)));
                              ir_expression *const r37F4 = expr(ir_unop_i2u, r37B2);
                              ir_expression *const r37F5 = lshift(r37F4, body.constant(int(20)));
                              ir_expression *const r37F6 = add(r37F3, r37F5);
                              body.emit(assign(r37F2, add(r37F6, r37B3), 0x02));

                              body.emit(assign(r37F2, r37B4, 0x01));

                              body.emit(assign(r37B7, r37F2, 0x03));

                              body.emit(assign(r37B6, body.constant(false), 0x01));


                           body.instructions = f37E3_parent_instructions;
                           body.emit(f37E3);

                           /* END IF */

                           body.emit(assign(r34CA, r37B7, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f376B->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r37F8 = less(r34D1, r34CF);
                           ir_if *f37F7 = new(mem_ctx) ir_if(operand(r37F8).val);
                           exec_list *const f37F7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f37F7->then_instructions;

                              ir_variable *const r37F9 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                              ir_variable *const r37FA = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r37FA, sub(r34CF, r34D1), 0x01));

                              ir_expression *const r37FB = sub(r34CE, r34D0);
                              ir_expression *const r37FC = less(r34CF, r34D1);
                              ir_expression *const r37FD = expr(ir_unop_b2i, r37FC);
                              ir_expression *const r37FE = expr(ir_unop_i2u, r37FD);
                              body.emit(assign(r37F9, sub(r37FB, r37FE), 0x01));

                              body.emit(assign(r34C9, bit_xor(r34C9, body.constant(1u)), 0x01));

                              body.emit(assign(r34D2, add(r34CC, body.constant(int(-1))), 0x01));

                              ir_variable *const r37FF = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r37FF, add(r34D2, body.constant(int(-10))), 0x01));

                              ir_variable *const r3800 = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r3800, r37F9, 0x01));

                              ir_variable *const r3801 = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r3801, r37FA, 0x01));

                              ir_variable *const r3802 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                              body.emit(r3802);
                              ir_variable *const r3803 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r3803);
                              /* IF CONDITION */
                              ir_expression *const r3805 = equal(r37F9, body.constant(0u));
                              ir_if *f3804 = new(mem_ctx) ir_if(operand(r3805).val);
                              exec_list *const f3804_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3804->then_instructions;

                                 body.emit(assign(r3800, r37FA, 0x01));

                                 body.emit(assign(r3801, body.constant(0u), 0x01));

                                 body.emit(assign(r37FF, add(r37FF, body.constant(int(-32))), 0x01));


                              body.instructions = f3804_parent_instructions;
                              body.emit(f3804);

                              /* END IF */

                              ir_variable *const r3806 = body.make_temp(glsl_type::uint_type, "a");
                              body.emit(assign(r3806, r3800, 0x01));

                              ir_variable *const r3807 = body.make_temp(glsl_type::int_type, "return_value");
                              ir_variable *const r3808 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r3808);
                              /* IF CONDITION */
                              ir_expression *const r380A = equal(r3800, body.constant(0u));
                              ir_if *f3809 = new(mem_ctx) ir_if(operand(r380A).val);
                              exec_list *const f3809_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3809->then_instructions;

                                 body.emit(assign(r3807, body.constant(int(32)), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3809->else_instructions;

                                 body.emit(assign(r3808, body.constant(int(0)), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r380C = bit_and(r3800, body.constant(4294901760u));
                                 ir_expression *const r380D = equal(r380C, body.constant(0u));
                                 ir_if *f380B = new(mem_ctx) ir_if(operand(r380D).val);
                                 exec_list *const f380B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f380B->then_instructions;

                                    body.emit(assign(r3808, body.constant(int(16)), 0x01));

                                    body.emit(assign(r3806, lshift(r3800, body.constant(int(16))), 0x01));


                                 body.instructions = f380B_parent_instructions;
                                 body.emit(f380B);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r380F = bit_and(r3806, body.constant(4278190080u));
                                 ir_expression *const r3810 = equal(r380F, body.constant(0u));
                                 ir_if *f380E = new(mem_ctx) ir_if(operand(r3810).val);
                                 exec_list *const f380E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f380E->then_instructions;

                                    body.emit(assign(r3808, add(r3808, body.constant(int(8))), 0x01));

                                    body.emit(assign(r3806, lshift(r3806, body.constant(int(8))), 0x01));


                                 body.instructions = f380E_parent_instructions;
                                 body.emit(f380E);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r3812 = bit_and(r3806, body.constant(4026531840u));
                                 ir_expression *const r3813 = equal(r3812, body.constant(0u));
                                 ir_if *f3811 = new(mem_ctx) ir_if(operand(r3813).val);
                                 exec_list *const f3811_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3811->then_instructions;

                                    body.emit(assign(r3808, add(r3808, body.constant(int(4))), 0x01));

                                    body.emit(assign(r3806, lshift(r3806, body.constant(int(4))), 0x01));


                                 body.instructions = f3811_parent_instructions;
                                 body.emit(f3811);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r3815 = bit_and(r3806, body.constant(3221225472u));
                                 ir_expression *const r3816 = equal(r3815, body.constant(0u));
                                 ir_if *f3814 = new(mem_ctx) ir_if(operand(r3816).val);
                                 exec_list *const f3814_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3814->then_instructions;

                                    body.emit(assign(r3808, add(r3808, body.constant(int(2))), 0x01));

                                    body.emit(assign(r3806, lshift(r3806, body.constant(int(2))), 0x01));


                                 body.instructions = f3814_parent_instructions;
                                 body.emit(f3814);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r3818 = bit_and(r3806, body.constant(2147483648u));
                                 ir_expression *const r3819 = equal(r3818, body.constant(0u));
                                 ir_if *f3817 = new(mem_ctx) ir_if(operand(r3819).val);
                                 exec_list *const f3817_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3817->then_instructions;

                                    body.emit(assign(r3808, add(r3808, body.constant(int(1))), 0x01));


                                 body.instructions = f3817_parent_instructions;
                                 body.emit(f3817);

                                 /* END IF */

                                 body.emit(assign(r3807, r3808, 0x01));


                              body.instructions = f3809_parent_instructions;
                              body.emit(f3809);

                              /* END IF */

                              body.emit(assign(r3803, add(r3807, body.constant(int(-11))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r381B = lequal(body.constant(int(0)), r3803);
                              ir_if *f381A = new(mem_ctx) ir_if(operand(r381B).val);
                              exec_list *const f381A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f381A->then_instructions;

                                 body.emit(assign(r3802, body.constant(0u), 0x01));

                                 ir_variable *const r381C = body.make_temp(glsl_type::uint_type, "z1Ptr");
                                 body.emit(assign(r381C, lshift(r3801, r3803), 0x01));

                                 ir_variable *const r381D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r381F = equal(r3803, body.constant(int(0)));
                                 ir_if *f381E = new(mem_ctx) ir_if(operand(r381F).val);
                                 exec_list *const f381E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f381E->then_instructions;

                                    body.emit(assign(r381D, r3800, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f381E->else_instructions;

                                    ir_expression *const r3820 = lshift(r3800, r3803);
                                    ir_expression *const r3821 = neg(r3803);
                                    ir_expression *const r3822 = bit_and(r3821, body.constant(int(31)));
                                    ir_expression *const r3823 = rshift(r3801, r3822);
                                    body.emit(assign(r381D, bit_or(r3820, r3823), 0x01));


                                 body.instructions = f381E_parent_instructions;
                                 body.emit(f381E);

                                 /* END IF */

                                 body.emit(assign(r3800, r381D, 0x01));

                                 body.emit(assign(r3801, r381C, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f381A->else_instructions;

                                 ir_variable *const r3824 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r3824, body.constant(0u), 0x01));

                                 ir_variable *const r3825 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r3825, neg(r3803), 0x01));

                                 ir_variable *const r3826 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r3826);
                                 ir_variable *const r3827 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r3827);
                                 ir_variable *const r3828 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r3828);
                                 ir_variable *const r3829 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r382A = neg(r3825);
                                 body.emit(assign(r3829, bit_and(r382A, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r382C = equal(r3825, body.constant(int(0)));
                                 ir_if *f382B = new(mem_ctx) ir_if(operand(r382C).val);
                                 exec_list *const f382B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f382B->then_instructions;

                                    body.emit(assign(r3826, r3824, 0x01));

                                    body.emit(assign(r3827, r3801, 0x01));

                                    body.emit(assign(r3828, r3800, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f382B->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r382E = less(r3825, body.constant(int(32)));
                                    ir_if *f382D = new(mem_ctx) ir_if(operand(r382E).val);
                                    exec_list *const f382D_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f382D->then_instructions;

                                       body.emit(assign(r3826, lshift(r3801, r3829), 0x01));

                                       ir_expression *const r382F = lshift(r3800, r3829);
                                       ir_expression *const r3830 = rshift(r3801, r3825);
                                       body.emit(assign(r3827, bit_or(r382F, r3830), 0x01));

                                       body.emit(assign(r3828, rshift(r3800, r3825), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f382D->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r3832 = equal(r3825, body.constant(int(32)));
                                       ir_if *f3831 = new(mem_ctx) ir_if(operand(r3832).val);
                                       exec_list *const f3831_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3831->then_instructions;

                                          body.emit(assign(r3826, r3801, 0x01));

                                          body.emit(assign(r3827, r3800, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3831->else_instructions;

                                          body.emit(assign(r3824, bit_or(body.constant(0u), r3801), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r3834 = less(r3825, body.constant(int(64)));
                                          ir_if *f3833 = new(mem_ctx) ir_if(operand(r3834).val);
                                          exec_list *const f3833_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3833->then_instructions;

                                             body.emit(assign(r3826, lshift(r3800, r3829), 0x01));

                                             ir_expression *const r3835 = bit_and(r3825, body.constant(int(31)));
                                             body.emit(assign(r3827, rshift(r3800, r3835), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3833->else_instructions;

                                             ir_variable *const r3836 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r3838 = equal(r3825, body.constant(int(64)));
                                             ir_if *f3837 = new(mem_ctx) ir_if(operand(r3838).val);
                                             exec_list *const f3837_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f3837->then_instructions;

                                                body.emit(assign(r3836, r3800, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f3837->else_instructions;

                                                ir_expression *const r3839 = nequal(r3800, body.constant(0u));
                                                ir_expression *const r383A = expr(ir_unop_b2i, r3839);
                                                body.emit(assign(r3836, expr(ir_unop_i2u, r383A), 0x01));


                                             body.instructions = f3837_parent_instructions;
                                             body.emit(f3837);

                                             /* END IF */

                                             body.emit(assign(r3826, r3836, 0x01));

                                             body.emit(assign(r3827, body.constant(0u), 0x01));


                                          body.instructions = f3833_parent_instructions;
                                          body.emit(f3833);

                                          /* END IF */


                                       body.instructions = f3831_parent_instructions;
                                       body.emit(f3831);

                                       /* END IF */

                                       body.emit(assign(r3828, body.constant(0u), 0x01));


                                    body.instructions = f382D_parent_instructions;
                                    body.emit(f382D);

                                    /* END IF */

                                    ir_expression *const r383B = nequal(r3824, body.constant(0u));
                                    ir_expression *const r383C = expr(ir_unop_b2i, r383B);
                                    ir_expression *const r383D = expr(ir_unop_i2u, r383C);
                                    body.emit(assign(r3826, bit_or(r3826, r383D), 0x01));


                                 body.instructions = f382B_parent_instructions;
                                 body.emit(f382B);

                                 /* END IF */

                                 body.emit(assign(r3800, r3828, 0x01));

                                 body.emit(assign(r3801, r3827, 0x01));

                                 body.emit(assign(r3802, r3826, 0x01));


                              body.instructions = f381A_parent_instructions;
                              body.emit(f381A);

                              /* END IF */

                              body.emit(assign(r37FF, sub(r37FF, r3803), 0x01));

                              ir_variable *const r383E = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r383E, r37FF, 0x01));

                              ir_variable *const r383F = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r383F, r3800, 0x01));

                              ir_variable *const r3840 = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r3840, r3801, 0x01));

                              ir_variable *const r3841 = body.make_temp(glsl_type::uint_type, "zFrac2");
                              body.emit(assign(r3841, r3802, 0x01));

                              ir_variable *const r3842 = body.make_temp(glsl_type::bool_type, "execute_flag");
                              body.emit(assign(r3842, body.constant(true), 0x01));

                              ir_variable *const r3843 = body.make_temp(glsl_type::uvec2_type, "return_value");
                              ir_variable *const r3844 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                              body.emit(r3844);
                              ir_expression *const r3845 = expr(ir_unop_u2i, r3802);
                              body.emit(assign(r3844, less(r3845, body.constant(int(0))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3847 = lequal(body.constant(int(2045)), r37FF);
                              ir_if *f3846 = new(mem_ctx) ir_if(operand(r3847).val);
                              exec_list *const f3846_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3846->then_instructions;

                                 ir_variable *const r3848 = body.make_temp(glsl_type::bool_type, "or_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r384A = less(body.constant(int(2045)), r37FF);
                                 ir_if *f3849 = new(mem_ctx) ir_if(operand(r384A).val);
                                 exec_list *const f3849_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3849->then_instructions;

                                    body.emit(assign(r3848, body.constant(true), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3849->else_instructions;

                                    ir_variable *const r384B = body.make_temp(glsl_type::bool_type, "and_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r384D = equal(r37FF, body.constant(int(2045)));
                                    ir_if *f384C = new(mem_ctx) ir_if(operand(r384D).val);
                                    exec_list *const f384C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f384C->then_instructions;

                                       ir_expression *const r384E = equal(body.constant(2097151u), r3800);
                                       ir_expression *const r384F = equal(body.constant(4294967295u), r3801);
                                       body.emit(assign(r384B, logic_and(r384E, r384F), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f384C->else_instructions;

                                       body.emit(assign(r384B, body.constant(false), 0x01));


                                    body.instructions = f384C_parent_instructions;
                                    body.emit(f384C);

                                    /* END IF */

                                    body.emit(assign(r3848, logic_and(r384B, r3844), 0x01));


                                 body.instructions = f3849_parent_instructions;
                                 body.emit(f3849);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_if *f3850 = new(mem_ctx) ir_if(operand(r3848).val);
                                 exec_list *const f3850_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3850->then_instructions;

                                    ir_variable *const r3851 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                    body.emit(r3851);
                                    ir_expression *const r3852 = lshift(r34C9, body.constant(int(31)));
                                    body.emit(assign(r3851, add(r3852, body.constant(2146435072u)), 0x02));

                                    body.emit(assign(r3851, body.constant(0u), 0x01));

                                    body.emit(assign(r3843, r3851, 0x03));

                                    body.emit(assign(r3842, body.constant(false), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3850->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r3854 = less(r37FF, body.constant(int(0)));
                                    ir_if *f3853 = new(mem_ctx) ir_if(operand(r3854).val);
                                    exec_list *const f3853_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3853->then_instructions;

                                       ir_variable *const r3855 = body.make_temp(glsl_type::uint_type, "a2");
                                       body.emit(assign(r3855, r3802, 0x01));

                                       ir_variable *const r3856 = body.make_temp(glsl_type::int_type, "count");
                                       body.emit(assign(r3856, neg(r37FF), 0x01));

                                       ir_variable *const r3857 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                       body.emit(r3857);
                                       ir_variable *const r3858 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                       body.emit(r3858);
                                       ir_variable *const r3859 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                       body.emit(r3859);
                                       ir_variable *const r385A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                       ir_expression *const r385B = neg(r3856);
                                       body.emit(assign(r385A, bit_and(r385B, body.constant(int(31))), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r385D = equal(r3856, body.constant(int(0)));
                                       ir_if *f385C = new(mem_ctx) ir_if(operand(r385D).val);
                                       exec_list *const f385C_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f385C->then_instructions;

                                          body.emit(assign(r3857, r3802, 0x01));

                                          body.emit(assign(r3858, r3801, 0x01));

                                          body.emit(assign(r3859, r3800, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f385C->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r385F = less(r3856, body.constant(int(32)));
                                          ir_if *f385E = new(mem_ctx) ir_if(operand(r385F).val);
                                          exec_list *const f385E_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f385E->then_instructions;

                                             body.emit(assign(r3857, lshift(r3801, r385A), 0x01));

                                             ir_expression *const r3860 = lshift(r3800, r385A);
                                             ir_expression *const r3861 = rshift(r3801, r3856);
                                             body.emit(assign(r3858, bit_or(r3860, r3861), 0x01));

                                             body.emit(assign(r3859, rshift(r3800, r3856), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f385E->else_instructions;

                                             /* IF CONDITION */
                                             ir_expression *const r3863 = equal(r3856, body.constant(int(32)));
                                             ir_if *f3862 = new(mem_ctx) ir_if(operand(r3863).val);
                                             exec_list *const f3862_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f3862->then_instructions;

                                                body.emit(assign(r3857, r3801, 0x01));

                                                body.emit(assign(r3858, r3800, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f3862->else_instructions;

                                                body.emit(assign(r3855, bit_or(r3802, r3801), 0x01));

                                                /* IF CONDITION */
                                                ir_expression *const r3865 = less(r3856, body.constant(int(64)));
                                                ir_if *f3864 = new(mem_ctx) ir_if(operand(r3865).val);
                                                exec_list *const f3864_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f3864->then_instructions;

                                                   body.emit(assign(r3857, lshift(r3800, r385A), 0x01));

                                                   ir_expression *const r3866 = bit_and(r3856, body.constant(int(31)));
                                                   body.emit(assign(r3858, rshift(r3800, r3866), 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f3864->else_instructions;

                                                   ir_variable *const r3867 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                   /* IF CONDITION */
                                                   ir_expression *const r3869 = equal(r3856, body.constant(int(64)));
                                                   ir_if *f3868 = new(mem_ctx) ir_if(operand(r3869).val);
                                                   exec_list *const f3868_parent_instructions = body.instructions;

                                                      /* THEN INSTRUCTIONS */
                                                      body.instructions = &f3868->then_instructions;

                                                      body.emit(assign(r3867, r3800, 0x01));


                                                      /* ELSE INSTRUCTIONS */
                                                      body.instructions = &f3868->else_instructions;

                                                      ir_expression *const r386A = nequal(r3800, body.constant(0u));
                                                      ir_expression *const r386B = expr(ir_unop_b2i, r386A);
                                                      body.emit(assign(r3867, expr(ir_unop_i2u, r386B), 0x01));


                                                   body.instructions = f3868_parent_instructions;
                                                   body.emit(f3868);

                                                   /* END IF */

                                                   body.emit(assign(r3857, r3867, 0x01));

                                                   body.emit(assign(r3858, body.constant(0u), 0x01));


                                                body.instructions = f3864_parent_instructions;
                                                body.emit(f3864);

                                                /* END IF */


                                             body.instructions = f3862_parent_instructions;
                                             body.emit(f3862);

                                             /* END IF */

                                             body.emit(assign(r3859, body.constant(0u), 0x01));


                                          body.instructions = f385E_parent_instructions;
                                          body.emit(f385E);

                                          /* END IF */

                                          ir_expression *const r386C = nequal(r3855, body.constant(0u));
                                          ir_expression *const r386D = expr(ir_unop_b2i, r386C);
                                          ir_expression *const r386E = expr(ir_unop_i2u, r386D);
                                          body.emit(assign(r3857, bit_or(r3857, r386E), 0x01));


                                       body.instructions = f385C_parent_instructions;
                                       body.emit(f385C);

                                       /* END IF */

                                       body.emit(assign(r383F, r3859, 0x01));

                                       body.emit(assign(r3840, r3858, 0x01));

                                       body.emit(assign(r3841, r3857, 0x01));

                                       body.emit(assign(r383E, body.constant(int(0)), 0x01));

                                       body.emit(assign(r3844, less(r3857, body.constant(0u)), 0x01));


                                    body.instructions = f3853_parent_instructions;
                                    body.emit(f3853);

                                    /* END IF */


                                 body.instructions = f3850_parent_instructions;
                                 body.emit(f3850);

                                 /* END IF */


                              body.instructions = f3846_parent_instructions;
                              body.emit(f3846);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f386F = new(mem_ctx) ir_if(operand(r3842).val);
                              exec_list *const f386F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f386F->then_instructions;

                                 /* IF CONDITION */
                                 ir_if *f3870 = new(mem_ctx) ir_if(operand(r3844).val);
                                 exec_list *const f3870_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3870->then_instructions;

                                    ir_variable *const r3871 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                    body.emit(assign(r3871, add(r3840, body.constant(1u)), 0x01));

                                    ir_expression *const r3872 = less(r3871, r3840);
                                    ir_expression *const r3873 = expr(ir_unop_b2i, r3872);
                                    ir_expression *const r3874 = expr(ir_unop_i2u, r3873);
                                    body.emit(assign(r383F, add(r383F, r3874), 0x01));

                                    ir_expression *const r3875 = equal(r3841, body.constant(0u));
                                    ir_expression *const r3876 = expr(ir_unop_b2i, r3875);
                                    ir_expression *const r3877 = expr(ir_unop_i2u, r3876);
                                    ir_expression *const r3878 = add(r3841, r3877);
                                    ir_expression *const r3879 = bit_and(r3878, body.constant(1u));
                                    ir_expression *const r387A = expr(ir_unop_bit_not, r3879);
                                    body.emit(assign(r3840, bit_and(r3871, r387A), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3870->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r387C = bit_or(r383F, r3840);
                                    ir_expression *const r387D = equal(r387C, body.constant(0u));
                                    ir_if *f387B = new(mem_ctx) ir_if(operand(r387D).val);
                                    exec_list *const f387B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f387B->then_instructions;

                                       body.emit(assign(r383E, body.constant(int(0)), 0x01));


                                    body.instructions = f387B_parent_instructions;
                                    body.emit(f387B);

                                    /* END IF */


                                 body.instructions = f3870_parent_instructions;
                                 body.emit(f3870);

                                 /* END IF */

                                 ir_variable *const r387E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r387E);
                                 ir_expression *const r387F = lshift(r34C9, body.constant(int(31)));
                                 ir_expression *const r3880 = expr(ir_unop_i2u, r383E);
                                 ir_expression *const r3881 = lshift(r3880, body.constant(int(20)));
                                 ir_expression *const r3882 = add(r387F, r3881);
                                 body.emit(assign(r387E, add(r3882, r383F), 0x02));

                                 body.emit(assign(r387E, r3840, 0x01));

                                 body.emit(assign(r3843, r387E, 0x03));

                                 body.emit(assign(r3842, body.constant(false), 0x01));


                              body.instructions = f386F_parent_instructions;
                              body.emit(f386F);

                              /* END IF */

                              body.emit(assign(r34CA, r3843, 0x03));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f37F7->else_instructions;

                              ir_variable *const r3883 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r3883);
                              body.emit(assign(r3883, body.constant(0u), 0x02));

                              body.emit(assign(r3883, body.constant(0u), 0x01));

                              body.emit(assign(r34CA, r3883, 0x03));


                           body.instructions = f37F7_parent_instructions;
                           body.emit(f37F7);

                           /* END IF */


                        body.instructions = f376B_parent_instructions;
                        body.emit(f376B);

                        /* END IF */


                     body.instructions = f36DF_parent_instructions;
                     body.emit(f36DF);

                     /* END IF */


                  body.instructions = f3653_parent_instructions;
                  body.emit(f3653);

                  /* END IF */


               body.instructions = f363E_parent_instructions;
               body.emit(f363E);

               /* END IF */


            body.instructions = f358F_parent_instructions;
            body.emit(f358F);

            /* END IF */


         body.instructions = f34DE_parent_instructions;
         body.emit(f34DE);

         /* END IF */

         body.emit(assign(r34C5, r34CA, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f34C7->else_instructions;

         ir_variable *const r3884 = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r3884, body.constant(true), 0x01));

         ir_variable *const r3885 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r3886 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r3886);
         ir_variable *const r3887 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
         body.emit(r3887);
         ir_variable *const r3888 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
         body.emit(r3888);
         ir_variable *const r3889 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
         body.emit(r3889);
         ir_variable *const r388A = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
         body.emit(r388A);
         ir_variable *const r388B = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r388B);
         ir_variable *const r388C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
         body.emit(r388C);
         ir_variable *const r388D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
         body.emit(r388D);
         body.emit(assign(r388D, body.constant(0u), 0x01));

         body.emit(assign(r388C, body.constant(0u), 0x01));

         ir_variable *const r388E = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r388E, swizzle_x(r3490), 0x01));

         body.emit(assign(r388A, r388E, 0x01));

         ir_variable *const r388F = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
         body.emit(assign(r388F, bit_and(swizzle_y(r3490), body.constant(1048575u)), 0x01));

         body.emit(assign(r3889, r388F, 0x01));

         ir_variable *const r3890 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
         body.emit(assign(r3890, body.constant(0u), 0x01));

         body.emit(assign(r3888, body.constant(0u), 0x01));

         body.emit(assign(r3887, body.constant(0u), 0x01));

         ir_variable *const r3891 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r3892 = rshift(swizzle_y(r3490), body.constant(int(20)));
         ir_expression *const r3893 = bit_and(r3892, body.constant(2047u));
         body.emit(assign(r3891, expr(ir_unop_u2i, r3893), 0x01));

         ir_variable *const r3894 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         body.emit(assign(r3894, body.constant(int(1023)), 0x01));

         ir_variable *const r3895 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r3895, add(r3891, body.constant(int(-1023))), 0x01));

         body.emit(assign(r3886, r3895, 0x01));

         /* IF CONDITION */
         ir_expression *const r3897 = less(body.constant(int(0)), r3895);
         ir_if *f3896 = new(mem_ctx) ir_if(operand(r3897).val);
         exec_list *const f3896_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3896->then_instructions;

            /* IF CONDITION */
            ir_expression *const r3899 = equal(r3891, body.constant(int(2047)));
            ir_if *f3898 = new(mem_ctx) ir_if(operand(r3899).val);
            exec_list *const f3898_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3898->then_instructions;

               /* IF CONDITION */
               ir_expression *const r389B = bit_or(r388F, swizzle_x(r3490));
               ir_expression *const r389C = nequal(r389B, body.constant(0u));
               ir_if *f389A = new(mem_ctx) ir_if(operand(r389C).val);
               exec_list *const f389A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f389A->then_instructions;

                  ir_variable *const r389D = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r389D, swizzle_x(r3490), 0x01));

                  ir_variable *const r389E = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r389E, body.constant(0u), 0x01));

                  ir_variable *const r389F = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r389D, bit_or(swizzle_y(r3490), body.constant(524288u)), 0x02));

                  body.emit(assign(r389E, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r38A1 = lshift(swizzle_y(r3490), body.constant(int(1)));
                  ir_expression *const r38A2 = lequal(body.constant(4292870144u), r38A1);
                  ir_expression *const r38A3 = nequal(swizzle_x(r3490), body.constant(0u));
                  ir_expression *const r38A4 = bit_and(swizzle_y(r3490), body.constant(1048575u));
                  ir_expression *const r38A5 = nequal(r38A4, body.constant(0u));
                  ir_expression *const r38A6 = logic_or(r38A3, r38A5);
                  ir_expression *const r38A7 = logic_and(r38A2, r38A6);
                  ir_if *f38A0 = new(mem_ctx) ir_if(operand(r38A7).val);
                  exec_list *const f38A0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f38A0->then_instructions;

                     body.emit(assign(r389F, r389D, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f38A0->else_instructions;

                     body.emit(assign(r389F, r389E, 0x03));


                  body.instructions = f38A0_parent_instructions;
                  body.emit(f38A0);

                  /* END IF */

                  body.emit(assign(r3885, r389F, 0x03));

                  body.emit(assign(r3884, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f389A->else_instructions;

                  body.emit(assign(r3885, r3490, 0x03));

                  body.emit(assign(r3884, body.constant(false), 0x01));


               body.instructions = f389A_parent_instructions;
               body.emit(f389A);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3898->else_instructions;

               body.emit(assign(r3887, body.constant(1048576u), 0x01));

               ir_variable *const r38A8 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r38A8, body.constant(0u), 0x01));

               ir_variable *const r38A9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r38A9);
               ir_variable *const r38AA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r38AA);
               ir_variable *const r38AB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r38AB);
               ir_variable *const r38AC = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r38AD = neg(r3895);
               body.emit(assign(r38AC, bit_and(r38AD, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r38AF = equal(r3895, body.constant(int(0)));
               ir_if *f38AE = new(mem_ctx) ir_if(operand(r38AF).val);
               exec_list *const f38AE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f38AE->then_instructions;

                  body.emit(assign(r38A9, r38A8, 0x01));

                  body.emit(assign(r38AA, body.constant(0u), 0x01));

                  body.emit(assign(r38AB, r3887, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f38AE->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r38B1 = less(r3895, body.constant(int(32)));
                  ir_if *f38B0 = new(mem_ctx) ir_if(operand(r38B1).val);
                  exec_list *const f38B0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f38B0->then_instructions;

                     body.emit(assign(r38A9, body.constant(0u), 0x01));

                     ir_expression *const r38B2 = lshift(body.constant(1048576u), r38AC);
                     body.emit(assign(r38AA, bit_or(r38B2, body.constant(0u)), 0x01));

                     body.emit(assign(r38AB, rshift(body.constant(1048576u), r3895), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f38B0->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r38B4 = equal(r3895, body.constant(int(32)));
                     ir_if *f38B3 = new(mem_ctx) ir_if(operand(r38B4).val);
                     exec_list *const f38B3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f38B3->then_instructions;

                        body.emit(assign(r38A9, body.constant(0u), 0x01));

                        body.emit(assign(r38AA, r3887, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f38B3->else_instructions;

                        body.emit(assign(r38A8, body.constant(0u), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r38B6 = less(r3895, body.constant(int(64)));
                        ir_if *f38B5 = new(mem_ctx) ir_if(operand(r38B6).val);
                        exec_list *const f38B5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f38B5->then_instructions;

                           body.emit(assign(r38A9, lshift(body.constant(1048576u), r38AC), 0x01));

                           ir_expression *const r38B7 = bit_and(r3895, body.constant(int(31)));
                           body.emit(assign(r38AA, rshift(body.constant(1048576u), r38B7), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f38B5->else_instructions;

                           ir_variable *const r38B8 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r38BA = equal(r3895, body.constant(int(64)));
                           ir_if *f38B9 = new(mem_ctx) ir_if(operand(r38BA).val);
                           exec_list *const f38B9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f38B9->then_instructions;

                              body.emit(assign(r38B8, r3887, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f38B9->else_instructions;

                              body.emit(assign(r38B8, body.constant(1u), 0x01));


                           body.instructions = f38B9_parent_instructions;
                           body.emit(f38B9);

                           /* END IF */

                           body.emit(assign(r38A9, r38B8, 0x01));

                           body.emit(assign(r38AA, body.constant(0u), 0x01));


                        body.instructions = f38B5_parent_instructions;
                        body.emit(f38B5);

                        /* END IF */


                     body.instructions = f38B3_parent_instructions;
                     body.emit(f38B3);

                     /* END IF */

                     body.emit(assign(r38AB, body.constant(0u), 0x01));


                  body.instructions = f38B0_parent_instructions;
                  body.emit(f38B0);

                  /* END IF */

                  ir_expression *const r38BB = nequal(r38A8, body.constant(0u));
                  ir_expression *const r38BC = expr(ir_unop_b2i, r38BB);
                  ir_expression *const r38BD = expr(ir_unop_i2u, r38BC);
                  body.emit(assign(r38A9, bit_or(r38A9, r38BD), 0x01));


               body.instructions = f38AE_parent_instructions;
               body.emit(f38AE);

               /* END IF */

               body.emit(assign(r3887, r38AB, 0x01));

               body.emit(assign(r3888, r38AA, 0x01));

               body.emit(assign(r388C, r38A9, 0x01));

               body.emit(assign(r388B, r3891, 0x01));


            body.instructions = f3898_parent_instructions;
            body.emit(f3898);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3896->else_instructions;

            /* IF CONDITION */
            ir_expression *const r38BF = less(r3895, body.constant(int(0)));
            ir_if *f38BE = new(mem_ctx) ir_if(operand(r38BF).val);
            exec_list *const f38BE_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f38BE->then_instructions;

               /* IF CONDITION */
               ir_expression *const r38C1 = equal(r3891, body.constant(int(0)));
               ir_if *f38C0 = new(mem_ctx) ir_if(operand(r38C1).val);
               exec_list *const f38C0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f38C0->then_instructions;

                  body.emit(assign(r3886, add(r3895, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f38C0->else_instructions;

                  body.emit(assign(r3889, bit_or(r388F, body.constant(1048576u)), 0x01));


               body.instructions = f38C0_parent_instructions;
               body.emit(f38C0);

               /* END IF */

               ir_variable *const r38C2 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r38C2, body.constant(0u), 0x01));

               ir_variable *const r38C3 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r38C3, neg(r3886), 0x01));

               ir_variable *const r38C4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r38C4);
               ir_variable *const r38C5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r38C5);
               ir_variable *const r38C6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r38C6);
               ir_variable *const r38C7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r38C8 = neg(r38C3);
               body.emit(assign(r38C7, bit_and(r38C8, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r38CA = equal(r38C3, body.constant(int(0)));
               ir_if *f38C9 = new(mem_ctx) ir_if(operand(r38CA).val);
               exec_list *const f38C9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f38C9->then_instructions;

                  body.emit(assign(r38C4, r38C2, 0x01));

                  body.emit(assign(r38C5, r388E, 0x01));

                  body.emit(assign(r38C6, r3889, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f38C9->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r38CC = less(r38C3, body.constant(int(32)));
                  ir_if *f38CB = new(mem_ctx) ir_if(operand(r38CC).val);
                  exec_list *const f38CB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f38CB->then_instructions;

                     body.emit(assign(r38C4, lshift(swizzle_x(r3490), r38C7), 0x01));

                     ir_expression *const r38CD = lshift(r3889, r38C7);
                     ir_expression *const r38CE = rshift(swizzle_x(r3490), r38C3);
                     body.emit(assign(r38C5, bit_or(r38CD, r38CE), 0x01));

                     body.emit(assign(r38C6, rshift(r3889, r38C3), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f38CB->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r38D0 = equal(r38C3, body.constant(int(32)));
                     ir_if *f38CF = new(mem_ctx) ir_if(operand(r38D0).val);
                     exec_list *const f38CF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f38CF->then_instructions;

                        body.emit(assign(r38C4, r388E, 0x01));

                        body.emit(assign(r38C5, r3889, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f38CF->else_instructions;

                        body.emit(assign(r38C2, bit_or(body.constant(0u), swizzle_x(r3490)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r38D2 = less(r38C3, body.constant(int(64)));
                        ir_if *f38D1 = new(mem_ctx) ir_if(operand(r38D2).val);
                        exec_list *const f38D1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f38D1->then_instructions;

                           body.emit(assign(r38C4, lshift(r3889, r38C7), 0x01));

                           ir_expression *const r38D3 = bit_and(r38C3, body.constant(int(31)));
                           body.emit(assign(r38C5, rshift(r3889, r38D3), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f38D1->else_instructions;

                           ir_variable *const r38D4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r38D6 = equal(r38C3, body.constant(int(64)));
                           ir_if *f38D5 = new(mem_ctx) ir_if(operand(r38D6).val);
                           exec_list *const f38D5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f38D5->then_instructions;

                              body.emit(assign(r38D4, r3889, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f38D5->else_instructions;

                              ir_expression *const r38D7 = nequal(r3889, body.constant(0u));
                              ir_expression *const r38D8 = expr(ir_unop_b2i, r38D7);
                              body.emit(assign(r38D4, expr(ir_unop_i2u, r38D8), 0x01));


                           body.instructions = f38D5_parent_instructions;
                           body.emit(f38D5);

                           /* END IF */

                           body.emit(assign(r38C4, r38D4, 0x01));

                           body.emit(assign(r38C5, body.constant(0u), 0x01));


                        body.instructions = f38D1_parent_instructions;
                        body.emit(f38D1);

                        /* END IF */


                     body.instructions = f38CF_parent_instructions;
                     body.emit(f38CF);

                     /* END IF */

                     body.emit(assign(r38C6, body.constant(0u), 0x01));


                  body.instructions = f38CB_parent_instructions;
                  body.emit(f38CB);

                  /* END IF */

                  ir_expression *const r38D9 = nequal(r38C2, body.constant(0u));
                  ir_expression *const r38DA = expr(ir_unop_b2i, r38D9);
                  ir_expression *const r38DB = expr(ir_unop_i2u, r38DA);
                  body.emit(assign(r38C4, bit_or(r38C4, r38DB), 0x01));


               body.instructions = f38C9_parent_instructions;
               body.emit(f38C9);

               /* END IF */

               body.emit(assign(r3889, r38C6, 0x01));

               body.emit(assign(r388A, r38C5, 0x01));

               body.emit(assign(r388C, r38C4, 0x01));

               body.emit(assign(r388B, body.constant(int(1023)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f38BE->else_instructions;

               /* IF CONDITION */
               ir_expression *const r38DD = equal(r3891, body.constant(int(2047)));
               ir_if *f38DC = new(mem_ctx) ir_if(operand(r38DD).val);
               exec_list *const f38DC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f38DC->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r38DF = bit_or(r3889, r388A);
                  ir_expression *const r38E0 = bit_or(r3887, r3888);
                  ir_expression *const r38E1 = bit_or(r38DF, r38E0);
                  ir_expression *const r38E2 = nequal(r38E1, body.constant(0u));
                  ir_if *f38DE = new(mem_ctx) ir_if(operand(r38E2).val);
                  exec_list *const f38DE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f38DE->then_instructions;

                     ir_variable *const r38E3 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r38E3, swizzle_x(r3490), 0x01));

                     ir_variable *const r38E4 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r38E4, body.constant(0u), 0x01));

                     ir_variable *const r38E5 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r38E3, bit_or(swizzle_y(r3490), body.constant(524288u)), 0x02));

                     body.emit(assign(r38E4, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r38E7 = lshift(swizzle_y(r3490), body.constant(int(1)));
                     ir_expression *const r38E8 = lequal(body.constant(4292870144u), r38E7);
                     ir_expression *const r38E9 = nequal(swizzle_x(r3490), body.constant(0u));
                     ir_expression *const r38EA = bit_and(swizzle_y(r3490), body.constant(1048575u));
                     ir_expression *const r38EB = nequal(r38EA, body.constant(0u));
                     ir_expression *const r38EC = logic_or(r38E9, r38EB);
                     ir_expression *const r38ED = logic_and(r38E8, r38EC);
                     ir_if *f38E6 = new(mem_ctx) ir_if(operand(r38ED).val);
                     exec_list *const f38E6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f38E6->then_instructions;

                        body.emit(assign(r38E5, r38E3, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f38E6->else_instructions;

                        body.emit(assign(r38E5, r38E4, 0x03));


                     body.instructions = f38E6_parent_instructions;
                     body.emit(f38E6);

                     /* END IF */

                     body.emit(assign(r3885, r38E5, 0x03));

                     body.emit(assign(r3884, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f38DE->else_instructions;

                     body.emit(assign(r3885, r3490, 0x03));

                     body.emit(assign(r3884, body.constant(false), 0x01));


                  body.instructions = f38DE_parent_instructions;
                  body.emit(f38DE);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f38DC->else_instructions;

                  ir_variable *const r38EE = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r38EF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r38EF, add(r388A, r3888), 0x01));

                  ir_expression *const r38F0 = add(r3889, r3887);
                  ir_expression *const r38F1 = less(r38EF, r388A);
                  ir_expression *const r38F2 = expr(ir_unop_b2i, r38F1);
                  ir_expression *const r38F3 = expr(ir_unop_i2u, r38F2);
                  body.emit(assign(r38EE, add(r38F0, r38F3), 0x01));

                  body.emit(assign(r388D, r38EE, 0x01));

                  /* IF CONDITION */
                  ir_expression *const r38F5 = equal(r3891, body.constant(int(0)));
                  ir_if *f38F4 = new(mem_ctx) ir_if(operand(r38F5).val);
                  exec_list *const f38F4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f38F4->then_instructions;

                     ir_variable *const r38F6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r38F6);
                     ir_expression *const r38F7 = lshift(r34C6, body.constant(int(31)));
                     body.emit(assign(r38F6, add(r38F7, r38EE), 0x02));

                     body.emit(assign(r38F6, r38EF, 0x01));

                     body.emit(assign(r3885, r38F6, 0x03));

                     body.emit(assign(r3884, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f38F4->else_instructions;

                     body.emit(assign(r388D, bit_or(r38EE, body.constant(2097152u)), 0x01));

                     body.emit(assign(r388B, r3891, 0x01));

                     ir_variable *const r38F8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r38F8);
                     ir_variable *const r38F9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r38F9);
                     ir_variable *const r38FA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r38FA);
                     body.emit(assign(r38F8, lshift(r38EF, body.constant(int(31))), 0x01));

                     ir_expression *const r38FB = lshift(r388D, body.constant(int(31)));
                     ir_expression *const r38FC = rshift(r38EF, body.constant(int(1)));
                     body.emit(assign(r38F9, bit_or(r38FB, r38FC), 0x01));

                     body.emit(assign(r38FA, rshift(r388D, body.constant(int(1))), 0x01));

                     body.emit(assign(r38F8, bit_or(r38F8, body.constant(0u)), 0x01));

                     body.emit(assign(r388D, r38FA, 0x01));

                     body.emit(assign(r388C, r38F8, 0x01));

                     ir_variable *const r38FD = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r38FD, r3891, 0x01));

                     ir_variable *const r38FE = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r38FE, r38FA, 0x01));

                     ir_variable *const r38FF = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r38FF, r38F9, 0x01));

                     ir_variable *const r3900 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r3900, r38F8, 0x01));

                     ir_variable *const r3901 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r3901, body.constant(true), 0x01));

                     ir_variable *const r3902 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r3903 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r3903);
                     ir_expression *const r3904 = expr(ir_unop_u2i, r38F8);
                     body.emit(assign(r3903, less(r3904, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3906 = lequal(body.constant(int(2045)), r3891);
                     ir_if *f3905 = new(mem_ctx) ir_if(operand(r3906).val);
                     exec_list *const f3905_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3905->then_instructions;

                        ir_variable *const r3907 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r3909 = less(body.constant(int(2045)), r3891);
                        ir_if *f3908 = new(mem_ctx) ir_if(operand(r3909).val);
                        exec_list *const f3908_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3908->then_instructions;

                           body.emit(assign(r3907, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3908->else_instructions;

                           ir_variable *const r390A = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r390C = equal(r3891, body.constant(int(2045)));
                           ir_if *f390B = new(mem_ctx) ir_if(operand(r390C).val);
                           exec_list *const f390B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f390B->then_instructions;

                              ir_expression *const r390D = equal(body.constant(2097151u), r38FA);
                              ir_expression *const r390E = equal(body.constant(4294967295u), r38F9);
                              body.emit(assign(r390A, logic_and(r390D, r390E), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f390B->else_instructions;

                              body.emit(assign(r390A, body.constant(false), 0x01));


                           body.instructions = f390B_parent_instructions;
                           body.emit(f390B);

                           /* END IF */

                           body.emit(assign(r3907, logic_and(r390A, r3903), 0x01));


                        body.instructions = f3908_parent_instructions;
                        body.emit(f3908);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f390F = new(mem_ctx) ir_if(operand(r3907).val);
                        exec_list *const f390F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f390F->then_instructions;

                           ir_variable *const r3910 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r3910);
                           ir_expression *const r3911 = lshift(r34C6, body.constant(int(31)));
                           body.emit(assign(r3910, add(r3911, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r3910, body.constant(0u), 0x01));

                           body.emit(assign(r3902, r3910, 0x03));

                           body.emit(assign(r3901, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f390F->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3913 = less(r3891, body.constant(int(0)));
                           ir_if *f3912 = new(mem_ctx) ir_if(operand(r3913).val);
                           exec_list *const f3912_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3912->then_instructions;

                              ir_variable *const r3914 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r3914, r38F8, 0x01));

                              ir_variable *const r3915 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r3915, neg(r3891), 0x01));

                              ir_variable *const r3916 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r3916);
                              ir_variable *const r3917 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r3917);
                              ir_variable *const r3918 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r3918);
                              ir_variable *const r3919 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r391A = neg(r3915);
                              body.emit(assign(r3919, bit_and(r391A, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r391C = equal(r3915, body.constant(int(0)));
                              ir_if *f391B = new(mem_ctx) ir_if(operand(r391C).val);
                              exec_list *const f391B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f391B->then_instructions;

                                 body.emit(assign(r3916, r38F8, 0x01));

                                 body.emit(assign(r3917, r38F9, 0x01));

                                 body.emit(assign(r3918, r38FA, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f391B->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r391E = less(r3915, body.constant(int(32)));
                                 ir_if *f391D = new(mem_ctx) ir_if(operand(r391E).val);
                                 exec_list *const f391D_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f391D->then_instructions;

                                    body.emit(assign(r3916, lshift(r38F9, r3919), 0x01));

                                    ir_expression *const r391F = lshift(r38FA, r3919);
                                    ir_expression *const r3920 = rshift(r38F9, r3915);
                                    body.emit(assign(r3917, bit_or(r391F, r3920), 0x01));

                                    body.emit(assign(r3918, rshift(r38FA, r3915), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f391D->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r3922 = equal(r3915, body.constant(int(32)));
                                    ir_if *f3921 = new(mem_ctx) ir_if(operand(r3922).val);
                                    exec_list *const f3921_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3921->then_instructions;

                                       body.emit(assign(r3916, r38F9, 0x01));

                                       body.emit(assign(r3917, r38FA, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3921->else_instructions;

                                       body.emit(assign(r3914, bit_or(r38F8, r38F9), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r3924 = less(r3915, body.constant(int(64)));
                                       ir_if *f3923 = new(mem_ctx) ir_if(operand(r3924).val);
                                       exec_list *const f3923_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3923->then_instructions;

                                          body.emit(assign(r3916, lshift(r38FA, r3919), 0x01));

                                          ir_expression *const r3925 = bit_and(r3915, body.constant(int(31)));
                                          body.emit(assign(r3917, rshift(r38FA, r3925), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3923->else_instructions;

                                          ir_variable *const r3926 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r3928 = equal(r3915, body.constant(int(64)));
                                          ir_if *f3927 = new(mem_ctx) ir_if(operand(r3928).val);
                                          exec_list *const f3927_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3927->then_instructions;

                                             body.emit(assign(r3926, r38FA, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3927->else_instructions;

                                             ir_expression *const r3929 = nequal(r38FA, body.constant(0u));
                                             ir_expression *const r392A = expr(ir_unop_b2i, r3929);
                                             body.emit(assign(r3926, expr(ir_unop_i2u, r392A), 0x01));


                                          body.instructions = f3927_parent_instructions;
                                          body.emit(f3927);

                                          /* END IF */

                                          body.emit(assign(r3916, r3926, 0x01));

                                          body.emit(assign(r3917, body.constant(0u), 0x01));


                                       body.instructions = f3923_parent_instructions;
                                       body.emit(f3923);

                                       /* END IF */


                                    body.instructions = f3921_parent_instructions;
                                    body.emit(f3921);

                                    /* END IF */

                                    body.emit(assign(r3918, body.constant(0u), 0x01));


                                 body.instructions = f391D_parent_instructions;
                                 body.emit(f391D);

                                 /* END IF */

                                 ir_expression *const r392B = nequal(r3914, body.constant(0u));
                                 ir_expression *const r392C = expr(ir_unop_b2i, r392B);
                                 ir_expression *const r392D = expr(ir_unop_i2u, r392C);
                                 body.emit(assign(r3916, bit_or(r3916, r392D), 0x01));


                              body.instructions = f391B_parent_instructions;
                              body.emit(f391B);

                              /* END IF */

                              body.emit(assign(r38FE, r3918, 0x01));

                              body.emit(assign(r38FF, r3917, 0x01));

                              body.emit(assign(r3900, r3916, 0x01));

                              body.emit(assign(r38FD, body.constant(int(0)), 0x01));

                              body.emit(assign(r3903, less(r3916, body.constant(0u)), 0x01));


                           body.instructions = f3912_parent_instructions;
                           body.emit(f3912);

                           /* END IF */


                        body.instructions = f390F_parent_instructions;
                        body.emit(f390F);

                        /* END IF */


                     body.instructions = f3905_parent_instructions;
                     body.emit(f3905);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f392E = new(mem_ctx) ir_if(operand(r3901).val);
                     exec_list *const f392E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f392E->then_instructions;

                        /* IF CONDITION */
                        ir_if *f392F = new(mem_ctx) ir_if(operand(r3903).val);
                        exec_list *const f392F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f392F->then_instructions;

                           ir_variable *const r3930 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r3930, add(r38FF, body.constant(1u)), 0x01));

                           ir_expression *const r3931 = less(r3930, r38FF);
                           ir_expression *const r3932 = expr(ir_unop_b2i, r3931);
                           ir_expression *const r3933 = expr(ir_unop_i2u, r3932);
                           body.emit(assign(r38FE, add(r38FE, r3933), 0x01));

                           ir_expression *const r3934 = equal(r3900, body.constant(0u));
                           ir_expression *const r3935 = expr(ir_unop_b2i, r3934);
                           ir_expression *const r3936 = expr(ir_unop_i2u, r3935);
                           ir_expression *const r3937 = add(r3900, r3936);
                           ir_expression *const r3938 = bit_and(r3937, body.constant(1u));
                           ir_expression *const r3939 = expr(ir_unop_bit_not, r3938);
                           body.emit(assign(r38FF, bit_and(r3930, r3939), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f392F->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r393B = bit_or(r38FE, r38FF);
                           ir_expression *const r393C = equal(r393B, body.constant(0u));
                           ir_if *f393A = new(mem_ctx) ir_if(operand(r393C).val);
                           exec_list *const f393A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f393A->then_instructions;

                              body.emit(assign(r38FD, body.constant(int(0)), 0x01));


                           body.instructions = f393A_parent_instructions;
                           body.emit(f393A);

                           /* END IF */


                        body.instructions = f392F_parent_instructions;
                        body.emit(f392F);

                        /* END IF */

                        ir_variable *const r393D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r393D);
                        ir_expression *const r393E = lshift(r34C6, body.constant(int(31)));
                        ir_expression *const r393F = expr(ir_unop_i2u, r38FD);
                        ir_expression *const r3940 = lshift(r393F, body.constant(int(20)));
                        ir_expression *const r3941 = add(r393E, r3940);
                        body.emit(assign(r393D, add(r3941, r38FE), 0x02));

                        body.emit(assign(r393D, r38FF, 0x01));

                        body.emit(assign(r3902, r393D, 0x03));

                        body.emit(assign(r3901, body.constant(false), 0x01));


                     body.instructions = f392E_parent_instructions;
                     body.emit(f392E);

                     /* END IF */

                     body.emit(assign(r3885, r3902, 0x03));

                     body.emit(assign(r3884, body.constant(false), 0x01));


                  body.instructions = f38F4_parent_instructions;
                  body.emit(f38F4);

                  /* END IF */


               body.instructions = f38DC_parent_instructions;
               body.emit(f38DC);

               /* END IF */


            body.instructions = f38BE_parent_instructions;
            body.emit(f38BE);

            /* END IF */


         body.instructions = f3896_parent_instructions;
         body.emit(f3896);

         /* END IF */

         /* IF CONDITION */
         ir_if *f3942 = new(mem_ctx) ir_if(operand(r3884).val);
         exec_list *const f3942_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3942->then_instructions;

            body.emit(assign(r3889, bit_or(r3889, body.constant(1048576u)), 0x01));

            ir_variable *const r3943 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r3944 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r3944, add(r388A, r3888), 0x01));

            ir_expression *const r3945 = add(r3889, r3887);
            ir_expression *const r3946 = less(r3944, r388A);
            ir_expression *const r3947 = expr(ir_unop_b2i, r3946);
            ir_expression *const r3948 = expr(ir_unop_i2u, r3947);
            body.emit(assign(r3943, add(r3945, r3948), 0x01));

            body.emit(assign(r388D, r3943, 0x01));

            body.emit(assign(r388B, add(r388B, body.constant(int(-1))), 0x01));

            /* IF CONDITION */
            ir_expression *const r394A = less(r3943, body.constant(2097152u));
            ir_if *f3949 = new(mem_ctx) ir_if(operand(r394A).val);
            exec_list *const f3949_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3949->then_instructions;

               ir_variable *const r394B = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r394B, r388B, 0x01));

               ir_variable *const r394C = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r394C, r3943, 0x01));

               ir_variable *const r394D = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r394D, r3944, 0x01));

               ir_variable *const r394E = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r394E, r388C, 0x01));

               ir_variable *const r394F = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r394F, body.constant(true), 0x01));

               ir_variable *const r3950 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r3951 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r3951);
               ir_expression *const r3952 = expr(ir_unop_u2i, r388C);
               body.emit(assign(r3951, less(r3952, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3954 = lequal(body.constant(int(2045)), r388B);
               ir_if *f3953 = new(mem_ctx) ir_if(operand(r3954).val);
               exec_list *const f3953_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3953->then_instructions;

                  ir_variable *const r3955 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3957 = less(body.constant(int(2045)), r388B);
                  ir_if *f3956 = new(mem_ctx) ir_if(operand(r3957).val);
                  exec_list *const f3956_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3956->then_instructions;

                     body.emit(assign(r3955, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3956->else_instructions;

                     ir_variable *const r3958 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r395A = equal(r388B, body.constant(int(2045)));
                     ir_if *f3959 = new(mem_ctx) ir_if(operand(r395A).val);
                     exec_list *const f3959_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3959->then_instructions;

                        ir_expression *const r395B = equal(body.constant(2097151u), r3943);
                        ir_expression *const r395C = equal(body.constant(4294967295u), r3944);
                        body.emit(assign(r3958, logic_and(r395B, r395C), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3959->else_instructions;

                        body.emit(assign(r3958, body.constant(false), 0x01));


                     body.instructions = f3959_parent_instructions;
                     body.emit(f3959);

                     /* END IF */

                     body.emit(assign(r3955, logic_and(r3958, r3951), 0x01));


                  body.instructions = f3956_parent_instructions;
                  body.emit(f3956);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f395D = new(mem_ctx) ir_if(operand(r3955).val);
                  exec_list *const f395D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f395D->then_instructions;

                     ir_variable *const r395E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r395E);
                     ir_expression *const r395F = lshift(r34C6, body.constant(int(31)));
                     body.emit(assign(r395E, add(r395F, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r395E, body.constant(0u), 0x01));

                     body.emit(assign(r3950, r395E, 0x03));

                     body.emit(assign(r394F, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f395D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3961 = less(r388B, body.constant(int(0)));
                     ir_if *f3960 = new(mem_ctx) ir_if(operand(r3961).val);
                     exec_list *const f3960_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3960->then_instructions;

                        ir_variable *const r3962 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r3962, r388C, 0x01));

                        ir_variable *const r3963 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r3963, neg(r388B), 0x01));

                        ir_variable *const r3964 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r3964);
                        ir_variable *const r3965 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r3965);
                        ir_variable *const r3966 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r3966);
                        ir_variable *const r3967 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r3968 = neg(r3963);
                        body.emit(assign(r3967, bit_and(r3968, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r396A = equal(r3963, body.constant(int(0)));
                        ir_if *f3969 = new(mem_ctx) ir_if(operand(r396A).val);
                        exec_list *const f3969_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3969->then_instructions;

                           body.emit(assign(r3964, r388C, 0x01));

                           body.emit(assign(r3965, r3944, 0x01));

                           body.emit(assign(r3966, r3943, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3969->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r396C = less(r3963, body.constant(int(32)));
                           ir_if *f396B = new(mem_ctx) ir_if(operand(r396C).val);
                           exec_list *const f396B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f396B->then_instructions;

                              body.emit(assign(r3964, lshift(r3944, r3967), 0x01));

                              ir_expression *const r396D = lshift(r3943, r3967);
                              ir_expression *const r396E = rshift(r3944, r3963);
                              body.emit(assign(r3965, bit_or(r396D, r396E), 0x01));

                              body.emit(assign(r3966, rshift(r3943, r3963), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f396B->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3970 = equal(r3963, body.constant(int(32)));
                              ir_if *f396F = new(mem_ctx) ir_if(operand(r3970).val);
                              exec_list *const f396F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f396F->then_instructions;

                                 body.emit(assign(r3964, r3944, 0x01));

                                 body.emit(assign(r3965, r3943, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f396F->else_instructions;

                                 body.emit(assign(r3962, bit_or(r388C, r3944), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3972 = less(r3963, body.constant(int(64)));
                                 ir_if *f3971 = new(mem_ctx) ir_if(operand(r3972).val);
                                 exec_list *const f3971_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3971->then_instructions;

                                    body.emit(assign(r3964, lshift(r3943, r3967), 0x01));

                                    ir_expression *const r3973 = bit_and(r3963, body.constant(int(31)));
                                    body.emit(assign(r3965, rshift(r3943, r3973), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3971->else_instructions;

                                    ir_variable *const r3974 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r3976 = equal(r3963, body.constant(int(64)));
                                    ir_if *f3975 = new(mem_ctx) ir_if(operand(r3976).val);
                                    exec_list *const f3975_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3975->then_instructions;

                                       body.emit(assign(r3974, r3943, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3975->else_instructions;

                                       ir_expression *const r3977 = nequal(r3943, body.constant(0u));
                                       ir_expression *const r3978 = expr(ir_unop_b2i, r3977);
                                       body.emit(assign(r3974, expr(ir_unop_i2u, r3978), 0x01));


                                    body.instructions = f3975_parent_instructions;
                                    body.emit(f3975);

                                    /* END IF */

                                    body.emit(assign(r3964, r3974, 0x01));

                                    body.emit(assign(r3965, body.constant(0u), 0x01));


                                 body.instructions = f3971_parent_instructions;
                                 body.emit(f3971);

                                 /* END IF */


                              body.instructions = f396F_parent_instructions;
                              body.emit(f396F);

                              /* END IF */

                              body.emit(assign(r3966, body.constant(0u), 0x01));


                           body.instructions = f396B_parent_instructions;
                           body.emit(f396B);

                           /* END IF */

                           ir_expression *const r3979 = nequal(r3962, body.constant(0u));
                           ir_expression *const r397A = expr(ir_unop_b2i, r3979);
                           ir_expression *const r397B = expr(ir_unop_i2u, r397A);
                           body.emit(assign(r3964, bit_or(r3964, r397B), 0x01));


                        body.instructions = f3969_parent_instructions;
                        body.emit(f3969);

                        /* END IF */

                        body.emit(assign(r394C, r3966, 0x01));

                        body.emit(assign(r394D, r3965, 0x01));

                        body.emit(assign(r394E, r3964, 0x01));

                        body.emit(assign(r394B, body.constant(int(0)), 0x01));

                        body.emit(assign(r3951, less(r3964, body.constant(0u)), 0x01));


                     body.instructions = f3960_parent_instructions;
                     body.emit(f3960);

                     /* END IF */


                  body.instructions = f395D_parent_instructions;
                  body.emit(f395D);

                  /* END IF */


               body.instructions = f3953_parent_instructions;
               body.emit(f3953);

               /* END IF */

               /* IF CONDITION */
               ir_if *f397C = new(mem_ctx) ir_if(operand(r394F).val);
               exec_list *const f397C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f397C->then_instructions;

                  /* IF CONDITION */
                  ir_if *f397D = new(mem_ctx) ir_if(operand(r3951).val);
                  exec_list *const f397D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f397D->then_instructions;

                     ir_variable *const r397E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r397E, add(r394D, body.constant(1u)), 0x01));

                     ir_expression *const r397F = less(r397E, r394D);
                     ir_expression *const r3980 = expr(ir_unop_b2i, r397F);
                     ir_expression *const r3981 = expr(ir_unop_i2u, r3980);
                     body.emit(assign(r394C, add(r394C, r3981), 0x01));

                     ir_expression *const r3982 = equal(r394E, body.constant(0u));
                     ir_expression *const r3983 = expr(ir_unop_b2i, r3982);
                     ir_expression *const r3984 = expr(ir_unop_i2u, r3983);
                     ir_expression *const r3985 = add(r394E, r3984);
                     ir_expression *const r3986 = bit_and(r3985, body.constant(1u));
                     ir_expression *const r3987 = expr(ir_unop_bit_not, r3986);
                     body.emit(assign(r394D, bit_and(r397E, r3987), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f397D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3989 = bit_or(r394C, r394D);
                     ir_expression *const r398A = equal(r3989, body.constant(0u));
                     ir_if *f3988 = new(mem_ctx) ir_if(operand(r398A).val);
                     exec_list *const f3988_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3988->then_instructions;

                        body.emit(assign(r394B, body.constant(int(0)), 0x01));


                     body.instructions = f3988_parent_instructions;
                     body.emit(f3988);

                     /* END IF */


                  body.instructions = f397D_parent_instructions;
                  body.emit(f397D);

                  /* END IF */

                  ir_variable *const r398B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r398B);
                  ir_expression *const r398C = lshift(r34C6, body.constant(int(31)));
                  ir_expression *const r398D = expr(ir_unop_i2u, r394B);
                  ir_expression *const r398E = lshift(r398D, body.constant(int(20)));
                  ir_expression *const r398F = add(r398C, r398E);
                  body.emit(assign(r398B, add(r398F, r394C), 0x02));

                  body.emit(assign(r398B, r394D, 0x01));

                  body.emit(assign(r3950, r398B, 0x03));

                  body.emit(assign(r394F, body.constant(false), 0x01));


               body.instructions = f397C_parent_instructions;
               body.emit(f397C);

               /* END IF */

               body.emit(assign(r3885, r3950, 0x03));

               body.emit(assign(r3884, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3949->else_instructions;

               body.emit(assign(r388B, add(r388B, body.constant(int(1))), 0x01));

               ir_variable *const r3990 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r3990);
               ir_variable *const r3991 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3991);
               ir_variable *const r3992 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3992);
               body.emit(assign(r3990, lshift(r3944, body.constant(int(31))), 0x01));

               ir_expression *const r3993 = lshift(r3943, body.constant(int(31)));
               ir_expression *const r3994 = rshift(r3944, body.constant(int(1)));
               body.emit(assign(r3991, bit_or(r3993, r3994), 0x01));

               body.emit(assign(r3992, rshift(r3943, body.constant(int(1))), 0x01));

               ir_expression *const r3995 = nequal(r388C, body.constant(0u));
               ir_expression *const r3996 = expr(ir_unop_b2i, r3995);
               ir_expression *const r3997 = expr(ir_unop_i2u, r3996);
               body.emit(assign(r3990, bit_or(r3990, r3997), 0x01));

               body.emit(assign(r388D, r3992, 0x01));

               body.emit(assign(r388C, r3990, 0x01));

               ir_variable *const r3998 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r3998, r388B, 0x01));

               ir_variable *const r3999 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r3999, r3992, 0x01));

               ir_variable *const r399A = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r399A, r3991, 0x01));

               ir_variable *const r399B = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r399B, r3990, 0x01));

               ir_variable *const r399C = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r399C, body.constant(true), 0x01));

               ir_variable *const r399D = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r399E = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r399E);
               ir_expression *const r399F = expr(ir_unop_u2i, r3990);
               body.emit(assign(r399E, less(r399F, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r39A1 = lequal(body.constant(int(2045)), r388B);
               ir_if *f39A0 = new(mem_ctx) ir_if(operand(r39A1).val);
               exec_list *const f39A0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f39A0->then_instructions;

                  ir_variable *const r39A2 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r39A4 = less(body.constant(int(2045)), r388B);
                  ir_if *f39A3 = new(mem_ctx) ir_if(operand(r39A4).val);
                  exec_list *const f39A3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f39A3->then_instructions;

                     body.emit(assign(r39A2, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f39A3->else_instructions;

                     ir_variable *const r39A5 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r39A7 = equal(r388B, body.constant(int(2045)));
                     ir_if *f39A6 = new(mem_ctx) ir_if(operand(r39A7).val);
                     exec_list *const f39A6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f39A6->then_instructions;

                        ir_expression *const r39A8 = equal(body.constant(2097151u), r3992);
                        ir_expression *const r39A9 = equal(body.constant(4294967295u), r3991);
                        body.emit(assign(r39A5, logic_and(r39A8, r39A9), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f39A6->else_instructions;

                        body.emit(assign(r39A5, body.constant(false), 0x01));


                     body.instructions = f39A6_parent_instructions;
                     body.emit(f39A6);

                     /* END IF */

                     body.emit(assign(r39A2, logic_and(r39A5, r399E), 0x01));


                  body.instructions = f39A3_parent_instructions;
                  body.emit(f39A3);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f39AA = new(mem_ctx) ir_if(operand(r39A2).val);
                  exec_list *const f39AA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f39AA->then_instructions;

                     ir_variable *const r39AB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r39AB);
                     ir_expression *const r39AC = lshift(r34C6, body.constant(int(31)));
                     body.emit(assign(r39AB, add(r39AC, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r39AB, body.constant(0u), 0x01));

                     body.emit(assign(r399D, r39AB, 0x03));

                     body.emit(assign(r399C, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f39AA->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r39AE = less(r388B, body.constant(int(0)));
                     ir_if *f39AD = new(mem_ctx) ir_if(operand(r39AE).val);
                     exec_list *const f39AD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f39AD->then_instructions;

                        ir_variable *const r39AF = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r39AF, r3990, 0x01));

                        ir_variable *const r39B0 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r39B0, neg(r388B), 0x01));

                        ir_variable *const r39B1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r39B1);
                        ir_variable *const r39B2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r39B2);
                        ir_variable *const r39B3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r39B3);
                        ir_variable *const r39B4 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r39B5 = neg(r39B0);
                        body.emit(assign(r39B4, bit_and(r39B5, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r39B7 = equal(r39B0, body.constant(int(0)));
                        ir_if *f39B6 = new(mem_ctx) ir_if(operand(r39B7).val);
                        exec_list *const f39B6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f39B6->then_instructions;

                           body.emit(assign(r39B1, r3990, 0x01));

                           body.emit(assign(r39B2, r3991, 0x01));

                           body.emit(assign(r39B3, r3992, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f39B6->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r39B9 = less(r39B0, body.constant(int(32)));
                           ir_if *f39B8 = new(mem_ctx) ir_if(operand(r39B9).val);
                           exec_list *const f39B8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f39B8->then_instructions;

                              body.emit(assign(r39B1, lshift(r3991, r39B4), 0x01));

                              ir_expression *const r39BA = lshift(r3992, r39B4);
                              ir_expression *const r39BB = rshift(r3991, r39B0);
                              body.emit(assign(r39B2, bit_or(r39BA, r39BB), 0x01));

                              body.emit(assign(r39B3, rshift(r3992, r39B0), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f39B8->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r39BD = equal(r39B0, body.constant(int(32)));
                              ir_if *f39BC = new(mem_ctx) ir_if(operand(r39BD).val);
                              exec_list *const f39BC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f39BC->then_instructions;

                                 body.emit(assign(r39B1, r3991, 0x01));

                                 body.emit(assign(r39B2, r3992, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f39BC->else_instructions;

                                 body.emit(assign(r39AF, bit_or(r3990, r3991), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r39BF = less(r39B0, body.constant(int(64)));
                                 ir_if *f39BE = new(mem_ctx) ir_if(operand(r39BF).val);
                                 exec_list *const f39BE_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f39BE->then_instructions;

                                    body.emit(assign(r39B1, lshift(r3992, r39B4), 0x01));

                                    ir_expression *const r39C0 = bit_and(r39B0, body.constant(int(31)));
                                    body.emit(assign(r39B2, rshift(r3992, r39C0), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f39BE->else_instructions;

                                    ir_variable *const r39C1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r39C3 = equal(r39B0, body.constant(int(64)));
                                    ir_if *f39C2 = new(mem_ctx) ir_if(operand(r39C3).val);
                                    exec_list *const f39C2_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f39C2->then_instructions;

                                       body.emit(assign(r39C1, r3992, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f39C2->else_instructions;

                                       ir_expression *const r39C4 = nequal(r3992, body.constant(0u));
                                       ir_expression *const r39C5 = expr(ir_unop_b2i, r39C4);
                                       body.emit(assign(r39C1, expr(ir_unop_i2u, r39C5), 0x01));


                                    body.instructions = f39C2_parent_instructions;
                                    body.emit(f39C2);

                                    /* END IF */

                                    body.emit(assign(r39B1, r39C1, 0x01));

                                    body.emit(assign(r39B2, body.constant(0u), 0x01));


                                 body.instructions = f39BE_parent_instructions;
                                 body.emit(f39BE);

                                 /* END IF */


                              body.instructions = f39BC_parent_instructions;
                              body.emit(f39BC);

                              /* END IF */

                              body.emit(assign(r39B3, body.constant(0u), 0x01));


                           body.instructions = f39B8_parent_instructions;
                           body.emit(f39B8);

                           /* END IF */

                           ir_expression *const r39C6 = nequal(r39AF, body.constant(0u));
                           ir_expression *const r39C7 = expr(ir_unop_b2i, r39C6);
                           ir_expression *const r39C8 = expr(ir_unop_i2u, r39C7);
                           body.emit(assign(r39B1, bit_or(r39B1, r39C8), 0x01));


                        body.instructions = f39B6_parent_instructions;
                        body.emit(f39B6);

                        /* END IF */

                        body.emit(assign(r3999, r39B3, 0x01));

                        body.emit(assign(r399A, r39B2, 0x01));

                        body.emit(assign(r399B, r39B1, 0x01));

                        body.emit(assign(r3998, body.constant(int(0)), 0x01));

                        body.emit(assign(r399E, less(r39B1, body.constant(0u)), 0x01));


                     body.instructions = f39AD_parent_instructions;
                     body.emit(f39AD);

                     /* END IF */


                  body.instructions = f39AA_parent_instructions;
                  body.emit(f39AA);

                  /* END IF */


               body.instructions = f39A0_parent_instructions;
               body.emit(f39A0);

               /* END IF */

               /* IF CONDITION */
               ir_if *f39C9 = new(mem_ctx) ir_if(operand(r399C).val);
               exec_list *const f39C9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f39C9->then_instructions;

                  /* IF CONDITION */
                  ir_if *f39CA = new(mem_ctx) ir_if(operand(r399E).val);
                  exec_list *const f39CA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f39CA->then_instructions;

                     ir_variable *const r39CB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r39CB, add(r399A, body.constant(1u)), 0x01));

                     ir_expression *const r39CC = less(r39CB, r399A);
                     ir_expression *const r39CD = expr(ir_unop_b2i, r39CC);
                     ir_expression *const r39CE = expr(ir_unop_i2u, r39CD);
                     body.emit(assign(r3999, add(r3999, r39CE), 0x01));

                     ir_expression *const r39CF = equal(r399B, body.constant(0u));
                     ir_expression *const r39D0 = expr(ir_unop_b2i, r39CF);
                     ir_expression *const r39D1 = expr(ir_unop_i2u, r39D0);
                     ir_expression *const r39D2 = add(r399B, r39D1);
                     ir_expression *const r39D3 = bit_and(r39D2, body.constant(1u));
                     ir_expression *const r39D4 = expr(ir_unop_bit_not, r39D3);
                     body.emit(assign(r399A, bit_and(r39CB, r39D4), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f39CA->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r39D6 = bit_or(r3999, r399A);
                     ir_expression *const r39D7 = equal(r39D6, body.constant(0u));
                     ir_if *f39D5 = new(mem_ctx) ir_if(operand(r39D7).val);
                     exec_list *const f39D5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f39D5->then_instructions;

                        body.emit(assign(r3998, body.constant(int(0)), 0x01));


                     body.instructions = f39D5_parent_instructions;
                     body.emit(f39D5);

                     /* END IF */


                  body.instructions = f39CA_parent_instructions;
                  body.emit(f39CA);

                  /* END IF */

                  ir_variable *const r39D8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r39D8);
                  ir_expression *const r39D9 = lshift(r34C6, body.constant(int(31)));
                  ir_expression *const r39DA = expr(ir_unop_i2u, r3998);
                  ir_expression *const r39DB = lshift(r39DA, body.constant(int(20)));
                  ir_expression *const r39DC = add(r39D9, r39DB);
                  body.emit(assign(r39D8, add(r39DC, r3999), 0x02));

                  body.emit(assign(r39D8, r399A, 0x01));

                  body.emit(assign(r399D, r39D8, 0x03));

                  body.emit(assign(r399C, body.constant(false), 0x01));


               body.instructions = f39C9_parent_instructions;
               body.emit(f39C9);

               /* END IF */

               body.emit(assign(r3885, r399D, 0x03));

               body.emit(assign(r3884, body.constant(false), 0x01));


            body.instructions = f3949_parent_instructions;
            body.emit(f3949);

            /* END IF */


         body.instructions = f3942_parent_instructions;
         body.emit(f3942);

         /* END IF */

         body.emit(assign(r34C5, r3885, 0x03));


      body.instructions = f34C7_parent_instructions;
      body.emit(f34C7);

      /* END IF */

      body.emit(assign(r34C3, r34C5, 0x03));


   body.instructions = f34C4_parent_instructions;
   body.emit(f34C4);

   /* END IF */

   ir_variable *const r39DD = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r39DD, body.constant(true), 0x01));

   ir_variable *const r39DE = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r39DF = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_auto);
   body.emit(r39DF);
   ir_variable *const r39E0 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
   body.emit(r39E0);
   ir_variable *const r39E1 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r39E1);
   ir_variable *const r39E2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
   body.emit(r39E2);
   ir_variable *const r39E3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
   body.emit(r39E3);
   ir_variable *const r39E4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
   body.emit(r39E4);
   ir_variable *const r39E5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
   body.emit(r39E5);
   ir_variable *const r39E6 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r39E6);
   ir_variable *const r39E7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
   body.emit(r39E7);
   ir_variable *const r39E8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r39E8);
   ir_variable *const r39E9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r39E9);
   body.emit(assign(r39E9, body.constant(0u), 0x01));

   body.emit(assign(r39E8, body.constant(0u), 0x01));

   body.emit(assign(r39E7, body.constant(0u), 0x01));

   ir_variable *const r39EA = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r39EA, swizzle_x(r321F), 0x01));

   body.emit(assign(r39E5, r39EA, 0x01));

   ir_variable *const r39EB = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r39EB, bit_and(swizzle_y(r321F), body.constant(1048575u)), 0x01));

   body.emit(assign(r39E4, r39EB, 0x01));

   ir_variable *const r39EC = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
   body.emit(assign(r39EC, swizzle_x(r34C3), 0x01));

   body.emit(assign(r39E3, r39EC, 0x01));

   ir_variable *const r39ED = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
   body.emit(assign(r39ED, bit_and(swizzle_y(r34C3), body.constant(1048575u)), 0x01));

   body.emit(assign(r39E2, r39ED, 0x01));

   ir_variable *const r39EE = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r39EF = rshift(swizzle_y(r321F), body.constant(int(20)));
   ir_expression *const r39F0 = bit_and(r39EF, body.constant(2047u));
   body.emit(assign(r39EE, expr(ir_unop_u2i, r39F0), 0x01));

   body.emit(assign(r39E1, r39EE, 0x01));

   ir_variable *const r39F1 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r39F2 = rshift(swizzle_y(r34C3), body.constant(int(20)));
   ir_expression *const r39F3 = bit_and(r39F2, body.constant(2047u));
   body.emit(assign(r39F1, expr(ir_unop_u2i, r39F3), 0x01));

   body.emit(assign(r39E0, r39F1, 0x01));

   ir_expression *const r39F4 = rshift(swizzle_y(r321F), body.constant(int(31)));
   ir_expression *const r39F5 = rshift(swizzle_y(r34C3), body.constant(int(31)));
   body.emit(assign(r39DF, bit_xor(r39F4, r39F5), 0x01));

   /* IF CONDITION */
   ir_expression *const r39F7 = equal(r39EE, body.constant(int(2047)));
   ir_if *f39F6 = new(mem_ctx) ir_if(operand(r39F7).val);
   exec_list *const f39F6_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f39F6->then_instructions;

      /* IF CONDITION */
      ir_expression *const r39F9 = bit_or(r39EB, swizzle_x(r321F));
      ir_expression *const r39FA = nequal(r39F9, body.constant(0u));
      ir_expression *const r39FB = equal(r39F1, body.constant(int(2047)));
      ir_expression *const r39FC = bit_or(r39ED, swizzle_x(r34C3));
      ir_expression *const r39FD = nequal(r39FC, body.constant(0u));
      ir_expression *const r39FE = logic_and(r39FB, r39FD);
      ir_expression *const r39FF = logic_or(r39FA, r39FE);
      ir_if *f39F8 = new(mem_ctx) ir_if(operand(r39FF).val);
      exec_list *const f39F8_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f39F8->then_instructions;

         ir_variable *const r3A00 = body.make_temp(glsl_type::uvec2_type, "a");
         body.emit(assign(r3A00, swizzle_x(r321F), 0x01));

         ir_variable *const r3A01 = body.make_temp(glsl_type::uvec2_type, "b");
         body.emit(assign(r3A01, swizzle_x(r34C3), 0x01));

         ir_variable *const r3A02 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r3A03 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
         ir_expression *const r3A04 = rshift(swizzle_y(r321F), body.constant(int(19)));
         ir_expression *const r3A05 = bit_and(r3A04, body.constant(4095u));
         ir_expression *const r3A06 = equal(r3A05, body.constant(4094u));
         ir_expression *const r3A07 = nequal(swizzle_x(r321F), body.constant(0u));
         ir_expression *const r3A08 = bit_and(swizzle_y(r321F), body.constant(524287u));
         ir_expression *const r3A09 = nequal(r3A08, body.constant(0u));
         ir_expression *const r3A0A = logic_or(r3A07, r3A09);
         body.emit(assign(r3A03, logic_and(r3A06, r3A0A), 0x01));

         ir_variable *const r3A0B = body.make_temp(glsl_type::bool_type, "is_nan_retval");
         ir_expression *const r3A0C = lshift(swizzle_y(r34C3), body.constant(int(1)));
         ir_expression *const r3A0D = lequal(body.constant(4292870144u), r3A0C);
         ir_expression *const r3A0E = nequal(swizzle_x(r34C3), body.constant(0u));
         ir_expression *const r3A0F = bit_and(swizzle_y(r34C3), body.constant(1048575u));
         ir_expression *const r3A10 = nequal(r3A0F, body.constant(0u));
         ir_expression *const r3A11 = logic_or(r3A0E, r3A10);
         body.emit(assign(r3A0B, logic_and(r3A0D, r3A11), 0x01));

         body.emit(assign(r3A00, bit_or(swizzle_y(r321F), body.constant(524288u)), 0x02));

         body.emit(assign(r3A01, bit_or(swizzle_y(r34C3), body.constant(524288u)), 0x02));

         /* IF CONDITION */
         ir_expression *const r3A13 = lshift(swizzle_y(r321F), body.constant(int(1)));
         ir_expression *const r3A14 = lequal(body.constant(4292870144u), r3A13);
         ir_expression *const r3A15 = nequal(swizzle_x(r321F), body.constant(0u));
         ir_expression *const r3A16 = bit_and(swizzle_y(r321F), body.constant(1048575u));
         ir_expression *const r3A17 = nequal(r3A16, body.constant(0u));
         ir_expression *const r3A18 = logic_or(r3A15, r3A17);
         ir_expression *const r3A19 = logic_and(r3A14, r3A18);
         ir_if *f3A12 = new(mem_ctx) ir_if(operand(r3A19).val);
         exec_list *const f3A12_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3A12->then_instructions;

            ir_variable *const r3A1A = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r3A1C = logic_and(r3A03, r3A0B);
            ir_if *f3A1B = new(mem_ctx) ir_if(operand(r3A1C).val);
            exec_list *const f3A1B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3A1B->then_instructions;

               body.emit(assign(r3A1A, r3A01, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3A1B->else_instructions;

               body.emit(assign(r3A1A, r3A00, 0x03));


            body.instructions = f3A1B_parent_instructions;
            body.emit(f3A1B);

            /* END IF */

            body.emit(assign(r3A02, r3A1A, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3A12->else_instructions;

            body.emit(assign(r3A02, r3A01, 0x03));


         body.instructions = f3A12_parent_instructions;
         body.emit(f3A12);

         /* END IF */

         body.emit(assign(r39DE, r3A02, 0x03));

         body.emit(assign(r39DD, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f39F8->else_instructions;

         /* IF CONDITION */
         ir_expression *const r3A1E = expr(ir_unop_i2u, r39F1);
         ir_expression *const r3A1F = bit_or(r3A1E, r39ED);
         ir_expression *const r3A20 = bit_or(r3A1F, swizzle_x(r34C3));
         ir_expression *const r3A21 = equal(r3A20, body.constant(0u));
         ir_if *f3A1D = new(mem_ctx) ir_if(operand(r3A21).val);
         exec_list *const f3A1D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3A1D->then_instructions;

            ir_constant_data r3A22_data;
            memset(&r3A22_data, 0, sizeof(ir_constant_data));
            r3A22_data.u[0] = 4294967295;
            r3A22_data.u[1] = 4294967295;
            ir_constant *const r3A22 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r3A22_data);
            body.emit(assign(r39DE, r3A22, 0x03));

            body.emit(assign(r39DD, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3A1D->else_instructions;

            ir_variable *const r3A23 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r3A23);
            ir_expression *const r3A24 = lshift(r39DF, body.constant(int(31)));
            body.emit(assign(r3A23, add(r3A24, body.constant(2146435072u)), 0x02));

            body.emit(assign(r3A23, body.constant(0u), 0x01));

            body.emit(assign(r39DE, r3A23, 0x03));

            body.emit(assign(r39DD, body.constant(false), 0x01));


         body.instructions = f3A1D_parent_instructions;
         body.emit(f3A1D);

         /* END IF */


      body.instructions = f39F8_parent_instructions;
      body.emit(f39F8);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f39F6->else_instructions;

      /* IF CONDITION */
      ir_expression *const r3A26 = equal(r39F1, body.constant(int(2047)));
      ir_if *f3A25 = new(mem_ctx) ir_if(operand(r3A26).val);
      exec_list *const f3A25_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f3A25->then_instructions;

         /* IF CONDITION */
         ir_expression *const r3A28 = bit_or(r39ED, swizzle_x(r34C3));
         ir_expression *const r3A29 = nequal(r3A28, body.constant(0u));
         ir_if *f3A27 = new(mem_ctx) ir_if(operand(r3A29).val);
         exec_list *const f3A27_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3A27->then_instructions;

            ir_variable *const r3A2A = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r3A2A, swizzle_x(r321F), 0x01));

            ir_variable *const r3A2B = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r3A2B, swizzle_x(r34C3), 0x01));

            ir_variable *const r3A2C = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r3A2D = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r3A2E = rshift(swizzle_y(r321F), body.constant(int(19)));
            ir_expression *const r3A2F = bit_and(r3A2E, body.constant(4095u));
            ir_expression *const r3A30 = equal(r3A2F, body.constant(4094u));
            ir_expression *const r3A31 = nequal(swizzle_x(r321F), body.constant(0u));
            ir_expression *const r3A32 = bit_and(swizzle_y(r321F), body.constant(524287u));
            ir_expression *const r3A33 = nequal(r3A32, body.constant(0u));
            ir_expression *const r3A34 = logic_or(r3A31, r3A33);
            body.emit(assign(r3A2D, logic_and(r3A30, r3A34), 0x01));

            ir_variable *const r3A35 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r3A36 = lshift(swizzle_y(r34C3), body.constant(int(1)));
            ir_expression *const r3A37 = lequal(body.constant(4292870144u), r3A36);
            ir_expression *const r3A38 = nequal(swizzle_x(r34C3), body.constant(0u));
            ir_expression *const r3A39 = bit_and(swizzle_y(r34C3), body.constant(1048575u));
            ir_expression *const r3A3A = nequal(r3A39, body.constant(0u));
            ir_expression *const r3A3B = logic_or(r3A38, r3A3A);
            body.emit(assign(r3A35, logic_and(r3A37, r3A3B), 0x01));

            body.emit(assign(r3A2A, bit_or(swizzle_y(r321F), body.constant(524288u)), 0x02));

            body.emit(assign(r3A2B, bit_or(swizzle_y(r34C3), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r3A3D = lshift(swizzle_y(r321F), body.constant(int(1)));
            ir_expression *const r3A3E = lequal(body.constant(4292870144u), r3A3D);
            ir_expression *const r3A3F = nequal(swizzle_x(r321F), body.constant(0u));
            ir_expression *const r3A40 = bit_and(swizzle_y(r321F), body.constant(1048575u));
            ir_expression *const r3A41 = nequal(r3A40, body.constant(0u));
            ir_expression *const r3A42 = logic_or(r3A3F, r3A41);
            ir_expression *const r3A43 = logic_and(r3A3E, r3A42);
            ir_if *f3A3C = new(mem_ctx) ir_if(operand(r3A43).val);
            exec_list *const f3A3C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3A3C->then_instructions;

               ir_variable *const r3A44 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r3A46 = logic_and(r3A2D, r3A35);
               ir_if *f3A45 = new(mem_ctx) ir_if(operand(r3A46).val);
               exec_list *const f3A45_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3A45->then_instructions;

                  body.emit(assign(r3A44, r3A2B, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3A45->else_instructions;

                  body.emit(assign(r3A44, r3A2A, 0x03));


               body.instructions = f3A45_parent_instructions;
               body.emit(f3A45);

               /* END IF */

               body.emit(assign(r3A2C, r3A44, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3A3C->else_instructions;

               body.emit(assign(r3A2C, r3A2B, 0x03));


            body.instructions = f3A3C_parent_instructions;
            body.emit(f3A3C);

            /* END IF */

            body.emit(assign(r39DE, r3A2C, 0x03));

            body.emit(assign(r39DD, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3A27->else_instructions;

            /* IF CONDITION */
            ir_expression *const r3A48 = expr(ir_unop_i2u, r39EE);
            ir_expression *const r3A49 = bit_or(r3A48, r39EB);
            ir_expression *const r3A4A = bit_or(r3A49, swizzle_x(r321F));
            ir_expression *const r3A4B = equal(r3A4A, body.constant(0u));
            ir_if *f3A47 = new(mem_ctx) ir_if(operand(r3A4B).val);
            exec_list *const f3A47_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3A47->then_instructions;

               ir_constant_data r3A4C_data;
               memset(&r3A4C_data, 0, sizeof(ir_constant_data));
               r3A4C_data.u[0] = 4294967295;
               r3A4C_data.u[1] = 4294967295;
               ir_constant *const r3A4C = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r3A4C_data);
               body.emit(assign(r39DE, r3A4C, 0x03));

               body.emit(assign(r39DD, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3A47->else_instructions;

               ir_variable *const r3A4D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r3A4D);
               ir_expression *const r3A4E = lshift(r39DF, body.constant(int(31)));
               body.emit(assign(r3A4D, add(r3A4E, body.constant(2146435072u)), 0x02));

               body.emit(assign(r3A4D, body.constant(0u), 0x01));

               body.emit(assign(r39DE, r3A4D, 0x03));

               body.emit(assign(r39DD, body.constant(false), 0x01));


            body.instructions = f3A47_parent_instructions;
            body.emit(f3A47);

            /* END IF */


         body.instructions = f3A27_parent_instructions;
         body.emit(f3A27);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f3A25->else_instructions;

         /* IF CONDITION */
         ir_expression *const r3A50 = equal(r39EE, body.constant(int(0)));
         ir_if *f3A4F = new(mem_ctx) ir_if(operand(r3A50).val);
         exec_list *const f3A4F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3A4F->then_instructions;

            /* IF CONDITION */
            ir_expression *const r3A52 = bit_or(r39EB, swizzle_x(r321F));
            ir_expression *const r3A53 = equal(r3A52, body.constant(0u));
            ir_if *f3A51 = new(mem_ctx) ir_if(operand(r3A53).val);
            exec_list *const f3A51_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3A51->then_instructions;

               ir_variable *const r3A54 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r3A54);
               body.emit(assign(r3A54, lshift(r39DF, body.constant(int(31))), 0x02));

               body.emit(assign(r3A54, body.constant(0u), 0x01));

               body.emit(assign(r39DE, r3A54, 0x03));

               body.emit(assign(r39DD, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3A51->else_instructions;

               ir_variable *const r3A55 = body.make_temp(glsl_type::int_type, "zExpPtr");
               body.emit(assign(r3A55, r39EE, 0x01));

               ir_variable *const r3A56 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
               body.emit(assign(r3A56, r39EB, 0x01));

               ir_variable *const r3A57 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
               body.emit(assign(r3A57, r39EA, 0x01));

               ir_variable *const r3A58 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r3A58);
               /* IF CONDITION */
               ir_expression *const r3A5A = equal(r39EB, body.constant(0u));
               ir_if *f3A59 = new(mem_ctx) ir_if(operand(r3A5A).val);
               exec_list *const f3A59_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3A59->then_instructions;

                  ir_variable *const r3A5B = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r3A5B, r39EA, 0x01));

                  ir_variable *const r3A5C = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r3A5D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r3A5D);
                  /* IF CONDITION */
                  ir_expression *const r3A5F = equal(swizzle_x(r321F), body.constant(0u));
                  ir_if *f3A5E = new(mem_ctx) ir_if(operand(r3A5F).val);
                  exec_list *const f3A5E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3A5E->then_instructions;

                     body.emit(assign(r3A5C, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3A5E->else_instructions;

                     body.emit(assign(r3A5D, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3A61 = bit_and(swizzle_x(r321F), body.constant(4294901760u));
                     ir_expression *const r3A62 = equal(r3A61, body.constant(0u));
                     ir_if *f3A60 = new(mem_ctx) ir_if(operand(r3A62).val);
                     exec_list *const f3A60_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3A60->then_instructions;

                        body.emit(assign(r3A5D, body.constant(int(16)), 0x01));

                        body.emit(assign(r3A5B, lshift(swizzle_x(r321F), body.constant(int(16))), 0x01));


                     body.instructions = f3A60_parent_instructions;
                     body.emit(f3A60);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3A64 = bit_and(r3A5B, body.constant(4278190080u));
                     ir_expression *const r3A65 = equal(r3A64, body.constant(0u));
                     ir_if *f3A63 = new(mem_ctx) ir_if(operand(r3A65).val);
                     exec_list *const f3A63_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3A63->then_instructions;

                        body.emit(assign(r3A5D, add(r3A5D, body.constant(int(8))), 0x01));

                        body.emit(assign(r3A5B, lshift(r3A5B, body.constant(int(8))), 0x01));


                     body.instructions = f3A63_parent_instructions;
                     body.emit(f3A63);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3A67 = bit_and(r3A5B, body.constant(4026531840u));
                     ir_expression *const r3A68 = equal(r3A67, body.constant(0u));
                     ir_if *f3A66 = new(mem_ctx) ir_if(operand(r3A68).val);
                     exec_list *const f3A66_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3A66->then_instructions;

                        body.emit(assign(r3A5D, add(r3A5D, body.constant(int(4))), 0x01));

                        body.emit(assign(r3A5B, lshift(r3A5B, body.constant(int(4))), 0x01));


                     body.instructions = f3A66_parent_instructions;
                     body.emit(f3A66);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3A6A = bit_and(r3A5B, body.constant(3221225472u));
                     ir_expression *const r3A6B = equal(r3A6A, body.constant(0u));
                     ir_if *f3A69 = new(mem_ctx) ir_if(operand(r3A6B).val);
                     exec_list *const f3A69_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3A69->then_instructions;

                        body.emit(assign(r3A5D, add(r3A5D, body.constant(int(2))), 0x01));

                        body.emit(assign(r3A5B, lshift(r3A5B, body.constant(int(2))), 0x01));


                     body.instructions = f3A69_parent_instructions;
                     body.emit(f3A69);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3A6D = bit_and(r3A5B, body.constant(2147483648u));
                     ir_expression *const r3A6E = equal(r3A6D, body.constant(0u));
                     ir_if *f3A6C = new(mem_ctx) ir_if(operand(r3A6E).val);
                     exec_list *const f3A6C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3A6C->then_instructions;

                        body.emit(assign(r3A5D, add(r3A5D, body.constant(int(1))), 0x01));


                     body.instructions = f3A6C_parent_instructions;
                     body.emit(f3A6C);

                     /* END IF */

                     body.emit(assign(r3A5C, r3A5D, 0x01));


                  body.instructions = f3A5E_parent_instructions;
                  body.emit(f3A5E);

                  /* END IF */

                  body.emit(assign(r3A58, add(r3A5C, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3A70 = less(r3A58, body.constant(int(0)));
                  ir_if *f3A6F = new(mem_ctx) ir_if(operand(r3A70).val);
                  exec_list *const f3A6F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3A6F->then_instructions;

                     ir_expression *const r3A71 = neg(r3A58);
                     body.emit(assign(r3A56, rshift(swizzle_x(r321F), r3A71), 0x01));

                     ir_expression *const r3A72 = bit_and(r3A58, body.constant(int(31)));
                     body.emit(assign(r3A57, lshift(swizzle_x(r321F), r3A72), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3A6F->else_instructions;

                     body.emit(assign(r3A56, lshift(swizzle_x(r321F), r3A58), 0x01));

                     body.emit(assign(r3A57, body.constant(0u), 0x01));


                  body.instructions = f3A6F_parent_instructions;
                  body.emit(f3A6F);

                  /* END IF */

                  body.emit(assign(r3A55, sub(body.constant(int(-31)), r3A58), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3A59->else_instructions;

                  ir_variable *const r3A73 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r3A73, r39EB, 0x01));

                  ir_variable *const r3A74 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r3A75 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r3A75);
                  /* IF CONDITION */
                  ir_expression *const r3A77 = equal(r39EB, body.constant(0u));
                  ir_if *f3A76 = new(mem_ctx) ir_if(operand(r3A77).val);
                  exec_list *const f3A76_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3A76->then_instructions;

                     body.emit(assign(r3A74, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3A76->else_instructions;

                     body.emit(assign(r3A75, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3A79 = bit_and(r39EB, body.constant(4294901760u));
                     ir_expression *const r3A7A = equal(r3A79, body.constant(0u));
                     ir_if *f3A78 = new(mem_ctx) ir_if(operand(r3A7A).val);
                     exec_list *const f3A78_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3A78->then_instructions;

                        body.emit(assign(r3A75, body.constant(int(16)), 0x01));

                        body.emit(assign(r3A73, lshift(r39EB, body.constant(int(16))), 0x01));


                     body.instructions = f3A78_parent_instructions;
                     body.emit(f3A78);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3A7C = bit_and(r3A73, body.constant(4278190080u));
                     ir_expression *const r3A7D = equal(r3A7C, body.constant(0u));
                     ir_if *f3A7B = new(mem_ctx) ir_if(operand(r3A7D).val);
                     exec_list *const f3A7B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3A7B->then_instructions;

                        body.emit(assign(r3A75, add(r3A75, body.constant(int(8))), 0x01));

                        body.emit(assign(r3A73, lshift(r3A73, body.constant(int(8))), 0x01));


                     body.instructions = f3A7B_parent_instructions;
                     body.emit(f3A7B);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3A7F = bit_and(r3A73, body.constant(4026531840u));
                     ir_expression *const r3A80 = equal(r3A7F, body.constant(0u));
                     ir_if *f3A7E = new(mem_ctx) ir_if(operand(r3A80).val);
                     exec_list *const f3A7E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3A7E->then_instructions;

                        body.emit(assign(r3A75, add(r3A75, body.constant(int(4))), 0x01));

                        body.emit(assign(r3A73, lshift(r3A73, body.constant(int(4))), 0x01));


                     body.instructions = f3A7E_parent_instructions;
                     body.emit(f3A7E);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3A82 = bit_and(r3A73, body.constant(3221225472u));
                     ir_expression *const r3A83 = equal(r3A82, body.constant(0u));
                     ir_if *f3A81 = new(mem_ctx) ir_if(operand(r3A83).val);
                     exec_list *const f3A81_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3A81->then_instructions;

                        body.emit(assign(r3A75, add(r3A75, body.constant(int(2))), 0x01));

                        body.emit(assign(r3A73, lshift(r3A73, body.constant(int(2))), 0x01));


                     body.instructions = f3A81_parent_instructions;
                     body.emit(f3A81);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3A85 = bit_and(r3A73, body.constant(2147483648u));
                     ir_expression *const r3A86 = equal(r3A85, body.constant(0u));
                     ir_if *f3A84 = new(mem_ctx) ir_if(operand(r3A86).val);
                     exec_list *const f3A84_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3A84->then_instructions;

                        body.emit(assign(r3A75, add(r3A75, body.constant(int(1))), 0x01));


                     body.instructions = f3A84_parent_instructions;
                     body.emit(f3A84);

                     /* END IF */

                     body.emit(assign(r3A74, r3A75, 0x01));


                  body.instructions = f3A76_parent_instructions;
                  body.emit(f3A76);

                  /* END IF */

                  body.emit(assign(r3A58, add(r3A74, body.constant(int(-11))), 0x01));

                  ir_variable *const r3A87 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r3A87, lshift(swizzle_x(r321F), r3A58), 0x01));

                  ir_variable *const r3A88 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3A8A = equal(r3A58, body.constant(int(0)));
                  ir_if *f3A89 = new(mem_ctx) ir_if(operand(r3A8A).val);
                  exec_list *const f3A89_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3A89->then_instructions;

                     body.emit(assign(r3A88, r39EB, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3A89->else_instructions;

                     ir_expression *const r3A8B = lshift(r39EB, r3A58);
                     ir_expression *const r3A8C = neg(r3A58);
                     ir_expression *const r3A8D = bit_and(r3A8C, body.constant(int(31)));
                     ir_expression *const r3A8E = rshift(swizzle_x(r321F), r3A8D);
                     body.emit(assign(r3A88, bit_or(r3A8B, r3A8E), 0x01));


                  body.instructions = f3A89_parent_instructions;
                  body.emit(f3A89);

                  /* END IF */

                  body.emit(assign(r3A56, r3A88, 0x01));

                  body.emit(assign(r3A57, r3A87, 0x01));

                  body.emit(assign(r3A55, sub(body.constant(int(1)), r3A58), 0x01));


               body.instructions = f3A59_parent_instructions;
               body.emit(f3A59);

               /* END IF */

               body.emit(assign(r39E1, r3A55, 0x01));

               body.emit(assign(r39E4, r3A56, 0x01));

               body.emit(assign(r39E5, r3A57, 0x01));


            body.instructions = f3A51_parent_instructions;
            body.emit(f3A51);

            /* END IF */


         body.instructions = f3A4F_parent_instructions;
         body.emit(f3A4F);

         /* END IF */

         /* IF CONDITION */
         ir_if *f3A8F = new(mem_ctx) ir_if(operand(r39DD).val);
         exec_list *const f3A8F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3A8F->then_instructions;

            /* IF CONDITION */
            ir_expression *const r3A91 = equal(r39F1, body.constant(int(0)));
            ir_if *f3A90 = new(mem_ctx) ir_if(operand(r3A91).val);
            exec_list *const f3A90_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3A90->then_instructions;

               /* IF CONDITION */
               ir_expression *const r3A93 = bit_or(r39ED, swizzle_x(r34C3));
               ir_expression *const r3A94 = equal(r3A93, body.constant(0u));
               ir_if *f3A92 = new(mem_ctx) ir_if(operand(r3A94).val);
               exec_list *const f3A92_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3A92->then_instructions;

                  ir_variable *const r3A95 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3A95);
                  body.emit(assign(r3A95, lshift(r39DF, body.constant(int(31))), 0x02));

                  body.emit(assign(r3A95, body.constant(0u), 0x01));

                  body.emit(assign(r39DE, r3A95, 0x03));

                  body.emit(assign(r39DD, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3A92->else_instructions;

                  ir_variable *const r3A96 = body.make_temp(glsl_type::int_type, "zExpPtr");
                  body.emit(assign(r3A96, r39F1, 0x01));

                  ir_variable *const r3A97 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
                  body.emit(assign(r3A97, r39ED, 0x01));

                  ir_variable *const r3A98 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
                  body.emit(assign(r3A98, r39EC, 0x01));

                  ir_variable *const r3A99 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r3A99);
                  /* IF CONDITION */
                  ir_expression *const r3A9B = equal(r39ED, body.constant(0u));
                  ir_if *f3A9A = new(mem_ctx) ir_if(operand(r3A9B).val);
                  exec_list *const f3A9A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3A9A->then_instructions;

                     ir_variable *const r3A9C = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r3A9C, r39EC, 0x01));

                     ir_variable *const r3A9D = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r3A9E = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r3A9E);
                     /* IF CONDITION */
                     ir_expression *const r3AA0 = equal(swizzle_x(r34C3), body.constant(0u));
                     ir_if *f3A9F = new(mem_ctx) ir_if(operand(r3AA0).val);
                     exec_list *const f3A9F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3A9F->then_instructions;

                        body.emit(assign(r3A9D, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3A9F->else_instructions;

                        body.emit(assign(r3A9E, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3AA2 = bit_and(swizzle_x(r34C3), body.constant(4294901760u));
                        ir_expression *const r3AA3 = equal(r3AA2, body.constant(0u));
                        ir_if *f3AA1 = new(mem_ctx) ir_if(operand(r3AA3).val);
                        exec_list *const f3AA1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3AA1->then_instructions;

                           body.emit(assign(r3A9E, body.constant(int(16)), 0x01));

                           body.emit(assign(r3A9C, lshift(swizzle_x(r34C3), body.constant(int(16))), 0x01));


                        body.instructions = f3AA1_parent_instructions;
                        body.emit(f3AA1);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3AA5 = bit_and(r3A9C, body.constant(4278190080u));
                        ir_expression *const r3AA6 = equal(r3AA5, body.constant(0u));
                        ir_if *f3AA4 = new(mem_ctx) ir_if(operand(r3AA6).val);
                        exec_list *const f3AA4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3AA4->then_instructions;

                           body.emit(assign(r3A9E, add(r3A9E, body.constant(int(8))), 0x01));

                           body.emit(assign(r3A9C, lshift(r3A9C, body.constant(int(8))), 0x01));


                        body.instructions = f3AA4_parent_instructions;
                        body.emit(f3AA4);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3AA8 = bit_and(r3A9C, body.constant(4026531840u));
                        ir_expression *const r3AA9 = equal(r3AA8, body.constant(0u));
                        ir_if *f3AA7 = new(mem_ctx) ir_if(operand(r3AA9).val);
                        exec_list *const f3AA7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3AA7->then_instructions;

                           body.emit(assign(r3A9E, add(r3A9E, body.constant(int(4))), 0x01));

                           body.emit(assign(r3A9C, lshift(r3A9C, body.constant(int(4))), 0x01));


                        body.instructions = f3AA7_parent_instructions;
                        body.emit(f3AA7);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3AAB = bit_and(r3A9C, body.constant(3221225472u));
                        ir_expression *const r3AAC = equal(r3AAB, body.constant(0u));
                        ir_if *f3AAA = new(mem_ctx) ir_if(operand(r3AAC).val);
                        exec_list *const f3AAA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3AAA->then_instructions;

                           body.emit(assign(r3A9E, add(r3A9E, body.constant(int(2))), 0x01));

                           body.emit(assign(r3A9C, lshift(r3A9C, body.constant(int(2))), 0x01));


                        body.instructions = f3AAA_parent_instructions;
                        body.emit(f3AAA);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3AAE = bit_and(r3A9C, body.constant(2147483648u));
                        ir_expression *const r3AAF = equal(r3AAE, body.constant(0u));
                        ir_if *f3AAD = new(mem_ctx) ir_if(operand(r3AAF).val);
                        exec_list *const f3AAD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3AAD->then_instructions;

                           body.emit(assign(r3A9E, add(r3A9E, body.constant(int(1))), 0x01));


                        body.instructions = f3AAD_parent_instructions;
                        body.emit(f3AAD);

                        /* END IF */

                        body.emit(assign(r3A9D, r3A9E, 0x01));


                     body.instructions = f3A9F_parent_instructions;
                     body.emit(f3A9F);

                     /* END IF */

                     body.emit(assign(r3A99, add(r3A9D, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3AB1 = less(r3A99, body.constant(int(0)));
                     ir_if *f3AB0 = new(mem_ctx) ir_if(operand(r3AB1).val);
                     exec_list *const f3AB0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3AB0->then_instructions;

                        ir_expression *const r3AB2 = neg(r3A99);
                        body.emit(assign(r3A97, rshift(swizzle_x(r34C3), r3AB2), 0x01));

                        ir_expression *const r3AB3 = bit_and(r3A99, body.constant(int(31)));
                        body.emit(assign(r3A98, lshift(swizzle_x(r34C3), r3AB3), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3AB0->else_instructions;

                        body.emit(assign(r3A97, lshift(swizzle_x(r34C3), r3A99), 0x01));

                        body.emit(assign(r3A98, body.constant(0u), 0x01));


                     body.instructions = f3AB0_parent_instructions;
                     body.emit(f3AB0);

                     /* END IF */

                     body.emit(assign(r3A96, sub(body.constant(int(-31)), r3A99), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3A9A->else_instructions;

                     ir_variable *const r3AB4 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r3AB4, r39ED, 0x01));

                     ir_variable *const r3AB5 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r3AB6 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r3AB6);
                     /* IF CONDITION */
                     ir_expression *const r3AB8 = equal(r39ED, body.constant(0u));
                     ir_if *f3AB7 = new(mem_ctx) ir_if(operand(r3AB8).val);
                     exec_list *const f3AB7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3AB7->then_instructions;

                        body.emit(assign(r3AB5, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3AB7->else_instructions;

                        body.emit(assign(r3AB6, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3ABA = bit_and(r39ED, body.constant(4294901760u));
                        ir_expression *const r3ABB = equal(r3ABA, body.constant(0u));
                        ir_if *f3AB9 = new(mem_ctx) ir_if(operand(r3ABB).val);
                        exec_list *const f3AB9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3AB9->then_instructions;

                           body.emit(assign(r3AB6, body.constant(int(16)), 0x01));

                           body.emit(assign(r3AB4, lshift(r39ED, body.constant(int(16))), 0x01));


                        body.instructions = f3AB9_parent_instructions;
                        body.emit(f3AB9);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3ABD = bit_and(r3AB4, body.constant(4278190080u));
                        ir_expression *const r3ABE = equal(r3ABD, body.constant(0u));
                        ir_if *f3ABC = new(mem_ctx) ir_if(operand(r3ABE).val);
                        exec_list *const f3ABC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3ABC->then_instructions;

                           body.emit(assign(r3AB6, add(r3AB6, body.constant(int(8))), 0x01));

                           body.emit(assign(r3AB4, lshift(r3AB4, body.constant(int(8))), 0x01));


                        body.instructions = f3ABC_parent_instructions;
                        body.emit(f3ABC);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3AC0 = bit_and(r3AB4, body.constant(4026531840u));
                        ir_expression *const r3AC1 = equal(r3AC0, body.constant(0u));
                        ir_if *f3ABF = new(mem_ctx) ir_if(operand(r3AC1).val);
                        exec_list *const f3ABF_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3ABF->then_instructions;

                           body.emit(assign(r3AB6, add(r3AB6, body.constant(int(4))), 0x01));

                           body.emit(assign(r3AB4, lshift(r3AB4, body.constant(int(4))), 0x01));


                        body.instructions = f3ABF_parent_instructions;
                        body.emit(f3ABF);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3AC3 = bit_and(r3AB4, body.constant(3221225472u));
                        ir_expression *const r3AC4 = equal(r3AC3, body.constant(0u));
                        ir_if *f3AC2 = new(mem_ctx) ir_if(operand(r3AC4).val);
                        exec_list *const f3AC2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3AC2->then_instructions;

                           body.emit(assign(r3AB6, add(r3AB6, body.constant(int(2))), 0x01));

                           body.emit(assign(r3AB4, lshift(r3AB4, body.constant(int(2))), 0x01));


                        body.instructions = f3AC2_parent_instructions;
                        body.emit(f3AC2);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3AC6 = bit_and(r3AB4, body.constant(2147483648u));
                        ir_expression *const r3AC7 = equal(r3AC6, body.constant(0u));
                        ir_if *f3AC5 = new(mem_ctx) ir_if(operand(r3AC7).val);
                        exec_list *const f3AC5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3AC5->then_instructions;

                           body.emit(assign(r3AB6, add(r3AB6, body.constant(int(1))), 0x01));


                        body.instructions = f3AC5_parent_instructions;
                        body.emit(f3AC5);

                        /* END IF */

                        body.emit(assign(r3AB5, r3AB6, 0x01));


                     body.instructions = f3AB7_parent_instructions;
                     body.emit(f3AB7);

                     /* END IF */

                     body.emit(assign(r3A99, add(r3AB5, body.constant(int(-11))), 0x01));

                     ir_variable *const r3AC8 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r3AC8, lshift(swizzle_x(r34C3), r3A99), 0x01));

                     ir_variable *const r3AC9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3ACB = equal(r3A99, body.constant(int(0)));
                     ir_if *f3ACA = new(mem_ctx) ir_if(operand(r3ACB).val);
                     exec_list *const f3ACA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3ACA->then_instructions;

                        body.emit(assign(r3AC9, r39ED, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3ACA->else_instructions;

                        ir_expression *const r3ACC = lshift(r39ED, r3A99);
                        ir_expression *const r3ACD = neg(r3A99);
                        ir_expression *const r3ACE = bit_and(r3ACD, body.constant(int(31)));
                        ir_expression *const r3ACF = rshift(swizzle_x(r34C3), r3ACE);
                        body.emit(assign(r3AC9, bit_or(r3ACC, r3ACF), 0x01));


                     body.instructions = f3ACA_parent_instructions;
                     body.emit(f3ACA);

                     /* END IF */

                     body.emit(assign(r3A97, r3AC9, 0x01));

                     body.emit(assign(r3A98, r3AC8, 0x01));

                     body.emit(assign(r3A96, sub(body.constant(int(1)), r3A99), 0x01));


                  body.instructions = f3A9A_parent_instructions;
                  body.emit(f3A9A);

                  /* END IF */

                  body.emit(assign(r39E0, r3A96, 0x01));

                  body.emit(assign(r39E2, r3A97, 0x01));

                  body.emit(assign(r39E3, r3A98, 0x01));


               body.instructions = f3A92_parent_instructions;
               body.emit(f3A92);

               /* END IF */


            body.instructions = f3A90_parent_instructions;
            body.emit(f3A90);

            /* END IF */

            /* IF CONDITION */
            ir_if *f3AD0 = new(mem_ctx) ir_if(operand(r39DD).val);
            exec_list *const f3AD0_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3AD0->then_instructions;

               ir_expression *const r3AD1 = add(r39E1, r39E0);
               body.emit(assign(r39E6, add(r3AD1, body.constant(int(-1024))), 0x01));

               body.emit(assign(r39E4, bit_or(r39E4, body.constant(1048576u)), 0x01));

               ir_variable *const r3AD2 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r3AD2, lshift(r39E3, body.constant(int(12))), 0x01));

               ir_variable *const r3AD3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r3AD4 = lshift(r39E2, body.constant(int(12)));
               ir_expression *const r3AD5 = rshift(r39E3, body.constant(int(20)));
               body.emit(assign(r3AD3, bit_or(r3AD4, r3AD5), 0x01));

               body.emit(assign(r39E2, r3AD3, 0x01));

               body.emit(assign(r39E3, r3AD2, 0x01));

               ir_variable *const r3AD6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3AD6);
               ir_variable *const r3AD7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r3AD7);
               ir_variable *const r3AD8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3AD8);
               ir_variable *const r3AD9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3AD9, bit_and(r39E5, body.constant(65535u)), 0x01));

               ir_variable *const r3ADA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3ADA, rshift(r39E5, body.constant(int(16))), 0x01));

               ir_variable *const r3ADB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3ADB, bit_and(r3AD2, body.constant(65535u)), 0x01));

               ir_variable *const r3ADC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3ADC, rshift(r3AD2, body.constant(int(16))), 0x01));

               ir_variable *const r3ADD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3ADD, mul(r3ADA, r3ADB), 0x01));

               ir_expression *const r3ADE = mul(r3AD9, r3ADC);
               body.emit(assign(r3AD7, add(r3ADE, r3ADD), 0x01));

               ir_expression *const r3ADF = mul(r3ADA, r3ADC);
               ir_expression *const r3AE0 = less(r3AD7, r3ADD);
               ir_expression *const r3AE1 = expr(ir_unop_b2i, r3AE0);
               ir_expression *const r3AE2 = expr(ir_unop_i2u, r3AE1);
               ir_expression *const r3AE3 = lshift(r3AE2, body.constant(int(16)));
               ir_expression *const r3AE4 = rshift(r3AD7, body.constant(int(16)));
               ir_expression *const r3AE5 = add(r3AE3, r3AE4);
               body.emit(assign(r3AD6, add(r3ADF, r3AE5), 0x01));

               body.emit(assign(r3AD7, lshift(r3AD7, body.constant(int(16))), 0x01));

               ir_expression *const r3AE6 = mul(r3AD9, r3ADB);
               body.emit(assign(r3AD8, add(r3AE6, r3AD7), 0x01));

               ir_expression *const r3AE7 = less(r3AD8, r3AD7);
               ir_expression *const r3AE8 = expr(ir_unop_b2i, r3AE7);
               ir_expression *const r3AE9 = expr(ir_unop_i2u, r3AE8);
               body.emit(assign(r3AD6, add(r3AD6, r3AE9), 0x01));

               ir_variable *const r3AEA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3AEA);
               ir_variable *const r3AEB = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r3AEB);
               ir_variable *const r3AEC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3AEC);
               ir_variable *const r3AED = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3AED, bit_and(r39E5, body.constant(65535u)), 0x01));

               ir_variable *const r3AEE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3AEE, rshift(r39E5, body.constant(int(16))), 0x01));

               ir_variable *const r3AEF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3AEF, bit_and(r3AD3, body.constant(65535u)), 0x01));

               ir_variable *const r3AF0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3AF0, rshift(r3AD3, body.constant(int(16))), 0x01));

               ir_variable *const r3AF1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3AF1, mul(r3AEE, r3AEF), 0x01));

               ir_expression *const r3AF2 = mul(r3AED, r3AF0);
               body.emit(assign(r3AEB, add(r3AF2, r3AF1), 0x01));

               ir_expression *const r3AF3 = mul(r3AEE, r3AF0);
               ir_expression *const r3AF4 = less(r3AEB, r3AF1);
               ir_expression *const r3AF5 = expr(ir_unop_b2i, r3AF4);
               ir_expression *const r3AF6 = expr(ir_unop_i2u, r3AF5);
               ir_expression *const r3AF7 = lshift(r3AF6, body.constant(int(16)));
               ir_expression *const r3AF8 = rshift(r3AEB, body.constant(int(16)));
               ir_expression *const r3AF9 = add(r3AF7, r3AF8);
               body.emit(assign(r3AEA, add(r3AF3, r3AF9), 0x01));

               body.emit(assign(r3AEB, lshift(r3AEB, body.constant(int(16))), 0x01));

               ir_expression *const r3AFA = mul(r3AED, r3AEF);
               body.emit(assign(r3AEC, add(r3AFA, r3AEB), 0x01));

               ir_expression *const r3AFB = less(r3AEC, r3AEB);
               ir_expression *const r3AFC = expr(ir_unop_b2i, r3AFB);
               ir_expression *const r3AFD = expr(ir_unop_i2u, r3AFC);
               body.emit(assign(r3AEA, add(r3AEA, r3AFD), 0x01));

               ir_variable *const r3AFE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3AFE, add(r3AEC, r3AD6), 0x01));

               ir_variable *const r3AFF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3AFF);
               ir_variable *const r3B00 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r3B00);
               ir_variable *const r3B01 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3B01);
               ir_variable *const r3B02 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B02, bit_and(r39E4, body.constant(65535u)), 0x01));

               ir_variable *const r3B03 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B03, rshift(r39E4, body.constant(int(16))), 0x01));

               ir_variable *const r3B04 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B04, bit_and(r3AD3, body.constant(65535u)), 0x01));

               ir_variable *const r3B05 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B05, rshift(r3AD3, body.constant(int(16))), 0x01));

               ir_variable *const r3B06 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B06, mul(r3B03, r3B04), 0x01));

               ir_expression *const r3B07 = mul(r3B02, r3B05);
               body.emit(assign(r3B00, add(r3B07, r3B06), 0x01));

               ir_expression *const r3B08 = mul(r3B03, r3B05);
               ir_expression *const r3B09 = less(r3B00, r3B06);
               ir_expression *const r3B0A = expr(ir_unop_b2i, r3B09);
               ir_expression *const r3B0B = expr(ir_unop_i2u, r3B0A);
               ir_expression *const r3B0C = lshift(r3B0B, body.constant(int(16)));
               ir_expression *const r3B0D = rshift(r3B00, body.constant(int(16)));
               ir_expression *const r3B0E = add(r3B0C, r3B0D);
               body.emit(assign(r3AFF, add(r3B08, r3B0E), 0x01));

               body.emit(assign(r3B00, lshift(r3B00, body.constant(int(16))), 0x01));

               ir_expression *const r3B0F = mul(r3B02, r3B04);
               body.emit(assign(r3B01, add(r3B0F, r3B00), 0x01));

               ir_expression *const r3B10 = less(r3B01, r3B00);
               ir_expression *const r3B11 = expr(ir_unop_b2i, r3B10);
               ir_expression *const r3B12 = expr(ir_unop_i2u, r3B11);
               body.emit(assign(r3AFF, add(r3AFF, r3B12), 0x01));

               ir_variable *const r3B13 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r3B14 = less(r3AFE, r3AEC);
               ir_expression *const r3B15 = expr(ir_unop_b2i, r3B14);
               ir_expression *const r3B16 = expr(ir_unop_i2u, r3B15);
               ir_expression *const r3B17 = add(r3AEA, r3B16);
               body.emit(assign(r3B13, add(r3B01, r3B17), 0x01));

               ir_variable *const r3B18 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3B18);
               ir_variable *const r3B19 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r3B19);
               ir_variable *const r3B1A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3B1A);
               ir_variable *const r3B1B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B1B, bit_and(r39E4, body.constant(65535u)), 0x01));

               ir_variable *const r3B1C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B1C, rshift(r39E4, body.constant(int(16))), 0x01));

               ir_variable *const r3B1D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B1D, bit_and(r3AD2, body.constant(65535u)), 0x01));

               ir_variable *const r3B1E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B1E, rshift(r3AD2, body.constant(int(16))), 0x01));

               ir_variable *const r3B1F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B1F, mul(r3B1C, r3B1D), 0x01));

               ir_expression *const r3B20 = mul(r3B1B, r3B1E);
               body.emit(assign(r3B19, add(r3B20, r3B1F), 0x01));

               ir_expression *const r3B21 = mul(r3B1C, r3B1E);
               ir_expression *const r3B22 = less(r3B19, r3B1F);
               ir_expression *const r3B23 = expr(ir_unop_b2i, r3B22);
               ir_expression *const r3B24 = expr(ir_unop_i2u, r3B23);
               ir_expression *const r3B25 = lshift(r3B24, body.constant(int(16)));
               ir_expression *const r3B26 = rshift(r3B19, body.constant(int(16)));
               ir_expression *const r3B27 = add(r3B25, r3B26);
               body.emit(assign(r3B18, add(r3B21, r3B27), 0x01));

               body.emit(assign(r3B19, lshift(r3B19, body.constant(int(16))), 0x01));

               ir_expression *const r3B28 = mul(r3B1B, r3B1D);
               body.emit(assign(r3B1A, add(r3B28, r3B19), 0x01));

               ir_expression *const r3B29 = less(r3B1A, r3B19);
               ir_expression *const r3B2A = expr(ir_unop_b2i, r3B29);
               ir_expression *const r3B2B = expr(ir_unop_i2u, r3B2A);
               body.emit(assign(r3B18, add(r3B18, r3B2B), 0x01));

               ir_variable *const r3B2C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B2C, add(r3B1A, r3AFE), 0x01));

               ir_variable *const r3B2D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r3B2E = less(r3B2C, r3B1A);
               ir_expression *const r3B2F = expr(ir_unop_b2i, r3B2E);
               ir_expression *const r3B30 = expr(ir_unop_i2u, r3B2F);
               ir_expression *const r3B31 = add(r3B18, r3B30);
               body.emit(assign(r3B2D, add(r3B13, r3B31), 0x01));

               ir_variable *const r3B32 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r3B33 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r3B33, add(r3B2D, r39E5), 0x01));

               ir_expression *const r3B34 = less(r3B13, r3B01);
               ir_expression *const r3B35 = expr(ir_unop_b2i, r3B34);
               ir_expression *const r3B36 = expr(ir_unop_i2u, r3B35);
               ir_expression *const r3B37 = add(r3AFF, r3B36);
               ir_expression *const r3B38 = less(r3B2D, r3B13);
               ir_expression *const r3B39 = expr(ir_unop_b2i, r3B38);
               ir_expression *const r3B3A = expr(ir_unop_i2u, r3B39);
               ir_expression *const r3B3B = add(r3B37, r3B3A);
               ir_expression *const r3B3C = add(r3B3B, r39E4);
               ir_expression *const r3B3D = less(r3B33, r3B2D);
               ir_expression *const r3B3E = expr(ir_unop_b2i, r3B3D);
               ir_expression *const r3B3F = expr(ir_unop_i2u, r3B3E);
               body.emit(assign(r3B32, add(r3B3C, r3B3F), 0x01));

               body.emit(assign(r39E9, r3B32, 0x01));

               body.emit(assign(r39E8, r3B33, 0x01));

               ir_expression *const r3B40 = nequal(r3AD8, body.constant(0u));
               ir_expression *const r3B41 = expr(ir_unop_b2i, r3B40);
               ir_expression *const r3B42 = expr(ir_unop_i2u, r3B41);
               body.emit(assign(r39E7, bit_or(r3B2C, r3B42), 0x01));

               /* IF CONDITION */
               ir_expression *const r3B44 = lequal(body.constant(2097152u), r3B32);
               ir_if *f3B43 = new(mem_ctx) ir_if(operand(r3B44).val);
               exec_list *const f3B43_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3B43->then_instructions;

                  ir_variable *const r3B45 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r3B45);
                  body.emit(assign(r3B45, lshift(r3B33, body.constant(int(31))), 0x01));

                  ir_expression *const r3B46 = nequal(r39E7, body.constant(0u));
                  ir_expression *const r3B47 = expr(ir_unop_b2i, r3B46);
                  ir_expression *const r3B48 = expr(ir_unop_i2u, r3B47);
                  body.emit(assign(r3B45, bit_or(r3B45, r3B48), 0x01));

                  body.emit(assign(r39E9, rshift(r3B32, body.constant(int(1))), 0x01));

                  ir_expression *const r3B49 = lshift(r3B32, body.constant(int(31)));
                  ir_expression *const r3B4A = rshift(r3B33, body.constant(int(1)));
                  body.emit(assign(r39E8, bit_or(r3B49, r3B4A), 0x01));

                  body.emit(assign(r39E7, r3B45, 0x01));

                  body.emit(assign(r39E6, add(r39E6, body.constant(int(1))), 0x01));


               body.instructions = f3B43_parent_instructions;
               body.emit(f3B43);

               /* END IF */

               ir_variable *const r3B4B = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r3B4B, r39E6, 0x01));

               ir_variable *const r3B4C = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r3B4C, r39E9, 0x01));

               ir_variable *const r3B4D = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r3B4D, r39E8, 0x01));

               ir_variable *const r3B4E = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r3B4E, r39E7, 0x01));

               ir_variable *const r3B4F = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r3B4F, body.constant(true), 0x01));

               ir_variable *const r3B50 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r3B51 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r3B51);
               ir_expression *const r3B52 = expr(ir_unop_u2i, r39E7);
               body.emit(assign(r3B51, less(r3B52, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3B54 = lequal(body.constant(int(2045)), r39E6);
               ir_if *f3B53 = new(mem_ctx) ir_if(operand(r3B54).val);
               exec_list *const f3B53_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3B53->then_instructions;

                  ir_variable *const r3B55 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3B57 = less(body.constant(int(2045)), r39E6);
                  ir_if *f3B56 = new(mem_ctx) ir_if(operand(r3B57).val);
                  exec_list *const f3B56_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3B56->then_instructions;

                     body.emit(assign(r3B55, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3B56->else_instructions;

                     ir_variable *const r3B58 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3B5A = equal(r39E6, body.constant(int(2045)));
                     ir_if *f3B59 = new(mem_ctx) ir_if(operand(r3B5A).val);
                     exec_list *const f3B59_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3B59->then_instructions;

                        ir_expression *const r3B5B = equal(body.constant(2097151u), r39E9);
                        ir_expression *const r3B5C = equal(body.constant(4294967295u), r39E8);
                        body.emit(assign(r3B58, logic_and(r3B5B, r3B5C), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3B59->else_instructions;

                        body.emit(assign(r3B58, body.constant(false), 0x01));


                     body.instructions = f3B59_parent_instructions;
                     body.emit(f3B59);

                     /* END IF */

                     body.emit(assign(r3B55, logic_and(r3B58, r3B51), 0x01));


                  body.instructions = f3B56_parent_instructions;
                  body.emit(f3B56);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f3B5D = new(mem_ctx) ir_if(operand(r3B55).val);
                  exec_list *const f3B5D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3B5D->then_instructions;

                     ir_variable *const r3B5E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r3B5E);
                     ir_expression *const r3B5F = lshift(r39DF, body.constant(int(31)));
                     body.emit(assign(r3B5E, add(r3B5F, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r3B5E, body.constant(0u), 0x01));

                     body.emit(assign(r3B50, r3B5E, 0x03));

                     body.emit(assign(r3B4F, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3B5D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3B61 = less(r39E6, body.constant(int(0)));
                     ir_if *f3B60 = new(mem_ctx) ir_if(operand(r3B61).val);
                     exec_list *const f3B60_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3B60->then_instructions;

                        ir_variable *const r3B62 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r3B62, r39E7, 0x01));

                        ir_variable *const r3B63 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r3B63, neg(r39E6), 0x01));

                        ir_variable *const r3B64 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r3B64);
                        ir_variable *const r3B65 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r3B65);
                        ir_variable *const r3B66 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r3B66);
                        ir_variable *const r3B67 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r3B68 = neg(r3B63);
                        body.emit(assign(r3B67, bit_and(r3B68, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3B6A = equal(r3B63, body.constant(int(0)));
                        ir_if *f3B69 = new(mem_ctx) ir_if(operand(r3B6A).val);
                        exec_list *const f3B69_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3B69->then_instructions;

                           body.emit(assign(r3B64, r39E7, 0x01));

                           body.emit(assign(r3B65, r39E8, 0x01));

                           body.emit(assign(r3B66, r39E9, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3B69->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3B6C = less(r3B63, body.constant(int(32)));
                           ir_if *f3B6B = new(mem_ctx) ir_if(operand(r3B6C).val);
                           exec_list *const f3B6B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3B6B->then_instructions;

                              body.emit(assign(r3B64, lshift(r39E8, r3B67), 0x01));

                              ir_expression *const r3B6D = lshift(r39E9, r3B67);
                              ir_expression *const r3B6E = rshift(r39E8, r3B63);
                              body.emit(assign(r3B65, bit_or(r3B6D, r3B6E), 0x01));

                              body.emit(assign(r3B66, rshift(r39E9, r3B63), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3B6B->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3B70 = equal(r3B63, body.constant(int(32)));
                              ir_if *f3B6F = new(mem_ctx) ir_if(operand(r3B70).val);
                              exec_list *const f3B6F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3B6F->then_instructions;

                                 body.emit(assign(r3B64, r39E8, 0x01));

                                 body.emit(assign(r3B65, r39E9, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3B6F->else_instructions;

                                 body.emit(assign(r3B62, bit_or(r39E7, r39E8), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3B72 = less(r3B63, body.constant(int(64)));
                                 ir_if *f3B71 = new(mem_ctx) ir_if(operand(r3B72).val);
                                 exec_list *const f3B71_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3B71->then_instructions;

                                    body.emit(assign(r3B64, lshift(r39E9, r3B67), 0x01));

                                    ir_expression *const r3B73 = bit_and(r3B63, body.constant(int(31)));
                                    body.emit(assign(r3B65, rshift(r39E9, r3B73), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3B71->else_instructions;

                                    ir_variable *const r3B74 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r3B76 = equal(r3B63, body.constant(int(64)));
                                    ir_if *f3B75 = new(mem_ctx) ir_if(operand(r3B76).val);
                                    exec_list *const f3B75_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3B75->then_instructions;

                                       body.emit(assign(r3B74, r39E9, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3B75->else_instructions;

                                       ir_expression *const r3B77 = nequal(r39E9, body.constant(0u));
                                       ir_expression *const r3B78 = expr(ir_unop_b2i, r3B77);
                                       body.emit(assign(r3B74, expr(ir_unop_i2u, r3B78), 0x01));


                                    body.instructions = f3B75_parent_instructions;
                                    body.emit(f3B75);

                                    /* END IF */

                                    body.emit(assign(r3B64, r3B74, 0x01));

                                    body.emit(assign(r3B65, body.constant(0u), 0x01));


                                 body.instructions = f3B71_parent_instructions;
                                 body.emit(f3B71);

                                 /* END IF */


                              body.instructions = f3B6F_parent_instructions;
                              body.emit(f3B6F);

                              /* END IF */

                              body.emit(assign(r3B66, body.constant(0u), 0x01));


                           body.instructions = f3B6B_parent_instructions;
                           body.emit(f3B6B);

                           /* END IF */

                           ir_expression *const r3B79 = nequal(r3B62, body.constant(0u));
                           ir_expression *const r3B7A = expr(ir_unop_b2i, r3B79);
                           ir_expression *const r3B7B = expr(ir_unop_i2u, r3B7A);
                           body.emit(assign(r3B64, bit_or(r3B64, r3B7B), 0x01));


                        body.instructions = f3B69_parent_instructions;
                        body.emit(f3B69);

                        /* END IF */

                        body.emit(assign(r3B4C, r3B66, 0x01));

                        body.emit(assign(r3B4D, r3B65, 0x01));

                        body.emit(assign(r3B4E, r3B64, 0x01));

                        body.emit(assign(r3B4B, body.constant(int(0)), 0x01));

                        body.emit(assign(r3B51, less(r3B64, body.constant(0u)), 0x01));


                     body.instructions = f3B60_parent_instructions;
                     body.emit(f3B60);

                     /* END IF */


                  body.instructions = f3B5D_parent_instructions;
                  body.emit(f3B5D);

                  /* END IF */


               body.instructions = f3B53_parent_instructions;
               body.emit(f3B53);

               /* END IF */

               /* IF CONDITION */
               ir_if *f3B7C = new(mem_ctx) ir_if(operand(r3B4F).val);
               exec_list *const f3B7C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3B7C->then_instructions;

                  /* IF CONDITION */
                  ir_if *f3B7D = new(mem_ctx) ir_if(operand(r3B51).val);
                  exec_list *const f3B7D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3B7D->then_instructions;

                     ir_variable *const r3B7E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r3B7E, add(r3B4D, body.constant(1u)), 0x01));

                     ir_expression *const r3B7F = less(r3B7E, r3B4D);
                     ir_expression *const r3B80 = expr(ir_unop_b2i, r3B7F);
                     ir_expression *const r3B81 = expr(ir_unop_i2u, r3B80);
                     body.emit(assign(r3B4C, add(r3B4C, r3B81), 0x01));

                     ir_expression *const r3B82 = equal(r3B4E, body.constant(0u));
                     ir_expression *const r3B83 = expr(ir_unop_b2i, r3B82);
                     ir_expression *const r3B84 = expr(ir_unop_i2u, r3B83);
                     ir_expression *const r3B85 = add(r3B4E, r3B84);
                     ir_expression *const r3B86 = bit_and(r3B85, body.constant(1u));
                     ir_expression *const r3B87 = expr(ir_unop_bit_not, r3B86);
                     body.emit(assign(r3B4D, bit_and(r3B7E, r3B87), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3B7D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3B89 = bit_or(r3B4C, r3B4D);
                     ir_expression *const r3B8A = equal(r3B89, body.constant(0u));
                     ir_if *f3B88 = new(mem_ctx) ir_if(operand(r3B8A).val);
                     exec_list *const f3B88_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3B88->then_instructions;

                        body.emit(assign(r3B4B, body.constant(int(0)), 0x01));


                     body.instructions = f3B88_parent_instructions;
                     body.emit(f3B88);

                     /* END IF */


                  body.instructions = f3B7D_parent_instructions;
                  body.emit(f3B7D);

                  /* END IF */

                  ir_variable *const r3B8B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3B8B);
                  ir_expression *const r3B8C = lshift(r39DF, body.constant(int(31)));
                  ir_expression *const r3B8D = expr(ir_unop_i2u, r3B4B);
                  ir_expression *const r3B8E = lshift(r3B8D, body.constant(int(20)));
                  ir_expression *const r3B8F = add(r3B8C, r3B8E);
                  body.emit(assign(r3B8B, add(r3B8F, r3B4C), 0x02));

                  body.emit(assign(r3B8B, r3B4D, 0x01));

                  body.emit(assign(r3B50, r3B8B, 0x03));

                  body.emit(assign(r3B4F, body.constant(false), 0x01));


               body.instructions = f3B7C_parent_instructions;
               body.emit(f3B7C);

               /* END IF */

               body.emit(assign(r39DE, r3B50, 0x03));

               body.emit(assign(r39DD, body.constant(false), 0x01));


            body.instructions = f3AD0_parent_instructions;
            body.emit(f3AD0);

            /* END IF */


         body.instructions = f3A8F_parent_instructions;
         body.emit(f3A8F);

         /* END IF */


      body.instructions = f3A25_parent_instructions;
      body.emit(f3A25);

      /* END IF */


   body.instructions = f39F6_parent_instructions;
   body.emit(f39F6);

   /* END IF */

   ir_variable *const r3B90 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r3B91 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r3B91, rshift(swizzle_y(r321E), body.constant(int(31))), 0x01));

   ir_variable *const r3B92 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r3B92, rshift(swizzle_y(r39DE), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r3B94 = equal(r3B91, r3B92);
   ir_if *f3B93 = new(mem_ctx) ir_if(operand(r3B94).val);
   exec_list *const f3B93_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f3B93->then_instructions;

      ir_variable *const r3B95 = body.make_temp(glsl_type::uint_type, "zSign");
      body.emit(assign(r3B95, r3B91, 0x01));

      ir_variable *const r3B96 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r3B97 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r3B97);
      ir_variable *const r3B98 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
      body.emit(r3B98);
      ir_variable *const r3B99 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
      body.emit(r3B99);
      ir_variable *const r3B9A = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
      body.emit(r3B9A);
      ir_variable *const r3B9B = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
      body.emit(r3B9B);
      ir_variable *const r3B9C = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
      body.emit(r3B9C);
      ir_variable *const r3B9D = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
      body.emit(r3B9D);
      ir_variable *const r3B9E = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r3B9E);
      ir_variable *const r3B9F = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r3BA0 = rshift(swizzle_y(r321E), body.constant(int(20)));
      ir_expression *const r3BA1 = bit_and(r3BA0, body.constant(2047u));
      body.emit(assign(r3B9F, expr(ir_unop_u2i, r3BA1), 0x01));

      body.emit(assign(r3B99, r3B9F, 0x01));

      ir_variable *const r3BA2 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r3BA3 = rshift(swizzle_y(r39DE), body.constant(int(20)));
      ir_expression *const r3BA4 = bit_and(r3BA3, body.constant(2047u));
      body.emit(assign(r3BA2, expr(ir_unop_u2i, r3BA4), 0x01));

      body.emit(assign(r3B98, r3BA2, 0x01));

      body.emit(assign(r3B97, sub(r3B9F, r3BA2), 0x01));

      ir_variable *const r3BA5 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r3BA5, lshift(swizzle_x(r321E), body.constant(int(10))), 0x01));

      ir_variable *const r3BA6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r3BA7 = bit_and(swizzle_y(r321E), body.constant(1048575u));
      ir_expression *const r3BA8 = lshift(r3BA7, body.constant(int(10)));
      ir_expression *const r3BA9 = rshift(swizzle_x(r321E), body.constant(int(22)));
      body.emit(assign(r3BA6, bit_or(r3BA8, r3BA9), 0x01));

      body.emit(assign(r3B9C, r3BA6, 0x01));

      body.emit(assign(r3B9D, r3BA5, 0x01));

      ir_variable *const r3BAA = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r3BAA, lshift(swizzle_x(r39DE), body.constant(int(10))), 0x01));

      ir_variable *const r3BAB = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r3BAC = bit_and(swizzle_y(r39DE), body.constant(1048575u));
      ir_expression *const r3BAD = lshift(r3BAC, body.constant(int(10)));
      ir_expression *const r3BAE = rshift(swizzle_x(r39DE), body.constant(int(22)));
      body.emit(assign(r3BAB, bit_or(r3BAD, r3BAE), 0x01));

      body.emit(assign(r3B9A, r3BAB, 0x01));

      body.emit(assign(r3B9B, r3BAA, 0x01));

      /* IF CONDITION */
      ir_expression *const r3BB0 = less(body.constant(int(0)), r3B97);
      ir_if *f3BAF = new(mem_ctx) ir_if(operand(r3BB0).val);
      exec_list *const f3BAF_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f3BAF->then_instructions;

         /* IF CONDITION */
         ir_expression *const r3BB2 = equal(r3B9F, body.constant(int(2047)));
         ir_if *f3BB1 = new(mem_ctx) ir_if(operand(r3BB2).val);
         exec_list *const f3BB1_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3BB1->then_instructions;

            /* IF CONDITION */
            ir_expression *const r3BB4 = bit_or(r3BA6, r3BA5);
            ir_expression *const r3BB5 = nequal(r3BB4, body.constant(0u));
            ir_if *f3BB3 = new(mem_ctx) ir_if(operand(r3BB5).val);
            exec_list *const f3BB3_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3BB3->then_instructions;

               ir_variable *const r3BB6 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r3BB6, swizzle_x(r321E), 0x01));

               ir_variable *const r3BB7 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r3BB7, swizzle_x(r39DE), 0x01));

               ir_variable *const r3BB8 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r3BB9 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r3BBA = rshift(swizzle_y(r321E), body.constant(int(19)));
               ir_expression *const r3BBB = bit_and(r3BBA, body.constant(4095u));
               ir_expression *const r3BBC = equal(r3BBB, body.constant(4094u));
               ir_expression *const r3BBD = nequal(swizzle_x(r321E), body.constant(0u));
               ir_expression *const r3BBE = bit_and(swizzle_y(r321E), body.constant(524287u));
               ir_expression *const r3BBF = nequal(r3BBE, body.constant(0u));
               ir_expression *const r3BC0 = logic_or(r3BBD, r3BBF);
               body.emit(assign(r3BB9, logic_and(r3BBC, r3BC0), 0x01));

               ir_variable *const r3BC1 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r3BC2 = lshift(swizzle_y(r39DE), body.constant(int(1)));
               ir_expression *const r3BC3 = lequal(body.constant(4292870144u), r3BC2);
               ir_expression *const r3BC4 = nequal(swizzle_x(r39DE), body.constant(0u));
               ir_expression *const r3BC5 = bit_and(swizzle_y(r39DE), body.constant(1048575u));
               ir_expression *const r3BC6 = nequal(r3BC5, body.constant(0u));
               ir_expression *const r3BC7 = logic_or(r3BC4, r3BC6);
               body.emit(assign(r3BC1, logic_and(r3BC3, r3BC7), 0x01));

               body.emit(assign(r3BB6, bit_or(swizzle_y(r321E), body.constant(524288u)), 0x02));

               body.emit(assign(r3BB7, bit_or(swizzle_y(r39DE), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r3BC9 = lshift(swizzle_y(r321E), body.constant(int(1)));
               ir_expression *const r3BCA = lequal(body.constant(4292870144u), r3BC9);
               ir_expression *const r3BCB = nequal(swizzle_x(r321E), body.constant(0u));
               ir_expression *const r3BCC = bit_and(swizzle_y(r321E), body.constant(1048575u));
               ir_expression *const r3BCD = nequal(r3BCC, body.constant(0u));
               ir_expression *const r3BCE = logic_or(r3BCB, r3BCD);
               ir_expression *const r3BCF = logic_and(r3BCA, r3BCE);
               ir_if *f3BC8 = new(mem_ctx) ir_if(operand(r3BCF).val);
               exec_list *const f3BC8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3BC8->then_instructions;

                  ir_variable *const r3BD0 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3BD2 = logic_and(r3BB9, r3BC1);
                  ir_if *f3BD1 = new(mem_ctx) ir_if(operand(r3BD2).val);
                  exec_list *const f3BD1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3BD1->then_instructions;

                     body.emit(assign(r3BD0, r3BB7, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3BD1->else_instructions;

                     body.emit(assign(r3BD0, r3BB6, 0x03));


                  body.instructions = f3BD1_parent_instructions;
                  body.emit(f3BD1);

                  /* END IF */

                  body.emit(assign(r3BB8, r3BD0, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3BC8->else_instructions;

                  body.emit(assign(r3BB8, r3BB7, 0x03));


               body.instructions = f3BC8_parent_instructions;
               body.emit(f3BC8);

               /* END IF */

               body.emit(assign(r3B96, r3BB8, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3BB3->else_instructions;

               body.emit(assign(r3B96, r321E, 0x03));


            body.instructions = f3BB3_parent_instructions;
            body.emit(f3BB3);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3BB1->else_instructions;

            /* IF CONDITION */
            ir_expression *const r3BD4 = equal(r3BA2, body.constant(int(0)));
            ir_if *f3BD3 = new(mem_ctx) ir_if(operand(r3BD4).val);
            exec_list *const f3BD3_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3BD3->then_instructions;

               body.emit(assign(r3B97, add(r3B97, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3BD3->else_instructions;

               body.emit(assign(r3B9A, bit_or(r3BAB, body.constant(1073741824u)), 0x01));


            body.instructions = f3BD3_parent_instructions;
            body.emit(f3BD3);

            /* END IF */

            ir_variable *const r3BD5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r3BD5);
            ir_variable *const r3BD6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r3BD6);
            ir_variable *const r3BD7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r3BD8 = neg(r3B97);
            body.emit(assign(r3BD7, bit_and(r3BD8, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r3BDA = equal(r3B97, body.constant(int(0)));
            ir_if *f3BD9 = new(mem_ctx) ir_if(operand(r3BDA).val);
            exec_list *const f3BD9_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3BD9->then_instructions;

               body.emit(assign(r3BD5, r3BAA, 0x01));

               body.emit(assign(r3BD6, r3B9A, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3BD9->else_instructions;

               /* IF CONDITION */
               ir_expression *const r3BDC = less(r3B97, body.constant(int(32)));
               ir_if *f3BDB = new(mem_ctx) ir_if(operand(r3BDC).val);
               exec_list *const f3BDB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3BDB->then_instructions;

                  ir_expression *const r3BDD = lshift(r3B9A, r3BD7);
                  ir_expression *const r3BDE = rshift(r3BAA, r3B97);
                  ir_expression *const r3BDF = bit_or(r3BDD, r3BDE);
                  ir_expression *const r3BE0 = lshift(r3BAA, r3BD7);
                  ir_expression *const r3BE1 = nequal(r3BE0, body.constant(0u));
                  ir_expression *const r3BE2 = expr(ir_unop_b2i, r3BE1);
                  ir_expression *const r3BE3 = expr(ir_unop_i2u, r3BE2);
                  body.emit(assign(r3BD5, bit_or(r3BDF, r3BE3), 0x01));

                  body.emit(assign(r3BD6, rshift(r3B9A, r3B97), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3BDB->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3BE5 = equal(r3B97, body.constant(int(32)));
                  ir_if *f3BE4 = new(mem_ctx) ir_if(operand(r3BE5).val);
                  exec_list *const f3BE4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3BE4->then_instructions;

                     ir_expression *const r3BE6 = nequal(r3BAA, body.constant(0u));
                     ir_expression *const r3BE7 = expr(ir_unop_b2i, r3BE6);
                     ir_expression *const r3BE8 = expr(ir_unop_i2u, r3BE7);
                     body.emit(assign(r3BD5, bit_or(r3B9A, r3BE8), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3BE4->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3BEA = less(r3B97, body.constant(int(64)));
                     ir_if *f3BE9 = new(mem_ctx) ir_if(operand(r3BEA).val);
                     exec_list *const f3BE9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3BE9->then_instructions;

                        ir_expression *const r3BEB = bit_and(r3B97, body.constant(int(31)));
                        ir_expression *const r3BEC = rshift(r3B9A, r3BEB);
                        ir_expression *const r3BED = lshift(r3B9A, r3BD7);
                        ir_expression *const r3BEE = bit_or(r3BED, r3BAA);
                        ir_expression *const r3BEF = nequal(r3BEE, body.constant(0u));
                        ir_expression *const r3BF0 = expr(ir_unop_b2i, r3BEF);
                        ir_expression *const r3BF1 = expr(ir_unop_i2u, r3BF0);
                        body.emit(assign(r3BD5, bit_or(r3BEC, r3BF1), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3BE9->else_instructions;

                        ir_expression *const r3BF2 = bit_or(r3B9A, r3BAA);
                        ir_expression *const r3BF3 = nequal(r3BF2, body.constant(0u));
                        ir_expression *const r3BF4 = expr(ir_unop_b2i, r3BF3);
                        body.emit(assign(r3BD5, expr(ir_unop_i2u, r3BF4), 0x01));


                     body.instructions = f3BE9_parent_instructions;
                     body.emit(f3BE9);

                     /* END IF */


                  body.instructions = f3BE4_parent_instructions;
                  body.emit(f3BE4);

                  /* END IF */

                  body.emit(assign(r3BD6, body.constant(0u), 0x01));


               body.instructions = f3BDB_parent_instructions;
               body.emit(f3BDB);

               /* END IF */


            body.instructions = f3BD9_parent_instructions;
            body.emit(f3BD9);

            /* END IF */

            body.emit(assign(r3B9A, r3BD6, 0x01));

            body.emit(assign(r3B9B, r3BD5, 0x01));

            body.emit(assign(r3B9C, bit_or(r3BA6, body.constant(1073741824u)), 0x01));

            ir_variable *const r3BF5 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r3BF6 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r3BF6, sub(r3BA5, r3BD5), 0x01));

            ir_expression *const r3BF7 = sub(r3B9C, r3BD6);
            ir_expression *const r3BF8 = less(r3BA5, r3BD5);
            ir_expression *const r3BF9 = expr(ir_unop_b2i, r3BF8);
            ir_expression *const r3BFA = expr(ir_unop_i2u, r3BF9);
            body.emit(assign(r3BF5, sub(r3BF7, r3BFA), 0x01));

            body.emit(assign(r3B9E, add(r3B9F, body.constant(int(-1))), 0x01));

            ir_variable *const r3BFB = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r3BFB, add(r3B9E, body.constant(int(-10))), 0x01));

            ir_variable *const r3BFC = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r3BFC, r3BF5, 0x01));

            ir_variable *const r3BFD = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r3BFD, r3BF6, 0x01));

            ir_variable *const r3BFE = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
            body.emit(r3BFE);
            ir_variable *const r3BFF = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r3BFF);
            /* IF CONDITION */
            ir_expression *const r3C01 = equal(r3BF5, body.constant(0u));
            ir_if *f3C00 = new(mem_ctx) ir_if(operand(r3C01).val);
            exec_list *const f3C00_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3C00->then_instructions;

               body.emit(assign(r3BFC, r3BF6, 0x01));

               body.emit(assign(r3BFD, body.constant(0u), 0x01));

               body.emit(assign(r3BFB, add(r3BFB, body.constant(int(-32))), 0x01));


            body.instructions = f3C00_parent_instructions;
            body.emit(f3C00);

            /* END IF */

            ir_variable *const r3C02 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r3C02, r3BFC, 0x01));

            ir_variable *const r3C03 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r3C04 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r3C04);
            /* IF CONDITION */
            ir_expression *const r3C06 = equal(r3BFC, body.constant(0u));
            ir_if *f3C05 = new(mem_ctx) ir_if(operand(r3C06).val);
            exec_list *const f3C05_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3C05->then_instructions;

               body.emit(assign(r3C03, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3C05->else_instructions;

               body.emit(assign(r3C04, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r3C08 = bit_and(r3BFC, body.constant(4294901760u));
               ir_expression *const r3C09 = equal(r3C08, body.constant(0u));
               ir_if *f3C07 = new(mem_ctx) ir_if(operand(r3C09).val);
               exec_list *const f3C07_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3C07->then_instructions;

                  body.emit(assign(r3C04, body.constant(int(16)), 0x01));

                  body.emit(assign(r3C02, lshift(r3BFC, body.constant(int(16))), 0x01));


               body.instructions = f3C07_parent_instructions;
               body.emit(f3C07);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r3C0B = bit_and(r3C02, body.constant(4278190080u));
               ir_expression *const r3C0C = equal(r3C0B, body.constant(0u));
               ir_if *f3C0A = new(mem_ctx) ir_if(operand(r3C0C).val);
               exec_list *const f3C0A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3C0A->then_instructions;

                  body.emit(assign(r3C04, add(r3C04, body.constant(int(8))), 0x01));

                  body.emit(assign(r3C02, lshift(r3C02, body.constant(int(8))), 0x01));


               body.instructions = f3C0A_parent_instructions;
               body.emit(f3C0A);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r3C0E = bit_and(r3C02, body.constant(4026531840u));
               ir_expression *const r3C0F = equal(r3C0E, body.constant(0u));
               ir_if *f3C0D = new(mem_ctx) ir_if(operand(r3C0F).val);
               exec_list *const f3C0D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3C0D->then_instructions;

                  body.emit(assign(r3C04, add(r3C04, body.constant(int(4))), 0x01));

                  body.emit(assign(r3C02, lshift(r3C02, body.constant(int(4))), 0x01));


               body.instructions = f3C0D_parent_instructions;
               body.emit(f3C0D);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r3C11 = bit_and(r3C02, body.constant(3221225472u));
               ir_expression *const r3C12 = equal(r3C11, body.constant(0u));
               ir_if *f3C10 = new(mem_ctx) ir_if(operand(r3C12).val);
               exec_list *const f3C10_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3C10->then_instructions;

                  body.emit(assign(r3C04, add(r3C04, body.constant(int(2))), 0x01));

                  body.emit(assign(r3C02, lshift(r3C02, body.constant(int(2))), 0x01));


               body.instructions = f3C10_parent_instructions;
               body.emit(f3C10);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r3C14 = bit_and(r3C02, body.constant(2147483648u));
               ir_expression *const r3C15 = equal(r3C14, body.constant(0u));
               ir_if *f3C13 = new(mem_ctx) ir_if(operand(r3C15).val);
               exec_list *const f3C13_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3C13->then_instructions;

                  body.emit(assign(r3C04, add(r3C04, body.constant(int(1))), 0x01));


               body.instructions = f3C13_parent_instructions;
               body.emit(f3C13);

               /* END IF */

               body.emit(assign(r3C03, r3C04, 0x01));


            body.instructions = f3C05_parent_instructions;
            body.emit(f3C05);

            /* END IF */

            body.emit(assign(r3BFF, add(r3C03, body.constant(int(-11))), 0x01));

            /* IF CONDITION */
            ir_expression *const r3C17 = lequal(body.constant(int(0)), r3BFF);
            ir_if *f3C16 = new(mem_ctx) ir_if(operand(r3C17).val);
            exec_list *const f3C16_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3C16->then_instructions;

               body.emit(assign(r3BFE, body.constant(0u), 0x01));

               ir_variable *const r3C18 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r3C18, lshift(r3BFD, r3BFF), 0x01));

               ir_variable *const r3C19 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r3C1B = equal(r3BFF, body.constant(int(0)));
               ir_if *f3C1A = new(mem_ctx) ir_if(operand(r3C1B).val);
               exec_list *const f3C1A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3C1A->then_instructions;

                  body.emit(assign(r3C19, r3BFC, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3C1A->else_instructions;

                  ir_expression *const r3C1C = lshift(r3BFC, r3BFF);
                  ir_expression *const r3C1D = neg(r3BFF);
                  ir_expression *const r3C1E = bit_and(r3C1D, body.constant(int(31)));
                  ir_expression *const r3C1F = rshift(r3BFD, r3C1E);
                  body.emit(assign(r3C19, bit_or(r3C1C, r3C1F), 0x01));


               body.instructions = f3C1A_parent_instructions;
               body.emit(f3C1A);

               /* END IF */

               body.emit(assign(r3BFC, r3C19, 0x01));

               body.emit(assign(r3BFD, r3C18, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3C16->else_instructions;

               ir_variable *const r3C20 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r3C20, body.constant(0u), 0x01));

               ir_variable *const r3C21 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r3C21, neg(r3BFF), 0x01));

               ir_variable *const r3C22 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r3C22);
               ir_variable *const r3C23 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3C23);
               ir_variable *const r3C24 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3C24);
               ir_variable *const r3C25 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r3C26 = neg(r3C21);
               body.emit(assign(r3C25, bit_and(r3C26, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3C28 = equal(r3C21, body.constant(int(0)));
               ir_if *f3C27 = new(mem_ctx) ir_if(operand(r3C28).val);
               exec_list *const f3C27_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3C27->then_instructions;

                  body.emit(assign(r3C22, r3C20, 0x01));

                  body.emit(assign(r3C23, r3BFD, 0x01));

                  body.emit(assign(r3C24, r3BFC, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3C27->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3C2A = less(r3C21, body.constant(int(32)));
                  ir_if *f3C29 = new(mem_ctx) ir_if(operand(r3C2A).val);
                  exec_list *const f3C29_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3C29->then_instructions;

                     body.emit(assign(r3C22, lshift(r3BFD, r3C25), 0x01));

                     ir_expression *const r3C2B = lshift(r3BFC, r3C25);
                     ir_expression *const r3C2C = rshift(r3BFD, r3C21);
                     body.emit(assign(r3C23, bit_or(r3C2B, r3C2C), 0x01));

                     body.emit(assign(r3C24, rshift(r3BFC, r3C21), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3C29->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3C2E = equal(r3C21, body.constant(int(32)));
                     ir_if *f3C2D = new(mem_ctx) ir_if(operand(r3C2E).val);
                     exec_list *const f3C2D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3C2D->then_instructions;

                        body.emit(assign(r3C22, r3BFD, 0x01));

                        body.emit(assign(r3C23, r3BFC, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3C2D->else_instructions;

                        body.emit(assign(r3C20, bit_or(body.constant(0u), r3BFD), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3C30 = less(r3C21, body.constant(int(64)));
                        ir_if *f3C2F = new(mem_ctx) ir_if(operand(r3C30).val);
                        exec_list *const f3C2F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3C2F->then_instructions;

                           body.emit(assign(r3C22, lshift(r3BFC, r3C25), 0x01));

                           ir_expression *const r3C31 = bit_and(r3C21, body.constant(int(31)));
                           body.emit(assign(r3C23, rshift(r3BFC, r3C31), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3C2F->else_instructions;

                           ir_variable *const r3C32 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r3C34 = equal(r3C21, body.constant(int(64)));
                           ir_if *f3C33 = new(mem_ctx) ir_if(operand(r3C34).val);
                           exec_list *const f3C33_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3C33->then_instructions;

                              body.emit(assign(r3C32, r3BFC, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3C33->else_instructions;

                              ir_expression *const r3C35 = nequal(r3BFC, body.constant(0u));
                              ir_expression *const r3C36 = expr(ir_unop_b2i, r3C35);
                              body.emit(assign(r3C32, expr(ir_unop_i2u, r3C36), 0x01));


                           body.instructions = f3C33_parent_instructions;
                           body.emit(f3C33);

                           /* END IF */

                           body.emit(assign(r3C22, r3C32, 0x01));

                           body.emit(assign(r3C23, body.constant(0u), 0x01));


                        body.instructions = f3C2F_parent_instructions;
                        body.emit(f3C2F);

                        /* END IF */


                     body.instructions = f3C2D_parent_instructions;
                     body.emit(f3C2D);

                     /* END IF */

                     body.emit(assign(r3C24, body.constant(0u), 0x01));


                  body.instructions = f3C29_parent_instructions;
                  body.emit(f3C29);

                  /* END IF */

                  ir_expression *const r3C37 = nequal(r3C20, body.constant(0u));
                  ir_expression *const r3C38 = expr(ir_unop_b2i, r3C37);
                  ir_expression *const r3C39 = expr(ir_unop_i2u, r3C38);
                  body.emit(assign(r3C22, bit_or(r3C22, r3C39), 0x01));


               body.instructions = f3C27_parent_instructions;
               body.emit(f3C27);

               /* END IF */

               body.emit(assign(r3BFC, r3C24, 0x01));

               body.emit(assign(r3BFD, r3C23, 0x01));

               body.emit(assign(r3BFE, r3C22, 0x01));


            body.instructions = f3C16_parent_instructions;
            body.emit(f3C16);

            /* END IF */

            body.emit(assign(r3BFB, sub(r3BFB, r3BFF), 0x01));

            ir_variable *const r3C3A = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r3C3A, r3BFB, 0x01));

            ir_variable *const r3C3B = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r3C3B, r3BFC, 0x01));

            ir_variable *const r3C3C = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r3C3C, r3BFD, 0x01));

            ir_variable *const r3C3D = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r3C3D, r3BFE, 0x01));

            ir_variable *const r3C3E = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r3C3E, body.constant(true), 0x01));

            ir_variable *const r3C3F = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r3C40 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r3C40);
            ir_expression *const r3C41 = expr(ir_unop_u2i, r3BFE);
            body.emit(assign(r3C40, less(r3C41, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r3C43 = lequal(body.constant(int(2045)), r3BFB);
            ir_if *f3C42 = new(mem_ctx) ir_if(operand(r3C43).val);
            exec_list *const f3C42_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3C42->then_instructions;

               ir_variable *const r3C44 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r3C46 = less(body.constant(int(2045)), r3BFB);
               ir_if *f3C45 = new(mem_ctx) ir_if(operand(r3C46).val);
               exec_list *const f3C45_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3C45->then_instructions;

                  body.emit(assign(r3C44, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3C45->else_instructions;

                  ir_variable *const r3C47 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3C49 = equal(r3BFB, body.constant(int(2045)));
                  ir_if *f3C48 = new(mem_ctx) ir_if(operand(r3C49).val);
                  exec_list *const f3C48_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3C48->then_instructions;

                     ir_expression *const r3C4A = equal(body.constant(2097151u), r3BFC);
                     ir_expression *const r3C4B = equal(body.constant(4294967295u), r3BFD);
                     body.emit(assign(r3C47, logic_and(r3C4A, r3C4B), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3C48->else_instructions;

                     body.emit(assign(r3C47, body.constant(false), 0x01));


                  body.instructions = f3C48_parent_instructions;
                  body.emit(f3C48);

                  /* END IF */

                  body.emit(assign(r3C44, logic_and(r3C47, r3C40), 0x01));


               body.instructions = f3C45_parent_instructions;
               body.emit(f3C45);

               /* END IF */

               /* IF CONDITION */
               ir_if *f3C4C = new(mem_ctx) ir_if(operand(r3C44).val);
               exec_list *const f3C4C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3C4C->then_instructions;

                  ir_variable *const r3C4D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3C4D);
                  ir_expression *const r3C4E = lshift(r3B91, body.constant(int(31)));
                  body.emit(assign(r3C4D, add(r3C4E, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r3C4D, body.constant(0u), 0x01));

                  body.emit(assign(r3C3F, r3C4D, 0x03));

                  body.emit(assign(r3C3E, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3C4C->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3C50 = less(r3BFB, body.constant(int(0)));
                  ir_if *f3C4F = new(mem_ctx) ir_if(operand(r3C50).val);
                  exec_list *const f3C4F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3C4F->then_instructions;

                     ir_variable *const r3C51 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r3C51, r3BFE, 0x01));

                     ir_variable *const r3C52 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r3C52, neg(r3BFB), 0x01));

                     ir_variable *const r3C53 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r3C53);
                     ir_variable *const r3C54 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r3C54);
                     ir_variable *const r3C55 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r3C55);
                     ir_variable *const r3C56 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r3C57 = neg(r3C52);
                     body.emit(assign(r3C56, bit_and(r3C57, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3C59 = equal(r3C52, body.constant(int(0)));
                     ir_if *f3C58 = new(mem_ctx) ir_if(operand(r3C59).val);
                     exec_list *const f3C58_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3C58->then_instructions;

                        body.emit(assign(r3C53, r3BFE, 0x01));

                        body.emit(assign(r3C54, r3BFD, 0x01));

                        body.emit(assign(r3C55, r3BFC, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3C58->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3C5B = less(r3C52, body.constant(int(32)));
                        ir_if *f3C5A = new(mem_ctx) ir_if(operand(r3C5B).val);
                        exec_list *const f3C5A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3C5A->then_instructions;

                           body.emit(assign(r3C53, lshift(r3BFD, r3C56), 0x01));

                           ir_expression *const r3C5C = lshift(r3BFC, r3C56);
                           ir_expression *const r3C5D = rshift(r3BFD, r3C52);
                           body.emit(assign(r3C54, bit_or(r3C5C, r3C5D), 0x01));

                           body.emit(assign(r3C55, rshift(r3BFC, r3C52), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3C5A->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3C5F = equal(r3C52, body.constant(int(32)));
                           ir_if *f3C5E = new(mem_ctx) ir_if(operand(r3C5F).val);
                           exec_list *const f3C5E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3C5E->then_instructions;

                              body.emit(assign(r3C53, r3BFD, 0x01));

                              body.emit(assign(r3C54, r3BFC, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3C5E->else_instructions;

                              body.emit(assign(r3C51, bit_or(r3BFE, r3BFD), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3C61 = less(r3C52, body.constant(int(64)));
                              ir_if *f3C60 = new(mem_ctx) ir_if(operand(r3C61).val);
                              exec_list *const f3C60_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3C60->then_instructions;

                                 body.emit(assign(r3C53, lshift(r3BFC, r3C56), 0x01));

                                 ir_expression *const r3C62 = bit_and(r3C52, body.constant(int(31)));
                                 body.emit(assign(r3C54, rshift(r3BFC, r3C62), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3C60->else_instructions;

                                 ir_variable *const r3C63 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r3C65 = equal(r3C52, body.constant(int(64)));
                                 ir_if *f3C64 = new(mem_ctx) ir_if(operand(r3C65).val);
                                 exec_list *const f3C64_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3C64->then_instructions;

                                    body.emit(assign(r3C63, r3BFC, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3C64->else_instructions;

                                    ir_expression *const r3C66 = nequal(r3BFC, body.constant(0u));
                                    ir_expression *const r3C67 = expr(ir_unop_b2i, r3C66);
                                    body.emit(assign(r3C63, expr(ir_unop_i2u, r3C67), 0x01));


                                 body.instructions = f3C64_parent_instructions;
                                 body.emit(f3C64);

                                 /* END IF */

                                 body.emit(assign(r3C53, r3C63, 0x01));

                                 body.emit(assign(r3C54, body.constant(0u), 0x01));


                              body.instructions = f3C60_parent_instructions;
                              body.emit(f3C60);

                              /* END IF */


                           body.instructions = f3C5E_parent_instructions;
                           body.emit(f3C5E);

                           /* END IF */

                           body.emit(assign(r3C55, body.constant(0u), 0x01));


                        body.instructions = f3C5A_parent_instructions;
                        body.emit(f3C5A);

                        /* END IF */

                        ir_expression *const r3C68 = nequal(r3C51, body.constant(0u));
                        ir_expression *const r3C69 = expr(ir_unop_b2i, r3C68);
                        ir_expression *const r3C6A = expr(ir_unop_i2u, r3C69);
                        body.emit(assign(r3C53, bit_or(r3C53, r3C6A), 0x01));


                     body.instructions = f3C58_parent_instructions;
                     body.emit(f3C58);

                     /* END IF */

                     body.emit(assign(r3C3B, r3C55, 0x01));

                     body.emit(assign(r3C3C, r3C54, 0x01));

                     body.emit(assign(r3C3D, r3C53, 0x01));

                     body.emit(assign(r3C3A, body.constant(int(0)), 0x01));

                     body.emit(assign(r3C40, less(r3C53, body.constant(0u)), 0x01));


                  body.instructions = f3C4F_parent_instructions;
                  body.emit(f3C4F);

                  /* END IF */


               body.instructions = f3C4C_parent_instructions;
               body.emit(f3C4C);

               /* END IF */


            body.instructions = f3C42_parent_instructions;
            body.emit(f3C42);

            /* END IF */

            /* IF CONDITION */
            ir_if *f3C6B = new(mem_ctx) ir_if(operand(r3C3E).val);
            exec_list *const f3C6B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3C6B->then_instructions;

               /* IF CONDITION */
               ir_if *f3C6C = new(mem_ctx) ir_if(operand(r3C40).val);
               exec_list *const f3C6C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3C6C->then_instructions;

                  ir_variable *const r3C6D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r3C6D, add(r3C3C, body.constant(1u)), 0x01));

                  ir_expression *const r3C6E = less(r3C6D, r3C3C);
                  ir_expression *const r3C6F = expr(ir_unop_b2i, r3C6E);
                  ir_expression *const r3C70 = expr(ir_unop_i2u, r3C6F);
                  body.emit(assign(r3C3B, add(r3C3B, r3C70), 0x01));

                  ir_expression *const r3C71 = equal(r3C3D, body.constant(0u));
                  ir_expression *const r3C72 = expr(ir_unop_b2i, r3C71);
                  ir_expression *const r3C73 = expr(ir_unop_i2u, r3C72);
                  ir_expression *const r3C74 = add(r3C3D, r3C73);
                  ir_expression *const r3C75 = bit_and(r3C74, body.constant(1u));
                  ir_expression *const r3C76 = expr(ir_unop_bit_not, r3C75);
                  body.emit(assign(r3C3C, bit_and(r3C6D, r3C76), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3C6C->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3C78 = bit_or(r3C3B, r3C3C);
                  ir_expression *const r3C79 = equal(r3C78, body.constant(0u));
                  ir_if *f3C77 = new(mem_ctx) ir_if(operand(r3C79).val);
                  exec_list *const f3C77_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3C77->then_instructions;

                     body.emit(assign(r3C3A, body.constant(int(0)), 0x01));


                  body.instructions = f3C77_parent_instructions;
                  body.emit(f3C77);

                  /* END IF */


               body.instructions = f3C6C_parent_instructions;
               body.emit(f3C6C);

               /* END IF */

               ir_variable *const r3C7A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r3C7A);
               ir_expression *const r3C7B = lshift(r3B91, body.constant(int(31)));
               ir_expression *const r3C7C = expr(ir_unop_i2u, r3C3A);
               ir_expression *const r3C7D = lshift(r3C7C, body.constant(int(20)));
               ir_expression *const r3C7E = add(r3C7B, r3C7D);
               body.emit(assign(r3C7A, add(r3C7E, r3C3B), 0x02));

               body.emit(assign(r3C7A, r3C3C, 0x01));

               body.emit(assign(r3C3F, r3C7A, 0x03));

               body.emit(assign(r3C3E, body.constant(false), 0x01));


            body.instructions = f3C6B_parent_instructions;
            body.emit(f3C6B);

            /* END IF */

            body.emit(assign(r3B96, r3C3F, 0x03));


         body.instructions = f3BB1_parent_instructions;
         body.emit(f3BB1);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f3BAF->else_instructions;

         /* IF CONDITION */
         ir_expression *const r3C80 = less(r3B97, body.constant(int(0)));
         ir_if *f3C7F = new(mem_ctx) ir_if(operand(r3C80).val);
         exec_list *const f3C7F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3C7F->then_instructions;

            /* IF CONDITION */
            ir_expression *const r3C82 = equal(r3BA2, body.constant(int(2047)));
            ir_if *f3C81 = new(mem_ctx) ir_if(operand(r3C82).val);
            exec_list *const f3C81_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3C81->then_instructions;

               /* IF CONDITION */
               ir_expression *const r3C84 = bit_or(r3B9A, r3B9B);
               ir_expression *const r3C85 = nequal(r3C84, body.constant(0u));
               ir_if *f3C83 = new(mem_ctx) ir_if(operand(r3C85).val);
               exec_list *const f3C83_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3C83->then_instructions;

                  ir_variable *const r3C86 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r3C86, swizzle_x(r321E), 0x01));

                  ir_variable *const r3C87 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r3C87, swizzle_x(r39DE), 0x01));

                  ir_variable *const r3C88 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r3C89 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r3C8A = rshift(swizzle_y(r321E), body.constant(int(19)));
                  ir_expression *const r3C8B = bit_and(r3C8A, body.constant(4095u));
                  ir_expression *const r3C8C = equal(r3C8B, body.constant(4094u));
                  ir_expression *const r3C8D = nequal(swizzle_x(r321E), body.constant(0u));
                  ir_expression *const r3C8E = bit_and(swizzle_y(r321E), body.constant(524287u));
                  ir_expression *const r3C8F = nequal(r3C8E, body.constant(0u));
                  ir_expression *const r3C90 = logic_or(r3C8D, r3C8F);
                  body.emit(assign(r3C89, logic_and(r3C8C, r3C90), 0x01));

                  ir_variable *const r3C91 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r3C92 = lshift(swizzle_y(r39DE), body.constant(int(1)));
                  ir_expression *const r3C93 = lequal(body.constant(4292870144u), r3C92);
                  ir_expression *const r3C94 = nequal(swizzle_x(r39DE), body.constant(0u));
                  ir_expression *const r3C95 = bit_and(swizzle_y(r39DE), body.constant(1048575u));
                  ir_expression *const r3C96 = nequal(r3C95, body.constant(0u));
                  ir_expression *const r3C97 = logic_or(r3C94, r3C96);
                  body.emit(assign(r3C91, logic_and(r3C93, r3C97), 0x01));

                  body.emit(assign(r3C86, bit_or(swizzle_y(r321E), body.constant(524288u)), 0x02));

                  body.emit(assign(r3C87, bit_or(swizzle_y(r39DE), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r3C99 = lshift(swizzle_y(r321E), body.constant(int(1)));
                  ir_expression *const r3C9A = lequal(body.constant(4292870144u), r3C99);
                  ir_expression *const r3C9B = nequal(swizzle_x(r321E), body.constant(0u));
                  ir_expression *const r3C9C = bit_and(swizzle_y(r321E), body.constant(1048575u));
                  ir_expression *const r3C9D = nequal(r3C9C, body.constant(0u));
                  ir_expression *const r3C9E = logic_or(r3C9B, r3C9D);
                  ir_expression *const r3C9F = logic_and(r3C9A, r3C9E);
                  ir_if *f3C98 = new(mem_ctx) ir_if(operand(r3C9F).val);
                  exec_list *const f3C98_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3C98->then_instructions;

                     ir_variable *const r3CA0 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3CA2 = logic_and(r3C89, r3C91);
                     ir_if *f3CA1 = new(mem_ctx) ir_if(operand(r3CA2).val);
                     exec_list *const f3CA1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3CA1->then_instructions;

                        body.emit(assign(r3CA0, r3C87, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3CA1->else_instructions;

                        body.emit(assign(r3CA0, r3C86, 0x03));


                     body.instructions = f3CA1_parent_instructions;
                     body.emit(f3CA1);

                     /* END IF */

                     body.emit(assign(r3C88, r3CA0, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3C98->else_instructions;

                     body.emit(assign(r3C88, r3C87, 0x03));


                  body.instructions = f3C98_parent_instructions;
                  body.emit(f3C98);

                  /* END IF */

                  body.emit(assign(r3B96, r3C88, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3C83->else_instructions;

                  ir_variable *const r3CA3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3CA3);
                  ir_expression *const r3CA4 = bit_xor(r3B91, body.constant(1u));
                  ir_expression *const r3CA5 = lshift(r3CA4, body.constant(int(31)));
                  body.emit(assign(r3CA3, add(r3CA5, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r3CA3, body.constant(0u), 0x01));

                  body.emit(assign(r3B96, r3CA3, 0x03));


               body.instructions = f3C83_parent_instructions;
               body.emit(f3C83);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3C81->else_instructions;

               /* IF CONDITION */
               ir_expression *const r3CA7 = equal(r3B9F, body.constant(int(0)));
               ir_if *f3CA6 = new(mem_ctx) ir_if(operand(r3CA7).val);
               exec_list *const f3CA6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3CA6->then_instructions;

                  body.emit(assign(r3B97, add(r3B97, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3CA6->else_instructions;

                  body.emit(assign(r3B9C, bit_or(r3B9C, body.constant(1073741824u)), 0x01));


               body.instructions = f3CA6_parent_instructions;
               body.emit(f3CA6);

               /* END IF */

               ir_variable *const r3CA8 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r3CA8, neg(r3B97), 0x01));

               ir_variable *const r3CA9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r3CA9);
               ir_variable *const r3CAA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r3CAA);
               ir_variable *const r3CAB = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r3CAC = neg(r3CA8);
               body.emit(assign(r3CAB, bit_and(r3CAC, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3CAE = equal(r3CA8, body.constant(int(0)));
               ir_if *f3CAD = new(mem_ctx) ir_if(operand(r3CAE).val);
               exec_list *const f3CAD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3CAD->then_instructions;

                  body.emit(assign(r3CA9, r3BA5, 0x01));

                  body.emit(assign(r3CAA, r3B9C, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3CAD->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3CB0 = less(r3CA8, body.constant(int(32)));
                  ir_if *f3CAF = new(mem_ctx) ir_if(operand(r3CB0).val);
                  exec_list *const f3CAF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3CAF->then_instructions;

                     ir_expression *const r3CB1 = lshift(r3B9C, r3CAB);
                     ir_expression *const r3CB2 = rshift(r3BA5, r3CA8);
                     ir_expression *const r3CB3 = bit_or(r3CB1, r3CB2);
                     ir_expression *const r3CB4 = lshift(r3BA5, r3CAB);
                     ir_expression *const r3CB5 = nequal(r3CB4, body.constant(0u));
                     ir_expression *const r3CB6 = expr(ir_unop_b2i, r3CB5);
                     ir_expression *const r3CB7 = expr(ir_unop_i2u, r3CB6);
                     body.emit(assign(r3CA9, bit_or(r3CB3, r3CB7), 0x01));

                     body.emit(assign(r3CAA, rshift(r3B9C, r3CA8), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3CAF->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3CB9 = equal(r3CA8, body.constant(int(32)));
                     ir_if *f3CB8 = new(mem_ctx) ir_if(operand(r3CB9).val);
                     exec_list *const f3CB8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3CB8->then_instructions;

                        ir_expression *const r3CBA = nequal(r3BA5, body.constant(0u));
                        ir_expression *const r3CBB = expr(ir_unop_b2i, r3CBA);
                        ir_expression *const r3CBC = expr(ir_unop_i2u, r3CBB);
                        body.emit(assign(r3CA9, bit_or(r3B9C, r3CBC), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3CB8->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3CBE = less(r3CA8, body.constant(int(64)));
                        ir_if *f3CBD = new(mem_ctx) ir_if(operand(r3CBE).val);
                        exec_list *const f3CBD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3CBD->then_instructions;

                           ir_expression *const r3CBF = bit_and(r3CA8, body.constant(int(31)));
                           ir_expression *const r3CC0 = rshift(r3B9C, r3CBF);
                           ir_expression *const r3CC1 = lshift(r3B9C, r3CAB);
                           ir_expression *const r3CC2 = bit_or(r3CC1, r3BA5);
                           ir_expression *const r3CC3 = nequal(r3CC2, body.constant(0u));
                           ir_expression *const r3CC4 = expr(ir_unop_b2i, r3CC3);
                           ir_expression *const r3CC5 = expr(ir_unop_i2u, r3CC4);
                           body.emit(assign(r3CA9, bit_or(r3CC0, r3CC5), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3CBD->else_instructions;

                           ir_expression *const r3CC6 = bit_or(r3B9C, r3BA5);
                           ir_expression *const r3CC7 = nequal(r3CC6, body.constant(0u));
                           ir_expression *const r3CC8 = expr(ir_unop_b2i, r3CC7);
                           body.emit(assign(r3CA9, expr(ir_unop_i2u, r3CC8), 0x01));


                        body.instructions = f3CBD_parent_instructions;
                        body.emit(f3CBD);

                        /* END IF */


                     body.instructions = f3CB8_parent_instructions;
                     body.emit(f3CB8);

                     /* END IF */

                     body.emit(assign(r3CAA, body.constant(0u), 0x01));


                  body.instructions = f3CAF_parent_instructions;
                  body.emit(f3CAF);

                  /* END IF */


               body.instructions = f3CAD_parent_instructions;
               body.emit(f3CAD);

               /* END IF */

               body.emit(assign(r3B9C, r3CAA, 0x01));

               body.emit(assign(r3B9D, r3CA9, 0x01));

               body.emit(assign(r3B9A, bit_or(r3B9A, body.constant(1073741824u)), 0x01));

               ir_variable *const r3CC9 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r3CCA = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r3CCA, sub(r3B9B, r3CA9), 0x01));

               ir_expression *const r3CCB = sub(r3B9A, r3CAA);
               ir_expression *const r3CCC = less(r3B9B, r3CA9);
               ir_expression *const r3CCD = expr(ir_unop_b2i, r3CCC);
               ir_expression *const r3CCE = expr(ir_unop_i2u, r3CCD);
               body.emit(assign(r3CC9, sub(r3CCB, r3CCE), 0x01));

               body.emit(assign(r3B95, bit_xor(r3B91, body.constant(1u)), 0x01));

               body.emit(assign(r3B9E, add(r3BA2, body.constant(int(-1))), 0x01));

               ir_variable *const r3CCF = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r3CCF, add(r3B9E, body.constant(int(-10))), 0x01));

               ir_variable *const r3CD0 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r3CD0, r3CC9, 0x01));

               ir_variable *const r3CD1 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r3CD1, r3CCA, 0x01));

               ir_variable *const r3CD2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r3CD2);
               ir_variable *const r3CD3 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r3CD3);
               /* IF CONDITION */
               ir_expression *const r3CD5 = equal(r3CC9, body.constant(0u));
               ir_if *f3CD4 = new(mem_ctx) ir_if(operand(r3CD5).val);
               exec_list *const f3CD4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3CD4->then_instructions;

                  body.emit(assign(r3CD0, r3CCA, 0x01));

                  body.emit(assign(r3CD1, body.constant(0u), 0x01));

                  body.emit(assign(r3CCF, add(r3CCF, body.constant(int(-32))), 0x01));


               body.instructions = f3CD4_parent_instructions;
               body.emit(f3CD4);

               /* END IF */

               ir_variable *const r3CD6 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r3CD6, r3CD0, 0x01));

               ir_variable *const r3CD7 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r3CD8 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r3CD8);
               /* IF CONDITION */
               ir_expression *const r3CDA = equal(r3CD0, body.constant(0u));
               ir_if *f3CD9 = new(mem_ctx) ir_if(operand(r3CDA).val);
               exec_list *const f3CD9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3CD9->then_instructions;

                  body.emit(assign(r3CD7, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3CD9->else_instructions;

                  body.emit(assign(r3CD8, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3CDC = bit_and(r3CD0, body.constant(4294901760u));
                  ir_expression *const r3CDD = equal(r3CDC, body.constant(0u));
                  ir_if *f3CDB = new(mem_ctx) ir_if(operand(r3CDD).val);
                  exec_list *const f3CDB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3CDB->then_instructions;

                     body.emit(assign(r3CD8, body.constant(int(16)), 0x01));

                     body.emit(assign(r3CD6, lshift(r3CD0, body.constant(int(16))), 0x01));


                  body.instructions = f3CDB_parent_instructions;
                  body.emit(f3CDB);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r3CDF = bit_and(r3CD6, body.constant(4278190080u));
                  ir_expression *const r3CE0 = equal(r3CDF, body.constant(0u));
                  ir_if *f3CDE = new(mem_ctx) ir_if(operand(r3CE0).val);
                  exec_list *const f3CDE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3CDE->then_instructions;

                     body.emit(assign(r3CD8, add(r3CD8, body.constant(int(8))), 0x01));

                     body.emit(assign(r3CD6, lshift(r3CD6, body.constant(int(8))), 0x01));


                  body.instructions = f3CDE_parent_instructions;
                  body.emit(f3CDE);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r3CE2 = bit_and(r3CD6, body.constant(4026531840u));
                  ir_expression *const r3CE3 = equal(r3CE2, body.constant(0u));
                  ir_if *f3CE1 = new(mem_ctx) ir_if(operand(r3CE3).val);
                  exec_list *const f3CE1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3CE1->then_instructions;

                     body.emit(assign(r3CD8, add(r3CD8, body.constant(int(4))), 0x01));

                     body.emit(assign(r3CD6, lshift(r3CD6, body.constant(int(4))), 0x01));


                  body.instructions = f3CE1_parent_instructions;
                  body.emit(f3CE1);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r3CE5 = bit_and(r3CD6, body.constant(3221225472u));
                  ir_expression *const r3CE6 = equal(r3CE5, body.constant(0u));
                  ir_if *f3CE4 = new(mem_ctx) ir_if(operand(r3CE6).val);
                  exec_list *const f3CE4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3CE4->then_instructions;

                     body.emit(assign(r3CD8, add(r3CD8, body.constant(int(2))), 0x01));

                     body.emit(assign(r3CD6, lshift(r3CD6, body.constant(int(2))), 0x01));


                  body.instructions = f3CE4_parent_instructions;
                  body.emit(f3CE4);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r3CE8 = bit_and(r3CD6, body.constant(2147483648u));
                  ir_expression *const r3CE9 = equal(r3CE8, body.constant(0u));
                  ir_if *f3CE7 = new(mem_ctx) ir_if(operand(r3CE9).val);
                  exec_list *const f3CE7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3CE7->then_instructions;

                     body.emit(assign(r3CD8, add(r3CD8, body.constant(int(1))), 0x01));


                  body.instructions = f3CE7_parent_instructions;
                  body.emit(f3CE7);

                  /* END IF */

                  body.emit(assign(r3CD7, r3CD8, 0x01));


               body.instructions = f3CD9_parent_instructions;
               body.emit(f3CD9);

               /* END IF */

               body.emit(assign(r3CD3, add(r3CD7, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3CEB = lequal(body.constant(int(0)), r3CD3);
               ir_if *f3CEA = new(mem_ctx) ir_if(operand(r3CEB).val);
               exec_list *const f3CEA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3CEA->then_instructions;

                  body.emit(assign(r3CD2, body.constant(0u), 0x01));

                  ir_variable *const r3CEC = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r3CEC, lshift(r3CD1, r3CD3), 0x01));

                  ir_variable *const r3CED = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3CEF = equal(r3CD3, body.constant(int(0)));
                  ir_if *f3CEE = new(mem_ctx) ir_if(operand(r3CEF).val);
                  exec_list *const f3CEE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3CEE->then_instructions;

                     body.emit(assign(r3CED, r3CD0, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3CEE->else_instructions;

                     ir_expression *const r3CF0 = lshift(r3CD0, r3CD3);
                     ir_expression *const r3CF1 = neg(r3CD3);
                     ir_expression *const r3CF2 = bit_and(r3CF1, body.constant(int(31)));
                     ir_expression *const r3CF3 = rshift(r3CD1, r3CF2);
                     body.emit(assign(r3CED, bit_or(r3CF0, r3CF3), 0x01));


                  body.instructions = f3CEE_parent_instructions;
                  body.emit(f3CEE);

                  /* END IF */

                  body.emit(assign(r3CD0, r3CED, 0x01));

                  body.emit(assign(r3CD1, r3CEC, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3CEA->else_instructions;

                  ir_variable *const r3CF4 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r3CF4, body.constant(0u), 0x01));

                  ir_variable *const r3CF5 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r3CF5, neg(r3CD3), 0x01));

                  ir_variable *const r3CF6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r3CF6);
                  ir_variable *const r3CF7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r3CF7);
                  ir_variable *const r3CF8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r3CF8);
                  ir_variable *const r3CF9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r3CFA = neg(r3CF5);
                  body.emit(assign(r3CF9, bit_and(r3CFA, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3CFC = equal(r3CF5, body.constant(int(0)));
                  ir_if *f3CFB = new(mem_ctx) ir_if(operand(r3CFC).val);
                  exec_list *const f3CFB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3CFB->then_instructions;

                     body.emit(assign(r3CF6, r3CF4, 0x01));

                     body.emit(assign(r3CF7, r3CD1, 0x01));

                     body.emit(assign(r3CF8, r3CD0, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3CFB->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3CFE = less(r3CF5, body.constant(int(32)));
                     ir_if *f3CFD = new(mem_ctx) ir_if(operand(r3CFE).val);
                     exec_list *const f3CFD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3CFD->then_instructions;

                        body.emit(assign(r3CF6, lshift(r3CD1, r3CF9), 0x01));

                        ir_expression *const r3CFF = lshift(r3CD0, r3CF9);
                        ir_expression *const r3D00 = rshift(r3CD1, r3CF5);
                        body.emit(assign(r3CF7, bit_or(r3CFF, r3D00), 0x01));

                        body.emit(assign(r3CF8, rshift(r3CD0, r3CF5), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3CFD->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3D02 = equal(r3CF5, body.constant(int(32)));
                        ir_if *f3D01 = new(mem_ctx) ir_if(operand(r3D02).val);
                        exec_list *const f3D01_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3D01->then_instructions;

                           body.emit(assign(r3CF6, r3CD1, 0x01));

                           body.emit(assign(r3CF7, r3CD0, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3D01->else_instructions;

                           body.emit(assign(r3CF4, bit_or(body.constant(0u), r3CD1), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3D04 = less(r3CF5, body.constant(int(64)));
                           ir_if *f3D03 = new(mem_ctx) ir_if(operand(r3D04).val);
                           exec_list *const f3D03_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3D03->then_instructions;

                              body.emit(assign(r3CF6, lshift(r3CD0, r3CF9), 0x01));

                              ir_expression *const r3D05 = bit_and(r3CF5, body.constant(int(31)));
                              body.emit(assign(r3CF7, rshift(r3CD0, r3D05), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3D03->else_instructions;

                              ir_variable *const r3D06 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r3D08 = equal(r3CF5, body.constant(int(64)));
                              ir_if *f3D07 = new(mem_ctx) ir_if(operand(r3D08).val);
                              exec_list *const f3D07_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3D07->then_instructions;

                                 body.emit(assign(r3D06, r3CD0, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3D07->else_instructions;

                                 ir_expression *const r3D09 = nequal(r3CD0, body.constant(0u));
                                 ir_expression *const r3D0A = expr(ir_unop_b2i, r3D09);
                                 body.emit(assign(r3D06, expr(ir_unop_i2u, r3D0A), 0x01));


                              body.instructions = f3D07_parent_instructions;
                              body.emit(f3D07);

                              /* END IF */

                              body.emit(assign(r3CF6, r3D06, 0x01));

                              body.emit(assign(r3CF7, body.constant(0u), 0x01));


                           body.instructions = f3D03_parent_instructions;
                           body.emit(f3D03);

                           /* END IF */


                        body.instructions = f3D01_parent_instructions;
                        body.emit(f3D01);

                        /* END IF */

                        body.emit(assign(r3CF8, body.constant(0u), 0x01));


                     body.instructions = f3CFD_parent_instructions;
                     body.emit(f3CFD);

                     /* END IF */

                     ir_expression *const r3D0B = nequal(r3CF4, body.constant(0u));
                     ir_expression *const r3D0C = expr(ir_unop_b2i, r3D0B);
                     ir_expression *const r3D0D = expr(ir_unop_i2u, r3D0C);
                     body.emit(assign(r3CF6, bit_or(r3CF6, r3D0D), 0x01));


                  body.instructions = f3CFB_parent_instructions;
                  body.emit(f3CFB);

                  /* END IF */

                  body.emit(assign(r3CD0, r3CF8, 0x01));

                  body.emit(assign(r3CD1, r3CF7, 0x01));

                  body.emit(assign(r3CD2, r3CF6, 0x01));


               body.instructions = f3CEA_parent_instructions;
               body.emit(f3CEA);

               /* END IF */

               body.emit(assign(r3CCF, sub(r3CCF, r3CD3), 0x01));

               ir_variable *const r3D0E = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r3D0E, r3CCF, 0x01));

               ir_variable *const r3D0F = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r3D0F, r3CD0, 0x01));

               ir_variable *const r3D10 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r3D10, r3CD1, 0x01));

               ir_variable *const r3D11 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r3D11, r3CD2, 0x01));

               ir_variable *const r3D12 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r3D12, body.constant(true), 0x01));

               ir_variable *const r3D13 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r3D14 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r3D14);
               ir_expression *const r3D15 = expr(ir_unop_u2i, r3CD2);
               body.emit(assign(r3D14, less(r3D15, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r3D17 = lequal(body.constant(int(2045)), r3CCF);
               ir_if *f3D16 = new(mem_ctx) ir_if(operand(r3D17).val);
               exec_list *const f3D16_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3D16->then_instructions;

                  ir_variable *const r3D18 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3D1A = less(body.constant(int(2045)), r3CCF);
                  ir_if *f3D19 = new(mem_ctx) ir_if(operand(r3D1A).val);
                  exec_list *const f3D19_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3D19->then_instructions;

                     body.emit(assign(r3D18, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3D19->else_instructions;

                     ir_variable *const r3D1B = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3D1D = equal(r3CCF, body.constant(int(2045)));
                     ir_if *f3D1C = new(mem_ctx) ir_if(operand(r3D1D).val);
                     exec_list *const f3D1C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3D1C->then_instructions;

                        ir_expression *const r3D1E = equal(body.constant(2097151u), r3CD0);
                        ir_expression *const r3D1F = equal(body.constant(4294967295u), r3CD1);
                        body.emit(assign(r3D1B, logic_and(r3D1E, r3D1F), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3D1C->else_instructions;

                        body.emit(assign(r3D1B, body.constant(false), 0x01));


                     body.instructions = f3D1C_parent_instructions;
                     body.emit(f3D1C);

                     /* END IF */

                     body.emit(assign(r3D18, logic_and(r3D1B, r3D14), 0x01));


                  body.instructions = f3D19_parent_instructions;
                  body.emit(f3D19);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f3D20 = new(mem_ctx) ir_if(operand(r3D18).val);
                  exec_list *const f3D20_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3D20->then_instructions;

                     ir_variable *const r3D21 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r3D21);
                     ir_expression *const r3D22 = lshift(r3B95, body.constant(int(31)));
                     body.emit(assign(r3D21, add(r3D22, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r3D21, body.constant(0u), 0x01));

                     body.emit(assign(r3D13, r3D21, 0x03));

                     body.emit(assign(r3D12, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3D20->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3D24 = less(r3CCF, body.constant(int(0)));
                     ir_if *f3D23 = new(mem_ctx) ir_if(operand(r3D24).val);
                     exec_list *const f3D23_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3D23->then_instructions;

                        ir_variable *const r3D25 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r3D25, r3CD2, 0x01));

                        ir_variable *const r3D26 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r3D26, neg(r3CCF), 0x01));

                        ir_variable *const r3D27 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r3D27);
                        ir_variable *const r3D28 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r3D28);
                        ir_variable *const r3D29 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r3D29);
                        ir_variable *const r3D2A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r3D2B = neg(r3D26);
                        body.emit(assign(r3D2A, bit_and(r3D2B, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3D2D = equal(r3D26, body.constant(int(0)));
                        ir_if *f3D2C = new(mem_ctx) ir_if(operand(r3D2D).val);
                        exec_list *const f3D2C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3D2C->then_instructions;

                           body.emit(assign(r3D27, r3CD2, 0x01));

                           body.emit(assign(r3D28, r3CD1, 0x01));

                           body.emit(assign(r3D29, r3CD0, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3D2C->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3D2F = less(r3D26, body.constant(int(32)));
                           ir_if *f3D2E = new(mem_ctx) ir_if(operand(r3D2F).val);
                           exec_list *const f3D2E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3D2E->then_instructions;

                              body.emit(assign(r3D27, lshift(r3CD1, r3D2A), 0x01));

                              ir_expression *const r3D30 = lshift(r3CD0, r3D2A);
                              ir_expression *const r3D31 = rshift(r3CD1, r3D26);
                              body.emit(assign(r3D28, bit_or(r3D30, r3D31), 0x01));

                              body.emit(assign(r3D29, rshift(r3CD0, r3D26), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3D2E->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3D33 = equal(r3D26, body.constant(int(32)));
                              ir_if *f3D32 = new(mem_ctx) ir_if(operand(r3D33).val);
                              exec_list *const f3D32_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3D32->then_instructions;

                                 body.emit(assign(r3D27, r3CD1, 0x01));

                                 body.emit(assign(r3D28, r3CD0, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3D32->else_instructions;

                                 body.emit(assign(r3D25, bit_or(r3CD2, r3CD1), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3D35 = less(r3D26, body.constant(int(64)));
                                 ir_if *f3D34 = new(mem_ctx) ir_if(operand(r3D35).val);
                                 exec_list *const f3D34_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3D34->then_instructions;

                                    body.emit(assign(r3D27, lshift(r3CD0, r3D2A), 0x01));

                                    ir_expression *const r3D36 = bit_and(r3D26, body.constant(int(31)));
                                    body.emit(assign(r3D28, rshift(r3CD0, r3D36), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3D34->else_instructions;

                                    ir_variable *const r3D37 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r3D39 = equal(r3D26, body.constant(int(64)));
                                    ir_if *f3D38 = new(mem_ctx) ir_if(operand(r3D39).val);
                                    exec_list *const f3D38_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3D38->then_instructions;

                                       body.emit(assign(r3D37, r3CD0, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3D38->else_instructions;

                                       ir_expression *const r3D3A = nequal(r3CD0, body.constant(0u));
                                       ir_expression *const r3D3B = expr(ir_unop_b2i, r3D3A);
                                       body.emit(assign(r3D37, expr(ir_unop_i2u, r3D3B), 0x01));


                                    body.instructions = f3D38_parent_instructions;
                                    body.emit(f3D38);

                                    /* END IF */

                                    body.emit(assign(r3D27, r3D37, 0x01));

                                    body.emit(assign(r3D28, body.constant(0u), 0x01));


                                 body.instructions = f3D34_parent_instructions;
                                 body.emit(f3D34);

                                 /* END IF */


                              body.instructions = f3D32_parent_instructions;
                              body.emit(f3D32);

                              /* END IF */

                              body.emit(assign(r3D29, body.constant(0u), 0x01));


                           body.instructions = f3D2E_parent_instructions;
                           body.emit(f3D2E);

                           /* END IF */

                           ir_expression *const r3D3C = nequal(r3D25, body.constant(0u));
                           ir_expression *const r3D3D = expr(ir_unop_b2i, r3D3C);
                           ir_expression *const r3D3E = expr(ir_unop_i2u, r3D3D);
                           body.emit(assign(r3D27, bit_or(r3D27, r3D3E), 0x01));


                        body.instructions = f3D2C_parent_instructions;
                        body.emit(f3D2C);

                        /* END IF */

                        body.emit(assign(r3D0F, r3D29, 0x01));

                        body.emit(assign(r3D10, r3D28, 0x01));

                        body.emit(assign(r3D11, r3D27, 0x01));

                        body.emit(assign(r3D0E, body.constant(int(0)), 0x01));

                        body.emit(assign(r3D14, less(r3D27, body.constant(0u)), 0x01));


                     body.instructions = f3D23_parent_instructions;
                     body.emit(f3D23);

                     /* END IF */


                  body.instructions = f3D20_parent_instructions;
                  body.emit(f3D20);

                  /* END IF */


               body.instructions = f3D16_parent_instructions;
               body.emit(f3D16);

               /* END IF */

               /* IF CONDITION */
               ir_if *f3D3F = new(mem_ctx) ir_if(operand(r3D12).val);
               exec_list *const f3D3F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3D3F->then_instructions;

                  /* IF CONDITION */
                  ir_if *f3D40 = new(mem_ctx) ir_if(operand(r3D14).val);
                  exec_list *const f3D40_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3D40->then_instructions;

                     ir_variable *const r3D41 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r3D41, add(r3D10, body.constant(1u)), 0x01));

                     ir_expression *const r3D42 = less(r3D41, r3D10);
                     ir_expression *const r3D43 = expr(ir_unop_b2i, r3D42);
                     ir_expression *const r3D44 = expr(ir_unop_i2u, r3D43);
                     body.emit(assign(r3D0F, add(r3D0F, r3D44), 0x01));

                     ir_expression *const r3D45 = equal(r3D11, body.constant(0u));
                     ir_expression *const r3D46 = expr(ir_unop_b2i, r3D45);
                     ir_expression *const r3D47 = expr(ir_unop_i2u, r3D46);
                     ir_expression *const r3D48 = add(r3D11, r3D47);
                     ir_expression *const r3D49 = bit_and(r3D48, body.constant(1u));
                     ir_expression *const r3D4A = expr(ir_unop_bit_not, r3D49);
                     body.emit(assign(r3D10, bit_and(r3D41, r3D4A), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3D40->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3D4C = bit_or(r3D0F, r3D10);
                     ir_expression *const r3D4D = equal(r3D4C, body.constant(0u));
                     ir_if *f3D4B = new(mem_ctx) ir_if(operand(r3D4D).val);
                     exec_list *const f3D4B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3D4B->then_instructions;

                        body.emit(assign(r3D0E, body.constant(int(0)), 0x01));


                     body.instructions = f3D4B_parent_instructions;
                     body.emit(f3D4B);

                     /* END IF */


                  body.instructions = f3D40_parent_instructions;
                  body.emit(f3D40);

                  /* END IF */

                  ir_variable *const r3D4E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3D4E);
                  ir_expression *const r3D4F = lshift(r3B95, body.constant(int(31)));
                  ir_expression *const r3D50 = expr(ir_unop_i2u, r3D0E);
                  ir_expression *const r3D51 = lshift(r3D50, body.constant(int(20)));
                  ir_expression *const r3D52 = add(r3D4F, r3D51);
                  body.emit(assign(r3D4E, add(r3D52, r3D0F), 0x02));

                  body.emit(assign(r3D4E, r3D10, 0x01));

                  body.emit(assign(r3D13, r3D4E, 0x03));

                  body.emit(assign(r3D12, body.constant(false), 0x01));


               body.instructions = f3D3F_parent_instructions;
               body.emit(f3D3F);

               /* END IF */

               body.emit(assign(r3B96, r3D13, 0x03));


            body.instructions = f3C81_parent_instructions;
            body.emit(f3C81);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3C7F->else_instructions;

            /* IF CONDITION */
            ir_expression *const r3D54 = equal(r3B9F, body.constant(int(2047)));
            ir_if *f3D53 = new(mem_ctx) ir_if(operand(r3D54).val);
            exec_list *const f3D53_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3D53->then_instructions;

               /* IF CONDITION */
               ir_expression *const r3D56 = bit_or(r3B9C, r3B9D);
               ir_expression *const r3D57 = bit_or(r3B9A, r3B9B);
               ir_expression *const r3D58 = bit_or(r3D56, r3D57);
               ir_expression *const r3D59 = nequal(r3D58, body.constant(0u));
               ir_if *f3D55 = new(mem_ctx) ir_if(operand(r3D59).val);
               exec_list *const f3D55_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3D55->then_instructions;

                  ir_variable *const r3D5A = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r3D5A, swizzle_x(r321E), 0x01));

                  ir_variable *const r3D5B = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r3D5B, swizzle_x(r39DE), 0x01));

                  ir_variable *const r3D5C = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r3D5D = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r3D5E = rshift(swizzle_y(r321E), body.constant(int(19)));
                  ir_expression *const r3D5F = bit_and(r3D5E, body.constant(4095u));
                  ir_expression *const r3D60 = equal(r3D5F, body.constant(4094u));
                  ir_expression *const r3D61 = nequal(swizzle_x(r321E), body.constant(0u));
                  ir_expression *const r3D62 = bit_and(swizzle_y(r321E), body.constant(524287u));
                  ir_expression *const r3D63 = nequal(r3D62, body.constant(0u));
                  ir_expression *const r3D64 = logic_or(r3D61, r3D63);
                  body.emit(assign(r3D5D, logic_and(r3D60, r3D64), 0x01));

                  ir_variable *const r3D65 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r3D66 = lshift(swizzle_y(r39DE), body.constant(int(1)));
                  ir_expression *const r3D67 = lequal(body.constant(4292870144u), r3D66);
                  ir_expression *const r3D68 = nequal(swizzle_x(r39DE), body.constant(0u));
                  ir_expression *const r3D69 = bit_and(swizzle_y(r39DE), body.constant(1048575u));
                  ir_expression *const r3D6A = nequal(r3D69, body.constant(0u));
                  ir_expression *const r3D6B = logic_or(r3D68, r3D6A);
                  body.emit(assign(r3D65, logic_and(r3D67, r3D6B), 0x01));

                  body.emit(assign(r3D5A, bit_or(swizzle_y(r321E), body.constant(524288u)), 0x02));

                  body.emit(assign(r3D5B, bit_or(swizzle_y(r39DE), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r3D6D = lshift(swizzle_y(r321E), body.constant(int(1)));
                  ir_expression *const r3D6E = lequal(body.constant(4292870144u), r3D6D);
                  ir_expression *const r3D6F = nequal(swizzle_x(r321E), body.constant(0u));
                  ir_expression *const r3D70 = bit_and(swizzle_y(r321E), body.constant(1048575u));
                  ir_expression *const r3D71 = nequal(r3D70, body.constant(0u));
                  ir_expression *const r3D72 = logic_or(r3D6F, r3D71);
                  ir_expression *const r3D73 = logic_and(r3D6E, r3D72);
                  ir_if *f3D6C = new(mem_ctx) ir_if(operand(r3D73).val);
                  exec_list *const f3D6C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3D6C->then_instructions;

                     ir_variable *const r3D74 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3D76 = logic_and(r3D5D, r3D65);
                     ir_if *f3D75 = new(mem_ctx) ir_if(operand(r3D76).val);
                     exec_list *const f3D75_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3D75->then_instructions;

                        body.emit(assign(r3D74, r3D5B, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3D75->else_instructions;

                        body.emit(assign(r3D74, r3D5A, 0x03));


                     body.instructions = f3D75_parent_instructions;
                     body.emit(f3D75);

                     /* END IF */

                     body.emit(assign(r3D5C, r3D74, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3D6C->else_instructions;

                     body.emit(assign(r3D5C, r3D5B, 0x03));


                  body.instructions = f3D6C_parent_instructions;
                  body.emit(f3D6C);

                  /* END IF */

                  body.emit(assign(r3B96, r3D5C, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3D55->else_instructions;

                  ir_constant_data r3D77_data;
                  memset(&r3D77_data, 0, sizeof(ir_constant_data));
                  r3D77_data.u[0] = 4294967295;
                  r3D77_data.u[1] = 4294967295;
                  ir_constant *const r3D77 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r3D77_data);
                  body.emit(assign(r3B96, r3D77, 0x03));


               body.instructions = f3D55_parent_instructions;
               body.emit(f3D55);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3D53->else_instructions;

               /* IF CONDITION */
               ir_expression *const r3D79 = equal(r3B9F, body.constant(int(0)));
               ir_if *f3D78 = new(mem_ctx) ir_if(operand(r3D79).val);
               exec_list *const f3D78_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3D78->then_instructions;

                  body.emit(assign(r3B99, body.constant(int(1)), 0x01));

                  body.emit(assign(r3B98, body.constant(int(1)), 0x01));


               body.instructions = f3D78_parent_instructions;
               body.emit(f3D78);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r3D7B = less(r3B9A, r3B9C);
               ir_if *f3D7A = new(mem_ctx) ir_if(operand(r3D7B).val);
               exec_list *const f3D7A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3D7A->then_instructions;

                  ir_variable *const r3D7C = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r3D7D = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r3D7D, sub(r3B9D, r3B9B), 0x01));

                  ir_expression *const r3D7E = sub(r3B9C, r3B9A);
                  ir_expression *const r3D7F = less(r3B9D, r3B9B);
                  ir_expression *const r3D80 = expr(ir_unop_b2i, r3D7F);
                  ir_expression *const r3D81 = expr(ir_unop_i2u, r3D80);
                  body.emit(assign(r3D7C, sub(r3D7E, r3D81), 0x01));

                  body.emit(assign(r3B9E, add(r3B99, body.constant(int(-1))), 0x01));

                  ir_variable *const r3D82 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r3D82, add(r3B9E, body.constant(int(-10))), 0x01));

                  ir_variable *const r3D83 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r3D83, r3D7C, 0x01));

                  ir_variable *const r3D84 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r3D84, r3D7D, 0x01));

                  ir_variable *const r3D85 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r3D85);
                  ir_variable *const r3D86 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r3D86);
                  /* IF CONDITION */
                  ir_expression *const r3D88 = equal(r3D7C, body.constant(0u));
                  ir_if *f3D87 = new(mem_ctx) ir_if(operand(r3D88).val);
                  exec_list *const f3D87_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3D87->then_instructions;

                     body.emit(assign(r3D83, r3D7D, 0x01));

                     body.emit(assign(r3D84, body.constant(0u), 0x01));

                     body.emit(assign(r3D82, add(r3D82, body.constant(int(-32))), 0x01));


                  body.instructions = f3D87_parent_instructions;
                  body.emit(f3D87);

                  /* END IF */

                  ir_variable *const r3D89 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r3D89, r3D83, 0x01));

                  ir_variable *const r3D8A = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r3D8B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r3D8B);
                  /* IF CONDITION */
                  ir_expression *const r3D8D = equal(r3D83, body.constant(0u));
                  ir_if *f3D8C = new(mem_ctx) ir_if(operand(r3D8D).val);
                  exec_list *const f3D8C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3D8C->then_instructions;

                     body.emit(assign(r3D8A, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3D8C->else_instructions;

                     body.emit(assign(r3D8B, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3D8F = bit_and(r3D83, body.constant(4294901760u));
                     ir_expression *const r3D90 = equal(r3D8F, body.constant(0u));
                     ir_if *f3D8E = new(mem_ctx) ir_if(operand(r3D90).val);
                     exec_list *const f3D8E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3D8E->then_instructions;

                        body.emit(assign(r3D8B, body.constant(int(16)), 0x01));

                        body.emit(assign(r3D89, lshift(r3D83, body.constant(int(16))), 0x01));


                     body.instructions = f3D8E_parent_instructions;
                     body.emit(f3D8E);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3D92 = bit_and(r3D89, body.constant(4278190080u));
                     ir_expression *const r3D93 = equal(r3D92, body.constant(0u));
                     ir_if *f3D91 = new(mem_ctx) ir_if(operand(r3D93).val);
                     exec_list *const f3D91_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3D91->then_instructions;

                        body.emit(assign(r3D8B, add(r3D8B, body.constant(int(8))), 0x01));

                        body.emit(assign(r3D89, lshift(r3D89, body.constant(int(8))), 0x01));


                     body.instructions = f3D91_parent_instructions;
                     body.emit(f3D91);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3D95 = bit_and(r3D89, body.constant(4026531840u));
                     ir_expression *const r3D96 = equal(r3D95, body.constant(0u));
                     ir_if *f3D94 = new(mem_ctx) ir_if(operand(r3D96).val);
                     exec_list *const f3D94_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3D94->then_instructions;

                        body.emit(assign(r3D8B, add(r3D8B, body.constant(int(4))), 0x01));

                        body.emit(assign(r3D89, lshift(r3D89, body.constant(int(4))), 0x01));


                     body.instructions = f3D94_parent_instructions;
                     body.emit(f3D94);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3D98 = bit_and(r3D89, body.constant(3221225472u));
                     ir_expression *const r3D99 = equal(r3D98, body.constant(0u));
                     ir_if *f3D97 = new(mem_ctx) ir_if(operand(r3D99).val);
                     exec_list *const f3D97_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3D97->then_instructions;

                        body.emit(assign(r3D8B, add(r3D8B, body.constant(int(2))), 0x01));

                        body.emit(assign(r3D89, lshift(r3D89, body.constant(int(2))), 0x01));


                     body.instructions = f3D97_parent_instructions;
                     body.emit(f3D97);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3D9B = bit_and(r3D89, body.constant(2147483648u));
                     ir_expression *const r3D9C = equal(r3D9B, body.constant(0u));
                     ir_if *f3D9A = new(mem_ctx) ir_if(operand(r3D9C).val);
                     exec_list *const f3D9A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3D9A->then_instructions;

                        body.emit(assign(r3D8B, add(r3D8B, body.constant(int(1))), 0x01));


                     body.instructions = f3D9A_parent_instructions;
                     body.emit(f3D9A);

                     /* END IF */

                     body.emit(assign(r3D8A, r3D8B, 0x01));


                  body.instructions = f3D8C_parent_instructions;
                  body.emit(f3D8C);

                  /* END IF */

                  body.emit(assign(r3D86, add(r3D8A, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3D9E = lequal(body.constant(int(0)), r3D86);
                  ir_if *f3D9D = new(mem_ctx) ir_if(operand(r3D9E).val);
                  exec_list *const f3D9D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3D9D->then_instructions;

                     body.emit(assign(r3D85, body.constant(0u), 0x01));

                     ir_variable *const r3D9F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r3D9F, lshift(r3D84, r3D86), 0x01));

                     ir_variable *const r3DA0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3DA2 = equal(r3D86, body.constant(int(0)));
                     ir_if *f3DA1 = new(mem_ctx) ir_if(operand(r3DA2).val);
                     exec_list *const f3DA1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3DA1->then_instructions;

                        body.emit(assign(r3DA0, r3D83, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3DA1->else_instructions;

                        ir_expression *const r3DA3 = lshift(r3D83, r3D86);
                        ir_expression *const r3DA4 = neg(r3D86);
                        ir_expression *const r3DA5 = bit_and(r3DA4, body.constant(int(31)));
                        ir_expression *const r3DA6 = rshift(r3D84, r3DA5);
                        body.emit(assign(r3DA0, bit_or(r3DA3, r3DA6), 0x01));


                     body.instructions = f3DA1_parent_instructions;
                     body.emit(f3DA1);

                     /* END IF */

                     body.emit(assign(r3D83, r3DA0, 0x01));

                     body.emit(assign(r3D84, r3D9F, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3D9D->else_instructions;

                     ir_variable *const r3DA7 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r3DA7, body.constant(0u), 0x01));

                     ir_variable *const r3DA8 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r3DA8, neg(r3D86), 0x01));

                     ir_variable *const r3DA9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r3DA9);
                     ir_variable *const r3DAA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r3DAA);
                     ir_variable *const r3DAB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r3DAB);
                     ir_variable *const r3DAC = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r3DAD = neg(r3DA8);
                     body.emit(assign(r3DAC, bit_and(r3DAD, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3DAF = equal(r3DA8, body.constant(int(0)));
                     ir_if *f3DAE = new(mem_ctx) ir_if(operand(r3DAF).val);
                     exec_list *const f3DAE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3DAE->then_instructions;

                        body.emit(assign(r3DA9, r3DA7, 0x01));

                        body.emit(assign(r3DAA, r3D84, 0x01));

                        body.emit(assign(r3DAB, r3D83, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3DAE->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3DB1 = less(r3DA8, body.constant(int(32)));
                        ir_if *f3DB0 = new(mem_ctx) ir_if(operand(r3DB1).val);
                        exec_list *const f3DB0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3DB0->then_instructions;

                           body.emit(assign(r3DA9, lshift(r3D84, r3DAC), 0x01));

                           ir_expression *const r3DB2 = lshift(r3D83, r3DAC);
                           ir_expression *const r3DB3 = rshift(r3D84, r3DA8);
                           body.emit(assign(r3DAA, bit_or(r3DB2, r3DB3), 0x01));

                           body.emit(assign(r3DAB, rshift(r3D83, r3DA8), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3DB0->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3DB5 = equal(r3DA8, body.constant(int(32)));
                           ir_if *f3DB4 = new(mem_ctx) ir_if(operand(r3DB5).val);
                           exec_list *const f3DB4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3DB4->then_instructions;

                              body.emit(assign(r3DA9, r3D84, 0x01));

                              body.emit(assign(r3DAA, r3D83, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3DB4->else_instructions;

                              body.emit(assign(r3DA7, bit_or(body.constant(0u), r3D84), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3DB7 = less(r3DA8, body.constant(int(64)));
                              ir_if *f3DB6 = new(mem_ctx) ir_if(operand(r3DB7).val);
                              exec_list *const f3DB6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3DB6->then_instructions;

                                 body.emit(assign(r3DA9, lshift(r3D83, r3DAC), 0x01));

                                 ir_expression *const r3DB8 = bit_and(r3DA8, body.constant(int(31)));
                                 body.emit(assign(r3DAA, rshift(r3D83, r3DB8), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3DB6->else_instructions;

                                 ir_variable *const r3DB9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r3DBB = equal(r3DA8, body.constant(int(64)));
                                 ir_if *f3DBA = new(mem_ctx) ir_if(operand(r3DBB).val);
                                 exec_list *const f3DBA_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3DBA->then_instructions;

                                    body.emit(assign(r3DB9, r3D83, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3DBA->else_instructions;

                                    ir_expression *const r3DBC = nequal(r3D83, body.constant(0u));
                                    ir_expression *const r3DBD = expr(ir_unop_b2i, r3DBC);
                                    body.emit(assign(r3DB9, expr(ir_unop_i2u, r3DBD), 0x01));


                                 body.instructions = f3DBA_parent_instructions;
                                 body.emit(f3DBA);

                                 /* END IF */

                                 body.emit(assign(r3DA9, r3DB9, 0x01));

                                 body.emit(assign(r3DAA, body.constant(0u), 0x01));


                              body.instructions = f3DB6_parent_instructions;
                              body.emit(f3DB6);

                              /* END IF */


                           body.instructions = f3DB4_parent_instructions;
                           body.emit(f3DB4);

                           /* END IF */

                           body.emit(assign(r3DAB, body.constant(0u), 0x01));


                        body.instructions = f3DB0_parent_instructions;
                        body.emit(f3DB0);

                        /* END IF */

                        ir_expression *const r3DBE = nequal(r3DA7, body.constant(0u));
                        ir_expression *const r3DBF = expr(ir_unop_b2i, r3DBE);
                        ir_expression *const r3DC0 = expr(ir_unop_i2u, r3DBF);
                        body.emit(assign(r3DA9, bit_or(r3DA9, r3DC0), 0x01));


                     body.instructions = f3DAE_parent_instructions;
                     body.emit(f3DAE);

                     /* END IF */

                     body.emit(assign(r3D83, r3DAB, 0x01));

                     body.emit(assign(r3D84, r3DAA, 0x01));

                     body.emit(assign(r3D85, r3DA9, 0x01));


                  body.instructions = f3D9D_parent_instructions;
                  body.emit(f3D9D);

                  /* END IF */

                  body.emit(assign(r3D82, sub(r3D82, r3D86), 0x01));

                  ir_variable *const r3DC1 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r3DC1, r3D82, 0x01));

                  ir_variable *const r3DC2 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r3DC2, r3D83, 0x01));

                  ir_variable *const r3DC3 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r3DC3, r3D84, 0x01));

                  ir_variable *const r3DC4 = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r3DC4, r3D85, 0x01));

                  ir_variable *const r3DC5 = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r3DC5, body.constant(true), 0x01));

                  ir_variable *const r3DC6 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r3DC7 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r3DC7);
                  ir_expression *const r3DC8 = expr(ir_unop_u2i, r3D85);
                  body.emit(assign(r3DC7, less(r3DC8, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3DCA = lequal(body.constant(int(2045)), r3D82);
                  ir_if *f3DC9 = new(mem_ctx) ir_if(operand(r3DCA).val);
                  exec_list *const f3DC9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3DC9->then_instructions;

                     ir_variable *const r3DCB = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3DCD = less(body.constant(int(2045)), r3D82);
                     ir_if *f3DCC = new(mem_ctx) ir_if(operand(r3DCD).val);
                     exec_list *const f3DCC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3DCC->then_instructions;

                        body.emit(assign(r3DCB, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3DCC->else_instructions;

                        ir_variable *const r3DCE = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r3DD0 = equal(r3D82, body.constant(int(2045)));
                        ir_if *f3DCF = new(mem_ctx) ir_if(operand(r3DD0).val);
                        exec_list *const f3DCF_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3DCF->then_instructions;

                           ir_expression *const r3DD1 = equal(body.constant(2097151u), r3D83);
                           ir_expression *const r3DD2 = equal(body.constant(4294967295u), r3D84);
                           body.emit(assign(r3DCE, logic_and(r3DD1, r3DD2), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3DCF->else_instructions;

                           body.emit(assign(r3DCE, body.constant(false), 0x01));


                        body.instructions = f3DCF_parent_instructions;
                        body.emit(f3DCF);

                        /* END IF */

                        body.emit(assign(r3DCB, logic_and(r3DCE, r3DC7), 0x01));


                     body.instructions = f3DCC_parent_instructions;
                     body.emit(f3DCC);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f3DD3 = new(mem_ctx) ir_if(operand(r3DCB).val);
                     exec_list *const f3DD3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3DD3->then_instructions;

                        ir_variable *const r3DD4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r3DD4);
                        ir_expression *const r3DD5 = lshift(r3B95, body.constant(int(31)));
                        body.emit(assign(r3DD4, add(r3DD5, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r3DD4, body.constant(0u), 0x01));

                        body.emit(assign(r3DC6, r3DD4, 0x03));

                        body.emit(assign(r3DC5, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3DD3->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3DD7 = less(r3D82, body.constant(int(0)));
                        ir_if *f3DD6 = new(mem_ctx) ir_if(operand(r3DD7).val);
                        exec_list *const f3DD6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3DD6->then_instructions;

                           ir_variable *const r3DD8 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r3DD8, r3D85, 0x01));

                           ir_variable *const r3DD9 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r3DD9, neg(r3D82), 0x01));

                           ir_variable *const r3DDA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r3DDA);
                           ir_variable *const r3DDB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r3DDB);
                           ir_variable *const r3DDC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r3DDC);
                           ir_variable *const r3DDD = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r3DDE = neg(r3DD9);
                           body.emit(assign(r3DDD, bit_and(r3DDE, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3DE0 = equal(r3DD9, body.constant(int(0)));
                           ir_if *f3DDF = new(mem_ctx) ir_if(operand(r3DE0).val);
                           exec_list *const f3DDF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3DDF->then_instructions;

                              body.emit(assign(r3DDA, r3D85, 0x01));

                              body.emit(assign(r3DDB, r3D84, 0x01));

                              body.emit(assign(r3DDC, r3D83, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3DDF->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3DE2 = less(r3DD9, body.constant(int(32)));
                              ir_if *f3DE1 = new(mem_ctx) ir_if(operand(r3DE2).val);
                              exec_list *const f3DE1_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3DE1->then_instructions;

                                 body.emit(assign(r3DDA, lshift(r3D84, r3DDD), 0x01));

                                 ir_expression *const r3DE3 = lshift(r3D83, r3DDD);
                                 ir_expression *const r3DE4 = rshift(r3D84, r3DD9);
                                 body.emit(assign(r3DDB, bit_or(r3DE3, r3DE4), 0x01));

                                 body.emit(assign(r3DDC, rshift(r3D83, r3DD9), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3DE1->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3DE6 = equal(r3DD9, body.constant(int(32)));
                                 ir_if *f3DE5 = new(mem_ctx) ir_if(operand(r3DE6).val);
                                 exec_list *const f3DE5_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3DE5->then_instructions;

                                    body.emit(assign(r3DDA, r3D84, 0x01));

                                    body.emit(assign(r3DDB, r3D83, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3DE5->else_instructions;

                                    body.emit(assign(r3DD8, bit_or(r3D85, r3D84), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r3DE8 = less(r3DD9, body.constant(int(64)));
                                    ir_if *f3DE7 = new(mem_ctx) ir_if(operand(r3DE8).val);
                                    exec_list *const f3DE7_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3DE7->then_instructions;

                                       body.emit(assign(r3DDA, lshift(r3D83, r3DDD), 0x01));

                                       ir_expression *const r3DE9 = bit_and(r3DD9, body.constant(int(31)));
                                       body.emit(assign(r3DDB, rshift(r3D83, r3DE9), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3DE7->else_instructions;

                                       ir_variable *const r3DEA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r3DEC = equal(r3DD9, body.constant(int(64)));
                                       ir_if *f3DEB = new(mem_ctx) ir_if(operand(r3DEC).val);
                                       exec_list *const f3DEB_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3DEB->then_instructions;

                                          body.emit(assign(r3DEA, r3D83, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3DEB->else_instructions;

                                          ir_expression *const r3DED = nequal(r3D83, body.constant(0u));
                                          ir_expression *const r3DEE = expr(ir_unop_b2i, r3DED);
                                          body.emit(assign(r3DEA, expr(ir_unop_i2u, r3DEE), 0x01));


                                       body.instructions = f3DEB_parent_instructions;
                                       body.emit(f3DEB);

                                       /* END IF */

                                       body.emit(assign(r3DDA, r3DEA, 0x01));

                                       body.emit(assign(r3DDB, body.constant(0u), 0x01));


                                    body.instructions = f3DE7_parent_instructions;
                                    body.emit(f3DE7);

                                    /* END IF */


                                 body.instructions = f3DE5_parent_instructions;
                                 body.emit(f3DE5);

                                 /* END IF */

                                 body.emit(assign(r3DDC, body.constant(0u), 0x01));


                              body.instructions = f3DE1_parent_instructions;
                              body.emit(f3DE1);

                              /* END IF */

                              ir_expression *const r3DEF = nequal(r3DD8, body.constant(0u));
                              ir_expression *const r3DF0 = expr(ir_unop_b2i, r3DEF);
                              ir_expression *const r3DF1 = expr(ir_unop_i2u, r3DF0);
                              body.emit(assign(r3DDA, bit_or(r3DDA, r3DF1), 0x01));


                           body.instructions = f3DDF_parent_instructions;
                           body.emit(f3DDF);

                           /* END IF */

                           body.emit(assign(r3DC2, r3DDC, 0x01));

                           body.emit(assign(r3DC3, r3DDB, 0x01));

                           body.emit(assign(r3DC4, r3DDA, 0x01));

                           body.emit(assign(r3DC1, body.constant(int(0)), 0x01));

                           body.emit(assign(r3DC7, less(r3DDA, body.constant(0u)), 0x01));


                        body.instructions = f3DD6_parent_instructions;
                        body.emit(f3DD6);

                        /* END IF */


                     body.instructions = f3DD3_parent_instructions;
                     body.emit(f3DD3);

                     /* END IF */


                  body.instructions = f3DC9_parent_instructions;
                  body.emit(f3DC9);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f3DF2 = new(mem_ctx) ir_if(operand(r3DC5).val);
                  exec_list *const f3DF2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3DF2->then_instructions;

                     /* IF CONDITION */
                     ir_if *f3DF3 = new(mem_ctx) ir_if(operand(r3DC7).val);
                     exec_list *const f3DF3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3DF3->then_instructions;

                        ir_variable *const r3DF4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r3DF4, add(r3DC3, body.constant(1u)), 0x01));

                        ir_expression *const r3DF5 = less(r3DF4, r3DC3);
                        ir_expression *const r3DF6 = expr(ir_unop_b2i, r3DF5);
                        ir_expression *const r3DF7 = expr(ir_unop_i2u, r3DF6);
                        body.emit(assign(r3DC2, add(r3DC2, r3DF7), 0x01));

                        ir_expression *const r3DF8 = equal(r3DC4, body.constant(0u));
                        ir_expression *const r3DF9 = expr(ir_unop_b2i, r3DF8);
                        ir_expression *const r3DFA = expr(ir_unop_i2u, r3DF9);
                        ir_expression *const r3DFB = add(r3DC4, r3DFA);
                        ir_expression *const r3DFC = bit_and(r3DFB, body.constant(1u));
                        ir_expression *const r3DFD = expr(ir_unop_bit_not, r3DFC);
                        body.emit(assign(r3DC3, bit_and(r3DF4, r3DFD), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3DF3->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3DFF = bit_or(r3DC2, r3DC3);
                        ir_expression *const r3E00 = equal(r3DFF, body.constant(0u));
                        ir_if *f3DFE = new(mem_ctx) ir_if(operand(r3E00).val);
                        exec_list *const f3DFE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3DFE->then_instructions;

                           body.emit(assign(r3DC1, body.constant(int(0)), 0x01));


                        body.instructions = f3DFE_parent_instructions;
                        body.emit(f3DFE);

                        /* END IF */


                     body.instructions = f3DF3_parent_instructions;
                     body.emit(f3DF3);

                     /* END IF */

                     ir_variable *const r3E01 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r3E01);
                     ir_expression *const r3E02 = lshift(r3B95, body.constant(int(31)));
                     ir_expression *const r3E03 = expr(ir_unop_i2u, r3DC1);
                     ir_expression *const r3E04 = lshift(r3E03, body.constant(int(20)));
                     ir_expression *const r3E05 = add(r3E02, r3E04);
                     body.emit(assign(r3E01, add(r3E05, r3DC2), 0x02));

                     body.emit(assign(r3E01, r3DC3, 0x01));

                     body.emit(assign(r3DC6, r3E01, 0x03));

                     body.emit(assign(r3DC5, body.constant(false), 0x01));


                  body.instructions = f3DF2_parent_instructions;
                  body.emit(f3DF2);

                  /* END IF */

                  body.emit(assign(r3B96, r3DC6, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3D7A->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3E07 = less(r3B9C, r3B9A);
                  ir_if *f3E06 = new(mem_ctx) ir_if(operand(r3E07).val);
                  exec_list *const f3E06_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3E06->then_instructions;

                     ir_variable *const r3E08 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r3E09 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r3E09, sub(r3B9B, r3B9D), 0x01));

                     ir_expression *const r3E0A = sub(r3B9A, r3B9C);
                     ir_expression *const r3E0B = less(r3B9B, r3B9D);
                     ir_expression *const r3E0C = expr(ir_unop_b2i, r3E0B);
                     ir_expression *const r3E0D = expr(ir_unop_i2u, r3E0C);
                     body.emit(assign(r3E08, sub(r3E0A, r3E0D), 0x01));

                     body.emit(assign(r3B95, bit_xor(r3B95, body.constant(1u)), 0x01));

                     body.emit(assign(r3B9E, add(r3B98, body.constant(int(-1))), 0x01));

                     ir_variable *const r3E0E = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r3E0E, add(r3B9E, body.constant(int(-10))), 0x01));

                     ir_variable *const r3E0F = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r3E0F, r3E08, 0x01));

                     ir_variable *const r3E10 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r3E10, r3E09, 0x01));

                     ir_variable *const r3E11 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r3E11);
                     ir_variable *const r3E12 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r3E12);
                     /* IF CONDITION */
                     ir_expression *const r3E14 = equal(r3E08, body.constant(0u));
                     ir_if *f3E13 = new(mem_ctx) ir_if(operand(r3E14).val);
                     exec_list *const f3E13_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3E13->then_instructions;

                        body.emit(assign(r3E0F, r3E09, 0x01));

                        body.emit(assign(r3E10, body.constant(0u), 0x01));

                        body.emit(assign(r3E0E, add(r3E0E, body.constant(int(-32))), 0x01));


                     body.instructions = f3E13_parent_instructions;
                     body.emit(f3E13);

                     /* END IF */

                     ir_variable *const r3E15 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r3E15, r3E0F, 0x01));

                     ir_variable *const r3E16 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r3E17 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r3E17);
                     /* IF CONDITION */
                     ir_expression *const r3E19 = equal(r3E0F, body.constant(0u));
                     ir_if *f3E18 = new(mem_ctx) ir_if(operand(r3E19).val);
                     exec_list *const f3E18_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3E18->then_instructions;

                        body.emit(assign(r3E16, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3E18->else_instructions;

                        body.emit(assign(r3E17, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3E1B = bit_and(r3E0F, body.constant(4294901760u));
                        ir_expression *const r3E1C = equal(r3E1B, body.constant(0u));
                        ir_if *f3E1A = new(mem_ctx) ir_if(operand(r3E1C).val);
                        exec_list *const f3E1A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3E1A->then_instructions;

                           body.emit(assign(r3E17, body.constant(int(16)), 0x01));

                           body.emit(assign(r3E15, lshift(r3E0F, body.constant(int(16))), 0x01));


                        body.instructions = f3E1A_parent_instructions;
                        body.emit(f3E1A);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3E1E = bit_and(r3E15, body.constant(4278190080u));
                        ir_expression *const r3E1F = equal(r3E1E, body.constant(0u));
                        ir_if *f3E1D = new(mem_ctx) ir_if(operand(r3E1F).val);
                        exec_list *const f3E1D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3E1D->then_instructions;

                           body.emit(assign(r3E17, add(r3E17, body.constant(int(8))), 0x01));

                           body.emit(assign(r3E15, lshift(r3E15, body.constant(int(8))), 0x01));


                        body.instructions = f3E1D_parent_instructions;
                        body.emit(f3E1D);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3E21 = bit_and(r3E15, body.constant(4026531840u));
                        ir_expression *const r3E22 = equal(r3E21, body.constant(0u));
                        ir_if *f3E20 = new(mem_ctx) ir_if(operand(r3E22).val);
                        exec_list *const f3E20_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3E20->then_instructions;

                           body.emit(assign(r3E17, add(r3E17, body.constant(int(4))), 0x01));

                           body.emit(assign(r3E15, lshift(r3E15, body.constant(int(4))), 0x01));


                        body.instructions = f3E20_parent_instructions;
                        body.emit(f3E20);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3E24 = bit_and(r3E15, body.constant(3221225472u));
                        ir_expression *const r3E25 = equal(r3E24, body.constant(0u));
                        ir_if *f3E23 = new(mem_ctx) ir_if(operand(r3E25).val);
                        exec_list *const f3E23_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3E23->then_instructions;

                           body.emit(assign(r3E17, add(r3E17, body.constant(int(2))), 0x01));

                           body.emit(assign(r3E15, lshift(r3E15, body.constant(int(2))), 0x01));


                        body.instructions = f3E23_parent_instructions;
                        body.emit(f3E23);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r3E27 = bit_and(r3E15, body.constant(2147483648u));
                        ir_expression *const r3E28 = equal(r3E27, body.constant(0u));
                        ir_if *f3E26 = new(mem_ctx) ir_if(operand(r3E28).val);
                        exec_list *const f3E26_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3E26->then_instructions;

                           body.emit(assign(r3E17, add(r3E17, body.constant(int(1))), 0x01));


                        body.instructions = f3E26_parent_instructions;
                        body.emit(f3E26);

                        /* END IF */

                        body.emit(assign(r3E16, r3E17, 0x01));


                     body.instructions = f3E18_parent_instructions;
                     body.emit(f3E18);

                     /* END IF */

                     body.emit(assign(r3E12, add(r3E16, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3E2A = lequal(body.constant(int(0)), r3E12);
                     ir_if *f3E29 = new(mem_ctx) ir_if(operand(r3E2A).val);
                     exec_list *const f3E29_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3E29->then_instructions;

                        body.emit(assign(r3E11, body.constant(0u), 0x01));

                        ir_variable *const r3E2B = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r3E2B, lshift(r3E10, r3E12), 0x01));

                        ir_variable *const r3E2C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r3E2E = equal(r3E12, body.constant(int(0)));
                        ir_if *f3E2D = new(mem_ctx) ir_if(operand(r3E2E).val);
                        exec_list *const f3E2D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3E2D->then_instructions;

                           body.emit(assign(r3E2C, r3E0F, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3E2D->else_instructions;

                           ir_expression *const r3E2F = lshift(r3E0F, r3E12);
                           ir_expression *const r3E30 = neg(r3E12);
                           ir_expression *const r3E31 = bit_and(r3E30, body.constant(int(31)));
                           ir_expression *const r3E32 = rshift(r3E10, r3E31);
                           body.emit(assign(r3E2C, bit_or(r3E2F, r3E32), 0x01));


                        body.instructions = f3E2D_parent_instructions;
                        body.emit(f3E2D);

                        /* END IF */

                        body.emit(assign(r3E0F, r3E2C, 0x01));

                        body.emit(assign(r3E10, r3E2B, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3E29->else_instructions;

                        ir_variable *const r3E33 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r3E33, body.constant(0u), 0x01));

                        ir_variable *const r3E34 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r3E34, neg(r3E12), 0x01));

                        ir_variable *const r3E35 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r3E35);
                        ir_variable *const r3E36 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r3E36);
                        ir_variable *const r3E37 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r3E37);
                        ir_variable *const r3E38 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r3E39 = neg(r3E34);
                        body.emit(assign(r3E38, bit_and(r3E39, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3E3B = equal(r3E34, body.constant(int(0)));
                        ir_if *f3E3A = new(mem_ctx) ir_if(operand(r3E3B).val);
                        exec_list *const f3E3A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3E3A->then_instructions;

                           body.emit(assign(r3E35, r3E33, 0x01));

                           body.emit(assign(r3E36, r3E10, 0x01));

                           body.emit(assign(r3E37, r3E0F, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3E3A->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3E3D = less(r3E34, body.constant(int(32)));
                           ir_if *f3E3C = new(mem_ctx) ir_if(operand(r3E3D).val);
                           exec_list *const f3E3C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3E3C->then_instructions;

                              body.emit(assign(r3E35, lshift(r3E10, r3E38), 0x01));

                              ir_expression *const r3E3E = lshift(r3E0F, r3E38);
                              ir_expression *const r3E3F = rshift(r3E10, r3E34);
                              body.emit(assign(r3E36, bit_or(r3E3E, r3E3F), 0x01));

                              body.emit(assign(r3E37, rshift(r3E0F, r3E34), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3E3C->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3E41 = equal(r3E34, body.constant(int(32)));
                              ir_if *f3E40 = new(mem_ctx) ir_if(operand(r3E41).val);
                              exec_list *const f3E40_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3E40->then_instructions;

                                 body.emit(assign(r3E35, r3E10, 0x01));

                                 body.emit(assign(r3E36, r3E0F, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3E40->else_instructions;

                                 body.emit(assign(r3E33, bit_or(body.constant(0u), r3E10), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3E43 = less(r3E34, body.constant(int(64)));
                                 ir_if *f3E42 = new(mem_ctx) ir_if(operand(r3E43).val);
                                 exec_list *const f3E42_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3E42->then_instructions;

                                    body.emit(assign(r3E35, lshift(r3E0F, r3E38), 0x01));

                                    ir_expression *const r3E44 = bit_and(r3E34, body.constant(int(31)));
                                    body.emit(assign(r3E36, rshift(r3E0F, r3E44), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3E42->else_instructions;

                                    ir_variable *const r3E45 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r3E47 = equal(r3E34, body.constant(int(64)));
                                    ir_if *f3E46 = new(mem_ctx) ir_if(operand(r3E47).val);
                                    exec_list *const f3E46_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3E46->then_instructions;

                                       body.emit(assign(r3E45, r3E0F, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3E46->else_instructions;

                                       ir_expression *const r3E48 = nequal(r3E0F, body.constant(0u));
                                       ir_expression *const r3E49 = expr(ir_unop_b2i, r3E48);
                                       body.emit(assign(r3E45, expr(ir_unop_i2u, r3E49), 0x01));


                                    body.instructions = f3E46_parent_instructions;
                                    body.emit(f3E46);

                                    /* END IF */

                                    body.emit(assign(r3E35, r3E45, 0x01));

                                    body.emit(assign(r3E36, body.constant(0u), 0x01));


                                 body.instructions = f3E42_parent_instructions;
                                 body.emit(f3E42);

                                 /* END IF */


                              body.instructions = f3E40_parent_instructions;
                              body.emit(f3E40);

                              /* END IF */

                              body.emit(assign(r3E37, body.constant(0u), 0x01));


                           body.instructions = f3E3C_parent_instructions;
                           body.emit(f3E3C);

                           /* END IF */

                           ir_expression *const r3E4A = nequal(r3E33, body.constant(0u));
                           ir_expression *const r3E4B = expr(ir_unop_b2i, r3E4A);
                           ir_expression *const r3E4C = expr(ir_unop_i2u, r3E4B);
                           body.emit(assign(r3E35, bit_or(r3E35, r3E4C), 0x01));


                        body.instructions = f3E3A_parent_instructions;
                        body.emit(f3E3A);

                        /* END IF */

                        body.emit(assign(r3E0F, r3E37, 0x01));

                        body.emit(assign(r3E10, r3E36, 0x01));

                        body.emit(assign(r3E11, r3E35, 0x01));


                     body.instructions = f3E29_parent_instructions;
                     body.emit(f3E29);

                     /* END IF */

                     body.emit(assign(r3E0E, sub(r3E0E, r3E12), 0x01));

                     ir_variable *const r3E4D = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r3E4D, r3E0E, 0x01));

                     ir_variable *const r3E4E = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r3E4E, r3E0F, 0x01));

                     ir_variable *const r3E4F = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r3E4F, r3E10, 0x01));

                     ir_variable *const r3E50 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r3E50, r3E11, 0x01));

                     ir_variable *const r3E51 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r3E51, body.constant(true), 0x01));

                     ir_variable *const r3E52 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r3E53 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r3E53);
                     ir_expression *const r3E54 = expr(ir_unop_u2i, r3E11);
                     body.emit(assign(r3E53, less(r3E54, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3E56 = lequal(body.constant(int(2045)), r3E0E);
                     ir_if *f3E55 = new(mem_ctx) ir_if(operand(r3E56).val);
                     exec_list *const f3E55_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3E55->then_instructions;

                        ir_variable *const r3E57 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r3E59 = less(body.constant(int(2045)), r3E0E);
                        ir_if *f3E58 = new(mem_ctx) ir_if(operand(r3E59).val);
                        exec_list *const f3E58_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3E58->then_instructions;

                           body.emit(assign(r3E57, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3E58->else_instructions;

                           ir_variable *const r3E5A = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r3E5C = equal(r3E0E, body.constant(int(2045)));
                           ir_if *f3E5B = new(mem_ctx) ir_if(operand(r3E5C).val);
                           exec_list *const f3E5B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3E5B->then_instructions;

                              ir_expression *const r3E5D = equal(body.constant(2097151u), r3E0F);
                              ir_expression *const r3E5E = equal(body.constant(4294967295u), r3E10);
                              body.emit(assign(r3E5A, logic_and(r3E5D, r3E5E), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3E5B->else_instructions;

                              body.emit(assign(r3E5A, body.constant(false), 0x01));


                           body.instructions = f3E5B_parent_instructions;
                           body.emit(f3E5B);

                           /* END IF */

                           body.emit(assign(r3E57, logic_and(r3E5A, r3E53), 0x01));


                        body.instructions = f3E58_parent_instructions;
                        body.emit(f3E58);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f3E5F = new(mem_ctx) ir_if(operand(r3E57).val);
                        exec_list *const f3E5F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3E5F->then_instructions;

                           ir_variable *const r3E60 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r3E60);
                           ir_expression *const r3E61 = lshift(r3B95, body.constant(int(31)));
                           body.emit(assign(r3E60, add(r3E61, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r3E60, body.constant(0u), 0x01));

                           body.emit(assign(r3E52, r3E60, 0x03));

                           body.emit(assign(r3E51, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3E5F->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3E63 = less(r3E0E, body.constant(int(0)));
                           ir_if *f3E62 = new(mem_ctx) ir_if(operand(r3E63).val);
                           exec_list *const f3E62_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3E62->then_instructions;

                              ir_variable *const r3E64 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r3E64, r3E11, 0x01));

                              ir_variable *const r3E65 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r3E65, neg(r3E0E), 0x01));

                              ir_variable *const r3E66 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r3E66);
                              ir_variable *const r3E67 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r3E67);
                              ir_variable *const r3E68 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r3E68);
                              ir_variable *const r3E69 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r3E6A = neg(r3E65);
                              body.emit(assign(r3E69, bit_and(r3E6A, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3E6C = equal(r3E65, body.constant(int(0)));
                              ir_if *f3E6B = new(mem_ctx) ir_if(operand(r3E6C).val);
                              exec_list *const f3E6B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3E6B->then_instructions;

                                 body.emit(assign(r3E66, r3E11, 0x01));

                                 body.emit(assign(r3E67, r3E10, 0x01));

                                 body.emit(assign(r3E68, r3E0F, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3E6B->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3E6E = less(r3E65, body.constant(int(32)));
                                 ir_if *f3E6D = new(mem_ctx) ir_if(operand(r3E6E).val);
                                 exec_list *const f3E6D_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3E6D->then_instructions;

                                    body.emit(assign(r3E66, lshift(r3E10, r3E69), 0x01));

                                    ir_expression *const r3E6F = lshift(r3E0F, r3E69);
                                    ir_expression *const r3E70 = rshift(r3E10, r3E65);
                                    body.emit(assign(r3E67, bit_or(r3E6F, r3E70), 0x01));

                                    body.emit(assign(r3E68, rshift(r3E0F, r3E65), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3E6D->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r3E72 = equal(r3E65, body.constant(int(32)));
                                    ir_if *f3E71 = new(mem_ctx) ir_if(operand(r3E72).val);
                                    exec_list *const f3E71_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3E71->then_instructions;

                                       body.emit(assign(r3E66, r3E10, 0x01));

                                       body.emit(assign(r3E67, r3E0F, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3E71->else_instructions;

                                       body.emit(assign(r3E64, bit_or(r3E11, r3E10), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r3E74 = less(r3E65, body.constant(int(64)));
                                       ir_if *f3E73 = new(mem_ctx) ir_if(operand(r3E74).val);
                                       exec_list *const f3E73_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3E73->then_instructions;

                                          body.emit(assign(r3E66, lshift(r3E0F, r3E69), 0x01));

                                          ir_expression *const r3E75 = bit_and(r3E65, body.constant(int(31)));
                                          body.emit(assign(r3E67, rshift(r3E0F, r3E75), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3E73->else_instructions;

                                          ir_variable *const r3E76 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r3E78 = equal(r3E65, body.constant(int(64)));
                                          ir_if *f3E77 = new(mem_ctx) ir_if(operand(r3E78).val);
                                          exec_list *const f3E77_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3E77->then_instructions;

                                             body.emit(assign(r3E76, r3E0F, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3E77->else_instructions;

                                             ir_expression *const r3E79 = nequal(r3E0F, body.constant(0u));
                                             ir_expression *const r3E7A = expr(ir_unop_b2i, r3E79);
                                             body.emit(assign(r3E76, expr(ir_unop_i2u, r3E7A), 0x01));


                                          body.instructions = f3E77_parent_instructions;
                                          body.emit(f3E77);

                                          /* END IF */

                                          body.emit(assign(r3E66, r3E76, 0x01));

                                          body.emit(assign(r3E67, body.constant(0u), 0x01));


                                       body.instructions = f3E73_parent_instructions;
                                       body.emit(f3E73);

                                       /* END IF */


                                    body.instructions = f3E71_parent_instructions;
                                    body.emit(f3E71);

                                    /* END IF */

                                    body.emit(assign(r3E68, body.constant(0u), 0x01));


                                 body.instructions = f3E6D_parent_instructions;
                                 body.emit(f3E6D);

                                 /* END IF */

                                 ir_expression *const r3E7B = nequal(r3E64, body.constant(0u));
                                 ir_expression *const r3E7C = expr(ir_unop_b2i, r3E7B);
                                 ir_expression *const r3E7D = expr(ir_unop_i2u, r3E7C);
                                 body.emit(assign(r3E66, bit_or(r3E66, r3E7D), 0x01));


                              body.instructions = f3E6B_parent_instructions;
                              body.emit(f3E6B);

                              /* END IF */

                              body.emit(assign(r3E4E, r3E68, 0x01));

                              body.emit(assign(r3E4F, r3E67, 0x01));

                              body.emit(assign(r3E50, r3E66, 0x01));

                              body.emit(assign(r3E4D, body.constant(int(0)), 0x01));

                              body.emit(assign(r3E53, less(r3E66, body.constant(0u)), 0x01));


                           body.instructions = f3E62_parent_instructions;
                           body.emit(f3E62);

                           /* END IF */


                        body.instructions = f3E5F_parent_instructions;
                        body.emit(f3E5F);

                        /* END IF */


                     body.instructions = f3E55_parent_instructions;
                     body.emit(f3E55);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f3E7E = new(mem_ctx) ir_if(operand(r3E51).val);
                     exec_list *const f3E7E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3E7E->then_instructions;

                        /* IF CONDITION */
                        ir_if *f3E7F = new(mem_ctx) ir_if(operand(r3E53).val);
                        exec_list *const f3E7F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3E7F->then_instructions;

                           ir_variable *const r3E80 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r3E80, add(r3E4F, body.constant(1u)), 0x01));

                           ir_expression *const r3E81 = less(r3E80, r3E4F);
                           ir_expression *const r3E82 = expr(ir_unop_b2i, r3E81);
                           ir_expression *const r3E83 = expr(ir_unop_i2u, r3E82);
                           body.emit(assign(r3E4E, add(r3E4E, r3E83), 0x01));

                           ir_expression *const r3E84 = equal(r3E50, body.constant(0u));
                           ir_expression *const r3E85 = expr(ir_unop_b2i, r3E84);
                           ir_expression *const r3E86 = expr(ir_unop_i2u, r3E85);
                           ir_expression *const r3E87 = add(r3E50, r3E86);
                           ir_expression *const r3E88 = bit_and(r3E87, body.constant(1u));
                           ir_expression *const r3E89 = expr(ir_unop_bit_not, r3E88);
                           body.emit(assign(r3E4F, bit_and(r3E80, r3E89), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3E7F->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3E8B = bit_or(r3E4E, r3E4F);
                           ir_expression *const r3E8C = equal(r3E8B, body.constant(0u));
                           ir_if *f3E8A = new(mem_ctx) ir_if(operand(r3E8C).val);
                           exec_list *const f3E8A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3E8A->then_instructions;

                              body.emit(assign(r3E4D, body.constant(int(0)), 0x01));


                           body.instructions = f3E8A_parent_instructions;
                           body.emit(f3E8A);

                           /* END IF */


                        body.instructions = f3E7F_parent_instructions;
                        body.emit(f3E7F);

                        /* END IF */

                        ir_variable *const r3E8D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r3E8D);
                        ir_expression *const r3E8E = lshift(r3B95, body.constant(int(31)));
                        ir_expression *const r3E8F = expr(ir_unop_i2u, r3E4D);
                        ir_expression *const r3E90 = lshift(r3E8F, body.constant(int(20)));
                        ir_expression *const r3E91 = add(r3E8E, r3E90);
                        body.emit(assign(r3E8D, add(r3E91, r3E4E), 0x02));

                        body.emit(assign(r3E8D, r3E4F, 0x01));

                        body.emit(assign(r3E52, r3E8D, 0x03));

                        body.emit(assign(r3E51, body.constant(false), 0x01));


                     body.instructions = f3E7E_parent_instructions;
                     body.emit(f3E7E);

                     /* END IF */

                     body.emit(assign(r3B96, r3E52, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3E06->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r3E93 = less(r3B9B, r3B9D);
                     ir_if *f3E92 = new(mem_ctx) ir_if(operand(r3E93).val);
                     exec_list *const f3E92_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3E92->then_instructions;

                        ir_variable *const r3E94 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r3E95 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r3E95, sub(r3B9D, r3B9B), 0x01));

                        ir_expression *const r3E96 = sub(r3B9C, r3B9A);
                        ir_expression *const r3E97 = less(r3B9D, r3B9B);
                        ir_expression *const r3E98 = expr(ir_unop_b2i, r3E97);
                        ir_expression *const r3E99 = expr(ir_unop_i2u, r3E98);
                        body.emit(assign(r3E94, sub(r3E96, r3E99), 0x01));

                        body.emit(assign(r3B9E, add(r3B99, body.constant(int(-1))), 0x01));

                        ir_variable *const r3E9A = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r3E9A, add(r3B9E, body.constant(int(-10))), 0x01));

                        ir_variable *const r3E9B = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r3E9B, r3E94, 0x01));

                        ir_variable *const r3E9C = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r3E9C, r3E95, 0x01));

                        ir_variable *const r3E9D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r3E9D);
                        ir_variable *const r3E9E = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r3E9E);
                        /* IF CONDITION */
                        ir_expression *const r3EA0 = equal(r3E94, body.constant(0u));
                        ir_if *f3E9F = new(mem_ctx) ir_if(operand(r3EA0).val);
                        exec_list *const f3E9F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3E9F->then_instructions;

                           body.emit(assign(r3E9B, r3E95, 0x01));

                           body.emit(assign(r3E9C, body.constant(0u), 0x01));

                           body.emit(assign(r3E9A, add(r3E9A, body.constant(int(-32))), 0x01));


                        body.instructions = f3E9F_parent_instructions;
                        body.emit(f3E9F);

                        /* END IF */

                        ir_variable *const r3EA1 = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r3EA1, r3E9B, 0x01));

                        ir_variable *const r3EA2 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r3EA3 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r3EA3);
                        /* IF CONDITION */
                        ir_expression *const r3EA5 = equal(r3E9B, body.constant(0u));
                        ir_if *f3EA4 = new(mem_ctx) ir_if(operand(r3EA5).val);
                        exec_list *const f3EA4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3EA4->then_instructions;

                           body.emit(assign(r3EA2, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3EA4->else_instructions;

                           body.emit(assign(r3EA3, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3EA7 = bit_and(r3E9B, body.constant(4294901760u));
                           ir_expression *const r3EA8 = equal(r3EA7, body.constant(0u));
                           ir_if *f3EA6 = new(mem_ctx) ir_if(operand(r3EA8).val);
                           exec_list *const f3EA6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3EA6->then_instructions;

                              body.emit(assign(r3EA3, body.constant(int(16)), 0x01));

                              body.emit(assign(r3EA1, lshift(r3E9B, body.constant(int(16))), 0x01));


                           body.instructions = f3EA6_parent_instructions;
                           body.emit(f3EA6);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r3EAA = bit_and(r3EA1, body.constant(4278190080u));
                           ir_expression *const r3EAB = equal(r3EAA, body.constant(0u));
                           ir_if *f3EA9 = new(mem_ctx) ir_if(operand(r3EAB).val);
                           exec_list *const f3EA9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3EA9->then_instructions;

                              body.emit(assign(r3EA3, add(r3EA3, body.constant(int(8))), 0x01));

                              body.emit(assign(r3EA1, lshift(r3EA1, body.constant(int(8))), 0x01));


                           body.instructions = f3EA9_parent_instructions;
                           body.emit(f3EA9);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r3EAD = bit_and(r3EA1, body.constant(4026531840u));
                           ir_expression *const r3EAE = equal(r3EAD, body.constant(0u));
                           ir_if *f3EAC = new(mem_ctx) ir_if(operand(r3EAE).val);
                           exec_list *const f3EAC_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3EAC->then_instructions;

                              body.emit(assign(r3EA3, add(r3EA3, body.constant(int(4))), 0x01));

                              body.emit(assign(r3EA1, lshift(r3EA1, body.constant(int(4))), 0x01));


                           body.instructions = f3EAC_parent_instructions;
                           body.emit(f3EAC);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r3EB0 = bit_and(r3EA1, body.constant(3221225472u));
                           ir_expression *const r3EB1 = equal(r3EB0, body.constant(0u));
                           ir_if *f3EAF = new(mem_ctx) ir_if(operand(r3EB1).val);
                           exec_list *const f3EAF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3EAF->then_instructions;

                              body.emit(assign(r3EA3, add(r3EA3, body.constant(int(2))), 0x01));

                              body.emit(assign(r3EA1, lshift(r3EA1, body.constant(int(2))), 0x01));


                           body.instructions = f3EAF_parent_instructions;
                           body.emit(f3EAF);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r3EB3 = bit_and(r3EA1, body.constant(2147483648u));
                           ir_expression *const r3EB4 = equal(r3EB3, body.constant(0u));
                           ir_if *f3EB2 = new(mem_ctx) ir_if(operand(r3EB4).val);
                           exec_list *const f3EB2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3EB2->then_instructions;

                              body.emit(assign(r3EA3, add(r3EA3, body.constant(int(1))), 0x01));


                           body.instructions = f3EB2_parent_instructions;
                           body.emit(f3EB2);

                           /* END IF */

                           body.emit(assign(r3EA2, r3EA3, 0x01));


                        body.instructions = f3EA4_parent_instructions;
                        body.emit(f3EA4);

                        /* END IF */

                        body.emit(assign(r3E9E, add(r3EA2, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3EB6 = lequal(body.constant(int(0)), r3E9E);
                        ir_if *f3EB5 = new(mem_ctx) ir_if(operand(r3EB6).val);
                        exec_list *const f3EB5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3EB5->then_instructions;

                           body.emit(assign(r3E9D, body.constant(0u), 0x01));

                           ir_variable *const r3EB7 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r3EB7, lshift(r3E9C, r3E9E), 0x01));

                           ir_variable *const r3EB8 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r3EBA = equal(r3E9E, body.constant(int(0)));
                           ir_if *f3EB9 = new(mem_ctx) ir_if(operand(r3EBA).val);
                           exec_list *const f3EB9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3EB9->then_instructions;

                              body.emit(assign(r3EB8, r3E9B, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3EB9->else_instructions;

                              ir_expression *const r3EBB = lshift(r3E9B, r3E9E);
                              ir_expression *const r3EBC = neg(r3E9E);
                              ir_expression *const r3EBD = bit_and(r3EBC, body.constant(int(31)));
                              ir_expression *const r3EBE = rshift(r3E9C, r3EBD);
                              body.emit(assign(r3EB8, bit_or(r3EBB, r3EBE), 0x01));


                           body.instructions = f3EB9_parent_instructions;
                           body.emit(f3EB9);

                           /* END IF */

                           body.emit(assign(r3E9B, r3EB8, 0x01));

                           body.emit(assign(r3E9C, r3EB7, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3EB5->else_instructions;

                           ir_variable *const r3EBF = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r3EBF, body.constant(0u), 0x01));

                           ir_variable *const r3EC0 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r3EC0, neg(r3E9E), 0x01));

                           ir_variable *const r3EC1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r3EC1);
                           ir_variable *const r3EC2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r3EC2);
                           ir_variable *const r3EC3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r3EC3);
                           ir_variable *const r3EC4 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r3EC5 = neg(r3EC0);
                           body.emit(assign(r3EC4, bit_and(r3EC5, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3EC7 = equal(r3EC0, body.constant(int(0)));
                           ir_if *f3EC6 = new(mem_ctx) ir_if(operand(r3EC7).val);
                           exec_list *const f3EC6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3EC6->then_instructions;

                              body.emit(assign(r3EC1, r3EBF, 0x01));

                              body.emit(assign(r3EC2, r3E9C, 0x01));

                              body.emit(assign(r3EC3, r3E9B, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3EC6->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3EC9 = less(r3EC0, body.constant(int(32)));
                              ir_if *f3EC8 = new(mem_ctx) ir_if(operand(r3EC9).val);
                              exec_list *const f3EC8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3EC8->then_instructions;

                                 body.emit(assign(r3EC1, lshift(r3E9C, r3EC4), 0x01));

                                 ir_expression *const r3ECA = lshift(r3E9B, r3EC4);
                                 ir_expression *const r3ECB = rshift(r3E9C, r3EC0);
                                 body.emit(assign(r3EC2, bit_or(r3ECA, r3ECB), 0x01));

                                 body.emit(assign(r3EC3, rshift(r3E9B, r3EC0), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3EC8->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3ECD = equal(r3EC0, body.constant(int(32)));
                                 ir_if *f3ECC = new(mem_ctx) ir_if(operand(r3ECD).val);
                                 exec_list *const f3ECC_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3ECC->then_instructions;

                                    body.emit(assign(r3EC1, r3E9C, 0x01));

                                    body.emit(assign(r3EC2, r3E9B, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3ECC->else_instructions;

                                    body.emit(assign(r3EBF, bit_or(body.constant(0u), r3E9C), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r3ECF = less(r3EC0, body.constant(int(64)));
                                    ir_if *f3ECE = new(mem_ctx) ir_if(operand(r3ECF).val);
                                    exec_list *const f3ECE_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3ECE->then_instructions;

                                       body.emit(assign(r3EC1, lshift(r3E9B, r3EC4), 0x01));

                                       ir_expression *const r3ED0 = bit_and(r3EC0, body.constant(int(31)));
                                       body.emit(assign(r3EC2, rshift(r3E9B, r3ED0), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3ECE->else_instructions;

                                       ir_variable *const r3ED1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r3ED3 = equal(r3EC0, body.constant(int(64)));
                                       ir_if *f3ED2 = new(mem_ctx) ir_if(operand(r3ED3).val);
                                       exec_list *const f3ED2_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3ED2->then_instructions;

                                          body.emit(assign(r3ED1, r3E9B, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3ED2->else_instructions;

                                          ir_expression *const r3ED4 = nequal(r3E9B, body.constant(0u));
                                          ir_expression *const r3ED5 = expr(ir_unop_b2i, r3ED4);
                                          body.emit(assign(r3ED1, expr(ir_unop_i2u, r3ED5), 0x01));


                                       body.instructions = f3ED2_parent_instructions;
                                       body.emit(f3ED2);

                                       /* END IF */

                                       body.emit(assign(r3EC1, r3ED1, 0x01));

                                       body.emit(assign(r3EC2, body.constant(0u), 0x01));


                                    body.instructions = f3ECE_parent_instructions;
                                    body.emit(f3ECE);

                                    /* END IF */


                                 body.instructions = f3ECC_parent_instructions;
                                 body.emit(f3ECC);

                                 /* END IF */

                                 body.emit(assign(r3EC3, body.constant(0u), 0x01));


                              body.instructions = f3EC8_parent_instructions;
                              body.emit(f3EC8);

                              /* END IF */

                              ir_expression *const r3ED6 = nequal(r3EBF, body.constant(0u));
                              ir_expression *const r3ED7 = expr(ir_unop_b2i, r3ED6);
                              ir_expression *const r3ED8 = expr(ir_unop_i2u, r3ED7);
                              body.emit(assign(r3EC1, bit_or(r3EC1, r3ED8), 0x01));


                           body.instructions = f3EC6_parent_instructions;
                           body.emit(f3EC6);

                           /* END IF */

                           body.emit(assign(r3E9B, r3EC3, 0x01));

                           body.emit(assign(r3E9C, r3EC2, 0x01));

                           body.emit(assign(r3E9D, r3EC1, 0x01));


                        body.instructions = f3EB5_parent_instructions;
                        body.emit(f3EB5);

                        /* END IF */

                        body.emit(assign(r3E9A, sub(r3E9A, r3E9E), 0x01));

                        ir_variable *const r3ED9 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r3ED9, r3E9A, 0x01));

                        ir_variable *const r3EDA = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r3EDA, r3E9B, 0x01));

                        ir_variable *const r3EDB = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r3EDB, r3E9C, 0x01));

                        ir_variable *const r3EDC = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r3EDC, r3E9D, 0x01));

                        ir_variable *const r3EDD = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r3EDD, body.constant(true), 0x01));

                        ir_variable *const r3EDE = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r3EDF = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r3EDF);
                        ir_expression *const r3EE0 = expr(ir_unop_u2i, r3E9D);
                        body.emit(assign(r3EDF, less(r3EE0, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r3EE2 = lequal(body.constant(int(2045)), r3E9A);
                        ir_if *f3EE1 = new(mem_ctx) ir_if(operand(r3EE2).val);
                        exec_list *const f3EE1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3EE1->then_instructions;

                           ir_variable *const r3EE3 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r3EE5 = less(body.constant(int(2045)), r3E9A);
                           ir_if *f3EE4 = new(mem_ctx) ir_if(operand(r3EE5).val);
                           exec_list *const f3EE4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3EE4->then_instructions;

                              body.emit(assign(r3EE3, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3EE4->else_instructions;

                              ir_variable *const r3EE6 = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r3EE8 = equal(r3E9A, body.constant(int(2045)));
                              ir_if *f3EE7 = new(mem_ctx) ir_if(operand(r3EE8).val);
                              exec_list *const f3EE7_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3EE7->then_instructions;

                                 ir_expression *const r3EE9 = equal(body.constant(2097151u), r3E9B);
                                 ir_expression *const r3EEA = equal(body.constant(4294967295u), r3E9C);
                                 body.emit(assign(r3EE6, logic_and(r3EE9, r3EEA), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3EE7->else_instructions;

                                 body.emit(assign(r3EE6, body.constant(false), 0x01));


                              body.instructions = f3EE7_parent_instructions;
                              body.emit(f3EE7);

                              /* END IF */

                              body.emit(assign(r3EE3, logic_and(r3EE6, r3EDF), 0x01));


                           body.instructions = f3EE4_parent_instructions;
                           body.emit(f3EE4);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f3EEB = new(mem_ctx) ir_if(operand(r3EE3).val);
                           exec_list *const f3EEB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3EEB->then_instructions;

                              ir_variable *const r3EEC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r3EEC);
                              ir_expression *const r3EED = lshift(r3B95, body.constant(int(31)));
                              body.emit(assign(r3EEC, add(r3EED, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r3EEC, body.constant(0u), 0x01));

                              body.emit(assign(r3EDE, r3EEC, 0x03));

                              body.emit(assign(r3EDD, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3EEB->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3EEF = less(r3E9A, body.constant(int(0)));
                              ir_if *f3EEE = new(mem_ctx) ir_if(operand(r3EEF).val);
                              exec_list *const f3EEE_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3EEE->then_instructions;

                                 ir_variable *const r3EF0 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r3EF0, r3E9D, 0x01));

                                 ir_variable *const r3EF1 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r3EF1, neg(r3E9A), 0x01));

                                 ir_variable *const r3EF2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r3EF2);
                                 ir_variable *const r3EF3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r3EF3);
                                 ir_variable *const r3EF4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r3EF4);
                                 ir_variable *const r3EF5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r3EF6 = neg(r3EF1);
                                 body.emit(assign(r3EF5, bit_and(r3EF6, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3EF8 = equal(r3EF1, body.constant(int(0)));
                                 ir_if *f3EF7 = new(mem_ctx) ir_if(operand(r3EF8).val);
                                 exec_list *const f3EF7_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3EF7->then_instructions;

                                    body.emit(assign(r3EF2, r3E9D, 0x01));

                                    body.emit(assign(r3EF3, r3E9C, 0x01));

                                    body.emit(assign(r3EF4, r3E9B, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3EF7->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r3EFA = less(r3EF1, body.constant(int(32)));
                                    ir_if *f3EF9 = new(mem_ctx) ir_if(operand(r3EFA).val);
                                    exec_list *const f3EF9_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3EF9->then_instructions;

                                       body.emit(assign(r3EF2, lshift(r3E9C, r3EF5), 0x01));

                                       ir_expression *const r3EFB = lshift(r3E9B, r3EF5);
                                       ir_expression *const r3EFC = rshift(r3E9C, r3EF1);
                                       body.emit(assign(r3EF3, bit_or(r3EFB, r3EFC), 0x01));

                                       body.emit(assign(r3EF4, rshift(r3E9B, r3EF1), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3EF9->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r3EFE = equal(r3EF1, body.constant(int(32)));
                                       ir_if *f3EFD = new(mem_ctx) ir_if(operand(r3EFE).val);
                                       exec_list *const f3EFD_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3EFD->then_instructions;

                                          body.emit(assign(r3EF2, r3E9C, 0x01));

                                          body.emit(assign(r3EF3, r3E9B, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3EFD->else_instructions;

                                          body.emit(assign(r3EF0, bit_or(r3E9D, r3E9C), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r3F00 = less(r3EF1, body.constant(int(64)));
                                          ir_if *f3EFF = new(mem_ctx) ir_if(operand(r3F00).val);
                                          exec_list *const f3EFF_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3EFF->then_instructions;

                                             body.emit(assign(r3EF2, lshift(r3E9B, r3EF5), 0x01));

                                             ir_expression *const r3F01 = bit_and(r3EF1, body.constant(int(31)));
                                             body.emit(assign(r3EF3, rshift(r3E9B, r3F01), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3EFF->else_instructions;

                                             ir_variable *const r3F02 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r3F04 = equal(r3EF1, body.constant(int(64)));
                                             ir_if *f3F03 = new(mem_ctx) ir_if(operand(r3F04).val);
                                             exec_list *const f3F03_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f3F03->then_instructions;

                                                body.emit(assign(r3F02, r3E9B, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f3F03->else_instructions;

                                                ir_expression *const r3F05 = nequal(r3E9B, body.constant(0u));
                                                ir_expression *const r3F06 = expr(ir_unop_b2i, r3F05);
                                                body.emit(assign(r3F02, expr(ir_unop_i2u, r3F06), 0x01));


                                             body.instructions = f3F03_parent_instructions;
                                             body.emit(f3F03);

                                             /* END IF */

                                             body.emit(assign(r3EF2, r3F02, 0x01));

                                             body.emit(assign(r3EF3, body.constant(0u), 0x01));


                                          body.instructions = f3EFF_parent_instructions;
                                          body.emit(f3EFF);

                                          /* END IF */


                                       body.instructions = f3EFD_parent_instructions;
                                       body.emit(f3EFD);

                                       /* END IF */

                                       body.emit(assign(r3EF4, body.constant(0u), 0x01));


                                    body.instructions = f3EF9_parent_instructions;
                                    body.emit(f3EF9);

                                    /* END IF */

                                    ir_expression *const r3F07 = nequal(r3EF0, body.constant(0u));
                                    ir_expression *const r3F08 = expr(ir_unop_b2i, r3F07);
                                    ir_expression *const r3F09 = expr(ir_unop_i2u, r3F08);
                                    body.emit(assign(r3EF2, bit_or(r3EF2, r3F09), 0x01));


                                 body.instructions = f3EF7_parent_instructions;
                                 body.emit(f3EF7);

                                 /* END IF */

                                 body.emit(assign(r3EDA, r3EF4, 0x01));

                                 body.emit(assign(r3EDB, r3EF3, 0x01));

                                 body.emit(assign(r3EDC, r3EF2, 0x01));

                                 body.emit(assign(r3ED9, body.constant(int(0)), 0x01));

                                 body.emit(assign(r3EDF, less(r3EF2, body.constant(0u)), 0x01));


                              body.instructions = f3EEE_parent_instructions;
                              body.emit(f3EEE);

                              /* END IF */


                           body.instructions = f3EEB_parent_instructions;
                           body.emit(f3EEB);

                           /* END IF */


                        body.instructions = f3EE1_parent_instructions;
                        body.emit(f3EE1);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f3F0A = new(mem_ctx) ir_if(operand(r3EDD).val);
                        exec_list *const f3F0A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3F0A->then_instructions;

                           /* IF CONDITION */
                           ir_if *f3F0B = new(mem_ctx) ir_if(operand(r3EDF).val);
                           exec_list *const f3F0B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3F0B->then_instructions;

                              ir_variable *const r3F0C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r3F0C, add(r3EDB, body.constant(1u)), 0x01));

                              ir_expression *const r3F0D = less(r3F0C, r3EDB);
                              ir_expression *const r3F0E = expr(ir_unop_b2i, r3F0D);
                              ir_expression *const r3F0F = expr(ir_unop_i2u, r3F0E);
                              body.emit(assign(r3EDA, add(r3EDA, r3F0F), 0x01));

                              ir_expression *const r3F10 = equal(r3EDC, body.constant(0u));
                              ir_expression *const r3F11 = expr(ir_unop_b2i, r3F10);
                              ir_expression *const r3F12 = expr(ir_unop_i2u, r3F11);
                              ir_expression *const r3F13 = add(r3EDC, r3F12);
                              ir_expression *const r3F14 = bit_and(r3F13, body.constant(1u));
                              ir_expression *const r3F15 = expr(ir_unop_bit_not, r3F14);
                              body.emit(assign(r3EDB, bit_and(r3F0C, r3F15), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3F0B->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3F17 = bit_or(r3EDA, r3EDB);
                              ir_expression *const r3F18 = equal(r3F17, body.constant(0u));
                              ir_if *f3F16 = new(mem_ctx) ir_if(operand(r3F18).val);
                              exec_list *const f3F16_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3F16->then_instructions;

                                 body.emit(assign(r3ED9, body.constant(int(0)), 0x01));


                              body.instructions = f3F16_parent_instructions;
                              body.emit(f3F16);

                              /* END IF */


                           body.instructions = f3F0B_parent_instructions;
                           body.emit(f3F0B);

                           /* END IF */

                           ir_variable *const r3F19 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r3F19);
                           ir_expression *const r3F1A = lshift(r3B95, body.constant(int(31)));
                           ir_expression *const r3F1B = expr(ir_unop_i2u, r3ED9);
                           ir_expression *const r3F1C = lshift(r3F1B, body.constant(int(20)));
                           ir_expression *const r3F1D = add(r3F1A, r3F1C);
                           body.emit(assign(r3F19, add(r3F1D, r3EDA), 0x02));

                           body.emit(assign(r3F19, r3EDB, 0x01));

                           body.emit(assign(r3EDE, r3F19, 0x03));

                           body.emit(assign(r3EDD, body.constant(false), 0x01));


                        body.instructions = f3F0A_parent_instructions;
                        body.emit(f3F0A);

                        /* END IF */

                        body.emit(assign(r3B96, r3EDE, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3E92->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3F1F = less(r3B9D, r3B9B);
                        ir_if *f3F1E = new(mem_ctx) ir_if(operand(r3F1F).val);
                        exec_list *const f3F1E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3F1E->then_instructions;

                           ir_variable *const r3F20 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r3F21 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r3F21, sub(r3B9B, r3B9D), 0x01));

                           ir_expression *const r3F22 = sub(r3B9A, r3B9C);
                           ir_expression *const r3F23 = less(r3B9B, r3B9D);
                           ir_expression *const r3F24 = expr(ir_unop_b2i, r3F23);
                           ir_expression *const r3F25 = expr(ir_unop_i2u, r3F24);
                           body.emit(assign(r3F20, sub(r3F22, r3F25), 0x01));

                           body.emit(assign(r3B95, bit_xor(r3B95, body.constant(1u)), 0x01));

                           body.emit(assign(r3B9E, add(r3B98, body.constant(int(-1))), 0x01));

                           ir_variable *const r3F26 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r3F26, add(r3B9E, body.constant(int(-10))), 0x01));

                           ir_variable *const r3F27 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r3F27, r3F20, 0x01));

                           ir_variable *const r3F28 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r3F28, r3F21, 0x01));

                           ir_variable *const r3F29 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r3F29);
                           ir_variable *const r3F2A = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r3F2A);
                           /* IF CONDITION */
                           ir_expression *const r3F2C = equal(r3F20, body.constant(0u));
                           ir_if *f3F2B = new(mem_ctx) ir_if(operand(r3F2C).val);
                           exec_list *const f3F2B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3F2B->then_instructions;

                              body.emit(assign(r3F27, r3F21, 0x01));

                              body.emit(assign(r3F28, body.constant(0u), 0x01));

                              body.emit(assign(r3F26, add(r3F26, body.constant(int(-32))), 0x01));


                           body.instructions = f3F2B_parent_instructions;
                           body.emit(f3F2B);

                           /* END IF */

                           ir_variable *const r3F2D = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r3F2D, r3F27, 0x01));

                           ir_variable *const r3F2E = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r3F2F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r3F2F);
                           /* IF CONDITION */
                           ir_expression *const r3F31 = equal(r3F27, body.constant(0u));
                           ir_if *f3F30 = new(mem_ctx) ir_if(operand(r3F31).val);
                           exec_list *const f3F30_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3F30->then_instructions;

                              body.emit(assign(r3F2E, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3F30->else_instructions;

                              body.emit(assign(r3F2F, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3F33 = bit_and(r3F27, body.constant(4294901760u));
                              ir_expression *const r3F34 = equal(r3F33, body.constant(0u));
                              ir_if *f3F32 = new(mem_ctx) ir_if(operand(r3F34).val);
                              exec_list *const f3F32_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3F32->then_instructions;

                                 body.emit(assign(r3F2F, body.constant(int(16)), 0x01));

                                 body.emit(assign(r3F2D, lshift(r3F27, body.constant(int(16))), 0x01));


                              body.instructions = f3F32_parent_instructions;
                              body.emit(f3F32);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r3F36 = bit_and(r3F2D, body.constant(4278190080u));
                              ir_expression *const r3F37 = equal(r3F36, body.constant(0u));
                              ir_if *f3F35 = new(mem_ctx) ir_if(operand(r3F37).val);
                              exec_list *const f3F35_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3F35->then_instructions;

                                 body.emit(assign(r3F2F, add(r3F2F, body.constant(int(8))), 0x01));

                                 body.emit(assign(r3F2D, lshift(r3F2D, body.constant(int(8))), 0x01));


                              body.instructions = f3F35_parent_instructions;
                              body.emit(f3F35);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r3F39 = bit_and(r3F2D, body.constant(4026531840u));
                              ir_expression *const r3F3A = equal(r3F39, body.constant(0u));
                              ir_if *f3F38 = new(mem_ctx) ir_if(operand(r3F3A).val);
                              exec_list *const f3F38_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3F38->then_instructions;

                                 body.emit(assign(r3F2F, add(r3F2F, body.constant(int(4))), 0x01));

                                 body.emit(assign(r3F2D, lshift(r3F2D, body.constant(int(4))), 0x01));


                              body.instructions = f3F38_parent_instructions;
                              body.emit(f3F38);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r3F3C = bit_and(r3F2D, body.constant(3221225472u));
                              ir_expression *const r3F3D = equal(r3F3C, body.constant(0u));
                              ir_if *f3F3B = new(mem_ctx) ir_if(operand(r3F3D).val);
                              exec_list *const f3F3B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3F3B->then_instructions;

                                 body.emit(assign(r3F2F, add(r3F2F, body.constant(int(2))), 0x01));

                                 body.emit(assign(r3F2D, lshift(r3F2D, body.constant(int(2))), 0x01));


                              body.instructions = f3F3B_parent_instructions;
                              body.emit(f3F3B);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r3F3F = bit_and(r3F2D, body.constant(2147483648u));
                              ir_expression *const r3F40 = equal(r3F3F, body.constant(0u));
                              ir_if *f3F3E = new(mem_ctx) ir_if(operand(r3F40).val);
                              exec_list *const f3F3E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3F3E->then_instructions;

                                 body.emit(assign(r3F2F, add(r3F2F, body.constant(int(1))), 0x01));


                              body.instructions = f3F3E_parent_instructions;
                              body.emit(f3F3E);

                              /* END IF */

                              body.emit(assign(r3F2E, r3F2F, 0x01));


                           body.instructions = f3F30_parent_instructions;
                           body.emit(f3F30);

                           /* END IF */

                           body.emit(assign(r3F2A, add(r3F2E, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3F42 = lequal(body.constant(int(0)), r3F2A);
                           ir_if *f3F41 = new(mem_ctx) ir_if(operand(r3F42).val);
                           exec_list *const f3F41_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3F41->then_instructions;

                              body.emit(assign(r3F29, body.constant(0u), 0x01));

                              ir_variable *const r3F43 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r3F43, lshift(r3F28, r3F2A), 0x01));

                              ir_variable *const r3F44 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r3F46 = equal(r3F2A, body.constant(int(0)));
                              ir_if *f3F45 = new(mem_ctx) ir_if(operand(r3F46).val);
                              exec_list *const f3F45_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3F45->then_instructions;

                                 body.emit(assign(r3F44, r3F27, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3F45->else_instructions;

                                 ir_expression *const r3F47 = lshift(r3F27, r3F2A);
                                 ir_expression *const r3F48 = neg(r3F2A);
                                 ir_expression *const r3F49 = bit_and(r3F48, body.constant(int(31)));
                                 ir_expression *const r3F4A = rshift(r3F28, r3F49);
                                 body.emit(assign(r3F44, bit_or(r3F47, r3F4A), 0x01));


                              body.instructions = f3F45_parent_instructions;
                              body.emit(f3F45);

                              /* END IF */

                              body.emit(assign(r3F27, r3F44, 0x01));

                              body.emit(assign(r3F28, r3F43, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3F41->else_instructions;

                              ir_variable *const r3F4B = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r3F4B, body.constant(0u), 0x01));

                              ir_variable *const r3F4C = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r3F4C, neg(r3F2A), 0x01));

                              ir_variable *const r3F4D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r3F4D);
                              ir_variable *const r3F4E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r3F4E);
                              ir_variable *const r3F4F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r3F4F);
                              ir_variable *const r3F50 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r3F51 = neg(r3F4C);
                              body.emit(assign(r3F50, bit_and(r3F51, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3F53 = equal(r3F4C, body.constant(int(0)));
                              ir_if *f3F52 = new(mem_ctx) ir_if(operand(r3F53).val);
                              exec_list *const f3F52_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3F52->then_instructions;

                                 body.emit(assign(r3F4D, r3F4B, 0x01));

                                 body.emit(assign(r3F4E, r3F28, 0x01));

                                 body.emit(assign(r3F4F, r3F27, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3F52->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3F55 = less(r3F4C, body.constant(int(32)));
                                 ir_if *f3F54 = new(mem_ctx) ir_if(operand(r3F55).val);
                                 exec_list *const f3F54_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3F54->then_instructions;

                                    body.emit(assign(r3F4D, lshift(r3F28, r3F50), 0x01));

                                    ir_expression *const r3F56 = lshift(r3F27, r3F50);
                                    ir_expression *const r3F57 = rshift(r3F28, r3F4C);
                                    body.emit(assign(r3F4E, bit_or(r3F56, r3F57), 0x01));

                                    body.emit(assign(r3F4F, rshift(r3F27, r3F4C), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3F54->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r3F59 = equal(r3F4C, body.constant(int(32)));
                                    ir_if *f3F58 = new(mem_ctx) ir_if(operand(r3F59).val);
                                    exec_list *const f3F58_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3F58->then_instructions;

                                       body.emit(assign(r3F4D, r3F28, 0x01));

                                       body.emit(assign(r3F4E, r3F27, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3F58->else_instructions;

                                       body.emit(assign(r3F4B, bit_or(body.constant(0u), r3F28), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r3F5B = less(r3F4C, body.constant(int(64)));
                                       ir_if *f3F5A = new(mem_ctx) ir_if(operand(r3F5B).val);
                                       exec_list *const f3F5A_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3F5A->then_instructions;

                                          body.emit(assign(r3F4D, lshift(r3F27, r3F50), 0x01));

                                          ir_expression *const r3F5C = bit_and(r3F4C, body.constant(int(31)));
                                          body.emit(assign(r3F4E, rshift(r3F27, r3F5C), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3F5A->else_instructions;

                                          ir_variable *const r3F5D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r3F5F = equal(r3F4C, body.constant(int(64)));
                                          ir_if *f3F5E = new(mem_ctx) ir_if(operand(r3F5F).val);
                                          exec_list *const f3F5E_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3F5E->then_instructions;

                                             body.emit(assign(r3F5D, r3F27, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3F5E->else_instructions;

                                             ir_expression *const r3F60 = nequal(r3F27, body.constant(0u));
                                             ir_expression *const r3F61 = expr(ir_unop_b2i, r3F60);
                                             body.emit(assign(r3F5D, expr(ir_unop_i2u, r3F61), 0x01));


                                          body.instructions = f3F5E_parent_instructions;
                                          body.emit(f3F5E);

                                          /* END IF */

                                          body.emit(assign(r3F4D, r3F5D, 0x01));

                                          body.emit(assign(r3F4E, body.constant(0u), 0x01));


                                       body.instructions = f3F5A_parent_instructions;
                                       body.emit(f3F5A);

                                       /* END IF */


                                    body.instructions = f3F58_parent_instructions;
                                    body.emit(f3F58);

                                    /* END IF */

                                    body.emit(assign(r3F4F, body.constant(0u), 0x01));


                                 body.instructions = f3F54_parent_instructions;
                                 body.emit(f3F54);

                                 /* END IF */

                                 ir_expression *const r3F62 = nequal(r3F4B, body.constant(0u));
                                 ir_expression *const r3F63 = expr(ir_unop_b2i, r3F62);
                                 ir_expression *const r3F64 = expr(ir_unop_i2u, r3F63);
                                 body.emit(assign(r3F4D, bit_or(r3F4D, r3F64), 0x01));


                              body.instructions = f3F52_parent_instructions;
                              body.emit(f3F52);

                              /* END IF */

                              body.emit(assign(r3F27, r3F4F, 0x01));

                              body.emit(assign(r3F28, r3F4E, 0x01));

                              body.emit(assign(r3F29, r3F4D, 0x01));


                           body.instructions = f3F41_parent_instructions;
                           body.emit(f3F41);

                           /* END IF */

                           body.emit(assign(r3F26, sub(r3F26, r3F2A), 0x01));

                           ir_variable *const r3F65 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r3F65, r3F26, 0x01));

                           ir_variable *const r3F66 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r3F66, r3F27, 0x01));

                           ir_variable *const r3F67 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r3F67, r3F28, 0x01));

                           ir_variable *const r3F68 = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r3F68, r3F29, 0x01));

                           ir_variable *const r3F69 = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r3F69, body.constant(true), 0x01));

                           ir_variable *const r3F6A = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r3F6B = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r3F6B);
                           ir_expression *const r3F6C = expr(ir_unop_u2i, r3F29);
                           body.emit(assign(r3F6B, less(r3F6C, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3F6E = lequal(body.constant(int(2045)), r3F26);
                           ir_if *f3F6D = new(mem_ctx) ir_if(operand(r3F6E).val);
                           exec_list *const f3F6D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3F6D->then_instructions;

                              ir_variable *const r3F6F = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r3F71 = less(body.constant(int(2045)), r3F26);
                              ir_if *f3F70 = new(mem_ctx) ir_if(operand(r3F71).val);
                              exec_list *const f3F70_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3F70->then_instructions;

                                 body.emit(assign(r3F6F, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3F70->else_instructions;

                                 ir_variable *const r3F72 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r3F74 = equal(r3F26, body.constant(int(2045)));
                                 ir_if *f3F73 = new(mem_ctx) ir_if(operand(r3F74).val);
                                 exec_list *const f3F73_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3F73->then_instructions;

                                    ir_expression *const r3F75 = equal(body.constant(2097151u), r3F27);
                                    ir_expression *const r3F76 = equal(body.constant(4294967295u), r3F28);
                                    body.emit(assign(r3F72, logic_and(r3F75, r3F76), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3F73->else_instructions;

                                    body.emit(assign(r3F72, body.constant(false), 0x01));


                                 body.instructions = f3F73_parent_instructions;
                                 body.emit(f3F73);

                                 /* END IF */

                                 body.emit(assign(r3F6F, logic_and(r3F72, r3F6B), 0x01));


                              body.instructions = f3F70_parent_instructions;
                              body.emit(f3F70);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f3F77 = new(mem_ctx) ir_if(operand(r3F6F).val);
                              exec_list *const f3F77_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3F77->then_instructions;

                                 ir_variable *const r3F78 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r3F78);
                                 ir_expression *const r3F79 = lshift(r3B95, body.constant(int(31)));
                                 body.emit(assign(r3F78, add(r3F79, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r3F78, body.constant(0u), 0x01));

                                 body.emit(assign(r3F6A, r3F78, 0x03));

                                 body.emit(assign(r3F69, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3F77->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3F7B = less(r3F26, body.constant(int(0)));
                                 ir_if *f3F7A = new(mem_ctx) ir_if(operand(r3F7B).val);
                                 exec_list *const f3F7A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3F7A->then_instructions;

                                    ir_variable *const r3F7C = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r3F7C, r3F29, 0x01));

                                    ir_variable *const r3F7D = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r3F7D, neg(r3F26), 0x01));

                                    ir_variable *const r3F7E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r3F7E);
                                    ir_variable *const r3F7F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r3F7F);
                                    ir_variable *const r3F80 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r3F80);
                                    ir_variable *const r3F81 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r3F82 = neg(r3F7D);
                                    body.emit(assign(r3F81, bit_and(r3F82, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r3F84 = equal(r3F7D, body.constant(int(0)));
                                    ir_if *f3F83 = new(mem_ctx) ir_if(operand(r3F84).val);
                                    exec_list *const f3F83_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3F83->then_instructions;

                                       body.emit(assign(r3F7E, r3F29, 0x01));

                                       body.emit(assign(r3F7F, r3F28, 0x01));

                                       body.emit(assign(r3F80, r3F27, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3F83->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r3F86 = less(r3F7D, body.constant(int(32)));
                                       ir_if *f3F85 = new(mem_ctx) ir_if(operand(r3F86).val);
                                       exec_list *const f3F85_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3F85->then_instructions;

                                          body.emit(assign(r3F7E, lshift(r3F28, r3F81), 0x01));

                                          ir_expression *const r3F87 = lshift(r3F27, r3F81);
                                          ir_expression *const r3F88 = rshift(r3F28, r3F7D);
                                          body.emit(assign(r3F7F, bit_or(r3F87, r3F88), 0x01));

                                          body.emit(assign(r3F80, rshift(r3F27, r3F7D), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3F85->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r3F8A = equal(r3F7D, body.constant(int(32)));
                                          ir_if *f3F89 = new(mem_ctx) ir_if(operand(r3F8A).val);
                                          exec_list *const f3F89_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3F89->then_instructions;

                                             body.emit(assign(r3F7E, r3F28, 0x01));

                                             body.emit(assign(r3F7F, r3F27, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3F89->else_instructions;

                                             body.emit(assign(r3F7C, bit_or(r3F29, r3F28), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r3F8C = less(r3F7D, body.constant(int(64)));
                                             ir_if *f3F8B = new(mem_ctx) ir_if(operand(r3F8C).val);
                                             exec_list *const f3F8B_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f3F8B->then_instructions;

                                                body.emit(assign(r3F7E, lshift(r3F27, r3F81), 0x01));

                                                ir_expression *const r3F8D = bit_and(r3F7D, body.constant(int(31)));
                                                body.emit(assign(r3F7F, rshift(r3F27, r3F8D), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f3F8B->else_instructions;

                                                ir_variable *const r3F8E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r3F90 = equal(r3F7D, body.constant(int(64)));
                                                ir_if *f3F8F = new(mem_ctx) ir_if(operand(r3F90).val);
                                                exec_list *const f3F8F_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f3F8F->then_instructions;

                                                   body.emit(assign(r3F8E, r3F27, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f3F8F->else_instructions;

                                                   ir_expression *const r3F91 = nequal(r3F27, body.constant(0u));
                                                   ir_expression *const r3F92 = expr(ir_unop_b2i, r3F91);
                                                   body.emit(assign(r3F8E, expr(ir_unop_i2u, r3F92), 0x01));


                                                body.instructions = f3F8F_parent_instructions;
                                                body.emit(f3F8F);

                                                /* END IF */

                                                body.emit(assign(r3F7E, r3F8E, 0x01));

                                                body.emit(assign(r3F7F, body.constant(0u), 0x01));


                                             body.instructions = f3F8B_parent_instructions;
                                             body.emit(f3F8B);

                                             /* END IF */


                                          body.instructions = f3F89_parent_instructions;
                                          body.emit(f3F89);

                                          /* END IF */

                                          body.emit(assign(r3F80, body.constant(0u), 0x01));


                                       body.instructions = f3F85_parent_instructions;
                                       body.emit(f3F85);

                                       /* END IF */

                                       ir_expression *const r3F93 = nequal(r3F7C, body.constant(0u));
                                       ir_expression *const r3F94 = expr(ir_unop_b2i, r3F93);
                                       ir_expression *const r3F95 = expr(ir_unop_i2u, r3F94);
                                       body.emit(assign(r3F7E, bit_or(r3F7E, r3F95), 0x01));


                                    body.instructions = f3F83_parent_instructions;
                                    body.emit(f3F83);

                                    /* END IF */

                                    body.emit(assign(r3F66, r3F80, 0x01));

                                    body.emit(assign(r3F67, r3F7F, 0x01));

                                    body.emit(assign(r3F68, r3F7E, 0x01));

                                    body.emit(assign(r3F65, body.constant(int(0)), 0x01));

                                    body.emit(assign(r3F6B, less(r3F7E, body.constant(0u)), 0x01));


                                 body.instructions = f3F7A_parent_instructions;
                                 body.emit(f3F7A);

                                 /* END IF */


                              body.instructions = f3F77_parent_instructions;
                              body.emit(f3F77);

                              /* END IF */


                           body.instructions = f3F6D_parent_instructions;
                           body.emit(f3F6D);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f3F96 = new(mem_ctx) ir_if(operand(r3F69).val);
                           exec_list *const f3F96_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3F96->then_instructions;

                              /* IF CONDITION */
                              ir_if *f3F97 = new(mem_ctx) ir_if(operand(r3F6B).val);
                              exec_list *const f3F97_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3F97->then_instructions;

                                 ir_variable *const r3F98 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r3F98, add(r3F67, body.constant(1u)), 0x01));

                                 ir_expression *const r3F99 = less(r3F98, r3F67);
                                 ir_expression *const r3F9A = expr(ir_unop_b2i, r3F99);
                                 ir_expression *const r3F9B = expr(ir_unop_i2u, r3F9A);
                                 body.emit(assign(r3F66, add(r3F66, r3F9B), 0x01));

                                 ir_expression *const r3F9C = equal(r3F68, body.constant(0u));
                                 ir_expression *const r3F9D = expr(ir_unop_b2i, r3F9C);
                                 ir_expression *const r3F9E = expr(ir_unop_i2u, r3F9D);
                                 ir_expression *const r3F9F = add(r3F68, r3F9E);
                                 ir_expression *const r3FA0 = bit_and(r3F9F, body.constant(1u));
                                 ir_expression *const r3FA1 = expr(ir_unop_bit_not, r3FA0);
                                 body.emit(assign(r3F67, bit_and(r3F98, r3FA1), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3F97->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3FA3 = bit_or(r3F66, r3F67);
                                 ir_expression *const r3FA4 = equal(r3FA3, body.constant(0u));
                                 ir_if *f3FA2 = new(mem_ctx) ir_if(operand(r3FA4).val);
                                 exec_list *const f3FA2_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3FA2->then_instructions;

                                    body.emit(assign(r3F65, body.constant(int(0)), 0x01));


                                 body.instructions = f3FA2_parent_instructions;
                                 body.emit(f3FA2);

                                 /* END IF */


                              body.instructions = f3F97_parent_instructions;
                              body.emit(f3F97);

                              /* END IF */

                              ir_variable *const r3FA5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r3FA5);
                              ir_expression *const r3FA6 = lshift(r3B95, body.constant(int(31)));
                              ir_expression *const r3FA7 = expr(ir_unop_i2u, r3F65);
                              ir_expression *const r3FA8 = lshift(r3FA7, body.constant(int(20)));
                              ir_expression *const r3FA9 = add(r3FA6, r3FA8);
                              body.emit(assign(r3FA5, add(r3FA9, r3F66), 0x02));

                              body.emit(assign(r3FA5, r3F67, 0x01));

                              body.emit(assign(r3F6A, r3FA5, 0x03));

                              body.emit(assign(r3F69, body.constant(false), 0x01));


                           body.instructions = f3F96_parent_instructions;
                           body.emit(f3F96);

                           /* END IF */

                           body.emit(assign(r3B96, r3F6A, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3F1E->else_instructions;

                           ir_variable *const r3FAA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r3FAA);
                           body.emit(assign(r3FAA, body.constant(0u), 0x02));

                           body.emit(assign(r3FAA, body.constant(0u), 0x01));

                           body.emit(assign(r3B96, r3FAA, 0x03));


                        body.instructions = f3F1E_parent_instructions;
                        body.emit(f3F1E);

                        /* END IF */


                     body.instructions = f3E92_parent_instructions;
                     body.emit(f3E92);

                     /* END IF */


                  body.instructions = f3E06_parent_instructions;
                  body.emit(f3E06);

                  /* END IF */


               body.instructions = f3D7A_parent_instructions;
               body.emit(f3D7A);

               /* END IF */


            body.instructions = f3D53_parent_instructions;
            body.emit(f3D53);

            /* END IF */


         body.instructions = f3C7F_parent_instructions;
         body.emit(f3C7F);

         /* END IF */


      body.instructions = f3BAF_parent_instructions;
      body.emit(f3BAF);

      /* END IF */

      body.emit(assign(r3B90, r3B96, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f3B93->else_instructions;

      ir_variable *const r3FAB = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r3FAB, body.constant(true), 0x01));

      ir_variable *const r3FAC = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r3FAD = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r3FAD);
      ir_variable *const r3FAE = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracHi", ir_var_auto);
      body.emit(r3FAE);
      ir_variable *const r3FAF = new(mem_ctx) ir_variable(glsl_type::uint_type, "bFracLo", ir_var_auto);
      body.emit(r3FAF);
      ir_variable *const r3FB0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracHi", ir_var_auto);
      body.emit(r3FB0);
      ir_variable *const r3FB1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracLo", ir_var_auto);
      body.emit(r3FB1);
      ir_variable *const r3FB2 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r3FB2);
      ir_variable *const r3FB3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
      body.emit(r3FB3);
      ir_variable *const r3FB4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
      body.emit(r3FB4);
      body.emit(assign(r3FB4, body.constant(0u), 0x01));

      body.emit(assign(r3FB3, body.constant(0u), 0x01));

      ir_variable *const r3FB5 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
      body.emit(assign(r3FB5, swizzle_x(r321E), 0x01));

      body.emit(assign(r3FB1, r3FB5, 0x01));

      ir_variable *const r3FB6 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
      body.emit(assign(r3FB6, bit_and(swizzle_y(r321E), body.constant(1048575u)), 0x01));

      body.emit(assign(r3FB0, r3FB6, 0x01));

      ir_variable *const r3FB7 = body.make_temp(glsl_type::uint_type, "extractFloat64FracLo_retval");
      body.emit(assign(r3FB7, swizzle_x(r39DE), 0x01));

      body.emit(assign(r3FAF, r3FB7, 0x01));

      ir_variable *const r3FB8 = body.make_temp(glsl_type::uint_type, "extractFloat64FracHi_retval");
      body.emit(assign(r3FB8, bit_and(swizzle_y(r39DE), body.constant(1048575u)), 0x01));

      body.emit(assign(r3FAE, r3FB8, 0x01));

      ir_variable *const r3FB9 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r3FBA = rshift(swizzle_y(r321E), body.constant(int(20)));
      ir_expression *const r3FBB = bit_and(r3FBA, body.constant(2047u));
      body.emit(assign(r3FB9, expr(ir_unop_u2i, r3FBB), 0x01));

      ir_variable *const r3FBC = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r3FBD = rshift(swizzle_y(r39DE), body.constant(int(20)));
      ir_expression *const r3FBE = bit_and(r3FBD, body.constant(2047u));
      body.emit(assign(r3FBC, expr(ir_unop_u2i, r3FBE), 0x01));

      ir_variable *const r3FBF = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r3FBF, sub(r3FB9, r3FBC), 0x01));

      body.emit(assign(r3FAD, r3FBF, 0x01));

      /* IF CONDITION */
      ir_expression *const r3FC1 = less(body.constant(int(0)), r3FBF);
      ir_if *f3FC0 = new(mem_ctx) ir_if(operand(r3FC1).val);
      exec_list *const f3FC0_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f3FC0->then_instructions;

         /* IF CONDITION */
         ir_expression *const r3FC3 = equal(r3FB9, body.constant(int(2047)));
         ir_if *f3FC2 = new(mem_ctx) ir_if(operand(r3FC3).val);
         exec_list *const f3FC2_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3FC2->then_instructions;

            /* IF CONDITION */
            ir_expression *const r3FC5 = bit_or(r3FB6, swizzle_x(r321E));
            ir_expression *const r3FC6 = nequal(r3FC5, body.constant(0u));
            ir_if *f3FC4 = new(mem_ctx) ir_if(operand(r3FC6).val);
            exec_list *const f3FC4_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3FC4->then_instructions;

               ir_variable *const r3FC7 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r3FC7, swizzle_x(r321E), 0x01));

               ir_variable *const r3FC8 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r3FC8, swizzle_x(r39DE), 0x01));

               ir_variable *const r3FC9 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r3FCA = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r3FCB = rshift(swizzle_y(r321E), body.constant(int(19)));
               ir_expression *const r3FCC = bit_and(r3FCB, body.constant(4095u));
               ir_expression *const r3FCD = equal(r3FCC, body.constant(4094u));
               ir_expression *const r3FCE = nequal(swizzle_x(r321E), body.constant(0u));
               ir_expression *const r3FCF = bit_and(swizzle_y(r321E), body.constant(524287u));
               ir_expression *const r3FD0 = nequal(r3FCF, body.constant(0u));
               ir_expression *const r3FD1 = logic_or(r3FCE, r3FD0);
               body.emit(assign(r3FCA, logic_and(r3FCD, r3FD1), 0x01));

               ir_variable *const r3FD2 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r3FD3 = lshift(swizzle_y(r39DE), body.constant(int(1)));
               ir_expression *const r3FD4 = lequal(body.constant(4292870144u), r3FD3);
               ir_expression *const r3FD5 = nequal(swizzle_x(r39DE), body.constant(0u));
               ir_expression *const r3FD6 = bit_and(swizzle_y(r39DE), body.constant(1048575u));
               ir_expression *const r3FD7 = nequal(r3FD6, body.constant(0u));
               ir_expression *const r3FD8 = logic_or(r3FD5, r3FD7);
               body.emit(assign(r3FD2, logic_and(r3FD4, r3FD8), 0x01));

               body.emit(assign(r3FC7, bit_or(swizzle_y(r321E), body.constant(524288u)), 0x02));

               body.emit(assign(r3FC8, bit_or(swizzle_y(r39DE), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r3FDA = lshift(swizzle_y(r321E), body.constant(int(1)));
               ir_expression *const r3FDB = lequal(body.constant(4292870144u), r3FDA);
               ir_expression *const r3FDC = nequal(swizzle_x(r321E), body.constant(0u));
               ir_expression *const r3FDD = bit_and(swizzle_y(r321E), body.constant(1048575u));
               ir_expression *const r3FDE = nequal(r3FDD, body.constant(0u));
               ir_expression *const r3FDF = logic_or(r3FDC, r3FDE);
               ir_expression *const r3FE0 = logic_and(r3FDB, r3FDF);
               ir_if *f3FD9 = new(mem_ctx) ir_if(operand(r3FE0).val);
               exec_list *const f3FD9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3FD9->then_instructions;

                  ir_variable *const r3FE1 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3FE3 = logic_and(r3FCA, r3FD2);
                  ir_if *f3FE2 = new(mem_ctx) ir_if(operand(r3FE3).val);
                  exec_list *const f3FE2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3FE2->then_instructions;

                     body.emit(assign(r3FE1, r3FC8, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3FE2->else_instructions;

                     body.emit(assign(r3FE1, r3FC7, 0x03));


                  body.instructions = f3FE2_parent_instructions;
                  body.emit(f3FE2);

                  /* END IF */

                  body.emit(assign(r3FC9, r3FE1, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3FD9->else_instructions;

                  body.emit(assign(r3FC9, r3FC8, 0x03));


               body.instructions = f3FD9_parent_instructions;
               body.emit(f3FD9);

               /* END IF */

               body.emit(assign(r3FAC, r3FC9, 0x03));

               body.emit(assign(r3FAB, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3FC4->else_instructions;

               body.emit(assign(r3FAC, r321E, 0x03));

               body.emit(assign(r3FAB, body.constant(false), 0x01));


            body.instructions = f3FC4_parent_instructions;
            body.emit(f3FC4);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3FC2->else_instructions;

            /* IF CONDITION */
            ir_expression *const r3FE5 = equal(r3FBC, body.constant(int(0)));
            ir_if *f3FE4 = new(mem_ctx) ir_if(operand(r3FE5).val);
            exec_list *const f3FE4_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3FE4->then_instructions;

               body.emit(assign(r3FAD, add(r3FBF, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3FE4->else_instructions;

               body.emit(assign(r3FAE, bit_or(r3FB8, body.constant(1048576u)), 0x01));


            body.instructions = f3FE4_parent_instructions;
            body.emit(f3FE4);

            /* END IF */

            ir_variable *const r3FE6 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r3FE6, body.constant(0u), 0x01));

            ir_variable *const r3FE7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r3FE7);
            ir_variable *const r3FE8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r3FE8);
            ir_variable *const r3FE9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r3FE9);
            ir_variable *const r3FEA = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r3FEB = neg(r3FAD);
            body.emit(assign(r3FEA, bit_and(r3FEB, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r3FED = equal(r3FAD, body.constant(int(0)));
            ir_if *f3FEC = new(mem_ctx) ir_if(operand(r3FED).val);
            exec_list *const f3FEC_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3FEC->then_instructions;

               body.emit(assign(r3FE7, r3FE6, 0x01));

               body.emit(assign(r3FE8, r3FB7, 0x01));

               body.emit(assign(r3FE9, r3FAE, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3FEC->else_instructions;

               /* IF CONDITION */
               ir_expression *const r3FEF = less(r3FAD, body.constant(int(32)));
               ir_if *f3FEE = new(mem_ctx) ir_if(operand(r3FEF).val);
               exec_list *const f3FEE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3FEE->then_instructions;

                  body.emit(assign(r3FE7, lshift(swizzle_x(r39DE), r3FEA), 0x01));

                  ir_expression *const r3FF0 = lshift(r3FAE, r3FEA);
                  ir_expression *const r3FF1 = rshift(swizzle_x(r39DE), r3FAD);
                  body.emit(assign(r3FE8, bit_or(r3FF0, r3FF1), 0x01));

                  body.emit(assign(r3FE9, rshift(r3FAE, r3FAD), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3FEE->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3FF3 = equal(r3FAD, body.constant(int(32)));
                  ir_if *f3FF2 = new(mem_ctx) ir_if(operand(r3FF3).val);
                  exec_list *const f3FF2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3FF2->then_instructions;

                     body.emit(assign(r3FE7, r3FB7, 0x01));

                     body.emit(assign(r3FE8, r3FAE, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3FF2->else_instructions;

                     body.emit(assign(r3FE6, bit_or(body.constant(0u), swizzle_x(r39DE)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3FF5 = less(r3FAD, body.constant(int(64)));
                     ir_if *f3FF4 = new(mem_ctx) ir_if(operand(r3FF5).val);
                     exec_list *const f3FF4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3FF4->then_instructions;

                        body.emit(assign(r3FE7, lshift(r3FAE, r3FEA), 0x01));

                        ir_expression *const r3FF6 = bit_and(r3FAD, body.constant(int(31)));
                        body.emit(assign(r3FE8, rshift(r3FAE, r3FF6), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3FF4->else_instructions;

                        ir_variable *const r3FF7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r3FF9 = equal(r3FAD, body.constant(int(64)));
                        ir_if *f3FF8 = new(mem_ctx) ir_if(operand(r3FF9).val);
                        exec_list *const f3FF8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3FF8->then_instructions;

                           body.emit(assign(r3FF7, r3FAE, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3FF8->else_instructions;

                           ir_expression *const r3FFA = nequal(r3FAE, body.constant(0u));
                           ir_expression *const r3FFB = expr(ir_unop_b2i, r3FFA);
                           body.emit(assign(r3FF7, expr(ir_unop_i2u, r3FFB), 0x01));


                        body.instructions = f3FF8_parent_instructions;
                        body.emit(f3FF8);

                        /* END IF */

                        body.emit(assign(r3FE7, r3FF7, 0x01));

                        body.emit(assign(r3FE8, body.constant(0u), 0x01));


                     body.instructions = f3FF4_parent_instructions;
                     body.emit(f3FF4);

                     /* END IF */


                  body.instructions = f3FF2_parent_instructions;
                  body.emit(f3FF2);

                  /* END IF */

                  body.emit(assign(r3FE9, body.constant(0u), 0x01));


               body.instructions = f3FEE_parent_instructions;
               body.emit(f3FEE);

               /* END IF */

               ir_expression *const r3FFC = nequal(r3FE6, body.constant(0u));
               ir_expression *const r3FFD = expr(ir_unop_b2i, r3FFC);
               ir_expression *const r3FFE = expr(ir_unop_i2u, r3FFD);
               body.emit(assign(r3FE7, bit_or(r3FE7, r3FFE), 0x01));


            body.instructions = f3FEC_parent_instructions;
            body.emit(f3FEC);

            /* END IF */

            body.emit(assign(r3FAE, r3FE9, 0x01));

            body.emit(assign(r3FAF, r3FE8, 0x01));

            body.emit(assign(r3FB3, r3FE7, 0x01));

            body.emit(assign(r3FB2, r3FB9, 0x01));


         body.instructions = f3FC2_parent_instructions;
         body.emit(f3FC2);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f3FC0->else_instructions;

         /* IF CONDITION */
         ir_expression *const r4000 = less(r3FAD, body.constant(int(0)));
         ir_if *f3FFF = new(mem_ctx) ir_if(operand(r4000).val);
         exec_list *const f3FFF_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3FFF->then_instructions;

            /* IF CONDITION */
            ir_expression *const r4002 = equal(r3FBC, body.constant(int(2047)));
            ir_if *f4001 = new(mem_ctx) ir_if(operand(r4002).val);
            exec_list *const f4001_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f4001->then_instructions;

               /* IF CONDITION */
               ir_expression *const r4004 = bit_or(r3FAE, r3FAF);
               ir_expression *const r4005 = nequal(r4004, body.constant(0u));
               ir_if *f4003 = new(mem_ctx) ir_if(operand(r4005).val);
               exec_list *const f4003_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f4003->then_instructions;

                  ir_variable *const r4006 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r4006, swizzle_x(r321E), 0x01));

                  ir_variable *const r4007 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r4007, swizzle_x(r39DE), 0x01));

                  ir_variable *const r4008 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r4009 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r400A = rshift(swizzle_y(r321E), body.constant(int(19)));
                  ir_expression *const r400B = bit_and(r400A, body.constant(4095u));
                  ir_expression *const r400C = equal(r400B, body.constant(4094u));
                  ir_expression *const r400D = nequal(swizzle_x(r321E), body.constant(0u));
                  ir_expression *const r400E = bit_and(swizzle_y(r321E), body.constant(524287u));
                  ir_expression *const r400F = nequal(r400E, body.constant(0u));
                  ir_expression *const r4010 = logic_or(r400D, r400F);
                  body.emit(assign(r4009, logic_and(r400C, r4010), 0x01));

                  ir_variable *const r4011 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r4012 = lshift(swizzle_y(r39DE), body.constant(int(1)));
                  ir_expression *const r4013 = lequal(body.constant(4292870144u), r4012);
                  ir_expression *const r4014 = nequal(swizzle_x(r39DE), body.constant(0u));
                  ir_expression *const r4015 = bit_and(swizzle_y(r39DE), body.constant(1048575u));
                  ir_expression *const r4016 = nequal(r4015, body.constant(0u));
                  ir_expression *const r4017 = logic_or(r4014, r4016);
                  body.emit(assign(r4011, logic_and(r4013, r4017), 0x01));

                  body.emit(assign(r4006, bit_or(swizzle_y(r321E), body.constant(524288u)), 0x02));

                  body.emit(assign(r4007, bit_or(swizzle_y(r39DE), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r4019 = lshift(swizzle_y(r321E), body.constant(int(1)));
                  ir_expression *const r401A = lequal(body.constant(4292870144u), r4019);
                  ir_expression *const r401B = nequal(swizzle_x(r321E), body.constant(0u));
                  ir_expression *const r401C = bit_and(swizzle_y(r321E), body.constant(1048575u));
                  ir_expression *const r401D = nequal(r401C, body.constant(0u));
                  ir_expression *const r401E = logic_or(r401B, r401D);
                  ir_expression *const r401F = logic_and(r401A, r401E);
                  ir_if *f4018 = new(mem_ctx) ir_if(operand(r401F).val);
                  exec_list *const f4018_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f4018->then_instructions;

                     ir_variable *const r4020 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r4022 = logic_and(r4009, r4011);
                     ir_if *f4021 = new(mem_ctx) ir_if(operand(r4022).val);
                     exec_list *const f4021_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f4021->then_instructions;

                        body.emit(assign(r4020, r4007, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f4021->else_instructions;

                        body.emit(assign(r4020, r4006, 0x03));


                     body.instructions = f4021_parent_instructions;
                     body.emit(f4021);

                     /* END IF */

                     body.emit(assign(r4008, r4020, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f4018->else_instructions;

                     body.emit(assign(r4008, r4007, 0x03));


                  body.instructions = f4018_parent_instructions;
                  body.emit(f4018);

                  /* END IF */

                  body.emit(assign(r3FAC, r4008, 0x03));

                  body.emit(assign(r3FAB, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f4003->else_instructions;

                  ir_variable *const r4023 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r4023);
                  ir_expression *const r4024 = lshift(r3B91, body.constant(int(31)));
                  body.emit(assign(r4023, add(r4024, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r4023, body.constant(0u), 0x01));

                  body.emit(assign(r3FAC, r4023, 0x03));

                  body.emit(assign(r3FAB, body.constant(false), 0x01));


               body.instructions = f4003_parent_instructions;
               body.emit(f4003);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f4001->else_instructions;

               /* IF CONDITION */
               ir_expression *const r4026 = equal(r3FB9, body.constant(int(0)));
               ir_if *f4025 = new(mem_ctx) ir_if(operand(r4026).val);
               exec_list *const f4025_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f4025->then_instructions;

                  body.emit(assign(r3FAD, add(r3FAD, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f4025->else_instructions;

                  body.emit(assign(r3FB0, bit_or(r3FB6, body.constant(1048576u)), 0x01));


               body.instructions = f4025_parent_instructions;
               body.emit(f4025);

               /* END IF */

               ir_variable *const r4027 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r4027, body.constant(0u), 0x01));

               ir_variable *const r4028 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r4028, neg(r3FAD), 0x01));

               ir_variable *const r4029 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r4029);
               ir_variable *const r402A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r402A);
               ir_variable *const r402B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r402B);
               ir_variable *const r402C = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r402D = neg(r4028);
               body.emit(assign(r402C, bit_and(r402D, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r402F = equal(r4028, body.constant(int(0)));
               ir_if *f402E = new(mem_ctx) ir_if(operand(r402F).val);
               exec_list *const f402E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f402E->then_instructions;

                  body.emit(assign(r4029, r4027, 0x01));

                  body.emit(assign(r402A, r3FB5, 0x01));

                  body.emit(assign(r402B, r3FB0, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f402E->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r4031 = less(r4028, body.constant(int(32)));
                  ir_if *f4030 = new(mem_ctx) ir_if(operand(r4031).val);
                  exec_list *const f4030_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f4030->then_instructions;

                     body.emit(assign(r4029, lshift(swizzle_x(r321E), r402C), 0x01));

                     ir_expression *const r4032 = lshift(r3FB0, r402C);
                     ir_expression *const r4033 = rshift(swizzle_x(r321E), r4028);
                     body.emit(assign(r402A, bit_or(r4032, r4033), 0x01));

                     body.emit(assign(r402B, rshift(r3FB0, r4028), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f4030->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r4035 = equal(r4028, body.constant(int(32)));
                     ir_if *f4034 = new(mem_ctx) ir_if(operand(r4035).val);
                     exec_list *const f4034_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f4034->then_instructions;

                        body.emit(assign(r4029, r3FB5, 0x01));

                        body.emit(assign(r402A, r3FB0, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f4034->else_instructions;

                        body.emit(assign(r4027, bit_or(body.constant(0u), swizzle_x(r321E)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r4037 = less(r4028, body.constant(int(64)));
                        ir_if *f4036 = new(mem_ctx) ir_if(operand(r4037).val);
                        exec_list *const f4036_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f4036->then_instructions;

                           body.emit(assign(r4029, lshift(r3FB0, r402C), 0x01));

                           ir_expression *const r4038 = bit_and(r4028, body.constant(int(31)));
                           body.emit(assign(r402A, rshift(r3FB0, r4038), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f4036->else_instructions;

                           ir_variable *const r4039 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r403B = equal(r4028, body.constant(int(64)));
                           ir_if *f403A = new(mem_ctx) ir_if(operand(r403B).val);
                           exec_list *const f403A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f403A->then_instructions;

                              body.emit(assign(r4039, r3FB0, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f403A->else_instructions;

                              ir_expression *const r403C = nequal(r3FB0, body.constant(0u));
                              ir_expression *const r403D = expr(ir_unop_b2i, r403C);
                              body.emit(assign(r4039, expr(ir_unop_i2u, r403D), 0x01));


                           body.instructions = f403A_parent_instructions;
                           body.emit(f403A);

                           /* END IF */

                           body.emit(assign(r4029, r4039, 0x01));

                           body.emit(assign(r402A, body.constant(0u), 0x01));


                        body.instructions = f4036_parent_instructions;
                        body.emit(f4036);

                        /* END IF */


                     body.instructions = f4034_parent_instructions;
                     body.emit(f4034);

                     /* END IF */

                     body.emit(assign(r402B, body.constant(0u), 0x01));


                  body.instructions = f4030_parent_instructions;
                  body.emit(f4030);

                  /* END IF */

                  ir_expression *const r403E = nequal(r4027, body.constant(0u));
                  ir_expression *const r403F = expr(ir_unop_b2i, r403E);
                  ir_expression *const r4040 = expr(ir_unop_i2u, r403F);
                  body.emit(assign(r4029, bit_or(r4029, r4040), 0x01));


               body.instructions = f402E_parent_instructions;
               body.emit(f402E);

               /* END IF */

               body.emit(assign(r3FB0, r402B, 0x01));

               body.emit(assign(r3FB1, r402A, 0x01));

               body.emit(assign(r3FB3, r4029, 0x01));

               body.emit(assign(r3FB2, r3FBC, 0x01));


            body.instructions = f4001_parent_instructions;
            body.emit(f4001);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3FFF->else_instructions;

            /* IF CONDITION */
            ir_expression *const r4042 = equal(r3FB9, body.constant(int(2047)));
            ir_if *f4041 = new(mem_ctx) ir_if(operand(r4042).val);
            exec_list *const f4041_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f4041->then_instructions;

               /* IF CONDITION */
               ir_expression *const r4044 = bit_or(r3FB0, r3FB1);
               ir_expression *const r4045 = bit_or(r3FAE, r3FAF);
               ir_expression *const r4046 = bit_or(r4044, r4045);
               ir_expression *const r4047 = nequal(r4046, body.constant(0u));
               ir_if *f4043 = new(mem_ctx) ir_if(operand(r4047).val);
               exec_list *const f4043_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f4043->then_instructions;

                  ir_variable *const r4048 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r4048, swizzle_x(r321E), 0x01));

                  ir_variable *const r4049 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r4049, swizzle_x(r39DE), 0x01));

                  ir_variable *const r404A = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r404B = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r404C = rshift(swizzle_y(r321E), body.constant(int(19)));
                  ir_expression *const r404D = bit_and(r404C, body.constant(4095u));
                  ir_expression *const r404E = equal(r404D, body.constant(4094u));
                  ir_expression *const r404F = nequal(swizzle_x(r321E), body.constant(0u));
                  ir_expression *const r4050 = bit_and(swizzle_y(r321E), body.constant(524287u));
                  ir_expression *const r4051 = nequal(r4050, body.constant(0u));
                  ir_expression *const r4052 = logic_or(r404F, r4051);
                  body.emit(assign(r404B, logic_and(r404E, r4052), 0x01));

                  ir_variable *const r4053 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r4054 = lshift(swizzle_y(r39DE), body.constant(int(1)));
                  ir_expression *const r4055 = lequal(body.constant(4292870144u), r4054);
                  ir_expression *const r4056 = nequal(swizzle_x(r39DE), body.constant(0u));
                  ir_expression *const r4057 = bit_and(swizzle_y(r39DE), body.constant(1048575u));
                  ir_expression *const r4058 = nequal(r4057, body.constant(0u));
                  ir_expression *const r4059 = logic_or(r4056, r4058);
                  body.emit(assign(r4053, logic_and(r4055, r4059), 0x01));

                  body.emit(assign(r4048, bit_or(swizzle_y(r321E), body.constant(524288u)), 0x02));

                  body.emit(assign(r4049, bit_or(swizzle_y(r39DE), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r405B = lshift(swizzle_y(r321E), body.constant(int(1)));
                  ir_expression *const r405C = lequal(body.constant(4292870144u), r405B);
                  ir_expression *const r405D = nequal(swizzle_x(r321E), body.constant(0u));
                  ir_expression *const r405E = bit_and(swizzle_y(r321E), body.constant(1048575u));
                  ir_expression *const r405F = nequal(r405E, body.constant(0u));
                  ir_expression *const r4060 = logic_or(r405D, r405F);
                  ir_expression *const r4061 = logic_and(r405C, r4060);
                  ir_if *f405A = new(mem_ctx) ir_if(operand(r4061).val);
                  exec_list *const f405A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f405A->then_instructions;

                     ir_variable *const r4062 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r4064 = logic_and(r404B, r4053);
                     ir_if *f4063 = new(mem_ctx) ir_if(operand(r4064).val);
                     exec_list *const f4063_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f4063->then_instructions;

                        body.emit(assign(r4062, r4049, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f4063->else_instructions;

                        body.emit(assign(r4062, r4048, 0x03));


                     body.instructions = f4063_parent_instructions;
                     body.emit(f4063);

                     /* END IF */

                     body.emit(assign(r404A, r4062, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f405A->else_instructions;

                     body.emit(assign(r404A, r4049, 0x03));


                  body.instructions = f405A_parent_instructions;
                  body.emit(f405A);

                  /* END IF */

                  body.emit(assign(r3FAC, r404A, 0x03));

                  body.emit(assign(r3FAB, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f4043->else_instructions;

                  body.emit(assign(r3FAC, r321E, 0x03));

                  body.emit(assign(r3FAB, body.constant(false), 0x01));


               body.instructions = f4043_parent_instructions;
               body.emit(f4043);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f4041->else_instructions;

               ir_variable *const r4065 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r4066 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r4066, add(r3FB1, r3FAF), 0x01));

               ir_expression *const r4067 = add(r3FB0, r3FAE);
               ir_expression *const r4068 = less(r4066, r3FB1);
               ir_expression *const r4069 = expr(ir_unop_b2i, r4068);
               ir_expression *const r406A = expr(ir_unop_i2u, r4069);
               body.emit(assign(r4065, add(r4067, r406A), 0x01));

               body.emit(assign(r3FB4, r4065, 0x01));

               /* IF CONDITION */
               ir_expression *const r406C = equal(r3FB9, body.constant(int(0)));
               ir_if *f406B = new(mem_ctx) ir_if(operand(r406C).val);
               exec_list *const f406B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f406B->then_instructions;

                  ir_variable *const r406D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r406D);
                  ir_expression *const r406E = lshift(r3B91, body.constant(int(31)));
                  body.emit(assign(r406D, add(r406E, r4065), 0x02));

                  body.emit(assign(r406D, r4066, 0x01));

                  body.emit(assign(r3FAC, r406D, 0x03));

                  body.emit(assign(r3FAB, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f406B->else_instructions;

                  body.emit(assign(r3FB4, bit_or(r4065, body.constant(2097152u)), 0x01));

                  body.emit(assign(r3FB2, r3FB9, 0x01));

                  ir_variable *const r406F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r406F);
                  ir_variable *const r4070 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r4070);
                  ir_variable *const r4071 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r4071);
                  body.emit(assign(r406F, lshift(r4066, body.constant(int(31))), 0x01));

                  ir_expression *const r4072 = lshift(r3FB4, body.constant(int(31)));
                  ir_expression *const r4073 = rshift(r4066, body.constant(int(1)));
                  body.emit(assign(r4070, bit_or(r4072, r4073), 0x01));

                  body.emit(assign(r4071, rshift(r3FB4, body.constant(int(1))), 0x01));

                  body.emit(assign(r406F, bit_or(r406F, body.constant(0u)), 0x01));

                  body.emit(assign(r3FB4, r4071, 0x01));

                  body.emit(assign(r3FB3, r406F, 0x01));

                  ir_variable *const r4074 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r4074, r3FB9, 0x01));

                  ir_variable *const r4075 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r4075, r4071, 0x01));

                  ir_variable *const r4076 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r4076, r4070, 0x01));

                  ir_variable *const r4077 = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r4077, r406F, 0x01));

                  ir_variable *const r4078 = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r4078, body.constant(true), 0x01));

                  ir_variable *const r4079 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r407A = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r407A);
                  ir_expression *const r407B = expr(ir_unop_u2i, r406F);
                  body.emit(assign(r407A, less(r407B, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r407D = lequal(body.constant(int(2045)), r3FB9);
                  ir_if *f407C = new(mem_ctx) ir_if(operand(r407D).val);
                  exec_list *const f407C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f407C->then_instructions;

                     ir_variable *const r407E = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r4080 = less(body.constant(int(2045)), r3FB9);
                     ir_if *f407F = new(mem_ctx) ir_if(operand(r4080).val);
                     exec_list *const f407F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f407F->then_instructions;

                        body.emit(assign(r407E, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f407F->else_instructions;

                        ir_variable *const r4081 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r4083 = equal(r3FB9, body.constant(int(2045)));
                        ir_if *f4082 = new(mem_ctx) ir_if(operand(r4083).val);
                        exec_list *const f4082_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f4082->then_instructions;

                           ir_expression *const r4084 = equal(body.constant(2097151u), r4071);
                           ir_expression *const r4085 = equal(body.constant(4294967295u), r4070);
                           body.emit(assign(r4081, logic_and(r4084, r4085), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f4082->else_instructions;

                           body.emit(assign(r4081, body.constant(false), 0x01));


                        body.instructions = f4082_parent_instructions;
                        body.emit(f4082);

                        /* END IF */

                        body.emit(assign(r407E, logic_and(r4081, r407A), 0x01));


                     body.instructions = f407F_parent_instructions;
                     body.emit(f407F);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f4086 = new(mem_ctx) ir_if(operand(r407E).val);
                     exec_list *const f4086_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f4086->then_instructions;

                        ir_variable *const r4087 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r4087);
                        ir_expression *const r4088 = lshift(r3B91, body.constant(int(31)));
                        body.emit(assign(r4087, add(r4088, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r4087, body.constant(0u), 0x01));

                        body.emit(assign(r4079, r4087, 0x03));

                        body.emit(assign(r4078, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f4086->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r408A = less(r3FB9, body.constant(int(0)));
                        ir_if *f4089 = new(mem_ctx) ir_if(operand(r408A).val);
                        exec_list *const f4089_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f4089->then_instructions;

                           ir_variable *const r408B = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r408B, r406F, 0x01));

                           ir_variable *const r408C = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r408C, neg(r3FB9), 0x01));

                           ir_variable *const r408D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r408D);
                           ir_variable *const r408E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r408E);
                           ir_variable *const r408F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r408F);
                           ir_variable *const r4090 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r4091 = neg(r408C);
                           body.emit(assign(r4090, bit_and(r4091, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r4093 = equal(r408C, body.constant(int(0)));
                           ir_if *f4092 = new(mem_ctx) ir_if(operand(r4093).val);
                           exec_list *const f4092_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f4092->then_instructions;

                              body.emit(assign(r408D, r406F, 0x01));

                              body.emit(assign(r408E, r4070, 0x01));

                              body.emit(assign(r408F, r4071, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f4092->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r4095 = less(r408C, body.constant(int(32)));
                              ir_if *f4094 = new(mem_ctx) ir_if(operand(r4095).val);
                              exec_list *const f4094_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f4094->then_instructions;

                                 body.emit(assign(r408D, lshift(r4070, r4090), 0x01));

                                 ir_expression *const r4096 = lshift(r4071, r4090);
                                 ir_expression *const r4097 = rshift(r4070, r408C);
                                 body.emit(assign(r408E, bit_or(r4096, r4097), 0x01));

                                 body.emit(assign(r408F, rshift(r4071, r408C), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f4094->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r4099 = equal(r408C, body.constant(int(32)));
                                 ir_if *f4098 = new(mem_ctx) ir_if(operand(r4099).val);
                                 exec_list *const f4098_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f4098->then_instructions;

                                    body.emit(assign(r408D, r4070, 0x01));

                                    body.emit(assign(r408E, r4071, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f4098->else_instructions;

                                    body.emit(assign(r408B, bit_or(r406F, r4070), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r409B = less(r408C, body.constant(int(64)));
                                    ir_if *f409A = new(mem_ctx) ir_if(operand(r409B).val);
                                    exec_list *const f409A_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f409A->then_instructions;

                                       body.emit(assign(r408D, lshift(r4071, r4090), 0x01));

                                       ir_expression *const r409C = bit_and(r408C, body.constant(int(31)));
                                       body.emit(assign(r408E, rshift(r4071, r409C), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f409A->else_instructions;

                                       ir_variable *const r409D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r409F = equal(r408C, body.constant(int(64)));
                                       ir_if *f409E = new(mem_ctx) ir_if(operand(r409F).val);
                                       exec_list *const f409E_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f409E->then_instructions;

                                          body.emit(assign(r409D, r4071, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f409E->else_instructions;

                                          ir_expression *const r40A0 = nequal(r4071, body.constant(0u));
                                          ir_expression *const r40A1 = expr(ir_unop_b2i, r40A0);
                                          body.emit(assign(r409D, expr(ir_unop_i2u, r40A1), 0x01));


                                       body.instructions = f409E_parent_instructions;
                                       body.emit(f409E);

                                       /* END IF */

                                       body.emit(assign(r408D, r409D, 0x01));

                                       body.emit(assign(r408E, body.constant(0u), 0x01));


                                    body.instructions = f409A_parent_instructions;
                                    body.emit(f409A);

                                    /* END IF */


                                 body.instructions = f4098_parent_instructions;
                                 body.emit(f4098);

                                 /* END IF */

                                 body.emit(assign(r408F, body.constant(0u), 0x01));


                              body.instructions = f4094_parent_instructions;
                              body.emit(f4094);

                              /* END IF */

                              ir_expression *const r40A2 = nequal(r408B, body.constant(0u));
                              ir_expression *const r40A3 = expr(ir_unop_b2i, r40A2);
                              ir_expression *const r40A4 = expr(ir_unop_i2u, r40A3);
                              body.emit(assign(r408D, bit_or(r408D, r40A4), 0x01));


                           body.instructions = f4092_parent_instructions;
                           body.emit(f4092);

                           /* END IF */

                           body.emit(assign(r4075, r408F, 0x01));

                           body.emit(assign(r4076, r408E, 0x01));

                           body.emit(assign(r4077, r408D, 0x01));

                           body.emit(assign(r4074, body.constant(int(0)), 0x01));

                           body.emit(assign(r407A, less(r408D, body.constant(0u)), 0x01));


                        body.instructions = f4089_parent_instructions;
                        body.emit(f4089);

                        /* END IF */


                     body.instructions = f4086_parent_instructions;
                     body.emit(f4086);

                     /* END IF */


                  body.instructions = f407C_parent_instructions;
                  body.emit(f407C);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f40A5 = new(mem_ctx) ir_if(operand(r4078).val);
                  exec_list *const f40A5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f40A5->then_instructions;

                     /* IF CONDITION */
                     ir_if *f40A6 = new(mem_ctx) ir_if(operand(r407A).val);
                     exec_list *const f40A6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f40A6->then_instructions;

                        ir_variable *const r40A7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r40A7, add(r4076, body.constant(1u)), 0x01));

                        ir_expression *const r40A8 = less(r40A7, r4076);
                        ir_expression *const r40A9 = expr(ir_unop_b2i, r40A8);
                        ir_expression *const r40AA = expr(ir_unop_i2u, r40A9);
                        body.emit(assign(r4075, add(r4075, r40AA), 0x01));

                        ir_expression *const r40AB = equal(r4077, body.constant(0u));
                        ir_expression *const r40AC = expr(ir_unop_b2i, r40AB);
                        ir_expression *const r40AD = expr(ir_unop_i2u, r40AC);
                        ir_expression *const r40AE = add(r4077, r40AD);
                        ir_expression *const r40AF = bit_and(r40AE, body.constant(1u));
                        ir_expression *const r40B0 = expr(ir_unop_bit_not, r40AF);
                        body.emit(assign(r4076, bit_and(r40A7, r40B0), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f40A6->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r40B2 = bit_or(r4075, r4076);
                        ir_expression *const r40B3 = equal(r40B2, body.constant(0u));
                        ir_if *f40B1 = new(mem_ctx) ir_if(operand(r40B3).val);
                        exec_list *const f40B1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f40B1->then_instructions;

                           body.emit(assign(r4074, body.constant(int(0)), 0x01));


                        body.instructions = f40B1_parent_instructions;
                        body.emit(f40B1);

                        /* END IF */


                     body.instructions = f40A6_parent_instructions;
                     body.emit(f40A6);

                     /* END IF */

                     ir_variable *const r40B4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r40B4);
                     ir_expression *const r40B5 = lshift(r3B91, body.constant(int(31)));
                     ir_expression *const r40B6 = expr(ir_unop_i2u, r4074);
                     ir_expression *const r40B7 = lshift(r40B6, body.constant(int(20)));
                     ir_expression *const r40B8 = add(r40B5, r40B7);
                     body.emit(assign(r40B4, add(r40B8, r4075), 0x02));

                     body.emit(assign(r40B4, r4076, 0x01));

                     body.emit(assign(r4079, r40B4, 0x03));

                     body.emit(assign(r4078, body.constant(false), 0x01));


                  body.instructions = f40A5_parent_instructions;
                  body.emit(f40A5);

                  /* END IF */

                  body.emit(assign(r3FAC, r4079, 0x03));

                  body.emit(assign(r3FAB, body.constant(false), 0x01));


               body.instructions = f406B_parent_instructions;
               body.emit(f406B);

               /* END IF */


            body.instructions = f4041_parent_instructions;
            body.emit(f4041);

            /* END IF */


         body.instructions = f3FFF_parent_instructions;
         body.emit(f3FFF);

         /* END IF */


      body.instructions = f3FC0_parent_instructions;
      body.emit(f3FC0);

      /* END IF */

      /* IF CONDITION */
      ir_if *f40B9 = new(mem_ctx) ir_if(operand(r3FAB).val);
      exec_list *const f40B9_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f40B9->then_instructions;

         body.emit(assign(r3FB0, bit_or(r3FB0, body.constant(1048576u)), 0x01));

         ir_variable *const r40BA = body.make_temp(glsl_type::uint_type, "z0Ptr");
         ir_variable *const r40BB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r40BB, add(r3FB1, r3FAF), 0x01));

         ir_expression *const r40BC = add(r3FB0, r3FAE);
         ir_expression *const r40BD = less(r40BB, r3FB1);
         ir_expression *const r40BE = expr(ir_unop_b2i, r40BD);
         ir_expression *const r40BF = expr(ir_unop_i2u, r40BE);
         body.emit(assign(r40BA, add(r40BC, r40BF), 0x01));

         body.emit(assign(r3FB4, r40BA, 0x01));

         body.emit(assign(r3FB2, add(r3FB2, body.constant(int(-1))), 0x01));

         /* IF CONDITION */
         ir_expression *const r40C1 = less(r40BA, body.constant(2097152u));
         ir_if *f40C0 = new(mem_ctx) ir_if(operand(r40C1).val);
         exec_list *const f40C0_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f40C0->then_instructions;

            ir_variable *const r40C2 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r40C2, r3FB2, 0x01));

            ir_variable *const r40C3 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r40C3, r40BA, 0x01));

            ir_variable *const r40C4 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r40C4, r40BB, 0x01));

            ir_variable *const r40C5 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r40C5, r3FB3, 0x01));

            ir_variable *const r40C6 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r40C6, body.constant(true), 0x01));

            ir_variable *const r40C7 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r40C8 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r40C8);
            ir_expression *const r40C9 = expr(ir_unop_u2i, r3FB3);
            body.emit(assign(r40C8, less(r40C9, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r40CB = lequal(body.constant(int(2045)), r3FB2);
            ir_if *f40CA = new(mem_ctx) ir_if(operand(r40CB).val);
            exec_list *const f40CA_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f40CA->then_instructions;

               ir_variable *const r40CC = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r40CE = less(body.constant(int(2045)), r3FB2);
               ir_if *f40CD = new(mem_ctx) ir_if(operand(r40CE).val);
               exec_list *const f40CD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f40CD->then_instructions;

                  body.emit(assign(r40CC, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f40CD->else_instructions;

                  ir_variable *const r40CF = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r40D1 = equal(r3FB2, body.constant(int(2045)));
                  ir_if *f40D0 = new(mem_ctx) ir_if(operand(r40D1).val);
                  exec_list *const f40D0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f40D0->then_instructions;

                     ir_expression *const r40D2 = equal(body.constant(2097151u), r40BA);
                     ir_expression *const r40D3 = equal(body.constant(4294967295u), r40BB);
                     body.emit(assign(r40CF, logic_and(r40D2, r40D3), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f40D0->else_instructions;

                     body.emit(assign(r40CF, body.constant(false), 0x01));


                  body.instructions = f40D0_parent_instructions;
                  body.emit(f40D0);

                  /* END IF */

                  body.emit(assign(r40CC, logic_and(r40CF, r40C8), 0x01));


               body.instructions = f40CD_parent_instructions;
               body.emit(f40CD);

               /* END IF */

               /* IF CONDITION */
               ir_if *f40D4 = new(mem_ctx) ir_if(operand(r40CC).val);
               exec_list *const f40D4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f40D4->then_instructions;

                  ir_variable *const r40D5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r40D5);
                  ir_expression *const r40D6 = lshift(r3B91, body.constant(int(31)));
                  body.emit(assign(r40D5, add(r40D6, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r40D5, body.constant(0u), 0x01));

                  body.emit(assign(r40C7, r40D5, 0x03));

                  body.emit(assign(r40C6, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f40D4->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r40D8 = less(r3FB2, body.constant(int(0)));
                  ir_if *f40D7 = new(mem_ctx) ir_if(operand(r40D8).val);
                  exec_list *const f40D7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f40D7->then_instructions;

                     ir_variable *const r40D9 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r40D9, r3FB3, 0x01));

                     ir_variable *const r40DA = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r40DA, neg(r3FB2), 0x01));

                     ir_variable *const r40DB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r40DB);
                     ir_variable *const r40DC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r40DC);
                     ir_variable *const r40DD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r40DD);
                     ir_variable *const r40DE = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r40DF = neg(r40DA);
                     body.emit(assign(r40DE, bit_and(r40DF, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r40E1 = equal(r40DA, body.constant(int(0)));
                     ir_if *f40E0 = new(mem_ctx) ir_if(operand(r40E1).val);
                     exec_list *const f40E0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f40E0->then_instructions;

                        body.emit(assign(r40DB, r3FB3, 0x01));

                        body.emit(assign(r40DC, r40BB, 0x01));

                        body.emit(assign(r40DD, r40BA, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f40E0->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r40E3 = less(r40DA, body.constant(int(32)));
                        ir_if *f40E2 = new(mem_ctx) ir_if(operand(r40E3).val);
                        exec_list *const f40E2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f40E2->then_instructions;

                           body.emit(assign(r40DB, lshift(r40BB, r40DE), 0x01));

                           ir_expression *const r40E4 = lshift(r40BA, r40DE);
                           ir_expression *const r40E5 = rshift(r40BB, r40DA);
                           body.emit(assign(r40DC, bit_or(r40E4, r40E5), 0x01));

                           body.emit(assign(r40DD, rshift(r40BA, r40DA), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f40E2->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r40E7 = equal(r40DA, body.constant(int(32)));
                           ir_if *f40E6 = new(mem_ctx) ir_if(operand(r40E7).val);
                           exec_list *const f40E6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f40E6->then_instructions;

                              body.emit(assign(r40DB, r40BB, 0x01));

                              body.emit(assign(r40DC, r40BA, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f40E6->else_instructions;

                              body.emit(assign(r40D9, bit_or(r3FB3, r40BB), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r40E9 = less(r40DA, body.constant(int(64)));
                              ir_if *f40E8 = new(mem_ctx) ir_if(operand(r40E9).val);
                              exec_list *const f40E8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f40E8->then_instructions;

                                 body.emit(assign(r40DB, lshift(r40BA, r40DE), 0x01));

                                 ir_expression *const r40EA = bit_and(r40DA, body.constant(int(31)));
                                 body.emit(assign(r40DC, rshift(r40BA, r40EA), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f40E8->else_instructions;

                                 ir_variable *const r40EB = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r40ED = equal(r40DA, body.constant(int(64)));
                                 ir_if *f40EC = new(mem_ctx) ir_if(operand(r40ED).val);
                                 exec_list *const f40EC_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f40EC->then_instructions;

                                    body.emit(assign(r40EB, r40BA, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f40EC->else_instructions;

                                    ir_expression *const r40EE = nequal(r40BA, body.constant(0u));
                                    ir_expression *const r40EF = expr(ir_unop_b2i, r40EE);
                                    body.emit(assign(r40EB, expr(ir_unop_i2u, r40EF), 0x01));


                                 body.instructions = f40EC_parent_instructions;
                                 body.emit(f40EC);

                                 /* END IF */

                                 body.emit(assign(r40DB, r40EB, 0x01));

                                 body.emit(assign(r40DC, body.constant(0u), 0x01));


                              body.instructions = f40E8_parent_instructions;
                              body.emit(f40E8);

                              /* END IF */


                           body.instructions = f40E6_parent_instructions;
                           body.emit(f40E6);

                           /* END IF */

                           body.emit(assign(r40DD, body.constant(0u), 0x01));


                        body.instructions = f40E2_parent_instructions;
                        body.emit(f40E2);

                        /* END IF */

                        ir_expression *const r40F0 = nequal(r40D9, body.constant(0u));
                        ir_expression *const r40F1 = expr(ir_unop_b2i, r40F0);
                        ir_expression *const r40F2 = expr(ir_unop_i2u, r40F1);
                        body.emit(assign(r40DB, bit_or(r40DB, r40F2), 0x01));


                     body.instructions = f40E0_parent_instructions;
                     body.emit(f40E0);

                     /* END IF */

                     body.emit(assign(r40C3, r40DD, 0x01));

                     body.emit(assign(r40C4, r40DC, 0x01));

                     body.emit(assign(r40C5, r40DB, 0x01));

                     body.emit(assign(r40C2, body.constant(int(0)), 0x01));

                     body.emit(assign(r40C8, less(r40DB, body.constant(0u)), 0x01));


                  body.instructions = f40D7_parent_instructions;
                  body.emit(f40D7);

                  /* END IF */


               body.instructions = f40D4_parent_instructions;
               body.emit(f40D4);

               /* END IF */


            body.instructions = f40CA_parent_instructions;
            body.emit(f40CA);

            /* END IF */

            /* IF CONDITION */
            ir_if *f40F3 = new(mem_ctx) ir_if(operand(r40C6).val);
            exec_list *const f40F3_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f40F3->then_instructions;

               /* IF CONDITION */
               ir_if *f40F4 = new(mem_ctx) ir_if(operand(r40C8).val);
               exec_list *const f40F4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f40F4->then_instructions;

                  ir_variable *const r40F5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r40F5, add(r40C4, body.constant(1u)), 0x01));

                  ir_expression *const r40F6 = less(r40F5, r40C4);
                  ir_expression *const r40F7 = expr(ir_unop_b2i, r40F6);
                  ir_expression *const r40F8 = expr(ir_unop_i2u, r40F7);
                  body.emit(assign(r40C3, add(r40C3, r40F8), 0x01));

                  ir_expression *const r40F9 = equal(r40C5, body.constant(0u));
                  ir_expression *const r40FA = expr(ir_unop_b2i, r40F9);
                  ir_expression *const r40FB = expr(ir_unop_i2u, r40FA);
                  ir_expression *const r40FC = add(r40C5, r40FB);
                  ir_expression *const r40FD = bit_and(r40FC, body.constant(1u));
                  ir_expression *const r40FE = expr(ir_unop_bit_not, r40FD);
                  body.emit(assign(r40C4, bit_and(r40F5, r40FE), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f40F4->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r4100 = bit_or(r40C3, r40C4);
                  ir_expression *const r4101 = equal(r4100, body.constant(0u));
                  ir_if *f40FF = new(mem_ctx) ir_if(operand(r4101).val);
                  exec_list *const f40FF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f40FF->then_instructions;

                     body.emit(assign(r40C2, body.constant(int(0)), 0x01));


                  body.instructions = f40FF_parent_instructions;
                  body.emit(f40FF);

                  /* END IF */


               body.instructions = f40F4_parent_instructions;
               body.emit(f40F4);

               /* END IF */

               ir_variable *const r4102 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r4102);
               ir_expression *const r4103 = lshift(r3B91, body.constant(int(31)));
               ir_expression *const r4104 = expr(ir_unop_i2u, r40C2);
               ir_expression *const r4105 = lshift(r4104, body.constant(int(20)));
               ir_expression *const r4106 = add(r4103, r4105);
               body.emit(assign(r4102, add(r4106, r40C3), 0x02));

               body.emit(assign(r4102, r40C4, 0x01));

               body.emit(assign(r40C7, r4102, 0x03));

               body.emit(assign(r40C6, body.constant(false), 0x01));


            body.instructions = f40F3_parent_instructions;
            body.emit(f40F3);

            /* END IF */

            body.emit(assign(r3FAC, r40C7, 0x03));

            body.emit(assign(r3FAB, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f40C0->else_instructions;

            body.emit(assign(r3FB2, add(r3FB2, body.constant(int(1))), 0x01));

            ir_variable *const r4107 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r4107);
            ir_variable *const r4108 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r4108);
            ir_variable *const r4109 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r4109);
            body.emit(assign(r4107, lshift(r40BB, body.constant(int(31))), 0x01));

            ir_expression *const r410A = lshift(r40BA, body.constant(int(31)));
            ir_expression *const r410B = rshift(r40BB, body.constant(int(1)));
            body.emit(assign(r4108, bit_or(r410A, r410B), 0x01));

            body.emit(assign(r4109, rshift(r40BA, body.constant(int(1))), 0x01));

            ir_expression *const r410C = nequal(r3FB3, body.constant(0u));
            ir_expression *const r410D = expr(ir_unop_b2i, r410C);
            ir_expression *const r410E = expr(ir_unop_i2u, r410D);
            body.emit(assign(r4107, bit_or(r4107, r410E), 0x01));

            body.emit(assign(r3FB4, r4109, 0x01));

            body.emit(assign(r3FB3, r4107, 0x01));

            ir_variable *const r410F = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r410F, r3FB2, 0x01));

            ir_variable *const r4110 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r4110, r4109, 0x01));

            ir_variable *const r4111 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r4111, r4108, 0x01));

            ir_variable *const r4112 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r4112, r4107, 0x01));

            ir_variable *const r4113 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r4113, body.constant(true), 0x01));

            ir_variable *const r4114 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r4115 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r4115);
            ir_expression *const r4116 = expr(ir_unop_u2i, r4107);
            body.emit(assign(r4115, less(r4116, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r4118 = lequal(body.constant(int(2045)), r3FB2);
            ir_if *f4117 = new(mem_ctx) ir_if(operand(r4118).val);
            exec_list *const f4117_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f4117->then_instructions;

               ir_variable *const r4119 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r411B = less(body.constant(int(2045)), r3FB2);
               ir_if *f411A = new(mem_ctx) ir_if(operand(r411B).val);
               exec_list *const f411A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f411A->then_instructions;

                  body.emit(assign(r4119, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f411A->else_instructions;

                  ir_variable *const r411C = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r411E = equal(r3FB2, body.constant(int(2045)));
                  ir_if *f411D = new(mem_ctx) ir_if(operand(r411E).val);
                  exec_list *const f411D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f411D->then_instructions;

                     ir_expression *const r411F = equal(body.constant(2097151u), r4109);
                     ir_expression *const r4120 = equal(body.constant(4294967295u), r4108);
                     body.emit(assign(r411C, logic_and(r411F, r4120), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f411D->else_instructions;

                     body.emit(assign(r411C, body.constant(false), 0x01));


                  body.instructions = f411D_parent_instructions;
                  body.emit(f411D);

                  /* END IF */

                  body.emit(assign(r4119, logic_and(r411C, r4115), 0x01));


               body.instructions = f411A_parent_instructions;
               body.emit(f411A);

               /* END IF */

               /* IF CONDITION */
               ir_if *f4121 = new(mem_ctx) ir_if(operand(r4119).val);
               exec_list *const f4121_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f4121->then_instructions;

                  ir_variable *const r4122 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r4122);
                  ir_expression *const r4123 = lshift(r3B91, body.constant(int(31)));
                  body.emit(assign(r4122, add(r4123, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r4122, body.constant(0u), 0x01));

                  body.emit(assign(r4114, r4122, 0x03));

                  body.emit(assign(r4113, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f4121->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r4125 = less(r3FB2, body.constant(int(0)));
                  ir_if *f4124 = new(mem_ctx) ir_if(operand(r4125).val);
                  exec_list *const f4124_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f4124->then_instructions;

                     ir_variable *const r4126 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r4126, r4107, 0x01));

                     ir_variable *const r4127 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r4127, neg(r3FB2), 0x01));

                     ir_variable *const r4128 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r4128);
                     ir_variable *const r4129 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r4129);
                     ir_variable *const r412A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r412A);
                     ir_variable *const r412B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r412C = neg(r4127);
                     body.emit(assign(r412B, bit_and(r412C, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r412E = equal(r4127, body.constant(int(0)));
                     ir_if *f412D = new(mem_ctx) ir_if(operand(r412E).val);
                     exec_list *const f412D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f412D->then_instructions;

                        body.emit(assign(r4128, r4107, 0x01));

                        body.emit(assign(r4129, r4108, 0x01));

                        body.emit(assign(r412A, r4109, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f412D->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r4130 = less(r4127, body.constant(int(32)));
                        ir_if *f412F = new(mem_ctx) ir_if(operand(r4130).val);
                        exec_list *const f412F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f412F->then_instructions;

                           body.emit(assign(r4128, lshift(r4108, r412B), 0x01));

                           ir_expression *const r4131 = lshift(r4109, r412B);
                           ir_expression *const r4132 = rshift(r4108, r4127);
                           body.emit(assign(r4129, bit_or(r4131, r4132), 0x01));

                           body.emit(assign(r412A, rshift(r4109, r4127), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f412F->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r4134 = equal(r4127, body.constant(int(32)));
                           ir_if *f4133 = new(mem_ctx) ir_if(operand(r4134).val);
                           exec_list *const f4133_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f4133->then_instructions;

                              body.emit(assign(r4128, r4108, 0x01));

                              body.emit(assign(r4129, r4109, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f4133->else_instructions;

                              body.emit(assign(r4126, bit_or(r4107, r4108), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r4136 = less(r4127, body.constant(int(64)));
                              ir_if *f4135 = new(mem_ctx) ir_if(operand(r4136).val);
                              exec_list *const f4135_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f4135->then_instructions;

                                 body.emit(assign(r4128, lshift(r4109, r412B), 0x01));

                                 ir_expression *const r4137 = bit_and(r4127, body.constant(int(31)));
                                 body.emit(assign(r4129, rshift(r4109, r4137), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f4135->else_instructions;

                                 ir_variable *const r4138 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r413A = equal(r4127, body.constant(int(64)));
                                 ir_if *f4139 = new(mem_ctx) ir_if(operand(r413A).val);
                                 exec_list *const f4139_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f4139->then_instructions;

                                    body.emit(assign(r4138, r4109, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f4139->else_instructions;

                                    ir_expression *const r413B = nequal(r4109, body.constant(0u));
                                    ir_expression *const r413C = expr(ir_unop_b2i, r413B);
                                    body.emit(assign(r4138, expr(ir_unop_i2u, r413C), 0x01));


                                 body.instructions = f4139_parent_instructions;
                                 body.emit(f4139);

                                 /* END IF */

                                 body.emit(assign(r4128, r4138, 0x01));

                                 body.emit(assign(r4129, body.constant(0u), 0x01));


                              body.instructions = f4135_parent_instructions;
                              body.emit(f4135);

                              /* END IF */


                           body.instructions = f4133_parent_instructions;
                           body.emit(f4133);

                           /* END IF */

                           body.emit(assign(r412A, body.constant(0u), 0x01));


                        body.instructions = f412F_parent_instructions;
                        body.emit(f412F);

                        /* END IF */

                        ir_expression *const r413D = nequal(r4126, body.constant(0u));
                        ir_expression *const r413E = expr(ir_unop_b2i, r413D);
                        ir_expression *const r413F = expr(ir_unop_i2u, r413E);
                        body.emit(assign(r4128, bit_or(r4128, r413F), 0x01));


                     body.instructions = f412D_parent_instructions;
                     body.emit(f412D);

                     /* END IF */

                     body.emit(assign(r4110, r412A, 0x01));

                     body.emit(assign(r4111, r4129, 0x01));

                     body.emit(assign(r4112, r4128, 0x01));

                     body.emit(assign(r410F, body.constant(int(0)), 0x01));

                     body.emit(assign(r4115, less(r4128, body.constant(0u)), 0x01));


                  body.instructions = f4124_parent_instructions;
                  body.emit(f4124);

                  /* END IF */


               body.instructions = f4121_parent_instructions;
               body.emit(f4121);

               /* END IF */


            body.instructions = f4117_parent_instructions;
            body.emit(f4117);

            /* END IF */

            /* IF CONDITION */
            ir_if *f4140 = new(mem_ctx) ir_if(operand(r4113).val);
            exec_list *const f4140_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f4140->then_instructions;

               /* IF CONDITION */
               ir_if *f4141 = new(mem_ctx) ir_if(operand(r4115).val);
               exec_list *const f4141_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f4141->then_instructions;

                  ir_variable *const r4142 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r4142, add(r4111, body.constant(1u)), 0x01));

                  ir_expression *const r4143 = less(r4142, r4111);
                  ir_expression *const r4144 = expr(ir_unop_b2i, r4143);
                  ir_expression *const r4145 = expr(ir_unop_i2u, r4144);
                  body.emit(assign(r4110, add(r4110, r4145), 0x01));

                  ir_expression *const r4146 = equal(r4112, body.constant(0u));
                  ir_expression *const r4147 = expr(ir_unop_b2i, r4146);
                  ir_expression *const r4148 = expr(ir_unop_i2u, r4147);
                  ir_expression *const r4149 = add(r4112, r4148);
                  ir_expression *const r414A = bit_and(r4149, body.constant(1u));
                  ir_expression *const r414B = expr(ir_unop_bit_not, r414A);
                  body.emit(assign(r4111, bit_and(r4142, r414B), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f4141->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r414D = bit_or(r4110, r4111);
                  ir_expression *const r414E = equal(r414D, body.constant(0u));
                  ir_if *f414C = new(mem_ctx) ir_if(operand(r414E).val);
                  exec_list *const f414C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f414C->then_instructions;

                     body.emit(assign(r410F, body.constant(int(0)), 0x01));


                  body.instructions = f414C_parent_instructions;
                  body.emit(f414C);

                  /* END IF */


               body.instructions = f4141_parent_instructions;
               body.emit(f4141);

               /* END IF */

               ir_variable *const r414F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r414F);
               ir_expression *const r4150 = lshift(r3B91, body.constant(int(31)));
               ir_expression *const r4151 = expr(ir_unop_i2u, r410F);
               ir_expression *const r4152 = lshift(r4151, body.constant(int(20)));
               ir_expression *const r4153 = add(r4150, r4152);
               body.emit(assign(r414F, add(r4153, r4110), 0x02));

               body.emit(assign(r414F, r4111, 0x01));

               body.emit(assign(r4114, r414F, 0x03));

               body.emit(assign(r4113, body.constant(false), 0x01));


            body.instructions = f4140_parent_instructions;
            body.emit(f4140);

            /* END IF */

            body.emit(assign(r3FAC, r4114, 0x03));

            body.emit(assign(r3FAB, body.constant(false), 0x01));


         body.instructions = f40C0_parent_instructions;
         body.emit(f40C0);

         /* END IF */


      body.instructions = f40B9_parent_instructions;
      body.emit(f40B9);

      /* END IF */

      body.emit(assign(r3B90, r3FAC, 0x03));


   body.instructions = f3B93_parent_instructions;
   body.emit(f3B93);

   /* END IF */

   ir_variable *const r4154 = body.make_temp(glsl_type::bool_type, "return_value");
   ir_variable *const r4155 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
   body.emit(r4155);
   ir_variable *const r4156 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
   body.emit(r4156);
   ir_expression *const r4157 = rshift(swizzle_y(r3B90), body.constant(int(20)));
   ir_expression *const r4158 = bit_and(r4157, body.constant(2047u));
   ir_expression *const r4159 = expr(ir_unop_u2i, r4158);
   ir_expression *const r415A = equal(r4159, body.constant(int(2047)));
   ir_expression *const r415B = bit_and(swizzle_y(r3B90), body.constant(1048575u));
   ir_expression *const r415C = bit_or(r415B, swizzle_x(r3B90));
   ir_expression *const r415D = nequal(r415C, body.constant(0u));
   body.emit(assign(r4156, logic_and(r415A, r415D), 0x01));

   ir_expression *const r415E = rshift(swizzle_y(r321F), body.constant(int(20)));
   ir_expression *const r415F = bit_and(r415E, body.constant(2047u));
   ir_expression *const r4160 = expr(ir_unop_u2i, r415F);
   ir_expression *const r4161 = equal(r4160, body.constant(int(2047)));
   ir_expression *const r4162 = bit_and(swizzle_y(r321F), body.constant(1048575u));
   ir_expression *const r4163 = bit_or(r4162, swizzle_x(r321F));
   ir_expression *const r4164 = nequal(r4163, body.constant(0u));
   body.emit(assign(r4155, logic_and(r4161, r4164), 0x01));

   /* IF CONDITION */
   ir_expression *const r4166 = logic_or(r4156, r4155);
   ir_if *f4165 = new(mem_ctx) ir_if(operand(r4166).val);
   exec_list *const f4165_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f4165->then_instructions;

      body.emit(assign(r4154, body.constant(false), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f4165->else_instructions;

      ir_expression *const r4167 = equal(swizzle_x(r3B90), swizzle_x(r321F));
      ir_expression *const r4168 = equal(swizzle_y(r3B90), swizzle_y(r321F));
      ir_expression *const r4169 = equal(swizzle_x(r3B90), body.constant(0u));
      ir_expression *const r416A = bit_or(swizzle_y(r3B90), swizzle_y(r321F));
      ir_expression *const r416B = lshift(r416A, body.constant(int(1)));
      ir_expression *const r416C = equal(r416B, body.constant(0u));
      ir_expression *const r416D = logic_and(r4169, r416C);
      ir_expression *const r416E = logic_or(r4168, r416D);
      body.emit(assign(r4154, logic_and(r4167, r416E), 0x01));


   body.instructions = f4165_parent_instructions;
   body.emit(f4165);

   /* END IF */

   ir_variable *const r416F = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
   /* IF CONDITION */
   ir_expression *const r4171 = expr(ir_unop_logic_not, r4154);
   ir_if *f4170 = new(mem_ctx) ir_if(operand(r4171).val);
   exec_list *const f4170_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f4170->then_instructions;

      body.emit(assign(r416F, r3B90, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f4170->else_instructions;

      body.emit(assign(r416F, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


   body.instructions = f4170_parent_instructions;
   body.emit(f4170);

   /* END IF */

   body.emit(ret(r416F));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fsign64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r4172 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r4172);
   ir_variable *const r4173 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r4174 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "retval", ir_var_auto);
   body.emit(r4174);
   /* IF CONDITION */
   ir_expression *const r4176 = lshift(swizzle_y(r4172), body.constant(int(1)));
   ir_expression *const r4177 = bit_or(r4176, swizzle_x(r4172));
   ir_expression *const r4178 = equal(r4177, body.constant(0u));
   ir_if *f4175 = new(mem_ctx) ir_if(operand(r4178).val);
   exec_list *const f4175_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f4175->then_instructions;

      body.emit(assign(r4173, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f4175->else_instructions;

      body.emit(assign(r4174, body.constant(0u), 0x01));

      ir_expression *const r4179 = bit_and(swizzle_y(r4172), body.constant(2147483648u));
      body.emit(assign(r4174, bit_or(r4179, body.constant(1072693248u)), 0x02));

      body.emit(assign(r4173, r4174, 0x03));


   body.instructions = f4175_parent_instructions;
   body.emit(f4175);

   /* END IF */

   body.emit(ret(r4173));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
