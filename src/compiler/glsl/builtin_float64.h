ir_function_signature *
fabs64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r000B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r000B);
   body.emit(assign(r000B, bit_and(swizzle_y(r000B), body.constant(2147483647u)), 0x02));

   body.emit(ret(r000B));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
is_nan(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r000C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r000C);
   ir_expression *const r000D = lshift(swizzle_y(r000C), body.constant(int(1)));
   ir_expression *const r000E = lequal(body.constant(4292870144u), r000D);
   ir_expression *const r000F = nequal(swizzle_x(r000C), body.constant(0u));
   ir_expression *const r0010 = bit_and(swizzle_y(r000C), body.constant(1048575u));
   ir_expression *const r0011 = nequal(r0010, body.constant(0u));
   ir_expression *const r0012 = logic_or(r000F, r0011);
   ir_expression *const r0013 = logic_and(r000E, r0012);
   body.emit(ret(r0013));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fneg64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0014 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0014);
   ir_variable *const r0015 = body.make_temp(glsl_type::uvec2_type, "return_value");
   /* IF CONDITION */
   ir_expression *const r0017 = lshift(swizzle_y(r0014), body.constant(int(1)));
   ir_expression *const r0018 = lequal(body.constant(4292870144u), r0017);
   ir_expression *const r0019 = nequal(swizzle_x(r0014), body.constant(0u));
   ir_expression *const r001A = bit_and(swizzle_y(r0014), body.constant(1048575u));
   ir_expression *const r001B = nequal(r001A, body.constant(0u));
   ir_expression *const r001C = logic_or(r0019, r001B);
   ir_expression *const r001D = logic_and(r0018, r001C);
   ir_if *f0016 = new(mem_ctx) ir_if(operand(r001D).val);
   exec_list *const f0016_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0016->then_instructions;

      body.emit(assign(r0015, r0014, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0016->else_instructions;

      body.emit(assign(r0014, bit_xor(swizzle_y(r0014), body.constant(2147483648u)), 0x02));

      body.emit(assign(r0015, r0014, 0x03));


   body.instructions = f0016_parent_instructions;
   body.emit(f0016);

   /* END IF */

   body.emit(ret(r0015));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat64Frac(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r001E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r001E);
   ir_variable *const r001F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r001F);
   body.emit(assign(r001F, bit_and(swizzle_y(r001E), body.constant(1048575u)), 0x02));

   body.emit(assign(r001F, swizzle_x(r001E), 0x01));

   body.emit(ret(r001F));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat64Exp(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::int_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0020 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0020);
   ir_expression *const r0021 = rshift(swizzle_y(r0020), body.constant(int(20)));
   ir_expression *const r0022 = bit_and(r0021, body.constant(2047u));
   ir_expression *const r0023 = expr(ir_unop_u2i, r0022);
   body.emit(ret(r0023));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
feq64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0024 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0024);
   ir_variable *const r0025 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0025);
   ir_variable *const r0026 = body.make_temp(glsl_type::bool_type, "return_value");
   ir_variable *const r0027 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
   body.emit(r0027);
   ir_variable *const r0028 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
   body.emit(r0028);
   ir_variable *const r0029 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r0029);
   body.emit(assign(r0029, bit_and(swizzle_y(r0024), body.constant(1048575u)), 0x02));

   body.emit(assign(r0029, swizzle_x(r0024), 0x01));

   ir_variable *const r002A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r002A);
   body.emit(assign(r002A, bit_and(swizzle_y(r0025), body.constant(1048575u)), 0x02));

   body.emit(assign(r002A, swizzle_x(r0025), 0x01));

   ir_expression *const r002B = rshift(swizzle_y(r0024), body.constant(int(20)));
   ir_expression *const r002C = bit_and(r002B, body.constant(2047u));
   ir_expression *const r002D = expr(ir_unop_u2i, r002C);
   ir_expression *const r002E = equal(r002D, body.constant(int(2047)));
   ir_expression *const r002F = bit_or(swizzle_y(r0029), swizzle_x(r0024));
   ir_expression *const r0030 = nequal(r002F, body.constant(0u));
   body.emit(assign(r0028, logic_and(r002E, r0030), 0x01));

   ir_expression *const r0031 = rshift(swizzle_y(r0025), body.constant(int(20)));
   ir_expression *const r0032 = bit_and(r0031, body.constant(2047u));
   ir_expression *const r0033 = expr(ir_unop_u2i, r0032);
   ir_expression *const r0034 = equal(r0033, body.constant(int(2047)));
   ir_expression *const r0035 = bit_or(swizzle_y(r002A), swizzle_x(r0025));
   ir_expression *const r0036 = nequal(r0035, body.constant(0u));
   body.emit(assign(r0027, logic_and(r0034, r0036), 0x01));

   /* IF CONDITION */
   ir_expression *const r0038 = logic_or(r0028, r0027);
   ir_if *f0037 = new(mem_ctx) ir_if(operand(r0038).val);
   exec_list *const f0037_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0037->then_instructions;

      body.emit(assign(r0026, body.constant(false), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0037->else_instructions;

      ir_expression *const r0039 = equal(swizzle_x(r0024), swizzle_x(r0025));
      ir_expression *const r003A = equal(swizzle_y(r0024), swizzle_y(r0025));
      ir_expression *const r003B = equal(swizzle_x(r0024), body.constant(0u));
      ir_expression *const r003C = bit_or(swizzle_y(r0024), swizzle_y(r0025));
      ir_expression *const r003D = lshift(r003C, body.constant(int(1)));
      ir_expression *const r003E = equal(r003D, body.constant(0u));
      ir_expression *const r003F = logic_and(r003B, r003E);
      ir_expression *const r0040 = logic_or(r003A, r003F);
      body.emit(assign(r0026, logic_and(r0039, r0040), 0x01));


   body.instructions = f0037_parent_instructions;
   body.emit(f0037);

   /* END IF */

   body.emit(ret(r0026));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat64Sign(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0041 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0041);
   ir_expression *const r0042 = rshift(swizzle_y(r0041), body.constant(int(31)));
   body.emit(ret(r0042));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
le64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0043 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r0043);
   ir_variable *const r0044 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r0044);
   ir_variable *const r0045 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r0045);
   ir_variable *const r0046 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r0046);
   ir_expression *const r0047 = less(r0043, r0045);
   ir_expression *const r0048 = equal(r0043, r0045);
   ir_expression *const r0049 = lequal(r0044, r0046);
   ir_expression *const r004A = logic_and(r0048, r0049);
   ir_expression *const r004B = logic_or(r0047, r004A);
   body.emit(ret(r004B));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fle64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r004C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r004C);
   ir_variable *const r004D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r004D);
   ir_variable *const r004E = body.make_temp(glsl_type::bool_type, "return_value");
   ir_variable *const r004F = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
   body.emit(r004F);
   ir_variable *const r0050 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
   body.emit(r0050);
   ir_variable *const r0051 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r0051);
   body.emit(assign(r0051, bit_and(swizzle_y(r004C), body.constant(1048575u)), 0x02));

   body.emit(assign(r0051, swizzle_x(r004C), 0x01));

   ir_variable *const r0052 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r0052);
   body.emit(assign(r0052, bit_and(swizzle_y(r004D), body.constant(1048575u)), 0x02));

   body.emit(assign(r0052, swizzle_x(r004D), 0x01));

   ir_expression *const r0053 = rshift(swizzle_y(r004C), body.constant(int(20)));
   ir_expression *const r0054 = bit_and(r0053, body.constant(2047u));
   ir_expression *const r0055 = expr(ir_unop_u2i, r0054);
   ir_expression *const r0056 = equal(r0055, body.constant(int(2047)));
   ir_expression *const r0057 = bit_or(swizzle_y(r0051), swizzle_x(r004C));
   ir_expression *const r0058 = nequal(r0057, body.constant(0u));
   body.emit(assign(r0050, logic_and(r0056, r0058), 0x01));

   ir_expression *const r0059 = rshift(swizzle_y(r004D), body.constant(int(20)));
   ir_expression *const r005A = bit_and(r0059, body.constant(2047u));
   ir_expression *const r005B = expr(ir_unop_u2i, r005A);
   ir_expression *const r005C = equal(r005B, body.constant(int(2047)));
   ir_expression *const r005D = bit_or(swizzle_y(r0052), swizzle_x(r004D));
   ir_expression *const r005E = nequal(r005D, body.constant(0u));
   body.emit(assign(r004F, logic_and(r005C, r005E), 0x01));

   /* IF CONDITION */
   ir_expression *const r0060 = logic_or(r0050, r004F);
   ir_if *f005F = new(mem_ctx) ir_if(operand(r0060).val);
   exec_list *const f005F_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f005F->then_instructions;

      body.emit(assign(r004E, body.constant(false), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f005F->else_instructions;

      ir_variable *const r0061 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r0061, rshift(swizzle_y(r004C), body.constant(int(31))), 0x01));

      ir_variable *const r0062 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r0062, rshift(swizzle_y(r004D), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r0064 = nequal(r0061, r0062);
      ir_if *f0063 = new(mem_ctx) ir_if(operand(r0064).val);
      exec_list *const f0063_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0063->then_instructions;

         ir_expression *const r0065 = nequal(r0061, body.constant(0u));
         ir_expression *const r0066 = bit_or(swizzle_y(r004C), swizzle_y(r004D));
         ir_expression *const r0067 = lshift(r0066, body.constant(int(1)));
         ir_expression *const r0068 = bit_or(r0067, swizzle_x(r004C));
         ir_expression *const r0069 = bit_or(r0068, swizzle_x(r004D));
         ir_expression *const r006A = equal(r0069, body.constant(0u));
         body.emit(assign(r004E, logic_or(r0065, r006A), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0063->else_instructions;

         ir_variable *const r006B = body.make_temp(glsl_type::bool_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r006D = nequal(r0061, body.constant(0u));
         ir_if *f006C = new(mem_ctx) ir_if(operand(r006D).val);
         exec_list *const f006C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f006C->then_instructions;

            ir_expression *const r006E = less(swizzle_y(r004D), swizzle_y(r004C));
            ir_expression *const r006F = equal(swizzle_y(r004D), swizzle_y(r004C));
            ir_expression *const r0070 = lequal(swizzle_x(r004D), swizzle_x(r004C));
            ir_expression *const r0071 = logic_and(r006F, r0070);
            body.emit(assign(r006B, logic_or(r006E, r0071), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f006C->else_instructions;

            ir_expression *const r0072 = less(swizzle_y(r004C), swizzle_y(r004D));
            ir_expression *const r0073 = equal(swizzle_y(r004C), swizzle_y(r004D));
            ir_expression *const r0074 = lequal(swizzle_x(r004C), swizzle_x(r004D));
            ir_expression *const r0075 = logic_and(r0073, r0074);
            body.emit(assign(r006B, logic_or(r0072, r0075), 0x01));


         body.instructions = f006C_parent_instructions;
         body.emit(f006C);

         /* END IF */

         body.emit(assign(r004E, r006B, 0x01));


      body.instructions = f0063_parent_instructions;
      body.emit(f0063);

      /* END IF */


   body.instructions = f005F_parent_instructions;
   body.emit(f005F);

   /* END IF */

   body.emit(ret(r004E));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
lt64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0076 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r0076);
   ir_variable *const r0077 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r0077);
   ir_variable *const r0078 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r0078);
   ir_variable *const r0079 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r0079);
   ir_expression *const r007A = less(r0076, r0078);
   ir_expression *const r007B = equal(r0076, r0078);
   ir_expression *const r007C = less(r0077, r0079);
   ir_expression *const r007D = logic_and(r007B, r007C);
   ir_expression *const r007E = logic_or(r007A, r007D);
   body.emit(ret(r007E));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
flt64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r007F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r007F);
   ir_variable *const r0080 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0080);
   ir_variable *const r0081 = body.make_temp(glsl_type::bool_type, "return_value");
   ir_variable *const r0082 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
   body.emit(r0082);
   ir_variable *const r0083 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
   body.emit(r0083);
   ir_variable *const r0084 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r0084);
   body.emit(assign(r0084, bit_and(swizzle_y(r007F), body.constant(1048575u)), 0x02));

   body.emit(assign(r0084, swizzle_x(r007F), 0x01));

   ir_variable *const r0085 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r0085);
   body.emit(assign(r0085, bit_and(swizzle_y(r0080), body.constant(1048575u)), 0x02));

   body.emit(assign(r0085, swizzle_x(r0080), 0x01));

   ir_expression *const r0086 = rshift(swizzle_y(r007F), body.constant(int(20)));
   ir_expression *const r0087 = bit_and(r0086, body.constant(2047u));
   ir_expression *const r0088 = expr(ir_unop_u2i, r0087);
   ir_expression *const r0089 = equal(r0088, body.constant(int(2047)));
   ir_expression *const r008A = bit_or(swizzle_y(r0084), swizzle_x(r007F));
   ir_expression *const r008B = nequal(r008A, body.constant(0u));
   body.emit(assign(r0083, logic_and(r0089, r008B), 0x01));

   ir_expression *const r008C = rshift(swizzle_y(r0080), body.constant(int(20)));
   ir_expression *const r008D = bit_and(r008C, body.constant(2047u));
   ir_expression *const r008E = expr(ir_unop_u2i, r008D);
   ir_expression *const r008F = equal(r008E, body.constant(int(2047)));
   ir_expression *const r0090 = bit_or(swizzle_y(r0085), swizzle_x(r0080));
   ir_expression *const r0091 = nequal(r0090, body.constant(0u));
   body.emit(assign(r0082, logic_and(r008F, r0091), 0x01));

   /* IF CONDITION */
   ir_expression *const r0093 = logic_or(r0083, r0082);
   ir_if *f0092 = new(mem_ctx) ir_if(operand(r0093).val);
   exec_list *const f0092_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0092->then_instructions;

      body.emit(assign(r0081, body.constant(false), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0092->else_instructions;

      ir_variable *const r0094 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r0094, rshift(swizzle_y(r007F), body.constant(int(31))), 0x01));

      ir_variable *const r0095 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r0095, rshift(swizzle_y(r0080), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r0097 = nequal(r0094, r0095);
      ir_if *f0096 = new(mem_ctx) ir_if(operand(r0097).val);
      exec_list *const f0096_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0096->then_instructions;

         ir_expression *const r0098 = nequal(r0094, body.constant(0u));
         ir_expression *const r0099 = bit_or(swizzle_y(r007F), swizzle_y(r0080));
         ir_expression *const r009A = lshift(r0099, body.constant(int(1)));
         ir_expression *const r009B = bit_or(r009A, swizzle_x(r007F));
         ir_expression *const r009C = bit_or(r009B, swizzle_x(r0080));
         ir_expression *const r009D = nequal(r009C, body.constant(0u));
         body.emit(assign(r0081, logic_and(r0098, r009D), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0096->else_instructions;

         ir_variable *const r009E = body.make_temp(glsl_type::bool_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r00A0 = nequal(r0094, body.constant(0u));
         ir_if *f009F = new(mem_ctx) ir_if(operand(r00A0).val);
         exec_list *const f009F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f009F->then_instructions;

            ir_expression *const r00A1 = less(swizzle_y(r0080), swizzle_y(r007F));
            ir_expression *const r00A2 = equal(swizzle_y(r0080), swizzle_y(r007F));
            ir_expression *const r00A3 = less(swizzle_x(r0080), swizzle_x(r007F));
            ir_expression *const r00A4 = logic_and(r00A2, r00A3);
            body.emit(assign(r009E, logic_or(r00A1, r00A4), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f009F->else_instructions;

            ir_expression *const r00A5 = less(swizzle_y(r007F), swizzle_y(r0080));
            ir_expression *const r00A6 = equal(swizzle_y(r007F), swizzle_y(r0080));
            ir_expression *const r00A7 = less(swizzle_x(r007F), swizzle_x(r0080));
            ir_expression *const r00A8 = logic_and(r00A6, r00A7);
            body.emit(assign(r009E, logic_or(r00A5, r00A8), 0x01));


         body.instructions = f009F_parent_instructions;
         body.emit(f009F);

         /* END IF */

         body.emit(assign(r0081, r009E, 0x01));


      body.instructions = f0096_parent_instructions;
      body.emit(f0096);

      /* END IF */


   body.instructions = f0092_parent_instructions;
   body.emit(f0092);

   /* END IF */

   body.emit(ret(r0081));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
add64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00A9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00A9);
   ir_variable *const r00AA = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00AA);
   ir_variable *const r00AB = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r00AB);
   ir_variable *const r00AC = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r00AC);
   ir_variable *const r00AD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00AD);
   ir_variable *const r00AE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00AE);
   ir_variable *const r00AF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r00AF, add(r00AA, r00AC), 0x01));

   body.emit(assign(r00AE, r00AF, 0x01));

   ir_expression *const r00B0 = add(r00A9, r00AB);
   ir_expression *const r00B1 = less(r00AF, r00AA);
   ir_expression *const r00B2 = expr(ir_unop_b2i, r00B1);
   ir_expression *const r00B3 = expr(ir_unop_i2u, r00B2);
   body.emit(assign(r00AD, add(r00B0, r00B3), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
sub64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00B4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00B4);
   ir_variable *const r00B5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00B5);
   ir_variable *const r00B6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r00B6);
   ir_variable *const r00B7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r00B7);
   ir_variable *const r00B8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00B8);
   ir_variable *const r00B9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00B9);
   body.emit(assign(r00B9, sub(r00B5, r00B7), 0x01));

   ir_expression *const r00BA = sub(r00B4, r00B6);
   ir_expression *const r00BB = less(r00B5, r00B7);
   ir_expression *const r00BC = expr(ir_unop_b2i, r00BB);
   ir_expression *const r00BD = expr(ir_unop_i2u, r00BC);
   body.emit(assign(r00B8, sub(r00BA, r00BD), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
eq64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00BE = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00BE);
   ir_variable *const r00BF = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00BF);
   ir_variable *const r00C0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r00C0);
   ir_variable *const r00C1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r00C1);
   ir_expression *const r00C2 = equal(r00BE, r00C0);
   ir_expression *const r00C3 = equal(r00BF, r00C1);
   ir_expression *const r00C4 = logic_and(r00C2, r00C3);
   body.emit(ret(r00C4));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
float64_is_signaling_nan(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00C5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r00C5);
   ir_expression *const r00C6 = rshift(swizzle_y(r00C5), body.constant(int(19)));
   ir_expression *const r00C7 = bit_and(r00C6, body.constant(4095u));
   ir_expression *const r00C8 = equal(r00C7, body.constant(4094u));
   ir_expression *const r00C9 = nequal(swizzle_x(r00C5), body.constant(0u));
   ir_expression *const r00CA = bit_and(swizzle_y(r00C5), body.constant(524287u));
   ir_expression *const r00CB = nequal(r00CA, body.constant(0u));
   ir_expression *const r00CC = logic_or(r00C9, r00CB);
   ir_expression *const r00CD = logic_and(r00C8, r00CC);
   body.emit(ret(r00CD));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift64RightJamming(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00CE = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00CE);
   ir_variable *const r00CF = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00CF);
   ir_variable *const r00D0 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r00D0);
   ir_variable *const r00D1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00D1);
   ir_variable *const r00D2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00D2);
   ir_variable *const r00D3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r00D3);
   ir_variable *const r00D4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r00D4);
   ir_variable *const r00D5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r00D6 = neg(r00D0);
   body.emit(assign(r00D5, bit_and(r00D6, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r00D8 = equal(r00D0, body.constant(int(0)));
   ir_if *f00D7 = new(mem_ctx) ir_if(operand(r00D8).val);
   exec_list *const f00D7_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f00D7->then_instructions;

      body.emit(assign(r00D3, r00CF, 0x01));

      body.emit(assign(r00D4, r00CE, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f00D7->else_instructions;

      /* IF CONDITION */
      ir_expression *const r00DA = less(r00D0, body.constant(int(32)));
      ir_if *f00D9 = new(mem_ctx) ir_if(operand(r00DA).val);
      exec_list *const f00D9_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f00D9->then_instructions;

         ir_expression *const r00DB = lshift(r00CE, r00D5);
         ir_expression *const r00DC = rshift(r00CF, r00D0);
         ir_expression *const r00DD = bit_or(r00DB, r00DC);
         ir_expression *const r00DE = lshift(r00CF, r00D5);
         ir_expression *const r00DF = nequal(r00DE, body.constant(0u));
         ir_expression *const r00E0 = expr(ir_unop_b2i, r00DF);
         ir_expression *const r00E1 = expr(ir_unop_i2u, r00E0);
         body.emit(assign(r00D3, bit_or(r00DD, r00E1), 0x01));

         body.emit(assign(r00D4, rshift(r00CE, r00D0), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f00D9->else_instructions;

         /* IF CONDITION */
         ir_expression *const r00E3 = equal(r00D0, body.constant(int(32)));
         ir_if *f00E2 = new(mem_ctx) ir_if(operand(r00E3).val);
         exec_list *const f00E2_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f00E2->then_instructions;

            ir_expression *const r00E4 = nequal(r00CF, body.constant(0u));
            ir_expression *const r00E5 = expr(ir_unop_b2i, r00E4);
            ir_expression *const r00E6 = expr(ir_unop_i2u, r00E5);
            body.emit(assign(r00D3, bit_or(r00CE, r00E6), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f00E2->else_instructions;

            /* IF CONDITION */
            ir_expression *const r00E8 = less(r00D0, body.constant(int(64)));
            ir_if *f00E7 = new(mem_ctx) ir_if(operand(r00E8).val);
            exec_list *const f00E7_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f00E7->then_instructions;

               ir_expression *const r00E9 = bit_and(r00D0, body.constant(int(31)));
               ir_expression *const r00EA = rshift(r00CE, r00E9);
               ir_expression *const r00EB = lshift(r00CE, r00D5);
               ir_expression *const r00EC = bit_or(r00EB, r00CF);
               ir_expression *const r00ED = nequal(r00EC, body.constant(0u));
               ir_expression *const r00EE = expr(ir_unop_b2i, r00ED);
               ir_expression *const r00EF = expr(ir_unop_i2u, r00EE);
               body.emit(assign(r00D3, bit_or(r00EA, r00EF), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f00E7->else_instructions;

               ir_expression *const r00F0 = bit_or(r00CE, r00CF);
               ir_expression *const r00F1 = nequal(r00F0, body.constant(0u));
               ir_expression *const r00F2 = expr(ir_unop_b2i, r00F1);
               body.emit(assign(r00D3, expr(ir_unop_i2u, r00F2), 0x01));


            body.instructions = f00E7_parent_instructions;
            body.emit(f00E7);

            /* END IF */


         body.instructions = f00E2_parent_instructions;
         body.emit(f00E2);

         /* END IF */

         body.emit(assign(r00D4, body.constant(0u), 0x01));


      body.instructions = f00D9_parent_instructions;
      body.emit(f00D9);

      /* END IF */


   body.instructions = f00D7_parent_instructions;
   body.emit(f00D7);

   /* END IF */

   body.emit(assign(r00D2, r00D3, 0x01));

   body.emit(assign(r00D1, r00D4, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift64ExtraRightJamming(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00F3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00F3);
   ir_variable *const r00F4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00F4);
   ir_variable *const r00F5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a2", ir_var_function_in);
   sig_parameters.push_tail(r00F5);
   ir_variable *const r00F6 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r00F6);
   ir_variable *const r00F7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00F7);
   ir_variable *const r00F8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00F8);
   ir_variable *const r00F9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00F9);
   ir_variable *const r00FA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
   body.emit(r00FA);
   ir_variable *const r00FB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r00FB);
   ir_variable *const r00FC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r00FC);
   ir_variable *const r00FD = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r00FE = neg(r00F6);
   body.emit(assign(r00FD, bit_and(r00FE, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r0100 = equal(r00F6, body.constant(int(0)));
   ir_if *f00FF = new(mem_ctx) ir_if(operand(r0100).val);
   exec_list *const f00FF_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f00FF->then_instructions;

      body.emit(assign(r00FA, r00F5, 0x01));

      body.emit(assign(r00FB, r00F4, 0x01));

      body.emit(assign(r00FC, r00F3, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f00FF->else_instructions;

      /* IF CONDITION */
      ir_expression *const r0102 = less(r00F6, body.constant(int(32)));
      ir_if *f0101 = new(mem_ctx) ir_if(operand(r0102).val);
      exec_list *const f0101_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0101->then_instructions;

         body.emit(assign(r00FA, lshift(r00F4, r00FD), 0x01));

         ir_expression *const r0103 = lshift(r00F3, r00FD);
         ir_expression *const r0104 = rshift(r00F4, r00F6);
         body.emit(assign(r00FB, bit_or(r0103, r0104), 0x01));

         body.emit(assign(r00FC, rshift(r00F3, r00F6), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0101->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0106 = equal(r00F6, body.constant(int(32)));
         ir_if *f0105 = new(mem_ctx) ir_if(operand(r0106).val);
         exec_list *const f0105_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0105->then_instructions;

            body.emit(assign(r00FA, r00F4, 0x01));

            body.emit(assign(r00FB, r00F3, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0105->else_instructions;

            body.emit(assign(r00F5, bit_or(r00F5, r00F4), 0x01));

            /* IF CONDITION */
            ir_expression *const r0108 = less(r00F6, body.constant(int(64)));
            ir_if *f0107 = new(mem_ctx) ir_if(operand(r0108).val);
            exec_list *const f0107_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0107->then_instructions;

               body.emit(assign(r00FA, lshift(r00F3, r00FD), 0x01));

               ir_expression *const r0109 = bit_and(r00F6, body.constant(int(31)));
               body.emit(assign(r00FB, rshift(r00F3, r0109), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0107->else_instructions;

               ir_variable *const r010A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r010C = equal(r00F6, body.constant(int(64)));
               ir_if *f010B = new(mem_ctx) ir_if(operand(r010C).val);
               exec_list *const f010B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f010B->then_instructions;

                  body.emit(assign(r010A, r00F3, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f010B->else_instructions;

                  ir_expression *const r010D = nequal(r00F3, body.constant(0u));
                  ir_expression *const r010E = expr(ir_unop_b2i, r010D);
                  body.emit(assign(r010A, expr(ir_unop_i2u, r010E), 0x01));


               body.instructions = f010B_parent_instructions;
               body.emit(f010B);

               /* END IF */

               body.emit(assign(r00FA, r010A, 0x01));

               body.emit(assign(r00FB, body.constant(0u), 0x01));


            body.instructions = f0107_parent_instructions;
            body.emit(f0107);

            /* END IF */


         body.instructions = f0105_parent_instructions;
         body.emit(f0105);

         /* END IF */

         body.emit(assign(r00FC, body.constant(0u), 0x01));


      body.instructions = f0101_parent_instructions;
      body.emit(f0101);

      /* END IF */

      ir_expression *const r010F = nequal(r00F5, body.constant(0u));
      ir_expression *const r0110 = expr(ir_unop_b2i, r010F);
      ir_expression *const r0111 = expr(ir_unop_i2u, r0110);
      body.emit(assign(r00FA, bit_or(r00FA, r0111), 0x01));


   body.instructions = f00FF_parent_instructions;
   body.emit(f00FF);

   /* END IF */

   body.emit(assign(r00F9, r00FA, 0x01));

   body.emit(assign(r00F8, r00FB, 0x01));

   body.emit(assign(r00F7, r00FC, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shortShift64Left(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0112 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r0112);
   ir_variable *const r0113 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r0113);
   ir_variable *const r0114 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r0114);
   ir_variable *const r0115 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0115);
   ir_variable *const r0116 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0116);
   body.emit(assign(r0116, lshift(r0113, r0114), 0x01));

   ir_variable *const r0117 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
   /* IF CONDITION */
   ir_expression *const r0119 = equal(r0114, body.constant(int(0)));
   ir_if *f0118 = new(mem_ctx) ir_if(operand(r0119).val);
   exec_list *const f0118_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0118->then_instructions;

      body.emit(assign(r0117, r0112, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0118->else_instructions;

      ir_expression *const r011A = lshift(r0112, r0114);
      ir_expression *const r011B = neg(r0114);
      ir_expression *const r011C = bit_and(r011B, body.constant(int(31)));
      ir_expression *const r011D = rshift(r0113, r011C);
      body.emit(assign(r0117, bit_or(r011A, r011D), 0x01));


   body.instructions = f0118_parent_instructions;
   body.emit(f0118);

   /* END IF */

   body.emit(assign(r0115, r0117, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
packFloat64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r011E = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r011E);
   ir_variable *const r011F = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r011F);
   ir_variable *const r0120 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_function_in);
   sig_parameters.push_tail(r0120);
   ir_variable *const r0121 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_function_in);
   sig_parameters.push_tail(r0121);
   ir_variable *const r0122 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
   body.emit(r0122);
   ir_expression *const r0123 = lshift(r011E, body.constant(int(31)));
   ir_expression *const r0124 = expr(ir_unop_i2u, r011F);
   ir_expression *const r0125 = lshift(r0124, body.constant(int(20)));
   ir_expression *const r0126 = add(r0123, r0125);
   body.emit(assign(r0122, add(r0126, r0120), 0x02));

   body.emit(assign(r0122, r0121, 0x01));

   body.emit(ret(r0122));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
roundAndPackFloat64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0127 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r0127);
   ir_variable *const r0128 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r0128);
   ir_variable *const r0129 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_function_in);
   sig_parameters.push_tail(r0129);
   ir_variable *const r012A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_function_in);
   sig_parameters.push_tail(r012A);
   ir_variable *const r012B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_function_in);
   sig_parameters.push_tail(r012B);
   ir_variable *const r012C = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r012C, body.constant(true), 0x01));

   ir_variable *const r012D = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r012E = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
   body.emit(r012E);
   ir_expression *const r012F = expr(ir_unop_u2i, r012B);
   body.emit(assign(r012E, less(r012F, body.constant(int(0))), 0x01));

   /* IF CONDITION */
   ir_expression *const r0131 = lequal(body.constant(int(2045)), r0128);
   ir_if *f0130 = new(mem_ctx) ir_if(operand(r0131).val);
   exec_list *const f0130_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0130->then_instructions;

      ir_variable *const r0132 = body.make_temp(glsl_type::bool_type, "or_tmp");
      /* IF CONDITION */
      ir_expression *const r0134 = less(body.constant(int(2045)), r0128);
      ir_if *f0133 = new(mem_ctx) ir_if(operand(r0134).val);
      exec_list *const f0133_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0133->then_instructions;

         body.emit(assign(r0132, body.constant(true), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0133->else_instructions;

         ir_variable *const r0135 = body.make_temp(glsl_type::bool_type, "and_tmp");
         /* IF CONDITION */
         ir_expression *const r0137 = equal(r0128, body.constant(int(2045)));
         ir_if *f0136 = new(mem_ctx) ir_if(operand(r0137).val);
         exec_list *const f0136_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0136->then_instructions;

            ir_expression *const r0138 = equal(body.constant(2097151u), r0129);
            ir_expression *const r0139 = equal(body.constant(4294967295u), r012A);
            body.emit(assign(r0135, logic_and(r0138, r0139), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0136->else_instructions;

            body.emit(assign(r0135, body.constant(false), 0x01));


         body.instructions = f0136_parent_instructions;
         body.emit(f0136);

         /* END IF */

         body.emit(assign(r0132, logic_and(r0135, r012E), 0x01));


      body.instructions = f0133_parent_instructions;
      body.emit(f0133);

      /* END IF */

      /* IF CONDITION */
      ir_if *f013A = new(mem_ctx) ir_if(operand(r0132).val);
      exec_list *const f013A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f013A->then_instructions;

         ir_variable *const r013B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r013B);
         ir_expression *const r013C = lshift(r0127, body.constant(int(31)));
         body.emit(assign(r013B, add(r013C, body.constant(2146435072u)), 0x02));

         body.emit(assign(r013B, body.constant(0u), 0x01));

         body.emit(assign(r012D, r013B, 0x03));

         body.emit(assign(r012C, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f013A->else_instructions;

         /* IF CONDITION */
         ir_expression *const r013E = less(r0128, body.constant(int(0)));
         ir_if *f013D = new(mem_ctx) ir_if(operand(r013E).val);
         exec_list *const f013D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f013D->then_instructions;

            ir_variable *const r013F = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r013F, r012B, 0x01));

            ir_variable *const r0140 = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r0140, neg(r0128), 0x01));

            ir_variable *const r0141 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r0141);
            ir_variable *const r0142 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r0142);
            ir_variable *const r0143 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r0143);
            ir_variable *const r0144 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r0145 = neg(r0140);
            body.emit(assign(r0144, bit_and(r0145, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0147 = equal(r0140, body.constant(int(0)));
            ir_if *f0146 = new(mem_ctx) ir_if(operand(r0147).val);
            exec_list *const f0146_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0146->then_instructions;

               body.emit(assign(r0141, r012B, 0x01));

               body.emit(assign(r0142, r012A, 0x01));

               body.emit(assign(r0143, r0129, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0146->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0149 = less(r0140, body.constant(int(32)));
               ir_if *f0148 = new(mem_ctx) ir_if(operand(r0149).val);
               exec_list *const f0148_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0148->then_instructions;

                  body.emit(assign(r0141, lshift(r012A, r0144), 0x01));

                  ir_expression *const r014A = lshift(r0129, r0144);
                  ir_expression *const r014B = rshift(r012A, r0140);
                  body.emit(assign(r0142, bit_or(r014A, r014B), 0x01));

                  body.emit(assign(r0143, rshift(r0129, r0140), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0148->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r014D = equal(r0140, body.constant(int(32)));
                  ir_if *f014C = new(mem_ctx) ir_if(operand(r014D).val);
                  exec_list *const f014C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f014C->then_instructions;

                     body.emit(assign(r0141, r012A, 0x01));

                     body.emit(assign(r0142, r0129, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f014C->else_instructions;

                     body.emit(assign(r013F, bit_or(r012B, r012A), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r014F = less(r0140, body.constant(int(64)));
                     ir_if *f014E = new(mem_ctx) ir_if(operand(r014F).val);
                     exec_list *const f014E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f014E->then_instructions;

                        body.emit(assign(r0141, lshift(r0129, r0144), 0x01));

                        ir_expression *const r0150 = bit_and(r0140, body.constant(int(31)));
                        body.emit(assign(r0142, rshift(r0129, r0150), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f014E->else_instructions;

                        ir_variable *const r0151 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0153 = equal(r0140, body.constant(int(64)));
                        ir_if *f0152 = new(mem_ctx) ir_if(operand(r0153).val);
                        exec_list *const f0152_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0152->then_instructions;

                           body.emit(assign(r0151, r0129, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0152->else_instructions;

                           ir_expression *const r0154 = nequal(r0129, body.constant(0u));
                           ir_expression *const r0155 = expr(ir_unop_b2i, r0154);
                           body.emit(assign(r0151, expr(ir_unop_i2u, r0155), 0x01));


                        body.instructions = f0152_parent_instructions;
                        body.emit(f0152);

                        /* END IF */

                        body.emit(assign(r0141, r0151, 0x01));

                        body.emit(assign(r0142, body.constant(0u), 0x01));


                     body.instructions = f014E_parent_instructions;
                     body.emit(f014E);

                     /* END IF */


                  body.instructions = f014C_parent_instructions;
                  body.emit(f014C);

                  /* END IF */

                  body.emit(assign(r0143, body.constant(0u), 0x01));


               body.instructions = f0148_parent_instructions;
               body.emit(f0148);

               /* END IF */

               ir_expression *const r0156 = nequal(r013F, body.constant(0u));
               ir_expression *const r0157 = expr(ir_unop_b2i, r0156);
               ir_expression *const r0158 = expr(ir_unop_i2u, r0157);
               body.emit(assign(r0141, bit_or(r0141, r0158), 0x01));


            body.instructions = f0146_parent_instructions;
            body.emit(f0146);

            /* END IF */

            body.emit(assign(r0129, r0143, 0x01));

            body.emit(assign(r012A, r0142, 0x01));

            body.emit(assign(r012B, r0141, 0x01));

            body.emit(assign(r0128, body.constant(int(0)), 0x01));

            body.emit(assign(r012E, less(r0141, body.constant(0u)), 0x01));


         body.instructions = f013D_parent_instructions;
         body.emit(f013D);

         /* END IF */


      body.instructions = f013A_parent_instructions;
      body.emit(f013A);

      /* END IF */


   body.instructions = f0130_parent_instructions;
   body.emit(f0130);

   /* END IF */

   /* IF CONDITION */
   ir_if *f0159 = new(mem_ctx) ir_if(operand(r012C).val);
   exec_list *const f0159_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0159->then_instructions;

      /* IF CONDITION */
      ir_if *f015A = new(mem_ctx) ir_if(operand(r012E).val);
      exec_list *const f015A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f015A->then_instructions;

         ir_variable *const r015B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r015B, add(r012A, body.constant(1u)), 0x01));

         ir_expression *const r015C = less(r015B, r012A);
         ir_expression *const r015D = expr(ir_unop_b2i, r015C);
         ir_expression *const r015E = expr(ir_unop_i2u, r015D);
         body.emit(assign(r0129, add(r0129, r015E), 0x01));

         ir_expression *const r015F = equal(r012B, body.constant(0u));
         ir_expression *const r0160 = expr(ir_unop_b2i, r015F);
         ir_expression *const r0161 = expr(ir_unop_i2u, r0160);
         ir_expression *const r0162 = add(r012B, r0161);
         ir_expression *const r0163 = bit_and(r0162, body.constant(1u));
         ir_expression *const r0164 = expr(ir_unop_bit_not, r0163);
         body.emit(assign(r012A, bit_and(r015B, r0164), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f015A->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0166 = bit_or(r0129, r012A);
         ir_expression *const r0167 = equal(r0166, body.constant(0u));
         ir_if *f0165 = new(mem_ctx) ir_if(operand(r0167).val);
         exec_list *const f0165_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0165->then_instructions;

            body.emit(assign(r0128, body.constant(int(0)), 0x01));


         body.instructions = f0165_parent_instructions;
         body.emit(f0165);

         /* END IF */


      body.instructions = f015A_parent_instructions;
      body.emit(f015A);

      /* END IF */

      ir_variable *const r0168 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r0168);
      ir_expression *const r0169 = lshift(r0127, body.constant(int(31)));
      ir_expression *const r016A = expr(ir_unop_i2u, r0128);
      ir_expression *const r016B = lshift(r016A, body.constant(int(20)));
      ir_expression *const r016C = add(r0169, r016B);
      body.emit(assign(r0168, add(r016C, r0129), 0x02));

      body.emit(assign(r0168, r012A, 0x01));

      body.emit(assign(r012D, r0168, 0x03));

      body.emit(assign(r012C, body.constant(false), 0x01));


   body.instructions = f0159_parent_instructions;
   body.emit(f0159);

   /* END IF */

   body.emit(ret(r012D));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
countLeadingZeros32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::int_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r016D = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r016D);
   ir_variable *const r016E = body.make_temp(glsl_type::int_type, "return_value");
   ir_variable *const r016F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r016F);
   /* IF CONDITION */
   ir_expression *const r0171 = equal(r016D, body.constant(0u));
   ir_if *f0170 = new(mem_ctx) ir_if(operand(r0171).val);
   exec_list *const f0170_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0170->then_instructions;

      body.emit(assign(r016E, body.constant(int(32)), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0170->else_instructions;

      body.emit(assign(r016F, body.constant(int(0)), 0x01));

      /* IF CONDITION */
      ir_expression *const r0173 = bit_and(r016D, body.constant(4294901760u));
      ir_expression *const r0174 = equal(r0173, body.constant(0u));
      ir_if *f0172 = new(mem_ctx) ir_if(operand(r0174).val);
      exec_list *const f0172_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0172->then_instructions;

         body.emit(assign(r016F, body.constant(int(16)), 0x01));

         body.emit(assign(r016D, lshift(r016D, body.constant(int(16))), 0x01));


      body.instructions = f0172_parent_instructions;
      body.emit(f0172);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0176 = bit_and(r016D, body.constant(4278190080u));
      ir_expression *const r0177 = equal(r0176, body.constant(0u));
      ir_if *f0175 = new(mem_ctx) ir_if(operand(r0177).val);
      exec_list *const f0175_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0175->then_instructions;

         body.emit(assign(r016F, add(r016F, body.constant(int(8))), 0x01));

         body.emit(assign(r016D, lshift(r016D, body.constant(int(8))), 0x01));


      body.instructions = f0175_parent_instructions;
      body.emit(f0175);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0179 = bit_and(r016D, body.constant(4026531840u));
      ir_expression *const r017A = equal(r0179, body.constant(0u));
      ir_if *f0178 = new(mem_ctx) ir_if(operand(r017A).val);
      exec_list *const f0178_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0178->then_instructions;

         body.emit(assign(r016F, add(r016F, body.constant(int(4))), 0x01));

         body.emit(assign(r016D, lshift(r016D, body.constant(int(4))), 0x01));


      body.instructions = f0178_parent_instructions;
      body.emit(f0178);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r017C = bit_and(r016D, body.constant(3221225472u));
      ir_expression *const r017D = equal(r017C, body.constant(0u));
      ir_if *f017B = new(mem_ctx) ir_if(operand(r017D).val);
      exec_list *const f017B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f017B->then_instructions;

         body.emit(assign(r016F, add(r016F, body.constant(int(2))), 0x01));

         body.emit(assign(r016D, lshift(r016D, body.constant(int(2))), 0x01));


      body.instructions = f017B_parent_instructions;
      body.emit(f017B);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r017F = bit_and(r016D, body.constant(2147483648u));
      ir_expression *const r0180 = equal(r017F, body.constant(0u));
      ir_if *f017E = new(mem_ctx) ir_if(operand(r0180).val);
      exec_list *const f017E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f017E->then_instructions;

         body.emit(assign(r016F, add(r016F, body.constant(int(1))), 0x01));


      body.instructions = f017E_parent_instructions;
      body.emit(f017E);

      /* END IF */

      body.emit(assign(r016E, r016F, 0x01));


   body.instructions = f0170_parent_instructions;
   body.emit(f0170);

   /* END IF */

   body.emit(ret(r016E));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
normalizeRoundAndPackFloat64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0181 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r0181);
   ir_variable *const r0182 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r0182);
   ir_variable *const r0183 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_function_in);
   sig_parameters.push_tail(r0183);
   ir_variable *const r0184 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_function_in);
   sig_parameters.push_tail(r0184);
   ir_variable *const r0185 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
   body.emit(r0185);
   ir_variable *const r0186 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r0186);
   /* IF CONDITION */
   ir_expression *const r0188 = equal(r0183, body.constant(0u));
   ir_if *f0187 = new(mem_ctx) ir_if(operand(r0188).val);
   exec_list *const f0187_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0187->then_instructions;

      body.emit(assign(r0183, r0184, 0x01));

      body.emit(assign(r0184, body.constant(0u), 0x01));

      body.emit(assign(r0182, add(r0182, body.constant(int(-32))), 0x01));


   body.instructions = f0187_parent_instructions;
   body.emit(f0187);

   /* END IF */

   ir_variable *const r0189 = body.make_temp(glsl_type::uint_type, "a");
   body.emit(assign(r0189, r0183, 0x01));

   ir_variable *const r018A = body.make_temp(glsl_type::int_type, "return_value");
   ir_variable *const r018B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r018B);
   /* IF CONDITION */
   ir_expression *const r018D = equal(r0183, body.constant(0u));
   ir_if *f018C = new(mem_ctx) ir_if(operand(r018D).val);
   exec_list *const f018C_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f018C->then_instructions;

      body.emit(assign(r018A, body.constant(int(32)), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f018C->else_instructions;

      body.emit(assign(r018B, body.constant(int(0)), 0x01));

      /* IF CONDITION */
      ir_expression *const r018F = bit_and(r0183, body.constant(4294901760u));
      ir_expression *const r0190 = equal(r018F, body.constant(0u));
      ir_if *f018E = new(mem_ctx) ir_if(operand(r0190).val);
      exec_list *const f018E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f018E->then_instructions;

         body.emit(assign(r018B, body.constant(int(16)), 0x01));

         body.emit(assign(r0189, lshift(r0183, body.constant(int(16))), 0x01));


      body.instructions = f018E_parent_instructions;
      body.emit(f018E);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0192 = bit_and(r0189, body.constant(4278190080u));
      ir_expression *const r0193 = equal(r0192, body.constant(0u));
      ir_if *f0191 = new(mem_ctx) ir_if(operand(r0193).val);
      exec_list *const f0191_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0191->then_instructions;

         body.emit(assign(r018B, add(r018B, body.constant(int(8))), 0x01));

         body.emit(assign(r0189, lshift(r0189, body.constant(int(8))), 0x01));


      body.instructions = f0191_parent_instructions;
      body.emit(f0191);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0195 = bit_and(r0189, body.constant(4026531840u));
      ir_expression *const r0196 = equal(r0195, body.constant(0u));
      ir_if *f0194 = new(mem_ctx) ir_if(operand(r0196).val);
      exec_list *const f0194_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0194->then_instructions;

         body.emit(assign(r018B, add(r018B, body.constant(int(4))), 0x01));

         body.emit(assign(r0189, lshift(r0189, body.constant(int(4))), 0x01));


      body.instructions = f0194_parent_instructions;
      body.emit(f0194);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0198 = bit_and(r0189, body.constant(3221225472u));
      ir_expression *const r0199 = equal(r0198, body.constant(0u));
      ir_if *f0197 = new(mem_ctx) ir_if(operand(r0199).val);
      exec_list *const f0197_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0197->then_instructions;

         body.emit(assign(r018B, add(r018B, body.constant(int(2))), 0x01));

         body.emit(assign(r0189, lshift(r0189, body.constant(int(2))), 0x01));


      body.instructions = f0197_parent_instructions;
      body.emit(f0197);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r019B = bit_and(r0189, body.constant(2147483648u));
      ir_expression *const r019C = equal(r019B, body.constant(0u));
      ir_if *f019A = new(mem_ctx) ir_if(operand(r019C).val);
      exec_list *const f019A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f019A->then_instructions;

         body.emit(assign(r018B, add(r018B, body.constant(int(1))), 0x01));


      body.instructions = f019A_parent_instructions;
      body.emit(f019A);

      /* END IF */

      body.emit(assign(r018A, r018B, 0x01));


   body.instructions = f018C_parent_instructions;
   body.emit(f018C);

   /* END IF */

   body.emit(assign(r0186, add(r018A, body.constant(int(-11))), 0x01));

   /* IF CONDITION */
   ir_expression *const r019E = lequal(body.constant(int(0)), r0186);
   ir_if *f019D = new(mem_ctx) ir_if(operand(r019E).val);
   exec_list *const f019D_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f019D->then_instructions;

      body.emit(assign(r0185, body.constant(0u), 0x01));

      ir_variable *const r019F = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r019F, lshift(r0184, r0186), 0x01));

      ir_variable *const r01A0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r01A2 = equal(r0186, body.constant(int(0)));
      ir_if *f01A1 = new(mem_ctx) ir_if(operand(r01A2).val);
      exec_list *const f01A1_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01A1->then_instructions;

         body.emit(assign(r01A0, r0183, 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01A1->else_instructions;

         ir_expression *const r01A3 = lshift(r0183, r0186);
         ir_expression *const r01A4 = neg(r0186);
         ir_expression *const r01A5 = bit_and(r01A4, body.constant(int(31)));
         ir_expression *const r01A6 = rshift(r0184, r01A5);
         body.emit(assign(r01A0, bit_or(r01A3, r01A6), 0x01));


      body.instructions = f01A1_parent_instructions;
      body.emit(f01A1);

      /* END IF */

      body.emit(assign(r0183, r01A0, 0x01));

      body.emit(assign(r0184, r019F, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f019D->else_instructions;

      ir_variable *const r01A7 = body.make_temp(glsl_type::uint_type, "a2");
      body.emit(assign(r01A7, body.constant(0u), 0x01));

      ir_variable *const r01A8 = body.make_temp(glsl_type::int_type, "count");
      body.emit(assign(r01A8, neg(r0186), 0x01));

      ir_variable *const r01A9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
      body.emit(r01A9);
      ir_variable *const r01AA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r01AA);
      ir_variable *const r01AB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r01AB);
      ir_variable *const r01AC = body.make_temp(glsl_type::int_type, "assignment_tmp");
      ir_expression *const r01AD = neg(r01A8);
      body.emit(assign(r01AC, bit_and(r01AD, body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r01AF = equal(r01A8, body.constant(int(0)));
      ir_if *f01AE = new(mem_ctx) ir_if(operand(r01AF).val);
      exec_list *const f01AE_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01AE->then_instructions;

         body.emit(assign(r01A9, r01A7, 0x01));

         body.emit(assign(r01AA, r0184, 0x01));

         body.emit(assign(r01AB, r0183, 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01AE->else_instructions;

         /* IF CONDITION */
         ir_expression *const r01B1 = less(r01A8, body.constant(int(32)));
         ir_if *f01B0 = new(mem_ctx) ir_if(operand(r01B1).val);
         exec_list *const f01B0_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f01B0->then_instructions;

            body.emit(assign(r01A9, lshift(r0184, r01AC), 0x01));

            ir_expression *const r01B2 = lshift(r0183, r01AC);
            ir_expression *const r01B3 = rshift(r0184, r01A8);
            body.emit(assign(r01AA, bit_or(r01B2, r01B3), 0x01));

            body.emit(assign(r01AB, rshift(r0183, r01A8), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f01B0->else_instructions;

            /* IF CONDITION */
            ir_expression *const r01B5 = equal(r01A8, body.constant(int(32)));
            ir_if *f01B4 = new(mem_ctx) ir_if(operand(r01B5).val);
            exec_list *const f01B4_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f01B4->then_instructions;

               body.emit(assign(r01A9, r0184, 0x01));

               body.emit(assign(r01AA, r0183, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f01B4->else_instructions;

               body.emit(assign(r01A7, bit_or(body.constant(0u), r0184), 0x01));

               /* IF CONDITION */
               ir_expression *const r01B7 = less(r01A8, body.constant(int(64)));
               ir_if *f01B6 = new(mem_ctx) ir_if(operand(r01B7).val);
               exec_list *const f01B6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f01B6->then_instructions;

                  body.emit(assign(r01A9, lshift(r0183, r01AC), 0x01));

                  ir_expression *const r01B8 = bit_and(r01A8, body.constant(int(31)));
                  body.emit(assign(r01AA, rshift(r0183, r01B8), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f01B6->else_instructions;

                  ir_variable *const r01B9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r01BB = equal(r01A8, body.constant(int(64)));
                  ir_if *f01BA = new(mem_ctx) ir_if(operand(r01BB).val);
                  exec_list *const f01BA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f01BA->then_instructions;

                     body.emit(assign(r01B9, r0183, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f01BA->else_instructions;

                     ir_expression *const r01BC = nequal(r0183, body.constant(0u));
                     ir_expression *const r01BD = expr(ir_unop_b2i, r01BC);
                     body.emit(assign(r01B9, expr(ir_unop_i2u, r01BD), 0x01));


                  body.instructions = f01BA_parent_instructions;
                  body.emit(f01BA);

                  /* END IF */

                  body.emit(assign(r01A9, r01B9, 0x01));

                  body.emit(assign(r01AA, body.constant(0u), 0x01));


               body.instructions = f01B6_parent_instructions;
               body.emit(f01B6);

               /* END IF */


            body.instructions = f01B4_parent_instructions;
            body.emit(f01B4);

            /* END IF */

            body.emit(assign(r01AB, body.constant(0u), 0x01));


         body.instructions = f01B0_parent_instructions;
         body.emit(f01B0);

         /* END IF */

         ir_expression *const r01BE = nequal(r01A7, body.constant(0u));
         ir_expression *const r01BF = expr(ir_unop_b2i, r01BE);
         ir_expression *const r01C0 = expr(ir_unop_i2u, r01BF);
         body.emit(assign(r01A9, bit_or(r01A9, r01C0), 0x01));


      body.instructions = f01AE_parent_instructions;
      body.emit(f01AE);

      /* END IF */

      body.emit(assign(r0183, r01AB, 0x01));

      body.emit(assign(r0184, r01AA, 0x01));

      body.emit(assign(r0185, r01A9, 0x01));


   body.instructions = f019D_parent_instructions;
   body.emit(f019D);

   /* END IF */

   body.emit(assign(r0182, sub(r0182, r0186), 0x01));

   ir_variable *const r01C1 = body.make_temp(glsl_type::int_type, "zExp");
   body.emit(assign(r01C1, r0182, 0x01));

   ir_variable *const r01C2 = body.make_temp(glsl_type::uint_type, "zFrac0");
   body.emit(assign(r01C2, r0183, 0x01));

   ir_variable *const r01C3 = body.make_temp(glsl_type::uint_type, "zFrac1");
   body.emit(assign(r01C3, r0184, 0x01));

   ir_variable *const r01C4 = body.make_temp(glsl_type::uint_type, "zFrac2");
   body.emit(assign(r01C4, r0185, 0x01));

   ir_variable *const r01C5 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r01C5, body.constant(true), 0x01));

   ir_variable *const r01C6 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r01C7 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
   body.emit(r01C7);
   ir_expression *const r01C8 = expr(ir_unop_u2i, r0185);
   body.emit(assign(r01C7, less(r01C8, body.constant(int(0))), 0x01));

   /* IF CONDITION */
   ir_expression *const r01CA = lequal(body.constant(int(2045)), r0182);
   ir_if *f01C9 = new(mem_ctx) ir_if(operand(r01CA).val);
   exec_list *const f01C9_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f01C9->then_instructions;

      ir_variable *const r01CB = body.make_temp(glsl_type::bool_type, "or_tmp");
      /* IF CONDITION */
      ir_expression *const r01CD = less(body.constant(int(2045)), r0182);
      ir_if *f01CC = new(mem_ctx) ir_if(operand(r01CD).val);
      exec_list *const f01CC_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01CC->then_instructions;

         body.emit(assign(r01CB, body.constant(true), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01CC->else_instructions;

         ir_variable *const r01CE = body.make_temp(glsl_type::bool_type, "and_tmp");
         /* IF CONDITION */
         ir_expression *const r01D0 = equal(r0182, body.constant(int(2045)));
         ir_if *f01CF = new(mem_ctx) ir_if(operand(r01D0).val);
         exec_list *const f01CF_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f01CF->then_instructions;

            ir_expression *const r01D1 = equal(body.constant(2097151u), r0183);
            ir_expression *const r01D2 = equal(body.constant(4294967295u), r0184);
            body.emit(assign(r01CE, logic_and(r01D1, r01D2), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f01CF->else_instructions;

            body.emit(assign(r01CE, body.constant(false), 0x01));


         body.instructions = f01CF_parent_instructions;
         body.emit(f01CF);

         /* END IF */

         body.emit(assign(r01CB, logic_and(r01CE, r01C7), 0x01));


      body.instructions = f01CC_parent_instructions;
      body.emit(f01CC);

      /* END IF */

      /* IF CONDITION */
      ir_if *f01D3 = new(mem_ctx) ir_if(operand(r01CB).val);
      exec_list *const f01D3_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01D3->then_instructions;

         ir_variable *const r01D4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r01D4);
         ir_expression *const r01D5 = lshift(r0181, body.constant(int(31)));
         body.emit(assign(r01D4, add(r01D5, body.constant(2146435072u)), 0x02));

         body.emit(assign(r01D4, body.constant(0u), 0x01));

         body.emit(assign(r01C6, r01D4, 0x03));

         body.emit(assign(r01C5, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01D3->else_instructions;

         /* IF CONDITION */
         ir_expression *const r01D7 = less(r0182, body.constant(int(0)));
         ir_if *f01D6 = new(mem_ctx) ir_if(operand(r01D7).val);
         exec_list *const f01D6_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f01D6->then_instructions;

            ir_variable *const r01D8 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r01D8, r0185, 0x01));

            ir_variable *const r01D9 = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r01D9, neg(r0182), 0x01));

            ir_variable *const r01DA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r01DA);
            ir_variable *const r01DB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r01DB);
            ir_variable *const r01DC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r01DC);
            ir_variable *const r01DD = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r01DE = neg(r01D9);
            body.emit(assign(r01DD, bit_and(r01DE, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r01E0 = equal(r01D9, body.constant(int(0)));
            ir_if *f01DF = new(mem_ctx) ir_if(operand(r01E0).val);
            exec_list *const f01DF_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f01DF->then_instructions;

               body.emit(assign(r01DA, r0185, 0x01));

               body.emit(assign(r01DB, r0184, 0x01));

               body.emit(assign(r01DC, r0183, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f01DF->else_instructions;

               /* IF CONDITION */
               ir_expression *const r01E2 = less(r01D9, body.constant(int(32)));
               ir_if *f01E1 = new(mem_ctx) ir_if(operand(r01E2).val);
               exec_list *const f01E1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f01E1->then_instructions;

                  body.emit(assign(r01DA, lshift(r0184, r01DD), 0x01));

                  ir_expression *const r01E3 = lshift(r0183, r01DD);
                  ir_expression *const r01E4 = rshift(r0184, r01D9);
                  body.emit(assign(r01DB, bit_or(r01E3, r01E4), 0x01));

                  body.emit(assign(r01DC, rshift(r0183, r01D9), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f01E1->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r01E6 = equal(r01D9, body.constant(int(32)));
                  ir_if *f01E5 = new(mem_ctx) ir_if(operand(r01E6).val);
                  exec_list *const f01E5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f01E5->then_instructions;

                     body.emit(assign(r01DA, r0184, 0x01));

                     body.emit(assign(r01DB, r0183, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f01E5->else_instructions;

                     body.emit(assign(r01D8, bit_or(r0185, r0184), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r01E8 = less(r01D9, body.constant(int(64)));
                     ir_if *f01E7 = new(mem_ctx) ir_if(operand(r01E8).val);
                     exec_list *const f01E7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f01E7->then_instructions;

                        body.emit(assign(r01DA, lshift(r0183, r01DD), 0x01));

                        ir_expression *const r01E9 = bit_and(r01D9, body.constant(int(31)));
                        body.emit(assign(r01DB, rshift(r0183, r01E9), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f01E7->else_instructions;

                        ir_variable *const r01EA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r01EC = equal(r01D9, body.constant(int(64)));
                        ir_if *f01EB = new(mem_ctx) ir_if(operand(r01EC).val);
                        exec_list *const f01EB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f01EB->then_instructions;

                           body.emit(assign(r01EA, r0183, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f01EB->else_instructions;

                           ir_expression *const r01ED = nequal(r0183, body.constant(0u));
                           ir_expression *const r01EE = expr(ir_unop_b2i, r01ED);
                           body.emit(assign(r01EA, expr(ir_unop_i2u, r01EE), 0x01));


                        body.instructions = f01EB_parent_instructions;
                        body.emit(f01EB);

                        /* END IF */

                        body.emit(assign(r01DA, r01EA, 0x01));

                        body.emit(assign(r01DB, body.constant(0u), 0x01));


                     body.instructions = f01E7_parent_instructions;
                     body.emit(f01E7);

                     /* END IF */


                  body.instructions = f01E5_parent_instructions;
                  body.emit(f01E5);

                  /* END IF */

                  body.emit(assign(r01DC, body.constant(0u), 0x01));


               body.instructions = f01E1_parent_instructions;
               body.emit(f01E1);

               /* END IF */

               ir_expression *const r01EF = nequal(r01D8, body.constant(0u));
               ir_expression *const r01F0 = expr(ir_unop_b2i, r01EF);
               ir_expression *const r01F1 = expr(ir_unop_i2u, r01F0);
               body.emit(assign(r01DA, bit_or(r01DA, r01F1), 0x01));


            body.instructions = f01DF_parent_instructions;
            body.emit(f01DF);

            /* END IF */

            body.emit(assign(r01C2, r01DC, 0x01));

            body.emit(assign(r01C3, r01DB, 0x01));

            body.emit(assign(r01C4, r01DA, 0x01));

            body.emit(assign(r01C1, body.constant(int(0)), 0x01));

            body.emit(assign(r01C7, less(r01DA, body.constant(0u)), 0x01));


         body.instructions = f01D6_parent_instructions;
         body.emit(f01D6);

         /* END IF */


      body.instructions = f01D3_parent_instructions;
      body.emit(f01D3);

      /* END IF */


   body.instructions = f01C9_parent_instructions;
   body.emit(f01C9);

   /* END IF */

   /* IF CONDITION */
   ir_if *f01F2 = new(mem_ctx) ir_if(operand(r01C5).val);
   exec_list *const f01F2_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f01F2->then_instructions;

      /* IF CONDITION */
      ir_if *f01F3 = new(mem_ctx) ir_if(operand(r01C7).val);
      exec_list *const f01F3_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01F3->then_instructions;

         ir_variable *const r01F4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r01F4, add(r01C3, body.constant(1u)), 0x01));

         ir_expression *const r01F5 = less(r01F4, r01C3);
         ir_expression *const r01F6 = expr(ir_unop_b2i, r01F5);
         ir_expression *const r01F7 = expr(ir_unop_i2u, r01F6);
         body.emit(assign(r01C2, add(r01C2, r01F7), 0x01));

         ir_expression *const r01F8 = equal(r01C4, body.constant(0u));
         ir_expression *const r01F9 = expr(ir_unop_b2i, r01F8);
         ir_expression *const r01FA = expr(ir_unop_i2u, r01F9);
         ir_expression *const r01FB = add(r01C4, r01FA);
         ir_expression *const r01FC = bit_and(r01FB, body.constant(1u));
         ir_expression *const r01FD = expr(ir_unop_bit_not, r01FC);
         body.emit(assign(r01C3, bit_and(r01F4, r01FD), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01F3->else_instructions;

         /* IF CONDITION */
         ir_expression *const r01FF = bit_or(r01C2, r01C3);
         ir_expression *const r0200 = equal(r01FF, body.constant(0u));
         ir_if *f01FE = new(mem_ctx) ir_if(operand(r0200).val);
         exec_list *const f01FE_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f01FE->then_instructions;

            body.emit(assign(r01C1, body.constant(int(0)), 0x01));


         body.instructions = f01FE_parent_instructions;
         body.emit(f01FE);

         /* END IF */


      body.instructions = f01F3_parent_instructions;
      body.emit(f01F3);

      /* END IF */

      ir_variable *const r0201 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r0201);
      ir_expression *const r0202 = lshift(r0181, body.constant(int(31)));
      ir_expression *const r0203 = expr(ir_unop_i2u, r01C1);
      ir_expression *const r0204 = lshift(r0203, body.constant(int(20)));
      ir_expression *const r0205 = add(r0202, r0204);
      body.emit(assign(r0201, add(r0205, r01C2), 0x02));

      body.emit(assign(r0201, r01C3, 0x01));

      body.emit(assign(r01C6, r0201, 0x03));

      body.emit(assign(r01C5, body.constant(false), 0x01));


   body.instructions = f01F2_parent_instructions;
   body.emit(f01F2);

   /* END IF */

   body.emit(ret(r01C6));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
propagateFloat64NaN(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0206 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0206);
   ir_variable *const r0207 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0207);
   ir_variable *const r0208 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r0209 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
   ir_expression *const r020A = lshift(swizzle_y(r0206), body.constant(int(1)));
   ir_expression *const r020B = lequal(body.constant(4292870144u), r020A);
   ir_expression *const r020C = nequal(swizzle_x(r0206), body.constant(0u));
   ir_expression *const r020D = bit_and(swizzle_y(r0206), body.constant(1048575u));
   ir_expression *const r020E = nequal(r020D, body.constant(0u));
   ir_expression *const r020F = logic_or(r020C, r020E);
   body.emit(assign(r0209, logic_and(r020B, r020F), 0x01));

   ir_variable *const r0210 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
   ir_expression *const r0211 = rshift(swizzle_y(r0206), body.constant(int(19)));
   ir_expression *const r0212 = bit_and(r0211, body.constant(4095u));
   ir_expression *const r0213 = equal(r0212, body.constant(4094u));
   ir_expression *const r0214 = nequal(swizzle_x(r0206), body.constant(0u));
   ir_expression *const r0215 = bit_and(swizzle_y(r0206), body.constant(524287u));
   ir_expression *const r0216 = nequal(r0215, body.constant(0u));
   ir_expression *const r0217 = logic_or(r0214, r0216);
   body.emit(assign(r0210, logic_and(r0213, r0217), 0x01));

   ir_variable *const r0218 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
   ir_expression *const r0219 = lshift(swizzle_y(r0207), body.constant(int(1)));
   ir_expression *const r021A = lequal(body.constant(4292870144u), r0219);
   ir_expression *const r021B = nequal(swizzle_x(r0207), body.constant(0u));
   ir_expression *const r021C = bit_and(swizzle_y(r0207), body.constant(1048575u));
   ir_expression *const r021D = nequal(r021C, body.constant(0u));
   ir_expression *const r021E = logic_or(r021B, r021D);
   body.emit(assign(r0218, logic_and(r021A, r021E), 0x01));

   body.emit(assign(r0206, bit_or(swizzle_y(r0206), body.constant(524288u)), 0x02));

   body.emit(assign(r0207, bit_or(swizzle_y(r0207), body.constant(524288u)), 0x02));

   /* IF CONDITION */
   ir_if *f021F = new(mem_ctx) ir_if(operand(r0209).val);
   exec_list *const f021F_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f021F->then_instructions;

      ir_variable *const r0220 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r0222 = logic_and(r0210, r0218);
      ir_if *f0221 = new(mem_ctx) ir_if(operand(r0222).val);
      exec_list *const f0221_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0221->then_instructions;

         body.emit(assign(r0220, r0207, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0221->else_instructions;

         body.emit(assign(r0220, r0206, 0x03));


      body.instructions = f0221_parent_instructions;
      body.emit(f0221);

      /* END IF */

      body.emit(assign(r0208, r0220, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f021F->else_instructions;

      body.emit(assign(r0208, r0207, 0x03));


   body.instructions = f021F_parent_instructions;
   body.emit(f021F);

   /* END IF */

   body.emit(ret(r0208));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
addFloat64Fracs(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0223 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0223);
   ir_variable *const r0224 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0224);
   ir_variable *const r0225 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r0225);
   ir_variable *const r0226 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r0226, body.constant(true), 0x01));

   ir_variable *const r0227 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r0228 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
   body.emit(r0228);
   ir_variable *const r0229 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
   body.emit(r0229);
   ir_variable *const r022A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
   body.emit(r022A);
   ir_variable *const r022B = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r022B);
   ir_variable *const r022C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
   body.emit(r022C);
   ir_variable *const r022D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r022D);
   body.emit(assign(r022D, body.constant(0u), 0x01));

   body.emit(assign(r022C, body.constant(0u), 0x01));

   ir_variable *const r022E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r022E);
   body.emit(assign(r022E, bit_and(swizzle_y(r0223), body.constant(1048575u)), 0x02));

   body.emit(assign(r022E, swizzle_x(r0223), 0x01));

   body.emit(assign(r022A, r022E, 0x03));

   ir_variable *const r022F = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r0230 = rshift(swizzle_y(r0223), body.constant(int(20)));
   ir_expression *const r0231 = bit_and(r0230, body.constant(2047u));
   body.emit(assign(r022F, expr(ir_unop_u2i, r0231), 0x01));

   ir_variable *const r0232 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r0232);
   body.emit(assign(r0232, bit_and(swizzle_y(r0224), body.constant(1048575u)), 0x02));

   body.emit(assign(r0232, swizzle_x(r0224), 0x01));

   body.emit(assign(r0229, r0232, 0x03));

   ir_variable *const r0233 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r0234 = rshift(swizzle_y(r0224), body.constant(int(20)));
   ir_expression *const r0235 = bit_and(r0234, body.constant(2047u));
   body.emit(assign(r0233, expr(ir_unop_u2i, r0235), 0x01));

   ir_variable *const r0236 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   body.emit(assign(r0236, sub(r022F, r0233), 0x01));

   body.emit(assign(r0228, r0236, 0x01));

   /* IF CONDITION */
   ir_expression *const r0238 = less(body.constant(int(0)), r0236);
   ir_if *f0237 = new(mem_ctx) ir_if(operand(r0238).val);
   exec_list *const f0237_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0237->then_instructions;

      /* IF CONDITION */
      ir_expression *const r023A = equal(r022F, body.constant(int(2047)));
      ir_if *f0239 = new(mem_ctx) ir_if(operand(r023A).val);
      exec_list *const f0239_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0239->then_instructions;

         /* IF CONDITION */
         ir_expression *const r023C = bit_or(swizzle_y(r022E), swizzle_x(r0223));
         ir_expression *const r023D = nequal(r023C, body.constant(0u));
         ir_if *f023B = new(mem_ctx) ir_if(operand(r023D).val);
         exec_list *const f023B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f023B->then_instructions;

            ir_variable *const r023E = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r023E, swizzle_x(r0223), 0x01));

            ir_variable *const r023F = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r023F, swizzle_x(r0224), 0x01));

            ir_variable *const r0240 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0241 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r0242 = rshift(swizzle_y(r0223), body.constant(int(19)));
            ir_expression *const r0243 = bit_and(r0242, body.constant(4095u));
            ir_expression *const r0244 = equal(r0243, body.constant(4094u));
            ir_expression *const r0245 = nequal(swizzle_x(r0223), body.constant(0u));
            ir_expression *const r0246 = bit_and(swizzle_y(r0223), body.constant(524287u));
            ir_expression *const r0247 = nequal(r0246, body.constant(0u));
            ir_expression *const r0248 = logic_or(r0245, r0247);
            body.emit(assign(r0241, logic_and(r0244, r0248), 0x01));

            ir_variable *const r0249 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r024A = lshift(swizzle_y(r0224), body.constant(int(1)));
            ir_expression *const r024B = lequal(body.constant(4292870144u), r024A);
            ir_expression *const r024C = nequal(swizzle_x(r0224), body.constant(0u));
            ir_expression *const r024D = bit_and(swizzle_y(r0224), body.constant(1048575u));
            ir_expression *const r024E = nequal(r024D, body.constant(0u));
            ir_expression *const r024F = logic_or(r024C, r024E);
            body.emit(assign(r0249, logic_and(r024B, r024F), 0x01));

            body.emit(assign(r023E, bit_or(swizzle_y(r0223), body.constant(524288u)), 0x02));

            body.emit(assign(r023F, bit_or(swizzle_y(r0224), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r0251 = lshift(swizzle_y(r0223), body.constant(int(1)));
            ir_expression *const r0252 = lequal(body.constant(4292870144u), r0251);
            ir_expression *const r0253 = nequal(swizzle_x(r0223), body.constant(0u));
            ir_expression *const r0254 = bit_and(swizzle_y(r0223), body.constant(1048575u));
            ir_expression *const r0255 = nequal(r0254, body.constant(0u));
            ir_expression *const r0256 = logic_or(r0253, r0255);
            ir_expression *const r0257 = logic_and(r0252, r0256);
            ir_if *f0250 = new(mem_ctx) ir_if(operand(r0257).val);
            exec_list *const f0250_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0250->then_instructions;

               ir_variable *const r0258 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r025A = logic_and(r0241, r0249);
               ir_if *f0259 = new(mem_ctx) ir_if(operand(r025A).val);
               exec_list *const f0259_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0259->then_instructions;

                  body.emit(assign(r0258, r023F, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0259->else_instructions;

                  body.emit(assign(r0258, r023E, 0x03));


               body.instructions = f0259_parent_instructions;
               body.emit(f0259);

               /* END IF */

               body.emit(assign(r0240, r0258, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0250->else_instructions;

               body.emit(assign(r0240, r023F, 0x03));


            body.instructions = f0250_parent_instructions;
            body.emit(f0250);

            /* END IF */

            body.emit(assign(r0227, r0240, 0x03));

            body.emit(assign(r0226, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f023B->else_instructions;

            body.emit(assign(r0227, r0223, 0x03));

            body.emit(assign(r0226, body.constant(false), 0x01));


         body.instructions = f023B_parent_instructions;
         body.emit(f023B);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0239->else_instructions;

         /* IF CONDITION */
         ir_expression *const r025C = equal(r0233, body.constant(int(0)));
         ir_if *f025B = new(mem_ctx) ir_if(operand(r025C).val);
         exec_list *const f025B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f025B->then_instructions;

            body.emit(assign(r0228, add(r0236, body.constant(int(-1))), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f025B->else_instructions;

            body.emit(assign(r0229, bit_or(swizzle_y(r0232), body.constant(1048576u)), 0x02));


         body.instructions = f025B_parent_instructions;
         body.emit(f025B);

         /* END IF */

         ir_variable *const r025D = body.make_temp(glsl_type::uint_type, "a0");
         body.emit(assign(r025D, swizzle_y(r0229), 0x01));

         ir_variable *const r025E = body.make_temp(glsl_type::uint_type, "a1");
         body.emit(assign(r025E, swizzle_x(r0229), 0x01));

         ir_variable *const r025F = body.make_temp(glsl_type::uint_type, "a2");
         body.emit(assign(r025F, body.constant(0u), 0x01));

         ir_variable *const r0260 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
         body.emit(r0260);
         ir_variable *const r0261 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r0261);
         ir_variable *const r0262 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r0262);
         ir_variable *const r0263 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         ir_expression *const r0264 = neg(r0228);
         body.emit(assign(r0263, bit_and(r0264, body.constant(int(31))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0266 = equal(r0228, body.constant(int(0)));
         ir_if *f0265 = new(mem_ctx) ir_if(operand(r0266).val);
         exec_list *const f0265_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0265->then_instructions;

            body.emit(assign(r0260, r025F, 0x01));

            body.emit(assign(r0261, r025E, 0x01));

            body.emit(assign(r0262, r025D, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0265->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0268 = less(r0228, body.constant(int(32)));
            ir_if *f0267 = new(mem_ctx) ir_if(operand(r0268).val);
            exec_list *const f0267_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0267->then_instructions;

               body.emit(assign(r0260, lshift(swizzle_x(r0232), r0263), 0x01));

               ir_expression *const r0269 = lshift(swizzle_y(r0229), r0263);
               ir_expression *const r026A = rshift(swizzle_x(r0232), r0228);
               body.emit(assign(r0261, bit_or(r0269, r026A), 0x01));

               body.emit(assign(r0262, rshift(swizzle_y(r0229), r0228), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0267->else_instructions;

               /* IF CONDITION */
               ir_expression *const r026C = equal(r0228, body.constant(int(32)));
               ir_if *f026B = new(mem_ctx) ir_if(operand(r026C).val);
               exec_list *const f026B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f026B->then_instructions;

                  body.emit(assign(r0260, r025E, 0x01));

                  body.emit(assign(r0261, r025D, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f026B->else_instructions;

                  body.emit(assign(r025F, bit_or(body.constant(0u), swizzle_x(r0232)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r026E = less(r0228, body.constant(int(64)));
                  ir_if *f026D = new(mem_ctx) ir_if(operand(r026E).val);
                  exec_list *const f026D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f026D->then_instructions;

                     body.emit(assign(r0260, lshift(swizzle_y(r0229), r0263), 0x01));

                     ir_expression *const r026F = bit_and(r0228, body.constant(int(31)));
                     body.emit(assign(r0261, rshift(swizzle_y(r0229), r026F), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f026D->else_instructions;

                     ir_variable *const r0270 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0272 = equal(r0228, body.constant(int(64)));
                     ir_if *f0271 = new(mem_ctx) ir_if(operand(r0272).val);
                     exec_list *const f0271_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0271->then_instructions;

                        body.emit(assign(r0270, r025D, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0271->else_instructions;

                        ir_expression *const r0273 = nequal(swizzle_y(r0229), body.constant(0u));
                        ir_expression *const r0274 = expr(ir_unop_b2i, r0273);
                        body.emit(assign(r0270, expr(ir_unop_i2u, r0274), 0x01));


                     body.instructions = f0271_parent_instructions;
                     body.emit(f0271);

                     /* END IF */

                     body.emit(assign(r0260, r0270, 0x01));

                     body.emit(assign(r0261, body.constant(0u), 0x01));


                  body.instructions = f026D_parent_instructions;
                  body.emit(f026D);

                  /* END IF */


               body.instructions = f026B_parent_instructions;
               body.emit(f026B);

               /* END IF */

               body.emit(assign(r0262, body.constant(0u), 0x01));


            body.instructions = f0267_parent_instructions;
            body.emit(f0267);

            /* END IF */

            ir_expression *const r0275 = nequal(r025F, body.constant(0u));
            ir_expression *const r0276 = expr(ir_unop_b2i, r0275);
            ir_expression *const r0277 = expr(ir_unop_i2u, r0276);
            body.emit(assign(r0260, bit_or(r0260, r0277), 0x01));


         body.instructions = f0265_parent_instructions;
         body.emit(f0265);

         /* END IF */

         body.emit(assign(r0229, r0262, 0x02));

         body.emit(assign(r0229, r0261, 0x01));

         body.emit(assign(r022C, r0260, 0x01));

         body.emit(assign(r022B, r022F, 0x01));


      body.instructions = f0239_parent_instructions;
      body.emit(f0239);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0237->else_instructions;

      /* IF CONDITION */
      ir_expression *const r0279 = less(r0228, body.constant(int(0)));
      ir_if *f0278 = new(mem_ctx) ir_if(operand(r0279).val);
      exec_list *const f0278_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0278->then_instructions;

         /* IF CONDITION */
         ir_expression *const r027B = equal(r0233, body.constant(int(2047)));
         ir_if *f027A = new(mem_ctx) ir_if(operand(r027B).val);
         exec_list *const f027A_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f027A->then_instructions;

            /* IF CONDITION */
            ir_expression *const r027D = bit_or(swizzle_y(r0229), swizzle_x(r0229));
            ir_expression *const r027E = nequal(r027D, body.constant(0u));
            ir_if *f027C = new(mem_ctx) ir_if(operand(r027E).val);
            exec_list *const f027C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f027C->then_instructions;

               ir_variable *const r027F = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r027F, swizzle_x(r0223), 0x01));

               ir_variable *const r0280 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r0280, swizzle_x(r0224), 0x01));

               ir_variable *const r0281 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0282 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r0283 = rshift(swizzle_y(r0223), body.constant(int(19)));
               ir_expression *const r0284 = bit_and(r0283, body.constant(4095u));
               ir_expression *const r0285 = equal(r0284, body.constant(4094u));
               ir_expression *const r0286 = nequal(swizzle_x(r0223), body.constant(0u));
               ir_expression *const r0287 = bit_and(swizzle_y(r0223), body.constant(524287u));
               ir_expression *const r0288 = nequal(r0287, body.constant(0u));
               ir_expression *const r0289 = logic_or(r0286, r0288);
               body.emit(assign(r0282, logic_and(r0285, r0289), 0x01));

               ir_variable *const r028A = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r028B = lshift(swizzle_y(r0224), body.constant(int(1)));
               ir_expression *const r028C = lequal(body.constant(4292870144u), r028B);
               ir_expression *const r028D = nequal(swizzle_x(r0224), body.constant(0u));
               ir_expression *const r028E = bit_and(swizzle_y(r0224), body.constant(1048575u));
               ir_expression *const r028F = nequal(r028E, body.constant(0u));
               ir_expression *const r0290 = logic_or(r028D, r028F);
               body.emit(assign(r028A, logic_and(r028C, r0290), 0x01));

               body.emit(assign(r027F, bit_or(swizzle_y(r0223), body.constant(524288u)), 0x02));

               body.emit(assign(r0280, bit_or(swizzle_y(r0224), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r0292 = lshift(swizzle_y(r0223), body.constant(int(1)));
               ir_expression *const r0293 = lequal(body.constant(4292870144u), r0292);
               ir_expression *const r0294 = nequal(swizzle_x(r0223), body.constant(0u));
               ir_expression *const r0295 = bit_and(swizzle_y(r0223), body.constant(1048575u));
               ir_expression *const r0296 = nequal(r0295, body.constant(0u));
               ir_expression *const r0297 = logic_or(r0294, r0296);
               ir_expression *const r0298 = logic_and(r0293, r0297);
               ir_if *f0291 = new(mem_ctx) ir_if(operand(r0298).val);
               exec_list *const f0291_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0291->then_instructions;

                  ir_variable *const r0299 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r029B = logic_and(r0282, r028A);
                  ir_if *f029A = new(mem_ctx) ir_if(operand(r029B).val);
                  exec_list *const f029A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f029A->then_instructions;

                     body.emit(assign(r0299, r0280, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f029A->else_instructions;

                     body.emit(assign(r0299, r027F, 0x03));


                  body.instructions = f029A_parent_instructions;
                  body.emit(f029A);

                  /* END IF */

                  body.emit(assign(r0281, r0299, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0291->else_instructions;

                  body.emit(assign(r0281, r0280, 0x03));


               body.instructions = f0291_parent_instructions;
               body.emit(f0291);

               /* END IF */

               body.emit(assign(r0227, r0281, 0x03));

               body.emit(assign(r0226, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f027C->else_instructions;

               ir_variable *const r029C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r029C);
               ir_expression *const r029D = lshift(r0225, body.constant(int(31)));
               body.emit(assign(r029C, add(r029D, body.constant(2146435072u)), 0x02));

               body.emit(assign(r029C, body.constant(0u), 0x01));

               body.emit(assign(r0227, r029C, 0x03));

               body.emit(assign(r0226, body.constant(false), 0x01));


            body.instructions = f027C_parent_instructions;
            body.emit(f027C);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f027A->else_instructions;

            /* IF CONDITION */
            ir_expression *const r029F = equal(r022F, body.constant(int(0)));
            ir_if *f029E = new(mem_ctx) ir_if(operand(r029F).val);
            exec_list *const f029E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f029E->then_instructions;

               body.emit(assign(r0228, add(r0228, body.constant(int(1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f029E->else_instructions;

               body.emit(assign(r022A, bit_or(swizzle_y(r022E), body.constant(1048576u)), 0x02));


            body.instructions = f029E_parent_instructions;
            body.emit(f029E);

            /* END IF */

            ir_variable *const r02A0 = body.make_temp(glsl_type::uint_type, "a0");
            body.emit(assign(r02A0, swizzle_y(r022A), 0x01));

            ir_variable *const r02A1 = body.make_temp(glsl_type::uint_type, "a1");
            body.emit(assign(r02A1, swizzle_x(r022A), 0x01));

            ir_variable *const r02A2 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r02A2, body.constant(0u), 0x01));

            ir_variable *const r02A3 = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r02A3, neg(r0228), 0x01));

            ir_variable *const r02A4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r02A4);
            ir_variable *const r02A5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r02A5);
            ir_variable *const r02A6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r02A6);
            ir_variable *const r02A7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r02A8 = neg(r02A3);
            body.emit(assign(r02A7, bit_and(r02A8, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r02AA = equal(r02A3, body.constant(int(0)));
            ir_if *f02A9 = new(mem_ctx) ir_if(operand(r02AA).val);
            exec_list *const f02A9_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f02A9->then_instructions;

               body.emit(assign(r02A4, r02A2, 0x01));

               body.emit(assign(r02A5, r02A1, 0x01));

               body.emit(assign(r02A6, r02A0, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f02A9->else_instructions;

               /* IF CONDITION */
               ir_expression *const r02AC = less(r02A3, body.constant(int(32)));
               ir_if *f02AB = new(mem_ctx) ir_if(operand(r02AC).val);
               exec_list *const f02AB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f02AB->then_instructions;

                  body.emit(assign(r02A4, lshift(swizzle_x(r022E), r02A7), 0x01));

                  ir_expression *const r02AD = lshift(swizzle_y(r022A), r02A7);
                  ir_expression *const r02AE = rshift(swizzle_x(r022E), r02A3);
                  body.emit(assign(r02A5, bit_or(r02AD, r02AE), 0x01));

                  body.emit(assign(r02A6, rshift(swizzle_y(r022A), r02A3), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f02AB->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r02B0 = equal(r02A3, body.constant(int(32)));
                  ir_if *f02AF = new(mem_ctx) ir_if(operand(r02B0).val);
                  exec_list *const f02AF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f02AF->then_instructions;

                     body.emit(assign(r02A4, r02A1, 0x01));

                     body.emit(assign(r02A5, r02A0, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f02AF->else_instructions;

                     body.emit(assign(r02A2, bit_or(body.constant(0u), swizzle_x(r022E)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r02B2 = less(r02A3, body.constant(int(64)));
                     ir_if *f02B1 = new(mem_ctx) ir_if(operand(r02B2).val);
                     exec_list *const f02B1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f02B1->then_instructions;

                        body.emit(assign(r02A4, lshift(swizzle_y(r022A), r02A7), 0x01));

                        ir_expression *const r02B3 = bit_and(r02A3, body.constant(int(31)));
                        body.emit(assign(r02A5, rshift(swizzle_y(r022A), r02B3), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f02B1->else_instructions;

                        ir_variable *const r02B4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r02B6 = equal(r02A3, body.constant(int(64)));
                        ir_if *f02B5 = new(mem_ctx) ir_if(operand(r02B6).val);
                        exec_list *const f02B5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f02B5->then_instructions;

                           body.emit(assign(r02B4, r02A0, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f02B5->else_instructions;

                           ir_expression *const r02B7 = nequal(swizzle_y(r022A), body.constant(0u));
                           ir_expression *const r02B8 = expr(ir_unop_b2i, r02B7);
                           body.emit(assign(r02B4, expr(ir_unop_i2u, r02B8), 0x01));


                        body.instructions = f02B5_parent_instructions;
                        body.emit(f02B5);

                        /* END IF */

                        body.emit(assign(r02A4, r02B4, 0x01));

                        body.emit(assign(r02A5, body.constant(0u), 0x01));


                     body.instructions = f02B1_parent_instructions;
                     body.emit(f02B1);

                     /* END IF */


                  body.instructions = f02AF_parent_instructions;
                  body.emit(f02AF);

                  /* END IF */

                  body.emit(assign(r02A6, body.constant(0u), 0x01));


               body.instructions = f02AB_parent_instructions;
               body.emit(f02AB);

               /* END IF */

               ir_expression *const r02B9 = nequal(r02A2, body.constant(0u));
               ir_expression *const r02BA = expr(ir_unop_b2i, r02B9);
               ir_expression *const r02BB = expr(ir_unop_i2u, r02BA);
               body.emit(assign(r02A4, bit_or(r02A4, r02BB), 0x01));


            body.instructions = f02A9_parent_instructions;
            body.emit(f02A9);

            /* END IF */

            body.emit(assign(r022A, r02A6, 0x02));

            body.emit(assign(r022A, r02A5, 0x01));

            body.emit(assign(r022C, r02A4, 0x01));

            body.emit(assign(r022B, r0233, 0x01));


         body.instructions = f027A_parent_instructions;
         body.emit(f027A);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0278->else_instructions;

         /* IF CONDITION */
         ir_expression *const r02BD = equal(r022F, body.constant(int(2047)));
         ir_if *f02BC = new(mem_ctx) ir_if(operand(r02BD).val);
         exec_list *const f02BC_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f02BC->then_instructions;

            /* IF CONDITION */
            ir_expression *const r02BF = bit_or(swizzle_y(r022A), swizzle_x(r022A));
            ir_expression *const r02C0 = bit_or(swizzle_y(r0229), swizzle_x(r0229));
            ir_expression *const r02C1 = bit_or(r02BF, r02C0);
            ir_expression *const r02C2 = nequal(r02C1, body.constant(0u));
            ir_if *f02BE = new(mem_ctx) ir_if(operand(r02C2).val);
            exec_list *const f02BE_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f02BE->then_instructions;

               ir_variable *const r02C3 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r02C3, swizzle_x(r0223), 0x01));

               ir_variable *const r02C4 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r02C4, swizzle_x(r0224), 0x01));

               ir_variable *const r02C5 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r02C6 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r02C7 = rshift(swizzle_y(r0223), body.constant(int(19)));
               ir_expression *const r02C8 = bit_and(r02C7, body.constant(4095u));
               ir_expression *const r02C9 = equal(r02C8, body.constant(4094u));
               ir_expression *const r02CA = nequal(swizzle_x(r0223), body.constant(0u));
               ir_expression *const r02CB = bit_and(swizzle_y(r0223), body.constant(524287u));
               ir_expression *const r02CC = nequal(r02CB, body.constant(0u));
               ir_expression *const r02CD = logic_or(r02CA, r02CC);
               body.emit(assign(r02C6, logic_and(r02C9, r02CD), 0x01));

               ir_variable *const r02CE = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r02CF = lshift(swizzle_y(r0224), body.constant(int(1)));
               ir_expression *const r02D0 = lequal(body.constant(4292870144u), r02CF);
               ir_expression *const r02D1 = nequal(swizzle_x(r0224), body.constant(0u));
               ir_expression *const r02D2 = bit_and(swizzle_y(r0224), body.constant(1048575u));
               ir_expression *const r02D3 = nequal(r02D2, body.constant(0u));
               ir_expression *const r02D4 = logic_or(r02D1, r02D3);
               body.emit(assign(r02CE, logic_and(r02D0, r02D4), 0x01));

               body.emit(assign(r02C3, bit_or(swizzle_y(r0223), body.constant(524288u)), 0x02));

               body.emit(assign(r02C4, bit_or(swizzle_y(r0224), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r02D6 = lshift(swizzle_y(r0223), body.constant(int(1)));
               ir_expression *const r02D7 = lequal(body.constant(4292870144u), r02D6);
               ir_expression *const r02D8 = nequal(swizzle_x(r0223), body.constant(0u));
               ir_expression *const r02D9 = bit_and(swizzle_y(r0223), body.constant(1048575u));
               ir_expression *const r02DA = nequal(r02D9, body.constant(0u));
               ir_expression *const r02DB = logic_or(r02D8, r02DA);
               ir_expression *const r02DC = logic_and(r02D7, r02DB);
               ir_if *f02D5 = new(mem_ctx) ir_if(operand(r02DC).val);
               exec_list *const f02D5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f02D5->then_instructions;

                  ir_variable *const r02DD = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r02DF = logic_and(r02C6, r02CE);
                  ir_if *f02DE = new(mem_ctx) ir_if(operand(r02DF).val);
                  exec_list *const f02DE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f02DE->then_instructions;

                     body.emit(assign(r02DD, r02C4, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f02DE->else_instructions;

                     body.emit(assign(r02DD, r02C3, 0x03));


                  body.instructions = f02DE_parent_instructions;
                  body.emit(f02DE);

                  /* END IF */

                  body.emit(assign(r02C5, r02DD, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f02D5->else_instructions;

                  body.emit(assign(r02C5, r02C4, 0x03));


               body.instructions = f02D5_parent_instructions;
               body.emit(f02D5);

               /* END IF */

               body.emit(assign(r0227, r02C5, 0x03));

               body.emit(assign(r0226, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f02BE->else_instructions;

               body.emit(assign(r0227, r0223, 0x03));

               body.emit(assign(r0226, body.constant(false), 0x01));


            body.instructions = f02BE_parent_instructions;
            body.emit(f02BE);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f02BC->else_instructions;

            ir_variable *const r02E0 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r02E1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r02E1, add(swizzle_x(r022A), swizzle_x(r0229)), 0x01));

            ir_expression *const r02E2 = add(swizzle_y(r022A), swizzle_y(r0229));
            ir_expression *const r02E3 = less(r02E1, swizzle_x(r022A));
            ir_expression *const r02E4 = expr(ir_unop_b2i, r02E3);
            ir_expression *const r02E5 = expr(ir_unop_i2u, r02E4);
            body.emit(assign(r02E0, add(r02E2, r02E5), 0x01));

            body.emit(assign(r022D, r02E0, 0x01));

            /* IF CONDITION */
            ir_expression *const r02E7 = equal(r022F, body.constant(int(0)));
            ir_if *f02E6 = new(mem_ctx) ir_if(operand(r02E7).val);
            exec_list *const f02E6_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f02E6->then_instructions;

               ir_variable *const r02E8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r02E8);
               ir_expression *const r02E9 = lshift(r0225, body.constant(int(31)));
               body.emit(assign(r02E8, add(r02E9, r02E0), 0x02));

               body.emit(assign(r02E8, r02E1, 0x01));

               body.emit(assign(r0227, r02E8, 0x03));

               body.emit(assign(r0226, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f02E6->else_instructions;

               body.emit(assign(r022D, bit_or(r02E0, body.constant(2097152u)), 0x01));

               body.emit(assign(r022B, r022F, 0x01));

               ir_variable *const r02EA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r02EA);
               ir_variable *const r02EB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r02EB);
               ir_variable *const r02EC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r02EC);
               body.emit(assign(r02EA, lshift(r02E1, body.constant(int(31))), 0x01));

               ir_expression *const r02ED = lshift(r022D, body.constant(int(31)));
               ir_expression *const r02EE = rshift(r02E1, body.constant(int(1)));
               body.emit(assign(r02EB, bit_or(r02ED, r02EE), 0x01));

               body.emit(assign(r02EC, rshift(r022D, body.constant(int(1))), 0x01));

               body.emit(assign(r02EA, bit_or(r02EA, body.constant(0u)), 0x01));

               body.emit(assign(r022D, r02EC, 0x01));

               body.emit(assign(r022C, r02EA, 0x01));

               ir_variable *const r02EF = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r02EF, r022F, 0x01));

               ir_variable *const r02F0 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r02F0, r02EC, 0x01));

               ir_variable *const r02F1 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r02F1, r02EB, 0x01));

               ir_variable *const r02F2 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r02F2, r02EA, 0x01));

               ir_variable *const r02F3 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r02F3, body.constant(true), 0x01));

               ir_variable *const r02F4 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r02F5 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r02F5);
               ir_expression *const r02F6 = expr(ir_unop_u2i, r02EA);
               body.emit(assign(r02F5, less(r02F6, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r02F8 = lequal(body.constant(int(2045)), r022F);
               ir_if *f02F7 = new(mem_ctx) ir_if(operand(r02F8).val);
               exec_list *const f02F7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f02F7->then_instructions;

                  ir_variable *const r02F9 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r02FB = less(body.constant(int(2045)), r022F);
                  ir_if *f02FA = new(mem_ctx) ir_if(operand(r02FB).val);
                  exec_list *const f02FA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f02FA->then_instructions;

                     body.emit(assign(r02F9, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f02FA->else_instructions;

                     ir_variable *const r02FC = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r02FE = equal(r022F, body.constant(int(2045)));
                     ir_if *f02FD = new(mem_ctx) ir_if(operand(r02FE).val);
                     exec_list *const f02FD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f02FD->then_instructions;

                        ir_expression *const r02FF = equal(body.constant(2097151u), r02EC);
                        ir_expression *const r0300 = equal(body.constant(4294967295u), r02EB);
                        body.emit(assign(r02FC, logic_and(r02FF, r0300), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f02FD->else_instructions;

                        body.emit(assign(r02FC, body.constant(false), 0x01));


                     body.instructions = f02FD_parent_instructions;
                     body.emit(f02FD);

                     /* END IF */

                     body.emit(assign(r02F9, logic_and(r02FC, r02F5), 0x01));


                  body.instructions = f02FA_parent_instructions;
                  body.emit(f02FA);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0301 = new(mem_ctx) ir_if(operand(r02F9).val);
                  exec_list *const f0301_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0301->then_instructions;

                     ir_variable *const r0302 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0302);
                     ir_expression *const r0303 = lshift(r0225, body.constant(int(31)));
                     body.emit(assign(r0302, add(r0303, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r0302, body.constant(0u), 0x01));

                     body.emit(assign(r02F4, r0302, 0x03));

                     body.emit(assign(r02F3, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0301->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0305 = less(r022F, body.constant(int(0)));
                     ir_if *f0304 = new(mem_ctx) ir_if(operand(r0305).val);
                     exec_list *const f0304_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0304->then_instructions;

                        ir_variable *const r0306 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0306, r02EA, 0x01));

                        ir_variable *const r0307 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0307, neg(r022F), 0x01));

                        ir_variable *const r0308 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0308);
                        ir_variable *const r0309 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0309);
                        ir_variable *const r030A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r030A);
                        ir_variable *const r030B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r030C = neg(r0307);
                        body.emit(assign(r030B, bit_and(r030C, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r030E = equal(r0307, body.constant(int(0)));
                        ir_if *f030D = new(mem_ctx) ir_if(operand(r030E).val);
                        exec_list *const f030D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f030D->then_instructions;

                           body.emit(assign(r0308, r02EA, 0x01));

                           body.emit(assign(r0309, r02EB, 0x01));

                           body.emit(assign(r030A, r02EC, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f030D->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0310 = less(r0307, body.constant(int(32)));
                           ir_if *f030F = new(mem_ctx) ir_if(operand(r0310).val);
                           exec_list *const f030F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f030F->then_instructions;

                              body.emit(assign(r0308, lshift(r02EB, r030B), 0x01));

                              ir_expression *const r0311 = lshift(r02EC, r030B);
                              ir_expression *const r0312 = rshift(r02EB, r0307);
                              body.emit(assign(r0309, bit_or(r0311, r0312), 0x01));

                              body.emit(assign(r030A, rshift(r02EC, r0307), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f030F->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0314 = equal(r0307, body.constant(int(32)));
                              ir_if *f0313 = new(mem_ctx) ir_if(operand(r0314).val);
                              exec_list *const f0313_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0313->then_instructions;

                                 body.emit(assign(r0308, r02EB, 0x01));

                                 body.emit(assign(r0309, r02EC, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0313->else_instructions;

                                 body.emit(assign(r0306, bit_or(r02EA, r02EB), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0316 = less(r0307, body.constant(int(64)));
                                 ir_if *f0315 = new(mem_ctx) ir_if(operand(r0316).val);
                                 exec_list *const f0315_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0315->then_instructions;

                                    body.emit(assign(r0308, lshift(r02EC, r030B), 0x01));

                                    ir_expression *const r0317 = bit_and(r0307, body.constant(int(31)));
                                    body.emit(assign(r0309, rshift(r02EC, r0317), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0315->else_instructions;

                                    ir_variable *const r0318 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r031A = equal(r0307, body.constant(int(64)));
                                    ir_if *f0319 = new(mem_ctx) ir_if(operand(r031A).val);
                                    exec_list *const f0319_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0319->then_instructions;

                                       body.emit(assign(r0318, r02EC, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0319->else_instructions;

                                       ir_expression *const r031B = nequal(r02EC, body.constant(0u));
                                       ir_expression *const r031C = expr(ir_unop_b2i, r031B);
                                       body.emit(assign(r0318, expr(ir_unop_i2u, r031C), 0x01));


                                    body.instructions = f0319_parent_instructions;
                                    body.emit(f0319);

                                    /* END IF */

                                    body.emit(assign(r0308, r0318, 0x01));

                                    body.emit(assign(r0309, body.constant(0u), 0x01));


                                 body.instructions = f0315_parent_instructions;
                                 body.emit(f0315);

                                 /* END IF */


                              body.instructions = f0313_parent_instructions;
                              body.emit(f0313);

                              /* END IF */

                              body.emit(assign(r030A, body.constant(0u), 0x01));


                           body.instructions = f030F_parent_instructions;
                           body.emit(f030F);

                           /* END IF */

                           ir_expression *const r031D = nequal(r0306, body.constant(0u));
                           ir_expression *const r031E = expr(ir_unop_b2i, r031D);
                           ir_expression *const r031F = expr(ir_unop_i2u, r031E);
                           body.emit(assign(r0308, bit_or(r0308, r031F), 0x01));


                        body.instructions = f030D_parent_instructions;
                        body.emit(f030D);

                        /* END IF */

                        body.emit(assign(r02F0, r030A, 0x01));

                        body.emit(assign(r02F1, r0309, 0x01));

                        body.emit(assign(r02F2, r0308, 0x01));

                        body.emit(assign(r02EF, body.constant(int(0)), 0x01));

                        body.emit(assign(r02F5, less(r0308, body.constant(0u)), 0x01));


                     body.instructions = f0304_parent_instructions;
                     body.emit(f0304);

                     /* END IF */


                  body.instructions = f0301_parent_instructions;
                  body.emit(f0301);

                  /* END IF */


               body.instructions = f02F7_parent_instructions;
               body.emit(f02F7);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0320 = new(mem_ctx) ir_if(operand(r02F3).val);
               exec_list *const f0320_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0320->then_instructions;

                  /* IF CONDITION */
                  ir_if *f0321 = new(mem_ctx) ir_if(operand(r02F5).val);
                  exec_list *const f0321_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0321->then_instructions;

                     ir_variable *const r0322 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r0322, add(r02F1, body.constant(1u)), 0x01));

                     ir_expression *const r0323 = less(r0322, r02F1);
                     ir_expression *const r0324 = expr(ir_unop_b2i, r0323);
                     ir_expression *const r0325 = expr(ir_unop_i2u, r0324);
                     body.emit(assign(r02F0, add(r02F0, r0325), 0x01));

                     ir_expression *const r0326 = equal(r02F2, body.constant(0u));
                     ir_expression *const r0327 = expr(ir_unop_b2i, r0326);
                     ir_expression *const r0328 = expr(ir_unop_i2u, r0327);
                     ir_expression *const r0329 = add(r02F2, r0328);
                     ir_expression *const r032A = bit_and(r0329, body.constant(1u));
                     ir_expression *const r032B = expr(ir_unop_bit_not, r032A);
                     body.emit(assign(r02F1, bit_and(r0322, r032B), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0321->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r032D = bit_or(r02F0, r02F1);
                     ir_expression *const r032E = equal(r032D, body.constant(0u));
                     ir_if *f032C = new(mem_ctx) ir_if(operand(r032E).val);
                     exec_list *const f032C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f032C->then_instructions;

                        body.emit(assign(r02EF, body.constant(int(0)), 0x01));


                     body.instructions = f032C_parent_instructions;
                     body.emit(f032C);

                     /* END IF */


                  body.instructions = f0321_parent_instructions;
                  body.emit(f0321);

                  /* END IF */

                  ir_variable *const r032F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r032F);
                  ir_expression *const r0330 = lshift(r0225, body.constant(int(31)));
                  ir_expression *const r0331 = expr(ir_unop_i2u, r02EF);
                  ir_expression *const r0332 = lshift(r0331, body.constant(int(20)));
                  ir_expression *const r0333 = add(r0330, r0332);
                  body.emit(assign(r032F, add(r0333, r02F0), 0x02));

                  body.emit(assign(r032F, r02F1, 0x01));

                  body.emit(assign(r02F4, r032F, 0x03));

                  body.emit(assign(r02F3, body.constant(false), 0x01));


               body.instructions = f0320_parent_instructions;
               body.emit(f0320);

               /* END IF */

               body.emit(assign(r0227, r02F4, 0x03));

               body.emit(assign(r0226, body.constant(false), 0x01));


            body.instructions = f02E6_parent_instructions;
            body.emit(f02E6);

            /* END IF */


         body.instructions = f02BC_parent_instructions;
         body.emit(f02BC);

         /* END IF */


      body.instructions = f0278_parent_instructions;
      body.emit(f0278);

      /* END IF */


   body.instructions = f0237_parent_instructions;
   body.emit(f0237);

   /* END IF */

   /* IF CONDITION */
   ir_if *f0334 = new(mem_ctx) ir_if(operand(r0226).val);
   exec_list *const f0334_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0334->then_instructions;

      body.emit(assign(r022A, bit_or(swizzle_y(r022A), body.constant(1048576u)), 0x02));

      ir_variable *const r0335 = body.make_temp(glsl_type::uint_type, "z0Ptr");
      ir_variable *const r0336 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r0336, add(swizzle_x(r022A), swizzle_x(r0229)), 0x01));

      ir_expression *const r0337 = add(swizzle_y(r022A), swizzle_y(r0229));
      ir_expression *const r0338 = less(r0336, swizzle_x(r022A));
      ir_expression *const r0339 = expr(ir_unop_b2i, r0338);
      ir_expression *const r033A = expr(ir_unop_i2u, r0339);
      body.emit(assign(r0335, add(r0337, r033A), 0x01));

      body.emit(assign(r022D, r0335, 0x01));

      body.emit(assign(r022B, add(r022B, body.constant(int(-1))), 0x01));

      /* IF CONDITION */
      ir_expression *const r033C = less(r0335, body.constant(2097152u));
      ir_if *f033B = new(mem_ctx) ir_if(operand(r033C).val);
      exec_list *const f033B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f033B->then_instructions;

         ir_variable *const r033D = body.make_temp(glsl_type::int_type, "zExp");
         body.emit(assign(r033D, r022B, 0x01));

         ir_variable *const r033E = body.make_temp(glsl_type::uint_type, "zFrac0");
         body.emit(assign(r033E, r0335, 0x01));

         ir_variable *const r033F = body.make_temp(glsl_type::uint_type, "zFrac1");
         body.emit(assign(r033F, r0336, 0x01));

         ir_variable *const r0340 = body.make_temp(glsl_type::uint_type, "zFrac2");
         body.emit(assign(r0340, r022C, 0x01));

         ir_variable *const r0341 = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r0341, body.constant(true), 0x01));

         ir_variable *const r0342 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r0343 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
         body.emit(r0343);
         ir_expression *const r0344 = expr(ir_unop_u2i, r022C);
         body.emit(assign(r0343, less(r0344, body.constant(int(0))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0346 = lequal(body.constant(int(2045)), r022B);
         ir_if *f0345 = new(mem_ctx) ir_if(operand(r0346).val);
         exec_list *const f0345_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0345->then_instructions;

            ir_variable *const r0347 = body.make_temp(glsl_type::bool_type, "or_tmp");
            /* IF CONDITION */
            ir_expression *const r0349 = less(body.constant(int(2045)), r022B);
            ir_if *f0348 = new(mem_ctx) ir_if(operand(r0349).val);
            exec_list *const f0348_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0348->then_instructions;

               body.emit(assign(r0347, body.constant(true), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0348->else_instructions;

               ir_variable *const r034A = body.make_temp(glsl_type::bool_type, "and_tmp");
               /* IF CONDITION */
               ir_expression *const r034C = equal(r022B, body.constant(int(2045)));
               ir_if *f034B = new(mem_ctx) ir_if(operand(r034C).val);
               exec_list *const f034B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f034B->then_instructions;

                  ir_expression *const r034D = equal(body.constant(2097151u), r0335);
                  ir_expression *const r034E = equal(body.constant(4294967295u), r0336);
                  body.emit(assign(r034A, logic_and(r034D, r034E), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f034B->else_instructions;

                  body.emit(assign(r034A, body.constant(false), 0x01));


               body.instructions = f034B_parent_instructions;
               body.emit(f034B);

               /* END IF */

               body.emit(assign(r0347, logic_and(r034A, r0343), 0x01));


            body.instructions = f0348_parent_instructions;
            body.emit(f0348);

            /* END IF */

            /* IF CONDITION */
            ir_if *f034F = new(mem_ctx) ir_if(operand(r0347).val);
            exec_list *const f034F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f034F->then_instructions;

               ir_variable *const r0350 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0350);
               ir_expression *const r0351 = lshift(r0225, body.constant(int(31)));
               body.emit(assign(r0350, add(r0351, body.constant(2146435072u)), 0x02));

               body.emit(assign(r0350, body.constant(0u), 0x01));

               body.emit(assign(r0342, r0350, 0x03));

               body.emit(assign(r0341, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f034F->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0353 = less(r022B, body.constant(int(0)));
               ir_if *f0352 = new(mem_ctx) ir_if(operand(r0353).val);
               exec_list *const f0352_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0352->then_instructions;

                  ir_variable *const r0354 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r0354, r022C, 0x01));

                  ir_variable *const r0355 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r0355, neg(r022B), 0x01));

                  ir_variable *const r0356 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r0356);
                  ir_variable *const r0357 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r0357);
                  ir_variable *const r0358 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r0358);
                  ir_variable *const r0359 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r035A = neg(r0355);
                  body.emit(assign(r0359, bit_and(r035A, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r035C = equal(r0355, body.constant(int(0)));
                  ir_if *f035B = new(mem_ctx) ir_if(operand(r035C).val);
                  exec_list *const f035B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f035B->then_instructions;

                     body.emit(assign(r0356, r022C, 0x01));

                     body.emit(assign(r0357, r0336, 0x01));

                     body.emit(assign(r0358, r0335, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f035B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r035E = less(r0355, body.constant(int(32)));
                     ir_if *f035D = new(mem_ctx) ir_if(operand(r035E).val);
                     exec_list *const f035D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f035D->then_instructions;

                        body.emit(assign(r0356, lshift(r0336, r0359), 0x01));

                        ir_expression *const r035F = lshift(r0335, r0359);
                        ir_expression *const r0360 = rshift(r0336, r0355);
                        body.emit(assign(r0357, bit_or(r035F, r0360), 0x01));

                        body.emit(assign(r0358, rshift(r0335, r0355), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f035D->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0362 = equal(r0355, body.constant(int(32)));
                        ir_if *f0361 = new(mem_ctx) ir_if(operand(r0362).val);
                        exec_list *const f0361_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0361->then_instructions;

                           body.emit(assign(r0356, r0336, 0x01));

                           body.emit(assign(r0357, r0335, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0361->else_instructions;

                           body.emit(assign(r0354, bit_or(r022C, r0336), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0364 = less(r0355, body.constant(int(64)));
                           ir_if *f0363 = new(mem_ctx) ir_if(operand(r0364).val);
                           exec_list *const f0363_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0363->then_instructions;

                              body.emit(assign(r0356, lshift(r0335, r0359), 0x01));

                              ir_expression *const r0365 = bit_and(r0355, body.constant(int(31)));
                              body.emit(assign(r0357, rshift(r0335, r0365), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0363->else_instructions;

                              ir_variable *const r0366 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0368 = equal(r0355, body.constant(int(64)));
                              ir_if *f0367 = new(mem_ctx) ir_if(operand(r0368).val);
                              exec_list *const f0367_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0367->then_instructions;

                                 body.emit(assign(r0366, r0335, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0367->else_instructions;

                                 ir_expression *const r0369 = nequal(r0335, body.constant(0u));
                                 ir_expression *const r036A = expr(ir_unop_b2i, r0369);
                                 body.emit(assign(r0366, expr(ir_unop_i2u, r036A), 0x01));


                              body.instructions = f0367_parent_instructions;
                              body.emit(f0367);

                              /* END IF */

                              body.emit(assign(r0356, r0366, 0x01));

                              body.emit(assign(r0357, body.constant(0u), 0x01));


                           body.instructions = f0363_parent_instructions;
                           body.emit(f0363);

                           /* END IF */


                        body.instructions = f0361_parent_instructions;
                        body.emit(f0361);

                        /* END IF */

                        body.emit(assign(r0358, body.constant(0u), 0x01));


                     body.instructions = f035D_parent_instructions;
                     body.emit(f035D);

                     /* END IF */

                     ir_expression *const r036B = nequal(r0354, body.constant(0u));
                     ir_expression *const r036C = expr(ir_unop_b2i, r036B);
                     ir_expression *const r036D = expr(ir_unop_i2u, r036C);
                     body.emit(assign(r0356, bit_or(r0356, r036D), 0x01));


                  body.instructions = f035B_parent_instructions;
                  body.emit(f035B);

                  /* END IF */

                  body.emit(assign(r033E, r0358, 0x01));

                  body.emit(assign(r033F, r0357, 0x01));

                  body.emit(assign(r0340, r0356, 0x01));

                  body.emit(assign(r033D, body.constant(int(0)), 0x01));

                  body.emit(assign(r0343, less(r0356, body.constant(0u)), 0x01));


               body.instructions = f0352_parent_instructions;
               body.emit(f0352);

               /* END IF */


            body.instructions = f034F_parent_instructions;
            body.emit(f034F);

            /* END IF */


         body.instructions = f0345_parent_instructions;
         body.emit(f0345);

         /* END IF */

         /* IF CONDITION */
         ir_if *f036E = new(mem_ctx) ir_if(operand(r0341).val);
         exec_list *const f036E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f036E->then_instructions;

            /* IF CONDITION */
            ir_if *f036F = new(mem_ctx) ir_if(operand(r0343).val);
            exec_list *const f036F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f036F->then_instructions;

               ir_variable *const r0370 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0370, add(r033F, body.constant(1u)), 0x01));

               ir_expression *const r0371 = less(r0370, r033F);
               ir_expression *const r0372 = expr(ir_unop_b2i, r0371);
               ir_expression *const r0373 = expr(ir_unop_i2u, r0372);
               body.emit(assign(r033E, add(r033E, r0373), 0x01));

               ir_expression *const r0374 = equal(r0340, body.constant(0u));
               ir_expression *const r0375 = expr(ir_unop_b2i, r0374);
               ir_expression *const r0376 = expr(ir_unop_i2u, r0375);
               ir_expression *const r0377 = add(r0340, r0376);
               ir_expression *const r0378 = bit_and(r0377, body.constant(1u));
               ir_expression *const r0379 = expr(ir_unop_bit_not, r0378);
               body.emit(assign(r033F, bit_and(r0370, r0379), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f036F->else_instructions;

               /* IF CONDITION */
               ir_expression *const r037B = bit_or(r033E, r033F);
               ir_expression *const r037C = equal(r037B, body.constant(0u));
               ir_if *f037A = new(mem_ctx) ir_if(operand(r037C).val);
               exec_list *const f037A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f037A->then_instructions;

                  body.emit(assign(r033D, body.constant(int(0)), 0x01));


               body.instructions = f037A_parent_instructions;
               body.emit(f037A);

               /* END IF */


            body.instructions = f036F_parent_instructions;
            body.emit(f036F);

            /* END IF */

            ir_variable *const r037D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r037D);
            ir_expression *const r037E = lshift(r0225, body.constant(int(31)));
            ir_expression *const r037F = expr(ir_unop_i2u, r033D);
            ir_expression *const r0380 = lshift(r037F, body.constant(int(20)));
            ir_expression *const r0381 = add(r037E, r0380);
            body.emit(assign(r037D, add(r0381, r033E), 0x02));

            body.emit(assign(r037D, r033F, 0x01));

            body.emit(assign(r0342, r037D, 0x03));

            body.emit(assign(r0341, body.constant(false), 0x01));


         body.instructions = f036E_parent_instructions;
         body.emit(f036E);

         /* END IF */

         body.emit(assign(r0227, r0342, 0x03));

         body.emit(assign(r0226, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f033B->else_instructions;

         body.emit(assign(r022B, add(r022B, body.constant(int(1))), 0x01));

         ir_variable *const r0382 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
         body.emit(r0382);
         ir_variable *const r0383 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r0383);
         ir_variable *const r0384 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r0384);
         body.emit(assign(r0382, lshift(r0336, body.constant(int(31))), 0x01));

         ir_expression *const r0385 = lshift(r0335, body.constant(int(31)));
         ir_expression *const r0386 = rshift(r0336, body.constant(int(1)));
         body.emit(assign(r0383, bit_or(r0385, r0386), 0x01));

         body.emit(assign(r0384, rshift(r0335, body.constant(int(1))), 0x01));

         ir_expression *const r0387 = nequal(r022C, body.constant(0u));
         ir_expression *const r0388 = expr(ir_unop_b2i, r0387);
         ir_expression *const r0389 = expr(ir_unop_i2u, r0388);
         body.emit(assign(r0382, bit_or(r0382, r0389), 0x01));

         body.emit(assign(r022D, r0384, 0x01));

         body.emit(assign(r022C, r0382, 0x01));

         ir_variable *const r038A = body.make_temp(glsl_type::int_type, "zExp");
         body.emit(assign(r038A, r022B, 0x01));

         ir_variable *const r038B = body.make_temp(glsl_type::uint_type, "zFrac0");
         body.emit(assign(r038B, r0384, 0x01));

         ir_variable *const r038C = body.make_temp(glsl_type::uint_type, "zFrac1");
         body.emit(assign(r038C, r0383, 0x01));

         ir_variable *const r038D = body.make_temp(glsl_type::uint_type, "zFrac2");
         body.emit(assign(r038D, r0382, 0x01));

         ir_variable *const r038E = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r038E, body.constant(true), 0x01));

         ir_variable *const r038F = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r0390 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
         body.emit(r0390);
         ir_expression *const r0391 = expr(ir_unop_u2i, r0382);
         body.emit(assign(r0390, less(r0391, body.constant(int(0))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0393 = lequal(body.constant(int(2045)), r022B);
         ir_if *f0392 = new(mem_ctx) ir_if(operand(r0393).val);
         exec_list *const f0392_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0392->then_instructions;

            ir_variable *const r0394 = body.make_temp(glsl_type::bool_type, "or_tmp");
            /* IF CONDITION */
            ir_expression *const r0396 = less(body.constant(int(2045)), r022B);
            ir_if *f0395 = new(mem_ctx) ir_if(operand(r0396).val);
            exec_list *const f0395_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0395->then_instructions;

               body.emit(assign(r0394, body.constant(true), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0395->else_instructions;

               ir_variable *const r0397 = body.make_temp(glsl_type::bool_type, "and_tmp");
               /* IF CONDITION */
               ir_expression *const r0399 = equal(r022B, body.constant(int(2045)));
               ir_if *f0398 = new(mem_ctx) ir_if(operand(r0399).val);
               exec_list *const f0398_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0398->then_instructions;

                  ir_expression *const r039A = equal(body.constant(2097151u), r0384);
                  ir_expression *const r039B = equal(body.constant(4294967295u), r0383);
                  body.emit(assign(r0397, logic_and(r039A, r039B), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0398->else_instructions;

                  body.emit(assign(r0397, body.constant(false), 0x01));


               body.instructions = f0398_parent_instructions;
               body.emit(f0398);

               /* END IF */

               body.emit(assign(r0394, logic_and(r0397, r0390), 0x01));


            body.instructions = f0395_parent_instructions;
            body.emit(f0395);

            /* END IF */

            /* IF CONDITION */
            ir_if *f039C = new(mem_ctx) ir_if(operand(r0394).val);
            exec_list *const f039C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f039C->then_instructions;

               ir_variable *const r039D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r039D);
               ir_expression *const r039E = lshift(r0225, body.constant(int(31)));
               body.emit(assign(r039D, add(r039E, body.constant(2146435072u)), 0x02));

               body.emit(assign(r039D, body.constant(0u), 0x01));

               body.emit(assign(r038F, r039D, 0x03));

               body.emit(assign(r038E, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f039C->else_instructions;

               /* IF CONDITION */
               ir_expression *const r03A0 = less(r022B, body.constant(int(0)));
               ir_if *f039F = new(mem_ctx) ir_if(operand(r03A0).val);
               exec_list *const f039F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f039F->then_instructions;

                  ir_variable *const r03A1 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r03A1, r0382, 0x01));

                  ir_variable *const r03A2 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r03A2, neg(r022B), 0x01));

                  ir_variable *const r03A3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r03A3);
                  ir_variable *const r03A4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r03A4);
                  ir_variable *const r03A5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r03A5);
                  ir_variable *const r03A6 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r03A7 = neg(r03A2);
                  body.emit(assign(r03A6, bit_and(r03A7, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r03A9 = equal(r03A2, body.constant(int(0)));
                  ir_if *f03A8 = new(mem_ctx) ir_if(operand(r03A9).val);
                  exec_list *const f03A8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f03A8->then_instructions;

                     body.emit(assign(r03A3, r0382, 0x01));

                     body.emit(assign(r03A4, r0383, 0x01));

                     body.emit(assign(r03A5, r0384, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f03A8->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r03AB = less(r03A2, body.constant(int(32)));
                     ir_if *f03AA = new(mem_ctx) ir_if(operand(r03AB).val);
                     exec_list *const f03AA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f03AA->then_instructions;

                        body.emit(assign(r03A3, lshift(r0383, r03A6), 0x01));

                        ir_expression *const r03AC = lshift(r0384, r03A6);
                        ir_expression *const r03AD = rshift(r0383, r03A2);
                        body.emit(assign(r03A4, bit_or(r03AC, r03AD), 0x01));

                        body.emit(assign(r03A5, rshift(r0384, r03A2), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f03AA->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r03AF = equal(r03A2, body.constant(int(32)));
                        ir_if *f03AE = new(mem_ctx) ir_if(operand(r03AF).val);
                        exec_list *const f03AE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f03AE->then_instructions;

                           body.emit(assign(r03A3, r0383, 0x01));

                           body.emit(assign(r03A4, r0384, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f03AE->else_instructions;

                           body.emit(assign(r03A1, bit_or(r0382, r0383), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r03B1 = less(r03A2, body.constant(int(64)));
                           ir_if *f03B0 = new(mem_ctx) ir_if(operand(r03B1).val);
                           exec_list *const f03B0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f03B0->then_instructions;

                              body.emit(assign(r03A3, lshift(r0384, r03A6), 0x01));

                              ir_expression *const r03B2 = bit_and(r03A2, body.constant(int(31)));
                              body.emit(assign(r03A4, rshift(r0384, r03B2), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f03B0->else_instructions;

                              ir_variable *const r03B3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r03B5 = equal(r03A2, body.constant(int(64)));
                              ir_if *f03B4 = new(mem_ctx) ir_if(operand(r03B5).val);
                              exec_list *const f03B4_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f03B4->then_instructions;

                                 body.emit(assign(r03B3, r0384, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f03B4->else_instructions;

                                 ir_expression *const r03B6 = nequal(r0384, body.constant(0u));
                                 ir_expression *const r03B7 = expr(ir_unop_b2i, r03B6);
                                 body.emit(assign(r03B3, expr(ir_unop_i2u, r03B7), 0x01));


                              body.instructions = f03B4_parent_instructions;
                              body.emit(f03B4);

                              /* END IF */

                              body.emit(assign(r03A3, r03B3, 0x01));

                              body.emit(assign(r03A4, body.constant(0u), 0x01));


                           body.instructions = f03B0_parent_instructions;
                           body.emit(f03B0);

                           /* END IF */


                        body.instructions = f03AE_parent_instructions;
                        body.emit(f03AE);

                        /* END IF */

                        body.emit(assign(r03A5, body.constant(0u), 0x01));


                     body.instructions = f03AA_parent_instructions;
                     body.emit(f03AA);

                     /* END IF */

                     ir_expression *const r03B8 = nequal(r03A1, body.constant(0u));
                     ir_expression *const r03B9 = expr(ir_unop_b2i, r03B8);
                     ir_expression *const r03BA = expr(ir_unop_i2u, r03B9);
                     body.emit(assign(r03A3, bit_or(r03A3, r03BA), 0x01));


                  body.instructions = f03A8_parent_instructions;
                  body.emit(f03A8);

                  /* END IF */

                  body.emit(assign(r038B, r03A5, 0x01));

                  body.emit(assign(r038C, r03A4, 0x01));

                  body.emit(assign(r038D, r03A3, 0x01));

                  body.emit(assign(r038A, body.constant(int(0)), 0x01));

                  body.emit(assign(r0390, less(r03A3, body.constant(0u)), 0x01));


               body.instructions = f039F_parent_instructions;
               body.emit(f039F);

               /* END IF */


            body.instructions = f039C_parent_instructions;
            body.emit(f039C);

            /* END IF */


         body.instructions = f0392_parent_instructions;
         body.emit(f0392);

         /* END IF */

         /* IF CONDITION */
         ir_if *f03BB = new(mem_ctx) ir_if(operand(r038E).val);
         exec_list *const f03BB_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f03BB->then_instructions;

            /* IF CONDITION */
            ir_if *f03BC = new(mem_ctx) ir_if(operand(r0390).val);
            exec_list *const f03BC_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f03BC->then_instructions;

               ir_variable *const r03BD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r03BD, add(r038C, body.constant(1u)), 0x01));

               ir_expression *const r03BE = less(r03BD, r038C);
               ir_expression *const r03BF = expr(ir_unop_b2i, r03BE);
               ir_expression *const r03C0 = expr(ir_unop_i2u, r03BF);
               body.emit(assign(r038B, add(r038B, r03C0), 0x01));

               ir_expression *const r03C1 = equal(r038D, body.constant(0u));
               ir_expression *const r03C2 = expr(ir_unop_b2i, r03C1);
               ir_expression *const r03C3 = expr(ir_unop_i2u, r03C2);
               ir_expression *const r03C4 = add(r038D, r03C3);
               ir_expression *const r03C5 = bit_and(r03C4, body.constant(1u));
               ir_expression *const r03C6 = expr(ir_unop_bit_not, r03C5);
               body.emit(assign(r038C, bit_and(r03BD, r03C6), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f03BC->else_instructions;

               /* IF CONDITION */
               ir_expression *const r03C8 = bit_or(r038B, r038C);
               ir_expression *const r03C9 = equal(r03C8, body.constant(0u));
               ir_if *f03C7 = new(mem_ctx) ir_if(operand(r03C9).val);
               exec_list *const f03C7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f03C7->then_instructions;

                  body.emit(assign(r038A, body.constant(int(0)), 0x01));


               body.instructions = f03C7_parent_instructions;
               body.emit(f03C7);

               /* END IF */


            body.instructions = f03BC_parent_instructions;
            body.emit(f03BC);

            /* END IF */

            ir_variable *const r03CA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r03CA);
            ir_expression *const r03CB = lshift(r0225, body.constant(int(31)));
            ir_expression *const r03CC = expr(ir_unop_i2u, r038A);
            ir_expression *const r03CD = lshift(r03CC, body.constant(int(20)));
            ir_expression *const r03CE = add(r03CB, r03CD);
            body.emit(assign(r03CA, add(r03CE, r038B), 0x02));

            body.emit(assign(r03CA, r038C, 0x01));

            body.emit(assign(r038F, r03CA, 0x03));

            body.emit(assign(r038E, body.constant(false), 0x01));


         body.instructions = f03BB_parent_instructions;
         body.emit(f03BB);

         /* END IF */

         body.emit(assign(r0227, r038F, 0x03));

         body.emit(assign(r0226, body.constant(false), 0x01));


      body.instructions = f033B_parent_instructions;
      body.emit(f033B);

      /* END IF */


   body.instructions = f0334_parent_instructions;
   body.emit(f0334);

   /* END IF */

   body.emit(ret(r0227));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
subFloat64Fracs(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r03CF = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r03CF);
   ir_variable *const r03D0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r03D0);
   ir_variable *const r03D1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r03D1);
   ir_variable *const r03D2 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r03D3 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
   body.emit(r03D3);
   ir_variable *const r03D4 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
   body.emit(r03D4);
   ir_variable *const r03D5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
   body.emit(r03D5);
   ir_variable *const r03D6 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r03D6);
   ir_variable *const r03D7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
   body.emit(r03D7);
   ir_variable *const r03D8 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r03D8);
   ir_variable *const r03D9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r03D9);
   body.emit(assign(r03D9, bit_and(swizzle_y(r03CF), body.constant(1048575u)), 0x02));

   body.emit(assign(r03D9, swizzle_x(r03CF), 0x01));

   ir_variable *const r03DA = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r03DB = rshift(swizzle_y(r03CF), body.constant(int(20)));
   ir_expression *const r03DC = bit_and(r03DB, body.constant(2047u));
   body.emit(assign(r03DA, expr(ir_unop_u2i, r03DC), 0x01));

   body.emit(assign(r03D6, r03DA, 0x01));

   ir_variable *const r03DD = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r03DD);
   body.emit(assign(r03DD, bit_and(swizzle_y(r03D0), body.constant(1048575u)), 0x02));

   body.emit(assign(r03DD, swizzle_x(r03D0), 0x01));

   ir_variable *const r03DE = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r03DF = rshift(swizzle_y(r03D0), body.constant(int(20)));
   ir_expression *const r03E0 = bit_and(r03DF, body.constant(2047u));
   body.emit(assign(r03DE, expr(ir_unop_u2i, r03E0), 0x01));

   body.emit(assign(r03D4, r03DE, 0x01));

   body.emit(assign(r03D3, sub(r03DA, r03DE), 0x01));

   ir_variable *const r03E1 = body.make_temp(glsl_type::uint_type, "z1Ptr");
   body.emit(assign(r03E1, lshift(swizzle_x(r03CF), body.constant(int(10))), 0x01));

   ir_variable *const r03E2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
   ir_expression *const r03E3 = lshift(swizzle_y(r03D9), body.constant(int(10)));
   ir_expression *const r03E4 = rshift(swizzle_x(r03CF), body.constant(int(22)));
   body.emit(assign(r03E2, bit_or(r03E3, r03E4), 0x01));

   body.emit(assign(r03D7, r03E2, 0x02));

   body.emit(assign(r03D7, r03E1, 0x01));

   ir_variable *const r03E5 = body.make_temp(glsl_type::uint_type, "z1Ptr");
   body.emit(assign(r03E5, lshift(swizzle_x(r03D0), body.constant(int(10))), 0x01));

   ir_variable *const r03E6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
   ir_expression *const r03E7 = lshift(swizzle_y(r03DD), body.constant(int(10)));
   ir_expression *const r03E8 = rshift(swizzle_x(r03D0), body.constant(int(22)));
   body.emit(assign(r03E6, bit_or(r03E7, r03E8), 0x01));

   body.emit(assign(r03D5, r03E6, 0x02));

   body.emit(assign(r03D5, r03E5, 0x01));

   /* IF CONDITION */
   ir_expression *const r03EA = less(body.constant(int(0)), r03D3);
   ir_if *f03E9 = new(mem_ctx) ir_if(operand(r03EA).val);
   exec_list *const f03E9_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f03E9->then_instructions;

      /* IF CONDITION */
      ir_expression *const r03EC = equal(r03DA, body.constant(int(2047)));
      ir_if *f03EB = new(mem_ctx) ir_if(operand(r03EC).val);
      exec_list *const f03EB_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f03EB->then_instructions;

         /* IF CONDITION */
         ir_expression *const r03EE = bit_or(r03E2, r03E1);
         ir_expression *const r03EF = nequal(r03EE, body.constant(0u));
         ir_if *f03ED = new(mem_ctx) ir_if(operand(r03EF).val);
         exec_list *const f03ED_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f03ED->then_instructions;

            ir_variable *const r03F0 = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r03F0, swizzle_x(r03CF), 0x01));

            ir_variable *const r03F1 = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r03F1, swizzle_x(r03D0), 0x01));

            ir_variable *const r03F2 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r03F3 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r03F4 = rshift(swizzle_y(r03CF), body.constant(int(19)));
            ir_expression *const r03F5 = bit_and(r03F4, body.constant(4095u));
            ir_expression *const r03F6 = equal(r03F5, body.constant(4094u));
            ir_expression *const r03F7 = nequal(swizzle_x(r03CF), body.constant(0u));
            ir_expression *const r03F8 = bit_and(swizzle_y(r03CF), body.constant(524287u));
            ir_expression *const r03F9 = nequal(r03F8, body.constant(0u));
            ir_expression *const r03FA = logic_or(r03F7, r03F9);
            body.emit(assign(r03F3, logic_and(r03F6, r03FA), 0x01));

            ir_variable *const r03FB = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r03FC = lshift(swizzle_y(r03D0), body.constant(int(1)));
            ir_expression *const r03FD = lequal(body.constant(4292870144u), r03FC);
            ir_expression *const r03FE = nequal(swizzle_x(r03D0), body.constant(0u));
            ir_expression *const r03FF = bit_and(swizzle_y(r03D0), body.constant(1048575u));
            ir_expression *const r0400 = nequal(r03FF, body.constant(0u));
            ir_expression *const r0401 = logic_or(r03FE, r0400);
            body.emit(assign(r03FB, logic_and(r03FD, r0401), 0x01));

            body.emit(assign(r03F0, bit_or(swizzle_y(r03CF), body.constant(524288u)), 0x02));

            body.emit(assign(r03F1, bit_or(swizzle_y(r03D0), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r0403 = lshift(swizzle_y(r03CF), body.constant(int(1)));
            ir_expression *const r0404 = lequal(body.constant(4292870144u), r0403);
            ir_expression *const r0405 = nequal(swizzle_x(r03CF), body.constant(0u));
            ir_expression *const r0406 = bit_and(swizzle_y(r03CF), body.constant(1048575u));
            ir_expression *const r0407 = nequal(r0406, body.constant(0u));
            ir_expression *const r0408 = logic_or(r0405, r0407);
            ir_expression *const r0409 = logic_and(r0404, r0408);
            ir_if *f0402 = new(mem_ctx) ir_if(operand(r0409).val);
            exec_list *const f0402_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0402->then_instructions;

               ir_variable *const r040A = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r040C = logic_and(r03F3, r03FB);
               ir_if *f040B = new(mem_ctx) ir_if(operand(r040C).val);
               exec_list *const f040B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f040B->then_instructions;

                  body.emit(assign(r040A, r03F1, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f040B->else_instructions;

                  body.emit(assign(r040A, r03F0, 0x03));


               body.instructions = f040B_parent_instructions;
               body.emit(f040B);

               /* END IF */

               body.emit(assign(r03F2, r040A, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0402->else_instructions;

               body.emit(assign(r03F2, r03F1, 0x03));


            body.instructions = f0402_parent_instructions;
            body.emit(f0402);

            /* END IF */

            body.emit(assign(r03D2, r03F2, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f03ED->else_instructions;

            body.emit(assign(r03D2, r03CF, 0x03));


         body.instructions = f03ED_parent_instructions;
         body.emit(f03ED);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f03EB->else_instructions;

         /* IF CONDITION */
         ir_expression *const r040E = equal(r03DE, body.constant(int(0)));
         ir_if *f040D = new(mem_ctx) ir_if(operand(r040E).val);
         exec_list *const f040D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f040D->then_instructions;

            body.emit(assign(r03D3, add(r03D3, body.constant(int(-1))), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f040D->else_instructions;

            body.emit(assign(r03D5, bit_or(r03E6, body.constant(1073741824u)), 0x02));


         body.instructions = f040D_parent_instructions;
         body.emit(f040D);

         /* END IF */

         ir_variable *const r040F = body.make_temp(glsl_type::uint_type, "a0");
         body.emit(assign(r040F, swizzle_y(r03D5), 0x01));

         ir_variable *const r0410 = body.make_temp(glsl_type::uint_type, "a1");
         body.emit(assign(r0410, swizzle_x(r03D5), 0x01));

         ir_variable *const r0411 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r0411);
         ir_variable *const r0412 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r0412);
         ir_variable *const r0413 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         ir_expression *const r0414 = neg(r03D3);
         body.emit(assign(r0413, bit_and(r0414, body.constant(int(31))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0416 = equal(r03D3, body.constant(int(0)));
         ir_if *f0415 = new(mem_ctx) ir_if(operand(r0416).val);
         exec_list *const f0415_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0415->then_instructions;

            body.emit(assign(r0411, r0410, 0x01));

            body.emit(assign(r0412, r040F, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0415->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0418 = less(r03D3, body.constant(int(32)));
            ir_if *f0417 = new(mem_ctx) ir_if(operand(r0418).val);
            exec_list *const f0417_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0417->then_instructions;

               ir_expression *const r0419 = lshift(swizzle_y(r03D5), r0413);
               ir_expression *const r041A = rshift(r03E5, r03D3);
               ir_expression *const r041B = bit_or(r0419, r041A);
               ir_expression *const r041C = lshift(r03E5, r0413);
               ir_expression *const r041D = nequal(r041C, body.constant(0u));
               ir_expression *const r041E = expr(ir_unop_b2i, r041D);
               ir_expression *const r041F = expr(ir_unop_i2u, r041E);
               body.emit(assign(r0411, bit_or(r041B, r041F), 0x01));

               body.emit(assign(r0412, rshift(swizzle_y(r03D5), r03D3), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0417->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0421 = equal(r03D3, body.constant(int(32)));
               ir_if *f0420 = new(mem_ctx) ir_if(operand(r0421).val);
               exec_list *const f0420_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0420->then_instructions;

                  ir_expression *const r0422 = nequal(r03E5, body.constant(0u));
                  ir_expression *const r0423 = expr(ir_unop_b2i, r0422);
                  ir_expression *const r0424 = expr(ir_unop_i2u, r0423);
                  body.emit(assign(r0411, bit_or(swizzle_y(r03D5), r0424), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0420->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0426 = less(r03D3, body.constant(int(64)));
                  ir_if *f0425 = new(mem_ctx) ir_if(operand(r0426).val);
                  exec_list *const f0425_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0425->then_instructions;

                     ir_expression *const r0427 = bit_and(r03D3, body.constant(int(31)));
                     ir_expression *const r0428 = rshift(swizzle_y(r03D5), r0427);
                     ir_expression *const r0429 = lshift(swizzle_y(r03D5), r0413);
                     ir_expression *const r042A = bit_or(r0429, r03E5);
                     ir_expression *const r042B = nequal(r042A, body.constant(0u));
                     ir_expression *const r042C = expr(ir_unop_b2i, r042B);
                     ir_expression *const r042D = expr(ir_unop_i2u, r042C);
                     body.emit(assign(r0411, bit_or(r0428, r042D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0425->else_instructions;

                     ir_expression *const r042E = bit_or(swizzle_y(r03D5), r03E5);
                     ir_expression *const r042F = nequal(r042E, body.constant(0u));
                     ir_expression *const r0430 = expr(ir_unop_b2i, r042F);
                     body.emit(assign(r0411, expr(ir_unop_i2u, r0430), 0x01));


                  body.instructions = f0425_parent_instructions;
                  body.emit(f0425);

                  /* END IF */


               body.instructions = f0420_parent_instructions;
               body.emit(f0420);

               /* END IF */

               body.emit(assign(r0412, body.constant(0u), 0x01));


            body.instructions = f0417_parent_instructions;
            body.emit(f0417);

            /* END IF */


         body.instructions = f0415_parent_instructions;
         body.emit(f0415);

         /* END IF */

         body.emit(assign(r03D5, r0412, 0x02));

         body.emit(assign(r03D5, r0411, 0x01));

         body.emit(assign(r03D7, bit_or(r03E2, body.constant(1073741824u)), 0x02));

         ir_variable *const r0431 = body.make_temp(glsl_type::uint_type, "z0Ptr");
         ir_variable *const r0432 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r0432, sub(r03E1, r0411), 0x01));

         ir_expression *const r0433 = sub(swizzle_y(r03D7), r0412);
         ir_expression *const r0434 = less(r03E1, r0411);
         ir_expression *const r0435 = expr(ir_unop_b2i, r0434);
         ir_expression *const r0436 = expr(ir_unop_i2u, r0435);
         body.emit(assign(r0431, sub(r0433, r0436), 0x01));

         body.emit(assign(r03D8, add(r03DA, body.constant(int(-1))), 0x01));

         ir_variable *const r0437 = body.make_temp(glsl_type::int_type, "zExp");
         body.emit(assign(r0437, add(r03D8, body.constant(int(-10))), 0x01));

         ir_variable *const r0438 = body.make_temp(glsl_type::uint_type, "zFrac0");
         body.emit(assign(r0438, r0431, 0x01));

         ir_variable *const r0439 = body.make_temp(glsl_type::uint_type, "zFrac1");
         body.emit(assign(r0439, r0432, 0x01));

         ir_variable *const r043A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
         body.emit(r043A);
         ir_variable *const r043B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
         body.emit(r043B);
         /* IF CONDITION */
         ir_expression *const r043D = equal(r0431, body.constant(0u));
         ir_if *f043C = new(mem_ctx) ir_if(operand(r043D).val);
         exec_list *const f043C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f043C->then_instructions;

            body.emit(assign(r0438, r0432, 0x01));

            body.emit(assign(r0439, body.constant(0u), 0x01));

            body.emit(assign(r0437, add(r0437, body.constant(int(-32))), 0x01));


         body.instructions = f043C_parent_instructions;
         body.emit(f043C);

         /* END IF */

         ir_variable *const r043E = body.make_temp(glsl_type::uint_type, "a");
         body.emit(assign(r043E, r0438, 0x01));

         ir_variable *const r043F = body.make_temp(glsl_type::int_type, "return_value");
         ir_variable *const r0440 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
         body.emit(r0440);
         /* IF CONDITION */
         ir_expression *const r0442 = equal(r0438, body.constant(0u));
         ir_if *f0441 = new(mem_ctx) ir_if(operand(r0442).val);
         exec_list *const f0441_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0441->then_instructions;

            body.emit(assign(r043F, body.constant(int(32)), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0441->else_instructions;

            body.emit(assign(r0440, body.constant(int(0)), 0x01));

            /* IF CONDITION */
            ir_expression *const r0444 = bit_and(r0438, body.constant(4294901760u));
            ir_expression *const r0445 = equal(r0444, body.constant(0u));
            ir_if *f0443 = new(mem_ctx) ir_if(operand(r0445).val);
            exec_list *const f0443_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0443->then_instructions;

               body.emit(assign(r0440, body.constant(int(16)), 0x01));

               body.emit(assign(r043E, lshift(r0438, body.constant(int(16))), 0x01));


            body.instructions = f0443_parent_instructions;
            body.emit(f0443);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r0447 = bit_and(r043E, body.constant(4278190080u));
            ir_expression *const r0448 = equal(r0447, body.constant(0u));
            ir_if *f0446 = new(mem_ctx) ir_if(operand(r0448).val);
            exec_list *const f0446_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0446->then_instructions;

               body.emit(assign(r0440, add(r0440, body.constant(int(8))), 0x01));

               body.emit(assign(r043E, lshift(r043E, body.constant(int(8))), 0x01));


            body.instructions = f0446_parent_instructions;
            body.emit(f0446);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r044A = bit_and(r043E, body.constant(4026531840u));
            ir_expression *const r044B = equal(r044A, body.constant(0u));
            ir_if *f0449 = new(mem_ctx) ir_if(operand(r044B).val);
            exec_list *const f0449_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0449->then_instructions;

               body.emit(assign(r0440, add(r0440, body.constant(int(4))), 0x01));

               body.emit(assign(r043E, lshift(r043E, body.constant(int(4))), 0x01));


            body.instructions = f0449_parent_instructions;
            body.emit(f0449);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r044D = bit_and(r043E, body.constant(3221225472u));
            ir_expression *const r044E = equal(r044D, body.constant(0u));
            ir_if *f044C = new(mem_ctx) ir_if(operand(r044E).val);
            exec_list *const f044C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f044C->then_instructions;

               body.emit(assign(r0440, add(r0440, body.constant(int(2))), 0x01));

               body.emit(assign(r043E, lshift(r043E, body.constant(int(2))), 0x01));


            body.instructions = f044C_parent_instructions;
            body.emit(f044C);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r0450 = bit_and(r043E, body.constant(2147483648u));
            ir_expression *const r0451 = equal(r0450, body.constant(0u));
            ir_if *f044F = new(mem_ctx) ir_if(operand(r0451).val);
            exec_list *const f044F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f044F->then_instructions;

               body.emit(assign(r0440, add(r0440, body.constant(int(1))), 0x01));


            body.instructions = f044F_parent_instructions;
            body.emit(f044F);

            /* END IF */

            body.emit(assign(r043F, r0440, 0x01));


         body.instructions = f0441_parent_instructions;
         body.emit(f0441);

         /* END IF */

         body.emit(assign(r043B, add(r043F, body.constant(int(-11))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0453 = lequal(body.constant(int(0)), r043B);
         ir_if *f0452 = new(mem_ctx) ir_if(operand(r0453).val);
         exec_list *const f0452_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0452->then_instructions;

            body.emit(assign(r043A, body.constant(0u), 0x01));

            ir_variable *const r0454 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r0454, lshift(r0439, r043B), 0x01));

            ir_variable *const r0455 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r0457 = equal(r043B, body.constant(int(0)));
            ir_if *f0456 = new(mem_ctx) ir_if(operand(r0457).val);
            exec_list *const f0456_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0456->then_instructions;

               body.emit(assign(r0455, r0438, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0456->else_instructions;

               ir_expression *const r0458 = lshift(r0438, r043B);
               ir_expression *const r0459 = neg(r043B);
               ir_expression *const r045A = bit_and(r0459, body.constant(int(31)));
               ir_expression *const r045B = rshift(r0439, r045A);
               body.emit(assign(r0455, bit_or(r0458, r045B), 0x01));


            body.instructions = f0456_parent_instructions;
            body.emit(f0456);

            /* END IF */

            body.emit(assign(r0438, r0455, 0x01));

            body.emit(assign(r0439, r0454, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0452->else_instructions;

            ir_variable *const r045C = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r045C, body.constant(0u), 0x01));

            ir_variable *const r045D = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r045D, neg(r043B), 0x01));

            ir_variable *const r045E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r045E);
            ir_variable *const r045F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r045F);
            ir_variable *const r0460 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r0460);
            ir_variable *const r0461 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r0462 = neg(r045D);
            body.emit(assign(r0461, bit_and(r0462, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0464 = equal(r045D, body.constant(int(0)));
            ir_if *f0463 = new(mem_ctx) ir_if(operand(r0464).val);
            exec_list *const f0463_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0463->then_instructions;

               body.emit(assign(r045E, r045C, 0x01));

               body.emit(assign(r045F, r0439, 0x01));

               body.emit(assign(r0460, r0438, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0463->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0466 = less(r045D, body.constant(int(32)));
               ir_if *f0465 = new(mem_ctx) ir_if(operand(r0466).val);
               exec_list *const f0465_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0465->then_instructions;

                  body.emit(assign(r045E, lshift(r0439, r0461), 0x01));

                  ir_expression *const r0467 = lshift(r0438, r0461);
                  ir_expression *const r0468 = rshift(r0439, r045D);
                  body.emit(assign(r045F, bit_or(r0467, r0468), 0x01));

                  body.emit(assign(r0460, rshift(r0438, r045D), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0465->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r046A = equal(r045D, body.constant(int(32)));
                  ir_if *f0469 = new(mem_ctx) ir_if(operand(r046A).val);
                  exec_list *const f0469_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0469->then_instructions;

                     body.emit(assign(r045E, r0439, 0x01));

                     body.emit(assign(r045F, r0438, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0469->else_instructions;

                     body.emit(assign(r045C, bit_or(body.constant(0u), r0439), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r046C = less(r045D, body.constant(int(64)));
                     ir_if *f046B = new(mem_ctx) ir_if(operand(r046C).val);
                     exec_list *const f046B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f046B->then_instructions;

                        body.emit(assign(r045E, lshift(r0438, r0461), 0x01));

                        ir_expression *const r046D = bit_and(r045D, body.constant(int(31)));
                        body.emit(assign(r045F, rshift(r0438, r046D), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f046B->else_instructions;

                        ir_variable *const r046E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0470 = equal(r045D, body.constant(int(64)));
                        ir_if *f046F = new(mem_ctx) ir_if(operand(r0470).val);
                        exec_list *const f046F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f046F->then_instructions;

                           body.emit(assign(r046E, r0438, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f046F->else_instructions;

                           ir_expression *const r0471 = nequal(r0438, body.constant(0u));
                           ir_expression *const r0472 = expr(ir_unop_b2i, r0471);
                           body.emit(assign(r046E, expr(ir_unop_i2u, r0472), 0x01));


                        body.instructions = f046F_parent_instructions;
                        body.emit(f046F);

                        /* END IF */

                        body.emit(assign(r045E, r046E, 0x01));

                        body.emit(assign(r045F, body.constant(0u), 0x01));


                     body.instructions = f046B_parent_instructions;
                     body.emit(f046B);

                     /* END IF */


                  body.instructions = f0469_parent_instructions;
                  body.emit(f0469);

                  /* END IF */

                  body.emit(assign(r0460, body.constant(0u), 0x01));


               body.instructions = f0465_parent_instructions;
               body.emit(f0465);

               /* END IF */

               ir_expression *const r0473 = nequal(r045C, body.constant(0u));
               ir_expression *const r0474 = expr(ir_unop_b2i, r0473);
               ir_expression *const r0475 = expr(ir_unop_i2u, r0474);
               body.emit(assign(r045E, bit_or(r045E, r0475), 0x01));


            body.instructions = f0463_parent_instructions;
            body.emit(f0463);

            /* END IF */

            body.emit(assign(r0438, r0460, 0x01));

            body.emit(assign(r0439, r045F, 0x01));

            body.emit(assign(r043A, r045E, 0x01));


         body.instructions = f0452_parent_instructions;
         body.emit(f0452);

         /* END IF */

         body.emit(assign(r0437, sub(r0437, r043B), 0x01));

         ir_variable *const r0476 = body.make_temp(glsl_type::int_type, "zExp");
         body.emit(assign(r0476, r0437, 0x01));

         ir_variable *const r0477 = body.make_temp(glsl_type::uint_type, "zFrac0");
         body.emit(assign(r0477, r0438, 0x01));

         ir_variable *const r0478 = body.make_temp(glsl_type::uint_type, "zFrac1");
         body.emit(assign(r0478, r0439, 0x01));

         ir_variable *const r0479 = body.make_temp(glsl_type::uint_type, "zFrac2");
         body.emit(assign(r0479, r043A, 0x01));

         ir_variable *const r047A = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r047A, body.constant(true), 0x01));

         ir_variable *const r047B = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r047C = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
         body.emit(r047C);
         ir_expression *const r047D = expr(ir_unop_u2i, r043A);
         body.emit(assign(r047C, less(r047D, body.constant(int(0))), 0x01));

         /* IF CONDITION */
         ir_expression *const r047F = lequal(body.constant(int(2045)), r0437);
         ir_if *f047E = new(mem_ctx) ir_if(operand(r047F).val);
         exec_list *const f047E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f047E->then_instructions;

            ir_variable *const r0480 = body.make_temp(glsl_type::bool_type, "or_tmp");
            /* IF CONDITION */
            ir_expression *const r0482 = less(body.constant(int(2045)), r0437);
            ir_if *f0481 = new(mem_ctx) ir_if(operand(r0482).val);
            exec_list *const f0481_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0481->then_instructions;

               body.emit(assign(r0480, body.constant(true), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0481->else_instructions;

               ir_variable *const r0483 = body.make_temp(glsl_type::bool_type, "and_tmp");
               /* IF CONDITION */
               ir_expression *const r0485 = equal(r0437, body.constant(int(2045)));
               ir_if *f0484 = new(mem_ctx) ir_if(operand(r0485).val);
               exec_list *const f0484_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0484->then_instructions;

                  ir_expression *const r0486 = equal(body.constant(2097151u), r0438);
                  ir_expression *const r0487 = equal(body.constant(4294967295u), r0439);
                  body.emit(assign(r0483, logic_and(r0486, r0487), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0484->else_instructions;

                  body.emit(assign(r0483, body.constant(false), 0x01));


               body.instructions = f0484_parent_instructions;
               body.emit(f0484);

               /* END IF */

               body.emit(assign(r0480, logic_and(r0483, r047C), 0x01));


            body.instructions = f0481_parent_instructions;
            body.emit(f0481);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0488 = new(mem_ctx) ir_if(operand(r0480).val);
            exec_list *const f0488_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0488->then_instructions;

               ir_variable *const r0489 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0489);
               ir_expression *const r048A = lshift(r03D1, body.constant(int(31)));
               body.emit(assign(r0489, add(r048A, body.constant(2146435072u)), 0x02));

               body.emit(assign(r0489, body.constant(0u), 0x01));

               body.emit(assign(r047B, r0489, 0x03));

               body.emit(assign(r047A, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0488->else_instructions;

               /* IF CONDITION */
               ir_expression *const r048C = less(r0437, body.constant(int(0)));
               ir_if *f048B = new(mem_ctx) ir_if(operand(r048C).val);
               exec_list *const f048B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f048B->then_instructions;

                  ir_variable *const r048D = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r048D, r043A, 0x01));

                  ir_variable *const r048E = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r048E, neg(r0437), 0x01));

                  ir_variable *const r048F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r048F);
                  ir_variable *const r0490 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r0490);
                  ir_variable *const r0491 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r0491);
                  ir_variable *const r0492 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r0493 = neg(r048E);
                  body.emit(assign(r0492, bit_and(r0493, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0495 = equal(r048E, body.constant(int(0)));
                  ir_if *f0494 = new(mem_ctx) ir_if(operand(r0495).val);
                  exec_list *const f0494_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0494->then_instructions;

                     body.emit(assign(r048F, r043A, 0x01));

                     body.emit(assign(r0490, r0439, 0x01));

                     body.emit(assign(r0491, r0438, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0494->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0497 = less(r048E, body.constant(int(32)));
                     ir_if *f0496 = new(mem_ctx) ir_if(operand(r0497).val);
                     exec_list *const f0496_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0496->then_instructions;

                        body.emit(assign(r048F, lshift(r0439, r0492), 0x01));

                        ir_expression *const r0498 = lshift(r0438, r0492);
                        ir_expression *const r0499 = rshift(r0439, r048E);
                        body.emit(assign(r0490, bit_or(r0498, r0499), 0x01));

                        body.emit(assign(r0491, rshift(r0438, r048E), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0496->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r049B = equal(r048E, body.constant(int(32)));
                        ir_if *f049A = new(mem_ctx) ir_if(operand(r049B).val);
                        exec_list *const f049A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f049A->then_instructions;

                           body.emit(assign(r048F, r0439, 0x01));

                           body.emit(assign(r0490, r0438, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f049A->else_instructions;

                           body.emit(assign(r048D, bit_or(r043A, r0439), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r049D = less(r048E, body.constant(int(64)));
                           ir_if *f049C = new(mem_ctx) ir_if(operand(r049D).val);
                           exec_list *const f049C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f049C->then_instructions;

                              body.emit(assign(r048F, lshift(r0438, r0492), 0x01));

                              ir_expression *const r049E = bit_and(r048E, body.constant(int(31)));
                              body.emit(assign(r0490, rshift(r0438, r049E), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f049C->else_instructions;

                              ir_variable *const r049F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r04A1 = equal(r048E, body.constant(int(64)));
                              ir_if *f04A0 = new(mem_ctx) ir_if(operand(r04A1).val);
                              exec_list *const f04A0_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f04A0->then_instructions;

                                 body.emit(assign(r049F, r0438, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f04A0->else_instructions;

                                 ir_expression *const r04A2 = nequal(r0438, body.constant(0u));
                                 ir_expression *const r04A3 = expr(ir_unop_b2i, r04A2);
                                 body.emit(assign(r049F, expr(ir_unop_i2u, r04A3), 0x01));


                              body.instructions = f04A0_parent_instructions;
                              body.emit(f04A0);

                              /* END IF */

                              body.emit(assign(r048F, r049F, 0x01));

                              body.emit(assign(r0490, body.constant(0u), 0x01));


                           body.instructions = f049C_parent_instructions;
                           body.emit(f049C);

                           /* END IF */


                        body.instructions = f049A_parent_instructions;
                        body.emit(f049A);

                        /* END IF */

                        body.emit(assign(r0491, body.constant(0u), 0x01));


                     body.instructions = f0496_parent_instructions;
                     body.emit(f0496);

                     /* END IF */

                     ir_expression *const r04A4 = nequal(r048D, body.constant(0u));
                     ir_expression *const r04A5 = expr(ir_unop_b2i, r04A4);
                     ir_expression *const r04A6 = expr(ir_unop_i2u, r04A5);
                     body.emit(assign(r048F, bit_or(r048F, r04A6), 0x01));


                  body.instructions = f0494_parent_instructions;
                  body.emit(f0494);

                  /* END IF */

                  body.emit(assign(r0477, r0491, 0x01));

                  body.emit(assign(r0478, r0490, 0x01));

                  body.emit(assign(r0479, r048F, 0x01));

                  body.emit(assign(r0476, body.constant(int(0)), 0x01));

                  body.emit(assign(r047C, less(r048F, body.constant(0u)), 0x01));


               body.instructions = f048B_parent_instructions;
               body.emit(f048B);

               /* END IF */


            body.instructions = f0488_parent_instructions;
            body.emit(f0488);

            /* END IF */


         body.instructions = f047E_parent_instructions;
         body.emit(f047E);

         /* END IF */

         /* IF CONDITION */
         ir_if *f04A7 = new(mem_ctx) ir_if(operand(r047A).val);
         exec_list *const f04A7_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f04A7->then_instructions;

            /* IF CONDITION */
            ir_if *f04A8 = new(mem_ctx) ir_if(operand(r047C).val);
            exec_list *const f04A8_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f04A8->then_instructions;

               ir_variable *const r04A9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r04A9, add(r0478, body.constant(1u)), 0x01));

               ir_expression *const r04AA = less(r04A9, r0478);
               ir_expression *const r04AB = expr(ir_unop_b2i, r04AA);
               ir_expression *const r04AC = expr(ir_unop_i2u, r04AB);
               body.emit(assign(r0477, add(r0477, r04AC), 0x01));

               ir_expression *const r04AD = equal(r0479, body.constant(0u));
               ir_expression *const r04AE = expr(ir_unop_b2i, r04AD);
               ir_expression *const r04AF = expr(ir_unop_i2u, r04AE);
               ir_expression *const r04B0 = add(r0479, r04AF);
               ir_expression *const r04B1 = bit_and(r04B0, body.constant(1u));
               ir_expression *const r04B2 = expr(ir_unop_bit_not, r04B1);
               body.emit(assign(r0478, bit_and(r04A9, r04B2), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f04A8->else_instructions;

               /* IF CONDITION */
               ir_expression *const r04B4 = bit_or(r0477, r0478);
               ir_expression *const r04B5 = equal(r04B4, body.constant(0u));
               ir_if *f04B3 = new(mem_ctx) ir_if(operand(r04B5).val);
               exec_list *const f04B3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f04B3->then_instructions;

                  body.emit(assign(r0476, body.constant(int(0)), 0x01));


               body.instructions = f04B3_parent_instructions;
               body.emit(f04B3);

               /* END IF */


            body.instructions = f04A8_parent_instructions;
            body.emit(f04A8);

            /* END IF */

            ir_variable *const r04B6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r04B6);
            ir_expression *const r04B7 = lshift(r03D1, body.constant(int(31)));
            ir_expression *const r04B8 = expr(ir_unop_i2u, r0476);
            ir_expression *const r04B9 = lshift(r04B8, body.constant(int(20)));
            ir_expression *const r04BA = add(r04B7, r04B9);
            body.emit(assign(r04B6, add(r04BA, r0477), 0x02));

            body.emit(assign(r04B6, r0478, 0x01));

            body.emit(assign(r047B, r04B6, 0x03));

            body.emit(assign(r047A, body.constant(false), 0x01));


         body.instructions = f04A7_parent_instructions;
         body.emit(f04A7);

         /* END IF */

         body.emit(assign(r03D2, r047B, 0x03));


      body.instructions = f03EB_parent_instructions;
      body.emit(f03EB);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f03E9->else_instructions;

      /* IF CONDITION */
      ir_expression *const r04BC = less(r03D3, body.constant(int(0)));
      ir_if *f04BB = new(mem_ctx) ir_if(operand(r04BC).val);
      exec_list *const f04BB_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f04BB->then_instructions;

         /* IF CONDITION */
         ir_expression *const r04BE = equal(r03DE, body.constant(int(2047)));
         ir_if *f04BD = new(mem_ctx) ir_if(operand(r04BE).val);
         exec_list *const f04BD_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f04BD->then_instructions;

            /* IF CONDITION */
            ir_expression *const r04C0 = bit_or(swizzle_y(r03D5), swizzle_x(r03D5));
            ir_expression *const r04C1 = nequal(r04C0, body.constant(0u));
            ir_if *f04BF = new(mem_ctx) ir_if(operand(r04C1).val);
            exec_list *const f04BF_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f04BF->then_instructions;

               ir_variable *const r04C2 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r04C2, swizzle_x(r03CF), 0x01));

               ir_variable *const r04C3 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r04C3, swizzle_x(r03D0), 0x01));

               ir_variable *const r04C4 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r04C5 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r04C6 = rshift(swizzle_y(r03CF), body.constant(int(19)));
               ir_expression *const r04C7 = bit_and(r04C6, body.constant(4095u));
               ir_expression *const r04C8 = equal(r04C7, body.constant(4094u));
               ir_expression *const r04C9 = nequal(swizzle_x(r03CF), body.constant(0u));
               ir_expression *const r04CA = bit_and(swizzle_y(r03CF), body.constant(524287u));
               ir_expression *const r04CB = nequal(r04CA, body.constant(0u));
               ir_expression *const r04CC = logic_or(r04C9, r04CB);
               body.emit(assign(r04C5, logic_and(r04C8, r04CC), 0x01));

               ir_variable *const r04CD = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r04CE = lshift(swizzle_y(r03D0), body.constant(int(1)));
               ir_expression *const r04CF = lequal(body.constant(4292870144u), r04CE);
               ir_expression *const r04D0 = nequal(swizzle_x(r03D0), body.constant(0u));
               ir_expression *const r04D1 = bit_and(swizzle_y(r03D0), body.constant(1048575u));
               ir_expression *const r04D2 = nequal(r04D1, body.constant(0u));
               ir_expression *const r04D3 = logic_or(r04D0, r04D2);
               body.emit(assign(r04CD, logic_and(r04CF, r04D3), 0x01));

               body.emit(assign(r04C2, bit_or(swizzle_y(r03CF), body.constant(524288u)), 0x02));

               body.emit(assign(r04C3, bit_or(swizzle_y(r03D0), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r04D5 = lshift(swizzle_y(r03CF), body.constant(int(1)));
               ir_expression *const r04D6 = lequal(body.constant(4292870144u), r04D5);
               ir_expression *const r04D7 = nequal(swizzle_x(r03CF), body.constant(0u));
               ir_expression *const r04D8 = bit_and(swizzle_y(r03CF), body.constant(1048575u));
               ir_expression *const r04D9 = nequal(r04D8, body.constant(0u));
               ir_expression *const r04DA = logic_or(r04D7, r04D9);
               ir_expression *const r04DB = logic_and(r04D6, r04DA);
               ir_if *f04D4 = new(mem_ctx) ir_if(operand(r04DB).val);
               exec_list *const f04D4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f04D4->then_instructions;

                  ir_variable *const r04DC = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r04DE = logic_and(r04C5, r04CD);
                  ir_if *f04DD = new(mem_ctx) ir_if(operand(r04DE).val);
                  exec_list *const f04DD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f04DD->then_instructions;

                     body.emit(assign(r04DC, r04C3, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f04DD->else_instructions;

                     body.emit(assign(r04DC, r04C2, 0x03));


                  body.instructions = f04DD_parent_instructions;
                  body.emit(f04DD);

                  /* END IF */

                  body.emit(assign(r04C4, r04DC, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f04D4->else_instructions;

                  body.emit(assign(r04C4, r04C3, 0x03));


               body.instructions = f04D4_parent_instructions;
               body.emit(f04D4);

               /* END IF */

               body.emit(assign(r03D2, r04C4, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f04BF->else_instructions;

               ir_variable *const r04DF = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r04DF);
               ir_expression *const r04E0 = bit_xor(r03D1, body.constant(1u));
               ir_expression *const r04E1 = lshift(r04E0, body.constant(int(31)));
               body.emit(assign(r04DF, add(r04E1, body.constant(2146435072u)), 0x02));

               body.emit(assign(r04DF, body.constant(0u), 0x01));

               body.emit(assign(r03D2, r04DF, 0x03));


            body.instructions = f04BF_parent_instructions;
            body.emit(f04BF);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f04BD->else_instructions;

            /* IF CONDITION */
            ir_expression *const r04E3 = equal(r03DA, body.constant(int(0)));
            ir_if *f04E2 = new(mem_ctx) ir_if(operand(r04E3).val);
            exec_list *const f04E2_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f04E2->then_instructions;

               body.emit(assign(r03D3, add(r03D3, body.constant(int(1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f04E2->else_instructions;

               body.emit(assign(r03D7, bit_or(swizzle_y(r03D7), body.constant(1073741824u)), 0x02));


            body.instructions = f04E2_parent_instructions;
            body.emit(f04E2);

            /* END IF */

            ir_variable *const r04E4 = body.make_temp(glsl_type::uint_type, "a0");
            body.emit(assign(r04E4, swizzle_y(r03D7), 0x01));

            ir_variable *const r04E5 = body.make_temp(glsl_type::uint_type, "a1");
            body.emit(assign(r04E5, swizzle_x(r03D7), 0x01));

            ir_variable *const r04E6 = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r04E6, neg(r03D3), 0x01));

            ir_variable *const r04E7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r04E7);
            ir_variable *const r04E8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r04E8);
            ir_variable *const r04E9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r04EA = neg(r04E6);
            body.emit(assign(r04E9, bit_and(r04EA, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r04EC = equal(r04E6, body.constant(int(0)));
            ir_if *f04EB = new(mem_ctx) ir_if(operand(r04EC).val);
            exec_list *const f04EB_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f04EB->then_instructions;

               body.emit(assign(r04E7, r04E5, 0x01));

               body.emit(assign(r04E8, r04E4, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f04EB->else_instructions;

               /* IF CONDITION */
               ir_expression *const r04EE = less(r04E6, body.constant(int(32)));
               ir_if *f04ED = new(mem_ctx) ir_if(operand(r04EE).val);
               exec_list *const f04ED_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f04ED->then_instructions;

                  ir_expression *const r04EF = lshift(swizzle_y(r03D7), r04E9);
                  ir_expression *const r04F0 = rshift(r03E1, r04E6);
                  ir_expression *const r04F1 = bit_or(r04EF, r04F0);
                  ir_expression *const r04F2 = lshift(r03E1, r04E9);
                  ir_expression *const r04F3 = nequal(r04F2, body.constant(0u));
                  ir_expression *const r04F4 = expr(ir_unop_b2i, r04F3);
                  ir_expression *const r04F5 = expr(ir_unop_i2u, r04F4);
                  body.emit(assign(r04E7, bit_or(r04F1, r04F5), 0x01));

                  body.emit(assign(r04E8, rshift(swizzle_y(r03D7), r04E6), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f04ED->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r04F7 = equal(r04E6, body.constant(int(32)));
                  ir_if *f04F6 = new(mem_ctx) ir_if(operand(r04F7).val);
                  exec_list *const f04F6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f04F6->then_instructions;

                     ir_expression *const r04F8 = nequal(r03E1, body.constant(0u));
                     ir_expression *const r04F9 = expr(ir_unop_b2i, r04F8);
                     ir_expression *const r04FA = expr(ir_unop_i2u, r04F9);
                     body.emit(assign(r04E7, bit_or(swizzle_y(r03D7), r04FA), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f04F6->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r04FC = less(r04E6, body.constant(int(64)));
                     ir_if *f04FB = new(mem_ctx) ir_if(operand(r04FC).val);
                     exec_list *const f04FB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f04FB->then_instructions;

                        ir_expression *const r04FD = bit_and(r04E6, body.constant(int(31)));
                        ir_expression *const r04FE = rshift(swizzle_y(r03D7), r04FD);
                        ir_expression *const r04FF = lshift(swizzle_y(r03D7), r04E9);
                        ir_expression *const r0500 = bit_or(r04FF, r03E1);
                        ir_expression *const r0501 = nequal(r0500, body.constant(0u));
                        ir_expression *const r0502 = expr(ir_unop_b2i, r0501);
                        ir_expression *const r0503 = expr(ir_unop_i2u, r0502);
                        body.emit(assign(r04E7, bit_or(r04FE, r0503), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f04FB->else_instructions;

                        ir_expression *const r0504 = bit_or(swizzle_y(r03D7), r03E1);
                        ir_expression *const r0505 = nequal(r0504, body.constant(0u));
                        ir_expression *const r0506 = expr(ir_unop_b2i, r0505);
                        body.emit(assign(r04E7, expr(ir_unop_i2u, r0506), 0x01));


                     body.instructions = f04FB_parent_instructions;
                     body.emit(f04FB);

                     /* END IF */


                  body.instructions = f04F6_parent_instructions;
                  body.emit(f04F6);

                  /* END IF */

                  body.emit(assign(r04E8, body.constant(0u), 0x01));


               body.instructions = f04ED_parent_instructions;
               body.emit(f04ED);

               /* END IF */


            body.instructions = f04EB_parent_instructions;
            body.emit(f04EB);

            /* END IF */

            body.emit(assign(r03D7, r04E8, 0x02));

            body.emit(assign(r03D7, r04E7, 0x01));

            body.emit(assign(r03D5, bit_or(swizzle_y(r03D5), body.constant(1073741824u)), 0x02));

            ir_variable *const r0507 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r0508 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r0508, sub(swizzle_x(r03D5), r04E7), 0x01));

            ir_expression *const r0509 = sub(swizzle_y(r03D5), r04E8);
            ir_expression *const r050A = less(swizzle_x(r03D5), r04E7);
            ir_expression *const r050B = expr(ir_unop_b2i, r050A);
            ir_expression *const r050C = expr(ir_unop_i2u, r050B);
            body.emit(assign(r0507, sub(r0509, r050C), 0x01));

            body.emit(assign(r03D1, bit_xor(r03D1, body.constant(1u)), 0x01));

            body.emit(assign(r03D8, add(r03DE, body.constant(int(-1))), 0x01));

            ir_variable *const r050D = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r050D, add(r03D8, body.constant(int(-10))), 0x01));

            ir_variable *const r050E = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r050E, r0507, 0x01));

            ir_variable *const r050F = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r050F, r0508, 0x01));

            ir_variable *const r0510 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
            body.emit(r0510);
            ir_variable *const r0511 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0511);
            /* IF CONDITION */
            ir_expression *const r0513 = equal(r0507, body.constant(0u));
            ir_if *f0512 = new(mem_ctx) ir_if(operand(r0513).val);
            exec_list *const f0512_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0512->then_instructions;

               body.emit(assign(r050E, r0508, 0x01));

               body.emit(assign(r050F, body.constant(0u), 0x01));

               body.emit(assign(r050D, add(r050D, body.constant(int(-32))), 0x01));


            body.instructions = f0512_parent_instructions;
            body.emit(f0512);

            /* END IF */

            ir_variable *const r0514 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r0514, r050E, 0x01));

            ir_variable *const r0515 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r0516 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0516);
            /* IF CONDITION */
            ir_expression *const r0518 = equal(r050E, body.constant(0u));
            ir_if *f0517 = new(mem_ctx) ir_if(operand(r0518).val);
            exec_list *const f0517_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0517->then_instructions;

               body.emit(assign(r0515, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0517->else_instructions;

               body.emit(assign(r0516, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r051A = bit_and(r050E, body.constant(4294901760u));
               ir_expression *const r051B = equal(r051A, body.constant(0u));
               ir_if *f0519 = new(mem_ctx) ir_if(operand(r051B).val);
               exec_list *const f0519_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0519->then_instructions;

                  body.emit(assign(r0516, body.constant(int(16)), 0x01));

                  body.emit(assign(r0514, lshift(r050E, body.constant(int(16))), 0x01));


               body.instructions = f0519_parent_instructions;
               body.emit(f0519);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r051D = bit_and(r0514, body.constant(4278190080u));
               ir_expression *const r051E = equal(r051D, body.constant(0u));
               ir_if *f051C = new(mem_ctx) ir_if(operand(r051E).val);
               exec_list *const f051C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f051C->then_instructions;

                  body.emit(assign(r0516, add(r0516, body.constant(int(8))), 0x01));

                  body.emit(assign(r0514, lshift(r0514, body.constant(int(8))), 0x01));


               body.instructions = f051C_parent_instructions;
               body.emit(f051C);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0520 = bit_and(r0514, body.constant(4026531840u));
               ir_expression *const r0521 = equal(r0520, body.constant(0u));
               ir_if *f051F = new(mem_ctx) ir_if(operand(r0521).val);
               exec_list *const f051F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f051F->then_instructions;

                  body.emit(assign(r0516, add(r0516, body.constant(int(4))), 0x01));

                  body.emit(assign(r0514, lshift(r0514, body.constant(int(4))), 0x01));


               body.instructions = f051F_parent_instructions;
               body.emit(f051F);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0523 = bit_and(r0514, body.constant(3221225472u));
               ir_expression *const r0524 = equal(r0523, body.constant(0u));
               ir_if *f0522 = new(mem_ctx) ir_if(operand(r0524).val);
               exec_list *const f0522_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0522->then_instructions;

                  body.emit(assign(r0516, add(r0516, body.constant(int(2))), 0x01));

                  body.emit(assign(r0514, lshift(r0514, body.constant(int(2))), 0x01));


               body.instructions = f0522_parent_instructions;
               body.emit(f0522);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0526 = bit_and(r0514, body.constant(2147483648u));
               ir_expression *const r0527 = equal(r0526, body.constant(0u));
               ir_if *f0525 = new(mem_ctx) ir_if(operand(r0527).val);
               exec_list *const f0525_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0525->then_instructions;

                  body.emit(assign(r0516, add(r0516, body.constant(int(1))), 0x01));


               body.instructions = f0525_parent_instructions;
               body.emit(f0525);

               /* END IF */

               body.emit(assign(r0515, r0516, 0x01));


            body.instructions = f0517_parent_instructions;
            body.emit(f0517);

            /* END IF */

            body.emit(assign(r0511, add(r0515, body.constant(int(-11))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0529 = lequal(body.constant(int(0)), r0511);
            ir_if *f0528 = new(mem_ctx) ir_if(operand(r0529).val);
            exec_list *const f0528_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0528->then_instructions;

               body.emit(assign(r0510, body.constant(0u), 0x01));

               ir_variable *const r052A = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r052A, lshift(r050F, r0511), 0x01));

               ir_variable *const r052B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r052D = equal(r0511, body.constant(int(0)));
               ir_if *f052C = new(mem_ctx) ir_if(operand(r052D).val);
               exec_list *const f052C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f052C->then_instructions;

                  body.emit(assign(r052B, r050E, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f052C->else_instructions;

                  ir_expression *const r052E = lshift(r050E, r0511);
                  ir_expression *const r052F = neg(r0511);
                  ir_expression *const r0530 = bit_and(r052F, body.constant(int(31)));
                  ir_expression *const r0531 = rshift(r050F, r0530);
                  body.emit(assign(r052B, bit_or(r052E, r0531), 0x01));


               body.instructions = f052C_parent_instructions;
               body.emit(f052C);

               /* END IF */

               body.emit(assign(r050E, r052B, 0x01));

               body.emit(assign(r050F, r052A, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0528->else_instructions;

               ir_variable *const r0532 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r0532, body.constant(0u), 0x01));

               ir_variable *const r0533 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0533, neg(r0511), 0x01));

               ir_variable *const r0534 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r0534);
               ir_variable *const r0535 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0535);
               ir_variable *const r0536 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0536);
               ir_variable *const r0537 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0538 = neg(r0533);
               body.emit(assign(r0537, bit_and(r0538, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r053A = equal(r0533, body.constant(int(0)));
               ir_if *f0539 = new(mem_ctx) ir_if(operand(r053A).val);
               exec_list *const f0539_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0539->then_instructions;

                  body.emit(assign(r0534, r0532, 0x01));

                  body.emit(assign(r0535, r050F, 0x01));

                  body.emit(assign(r0536, r050E, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0539->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r053C = less(r0533, body.constant(int(32)));
                  ir_if *f053B = new(mem_ctx) ir_if(operand(r053C).val);
                  exec_list *const f053B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f053B->then_instructions;

                     body.emit(assign(r0534, lshift(r050F, r0537), 0x01));

                     ir_expression *const r053D = lshift(r050E, r0537);
                     ir_expression *const r053E = rshift(r050F, r0533);
                     body.emit(assign(r0535, bit_or(r053D, r053E), 0x01));

                     body.emit(assign(r0536, rshift(r050E, r0533), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f053B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0540 = equal(r0533, body.constant(int(32)));
                     ir_if *f053F = new(mem_ctx) ir_if(operand(r0540).val);
                     exec_list *const f053F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f053F->then_instructions;

                        body.emit(assign(r0534, r050F, 0x01));

                        body.emit(assign(r0535, r050E, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f053F->else_instructions;

                        body.emit(assign(r0532, bit_or(body.constant(0u), r050F), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0542 = less(r0533, body.constant(int(64)));
                        ir_if *f0541 = new(mem_ctx) ir_if(operand(r0542).val);
                        exec_list *const f0541_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0541->then_instructions;

                           body.emit(assign(r0534, lshift(r050E, r0537), 0x01));

                           ir_expression *const r0543 = bit_and(r0533, body.constant(int(31)));
                           body.emit(assign(r0535, rshift(r050E, r0543), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0541->else_instructions;

                           ir_variable *const r0544 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0546 = equal(r0533, body.constant(int(64)));
                           ir_if *f0545 = new(mem_ctx) ir_if(operand(r0546).val);
                           exec_list *const f0545_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0545->then_instructions;

                              body.emit(assign(r0544, r050E, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0545->else_instructions;

                              ir_expression *const r0547 = nequal(r050E, body.constant(0u));
                              ir_expression *const r0548 = expr(ir_unop_b2i, r0547);
                              body.emit(assign(r0544, expr(ir_unop_i2u, r0548), 0x01));


                           body.instructions = f0545_parent_instructions;
                           body.emit(f0545);

                           /* END IF */

                           body.emit(assign(r0534, r0544, 0x01));

                           body.emit(assign(r0535, body.constant(0u), 0x01));


                        body.instructions = f0541_parent_instructions;
                        body.emit(f0541);

                        /* END IF */


                     body.instructions = f053F_parent_instructions;
                     body.emit(f053F);

                     /* END IF */

                     body.emit(assign(r0536, body.constant(0u), 0x01));


                  body.instructions = f053B_parent_instructions;
                  body.emit(f053B);

                  /* END IF */

                  ir_expression *const r0549 = nequal(r0532, body.constant(0u));
                  ir_expression *const r054A = expr(ir_unop_b2i, r0549);
                  ir_expression *const r054B = expr(ir_unop_i2u, r054A);
                  body.emit(assign(r0534, bit_or(r0534, r054B), 0x01));


               body.instructions = f0539_parent_instructions;
               body.emit(f0539);

               /* END IF */

               body.emit(assign(r050E, r0536, 0x01));

               body.emit(assign(r050F, r0535, 0x01));

               body.emit(assign(r0510, r0534, 0x01));


            body.instructions = f0528_parent_instructions;
            body.emit(f0528);

            /* END IF */

            body.emit(assign(r050D, sub(r050D, r0511), 0x01));

            ir_variable *const r054C = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r054C, r050D, 0x01));

            ir_variable *const r054D = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r054D, r050E, 0x01));

            ir_variable *const r054E = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r054E, r050F, 0x01));

            ir_variable *const r054F = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r054F, r0510, 0x01));

            ir_variable *const r0550 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r0550, body.constant(true), 0x01));

            ir_variable *const r0551 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0552 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r0552);
            ir_expression *const r0553 = expr(ir_unop_u2i, r0510);
            body.emit(assign(r0552, less(r0553, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0555 = lequal(body.constant(int(2045)), r050D);
            ir_if *f0554 = new(mem_ctx) ir_if(operand(r0555).val);
            exec_list *const f0554_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0554->then_instructions;

               ir_variable *const r0556 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0558 = less(body.constant(int(2045)), r050D);
               ir_if *f0557 = new(mem_ctx) ir_if(operand(r0558).val);
               exec_list *const f0557_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0557->then_instructions;

                  body.emit(assign(r0556, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0557->else_instructions;

                  ir_variable *const r0559 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r055B = equal(r050D, body.constant(int(2045)));
                  ir_if *f055A = new(mem_ctx) ir_if(operand(r055B).val);
                  exec_list *const f055A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f055A->then_instructions;

                     ir_expression *const r055C = equal(body.constant(2097151u), r050E);
                     ir_expression *const r055D = equal(body.constant(4294967295u), r050F);
                     body.emit(assign(r0559, logic_and(r055C, r055D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f055A->else_instructions;

                     body.emit(assign(r0559, body.constant(false), 0x01));


                  body.instructions = f055A_parent_instructions;
                  body.emit(f055A);

                  /* END IF */

                  body.emit(assign(r0556, logic_and(r0559, r0552), 0x01));


               body.instructions = f0557_parent_instructions;
               body.emit(f0557);

               /* END IF */

               /* IF CONDITION */
               ir_if *f055E = new(mem_ctx) ir_if(operand(r0556).val);
               exec_list *const f055E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f055E->then_instructions;

                  ir_variable *const r055F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r055F);
                  ir_expression *const r0560 = lshift(r03D1, body.constant(int(31)));
                  body.emit(assign(r055F, add(r0560, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r055F, body.constant(0u), 0x01));

                  body.emit(assign(r0551, r055F, 0x03));

                  body.emit(assign(r0550, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f055E->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0562 = less(r050D, body.constant(int(0)));
                  ir_if *f0561 = new(mem_ctx) ir_if(operand(r0562).val);
                  exec_list *const f0561_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0561->then_instructions;

                     ir_variable *const r0563 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0563, r0510, 0x01));

                     ir_variable *const r0564 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0564, neg(r050D), 0x01));

                     ir_variable *const r0565 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0565);
                     ir_variable *const r0566 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0566);
                     ir_variable *const r0567 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0567);
                     ir_variable *const r0568 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0569 = neg(r0564);
                     body.emit(assign(r0568, bit_and(r0569, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r056B = equal(r0564, body.constant(int(0)));
                     ir_if *f056A = new(mem_ctx) ir_if(operand(r056B).val);
                     exec_list *const f056A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f056A->then_instructions;

                        body.emit(assign(r0565, r0510, 0x01));

                        body.emit(assign(r0566, r050F, 0x01));

                        body.emit(assign(r0567, r050E, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f056A->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r056D = less(r0564, body.constant(int(32)));
                        ir_if *f056C = new(mem_ctx) ir_if(operand(r056D).val);
                        exec_list *const f056C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f056C->then_instructions;

                           body.emit(assign(r0565, lshift(r050F, r0568), 0x01));

                           ir_expression *const r056E = lshift(r050E, r0568);
                           ir_expression *const r056F = rshift(r050F, r0564);
                           body.emit(assign(r0566, bit_or(r056E, r056F), 0x01));

                           body.emit(assign(r0567, rshift(r050E, r0564), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f056C->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0571 = equal(r0564, body.constant(int(32)));
                           ir_if *f0570 = new(mem_ctx) ir_if(operand(r0571).val);
                           exec_list *const f0570_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0570->then_instructions;

                              body.emit(assign(r0565, r050F, 0x01));

                              body.emit(assign(r0566, r050E, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0570->else_instructions;

                              body.emit(assign(r0563, bit_or(r0510, r050F), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0573 = less(r0564, body.constant(int(64)));
                              ir_if *f0572 = new(mem_ctx) ir_if(operand(r0573).val);
                              exec_list *const f0572_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0572->then_instructions;

                                 body.emit(assign(r0565, lshift(r050E, r0568), 0x01));

                                 ir_expression *const r0574 = bit_and(r0564, body.constant(int(31)));
                                 body.emit(assign(r0566, rshift(r050E, r0574), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0572->else_instructions;

                                 ir_variable *const r0575 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0577 = equal(r0564, body.constant(int(64)));
                                 ir_if *f0576 = new(mem_ctx) ir_if(operand(r0577).val);
                                 exec_list *const f0576_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0576->then_instructions;

                                    body.emit(assign(r0575, r050E, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0576->else_instructions;

                                    ir_expression *const r0578 = nequal(r050E, body.constant(0u));
                                    ir_expression *const r0579 = expr(ir_unop_b2i, r0578);
                                    body.emit(assign(r0575, expr(ir_unop_i2u, r0579), 0x01));


                                 body.instructions = f0576_parent_instructions;
                                 body.emit(f0576);

                                 /* END IF */

                                 body.emit(assign(r0565, r0575, 0x01));

                                 body.emit(assign(r0566, body.constant(0u), 0x01));


                              body.instructions = f0572_parent_instructions;
                              body.emit(f0572);

                              /* END IF */


                           body.instructions = f0570_parent_instructions;
                           body.emit(f0570);

                           /* END IF */

                           body.emit(assign(r0567, body.constant(0u), 0x01));


                        body.instructions = f056C_parent_instructions;
                        body.emit(f056C);

                        /* END IF */

                        ir_expression *const r057A = nequal(r0563, body.constant(0u));
                        ir_expression *const r057B = expr(ir_unop_b2i, r057A);
                        ir_expression *const r057C = expr(ir_unop_i2u, r057B);
                        body.emit(assign(r0565, bit_or(r0565, r057C), 0x01));


                     body.instructions = f056A_parent_instructions;
                     body.emit(f056A);

                     /* END IF */

                     body.emit(assign(r054D, r0567, 0x01));

                     body.emit(assign(r054E, r0566, 0x01));

                     body.emit(assign(r054F, r0565, 0x01));

                     body.emit(assign(r054C, body.constant(int(0)), 0x01));

                     body.emit(assign(r0552, less(r0565, body.constant(0u)), 0x01));


                  body.instructions = f0561_parent_instructions;
                  body.emit(f0561);

                  /* END IF */


               body.instructions = f055E_parent_instructions;
               body.emit(f055E);

               /* END IF */


            body.instructions = f0554_parent_instructions;
            body.emit(f0554);

            /* END IF */

            /* IF CONDITION */
            ir_if *f057D = new(mem_ctx) ir_if(operand(r0550).val);
            exec_list *const f057D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f057D->then_instructions;

               /* IF CONDITION */
               ir_if *f057E = new(mem_ctx) ir_if(operand(r0552).val);
               exec_list *const f057E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f057E->then_instructions;

                  ir_variable *const r057F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r057F, add(r054E, body.constant(1u)), 0x01));

                  ir_expression *const r0580 = less(r057F, r054E);
                  ir_expression *const r0581 = expr(ir_unop_b2i, r0580);
                  ir_expression *const r0582 = expr(ir_unop_i2u, r0581);
                  body.emit(assign(r054D, add(r054D, r0582), 0x01));

                  ir_expression *const r0583 = equal(r054F, body.constant(0u));
                  ir_expression *const r0584 = expr(ir_unop_b2i, r0583);
                  ir_expression *const r0585 = expr(ir_unop_i2u, r0584);
                  ir_expression *const r0586 = add(r054F, r0585);
                  ir_expression *const r0587 = bit_and(r0586, body.constant(1u));
                  ir_expression *const r0588 = expr(ir_unop_bit_not, r0587);
                  body.emit(assign(r054E, bit_and(r057F, r0588), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f057E->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r058A = bit_or(r054D, r054E);
                  ir_expression *const r058B = equal(r058A, body.constant(0u));
                  ir_if *f0589 = new(mem_ctx) ir_if(operand(r058B).val);
                  exec_list *const f0589_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0589->then_instructions;

                     body.emit(assign(r054C, body.constant(int(0)), 0x01));


                  body.instructions = f0589_parent_instructions;
                  body.emit(f0589);

                  /* END IF */


               body.instructions = f057E_parent_instructions;
               body.emit(f057E);

               /* END IF */

               ir_variable *const r058C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r058C);
               ir_expression *const r058D = lshift(r03D1, body.constant(int(31)));
               ir_expression *const r058E = expr(ir_unop_i2u, r054C);
               ir_expression *const r058F = lshift(r058E, body.constant(int(20)));
               ir_expression *const r0590 = add(r058D, r058F);
               body.emit(assign(r058C, add(r0590, r054D), 0x02));

               body.emit(assign(r058C, r054E, 0x01));

               body.emit(assign(r0551, r058C, 0x03));

               body.emit(assign(r0550, body.constant(false), 0x01));


            body.instructions = f057D_parent_instructions;
            body.emit(f057D);

            /* END IF */

            body.emit(assign(r03D2, r0551, 0x03));


         body.instructions = f04BD_parent_instructions;
         body.emit(f04BD);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f04BB->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0592 = equal(r03DA, body.constant(int(2047)));
         ir_if *f0591 = new(mem_ctx) ir_if(operand(r0592).val);
         exec_list *const f0591_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0591->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0594 = bit_or(swizzle_y(r03D7), swizzle_x(r03D7));
            ir_expression *const r0595 = bit_or(swizzle_y(r03D5), swizzle_x(r03D5));
            ir_expression *const r0596 = bit_or(r0594, r0595);
            ir_expression *const r0597 = nequal(r0596, body.constant(0u));
            ir_if *f0593 = new(mem_ctx) ir_if(operand(r0597).val);
            exec_list *const f0593_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0593->then_instructions;

               ir_variable *const r0598 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r0598, swizzle_x(r03CF), 0x01));

               ir_variable *const r0599 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r0599, swizzle_x(r03D0), 0x01));

               ir_variable *const r059A = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r059B = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r059C = rshift(swizzle_y(r03CF), body.constant(int(19)));
               ir_expression *const r059D = bit_and(r059C, body.constant(4095u));
               ir_expression *const r059E = equal(r059D, body.constant(4094u));
               ir_expression *const r059F = nequal(swizzle_x(r03CF), body.constant(0u));
               ir_expression *const r05A0 = bit_and(swizzle_y(r03CF), body.constant(524287u));
               ir_expression *const r05A1 = nequal(r05A0, body.constant(0u));
               ir_expression *const r05A2 = logic_or(r059F, r05A1);
               body.emit(assign(r059B, logic_and(r059E, r05A2), 0x01));

               ir_variable *const r05A3 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r05A4 = lshift(swizzle_y(r03D0), body.constant(int(1)));
               ir_expression *const r05A5 = lequal(body.constant(4292870144u), r05A4);
               ir_expression *const r05A6 = nequal(swizzle_x(r03D0), body.constant(0u));
               ir_expression *const r05A7 = bit_and(swizzle_y(r03D0), body.constant(1048575u));
               ir_expression *const r05A8 = nequal(r05A7, body.constant(0u));
               ir_expression *const r05A9 = logic_or(r05A6, r05A8);
               body.emit(assign(r05A3, logic_and(r05A5, r05A9), 0x01));

               body.emit(assign(r0598, bit_or(swizzle_y(r03CF), body.constant(524288u)), 0x02));

               body.emit(assign(r0599, bit_or(swizzle_y(r03D0), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r05AB = lshift(swizzle_y(r03CF), body.constant(int(1)));
               ir_expression *const r05AC = lequal(body.constant(4292870144u), r05AB);
               ir_expression *const r05AD = nequal(swizzle_x(r03CF), body.constant(0u));
               ir_expression *const r05AE = bit_and(swizzle_y(r03CF), body.constant(1048575u));
               ir_expression *const r05AF = nequal(r05AE, body.constant(0u));
               ir_expression *const r05B0 = logic_or(r05AD, r05AF);
               ir_expression *const r05B1 = logic_and(r05AC, r05B0);
               ir_if *f05AA = new(mem_ctx) ir_if(operand(r05B1).val);
               exec_list *const f05AA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f05AA->then_instructions;

                  ir_variable *const r05B2 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r05B4 = logic_and(r059B, r05A3);
                  ir_if *f05B3 = new(mem_ctx) ir_if(operand(r05B4).val);
                  exec_list *const f05B3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05B3->then_instructions;

                     body.emit(assign(r05B2, r0599, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f05B3->else_instructions;

                     body.emit(assign(r05B2, r0598, 0x03));


                  body.instructions = f05B3_parent_instructions;
                  body.emit(f05B3);

                  /* END IF */

                  body.emit(assign(r059A, r05B2, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f05AA->else_instructions;

                  body.emit(assign(r059A, r0599, 0x03));


               body.instructions = f05AA_parent_instructions;
               body.emit(f05AA);

               /* END IF */

               body.emit(assign(r03D2, r059A, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0593->else_instructions;

               ir_constant_data r05B5_data;
               memset(&r05B5_data, 0, sizeof(ir_constant_data));
r05B5_data.u[0] = 4294967295;
r05B5_data.u[1] = 4294967295;
               ir_constant *const r05B5 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r05B5_data);
               body.emit(assign(r03D2, r05B5, 0x03));


            body.instructions = f0593_parent_instructions;
            body.emit(f0593);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0591->else_instructions;

            /* IF CONDITION */
            ir_expression *const r05B7 = equal(r03DA, body.constant(int(0)));
            ir_if *f05B6 = new(mem_ctx) ir_if(operand(r05B7).val);
            exec_list *const f05B6_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f05B6->then_instructions;

               body.emit(assign(r03D6, body.constant(int(1)), 0x01));

               body.emit(assign(r03D4, body.constant(int(1)), 0x01));


            body.instructions = f05B6_parent_instructions;
            body.emit(f05B6);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r05B9 = less(swizzle_y(r03D5), swizzle_y(r03D7));
            ir_if *f05B8 = new(mem_ctx) ir_if(operand(r05B9).val);
            exec_list *const f05B8_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f05B8->then_instructions;

               ir_variable *const r05BA = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r05BB = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r05BB, sub(swizzle_x(r03D7), swizzle_x(r03D5)), 0x01));

               ir_expression *const r05BC = sub(swizzle_y(r03D7), swizzle_y(r03D5));
               ir_expression *const r05BD = less(swizzle_x(r03D7), swizzle_x(r03D5));
               ir_expression *const r05BE = expr(ir_unop_b2i, r05BD);
               ir_expression *const r05BF = expr(ir_unop_i2u, r05BE);
               body.emit(assign(r05BA, sub(r05BC, r05BF), 0x01));

               body.emit(assign(r03D8, add(r03D6, body.constant(int(-1))), 0x01));

               ir_variable *const r05C0 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r05C0, add(r03D8, body.constant(int(-10))), 0x01));

               ir_variable *const r05C1 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r05C1, r05BA, 0x01));

               ir_variable *const r05C2 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r05C2, r05BB, 0x01));

               ir_variable *const r05C3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r05C3);
               ir_variable *const r05C4 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r05C4);
               /* IF CONDITION */
               ir_expression *const r05C6 = equal(r05BA, body.constant(0u));
               ir_if *f05C5 = new(mem_ctx) ir_if(operand(r05C6).val);
               exec_list *const f05C5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f05C5->then_instructions;

                  body.emit(assign(r05C1, r05BB, 0x01));

                  body.emit(assign(r05C2, body.constant(0u), 0x01));

                  body.emit(assign(r05C0, add(r05C0, body.constant(int(-32))), 0x01));


               body.instructions = f05C5_parent_instructions;
               body.emit(f05C5);

               /* END IF */

               ir_variable *const r05C7 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r05C7, r05C1, 0x01));

               ir_variable *const r05C8 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r05C9 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r05C9);
               /* IF CONDITION */
               ir_expression *const r05CB = equal(r05C1, body.constant(0u));
               ir_if *f05CA = new(mem_ctx) ir_if(operand(r05CB).val);
               exec_list *const f05CA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f05CA->then_instructions;

                  body.emit(assign(r05C8, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f05CA->else_instructions;

                  body.emit(assign(r05C9, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r05CD = bit_and(r05C1, body.constant(4294901760u));
                  ir_expression *const r05CE = equal(r05CD, body.constant(0u));
                  ir_if *f05CC = new(mem_ctx) ir_if(operand(r05CE).val);
                  exec_list *const f05CC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05CC->then_instructions;

                     body.emit(assign(r05C9, body.constant(int(16)), 0x01));

                     body.emit(assign(r05C7, lshift(r05C1, body.constant(int(16))), 0x01));


                  body.instructions = f05CC_parent_instructions;
                  body.emit(f05CC);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r05D0 = bit_and(r05C7, body.constant(4278190080u));
                  ir_expression *const r05D1 = equal(r05D0, body.constant(0u));
                  ir_if *f05CF = new(mem_ctx) ir_if(operand(r05D1).val);
                  exec_list *const f05CF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05CF->then_instructions;

                     body.emit(assign(r05C9, add(r05C9, body.constant(int(8))), 0x01));

                     body.emit(assign(r05C7, lshift(r05C7, body.constant(int(8))), 0x01));


                  body.instructions = f05CF_parent_instructions;
                  body.emit(f05CF);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r05D3 = bit_and(r05C7, body.constant(4026531840u));
                  ir_expression *const r05D4 = equal(r05D3, body.constant(0u));
                  ir_if *f05D2 = new(mem_ctx) ir_if(operand(r05D4).val);
                  exec_list *const f05D2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05D2->then_instructions;

                     body.emit(assign(r05C9, add(r05C9, body.constant(int(4))), 0x01));

                     body.emit(assign(r05C7, lshift(r05C7, body.constant(int(4))), 0x01));


                  body.instructions = f05D2_parent_instructions;
                  body.emit(f05D2);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r05D6 = bit_and(r05C7, body.constant(3221225472u));
                  ir_expression *const r05D7 = equal(r05D6, body.constant(0u));
                  ir_if *f05D5 = new(mem_ctx) ir_if(operand(r05D7).val);
                  exec_list *const f05D5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05D5->then_instructions;

                     body.emit(assign(r05C9, add(r05C9, body.constant(int(2))), 0x01));

                     body.emit(assign(r05C7, lshift(r05C7, body.constant(int(2))), 0x01));


                  body.instructions = f05D5_parent_instructions;
                  body.emit(f05D5);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r05D9 = bit_and(r05C7, body.constant(2147483648u));
                  ir_expression *const r05DA = equal(r05D9, body.constant(0u));
                  ir_if *f05D8 = new(mem_ctx) ir_if(operand(r05DA).val);
                  exec_list *const f05D8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05D8->then_instructions;

                     body.emit(assign(r05C9, add(r05C9, body.constant(int(1))), 0x01));


                  body.instructions = f05D8_parent_instructions;
                  body.emit(f05D8);

                  /* END IF */

                  body.emit(assign(r05C8, r05C9, 0x01));


               body.instructions = f05CA_parent_instructions;
               body.emit(f05CA);

               /* END IF */

               body.emit(assign(r05C4, add(r05C8, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r05DC = lequal(body.constant(int(0)), r05C4);
               ir_if *f05DB = new(mem_ctx) ir_if(operand(r05DC).val);
               exec_list *const f05DB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f05DB->then_instructions;

                  body.emit(assign(r05C3, body.constant(0u), 0x01));

                  ir_variable *const r05DD = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r05DD, lshift(r05C2, r05C4), 0x01));

                  ir_variable *const r05DE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r05E0 = equal(r05C4, body.constant(int(0)));
                  ir_if *f05DF = new(mem_ctx) ir_if(operand(r05E0).val);
                  exec_list *const f05DF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05DF->then_instructions;

                     body.emit(assign(r05DE, r05C1, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f05DF->else_instructions;

                     ir_expression *const r05E1 = lshift(r05C1, r05C4);
                     ir_expression *const r05E2 = neg(r05C4);
                     ir_expression *const r05E3 = bit_and(r05E2, body.constant(int(31)));
                     ir_expression *const r05E4 = rshift(r05C2, r05E3);
                     body.emit(assign(r05DE, bit_or(r05E1, r05E4), 0x01));


                  body.instructions = f05DF_parent_instructions;
                  body.emit(f05DF);

                  /* END IF */

                  body.emit(assign(r05C1, r05DE, 0x01));

                  body.emit(assign(r05C2, r05DD, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f05DB->else_instructions;

                  ir_variable *const r05E5 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r05E5, body.constant(0u), 0x01));

                  ir_variable *const r05E6 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r05E6, neg(r05C4), 0x01));

                  ir_variable *const r05E7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r05E7);
                  ir_variable *const r05E8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r05E8);
                  ir_variable *const r05E9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r05E9);
                  ir_variable *const r05EA = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r05EB = neg(r05E6);
                  body.emit(assign(r05EA, bit_and(r05EB, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r05ED = equal(r05E6, body.constant(int(0)));
                  ir_if *f05EC = new(mem_ctx) ir_if(operand(r05ED).val);
                  exec_list *const f05EC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05EC->then_instructions;

                     body.emit(assign(r05E7, r05E5, 0x01));

                     body.emit(assign(r05E8, r05C2, 0x01));

                     body.emit(assign(r05E9, r05C1, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f05EC->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r05EF = less(r05E6, body.constant(int(32)));
                     ir_if *f05EE = new(mem_ctx) ir_if(operand(r05EF).val);
                     exec_list *const f05EE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f05EE->then_instructions;

                        body.emit(assign(r05E7, lshift(r05C2, r05EA), 0x01));

                        ir_expression *const r05F0 = lshift(r05C1, r05EA);
                        ir_expression *const r05F1 = rshift(r05C2, r05E6);
                        body.emit(assign(r05E8, bit_or(r05F0, r05F1), 0x01));

                        body.emit(assign(r05E9, rshift(r05C1, r05E6), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f05EE->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r05F3 = equal(r05E6, body.constant(int(32)));
                        ir_if *f05F2 = new(mem_ctx) ir_if(operand(r05F3).val);
                        exec_list *const f05F2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f05F2->then_instructions;

                           body.emit(assign(r05E7, r05C2, 0x01));

                           body.emit(assign(r05E8, r05C1, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f05F2->else_instructions;

                           body.emit(assign(r05E5, bit_or(body.constant(0u), r05C2), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r05F5 = less(r05E6, body.constant(int(64)));
                           ir_if *f05F4 = new(mem_ctx) ir_if(operand(r05F5).val);
                           exec_list *const f05F4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f05F4->then_instructions;

                              body.emit(assign(r05E7, lshift(r05C1, r05EA), 0x01));

                              ir_expression *const r05F6 = bit_and(r05E6, body.constant(int(31)));
                              body.emit(assign(r05E8, rshift(r05C1, r05F6), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f05F4->else_instructions;

                              ir_variable *const r05F7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r05F9 = equal(r05E6, body.constant(int(64)));
                              ir_if *f05F8 = new(mem_ctx) ir_if(operand(r05F9).val);
                              exec_list *const f05F8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f05F8->then_instructions;

                                 body.emit(assign(r05F7, r05C1, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f05F8->else_instructions;

                                 ir_expression *const r05FA = nequal(r05C1, body.constant(0u));
                                 ir_expression *const r05FB = expr(ir_unop_b2i, r05FA);
                                 body.emit(assign(r05F7, expr(ir_unop_i2u, r05FB), 0x01));


                              body.instructions = f05F8_parent_instructions;
                              body.emit(f05F8);

                              /* END IF */

                              body.emit(assign(r05E7, r05F7, 0x01));

                              body.emit(assign(r05E8, body.constant(0u), 0x01));


                           body.instructions = f05F4_parent_instructions;
                           body.emit(f05F4);

                           /* END IF */


                        body.instructions = f05F2_parent_instructions;
                        body.emit(f05F2);

                        /* END IF */

                        body.emit(assign(r05E9, body.constant(0u), 0x01));


                     body.instructions = f05EE_parent_instructions;
                     body.emit(f05EE);

                     /* END IF */

                     ir_expression *const r05FC = nequal(r05E5, body.constant(0u));
                     ir_expression *const r05FD = expr(ir_unop_b2i, r05FC);
                     ir_expression *const r05FE = expr(ir_unop_i2u, r05FD);
                     body.emit(assign(r05E7, bit_or(r05E7, r05FE), 0x01));


                  body.instructions = f05EC_parent_instructions;
                  body.emit(f05EC);

                  /* END IF */

                  body.emit(assign(r05C1, r05E9, 0x01));

                  body.emit(assign(r05C2, r05E8, 0x01));

                  body.emit(assign(r05C3, r05E7, 0x01));


               body.instructions = f05DB_parent_instructions;
               body.emit(f05DB);

               /* END IF */

               body.emit(assign(r05C0, sub(r05C0, r05C4), 0x01));

               ir_variable *const r05FF = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r05FF, r05C0, 0x01));

               ir_variable *const r0600 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0600, r05C1, 0x01));

               ir_variable *const r0601 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0601, r05C2, 0x01));

               ir_variable *const r0602 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r0602, r05C3, 0x01));

               ir_variable *const r0603 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r0603, body.constant(true), 0x01));

               ir_variable *const r0604 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0605 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r0605);
               ir_expression *const r0606 = expr(ir_unop_u2i, r05C3);
               body.emit(assign(r0605, less(r0606, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0608 = lequal(body.constant(int(2045)), r05C0);
               ir_if *f0607 = new(mem_ctx) ir_if(operand(r0608).val);
               exec_list *const f0607_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0607->then_instructions;

                  ir_variable *const r0609 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r060B = less(body.constant(int(2045)), r05C0);
                  ir_if *f060A = new(mem_ctx) ir_if(operand(r060B).val);
                  exec_list *const f060A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f060A->then_instructions;

                     body.emit(assign(r0609, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f060A->else_instructions;

                     ir_variable *const r060C = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r060E = equal(r05C0, body.constant(int(2045)));
                     ir_if *f060D = new(mem_ctx) ir_if(operand(r060E).val);
                     exec_list *const f060D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f060D->then_instructions;

                        ir_expression *const r060F = equal(body.constant(2097151u), r05C1);
                        ir_expression *const r0610 = equal(body.constant(4294967295u), r05C2);
                        body.emit(assign(r060C, logic_and(r060F, r0610), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f060D->else_instructions;

                        body.emit(assign(r060C, body.constant(false), 0x01));


                     body.instructions = f060D_parent_instructions;
                     body.emit(f060D);

                     /* END IF */

                     body.emit(assign(r0609, logic_and(r060C, r0605), 0x01));


                  body.instructions = f060A_parent_instructions;
                  body.emit(f060A);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0611 = new(mem_ctx) ir_if(operand(r0609).val);
                  exec_list *const f0611_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0611->then_instructions;

                     ir_variable *const r0612 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0612);
                     ir_expression *const r0613 = lshift(r03D1, body.constant(int(31)));
                     body.emit(assign(r0612, add(r0613, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r0612, body.constant(0u), 0x01));

                     body.emit(assign(r0604, r0612, 0x03));

                     body.emit(assign(r0603, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0611->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0615 = less(r05C0, body.constant(int(0)));
                     ir_if *f0614 = new(mem_ctx) ir_if(operand(r0615).val);
                     exec_list *const f0614_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0614->then_instructions;

                        ir_variable *const r0616 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0616, r05C3, 0x01));

                        ir_variable *const r0617 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0617, neg(r05C0), 0x01));

                        ir_variable *const r0618 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0618);
                        ir_variable *const r0619 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0619);
                        ir_variable *const r061A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r061A);
                        ir_variable *const r061B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r061C = neg(r0617);
                        body.emit(assign(r061B, bit_and(r061C, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r061E = equal(r0617, body.constant(int(0)));
                        ir_if *f061D = new(mem_ctx) ir_if(operand(r061E).val);
                        exec_list *const f061D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f061D->then_instructions;

                           body.emit(assign(r0618, r05C3, 0x01));

                           body.emit(assign(r0619, r05C2, 0x01));

                           body.emit(assign(r061A, r05C1, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f061D->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0620 = less(r0617, body.constant(int(32)));
                           ir_if *f061F = new(mem_ctx) ir_if(operand(r0620).val);
                           exec_list *const f061F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f061F->then_instructions;

                              body.emit(assign(r0618, lshift(r05C2, r061B), 0x01));

                              ir_expression *const r0621 = lshift(r05C1, r061B);
                              ir_expression *const r0622 = rshift(r05C2, r0617);
                              body.emit(assign(r0619, bit_or(r0621, r0622), 0x01));

                              body.emit(assign(r061A, rshift(r05C1, r0617), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f061F->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0624 = equal(r0617, body.constant(int(32)));
                              ir_if *f0623 = new(mem_ctx) ir_if(operand(r0624).val);
                              exec_list *const f0623_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0623->then_instructions;

                                 body.emit(assign(r0618, r05C2, 0x01));

                                 body.emit(assign(r0619, r05C1, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0623->else_instructions;

                                 body.emit(assign(r0616, bit_or(r05C3, r05C2), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0626 = less(r0617, body.constant(int(64)));
                                 ir_if *f0625 = new(mem_ctx) ir_if(operand(r0626).val);
                                 exec_list *const f0625_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0625->then_instructions;

                                    body.emit(assign(r0618, lshift(r05C1, r061B), 0x01));

                                    ir_expression *const r0627 = bit_and(r0617, body.constant(int(31)));
                                    body.emit(assign(r0619, rshift(r05C1, r0627), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0625->else_instructions;

                                    ir_variable *const r0628 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r062A = equal(r0617, body.constant(int(64)));
                                    ir_if *f0629 = new(mem_ctx) ir_if(operand(r062A).val);
                                    exec_list *const f0629_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0629->then_instructions;

                                       body.emit(assign(r0628, r05C1, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0629->else_instructions;

                                       ir_expression *const r062B = nequal(r05C1, body.constant(0u));
                                       ir_expression *const r062C = expr(ir_unop_b2i, r062B);
                                       body.emit(assign(r0628, expr(ir_unop_i2u, r062C), 0x01));


                                    body.instructions = f0629_parent_instructions;
                                    body.emit(f0629);

                                    /* END IF */

                                    body.emit(assign(r0618, r0628, 0x01));

                                    body.emit(assign(r0619, body.constant(0u), 0x01));


                                 body.instructions = f0625_parent_instructions;
                                 body.emit(f0625);

                                 /* END IF */


                              body.instructions = f0623_parent_instructions;
                              body.emit(f0623);

                              /* END IF */

                              body.emit(assign(r061A, body.constant(0u), 0x01));


                           body.instructions = f061F_parent_instructions;
                           body.emit(f061F);

                           /* END IF */

                           ir_expression *const r062D = nequal(r0616, body.constant(0u));
                           ir_expression *const r062E = expr(ir_unop_b2i, r062D);
                           ir_expression *const r062F = expr(ir_unop_i2u, r062E);
                           body.emit(assign(r0618, bit_or(r0618, r062F), 0x01));


                        body.instructions = f061D_parent_instructions;
                        body.emit(f061D);

                        /* END IF */

                        body.emit(assign(r0600, r061A, 0x01));

                        body.emit(assign(r0601, r0619, 0x01));

                        body.emit(assign(r0602, r0618, 0x01));

                        body.emit(assign(r05FF, body.constant(int(0)), 0x01));

                        body.emit(assign(r0605, less(r0618, body.constant(0u)), 0x01));


                     body.instructions = f0614_parent_instructions;
                     body.emit(f0614);

                     /* END IF */


                  body.instructions = f0611_parent_instructions;
                  body.emit(f0611);

                  /* END IF */


               body.instructions = f0607_parent_instructions;
               body.emit(f0607);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0630 = new(mem_ctx) ir_if(operand(r0603).val);
               exec_list *const f0630_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0630->then_instructions;

                  /* IF CONDITION */
                  ir_if *f0631 = new(mem_ctx) ir_if(operand(r0605).val);
                  exec_list *const f0631_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0631->then_instructions;

                     ir_variable *const r0632 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r0632, add(r0601, body.constant(1u)), 0x01));

                     ir_expression *const r0633 = less(r0632, r0601);
                     ir_expression *const r0634 = expr(ir_unop_b2i, r0633);
                     ir_expression *const r0635 = expr(ir_unop_i2u, r0634);
                     body.emit(assign(r0600, add(r0600, r0635), 0x01));

                     ir_expression *const r0636 = equal(r0602, body.constant(0u));
                     ir_expression *const r0637 = expr(ir_unop_b2i, r0636);
                     ir_expression *const r0638 = expr(ir_unop_i2u, r0637);
                     ir_expression *const r0639 = add(r0602, r0638);
                     ir_expression *const r063A = bit_and(r0639, body.constant(1u));
                     ir_expression *const r063B = expr(ir_unop_bit_not, r063A);
                     body.emit(assign(r0601, bit_and(r0632, r063B), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0631->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r063D = bit_or(r0600, r0601);
                     ir_expression *const r063E = equal(r063D, body.constant(0u));
                     ir_if *f063C = new(mem_ctx) ir_if(operand(r063E).val);
                     exec_list *const f063C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f063C->then_instructions;

                        body.emit(assign(r05FF, body.constant(int(0)), 0x01));


                     body.instructions = f063C_parent_instructions;
                     body.emit(f063C);

                     /* END IF */


                  body.instructions = f0631_parent_instructions;
                  body.emit(f0631);

                  /* END IF */

                  ir_variable *const r063F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r063F);
                  ir_expression *const r0640 = lshift(r03D1, body.constant(int(31)));
                  ir_expression *const r0641 = expr(ir_unop_i2u, r05FF);
                  ir_expression *const r0642 = lshift(r0641, body.constant(int(20)));
                  ir_expression *const r0643 = add(r0640, r0642);
                  body.emit(assign(r063F, add(r0643, r0600), 0x02));

                  body.emit(assign(r063F, r0601, 0x01));

                  body.emit(assign(r0604, r063F, 0x03));

                  body.emit(assign(r0603, body.constant(false), 0x01));


               body.instructions = f0630_parent_instructions;
               body.emit(f0630);

               /* END IF */

               body.emit(assign(r03D2, r0604, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f05B8->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0645 = less(swizzle_y(r03D7), swizzle_y(r03D5));
               ir_if *f0644 = new(mem_ctx) ir_if(operand(r0645).val);
               exec_list *const f0644_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0644->then_instructions;

                  ir_variable *const r0646 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r0647 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0647, sub(swizzle_x(r03D5), swizzle_x(r03D7)), 0x01));

                  ir_expression *const r0648 = sub(swizzle_y(r03D5), swizzle_y(r03D7));
                  ir_expression *const r0649 = less(swizzle_x(r03D5), swizzle_x(r03D7));
                  ir_expression *const r064A = expr(ir_unop_b2i, r0649);
                  ir_expression *const r064B = expr(ir_unop_i2u, r064A);
                  body.emit(assign(r0646, sub(r0648, r064B), 0x01));

                  body.emit(assign(r03D1, bit_xor(r03D1, body.constant(1u)), 0x01));

                  body.emit(assign(r03D8, add(r03D4, body.constant(int(-1))), 0x01));

                  ir_variable *const r064C = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r064C, add(r03D8, body.constant(int(-10))), 0x01));

                  ir_variable *const r064D = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r064D, r0646, 0x01));

                  ir_variable *const r064E = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r064E, r0647, 0x01));

                  ir_variable *const r064F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r064F);
                  ir_variable *const r0650 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0650);
                  /* IF CONDITION */
                  ir_expression *const r0652 = equal(r0646, body.constant(0u));
                  ir_if *f0651 = new(mem_ctx) ir_if(operand(r0652).val);
                  exec_list *const f0651_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0651->then_instructions;

                     body.emit(assign(r064D, r0647, 0x01));

                     body.emit(assign(r064E, body.constant(0u), 0x01));

                     body.emit(assign(r064C, add(r064C, body.constant(int(-32))), 0x01));


                  body.instructions = f0651_parent_instructions;
                  body.emit(f0651);

                  /* END IF */

                  ir_variable *const r0653 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r0653, r064D, 0x01));

                  ir_variable *const r0654 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r0655 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0655);
                  /* IF CONDITION */
                  ir_expression *const r0657 = equal(r064D, body.constant(0u));
                  ir_if *f0656 = new(mem_ctx) ir_if(operand(r0657).val);
                  exec_list *const f0656_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0656->then_instructions;

                     body.emit(assign(r0654, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0656->else_instructions;

                     body.emit(assign(r0655, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0659 = bit_and(r064D, body.constant(4294901760u));
                     ir_expression *const r065A = equal(r0659, body.constant(0u));
                     ir_if *f0658 = new(mem_ctx) ir_if(operand(r065A).val);
                     exec_list *const f0658_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0658->then_instructions;

                        body.emit(assign(r0655, body.constant(int(16)), 0x01));

                        body.emit(assign(r0653, lshift(r064D, body.constant(int(16))), 0x01));


                     body.instructions = f0658_parent_instructions;
                     body.emit(f0658);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r065C = bit_and(r0653, body.constant(4278190080u));
                     ir_expression *const r065D = equal(r065C, body.constant(0u));
                     ir_if *f065B = new(mem_ctx) ir_if(operand(r065D).val);
                     exec_list *const f065B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f065B->then_instructions;

                        body.emit(assign(r0655, add(r0655, body.constant(int(8))), 0x01));

                        body.emit(assign(r0653, lshift(r0653, body.constant(int(8))), 0x01));


                     body.instructions = f065B_parent_instructions;
                     body.emit(f065B);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r065F = bit_and(r0653, body.constant(4026531840u));
                     ir_expression *const r0660 = equal(r065F, body.constant(0u));
                     ir_if *f065E = new(mem_ctx) ir_if(operand(r0660).val);
                     exec_list *const f065E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f065E->then_instructions;

                        body.emit(assign(r0655, add(r0655, body.constant(int(4))), 0x01));

                        body.emit(assign(r0653, lshift(r0653, body.constant(int(4))), 0x01));


                     body.instructions = f065E_parent_instructions;
                     body.emit(f065E);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0662 = bit_and(r0653, body.constant(3221225472u));
                     ir_expression *const r0663 = equal(r0662, body.constant(0u));
                     ir_if *f0661 = new(mem_ctx) ir_if(operand(r0663).val);
                     exec_list *const f0661_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0661->then_instructions;

                        body.emit(assign(r0655, add(r0655, body.constant(int(2))), 0x01));

                        body.emit(assign(r0653, lshift(r0653, body.constant(int(2))), 0x01));


                     body.instructions = f0661_parent_instructions;
                     body.emit(f0661);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0665 = bit_and(r0653, body.constant(2147483648u));
                     ir_expression *const r0666 = equal(r0665, body.constant(0u));
                     ir_if *f0664 = new(mem_ctx) ir_if(operand(r0666).val);
                     exec_list *const f0664_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0664->then_instructions;

                        body.emit(assign(r0655, add(r0655, body.constant(int(1))), 0x01));


                     body.instructions = f0664_parent_instructions;
                     body.emit(f0664);

                     /* END IF */

                     body.emit(assign(r0654, r0655, 0x01));


                  body.instructions = f0656_parent_instructions;
                  body.emit(f0656);

                  /* END IF */

                  body.emit(assign(r0650, add(r0654, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0668 = lequal(body.constant(int(0)), r0650);
                  ir_if *f0667 = new(mem_ctx) ir_if(operand(r0668).val);
                  exec_list *const f0667_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0667->then_instructions;

                     body.emit(assign(r064F, body.constant(0u), 0x01));

                     ir_variable *const r0669 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r0669, lshift(r064E, r0650), 0x01));

                     ir_variable *const r066A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r066C = equal(r0650, body.constant(int(0)));
                     ir_if *f066B = new(mem_ctx) ir_if(operand(r066C).val);
                     exec_list *const f066B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f066B->then_instructions;

                        body.emit(assign(r066A, r064D, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f066B->else_instructions;

                        ir_expression *const r066D = lshift(r064D, r0650);
                        ir_expression *const r066E = neg(r0650);
                        ir_expression *const r066F = bit_and(r066E, body.constant(int(31)));
                        ir_expression *const r0670 = rshift(r064E, r066F);
                        body.emit(assign(r066A, bit_or(r066D, r0670), 0x01));


                     body.instructions = f066B_parent_instructions;
                     body.emit(f066B);

                     /* END IF */

                     body.emit(assign(r064D, r066A, 0x01));

                     body.emit(assign(r064E, r0669, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0667->else_instructions;

                     ir_variable *const r0671 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0671, body.constant(0u), 0x01));

                     ir_variable *const r0672 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0672, neg(r0650), 0x01));

                     ir_variable *const r0673 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0673);
                     ir_variable *const r0674 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0674);
                     ir_variable *const r0675 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0675);
                     ir_variable *const r0676 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0677 = neg(r0672);
                     body.emit(assign(r0676, bit_and(r0677, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0679 = equal(r0672, body.constant(int(0)));
                     ir_if *f0678 = new(mem_ctx) ir_if(operand(r0679).val);
                     exec_list *const f0678_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0678->then_instructions;

                        body.emit(assign(r0673, r0671, 0x01));

                        body.emit(assign(r0674, r064E, 0x01));

                        body.emit(assign(r0675, r064D, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0678->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r067B = less(r0672, body.constant(int(32)));
                        ir_if *f067A = new(mem_ctx) ir_if(operand(r067B).val);
                        exec_list *const f067A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f067A->then_instructions;

                           body.emit(assign(r0673, lshift(r064E, r0676), 0x01));

                           ir_expression *const r067C = lshift(r064D, r0676);
                           ir_expression *const r067D = rshift(r064E, r0672);
                           body.emit(assign(r0674, bit_or(r067C, r067D), 0x01));

                           body.emit(assign(r0675, rshift(r064D, r0672), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f067A->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r067F = equal(r0672, body.constant(int(32)));
                           ir_if *f067E = new(mem_ctx) ir_if(operand(r067F).val);
                           exec_list *const f067E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f067E->then_instructions;

                              body.emit(assign(r0673, r064E, 0x01));

                              body.emit(assign(r0674, r064D, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f067E->else_instructions;

                              body.emit(assign(r0671, bit_or(body.constant(0u), r064E), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0681 = less(r0672, body.constant(int(64)));
                              ir_if *f0680 = new(mem_ctx) ir_if(operand(r0681).val);
                              exec_list *const f0680_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0680->then_instructions;

                                 body.emit(assign(r0673, lshift(r064D, r0676), 0x01));

                                 ir_expression *const r0682 = bit_and(r0672, body.constant(int(31)));
                                 body.emit(assign(r0674, rshift(r064D, r0682), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0680->else_instructions;

                                 ir_variable *const r0683 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0685 = equal(r0672, body.constant(int(64)));
                                 ir_if *f0684 = new(mem_ctx) ir_if(operand(r0685).val);
                                 exec_list *const f0684_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0684->then_instructions;

                                    body.emit(assign(r0683, r064D, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0684->else_instructions;

                                    ir_expression *const r0686 = nequal(r064D, body.constant(0u));
                                    ir_expression *const r0687 = expr(ir_unop_b2i, r0686);
                                    body.emit(assign(r0683, expr(ir_unop_i2u, r0687), 0x01));


                                 body.instructions = f0684_parent_instructions;
                                 body.emit(f0684);

                                 /* END IF */

                                 body.emit(assign(r0673, r0683, 0x01));

                                 body.emit(assign(r0674, body.constant(0u), 0x01));


                              body.instructions = f0680_parent_instructions;
                              body.emit(f0680);

                              /* END IF */


                           body.instructions = f067E_parent_instructions;
                           body.emit(f067E);

                           /* END IF */

                           body.emit(assign(r0675, body.constant(0u), 0x01));


                        body.instructions = f067A_parent_instructions;
                        body.emit(f067A);

                        /* END IF */

                        ir_expression *const r0688 = nequal(r0671, body.constant(0u));
                        ir_expression *const r0689 = expr(ir_unop_b2i, r0688);
                        ir_expression *const r068A = expr(ir_unop_i2u, r0689);
                        body.emit(assign(r0673, bit_or(r0673, r068A), 0x01));


                     body.instructions = f0678_parent_instructions;
                     body.emit(f0678);

                     /* END IF */

                     body.emit(assign(r064D, r0675, 0x01));

                     body.emit(assign(r064E, r0674, 0x01));

                     body.emit(assign(r064F, r0673, 0x01));


                  body.instructions = f0667_parent_instructions;
                  body.emit(f0667);

                  /* END IF */

                  body.emit(assign(r064C, sub(r064C, r0650), 0x01));

                  ir_variable *const r068B = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r068B, r064C, 0x01));

                  ir_variable *const r068C = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r068C, r064D, 0x01));

                  ir_variable *const r068D = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r068D, r064E, 0x01));

                  ir_variable *const r068E = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r068E, r064F, 0x01));

                  ir_variable *const r068F = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r068F, body.constant(true), 0x01));

                  ir_variable *const r0690 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0691 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r0691);
                  ir_expression *const r0692 = expr(ir_unop_u2i, r064F);
                  body.emit(assign(r0691, less(r0692, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0694 = lequal(body.constant(int(2045)), r064C);
                  ir_if *f0693 = new(mem_ctx) ir_if(operand(r0694).val);
                  exec_list *const f0693_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0693->then_instructions;

                     ir_variable *const r0695 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0697 = less(body.constant(int(2045)), r064C);
                     ir_if *f0696 = new(mem_ctx) ir_if(operand(r0697).val);
                     exec_list *const f0696_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0696->then_instructions;

                        body.emit(assign(r0695, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0696->else_instructions;

                        ir_variable *const r0698 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r069A = equal(r064C, body.constant(int(2045)));
                        ir_if *f0699 = new(mem_ctx) ir_if(operand(r069A).val);
                        exec_list *const f0699_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0699->then_instructions;

                           ir_expression *const r069B = equal(body.constant(2097151u), r064D);
                           ir_expression *const r069C = equal(body.constant(4294967295u), r064E);
                           body.emit(assign(r0698, logic_and(r069B, r069C), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0699->else_instructions;

                           body.emit(assign(r0698, body.constant(false), 0x01));


                        body.instructions = f0699_parent_instructions;
                        body.emit(f0699);

                        /* END IF */

                        body.emit(assign(r0695, logic_and(r0698, r0691), 0x01));


                     body.instructions = f0696_parent_instructions;
                     body.emit(f0696);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f069D = new(mem_ctx) ir_if(operand(r0695).val);
                     exec_list *const f069D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f069D->then_instructions;

                        ir_variable *const r069E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r069E);
                        ir_expression *const r069F = lshift(r03D1, body.constant(int(31)));
                        body.emit(assign(r069E, add(r069F, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r069E, body.constant(0u), 0x01));

                        body.emit(assign(r0690, r069E, 0x03));

                        body.emit(assign(r068F, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f069D->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r06A1 = less(r064C, body.constant(int(0)));
                        ir_if *f06A0 = new(mem_ctx) ir_if(operand(r06A1).val);
                        exec_list *const f06A0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06A0->then_instructions;

                           ir_variable *const r06A2 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r06A2, r064F, 0x01));

                           ir_variable *const r06A3 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r06A3, neg(r064C), 0x01));

                           ir_variable *const r06A4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r06A4);
                           ir_variable *const r06A5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r06A5);
                           ir_variable *const r06A6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r06A6);
                           ir_variable *const r06A7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r06A8 = neg(r06A3);
                           body.emit(assign(r06A7, bit_and(r06A8, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r06AA = equal(r06A3, body.constant(int(0)));
                           ir_if *f06A9 = new(mem_ctx) ir_if(operand(r06AA).val);
                           exec_list *const f06A9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f06A9->then_instructions;

                              body.emit(assign(r06A4, r064F, 0x01));

                              body.emit(assign(r06A5, r064E, 0x01));

                              body.emit(assign(r06A6, r064D, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f06A9->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r06AC = less(r06A3, body.constant(int(32)));
                              ir_if *f06AB = new(mem_ctx) ir_if(operand(r06AC).val);
                              exec_list *const f06AB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f06AB->then_instructions;

                                 body.emit(assign(r06A4, lshift(r064E, r06A7), 0x01));

                                 ir_expression *const r06AD = lshift(r064D, r06A7);
                                 ir_expression *const r06AE = rshift(r064E, r06A3);
                                 body.emit(assign(r06A5, bit_or(r06AD, r06AE), 0x01));

                                 body.emit(assign(r06A6, rshift(r064D, r06A3), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f06AB->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r06B0 = equal(r06A3, body.constant(int(32)));
                                 ir_if *f06AF = new(mem_ctx) ir_if(operand(r06B0).val);
                                 exec_list *const f06AF_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f06AF->then_instructions;

                                    body.emit(assign(r06A4, r064E, 0x01));

                                    body.emit(assign(r06A5, r064D, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f06AF->else_instructions;

                                    body.emit(assign(r06A2, bit_or(r064F, r064E), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r06B2 = less(r06A3, body.constant(int(64)));
                                    ir_if *f06B1 = new(mem_ctx) ir_if(operand(r06B2).val);
                                    exec_list *const f06B1_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f06B1->then_instructions;

                                       body.emit(assign(r06A4, lshift(r064D, r06A7), 0x01));

                                       ir_expression *const r06B3 = bit_and(r06A3, body.constant(int(31)));
                                       body.emit(assign(r06A5, rshift(r064D, r06B3), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f06B1->else_instructions;

                                       ir_variable *const r06B4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r06B6 = equal(r06A3, body.constant(int(64)));
                                       ir_if *f06B5 = new(mem_ctx) ir_if(operand(r06B6).val);
                                       exec_list *const f06B5_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f06B5->then_instructions;

                                          body.emit(assign(r06B4, r064D, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f06B5->else_instructions;

                                          ir_expression *const r06B7 = nequal(r064D, body.constant(0u));
                                          ir_expression *const r06B8 = expr(ir_unop_b2i, r06B7);
                                          body.emit(assign(r06B4, expr(ir_unop_i2u, r06B8), 0x01));


                                       body.instructions = f06B5_parent_instructions;
                                       body.emit(f06B5);

                                       /* END IF */

                                       body.emit(assign(r06A4, r06B4, 0x01));

                                       body.emit(assign(r06A5, body.constant(0u), 0x01));


                                    body.instructions = f06B1_parent_instructions;
                                    body.emit(f06B1);

                                    /* END IF */


                                 body.instructions = f06AF_parent_instructions;
                                 body.emit(f06AF);

                                 /* END IF */

                                 body.emit(assign(r06A6, body.constant(0u), 0x01));


                              body.instructions = f06AB_parent_instructions;
                              body.emit(f06AB);

                              /* END IF */

                              ir_expression *const r06B9 = nequal(r06A2, body.constant(0u));
                              ir_expression *const r06BA = expr(ir_unop_b2i, r06B9);
                              ir_expression *const r06BB = expr(ir_unop_i2u, r06BA);
                              body.emit(assign(r06A4, bit_or(r06A4, r06BB), 0x01));


                           body.instructions = f06A9_parent_instructions;
                           body.emit(f06A9);

                           /* END IF */

                           body.emit(assign(r068C, r06A6, 0x01));

                           body.emit(assign(r068D, r06A5, 0x01));

                           body.emit(assign(r068E, r06A4, 0x01));

                           body.emit(assign(r068B, body.constant(int(0)), 0x01));

                           body.emit(assign(r0691, less(r06A4, body.constant(0u)), 0x01));


                        body.instructions = f06A0_parent_instructions;
                        body.emit(f06A0);

                        /* END IF */


                     body.instructions = f069D_parent_instructions;
                     body.emit(f069D);

                     /* END IF */


                  body.instructions = f0693_parent_instructions;
                  body.emit(f0693);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f06BC = new(mem_ctx) ir_if(operand(r068F).val);
                  exec_list *const f06BC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f06BC->then_instructions;

                     /* IF CONDITION */
                     ir_if *f06BD = new(mem_ctx) ir_if(operand(r0691).val);
                     exec_list *const f06BD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f06BD->then_instructions;

                        ir_variable *const r06BE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r06BE, add(r068D, body.constant(1u)), 0x01));

                        ir_expression *const r06BF = less(r06BE, r068D);
                        ir_expression *const r06C0 = expr(ir_unop_b2i, r06BF);
                        ir_expression *const r06C1 = expr(ir_unop_i2u, r06C0);
                        body.emit(assign(r068C, add(r068C, r06C1), 0x01));

                        ir_expression *const r06C2 = equal(r068E, body.constant(0u));
                        ir_expression *const r06C3 = expr(ir_unop_b2i, r06C2);
                        ir_expression *const r06C4 = expr(ir_unop_i2u, r06C3);
                        ir_expression *const r06C5 = add(r068E, r06C4);
                        ir_expression *const r06C6 = bit_and(r06C5, body.constant(1u));
                        ir_expression *const r06C7 = expr(ir_unop_bit_not, r06C6);
                        body.emit(assign(r068D, bit_and(r06BE, r06C7), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f06BD->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r06C9 = bit_or(r068C, r068D);
                        ir_expression *const r06CA = equal(r06C9, body.constant(0u));
                        ir_if *f06C8 = new(mem_ctx) ir_if(operand(r06CA).val);
                        exec_list *const f06C8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06C8->then_instructions;

                           body.emit(assign(r068B, body.constant(int(0)), 0x01));


                        body.instructions = f06C8_parent_instructions;
                        body.emit(f06C8);

                        /* END IF */


                     body.instructions = f06BD_parent_instructions;
                     body.emit(f06BD);

                     /* END IF */

                     ir_variable *const r06CB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r06CB);
                     ir_expression *const r06CC = lshift(r03D1, body.constant(int(31)));
                     ir_expression *const r06CD = expr(ir_unop_i2u, r068B);
                     ir_expression *const r06CE = lshift(r06CD, body.constant(int(20)));
                     ir_expression *const r06CF = add(r06CC, r06CE);
                     body.emit(assign(r06CB, add(r06CF, r068C), 0x02));

                     body.emit(assign(r06CB, r068D, 0x01));

                     body.emit(assign(r0690, r06CB, 0x03));

                     body.emit(assign(r068F, body.constant(false), 0x01));


                  body.instructions = f06BC_parent_instructions;
                  body.emit(f06BC);

                  /* END IF */

                  body.emit(assign(r03D2, r0690, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0644->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r06D1 = less(swizzle_x(r03D5), swizzle_x(r03D7));
                  ir_if *f06D0 = new(mem_ctx) ir_if(operand(r06D1).val);
                  exec_list *const f06D0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f06D0->then_instructions;

                     ir_variable *const r06D2 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r06D3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r06D3, sub(swizzle_x(r03D7), swizzle_x(r03D5)), 0x01));

                     ir_expression *const r06D4 = sub(swizzle_y(r03D7), swizzle_y(r03D5));
                     ir_expression *const r06D5 = less(swizzle_x(r03D7), swizzle_x(r03D5));
                     ir_expression *const r06D6 = expr(ir_unop_b2i, r06D5);
                     ir_expression *const r06D7 = expr(ir_unop_i2u, r06D6);
                     body.emit(assign(r06D2, sub(r06D4, r06D7), 0x01));

                     body.emit(assign(r03D8, add(r03D6, body.constant(int(-1))), 0x01));

                     ir_variable *const r06D8 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r06D8, add(r03D8, body.constant(int(-10))), 0x01));

                     ir_variable *const r06D9 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r06D9, r06D2, 0x01));

                     ir_variable *const r06DA = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r06DA, r06D3, 0x01));

                     ir_variable *const r06DB = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r06DB);
                     ir_variable *const r06DC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r06DC);
                     /* IF CONDITION */
                     ir_expression *const r06DE = equal(r06D2, body.constant(0u));
                     ir_if *f06DD = new(mem_ctx) ir_if(operand(r06DE).val);
                     exec_list *const f06DD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f06DD->then_instructions;

                        body.emit(assign(r06D9, r06D3, 0x01));

                        body.emit(assign(r06DA, body.constant(0u), 0x01));

                        body.emit(assign(r06D8, add(r06D8, body.constant(int(-32))), 0x01));


                     body.instructions = f06DD_parent_instructions;
                     body.emit(f06DD);

                     /* END IF */

                     ir_variable *const r06DF = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r06DF, r06D9, 0x01));

                     ir_variable *const r06E0 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r06E1 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r06E1);
                     /* IF CONDITION */
                     ir_expression *const r06E3 = equal(r06D9, body.constant(0u));
                     ir_if *f06E2 = new(mem_ctx) ir_if(operand(r06E3).val);
                     exec_list *const f06E2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f06E2->then_instructions;

                        body.emit(assign(r06E0, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f06E2->else_instructions;

                        body.emit(assign(r06E1, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r06E5 = bit_and(r06D9, body.constant(4294901760u));
                        ir_expression *const r06E6 = equal(r06E5, body.constant(0u));
                        ir_if *f06E4 = new(mem_ctx) ir_if(operand(r06E6).val);
                        exec_list *const f06E4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06E4->then_instructions;

                           body.emit(assign(r06E1, body.constant(int(16)), 0x01));

                           body.emit(assign(r06DF, lshift(r06D9, body.constant(int(16))), 0x01));


                        body.instructions = f06E4_parent_instructions;
                        body.emit(f06E4);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r06E8 = bit_and(r06DF, body.constant(4278190080u));
                        ir_expression *const r06E9 = equal(r06E8, body.constant(0u));
                        ir_if *f06E7 = new(mem_ctx) ir_if(operand(r06E9).val);
                        exec_list *const f06E7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06E7->then_instructions;

                           body.emit(assign(r06E1, add(r06E1, body.constant(int(8))), 0x01));

                           body.emit(assign(r06DF, lshift(r06DF, body.constant(int(8))), 0x01));


                        body.instructions = f06E7_parent_instructions;
                        body.emit(f06E7);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r06EB = bit_and(r06DF, body.constant(4026531840u));
                        ir_expression *const r06EC = equal(r06EB, body.constant(0u));
                        ir_if *f06EA = new(mem_ctx) ir_if(operand(r06EC).val);
                        exec_list *const f06EA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06EA->then_instructions;

                           body.emit(assign(r06E1, add(r06E1, body.constant(int(4))), 0x01));

                           body.emit(assign(r06DF, lshift(r06DF, body.constant(int(4))), 0x01));


                        body.instructions = f06EA_parent_instructions;
                        body.emit(f06EA);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r06EE = bit_and(r06DF, body.constant(3221225472u));
                        ir_expression *const r06EF = equal(r06EE, body.constant(0u));
                        ir_if *f06ED = new(mem_ctx) ir_if(operand(r06EF).val);
                        exec_list *const f06ED_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06ED->then_instructions;

                           body.emit(assign(r06E1, add(r06E1, body.constant(int(2))), 0x01));

                           body.emit(assign(r06DF, lshift(r06DF, body.constant(int(2))), 0x01));


                        body.instructions = f06ED_parent_instructions;
                        body.emit(f06ED);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r06F1 = bit_and(r06DF, body.constant(2147483648u));
                        ir_expression *const r06F2 = equal(r06F1, body.constant(0u));
                        ir_if *f06F0 = new(mem_ctx) ir_if(operand(r06F2).val);
                        exec_list *const f06F0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06F0->then_instructions;

                           body.emit(assign(r06E1, add(r06E1, body.constant(int(1))), 0x01));


                        body.instructions = f06F0_parent_instructions;
                        body.emit(f06F0);

                        /* END IF */

                        body.emit(assign(r06E0, r06E1, 0x01));


                     body.instructions = f06E2_parent_instructions;
                     body.emit(f06E2);

                     /* END IF */

                     body.emit(assign(r06DC, add(r06E0, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r06F4 = lequal(body.constant(int(0)), r06DC);
                     ir_if *f06F3 = new(mem_ctx) ir_if(operand(r06F4).val);
                     exec_list *const f06F3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f06F3->then_instructions;

                        body.emit(assign(r06DB, body.constant(0u), 0x01));

                        ir_variable *const r06F5 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r06F5, lshift(r06DA, r06DC), 0x01));

                        ir_variable *const r06F6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r06F8 = equal(r06DC, body.constant(int(0)));
                        ir_if *f06F7 = new(mem_ctx) ir_if(operand(r06F8).val);
                        exec_list *const f06F7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06F7->then_instructions;

                           body.emit(assign(r06F6, r06D9, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f06F7->else_instructions;

                           ir_expression *const r06F9 = lshift(r06D9, r06DC);
                           ir_expression *const r06FA = neg(r06DC);
                           ir_expression *const r06FB = bit_and(r06FA, body.constant(int(31)));
                           ir_expression *const r06FC = rshift(r06DA, r06FB);
                           body.emit(assign(r06F6, bit_or(r06F9, r06FC), 0x01));


                        body.instructions = f06F7_parent_instructions;
                        body.emit(f06F7);

                        /* END IF */

                        body.emit(assign(r06D9, r06F6, 0x01));

                        body.emit(assign(r06DA, r06F5, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f06F3->else_instructions;

                        ir_variable *const r06FD = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r06FD, body.constant(0u), 0x01));

                        ir_variable *const r06FE = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r06FE, neg(r06DC), 0x01));

                        ir_variable *const r06FF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r06FF);
                        ir_variable *const r0700 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0700);
                        ir_variable *const r0701 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0701);
                        ir_variable *const r0702 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r0703 = neg(r06FE);
                        body.emit(assign(r0702, bit_and(r0703, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0705 = equal(r06FE, body.constant(int(0)));
                        ir_if *f0704 = new(mem_ctx) ir_if(operand(r0705).val);
                        exec_list *const f0704_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0704->then_instructions;

                           body.emit(assign(r06FF, r06FD, 0x01));

                           body.emit(assign(r0700, r06DA, 0x01));

                           body.emit(assign(r0701, r06D9, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0704->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0707 = less(r06FE, body.constant(int(32)));
                           ir_if *f0706 = new(mem_ctx) ir_if(operand(r0707).val);
                           exec_list *const f0706_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0706->then_instructions;

                              body.emit(assign(r06FF, lshift(r06DA, r0702), 0x01));

                              ir_expression *const r0708 = lshift(r06D9, r0702);
                              ir_expression *const r0709 = rshift(r06DA, r06FE);
                              body.emit(assign(r0700, bit_or(r0708, r0709), 0x01));

                              body.emit(assign(r0701, rshift(r06D9, r06FE), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0706->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r070B = equal(r06FE, body.constant(int(32)));
                              ir_if *f070A = new(mem_ctx) ir_if(operand(r070B).val);
                              exec_list *const f070A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f070A->then_instructions;

                                 body.emit(assign(r06FF, r06DA, 0x01));

                                 body.emit(assign(r0700, r06D9, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f070A->else_instructions;

                                 body.emit(assign(r06FD, bit_or(body.constant(0u), r06DA), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r070D = less(r06FE, body.constant(int(64)));
                                 ir_if *f070C = new(mem_ctx) ir_if(operand(r070D).val);
                                 exec_list *const f070C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f070C->then_instructions;

                                    body.emit(assign(r06FF, lshift(r06D9, r0702), 0x01));

                                    ir_expression *const r070E = bit_and(r06FE, body.constant(int(31)));
                                    body.emit(assign(r0700, rshift(r06D9, r070E), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f070C->else_instructions;

                                    ir_variable *const r070F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r0711 = equal(r06FE, body.constant(int(64)));
                                    ir_if *f0710 = new(mem_ctx) ir_if(operand(r0711).val);
                                    exec_list *const f0710_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0710->then_instructions;

                                       body.emit(assign(r070F, r06D9, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0710->else_instructions;

                                       ir_expression *const r0712 = nequal(r06D9, body.constant(0u));
                                       ir_expression *const r0713 = expr(ir_unop_b2i, r0712);
                                       body.emit(assign(r070F, expr(ir_unop_i2u, r0713), 0x01));


                                    body.instructions = f0710_parent_instructions;
                                    body.emit(f0710);

                                    /* END IF */

                                    body.emit(assign(r06FF, r070F, 0x01));

                                    body.emit(assign(r0700, body.constant(0u), 0x01));


                                 body.instructions = f070C_parent_instructions;
                                 body.emit(f070C);

                                 /* END IF */


                              body.instructions = f070A_parent_instructions;
                              body.emit(f070A);

                              /* END IF */

                              body.emit(assign(r0701, body.constant(0u), 0x01));


                           body.instructions = f0706_parent_instructions;
                           body.emit(f0706);

                           /* END IF */

                           ir_expression *const r0714 = nequal(r06FD, body.constant(0u));
                           ir_expression *const r0715 = expr(ir_unop_b2i, r0714);
                           ir_expression *const r0716 = expr(ir_unop_i2u, r0715);
                           body.emit(assign(r06FF, bit_or(r06FF, r0716), 0x01));


                        body.instructions = f0704_parent_instructions;
                        body.emit(f0704);

                        /* END IF */

                        body.emit(assign(r06D9, r0701, 0x01));

                        body.emit(assign(r06DA, r0700, 0x01));

                        body.emit(assign(r06DB, r06FF, 0x01));


                     body.instructions = f06F3_parent_instructions;
                     body.emit(f06F3);

                     /* END IF */

                     body.emit(assign(r06D8, sub(r06D8, r06DC), 0x01));

                     ir_variable *const r0717 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r0717, r06D8, 0x01));

                     ir_variable *const r0718 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r0718, r06D9, 0x01));

                     ir_variable *const r0719 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r0719, r06DA, 0x01));

                     ir_variable *const r071A = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r071A, r06DB, 0x01));

                     ir_variable *const r071B = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r071B, body.constant(true), 0x01));

                     ir_variable *const r071C = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r071D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r071D);
                     ir_expression *const r071E = expr(ir_unop_u2i, r06DB);
                     body.emit(assign(r071D, less(r071E, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0720 = lequal(body.constant(int(2045)), r06D8);
                     ir_if *f071F = new(mem_ctx) ir_if(operand(r0720).val);
                     exec_list *const f071F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f071F->then_instructions;

                        ir_variable *const r0721 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0723 = less(body.constant(int(2045)), r06D8);
                        ir_if *f0722 = new(mem_ctx) ir_if(operand(r0723).val);
                        exec_list *const f0722_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0722->then_instructions;

                           body.emit(assign(r0721, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0722->else_instructions;

                           ir_variable *const r0724 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0726 = equal(r06D8, body.constant(int(2045)));
                           ir_if *f0725 = new(mem_ctx) ir_if(operand(r0726).val);
                           exec_list *const f0725_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0725->then_instructions;

                              ir_expression *const r0727 = equal(body.constant(2097151u), r06D9);
                              ir_expression *const r0728 = equal(body.constant(4294967295u), r06DA);
                              body.emit(assign(r0724, logic_and(r0727, r0728), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0725->else_instructions;

                              body.emit(assign(r0724, body.constant(false), 0x01));


                           body.instructions = f0725_parent_instructions;
                           body.emit(f0725);

                           /* END IF */

                           body.emit(assign(r0721, logic_and(r0724, r071D), 0x01));


                        body.instructions = f0722_parent_instructions;
                        body.emit(f0722);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f0729 = new(mem_ctx) ir_if(operand(r0721).val);
                        exec_list *const f0729_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0729->then_instructions;

                           ir_variable *const r072A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r072A);
                           ir_expression *const r072B = lshift(r03D1, body.constant(int(31)));
                           body.emit(assign(r072A, add(r072B, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r072A, body.constant(0u), 0x01));

                           body.emit(assign(r071C, r072A, 0x03));

                           body.emit(assign(r071B, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0729->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r072D = less(r06D8, body.constant(int(0)));
                           ir_if *f072C = new(mem_ctx) ir_if(operand(r072D).val);
                           exec_list *const f072C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f072C->then_instructions;

                              ir_variable *const r072E = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r072E, r06DB, 0x01));

                              ir_variable *const r072F = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r072F, neg(r06D8), 0x01));

                              ir_variable *const r0730 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r0730);
                              ir_variable *const r0731 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r0731);
                              ir_variable *const r0732 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r0732);
                              ir_variable *const r0733 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r0734 = neg(r072F);
                              body.emit(assign(r0733, bit_and(r0734, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0736 = equal(r072F, body.constant(int(0)));
                              ir_if *f0735 = new(mem_ctx) ir_if(operand(r0736).val);
                              exec_list *const f0735_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0735->then_instructions;

                                 body.emit(assign(r0730, r06DB, 0x01));

                                 body.emit(assign(r0731, r06DA, 0x01));

                                 body.emit(assign(r0732, r06D9, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0735->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0738 = less(r072F, body.constant(int(32)));
                                 ir_if *f0737 = new(mem_ctx) ir_if(operand(r0738).val);
                                 exec_list *const f0737_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0737->then_instructions;

                                    body.emit(assign(r0730, lshift(r06DA, r0733), 0x01));

                                    ir_expression *const r0739 = lshift(r06D9, r0733);
                                    ir_expression *const r073A = rshift(r06DA, r072F);
                                    body.emit(assign(r0731, bit_or(r0739, r073A), 0x01));

                                    body.emit(assign(r0732, rshift(r06D9, r072F), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0737->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r073C = equal(r072F, body.constant(int(32)));
                                    ir_if *f073B = new(mem_ctx) ir_if(operand(r073C).val);
                                    exec_list *const f073B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f073B->then_instructions;

                                       body.emit(assign(r0730, r06DA, 0x01));

                                       body.emit(assign(r0731, r06D9, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f073B->else_instructions;

                                       body.emit(assign(r072E, bit_or(r06DB, r06DA), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r073E = less(r072F, body.constant(int(64)));
                                       ir_if *f073D = new(mem_ctx) ir_if(operand(r073E).val);
                                       exec_list *const f073D_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f073D->then_instructions;

                                          body.emit(assign(r0730, lshift(r06D9, r0733), 0x01));

                                          ir_expression *const r073F = bit_and(r072F, body.constant(int(31)));
                                          body.emit(assign(r0731, rshift(r06D9, r073F), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f073D->else_instructions;

                                          ir_variable *const r0740 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r0742 = equal(r072F, body.constant(int(64)));
                                          ir_if *f0741 = new(mem_ctx) ir_if(operand(r0742).val);
                                          exec_list *const f0741_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0741->then_instructions;

                                             body.emit(assign(r0740, r06D9, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0741->else_instructions;

                                             ir_expression *const r0743 = nequal(r06D9, body.constant(0u));
                                             ir_expression *const r0744 = expr(ir_unop_b2i, r0743);
                                             body.emit(assign(r0740, expr(ir_unop_i2u, r0744), 0x01));


                                          body.instructions = f0741_parent_instructions;
                                          body.emit(f0741);

                                          /* END IF */

                                          body.emit(assign(r0730, r0740, 0x01));

                                          body.emit(assign(r0731, body.constant(0u), 0x01));


                                       body.instructions = f073D_parent_instructions;
                                       body.emit(f073D);

                                       /* END IF */


                                    body.instructions = f073B_parent_instructions;
                                    body.emit(f073B);

                                    /* END IF */

                                    body.emit(assign(r0732, body.constant(0u), 0x01));


                                 body.instructions = f0737_parent_instructions;
                                 body.emit(f0737);

                                 /* END IF */

                                 ir_expression *const r0745 = nequal(r072E, body.constant(0u));
                                 ir_expression *const r0746 = expr(ir_unop_b2i, r0745);
                                 ir_expression *const r0747 = expr(ir_unop_i2u, r0746);
                                 body.emit(assign(r0730, bit_or(r0730, r0747), 0x01));


                              body.instructions = f0735_parent_instructions;
                              body.emit(f0735);

                              /* END IF */

                              body.emit(assign(r0718, r0732, 0x01));

                              body.emit(assign(r0719, r0731, 0x01));

                              body.emit(assign(r071A, r0730, 0x01));

                              body.emit(assign(r0717, body.constant(int(0)), 0x01));

                              body.emit(assign(r071D, less(r0730, body.constant(0u)), 0x01));


                           body.instructions = f072C_parent_instructions;
                           body.emit(f072C);

                           /* END IF */


                        body.instructions = f0729_parent_instructions;
                        body.emit(f0729);

                        /* END IF */


                     body.instructions = f071F_parent_instructions;
                     body.emit(f071F);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f0748 = new(mem_ctx) ir_if(operand(r071B).val);
                     exec_list *const f0748_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0748->then_instructions;

                        /* IF CONDITION */
                        ir_if *f0749 = new(mem_ctx) ir_if(operand(r071D).val);
                        exec_list *const f0749_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0749->then_instructions;

                           ir_variable *const r074A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r074A, add(r0719, body.constant(1u)), 0x01));

                           ir_expression *const r074B = less(r074A, r0719);
                           ir_expression *const r074C = expr(ir_unop_b2i, r074B);
                           ir_expression *const r074D = expr(ir_unop_i2u, r074C);
                           body.emit(assign(r0718, add(r0718, r074D), 0x01));

                           ir_expression *const r074E = equal(r071A, body.constant(0u));
                           ir_expression *const r074F = expr(ir_unop_b2i, r074E);
                           ir_expression *const r0750 = expr(ir_unop_i2u, r074F);
                           ir_expression *const r0751 = add(r071A, r0750);
                           ir_expression *const r0752 = bit_and(r0751, body.constant(1u));
                           ir_expression *const r0753 = expr(ir_unop_bit_not, r0752);
                           body.emit(assign(r0719, bit_and(r074A, r0753), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0749->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0755 = bit_or(r0718, r0719);
                           ir_expression *const r0756 = equal(r0755, body.constant(0u));
                           ir_if *f0754 = new(mem_ctx) ir_if(operand(r0756).val);
                           exec_list *const f0754_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0754->then_instructions;

                              body.emit(assign(r0717, body.constant(int(0)), 0x01));


                           body.instructions = f0754_parent_instructions;
                           body.emit(f0754);

                           /* END IF */


                        body.instructions = f0749_parent_instructions;
                        body.emit(f0749);

                        /* END IF */

                        ir_variable *const r0757 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r0757);
                        ir_expression *const r0758 = lshift(r03D1, body.constant(int(31)));
                        ir_expression *const r0759 = expr(ir_unop_i2u, r0717);
                        ir_expression *const r075A = lshift(r0759, body.constant(int(20)));
                        ir_expression *const r075B = add(r0758, r075A);
                        body.emit(assign(r0757, add(r075B, r0718), 0x02));

                        body.emit(assign(r0757, r0719, 0x01));

                        body.emit(assign(r071C, r0757, 0x03));

                        body.emit(assign(r071B, body.constant(false), 0x01));


                     body.instructions = f0748_parent_instructions;
                     body.emit(f0748);

                     /* END IF */

                     body.emit(assign(r03D2, r071C, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f06D0->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r075D = less(swizzle_x(r03D7), swizzle_x(r03D5));
                     ir_if *f075C = new(mem_ctx) ir_if(operand(r075D).val);
                     exec_list *const f075C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f075C->then_instructions;

                        ir_variable *const r075E = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r075F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r075F, sub(swizzle_x(r03D5), swizzle_x(r03D7)), 0x01));

                        ir_expression *const r0760 = sub(swizzle_y(r03D5), swizzle_y(r03D7));
                        ir_expression *const r0761 = less(swizzle_x(r03D5), swizzle_x(r03D7));
                        ir_expression *const r0762 = expr(ir_unop_b2i, r0761);
                        ir_expression *const r0763 = expr(ir_unop_i2u, r0762);
                        body.emit(assign(r075E, sub(r0760, r0763), 0x01));

                        body.emit(assign(r03D1, bit_xor(r03D1, body.constant(1u)), 0x01));

                        body.emit(assign(r03D8, add(r03D4, body.constant(int(-1))), 0x01));

                        ir_variable *const r0764 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r0764, add(r03D8, body.constant(int(-10))), 0x01));

                        ir_variable *const r0765 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r0765, r075E, 0x01));

                        ir_variable *const r0766 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r0766, r075F, 0x01));

                        ir_variable *const r0767 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r0767);
                        ir_variable *const r0768 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r0768);
                        /* IF CONDITION */
                        ir_expression *const r076A = equal(r075E, body.constant(0u));
                        ir_if *f0769 = new(mem_ctx) ir_if(operand(r076A).val);
                        exec_list *const f0769_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0769->then_instructions;

                           body.emit(assign(r0765, r075F, 0x01));

                           body.emit(assign(r0766, body.constant(0u), 0x01));

                           body.emit(assign(r0764, add(r0764, body.constant(int(-32))), 0x01));


                        body.instructions = f0769_parent_instructions;
                        body.emit(f0769);

                        /* END IF */

                        ir_variable *const r076B = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r076B, r0765, 0x01));

                        ir_variable *const r076C = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r076D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r076D);
                        /* IF CONDITION */
                        ir_expression *const r076F = equal(r0765, body.constant(0u));
                        ir_if *f076E = new(mem_ctx) ir_if(operand(r076F).val);
                        exec_list *const f076E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f076E->then_instructions;

                           body.emit(assign(r076C, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f076E->else_instructions;

                           body.emit(assign(r076D, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0771 = bit_and(r0765, body.constant(4294901760u));
                           ir_expression *const r0772 = equal(r0771, body.constant(0u));
                           ir_if *f0770 = new(mem_ctx) ir_if(operand(r0772).val);
                           exec_list *const f0770_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0770->then_instructions;

                              body.emit(assign(r076D, body.constant(int(16)), 0x01));

                              body.emit(assign(r076B, lshift(r0765, body.constant(int(16))), 0x01));


                           body.instructions = f0770_parent_instructions;
                           body.emit(f0770);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0774 = bit_and(r076B, body.constant(4278190080u));
                           ir_expression *const r0775 = equal(r0774, body.constant(0u));
                           ir_if *f0773 = new(mem_ctx) ir_if(operand(r0775).val);
                           exec_list *const f0773_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0773->then_instructions;

                              body.emit(assign(r076D, add(r076D, body.constant(int(8))), 0x01));

                              body.emit(assign(r076B, lshift(r076B, body.constant(int(8))), 0x01));


                           body.instructions = f0773_parent_instructions;
                           body.emit(f0773);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0777 = bit_and(r076B, body.constant(4026531840u));
                           ir_expression *const r0778 = equal(r0777, body.constant(0u));
                           ir_if *f0776 = new(mem_ctx) ir_if(operand(r0778).val);
                           exec_list *const f0776_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0776->then_instructions;

                              body.emit(assign(r076D, add(r076D, body.constant(int(4))), 0x01));

                              body.emit(assign(r076B, lshift(r076B, body.constant(int(4))), 0x01));


                           body.instructions = f0776_parent_instructions;
                           body.emit(f0776);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r077A = bit_and(r076B, body.constant(3221225472u));
                           ir_expression *const r077B = equal(r077A, body.constant(0u));
                           ir_if *f0779 = new(mem_ctx) ir_if(operand(r077B).val);
                           exec_list *const f0779_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0779->then_instructions;

                              body.emit(assign(r076D, add(r076D, body.constant(int(2))), 0x01));

                              body.emit(assign(r076B, lshift(r076B, body.constant(int(2))), 0x01));


                           body.instructions = f0779_parent_instructions;
                           body.emit(f0779);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r077D = bit_and(r076B, body.constant(2147483648u));
                           ir_expression *const r077E = equal(r077D, body.constant(0u));
                           ir_if *f077C = new(mem_ctx) ir_if(operand(r077E).val);
                           exec_list *const f077C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f077C->then_instructions;

                              body.emit(assign(r076D, add(r076D, body.constant(int(1))), 0x01));


                           body.instructions = f077C_parent_instructions;
                           body.emit(f077C);

                           /* END IF */

                           body.emit(assign(r076C, r076D, 0x01));


                        body.instructions = f076E_parent_instructions;
                        body.emit(f076E);

                        /* END IF */

                        body.emit(assign(r0768, add(r076C, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0780 = lequal(body.constant(int(0)), r0768);
                        ir_if *f077F = new(mem_ctx) ir_if(operand(r0780).val);
                        exec_list *const f077F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f077F->then_instructions;

                           body.emit(assign(r0767, body.constant(0u), 0x01));

                           ir_variable *const r0781 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r0781, lshift(r0766, r0768), 0x01));

                           ir_variable *const r0782 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0784 = equal(r0768, body.constant(int(0)));
                           ir_if *f0783 = new(mem_ctx) ir_if(operand(r0784).val);
                           exec_list *const f0783_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0783->then_instructions;

                              body.emit(assign(r0782, r0765, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0783->else_instructions;

                              ir_expression *const r0785 = lshift(r0765, r0768);
                              ir_expression *const r0786 = neg(r0768);
                              ir_expression *const r0787 = bit_and(r0786, body.constant(int(31)));
                              ir_expression *const r0788 = rshift(r0766, r0787);
                              body.emit(assign(r0782, bit_or(r0785, r0788), 0x01));


                           body.instructions = f0783_parent_instructions;
                           body.emit(f0783);

                           /* END IF */

                           body.emit(assign(r0765, r0782, 0x01));

                           body.emit(assign(r0766, r0781, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f077F->else_instructions;

                           ir_variable *const r0789 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r0789, body.constant(0u), 0x01));

                           ir_variable *const r078A = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r078A, neg(r0768), 0x01));

                           ir_variable *const r078B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r078B);
                           ir_variable *const r078C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r078C);
                           ir_variable *const r078D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r078D);
                           ir_variable *const r078E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r078F = neg(r078A);
                           body.emit(assign(r078E, bit_and(r078F, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0791 = equal(r078A, body.constant(int(0)));
                           ir_if *f0790 = new(mem_ctx) ir_if(operand(r0791).val);
                           exec_list *const f0790_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0790->then_instructions;

                              body.emit(assign(r078B, r0789, 0x01));

                              body.emit(assign(r078C, r0766, 0x01));

                              body.emit(assign(r078D, r0765, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0790->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0793 = less(r078A, body.constant(int(32)));
                              ir_if *f0792 = new(mem_ctx) ir_if(operand(r0793).val);
                              exec_list *const f0792_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0792->then_instructions;

                                 body.emit(assign(r078B, lshift(r0766, r078E), 0x01));

                                 ir_expression *const r0794 = lshift(r0765, r078E);
                                 ir_expression *const r0795 = rshift(r0766, r078A);
                                 body.emit(assign(r078C, bit_or(r0794, r0795), 0x01));

                                 body.emit(assign(r078D, rshift(r0765, r078A), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0792->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0797 = equal(r078A, body.constant(int(32)));
                                 ir_if *f0796 = new(mem_ctx) ir_if(operand(r0797).val);
                                 exec_list *const f0796_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0796->then_instructions;

                                    body.emit(assign(r078B, r0766, 0x01));

                                    body.emit(assign(r078C, r0765, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0796->else_instructions;

                                    body.emit(assign(r0789, bit_or(body.constant(0u), r0766), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r0799 = less(r078A, body.constant(int(64)));
                                    ir_if *f0798 = new(mem_ctx) ir_if(operand(r0799).val);
                                    exec_list *const f0798_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0798->then_instructions;

                                       body.emit(assign(r078B, lshift(r0765, r078E), 0x01));

                                       ir_expression *const r079A = bit_and(r078A, body.constant(int(31)));
                                       body.emit(assign(r078C, rshift(r0765, r079A), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0798->else_instructions;

                                       ir_variable *const r079B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r079D = equal(r078A, body.constant(int(64)));
                                       ir_if *f079C = new(mem_ctx) ir_if(operand(r079D).val);
                                       exec_list *const f079C_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f079C->then_instructions;

                                          body.emit(assign(r079B, r0765, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f079C->else_instructions;

                                          ir_expression *const r079E = nequal(r0765, body.constant(0u));
                                          ir_expression *const r079F = expr(ir_unop_b2i, r079E);
                                          body.emit(assign(r079B, expr(ir_unop_i2u, r079F), 0x01));


                                       body.instructions = f079C_parent_instructions;
                                       body.emit(f079C);

                                       /* END IF */

                                       body.emit(assign(r078B, r079B, 0x01));

                                       body.emit(assign(r078C, body.constant(0u), 0x01));


                                    body.instructions = f0798_parent_instructions;
                                    body.emit(f0798);

                                    /* END IF */


                                 body.instructions = f0796_parent_instructions;
                                 body.emit(f0796);

                                 /* END IF */

                                 body.emit(assign(r078D, body.constant(0u), 0x01));


                              body.instructions = f0792_parent_instructions;
                              body.emit(f0792);

                              /* END IF */

                              ir_expression *const r07A0 = nequal(r0789, body.constant(0u));
                              ir_expression *const r07A1 = expr(ir_unop_b2i, r07A0);
                              ir_expression *const r07A2 = expr(ir_unop_i2u, r07A1);
                              body.emit(assign(r078B, bit_or(r078B, r07A2), 0x01));


                           body.instructions = f0790_parent_instructions;
                           body.emit(f0790);

                           /* END IF */

                           body.emit(assign(r0765, r078D, 0x01));

                           body.emit(assign(r0766, r078C, 0x01));

                           body.emit(assign(r0767, r078B, 0x01));


                        body.instructions = f077F_parent_instructions;
                        body.emit(f077F);

                        /* END IF */

                        body.emit(assign(r0764, sub(r0764, r0768), 0x01));

                        ir_variable *const r07A3 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r07A3, r0764, 0x01));

                        ir_variable *const r07A4 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r07A4, r0765, 0x01));

                        ir_variable *const r07A5 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r07A5, r0766, 0x01));

                        ir_variable *const r07A6 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r07A6, r0767, 0x01));

                        ir_variable *const r07A7 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r07A7, body.constant(true), 0x01));

                        ir_variable *const r07A8 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r07A9 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r07A9);
                        ir_expression *const r07AA = expr(ir_unop_u2i, r0767);
                        body.emit(assign(r07A9, less(r07AA, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r07AC = lequal(body.constant(int(2045)), r0764);
                        ir_if *f07AB = new(mem_ctx) ir_if(operand(r07AC).val);
                        exec_list *const f07AB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f07AB->then_instructions;

                           ir_variable *const r07AD = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r07AF = less(body.constant(int(2045)), r0764);
                           ir_if *f07AE = new(mem_ctx) ir_if(operand(r07AF).val);
                           exec_list *const f07AE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f07AE->then_instructions;

                              body.emit(assign(r07AD, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f07AE->else_instructions;

                              ir_variable *const r07B0 = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r07B2 = equal(r0764, body.constant(int(2045)));
                              ir_if *f07B1 = new(mem_ctx) ir_if(operand(r07B2).val);
                              exec_list *const f07B1_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f07B1->then_instructions;

                                 ir_expression *const r07B3 = equal(body.constant(2097151u), r0765);
                                 ir_expression *const r07B4 = equal(body.constant(4294967295u), r0766);
                                 body.emit(assign(r07B0, logic_and(r07B3, r07B4), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f07B1->else_instructions;

                                 body.emit(assign(r07B0, body.constant(false), 0x01));


                              body.instructions = f07B1_parent_instructions;
                              body.emit(f07B1);

                              /* END IF */

                              body.emit(assign(r07AD, logic_and(r07B0, r07A9), 0x01));


                           body.instructions = f07AE_parent_instructions;
                           body.emit(f07AE);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f07B5 = new(mem_ctx) ir_if(operand(r07AD).val);
                           exec_list *const f07B5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f07B5->then_instructions;

                              ir_variable *const r07B6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r07B6);
                              ir_expression *const r07B7 = lshift(r03D1, body.constant(int(31)));
                              body.emit(assign(r07B6, add(r07B7, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r07B6, body.constant(0u), 0x01));

                              body.emit(assign(r07A8, r07B6, 0x03));

                              body.emit(assign(r07A7, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f07B5->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r07B9 = less(r0764, body.constant(int(0)));
                              ir_if *f07B8 = new(mem_ctx) ir_if(operand(r07B9).val);
                              exec_list *const f07B8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f07B8->then_instructions;

                                 ir_variable *const r07BA = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r07BA, r0767, 0x01));

                                 ir_variable *const r07BB = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r07BB, neg(r0764), 0x01));

                                 ir_variable *const r07BC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r07BC);
                                 ir_variable *const r07BD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r07BD);
                                 ir_variable *const r07BE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r07BE);
                                 ir_variable *const r07BF = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r07C0 = neg(r07BB);
                                 body.emit(assign(r07BF, bit_and(r07C0, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r07C2 = equal(r07BB, body.constant(int(0)));
                                 ir_if *f07C1 = new(mem_ctx) ir_if(operand(r07C2).val);
                                 exec_list *const f07C1_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f07C1->then_instructions;

                                    body.emit(assign(r07BC, r0767, 0x01));

                                    body.emit(assign(r07BD, r0766, 0x01));

                                    body.emit(assign(r07BE, r0765, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f07C1->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r07C4 = less(r07BB, body.constant(int(32)));
                                    ir_if *f07C3 = new(mem_ctx) ir_if(operand(r07C4).val);
                                    exec_list *const f07C3_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f07C3->then_instructions;

                                       body.emit(assign(r07BC, lshift(r0766, r07BF), 0x01));

                                       ir_expression *const r07C5 = lshift(r0765, r07BF);
                                       ir_expression *const r07C6 = rshift(r0766, r07BB);
                                       body.emit(assign(r07BD, bit_or(r07C5, r07C6), 0x01));

                                       body.emit(assign(r07BE, rshift(r0765, r07BB), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f07C3->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r07C8 = equal(r07BB, body.constant(int(32)));
                                       ir_if *f07C7 = new(mem_ctx) ir_if(operand(r07C8).val);
                                       exec_list *const f07C7_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f07C7->then_instructions;

                                          body.emit(assign(r07BC, r0766, 0x01));

                                          body.emit(assign(r07BD, r0765, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f07C7->else_instructions;

                                          body.emit(assign(r07BA, bit_or(r0767, r0766), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r07CA = less(r07BB, body.constant(int(64)));
                                          ir_if *f07C9 = new(mem_ctx) ir_if(operand(r07CA).val);
                                          exec_list *const f07C9_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f07C9->then_instructions;

                                             body.emit(assign(r07BC, lshift(r0765, r07BF), 0x01));

                                             ir_expression *const r07CB = bit_and(r07BB, body.constant(int(31)));
                                             body.emit(assign(r07BD, rshift(r0765, r07CB), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f07C9->else_instructions;

                                             ir_variable *const r07CC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r07CE = equal(r07BB, body.constant(int(64)));
                                             ir_if *f07CD = new(mem_ctx) ir_if(operand(r07CE).val);
                                             exec_list *const f07CD_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f07CD->then_instructions;

                                                body.emit(assign(r07CC, r0765, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f07CD->else_instructions;

                                                ir_expression *const r07CF = nequal(r0765, body.constant(0u));
                                                ir_expression *const r07D0 = expr(ir_unop_b2i, r07CF);
                                                body.emit(assign(r07CC, expr(ir_unop_i2u, r07D0), 0x01));


                                             body.instructions = f07CD_parent_instructions;
                                             body.emit(f07CD);

                                             /* END IF */

                                             body.emit(assign(r07BC, r07CC, 0x01));

                                             body.emit(assign(r07BD, body.constant(0u), 0x01));


                                          body.instructions = f07C9_parent_instructions;
                                          body.emit(f07C9);

                                          /* END IF */


                                       body.instructions = f07C7_parent_instructions;
                                       body.emit(f07C7);

                                       /* END IF */

                                       body.emit(assign(r07BE, body.constant(0u), 0x01));


                                    body.instructions = f07C3_parent_instructions;
                                    body.emit(f07C3);

                                    /* END IF */

                                    ir_expression *const r07D1 = nequal(r07BA, body.constant(0u));
                                    ir_expression *const r07D2 = expr(ir_unop_b2i, r07D1);
                                    ir_expression *const r07D3 = expr(ir_unop_i2u, r07D2);
                                    body.emit(assign(r07BC, bit_or(r07BC, r07D3), 0x01));


                                 body.instructions = f07C1_parent_instructions;
                                 body.emit(f07C1);

                                 /* END IF */

                                 body.emit(assign(r07A4, r07BE, 0x01));

                                 body.emit(assign(r07A5, r07BD, 0x01));

                                 body.emit(assign(r07A6, r07BC, 0x01));

                                 body.emit(assign(r07A3, body.constant(int(0)), 0x01));

                                 body.emit(assign(r07A9, less(r07BC, body.constant(0u)), 0x01));


                              body.instructions = f07B8_parent_instructions;
                              body.emit(f07B8);

                              /* END IF */


                           body.instructions = f07B5_parent_instructions;
                           body.emit(f07B5);

                           /* END IF */


                        body.instructions = f07AB_parent_instructions;
                        body.emit(f07AB);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f07D4 = new(mem_ctx) ir_if(operand(r07A7).val);
                        exec_list *const f07D4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f07D4->then_instructions;

                           /* IF CONDITION */
                           ir_if *f07D5 = new(mem_ctx) ir_if(operand(r07A9).val);
                           exec_list *const f07D5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f07D5->then_instructions;

                              ir_variable *const r07D6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r07D6, add(r07A5, body.constant(1u)), 0x01));

                              ir_expression *const r07D7 = less(r07D6, r07A5);
                              ir_expression *const r07D8 = expr(ir_unop_b2i, r07D7);
                              ir_expression *const r07D9 = expr(ir_unop_i2u, r07D8);
                              body.emit(assign(r07A4, add(r07A4, r07D9), 0x01));

                              ir_expression *const r07DA = equal(r07A6, body.constant(0u));
                              ir_expression *const r07DB = expr(ir_unop_b2i, r07DA);
                              ir_expression *const r07DC = expr(ir_unop_i2u, r07DB);
                              ir_expression *const r07DD = add(r07A6, r07DC);
                              ir_expression *const r07DE = bit_and(r07DD, body.constant(1u));
                              ir_expression *const r07DF = expr(ir_unop_bit_not, r07DE);
                              body.emit(assign(r07A5, bit_and(r07D6, r07DF), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f07D5->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r07E1 = bit_or(r07A4, r07A5);
                              ir_expression *const r07E2 = equal(r07E1, body.constant(0u));
                              ir_if *f07E0 = new(mem_ctx) ir_if(operand(r07E2).val);
                              exec_list *const f07E0_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f07E0->then_instructions;

                                 body.emit(assign(r07A3, body.constant(int(0)), 0x01));


                              body.instructions = f07E0_parent_instructions;
                              body.emit(f07E0);

                              /* END IF */


                           body.instructions = f07D5_parent_instructions;
                           body.emit(f07D5);

                           /* END IF */

                           ir_variable *const r07E3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r07E3);
                           ir_expression *const r07E4 = lshift(r03D1, body.constant(int(31)));
                           ir_expression *const r07E5 = expr(ir_unop_i2u, r07A3);
                           ir_expression *const r07E6 = lshift(r07E5, body.constant(int(20)));
                           ir_expression *const r07E7 = add(r07E4, r07E6);
                           body.emit(assign(r07E3, add(r07E7, r07A4), 0x02));

                           body.emit(assign(r07E3, r07A5, 0x01));

                           body.emit(assign(r07A8, r07E3, 0x03));

                           body.emit(assign(r07A7, body.constant(false), 0x01));


                        body.instructions = f07D4_parent_instructions;
                        body.emit(f07D4);

                        /* END IF */

                        body.emit(assign(r03D2, r07A8, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f075C->else_instructions;

                        ir_variable *const r07E8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r07E8);
                        body.emit(assign(r07E8, body.constant(0u), 0x02));

                        body.emit(assign(r07E8, body.constant(0u), 0x01));

                        body.emit(assign(r03D2, r07E8, 0x03));


                     body.instructions = f075C_parent_instructions;
                     body.emit(f075C);

                     /* END IF */


                  body.instructions = f06D0_parent_instructions;
                  body.emit(f06D0);

                  /* END IF */


               body.instructions = f0644_parent_instructions;
               body.emit(f0644);

               /* END IF */


            body.instructions = f05B8_parent_instructions;
            body.emit(f05B8);

            /* END IF */


         body.instructions = f0591_parent_instructions;
         body.emit(f0591);

         /* END IF */


      body.instructions = f04BB_parent_instructions;
      body.emit(f04BB);

      /* END IF */


   body.instructions = f03E9_parent_instructions;
   body.emit(f03E9);

   /* END IF */

   body.emit(ret(r03D2));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fadd64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r07E9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r07E9);
   ir_variable *const r07EA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r07EA);
   ir_variable *const r07EB = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r07EC = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r07EC, rshift(swizzle_y(r07E9), body.constant(int(31))), 0x01));

   ir_variable *const r07ED = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r07ED, rshift(swizzle_y(r07EA), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r07EF = equal(r07EC, r07ED);
   ir_if *f07EE = new(mem_ctx) ir_if(operand(r07EF).val);
   exec_list *const f07EE_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f07EE->then_instructions;

      ir_variable *const r07F0 = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r07F0, body.constant(true), 0x01));

      ir_variable *const r07F1 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r07F2 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r07F2);
      ir_variable *const r07F3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
      body.emit(r07F3);
      ir_variable *const r07F4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
      body.emit(r07F4);
      ir_variable *const r07F5 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r07F5);
      ir_variable *const r07F6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
      body.emit(r07F6);
      ir_variable *const r07F7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
      body.emit(r07F7);
      body.emit(assign(r07F7, body.constant(0u), 0x01));

      body.emit(assign(r07F6, body.constant(0u), 0x01));

      ir_variable *const r07F8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r07F8);
      body.emit(assign(r07F8, bit_and(swizzle_y(r07E9), body.constant(1048575u)), 0x02));

      body.emit(assign(r07F8, swizzle_x(r07E9), 0x01));

      body.emit(assign(r07F4, r07F8, 0x03));

      ir_variable *const r07F9 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r07FA = rshift(swizzle_y(r07E9), body.constant(int(20)));
      ir_expression *const r07FB = bit_and(r07FA, body.constant(2047u));
      body.emit(assign(r07F9, expr(ir_unop_u2i, r07FB), 0x01));

      ir_variable *const r07FC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r07FC);
      body.emit(assign(r07FC, bit_and(swizzle_y(r07EA), body.constant(1048575u)), 0x02));

      body.emit(assign(r07FC, swizzle_x(r07EA), 0x01));

      body.emit(assign(r07F3, r07FC, 0x03));

      ir_variable *const r07FD = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r07FE = rshift(swizzle_y(r07EA), body.constant(int(20)));
      ir_expression *const r07FF = bit_and(r07FE, body.constant(2047u));
      body.emit(assign(r07FD, expr(ir_unop_u2i, r07FF), 0x01));

      ir_variable *const r0800 = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r0800, sub(r07F9, r07FD), 0x01));

      body.emit(assign(r07F2, r0800, 0x01));

      /* IF CONDITION */
      ir_expression *const r0802 = less(body.constant(int(0)), r0800);
      ir_if *f0801 = new(mem_ctx) ir_if(operand(r0802).val);
      exec_list *const f0801_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0801->then_instructions;

         /* IF CONDITION */
         ir_expression *const r0804 = equal(r07F9, body.constant(int(2047)));
         ir_if *f0803 = new(mem_ctx) ir_if(operand(r0804).val);
         exec_list *const f0803_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0803->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0806 = bit_or(swizzle_y(r07F8), swizzle_x(r07E9));
            ir_expression *const r0807 = nequal(r0806, body.constant(0u));
            ir_if *f0805 = new(mem_ctx) ir_if(operand(r0807).val);
            exec_list *const f0805_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0805->then_instructions;

               ir_variable *const r0808 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r0808, swizzle_x(r07E9), 0x01));

               ir_variable *const r0809 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r0809, swizzle_x(r07EA), 0x01));

               ir_variable *const r080A = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r080B = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r080C = rshift(swizzle_y(r07E9), body.constant(int(19)));
               ir_expression *const r080D = bit_and(r080C, body.constant(4095u));
               ir_expression *const r080E = equal(r080D, body.constant(4094u));
               ir_expression *const r080F = nequal(swizzle_x(r07E9), body.constant(0u));
               ir_expression *const r0810 = bit_and(swizzle_y(r07E9), body.constant(524287u));
               ir_expression *const r0811 = nequal(r0810, body.constant(0u));
               ir_expression *const r0812 = logic_or(r080F, r0811);
               body.emit(assign(r080B, logic_and(r080E, r0812), 0x01));

               ir_variable *const r0813 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r0814 = lshift(swizzle_y(r07EA), body.constant(int(1)));
               ir_expression *const r0815 = lequal(body.constant(4292870144u), r0814);
               ir_expression *const r0816 = nequal(swizzle_x(r07EA), body.constant(0u));
               ir_expression *const r0817 = bit_and(swizzle_y(r07EA), body.constant(1048575u));
               ir_expression *const r0818 = nequal(r0817, body.constant(0u));
               ir_expression *const r0819 = logic_or(r0816, r0818);
               body.emit(assign(r0813, logic_and(r0815, r0819), 0x01));

               body.emit(assign(r0808, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

               body.emit(assign(r0809, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r081B = lshift(swizzle_y(r07E9), body.constant(int(1)));
               ir_expression *const r081C = lequal(body.constant(4292870144u), r081B);
               ir_expression *const r081D = nequal(swizzle_x(r07E9), body.constant(0u));
               ir_expression *const r081E = bit_and(swizzle_y(r07E9), body.constant(1048575u));
               ir_expression *const r081F = nequal(r081E, body.constant(0u));
               ir_expression *const r0820 = logic_or(r081D, r081F);
               ir_expression *const r0821 = logic_and(r081C, r0820);
               ir_if *f081A = new(mem_ctx) ir_if(operand(r0821).val);
               exec_list *const f081A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f081A->then_instructions;

                  ir_variable *const r0822 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0824 = logic_and(r080B, r0813);
                  ir_if *f0823 = new(mem_ctx) ir_if(operand(r0824).val);
                  exec_list *const f0823_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0823->then_instructions;

                     body.emit(assign(r0822, r0809, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0823->else_instructions;

                     body.emit(assign(r0822, r0808, 0x03));


                  body.instructions = f0823_parent_instructions;
                  body.emit(f0823);

                  /* END IF */

                  body.emit(assign(r080A, r0822, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f081A->else_instructions;

                  body.emit(assign(r080A, r0809, 0x03));


               body.instructions = f081A_parent_instructions;
               body.emit(f081A);

               /* END IF */

               body.emit(assign(r07F1, r080A, 0x03));

               body.emit(assign(r07F0, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0805->else_instructions;

               body.emit(assign(r07F1, r07E9, 0x03));

               body.emit(assign(r07F0, body.constant(false), 0x01));


            body.instructions = f0805_parent_instructions;
            body.emit(f0805);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0803->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0826 = equal(r07FD, body.constant(int(0)));
            ir_if *f0825 = new(mem_ctx) ir_if(operand(r0826).val);
            exec_list *const f0825_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0825->then_instructions;

               body.emit(assign(r07F2, add(r0800, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0825->else_instructions;

               body.emit(assign(r07F3, bit_or(swizzle_y(r07FC), body.constant(1048576u)), 0x02));


            body.instructions = f0825_parent_instructions;
            body.emit(f0825);

            /* END IF */

            ir_variable *const r0827 = body.make_temp(glsl_type::uint_type, "a0");
            body.emit(assign(r0827, swizzle_y(r07F3), 0x01));

            ir_variable *const r0828 = body.make_temp(glsl_type::uint_type, "a1");
            body.emit(assign(r0828, swizzle_x(r07F3), 0x01));

            ir_variable *const r0829 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r0829, body.constant(0u), 0x01));

            ir_variable *const r082A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r082A);
            ir_variable *const r082B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r082B);
            ir_variable *const r082C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r082C);
            ir_variable *const r082D = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r082E = neg(r07F2);
            body.emit(assign(r082D, bit_and(r082E, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0830 = equal(r07F2, body.constant(int(0)));
            ir_if *f082F = new(mem_ctx) ir_if(operand(r0830).val);
            exec_list *const f082F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f082F->then_instructions;

               body.emit(assign(r082A, r0829, 0x01));

               body.emit(assign(r082B, r0828, 0x01));

               body.emit(assign(r082C, r0827, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f082F->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0832 = less(r07F2, body.constant(int(32)));
               ir_if *f0831 = new(mem_ctx) ir_if(operand(r0832).val);
               exec_list *const f0831_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0831->then_instructions;

                  body.emit(assign(r082A, lshift(swizzle_x(r07FC), r082D), 0x01));

                  ir_expression *const r0833 = lshift(swizzle_y(r07F3), r082D);
                  ir_expression *const r0834 = rshift(swizzle_x(r07FC), r07F2);
                  body.emit(assign(r082B, bit_or(r0833, r0834), 0x01));

                  body.emit(assign(r082C, rshift(swizzle_y(r07F3), r07F2), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0831->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0836 = equal(r07F2, body.constant(int(32)));
                  ir_if *f0835 = new(mem_ctx) ir_if(operand(r0836).val);
                  exec_list *const f0835_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0835->then_instructions;

                     body.emit(assign(r082A, r0828, 0x01));

                     body.emit(assign(r082B, r0827, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0835->else_instructions;

                     body.emit(assign(r0829, bit_or(body.constant(0u), swizzle_x(r07FC)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0838 = less(r07F2, body.constant(int(64)));
                     ir_if *f0837 = new(mem_ctx) ir_if(operand(r0838).val);
                     exec_list *const f0837_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0837->then_instructions;

                        body.emit(assign(r082A, lshift(swizzle_y(r07F3), r082D), 0x01));

                        ir_expression *const r0839 = bit_and(r07F2, body.constant(int(31)));
                        body.emit(assign(r082B, rshift(swizzle_y(r07F3), r0839), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0837->else_instructions;

                        ir_variable *const r083A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r083C = equal(r07F2, body.constant(int(64)));
                        ir_if *f083B = new(mem_ctx) ir_if(operand(r083C).val);
                        exec_list *const f083B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f083B->then_instructions;

                           body.emit(assign(r083A, r0827, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f083B->else_instructions;

                           ir_expression *const r083D = nequal(swizzle_y(r07F3), body.constant(0u));
                           ir_expression *const r083E = expr(ir_unop_b2i, r083D);
                           body.emit(assign(r083A, expr(ir_unop_i2u, r083E), 0x01));


                        body.instructions = f083B_parent_instructions;
                        body.emit(f083B);

                        /* END IF */

                        body.emit(assign(r082A, r083A, 0x01));

                        body.emit(assign(r082B, body.constant(0u), 0x01));


                     body.instructions = f0837_parent_instructions;
                     body.emit(f0837);

                     /* END IF */


                  body.instructions = f0835_parent_instructions;
                  body.emit(f0835);

                  /* END IF */

                  body.emit(assign(r082C, body.constant(0u), 0x01));


               body.instructions = f0831_parent_instructions;
               body.emit(f0831);

               /* END IF */

               ir_expression *const r083F = nequal(r0829, body.constant(0u));
               ir_expression *const r0840 = expr(ir_unop_b2i, r083F);
               ir_expression *const r0841 = expr(ir_unop_i2u, r0840);
               body.emit(assign(r082A, bit_or(r082A, r0841), 0x01));


            body.instructions = f082F_parent_instructions;
            body.emit(f082F);

            /* END IF */

            body.emit(assign(r07F3, r082C, 0x02));

            body.emit(assign(r07F3, r082B, 0x01));

            body.emit(assign(r07F6, r082A, 0x01));

            body.emit(assign(r07F5, r07F9, 0x01));


         body.instructions = f0803_parent_instructions;
         body.emit(f0803);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0801->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0843 = less(r07F2, body.constant(int(0)));
         ir_if *f0842 = new(mem_ctx) ir_if(operand(r0843).val);
         exec_list *const f0842_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0842->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0845 = equal(r07FD, body.constant(int(2047)));
            ir_if *f0844 = new(mem_ctx) ir_if(operand(r0845).val);
            exec_list *const f0844_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0844->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0847 = bit_or(swizzle_y(r07F3), swizzle_x(r07F3));
               ir_expression *const r0848 = nequal(r0847, body.constant(0u));
               ir_if *f0846 = new(mem_ctx) ir_if(operand(r0848).val);
               exec_list *const f0846_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0846->then_instructions;

                  ir_variable *const r0849 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r0849, swizzle_x(r07E9), 0x01));

                  ir_variable *const r084A = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r084A, swizzle_x(r07EA), 0x01));

                  ir_variable *const r084B = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r084C = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r084D = rshift(swizzle_y(r07E9), body.constant(int(19)));
                  ir_expression *const r084E = bit_and(r084D, body.constant(4095u));
                  ir_expression *const r084F = equal(r084E, body.constant(4094u));
                  ir_expression *const r0850 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0851 = bit_and(swizzle_y(r07E9), body.constant(524287u));
                  ir_expression *const r0852 = nequal(r0851, body.constant(0u));
                  ir_expression *const r0853 = logic_or(r0850, r0852);
                  body.emit(assign(r084C, logic_and(r084F, r0853), 0x01));

                  ir_variable *const r0854 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0855 = lshift(swizzle_y(r07EA), body.constant(int(1)));
                  ir_expression *const r0856 = lequal(body.constant(4292870144u), r0855);
                  ir_expression *const r0857 = nequal(swizzle_x(r07EA), body.constant(0u));
                  ir_expression *const r0858 = bit_and(swizzle_y(r07EA), body.constant(1048575u));
                  ir_expression *const r0859 = nequal(r0858, body.constant(0u));
                  ir_expression *const r085A = logic_or(r0857, r0859);
                  body.emit(assign(r0854, logic_and(r0856, r085A), 0x01));

                  body.emit(assign(r0849, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

                  body.emit(assign(r084A, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r085C = lshift(swizzle_y(r07E9), body.constant(int(1)));
                  ir_expression *const r085D = lequal(body.constant(4292870144u), r085C);
                  ir_expression *const r085E = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r085F = bit_and(swizzle_y(r07E9), body.constant(1048575u));
                  ir_expression *const r0860 = nequal(r085F, body.constant(0u));
                  ir_expression *const r0861 = logic_or(r085E, r0860);
                  ir_expression *const r0862 = logic_and(r085D, r0861);
                  ir_if *f085B = new(mem_ctx) ir_if(operand(r0862).val);
                  exec_list *const f085B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f085B->then_instructions;

                     ir_variable *const r0863 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0865 = logic_and(r084C, r0854);
                     ir_if *f0864 = new(mem_ctx) ir_if(operand(r0865).val);
                     exec_list *const f0864_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0864->then_instructions;

                        body.emit(assign(r0863, r084A, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0864->else_instructions;

                        body.emit(assign(r0863, r0849, 0x03));


                     body.instructions = f0864_parent_instructions;
                     body.emit(f0864);

                     /* END IF */

                     body.emit(assign(r084B, r0863, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f085B->else_instructions;

                     body.emit(assign(r084B, r084A, 0x03));


                  body.instructions = f085B_parent_instructions;
                  body.emit(f085B);

                  /* END IF */

                  body.emit(assign(r07F1, r084B, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0846->else_instructions;

                  ir_variable *const r0866 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0866);
                  ir_expression *const r0867 = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r0866, add(r0867, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0866, body.constant(0u), 0x01));

                  body.emit(assign(r07F1, r0866, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


               body.instructions = f0846_parent_instructions;
               body.emit(f0846);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0844->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0869 = equal(r07F9, body.constant(int(0)));
               ir_if *f0868 = new(mem_ctx) ir_if(operand(r0869).val);
               exec_list *const f0868_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0868->then_instructions;

                  body.emit(assign(r07F2, add(r07F2, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0868->else_instructions;

                  body.emit(assign(r07F4, bit_or(swizzle_y(r07F8), body.constant(1048576u)), 0x02));


               body.instructions = f0868_parent_instructions;
               body.emit(f0868);

               /* END IF */

               ir_variable *const r086A = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r086A, swizzle_y(r07F4), 0x01));

               ir_variable *const r086B = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r086B, swizzle_x(r07F4), 0x01));

               ir_variable *const r086C = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r086C, body.constant(0u), 0x01));

               ir_variable *const r086D = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r086D, neg(r07F2), 0x01));

               ir_variable *const r086E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r086E);
               ir_variable *const r086F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r086F);
               ir_variable *const r0870 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0870);
               ir_variable *const r0871 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0872 = neg(r086D);
               body.emit(assign(r0871, bit_and(r0872, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0874 = equal(r086D, body.constant(int(0)));
               ir_if *f0873 = new(mem_ctx) ir_if(operand(r0874).val);
               exec_list *const f0873_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0873->then_instructions;

                  body.emit(assign(r086E, r086C, 0x01));

                  body.emit(assign(r086F, r086B, 0x01));

                  body.emit(assign(r0870, r086A, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0873->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0876 = less(r086D, body.constant(int(32)));
                  ir_if *f0875 = new(mem_ctx) ir_if(operand(r0876).val);
                  exec_list *const f0875_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0875->then_instructions;

                     body.emit(assign(r086E, lshift(swizzle_x(r07F8), r0871), 0x01));

                     ir_expression *const r0877 = lshift(swizzle_y(r07F4), r0871);
                     ir_expression *const r0878 = rshift(swizzle_x(r07F8), r086D);
                     body.emit(assign(r086F, bit_or(r0877, r0878), 0x01));

                     body.emit(assign(r0870, rshift(swizzle_y(r07F4), r086D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0875->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r087A = equal(r086D, body.constant(int(32)));
                     ir_if *f0879 = new(mem_ctx) ir_if(operand(r087A).val);
                     exec_list *const f0879_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0879->then_instructions;

                        body.emit(assign(r086E, r086B, 0x01));

                        body.emit(assign(r086F, r086A, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0879->else_instructions;

                        body.emit(assign(r086C, bit_or(body.constant(0u), swizzle_x(r07F8)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r087C = less(r086D, body.constant(int(64)));
                        ir_if *f087B = new(mem_ctx) ir_if(operand(r087C).val);
                        exec_list *const f087B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f087B->then_instructions;

                           body.emit(assign(r086E, lshift(swizzle_y(r07F4), r0871), 0x01));

                           ir_expression *const r087D = bit_and(r086D, body.constant(int(31)));
                           body.emit(assign(r086F, rshift(swizzle_y(r07F4), r087D), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f087B->else_instructions;

                           ir_variable *const r087E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0880 = equal(r086D, body.constant(int(64)));
                           ir_if *f087F = new(mem_ctx) ir_if(operand(r0880).val);
                           exec_list *const f087F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f087F->then_instructions;

                              body.emit(assign(r087E, r086A, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f087F->else_instructions;

                              ir_expression *const r0881 = nequal(swizzle_y(r07F4), body.constant(0u));
                              ir_expression *const r0882 = expr(ir_unop_b2i, r0881);
                              body.emit(assign(r087E, expr(ir_unop_i2u, r0882), 0x01));


                           body.instructions = f087F_parent_instructions;
                           body.emit(f087F);

                           /* END IF */

                           body.emit(assign(r086E, r087E, 0x01));

                           body.emit(assign(r086F, body.constant(0u), 0x01));


                        body.instructions = f087B_parent_instructions;
                        body.emit(f087B);

                        /* END IF */


                     body.instructions = f0879_parent_instructions;
                     body.emit(f0879);

                     /* END IF */

                     body.emit(assign(r0870, body.constant(0u), 0x01));


                  body.instructions = f0875_parent_instructions;
                  body.emit(f0875);

                  /* END IF */

                  ir_expression *const r0883 = nequal(r086C, body.constant(0u));
                  ir_expression *const r0884 = expr(ir_unop_b2i, r0883);
                  ir_expression *const r0885 = expr(ir_unop_i2u, r0884);
                  body.emit(assign(r086E, bit_or(r086E, r0885), 0x01));


               body.instructions = f0873_parent_instructions;
               body.emit(f0873);

               /* END IF */

               body.emit(assign(r07F4, r0870, 0x02));

               body.emit(assign(r07F4, r086F, 0x01));

               body.emit(assign(r07F6, r086E, 0x01));

               body.emit(assign(r07F5, r07FD, 0x01));


            body.instructions = f0844_parent_instructions;
            body.emit(f0844);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0842->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0887 = equal(r07F9, body.constant(int(2047)));
            ir_if *f0886 = new(mem_ctx) ir_if(operand(r0887).val);
            exec_list *const f0886_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0886->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0889 = bit_or(swizzle_y(r07F4), swizzle_x(r07F4));
               ir_expression *const r088A = bit_or(swizzle_y(r07F3), swizzle_x(r07F3));
               ir_expression *const r088B = bit_or(r0889, r088A);
               ir_expression *const r088C = nequal(r088B, body.constant(0u));
               ir_if *f0888 = new(mem_ctx) ir_if(operand(r088C).val);
               exec_list *const f0888_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0888->then_instructions;

                  ir_variable *const r088D = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r088D, swizzle_x(r07E9), 0x01));

                  ir_variable *const r088E = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r088E, swizzle_x(r07EA), 0x01));

                  ir_variable *const r088F = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0890 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0891 = rshift(swizzle_y(r07E9), body.constant(int(19)));
                  ir_expression *const r0892 = bit_and(r0891, body.constant(4095u));
                  ir_expression *const r0893 = equal(r0892, body.constant(4094u));
                  ir_expression *const r0894 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0895 = bit_and(swizzle_y(r07E9), body.constant(524287u));
                  ir_expression *const r0896 = nequal(r0895, body.constant(0u));
                  ir_expression *const r0897 = logic_or(r0894, r0896);
                  body.emit(assign(r0890, logic_and(r0893, r0897), 0x01));

                  ir_variable *const r0898 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0899 = lshift(swizzle_y(r07EA), body.constant(int(1)));
                  ir_expression *const r089A = lequal(body.constant(4292870144u), r0899);
                  ir_expression *const r089B = nequal(swizzle_x(r07EA), body.constant(0u));
                  ir_expression *const r089C = bit_and(swizzle_y(r07EA), body.constant(1048575u));
                  ir_expression *const r089D = nequal(r089C, body.constant(0u));
                  ir_expression *const r089E = logic_or(r089B, r089D);
                  body.emit(assign(r0898, logic_and(r089A, r089E), 0x01));

                  body.emit(assign(r088D, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

                  body.emit(assign(r088E, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r08A0 = lshift(swizzle_y(r07E9), body.constant(int(1)));
                  ir_expression *const r08A1 = lequal(body.constant(4292870144u), r08A0);
                  ir_expression *const r08A2 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r08A3 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
                  ir_expression *const r08A4 = nequal(r08A3, body.constant(0u));
                  ir_expression *const r08A5 = logic_or(r08A2, r08A4);
                  ir_expression *const r08A6 = logic_and(r08A1, r08A5);
                  ir_if *f089F = new(mem_ctx) ir_if(operand(r08A6).val);
                  exec_list *const f089F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f089F->then_instructions;

                     ir_variable *const r08A7 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r08A9 = logic_and(r0890, r0898);
                     ir_if *f08A8 = new(mem_ctx) ir_if(operand(r08A9).val);
                     exec_list *const f08A8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f08A8->then_instructions;

                        body.emit(assign(r08A7, r088E, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f08A8->else_instructions;

                        body.emit(assign(r08A7, r088D, 0x03));


                     body.instructions = f08A8_parent_instructions;
                     body.emit(f08A8);

                     /* END IF */

                     body.emit(assign(r088F, r08A7, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f089F->else_instructions;

                     body.emit(assign(r088F, r088E, 0x03));


                  body.instructions = f089F_parent_instructions;
                  body.emit(f089F);

                  /* END IF */

                  body.emit(assign(r07F1, r088F, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0888->else_instructions;

                  body.emit(assign(r07F1, r07E9, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


               body.instructions = f0888_parent_instructions;
               body.emit(f0888);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0886->else_instructions;

               ir_variable *const r08AA = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r08AB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r08AB, add(swizzle_x(r07F4), swizzle_x(r07F3)), 0x01));

               ir_expression *const r08AC = add(swizzle_y(r07F4), swizzle_y(r07F3));
               ir_expression *const r08AD = less(r08AB, swizzle_x(r07F4));
               ir_expression *const r08AE = expr(ir_unop_b2i, r08AD);
               ir_expression *const r08AF = expr(ir_unop_i2u, r08AE);
               body.emit(assign(r08AA, add(r08AC, r08AF), 0x01));

               body.emit(assign(r07F7, r08AA, 0x01));

               /* IF CONDITION */
               ir_expression *const r08B1 = equal(r07F9, body.constant(int(0)));
               ir_if *f08B0 = new(mem_ctx) ir_if(operand(r08B1).val);
               exec_list *const f08B0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f08B0->then_instructions;

                  ir_variable *const r08B2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r08B2);
                  ir_expression *const r08B3 = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r08B2, add(r08B3, r08AA), 0x02));

                  body.emit(assign(r08B2, r08AB, 0x01));

                  body.emit(assign(r07F1, r08B2, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f08B0->else_instructions;

                  body.emit(assign(r07F7, bit_or(r08AA, body.constant(2097152u)), 0x01));

                  body.emit(assign(r07F5, r07F9, 0x01));

                  ir_variable *const r08B4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r08B4);
                  ir_variable *const r08B5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r08B5);
                  ir_variable *const r08B6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r08B6);
                  body.emit(assign(r08B4, lshift(r08AB, body.constant(int(31))), 0x01));

                  ir_expression *const r08B7 = lshift(r07F7, body.constant(int(31)));
                  ir_expression *const r08B8 = rshift(r08AB, body.constant(int(1)));
                  body.emit(assign(r08B5, bit_or(r08B7, r08B8), 0x01));

                  body.emit(assign(r08B6, rshift(r07F7, body.constant(int(1))), 0x01));

                  body.emit(assign(r08B4, bit_or(r08B4, body.constant(0u)), 0x01));

                  body.emit(assign(r07F7, r08B6, 0x01));

                  body.emit(assign(r07F6, r08B4, 0x01));

                  ir_variable *const r08B9 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r08B9, r07F9, 0x01));

                  ir_variable *const r08BA = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r08BA, r08B6, 0x01));

                  ir_variable *const r08BB = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r08BB, r08B5, 0x01));

                  ir_variable *const r08BC = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r08BC, r08B4, 0x01));

                  ir_variable *const r08BD = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r08BD, body.constant(true), 0x01));

                  ir_variable *const r08BE = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r08BF = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r08BF);
                  ir_expression *const r08C0 = expr(ir_unop_u2i, r08B4);
                  body.emit(assign(r08BF, less(r08C0, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r08C2 = lequal(body.constant(int(2045)), r07F9);
                  ir_if *f08C1 = new(mem_ctx) ir_if(operand(r08C2).val);
                  exec_list *const f08C1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f08C1->then_instructions;

                     ir_variable *const r08C3 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r08C5 = less(body.constant(int(2045)), r07F9);
                     ir_if *f08C4 = new(mem_ctx) ir_if(operand(r08C5).val);
                     exec_list *const f08C4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f08C4->then_instructions;

                        body.emit(assign(r08C3, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f08C4->else_instructions;

                        ir_variable *const r08C6 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r08C8 = equal(r07F9, body.constant(int(2045)));
                        ir_if *f08C7 = new(mem_ctx) ir_if(operand(r08C8).val);
                        exec_list *const f08C7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f08C7->then_instructions;

                           ir_expression *const r08C9 = equal(body.constant(2097151u), r08B6);
                           ir_expression *const r08CA = equal(body.constant(4294967295u), r08B5);
                           body.emit(assign(r08C6, logic_and(r08C9, r08CA), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f08C7->else_instructions;

                           body.emit(assign(r08C6, body.constant(false), 0x01));


                        body.instructions = f08C7_parent_instructions;
                        body.emit(f08C7);

                        /* END IF */

                        body.emit(assign(r08C3, logic_and(r08C6, r08BF), 0x01));


                     body.instructions = f08C4_parent_instructions;
                     body.emit(f08C4);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f08CB = new(mem_ctx) ir_if(operand(r08C3).val);
                     exec_list *const f08CB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f08CB->then_instructions;

                        ir_variable *const r08CC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r08CC);
                        ir_expression *const r08CD = lshift(r07EC, body.constant(int(31)));
                        body.emit(assign(r08CC, add(r08CD, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r08CC, body.constant(0u), 0x01));

                        body.emit(assign(r08BE, r08CC, 0x03));

                        body.emit(assign(r08BD, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f08CB->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r08CF = less(r07F9, body.constant(int(0)));
                        ir_if *f08CE = new(mem_ctx) ir_if(operand(r08CF).val);
                        exec_list *const f08CE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f08CE->then_instructions;

                           ir_variable *const r08D0 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r08D0, r08B4, 0x01));

                           ir_variable *const r08D1 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r08D1, neg(r07F9), 0x01));

                           ir_variable *const r08D2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r08D2);
                           ir_variable *const r08D3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r08D3);
                           ir_variable *const r08D4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r08D4);
                           ir_variable *const r08D5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r08D6 = neg(r08D1);
                           body.emit(assign(r08D5, bit_and(r08D6, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r08D8 = equal(r08D1, body.constant(int(0)));
                           ir_if *f08D7 = new(mem_ctx) ir_if(operand(r08D8).val);
                           exec_list *const f08D7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f08D7->then_instructions;

                              body.emit(assign(r08D2, r08B4, 0x01));

                              body.emit(assign(r08D3, r08B5, 0x01));

                              body.emit(assign(r08D4, r08B6, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f08D7->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r08DA = less(r08D1, body.constant(int(32)));
                              ir_if *f08D9 = new(mem_ctx) ir_if(operand(r08DA).val);
                              exec_list *const f08D9_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f08D9->then_instructions;

                                 body.emit(assign(r08D2, lshift(r08B5, r08D5), 0x01));

                                 ir_expression *const r08DB = lshift(r08B6, r08D5);
                                 ir_expression *const r08DC = rshift(r08B5, r08D1);
                                 body.emit(assign(r08D3, bit_or(r08DB, r08DC), 0x01));

                                 body.emit(assign(r08D4, rshift(r08B6, r08D1), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f08D9->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r08DE = equal(r08D1, body.constant(int(32)));
                                 ir_if *f08DD = new(mem_ctx) ir_if(operand(r08DE).val);
                                 exec_list *const f08DD_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f08DD->then_instructions;

                                    body.emit(assign(r08D2, r08B5, 0x01));

                                    body.emit(assign(r08D3, r08B6, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f08DD->else_instructions;

                                    body.emit(assign(r08D0, bit_or(r08B4, r08B5), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r08E0 = less(r08D1, body.constant(int(64)));
                                    ir_if *f08DF = new(mem_ctx) ir_if(operand(r08E0).val);
                                    exec_list *const f08DF_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f08DF->then_instructions;

                                       body.emit(assign(r08D2, lshift(r08B6, r08D5), 0x01));

                                       ir_expression *const r08E1 = bit_and(r08D1, body.constant(int(31)));
                                       body.emit(assign(r08D3, rshift(r08B6, r08E1), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f08DF->else_instructions;

                                       ir_variable *const r08E2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r08E4 = equal(r08D1, body.constant(int(64)));
                                       ir_if *f08E3 = new(mem_ctx) ir_if(operand(r08E4).val);
                                       exec_list *const f08E3_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f08E3->then_instructions;

                                          body.emit(assign(r08E2, r08B6, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f08E3->else_instructions;

                                          ir_expression *const r08E5 = nequal(r08B6, body.constant(0u));
                                          ir_expression *const r08E6 = expr(ir_unop_b2i, r08E5);
                                          body.emit(assign(r08E2, expr(ir_unop_i2u, r08E6), 0x01));


                                       body.instructions = f08E3_parent_instructions;
                                       body.emit(f08E3);

                                       /* END IF */

                                       body.emit(assign(r08D2, r08E2, 0x01));

                                       body.emit(assign(r08D3, body.constant(0u), 0x01));


                                    body.instructions = f08DF_parent_instructions;
                                    body.emit(f08DF);

                                    /* END IF */


                                 body.instructions = f08DD_parent_instructions;
                                 body.emit(f08DD);

                                 /* END IF */

                                 body.emit(assign(r08D4, body.constant(0u), 0x01));


                              body.instructions = f08D9_parent_instructions;
                              body.emit(f08D9);

                              /* END IF */

                              ir_expression *const r08E7 = nequal(r08D0, body.constant(0u));
                              ir_expression *const r08E8 = expr(ir_unop_b2i, r08E7);
                              ir_expression *const r08E9 = expr(ir_unop_i2u, r08E8);
                              body.emit(assign(r08D2, bit_or(r08D2, r08E9), 0x01));


                           body.instructions = f08D7_parent_instructions;
                           body.emit(f08D7);

                           /* END IF */

                           body.emit(assign(r08BA, r08D4, 0x01));

                           body.emit(assign(r08BB, r08D3, 0x01));

                           body.emit(assign(r08BC, r08D2, 0x01));

                           body.emit(assign(r08B9, body.constant(int(0)), 0x01));

                           body.emit(assign(r08BF, less(r08D2, body.constant(0u)), 0x01));


                        body.instructions = f08CE_parent_instructions;
                        body.emit(f08CE);

                        /* END IF */


                     body.instructions = f08CB_parent_instructions;
                     body.emit(f08CB);

                     /* END IF */


                  body.instructions = f08C1_parent_instructions;
                  body.emit(f08C1);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f08EA = new(mem_ctx) ir_if(operand(r08BD).val);
                  exec_list *const f08EA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f08EA->then_instructions;

                     /* IF CONDITION */
                     ir_if *f08EB = new(mem_ctx) ir_if(operand(r08BF).val);
                     exec_list *const f08EB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f08EB->then_instructions;

                        ir_variable *const r08EC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r08EC, add(r08BB, body.constant(1u)), 0x01));

                        ir_expression *const r08ED = less(r08EC, r08BB);
                        ir_expression *const r08EE = expr(ir_unop_b2i, r08ED);
                        ir_expression *const r08EF = expr(ir_unop_i2u, r08EE);
                        body.emit(assign(r08BA, add(r08BA, r08EF), 0x01));

                        ir_expression *const r08F0 = equal(r08BC, body.constant(0u));
                        ir_expression *const r08F1 = expr(ir_unop_b2i, r08F0);
                        ir_expression *const r08F2 = expr(ir_unop_i2u, r08F1);
                        ir_expression *const r08F3 = add(r08BC, r08F2);
                        ir_expression *const r08F4 = bit_and(r08F3, body.constant(1u));
                        ir_expression *const r08F5 = expr(ir_unop_bit_not, r08F4);
                        body.emit(assign(r08BB, bit_and(r08EC, r08F5), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f08EB->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r08F7 = bit_or(r08BA, r08BB);
                        ir_expression *const r08F8 = equal(r08F7, body.constant(0u));
                        ir_if *f08F6 = new(mem_ctx) ir_if(operand(r08F8).val);
                        exec_list *const f08F6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f08F6->then_instructions;

                           body.emit(assign(r08B9, body.constant(int(0)), 0x01));


                        body.instructions = f08F6_parent_instructions;
                        body.emit(f08F6);

                        /* END IF */


                     body.instructions = f08EB_parent_instructions;
                     body.emit(f08EB);

                     /* END IF */

                     ir_variable *const r08F9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r08F9);
                     ir_expression *const r08FA = lshift(r07EC, body.constant(int(31)));
                     ir_expression *const r08FB = expr(ir_unop_i2u, r08B9);
                     ir_expression *const r08FC = lshift(r08FB, body.constant(int(20)));
                     ir_expression *const r08FD = add(r08FA, r08FC);
                     body.emit(assign(r08F9, add(r08FD, r08BA), 0x02));

                     body.emit(assign(r08F9, r08BB, 0x01));

                     body.emit(assign(r08BE, r08F9, 0x03));

                     body.emit(assign(r08BD, body.constant(false), 0x01));


                  body.instructions = f08EA_parent_instructions;
                  body.emit(f08EA);

                  /* END IF */

                  body.emit(assign(r07F1, r08BE, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


               body.instructions = f08B0_parent_instructions;
               body.emit(f08B0);

               /* END IF */


            body.instructions = f0886_parent_instructions;
            body.emit(f0886);

            /* END IF */


         body.instructions = f0842_parent_instructions;
         body.emit(f0842);

         /* END IF */


      body.instructions = f0801_parent_instructions;
      body.emit(f0801);

      /* END IF */

      /* IF CONDITION */
      ir_if *f08FE = new(mem_ctx) ir_if(operand(r07F0).val);
      exec_list *const f08FE_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f08FE->then_instructions;

         body.emit(assign(r07F4, bit_or(swizzle_y(r07F4), body.constant(1048576u)), 0x02));

         ir_variable *const r08FF = body.make_temp(glsl_type::uint_type, "z0Ptr");
         ir_variable *const r0900 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r0900, add(swizzle_x(r07F4), swizzle_x(r07F3)), 0x01));

         ir_expression *const r0901 = add(swizzle_y(r07F4), swizzle_y(r07F3));
         ir_expression *const r0902 = less(r0900, swizzle_x(r07F4));
         ir_expression *const r0903 = expr(ir_unop_b2i, r0902);
         ir_expression *const r0904 = expr(ir_unop_i2u, r0903);
         body.emit(assign(r08FF, add(r0901, r0904), 0x01));

         body.emit(assign(r07F7, r08FF, 0x01));

         body.emit(assign(r07F5, add(r07F5, body.constant(int(-1))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0906 = less(r08FF, body.constant(2097152u));
         ir_if *f0905 = new(mem_ctx) ir_if(operand(r0906).val);
         exec_list *const f0905_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0905->then_instructions;

            ir_variable *const r0907 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0907, r07F5, 0x01));

            ir_variable *const r0908 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0908, r08FF, 0x01));

            ir_variable *const r0909 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0909, r0900, 0x01));

            ir_variable *const r090A = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r090A, r07F6, 0x01));

            ir_variable *const r090B = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r090B, body.constant(true), 0x01));

            ir_variable *const r090C = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r090D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r090D);
            ir_expression *const r090E = expr(ir_unop_u2i, r07F6);
            body.emit(assign(r090D, less(r090E, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0910 = lequal(body.constant(int(2045)), r07F5);
            ir_if *f090F = new(mem_ctx) ir_if(operand(r0910).val);
            exec_list *const f090F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f090F->then_instructions;

               ir_variable *const r0911 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0913 = less(body.constant(int(2045)), r07F5);
               ir_if *f0912 = new(mem_ctx) ir_if(operand(r0913).val);
               exec_list *const f0912_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0912->then_instructions;

                  body.emit(assign(r0911, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0912->else_instructions;

                  ir_variable *const r0914 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0916 = equal(r07F5, body.constant(int(2045)));
                  ir_if *f0915 = new(mem_ctx) ir_if(operand(r0916).val);
                  exec_list *const f0915_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0915->then_instructions;

                     ir_expression *const r0917 = equal(body.constant(2097151u), r08FF);
                     ir_expression *const r0918 = equal(body.constant(4294967295u), r0900);
                     body.emit(assign(r0914, logic_and(r0917, r0918), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0915->else_instructions;

                     body.emit(assign(r0914, body.constant(false), 0x01));


                  body.instructions = f0915_parent_instructions;
                  body.emit(f0915);

                  /* END IF */

                  body.emit(assign(r0911, logic_and(r0914, r090D), 0x01));


               body.instructions = f0912_parent_instructions;
               body.emit(f0912);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0919 = new(mem_ctx) ir_if(operand(r0911).val);
               exec_list *const f0919_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0919->then_instructions;

                  ir_variable *const r091A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r091A);
                  ir_expression *const r091B = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r091A, add(r091B, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r091A, body.constant(0u), 0x01));

                  body.emit(assign(r090C, r091A, 0x03));

                  body.emit(assign(r090B, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0919->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r091D = less(r07F5, body.constant(int(0)));
                  ir_if *f091C = new(mem_ctx) ir_if(operand(r091D).val);
                  exec_list *const f091C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f091C->then_instructions;

                     ir_variable *const r091E = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r091E, r07F6, 0x01));

                     ir_variable *const r091F = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r091F, neg(r07F5), 0x01));

                     ir_variable *const r0920 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0920);
                     ir_variable *const r0921 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0921);
                     ir_variable *const r0922 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0922);
                     ir_variable *const r0923 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0924 = neg(r091F);
                     body.emit(assign(r0923, bit_and(r0924, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0926 = equal(r091F, body.constant(int(0)));
                     ir_if *f0925 = new(mem_ctx) ir_if(operand(r0926).val);
                     exec_list *const f0925_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0925->then_instructions;

                        body.emit(assign(r0920, r07F6, 0x01));

                        body.emit(assign(r0921, r0900, 0x01));

                        body.emit(assign(r0922, r08FF, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0925->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0928 = less(r091F, body.constant(int(32)));
                        ir_if *f0927 = new(mem_ctx) ir_if(operand(r0928).val);
                        exec_list *const f0927_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0927->then_instructions;

                           body.emit(assign(r0920, lshift(r0900, r0923), 0x01));

                           ir_expression *const r0929 = lshift(r08FF, r0923);
                           ir_expression *const r092A = rshift(r0900, r091F);
                           body.emit(assign(r0921, bit_or(r0929, r092A), 0x01));

                           body.emit(assign(r0922, rshift(r08FF, r091F), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0927->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r092C = equal(r091F, body.constant(int(32)));
                           ir_if *f092B = new(mem_ctx) ir_if(operand(r092C).val);
                           exec_list *const f092B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f092B->then_instructions;

                              body.emit(assign(r0920, r0900, 0x01));

                              body.emit(assign(r0921, r08FF, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f092B->else_instructions;

                              body.emit(assign(r091E, bit_or(r07F6, r0900), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r092E = less(r091F, body.constant(int(64)));
                              ir_if *f092D = new(mem_ctx) ir_if(operand(r092E).val);
                              exec_list *const f092D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f092D->then_instructions;

                                 body.emit(assign(r0920, lshift(r08FF, r0923), 0x01));

                                 ir_expression *const r092F = bit_and(r091F, body.constant(int(31)));
                                 body.emit(assign(r0921, rshift(r08FF, r092F), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f092D->else_instructions;

                                 ir_variable *const r0930 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0932 = equal(r091F, body.constant(int(64)));
                                 ir_if *f0931 = new(mem_ctx) ir_if(operand(r0932).val);
                                 exec_list *const f0931_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0931->then_instructions;

                                    body.emit(assign(r0930, r08FF, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0931->else_instructions;

                                    ir_expression *const r0933 = nequal(r08FF, body.constant(0u));
                                    ir_expression *const r0934 = expr(ir_unop_b2i, r0933);
                                    body.emit(assign(r0930, expr(ir_unop_i2u, r0934), 0x01));


                                 body.instructions = f0931_parent_instructions;
                                 body.emit(f0931);

                                 /* END IF */

                                 body.emit(assign(r0920, r0930, 0x01));

                                 body.emit(assign(r0921, body.constant(0u), 0x01));


                              body.instructions = f092D_parent_instructions;
                              body.emit(f092D);

                              /* END IF */


                           body.instructions = f092B_parent_instructions;
                           body.emit(f092B);

                           /* END IF */

                           body.emit(assign(r0922, body.constant(0u), 0x01));


                        body.instructions = f0927_parent_instructions;
                        body.emit(f0927);

                        /* END IF */

                        ir_expression *const r0935 = nequal(r091E, body.constant(0u));
                        ir_expression *const r0936 = expr(ir_unop_b2i, r0935);
                        ir_expression *const r0937 = expr(ir_unop_i2u, r0936);
                        body.emit(assign(r0920, bit_or(r0920, r0937), 0x01));


                     body.instructions = f0925_parent_instructions;
                     body.emit(f0925);

                     /* END IF */

                     body.emit(assign(r0908, r0922, 0x01));

                     body.emit(assign(r0909, r0921, 0x01));

                     body.emit(assign(r090A, r0920, 0x01));

                     body.emit(assign(r0907, body.constant(int(0)), 0x01));

                     body.emit(assign(r090D, less(r0920, body.constant(0u)), 0x01));


                  body.instructions = f091C_parent_instructions;
                  body.emit(f091C);

                  /* END IF */


               body.instructions = f0919_parent_instructions;
               body.emit(f0919);

               /* END IF */


            body.instructions = f090F_parent_instructions;
            body.emit(f090F);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0938 = new(mem_ctx) ir_if(operand(r090B).val);
            exec_list *const f0938_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0938->then_instructions;

               /* IF CONDITION */
               ir_if *f0939 = new(mem_ctx) ir_if(operand(r090D).val);
               exec_list *const f0939_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0939->then_instructions;

                  ir_variable *const r093A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r093A, add(r0909, body.constant(1u)), 0x01));

                  ir_expression *const r093B = less(r093A, r0909);
                  ir_expression *const r093C = expr(ir_unop_b2i, r093B);
                  ir_expression *const r093D = expr(ir_unop_i2u, r093C);
                  body.emit(assign(r0908, add(r0908, r093D), 0x01));

                  ir_expression *const r093E = equal(r090A, body.constant(0u));
                  ir_expression *const r093F = expr(ir_unop_b2i, r093E);
                  ir_expression *const r0940 = expr(ir_unop_i2u, r093F);
                  ir_expression *const r0941 = add(r090A, r0940);
                  ir_expression *const r0942 = bit_and(r0941, body.constant(1u));
                  ir_expression *const r0943 = expr(ir_unop_bit_not, r0942);
                  body.emit(assign(r0909, bit_and(r093A, r0943), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0939->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0945 = bit_or(r0908, r0909);
                  ir_expression *const r0946 = equal(r0945, body.constant(0u));
                  ir_if *f0944 = new(mem_ctx) ir_if(operand(r0946).val);
                  exec_list *const f0944_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0944->then_instructions;

                     body.emit(assign(r0907, body.constant(int(0)), 0x01));


                  body.instructions = f0944_parent_instructions;
                  body.emit(f0944);

                  /* END IF */


               body.instructions = f0939_parent_instructions;
               body.emit(f0939);

               /* END IF */

               ir_variable *const r0947 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0947);
               ir_expression *const r0948 = lshift(r07EC, body.constant(int(31)));
               ir_expression *const r0949 = expr(ir_unop_i2u, r0907);
               ir_expression *const r094A = lshift(r0949, body.constant(int(20)));
               ir_expression *const r094B = add(r0948, r094A);
               body.emit(assign(r0947, add(r094B, r0908), 0x02));

               body.emit(assign(r0947, r0909, 0x01));

               body.emit(assign(r090C, r0947, 0x03));

               body.emit(assign(r090B, body.constant(false), 0x01));


            body.instructions = f0938_parent_instructions;
            body.emit(f0938);

            /* END IF */

            body.emit(assign(r07F1, r090C, 0x03));

            body.emit(assign(r07F0, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0905->else_instructions;

            body.emit(assign(r07F5, add(r07F5, body.constant(int(1))), 0x01));

            ir_variable *const r094C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r094C);
            ir_variable *const r094D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r094D);
            ir_variable *const r094E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r094E);
            body.emit(assign(r094C, lshift(r0900, body.constant(int(31))), 0x01));

            ir_expression *const r094F = lshift(r08FF, body.constant(int(31)));
            ir_expression *const r0950 = rshift(r0900, body.constant(int(1)));
            body.emit(assign(r094D, bit_or(r094F, r0950), 0x01));

            body.emit(assign(r094E, rshift(r08FF, body.constant(int(1))), 0x01));

            ir_expression *const r0951 = nequal(r07F6, body.constant(0u));
            ir_expression *const r0952 = expr(ir_unop_b2i, r0951);
            ir_expression *const r0953 = expr(ir_unop_i2u, r0952);
            body.emit(assign(r094C, bit_or(r094C, r0953), 0x01));

            body.emit(assign(r07F7, r094E, 0x01));

            body.emit(assign(r07F6, r094C, 0x01));

            ir_variable *const r0954 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0954, r07F5, 0x01));

            ir_variable *const r0955 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0955, r094E, 0x01));

            ir_variable *const r0956 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0956, r094D, 0x01));

            ir_variable *const r0957 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r0957, r094C, 0x01));

            ir_variable *const r0958 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r0958, body.constant(true), 0x01));

            ir_variable *const r0959 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r095A = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r095A);
            ir_expression *const r095B = expr(ir_unop_u2i, r094C);
            body.emit(assign(r095A, less(r095B, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r095D = lequal(body.constant(int(2045)), r07F5);
            ir_if *f095C = new(mem_ctx) ir_if(operand(r095D).val);
            exec_list *const f095C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f095C->then_instructions;

               ir_variable *const r095E = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0960 = less(body.constant(int(2045)), r07F5);
               ir_if *f095F = new(mem_ctx) ir_if(operand(r0960).val);
               exec_list *const f095F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f095F->then_instructions;

                  body.emit(assign(r095E, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f095F->else_instructions;

                  ir_variable *const r0961 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0963 = equal(r07F5, body.constant(int(2045)));
                  ir_if *f0962 = new(mem_ctx) ir_if(operand(r0963).val);
                  exec_list *const f0962_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0962->then_instructions;

                     ir_expression *const r0964 = equal(body.constant(2097151u), r094E);
                     ir_expression *const r0965 = equal(body.constant(4294967295u), r094D);
                     body.emit(assign(r0961, logic_and(r0964, r0965), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0962->else_instructions;

                     body.emit(assign(r0961, body.constant(false), 0x01));


                  body.instructions = f0962_parent_instructions;
                  body.emit(f0962);

                  /* END IF */

                  body.emit(assign(r095E, logic_and(r0961, r095A), 0x01));


               body.instructions = f095F_parent_instructions;
               body.emit(f095F);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0966 = new(mem_ctx) ir_if(operand(r095E).val);
               exec_list *const f0966_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0966->then_instructions;

                  ir_variable *const r0967 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0967);
                  ir_expression *const r0968 = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r0967, add(r0968, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0967, body.constant(0u), 0x01));

                  body.emit(assign(r0959, r0967, 0x03));

                  body.emit(assign(r0958, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0966->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r096A = less(r07F5, body.constant(int(0)));
                  ir_if *f0969 = new(mem_ctx) ir_if(operand(r096A).val);
                  exec_list *const f0969_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0969->then_instructions;

                     ir_variable *const r096B = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r096B, r094C, 0x01));

                     ir_variable *const r096C = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r096C, neg(r07F5), 0x01));

                     ir_variable *const r096D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r096D);
                     ir_variable *const r096E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r096E);
                     ir_variable *const r096F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r096F);
                     ir_variable *const r0970 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0971 = neg(r096C);
                     body.emit(assign(r0970, bit_and(r0971, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0973 = equal(r096C, body.constant(int(0)));
                     ir_if *f0972 = new(mem_ctx) ir_if(operand(r0973).val);
                     exec_list *const f0972_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0972->then_instructions;

                        body.emit(assign(r096D, r094C, 0x01));

                        body.emit(assign(r096E, r094D, 0x01));

                        body.emit(assign(r096F, r094E, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0972->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0975 = less(r096C, body.constant(int(32)));
                        ir_if *f0974 = new(mem_ctx) ir_if(operand(r0975).val);
                        exec_list *const f0974_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0974->then_instructions;

                           body.emit(assign(r096D, lshift(r094D, r0970), 0x01));

                           ir_expression *const r0976 = lshift(r094E, r0970);
                           ir_expression *const r0977 = rshift(r094D, r096C);
                           body.emit(assign(r096E, bit_or(r0976, r0977), 0x01));

                           body.emit(assign(r096F, rshift(r094E, r096C), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0974->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0979 = equal(r096C, body.constant(int(32)));
                           ir_if *f0978 = new(mem_ctx) ir_if(operand(r0979).val);
                           exec_list *const f0978_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0978->then_instructions;

                              body.emit(assign(r096D, r094D, 0x01));

                              body.emit(assign(r096E, r094E, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0978->else_instructions;

                              body.emit(assign(r096B, bit_or(r094C, r094D), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r097B = less(r096C, body.constant(int(64)));
                              ir_if *f097A = new(mem_ctx) ir_if(operand(r097B).val);
                              exec_list *const f097A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f097A->then_instructions;

                                 body.emit(assign(r096D, lshift(r094E, r0970), 0x01));

                                 ir_expression *const r097C = bit_and(r096C, body.constant(int(31)));
                                 body.emit(assign(r096E, rshift(r094E, r097C), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f097A->else_instructions;

                                 ir_variable *const r097D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r097F = equal(r096C, body.constant(int(64)));
                                 ir_if *f097E = new(mem_ctx) ir_if(operand(r097F).val);
                                 exec_list *const f097E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f097E->then_instructions;

                                    body.emit(assign(r097D, r094E, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f097E->else_instructions;

                                    ir_expression *const r0980 = nequal(r094E, body.constant(0u));
                                    ir_expression *const r0981 = expr(ir_unop_b2i, r0980);
                                    body.emit(assign(r097D, expr(ir_unop_i2u, r0981), 0x01));


                                 body.instructions = f097E_parent_instructions;
                                 body.emit(f097E);

                                 /* END IF */

                                 body.emit(assign(r096D, r097D, 0x01));

                                 body.emit(assign(r096E, body.constant(0u), 0x01));


                              body.instructions = f097A_parent_instructions;
                              body.emit(f097A);

                              /* END IF */


                           body.instructions = f0978_parent_instructions;
                           body.emit(f0978);

                           /* END IF */

                           body.emit(assign(r096F, body.constant(0u), 0x01));


                        body.instructions = f0974_parent_instructions;
                        body.emit(f0974);

                        /* END IF */

                        ir_expression *const r0982 = nequal(r096B, body.constant(0u));
                        ir_expression *const r0983 = expr(ir_unop_b2i, r0982);
                        ir_expression *const r0984 = expr(ir_unop_i2u, r0983);
                        body.emit(assign(r096D, bit_or(r096D, r0984), 0x01));


                     body.instructions = f0972_parent_instructions;
                     body.emit(f0972);

                     /* END IF */

                     body.emit(assign(r0955, r096F, 0x01));

                     body.emit(assign(r0956, r096E, 0x01));

                     body.emit(assign(r0957, r096D, 0x01));

                     body.emit(assign(r0954, body.constant(int(0)), 0x01));

                     body.emit(assign(r095A, less(r096D, body.constant(0u)), 0x01));


                  body.instructions = f0969_parent_instructions;
                  body.emit(f0969);

                  /* END IF */


               body.instructions = f0966_parent_instructions;
               body.emit(f0966);

               /* END IF */


            body.instructions = f095C_parent_instructions;
            body.emit(f095C);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0985 = new(mem_ctx) ir_if(operand(r0958).val);
            exec_list *const f0985_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0985->then_instructions;

               /* IF CONDITION */
               ir_if *f0986 = new(mem_ctx) ir_if(operand(r095A).val);
               exec_list *const f0986_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0986->then_instructions;

                  ir_variable *const r0987 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r0987, add(r0956, body.constant(1u)), 0x01));

                  ir_expression *const r0988 = less(r0987, r0956);
                  ir_expression *const r0989 = expr(ir_unop_b2i, r0988);
                  ir_expression *const r098A = expr(ir_unop_i2u, r0989);
                  body.emit(assign(r0955, add(r0955, r098A), 0x01));

                  ir_expression *const r098B = equal(r0957, body.constant(0u));
                  ir_expression *const r098C = expr(ir_unop_b2i, r098B);
                  ir_expression *const r098D = expr(ir_unop_i2u, r098C);
                  ir_expression *const r098E = add(r0957, r098D);
                  ir_expression *const r098F = bit_and(r098E, body.constant(1u));
                  ir_expression *const r0990 = expr(ir_unop_bit_not, r098F);
                  body.emit(assign(r0956, bit_and(r0987, r0990), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0986->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0992 = bit_or(r0955, r0956);
                  ir_expression *const r0993 = equal(r0992, body.constant(0u));
                  ir_if *f0991 = new(mem_ctx) ir_if(operand(r0993).val);
                  exec_list *const f0991_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0991->then_instructions;

                     body.emit(assign(r0954, body.constant(int(0)), 0x01));


                  body.instructions = f0991_parent_instructions;
                  body.emit(f0991);

                  /* END IF */


               body.instructions = f0986_parent_instructions;
               body.emit(f0986);

               /* END IF */

               ir_variable *const r0994 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0994);
               ir_expression *const r0995 = lshift(r07EC, body.constant(int(31)));
               ir_expression *const r0996 = expr(ir_unop_i2u, r0954);
               ir_expression *const r0997 = lshift(r0996, body.constant(int(20)));
               ir_expression *const r0998 = add(r0995, r0997);
               body.emit(assign(r0994, add(r0998, r0955), 0x02));

               body.emit(assign(r0994, r0956, 0x01));

               body.emit(assign(r0959, r0994, 0x03));

               body.emit(assign(r0958, body.constant(false), 0x01));


            body.instructions = f0985_parent_instructions;
            body.emit(f0985);

            /* END IF */

            body.emit(assign(r07F1, r0959, 0x03));

            body.emit(assign(r07F0, body.constant(false), 0x01));


         body.instructions = f0905_parent_instructions;
         body.emit(f0905);

         /* END IF */


      body.instructions = f08FE_parent_instructions;
      body.emit(f08FE);

      /* END IF */

      body.emit(assign(r07EB, r07F1, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f07EE->else_instructions;

      ir_variable *const r0999 = body.make_temp(glsl_type::uint_type, "zSign");
      body.emit(assign(r0999, r07EC, 0x01));

      ir_variable *const r099A = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r099B = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r099B);
      ir_variable *const r099C = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
      body.emit(r099C);
      ir_variable *const r099D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
      body.emit(r099D);
      ir_variable *const r099E = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
      body.emit(r099E);
      ir_variable *const r099F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
      body.emit(r099F);
      ir_variable *const r09A0 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r09A0);
      ir_variable *const r09A1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r09A1);
      body.emit(assign(r09A1, bit_and(swizzle_y(r07E9), body.constant(1048575u)), 0x02));

      body.emit(assign(r09A1, swizzle_x(r07E9), 0x01));

      ir_variable *const r09A2 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r09A3 = rshift(swizzle_y(r07E9), body.constant(int(20)));
      ir_expression *const r09A4 = bit_and(r09A3, body.constant(2047u));
      body.emit(assign(r09A2, expr(ir_unop_u2i, r09A4), 0x01));

      body.emit(assign(r099E, r09A2, 0x01));

      ir_variable *const r09A5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r09A5);
      body.emit(assign(r09A5, bit_and(swizzle_y(r07EA), body.constant(1048575u)), 0x02));

      body.emit(assign(r09A5, swizzle_x(r07EA), 0x01));

      ir_variable *const r09A6 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r09A7 = rshift(swizzle_y(r07EA), body.constant(int(20)));
      ir_expression *const r09A8 = bit_and(r09A7, body.constant(2047u));
      body.emit(assign(r09A6, expr(ir_unop_u2i, r09A8), 0x01));

      body.emit(assign(r099C, r09A6, 0x01));

      body.emit(assign(r099B, sub(r09A2, r09A6), 0x01));

      ir_variable *const r09A9 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r09A9, lshift(swizzle_x(r07E9), body.constant(int(10))), 0x01));

      ir_variable *const r09AA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r09AB = lshift(swizzle_y(r09A1), body.constant(int(10)));
      ir_expression *const r09AC = rshift(swizzle_x(r07E9), body.constant(int(22)));
      body.emit(assign(r09AA, bit_or(r09AB, r09AC), 0x01));

      body.emit(assign(r099F, r09AA, 0x02));

      body.emit(assign(r099F, r09A9, 0x01));

      ir_variable *const r09AD = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r09AD, lshift(swizzle_x(r07EA), body.constant(int(10))), 0x01));

      ir_variable *const r09AE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r09AF = lshift(swizzle_y(r09A5), body.constant(int(10)));
      ir_expression *const r09B0 = rshift(swizzle_x(r07EA), body.constant(int(22)));
      body.emit(assign(r09AE, bit_or(r09AF, r09B0), 0x01));

      body.emit(assign(r099D, r09AE, 0x02));

      body.emit(assign(r099D, r09AD, 0x01));

      /* IF CONDITION */
      ir_expression *const r09B2 = less(body.constant(int(0)), r099B);
      ir_if *f09B1 = new(mem_ctx) ir_if(operand(r09B2).val);
      exec_list *const f09B1_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f09B1->then_instructions;

         /* IF CONDITION */
         ir_expression *const r09B4 = equal(r09A2, body.constant(int(2047)));
         ir_if *f09B3 = new(mem_ctx) ir_if(operand(r09B4).val);
         exec_list *const f09B3_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f09B3->then_instructions;

            /* IF CONDITION */
            ir_expression *const r09B6 = bit_or(r09AA, r09A9);
            ir_expression *const r09B7 = nequal(r09B6, body.constant(0u));
            ir_if *f09B5 = new(mem_ctx) ir_if(operand(r09B7).val);
            exec_list *const f09B5_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f09B5->then_instructions;

               ir_variable *const r09B8 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r09B8, swizzle_x(r07E9), 0x01));

               ir_variable *const r09B9 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r09B9, swizzle_x(r07EA), 0x01));

               ir_variable *const r09BA = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r09BB = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r09BC = rshift(swizzle_y(r07E9), body.constant(int(19)));
               ir_expression *const r09BD = bit_and(r09BC, body.constant(4095u));
               ir_expression *const r09BE = equal(r09BD, body.constant(4094u));
               ir_expression *const r09BF = nequal(swizzle_x(r07E9), body.constant(0u));
               ir_expression *const r09C0 = bit_and(swizzle_y(r07E9), body.constant(524287u));
               ir_expression *const r09C1 = nequal(r09C0, body.constant(0u));
               ir_expression *const r09C2 = logic_or(r09BF, r09C1);
               body.emit(assign(r09BB, logic_and(r09BE, r09C2), 0x01));

               ir_variable *const r09C3 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r09C4 = lshift(swizzle_y(r07EA), body.constant(int(1)));
               ir_expression *const r09C5 = lequal(body.constant(4292870144u), r09C4);
               ir_expression *const r09C6 = nequal(swizzle_x(r07EA), body.constant(0u));
               ir_expression *const r09C7 = bit_and(swizzle_y(r07EA), body.constant(1048575u));
               ir_expression *const r09C8 = nequal(r09C7, body.constant(0u));
               ir_expression *const r09C9 = logic_or(r09C6, r09C8);
               body.emit(assign(r09C3, logic_and(r09C5, r09C9), 0x01));

               body.emit(assign(r09B8, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

               body.emit(assign(r09B9, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r09CB = lshift(swizzle_y(r07E9), body.constant(int(1)));
               ir_expression *const r09CC = lequal(body.constant(4292870144u), r09CB);
               ir_expression *const r09CD = nequal(swizzle_x(r07E9), body.constant(0u));
               ir_expression *const r09CE = bit_and(swizzle_y(r07E9), body.constant(1048575u));
               ir_expression *const r09CF = nequal(r09CE, body.constant(0u));
               ir_expression *const r09D0 = logic_or(r09CD, r09CF);
               ir_expression *const r09D1 = logic_and(r09CC, r09D0);
               ir_if *f09CA = new(mem_ctx) ir_if(operand(r09D1).val);
               exec_list *const f09CA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f09CA->then_instructions;

                  ir_variable *const r09D2 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r09D4 = logic_and(r09BB, r09C3);
                  ir_if *f09D3 = new(mem_ctx) ir_if(operand(r09D4).val);
                  exec_list *const f09D3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f09D3->then_instructions;

                     body.emit(assign(r09D2, r09B9, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f09D3->else_instructions;

                     body.emit(assign(r09D2, r09B8, 0x03));


                  body.instructions = f09D3_parent_instructions;
                  body.emit(f09D3);

                  /* END IF */

                  body.emit(assign(r09BA, r09D2, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f09CA->else_instructions;

                  body.emit(assign(r09BA, r09B9, 0x03));


               body.instructions = f09CA_parent_instructions;
               body.emit(f09CA);

               /* END IF */

               body.emit(assign(r099A, r09BA, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f09B5->else_instructions;

               body.emit(assign(r099A, r07E9, 0x03));


            body.instructions = f09B5_parent_instructions;
            body.emit(f09B5);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f09B3->else_instructions;

            /* IF CONDITION */
            ir_expression *const r09D6 = equal(r09A6, body.constant(int(0)));
            ir_if *f09D5 = new(mem_ctx) ir_if(operand(r09D6).val);
            exec_list *const f09D5_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f09D5->then_instructions;

               body.emit(assign(r099B, add(r099B, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f09D5->else_instructions;

               body.emit(assign(r099D, bit_or(r09AE, body.constant(1073741824u)), 0x02));


            body.instructions = f09D5_parent_instructions;
            body.emit(f09D5);

            /* END IF */

            ir_variable *const r09D7 = body.make_temp(glsl_type::uint_type, "a0");
            body.emit(assign(r09D7, swizzle_y(r099D), 0x01));

            ir_variable *const r09D8 = body.make_temp(glsl_type::uint_type, "a1");
            body.emit(assign(r09D8, swizzle_x(r099D), 0x01));

            ir_variable *const r09D9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r09D9);
            ir_variable *const r09DA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r09DA);
            ir_variable *const r09DB = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r09DC = neg(r099B);
            body.emit(assign(r09DB, bit_and(r09DC, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r09DE = equal(r099B, body.constant(int(0)));
            ir_if *f09DD = new(mem_ctx) ir_if(operand(r09DE).val);
            exec_list *const f09DD_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f09DD->then_instructions;

               body.emit(assign(r09D9, r09D8, 0x01));

               body.emit(assign(r09DA, r09D7, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f09DD->else_instructions;

               /* IF CONDITION */
               ir_expression *const r09E0 = less(r099B, body.constant(int(32)));
               ir_if *f09DF = new(mem_ctx) ir_if(operand(r09E0).val);
               exec_list *const f09DF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f09DF->then_instructions;

                  ir_expression *const r09E1 = lshift(swizzle_y(r099D), r09DB);
                  ir_expression *const r09E2 = rshift(r09AD, r099B);
                  ir_expression *const r09E3 = bit_or(r09E1, r09E2);
                  ir_expression *const r09E4 = lshift(r09AD, r09DB);
                  ir_expression *const r09E5 = nequal(r09E4, body.constant(0u));
                  ir_expression *const r09E6 = expr(ir_unop_b2i, r09E5);
                  ir_expression *const r09E7 = expr(ir_unop_i2u, r09E6);
                  body.emit(assign(r09D9, bit_or(r09E3, r09E7), 0x01));

                  body.emit(assign(r09DA, rshift(swizzle_y(r099D), r099B), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f09DF->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r09E9 = equal(r099B, body.constant(int(32)));
                  ir_if *f09E8 = new(mem_ctx) ir_if(operand(r09E9).val);
                  exec_list *const f09E8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f09E8->then_instructions;

                     ir_expression *const r09EA = nequal(r09AD, body.constant(0u));
                     ir_expression *const r09EB = expr(ir_unop_b2i, r09EA);
                     ir_expression *const r09EC = expr(ir_unop_i2u, r09EB);
                     body.emit(assign(r09D9, bit_or(swizzle_y(r099D), r09EC), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f09E8->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r09EE = less(r099B, body.constant(int(64)));
                     ir_if *f09ED = new(mem_ctx) ir_if(operand(r09EE).val);
                     exec_list *const f09ED_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f09ED->then_instructions;

                        ir_expression *const r09EF = bit_and(r099B, body.constant(int(31)));
                        ir_expression *const r09F0 = rshift(swizzle_y(r099D), r09EF);
                        ir_expression *const r09F1 = lshift(swizzle_y(r099D), r09DB);
                        ir_expression *const r09F2 = bit_or(r09F1, r09AD);
                        ir_expression *const r09F3 = nequal(r09F2, body.constant(0u));
                        ir_expression *const r09F4 = expr(ir_unop_b2i, r09F3);
                        ir_expression *const r09F5 = expr(ir_unop_i2u, r09F4);
                        body.emit(assign(r09D9, bit_or(r09F0, r09F5), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f09ED->else_instructions;

                        ir_expression *const r09F6 = bit_or(swizzle_y(r099D), r09AD);
                        ir_expression *const r09F7 = nequal(r09F6, body.constant(0u));
                        ir_expression *const r09F8 = expr(ir_unop_b2i, r09F7);
                        body.emit(assign(r09D9, expr(ir_unop_i2u, r09F8), 0x01));


                     body.instructions = f09ED_parent_instructions;
                     body.emit(f09ED);

                     /* END IF */


                  body.instructions = f09E8_parent_instructions;
                  body.emit(f09E8);

                  /* END IF */

                  body.emit(assign(r09DA, body.constant(0u), 0x01));


               body.instructions = f09DF_parent_instructions;
               body.emit(f09DF);

               /* END IF */


            body.instructions = f09DD_parent_instructions;
            body.emit(f09DD);

            /* END IF */

            body.emit(assign(r099D, r09DA, 0x02));

            body.emit(assign(r099D, r09D9, 0x01));

            body.emit(assign(r099F, bit_or(r09AA, body.constant(1073741824u)), 0x02));

            ir_variable *const r09F9 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r09FA = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r09FA, sub(r09A9, r09D9), 0x01));

            ir_expression *const r09FB = sub(swizzle_y(r099F), r09DA);
            ir_expression *const r09FC = less(r09A9, r09D9);
            ir_expression *const r09FD = expr(ir_unop_b2i, r09FC);
            ir_expression *const r09FE = expr(ir_unop_i2u, r09FD);
            body.emit(assign(r09F9, sub(r09FB, r09FE), 0x01));

            body.emit(assign(r09A0, add(r09A2, body.constant(int(-1))), 0x01));

            ir_variable *const r09FF = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r09FF, add(r09A0, body.constant(int(-10))), 0x01));

            ir_variable *const r0A00 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0A00, r09F9, 0x01));

            ir_variable *const r0A01 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0A01, r09FA, 0x01));

            ir_variable *const r0A02 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
            body.emit(r0A02);
            ir_variable *const r0A03 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0A03);
            /* IF CONDITION */
            ir_expression *const r0A05 = equal(r09F9, body.constant(0u));
            ir_if *f0A04 = new(mem_ctx) ir_if(operand(r0A05).val);
            exec_list *const f0A04_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A04->then_instructions;

               body.emit(assign(r0A00, r09FA, 0x01));

               body.emit(assign(r0A01, body.constant(0u), 0x01));

               body.emit(assign(r09FF, add(r09FF, body.constant(int(-32))), 0x01));


            body.instructions = f0A04_parent_instructions;
            body.emit(f0A04);

            /* END IF */

            ir_variable *const r0A06 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r0A06, r0A00, 0x01));

            ir_variable *const r0A07 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r0A08 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0A08);
            /* IF CONDITION */
            ir_expression *const r0A0A = equal(r0A00, body.constant(0u));
            ir_if *f0A09 = new(mem_ctx) ir_if(operand(r0A0A).val);
            exec_list *const f0A09_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A09->then_instructions;

               body.emit(assign(r0A07, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0A09->else_instructions;

               body.emit(assign(r0A08, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r0A0C = bit_and(r0A00, body.constant(4294901760u));
               ir_expression *const r0A0D = equal(r0A0C, body.constant(0u));
               ir_if *f0A0B = new(mem_ctx) ir_if(operand(r0A0D).val);
               exec_list *const f0A0B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A0B->then_instructions;

                  body.emit(assign(r0A08, body.constant(int(16)), 0x01));

                  body.emit(assign(r0A06, lshift(r0A00, body.constant(int(16))), 0x01));


               body.instructions = f0A0B_parent_instructions;
               body.emit(f0A0B);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0A0F = bit_and(r0A06, body.constant(4278190080u));
               ir_expression *const r0A10 = equal(r0A0F, body.constant(0u));
               ir_if *f0A0E = new(mem_ctx) ir_if(operand(r0A10).val);
               exec_list *const f0A0E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A0E->then_instructions;

                  body.emit(assign(r0A08, add(r0A08, body.constant(int(8))), 0x01));

                  body.emit(assign(r0A06, lshift(r0A06, body.constant(int(8))), 0x01));


               body.instructions = f0A0E_parent_instructions;
               body.emit(f0A0E);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0A12 = bit_and(r0A06, body.constant(4026531840u));
               ir_expression *const r0A13 = equal(r0A12, body.constant(0u));
               ir_if *f0A11 = new(mem_ctx) ir_if(operand(r0A13).val);
               exec_list *const f0A11_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A11->then_instructions;

                  body.emit(assign(r0A08, add(r0A08, body.constant(int(4))), 0x01));

                  body.emit(assign(r0A06, lshift(r0A06, body.constant(int(4))), 0x01));


               body.instructions = f0A11_parent_instructions;
               body.emit(f0A11);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0A15 = bit_and(r0A06, body.constant(3221225472u));
               ir_expression *const r0A16 = equal(r0A15, body.constant(0u));
               ir_if *f0A14 = new(mem_ctx) ir_if(operand(r0A16).val);
               exec_list *const f0A14_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A14->then_instructions;

                  body.emit(assign(r0A08, add(r0A08, body.constant(int(2))), 0x01));

                  body.emit(assign(r0A06, lshift(r0A06, body.constant(int(2))), 0x01));


               body.instructions = f0A14_parent_instructions;
               body.emit(f0A14);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0A18 = bit_and(r0A06, body.constant(2147483648u));
               ir_expression *const r0A19 = equal(r0A18, body.constant(0u));
               ir_if *f0A17 = new(mem_ctx) ir_if(operand(r0A19).val);
               exec_list *const f0A17_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A17->then_instructions;

                  body.emit(assign(r0A08, add(r0A08, body.constant(int(1))), 0x01));


               body.instructions = f0A17_parent_instructions;
               body.emit(f0A17);

               /* END IF */

               body.emit(assign(r0A07, r0A08, 0x01));


            body.instructions = f0A09_parent_instructions;
            body.emit(f0A09);

            /* END IF */

            body.emit(assign(r0A03, add(r0A07, body.constant(int(-11))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0A1B = lequal(body.constant(int(0)), r0A03);
            ir_if *f0A1A = new(mem_ctx) ir_if(operand(r0A1B).val);
            exec_list *const f0A1A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A1A->then_instructions;

               body.emit(assign(r0A02, body.constant(0u), 0x01));

               ir_variable *const r0A1C = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r0A1C, lshift(r0A01, r0A03), 0x01));

               ir_variable *const r0A1D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r0A1F = equal(r0A03, body.constant(int(0)));
               ir_if *f0A1E = new(mem_ctx) ir_if(operand(r0A1F).val);
               exec_list *const f0A1E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A1E->then_instructions;

                  body.emit(assign(r0A1D, r0A00, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A1E->else_instructions;

                  ir_expression *const r0A20 = lshift(r0A00, r0A03);
                  ir_expression *const r0A21 = neg(r0A03);
                  ir_expression *const r0A22 = bit_and(r0A21, body.constant(int(31)));
                  ir_expression *const r0A23 = rshift(r0A01, r0A22);
                  body.emit(assign(r0A1D, bit_or(r0A20, r0A23), 0x01));


               body.instructions = f0A1E_parent_instructions;
               body.emit(f0A1E);

               /* END IF */

               body.emit(assign(r0A00, r0A1D, 0x01));

               body.emit(assign(r0A01, r0A1C, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0A1A->else_instructions;

               ir_variable *const r0A24 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r0A24, body.constant(0u), 0x01));

               ir_variable *const r0A25 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0A25, neg(r0A03), 0x01));

               ir_variable *const r0A26 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r0A26);
               ir_variable *const r0A27 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0A27);
               ir_variable *const r0A28 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0A28);
               ir_variable *const r0A29 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0A2A = neg(r0A25);
               body.emit(assign(r0A29, bit_and(r0A2A, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0A2C = equal(r0A25, body.constant(int(0)));
               ir_if *f0A2B = new(mem_ctx) ir_if(operand(r0A2C).val);
               exec_list *const f0A2B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A2B->then_instructions;

                  body.emit(assign(r0A26, r0A24, 0x01));

                  body.emit(assign(r0A27, r0A01, 0x01));

                  body.emit(assign(r0A28, r0A00, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A2B->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0A2E = less(r0A25, body.constant(int(32)));
                  ir_if *f0A2D = new(mem_ctx) ir_if(operand(r0A2E).val);
                  exec_list *const f0A2D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A2D->then_instructions;

                     body.emit(assign(r0A26, lshift(r0A01, r0A29), 0x01));

                     ir_expression *const r0A2F = lshift(r0A00, r0A29);
                     ir_expression *const r0A30 = rshift(r0A01, r0A25);
                     body.emit(assign(r0A27, bit_or(r0A2F, r0A30), 0x01));

                     body.emit(assign(r0A28, rshift(r0A00, r0A25), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0A2D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0A32 = equal(r0A25, body.constant(int(32)));
                     ir_if *f0A31 = new(mem_ctx) ir_if(operand(r0A32).val);
                     exec_list *const f0A31_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0A31->then_instructions;

                        body.emit(assign(r0A26, r0A01, 0x01));

                        body.emit(assign(r0A27, r0A00, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0A31->else_instructions;

                        body.emit(assign(r0A24, bit_or(body.constant(0u), r0A01), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0A34 = less(r0A25, body.constant(int(64)));
                        ir_if *f0A33 = new(mem_ctx) ir_if(operand(r0A34).val);
                        exec_list *const f0A33_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0A33->then_instructions;

                           body.emit(assign(r0A26, lshift(r0A00, r0A29), 0x01));

                           ir_expression *const r0A35 = bit_and(r0A25, body.constant(int(31)));
                           body.emit(assign(r0A27, rshift(r0A00, r0A35), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0A33->else_instructions;

                           ir_variable *const r0A36 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0A38 = equal(r0A25, body.constant(int(64)));
                           ir_if *f0A37 = new(mem_ctx) ir_if(operand(r0A38).val);
                           exec_list *const f0A37_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0A37->then_instructions;

                              body.emit(assign(r0A36, r0A00, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0A37->else_instructions;

                              ir_expression *const r0A39 = nequal(r0A00, body.constant(0u));
                              ir_expression *const r0A3A = expr(ir_unop_b2i, r0A39);
                              body.emit(assign(r0A36, expr(ir_unop_i2u, r0A3A), 0x01));


                           body.instructions = f0A37_parent_instructions;
                           body.emit(f0A37);

                           /* END IF */

                           body.emit(assign(r0A26, r0A36, 0x01));

                           body.emit(assign(r0A27, body.constant(0u), 0x01));


                        body.instructions = f0A33_parent_instructions;
                        body.emit(f0A33);

                        /* END IF */


                     body.instructions = f0A31_parent_instructions;
                     body.emit(f0A31);

                     /* END IF */

                     body.emit(assign(r0A28, body.constant(0u), 0x01));


                  body.instructions = f0A2D_parent_instructions;
                  body.emit(f0A2D);

                  /* END IF */

                  ir_expression *const r0A3B = nequal(r0A24, body.constant(0u));
                  ir_expression *const r0A3C = expr(ir_unop_b2i, r0A3B);
                  ir_expression *const r0A3D = expr(ir_unop_i2u, r0A3C);
                  body.emit(assign(r0A26, bit_or(r0A26, r0A3D), 0x01));


               body.instructions = f0A2B_parent_instructions;
               body.emit(f0A2B);

               /* END IF */

               body.emit(assign(r0A00, r0A28, 0x01));

               body.emit(assign(r0A01, r0A27, 0x01));

               body.emit(assign(r0A02, r0A26, 0x01));


            body.instructions = f0A1A_parent_instructions;
            body.emit(f0A1A);

            /* END IF */

            body.emit(assign(r09FF, sub(r09FF, r0A03), 0x01));

            ir_variable *const r0A3E = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0A3E, r09FF, 0x01));

            ir_variable *const r0A3F = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0A3F, r0A00, 0x01));

            ir_variable *const r0A40 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0A40, r0A01, 0x01));

            ir_variable *const r0A41 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r0A41, r0A02, 0x01));

            ir_variable *const r0A42 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r0A42, body.constant(true), 0x01));

            ir_variable *const r0A43 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0A44 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r0A44);
            ir_expression *const r0A45 = expr(ir_unop_u2i, r0A02);
            body.emit(assign(r0A44, less(r0A45, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0A47 = lequal(body.constant(int(2045)), r09FF);
            ir_if *f0A46 = new(mem_ctx) ir_if(operand(r0A47).val);
            exec_list *const f0A46_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A46->then_instructions;

               ir_variable *const r0A48 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0A4A = less(body.constant(int(2045)), r09FF);
               ir_if *f0A49 = new(mem_ctx) ir_if(operand(r0A4A).val);
               exec_list *const f0A49_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A49->then_instructions;

                  body.emit(assign(r0A48, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A49->else_instructions;

                  ir_variable *const r0A4B = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0A4D = equal(r09FF, body.constant(int(2045)));
                  ir_if *f0A4C = new(mem_ctx) ir_if(operand(r0A4D).val);
                  exec_list *const f0A4C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A4C->then_instructions;

                     ir_expression *const r0A4E = equal(body.constant(2097151u), r0A00);
                     ir_expression *const r0A4F = equal(body.constant(4294967295u), r0A01);
                     body.emit(assign(r0A4B, logic_and(r0A4E, r0A4F), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0A4C->else_instructions;

                     body.emit(assign(r0A4B, body.constant(false), 0x01));


                  body.instructions = f0A4C_parent_instructions;
                  body.emit(f0A4C);

                  /* END IF */

                  body.emit(assign(r0A48, logic_and(r0A4B, r0A44), 0x01));


               body.instructions = f0A49_parent_instructions;
               body.emit(f0A49);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0A50 = new(mem_ctx) ir_if(operand(r0A48).val);
               exec_list *const f0A50_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A50->then_instructions;

                  ir_variable *const r0A51 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0A51);
                  ir_expression *const r0A52 = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r0A51, add(r0A52, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0A51, body.constant(0u), 0x01));

                  body.emit(assign(r0A43, r0A51, 0x03));

                  body.emit(assign(r0A42, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A50->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0A54 = less(r09FF, body.constant(int(0)));
                  ir_if *f0A53 = new(mem_ctx) ir_if(operand(r0A54).val);
                  exec_list *const f0A53_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A53->then_instructions;

                     ir_variable *const r0A55 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0A55, r0A02, 0x01));

                     ir_variable *const r0A56 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0A56, neg(r09FF), 0x01));

                     ir_variable *const r0A57 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0A57);
                     ir_variable *const r0A58 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0A58);
                     ir_variable *const r0A59 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0A59);
                     ir_variable *const r0A5A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0A5B = neg(r0A56);
                     body.emit(assign(r0A5A, bit_and(r0A5B, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0A5D = equal(r0A56, body.constant(int(0)));
                     ir_if *f0A5C = new(mem_ctx) ir_if(operand(r0A5D).val);
                     exec_list *const f0A5C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0A5C->then_instructions;

                        body.emit(assign(r0A57, r0A02, 0x01));

                        body.emit(assign(r0A58, r0A01, 0x01));

                        body.emit(assign(r0A59, r0A00, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0A5C->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0A5F = less(r0A56, body.constant(int(32)));
                        ir_if *f0A5E = new(mem_ctx) ir_if(operand(r0A5F).val);
                        exec_list *const f0A5E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0A5E->then_instructions;

                           body.emit(assign(r0A57, lshift(r0A01, r0A5A), 0x01));

                           ir_expression *const r0A60 = lshift(r0A00, r0A5A);
                           ir_expression *const r0A61 = rshift(r0A01, r0A56);
                           body.emit(assign(r0A58, bit_or(r0A60, r0A61), 0x01));

                           body.emit(assign(r0A59, rshift(r0A00, r0A56), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0A5E->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0A63 = equal(r0A56, body.constant(int(32)));
                           ir_if *f0A62 = new(mem_ctx) ir_if(operand(r0A63).val);
                           exec_list *const f0A62_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0A62->then_instructions;

                              body.emit(assign(r0A57, r0A01, 0x01));

                              body.emit(assign(r0A58, r0A00, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0A62->else_instructions;

                              body.emit(assign(r0A55, bit_or(r0A02, r0A01), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0A65 = less(r0A56, body.constant(int(64)));
                              ir_if *f0A64 = new(mem_ctx) ir_if(operand(r0A65).val);
                              exec_list *const f0A64_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0A64->then_instructions;

                                 body.emit(assign(r0A57, lshift(r0A00, r0A5A), 0x01));

                                 ir_expression *const r0A66 = bit_and(r0A56, body.constant(int(31)));
                                 body.emit(assign(r0A58, rshift(r0A00, r0A66), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0A64->else_instructions;

                                 ir_variable *const r0A67 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0A69 = equal(r0A56, body.constant(int(64)));
                                 ir_if *f0A68 = new(mem_ctx) ir_if(operand(r0A69).val);
                                 exec_list *const f0A68_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0A68->then_instructions;

                                    body.emit(assign(r0A67, r0A00, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0A68->else_instructions;

                                    ir_expression *const r0A6A = nequal(r0A00, body.constant(0u));
                                    ir_expression *const r0A6B = expr(ir_unop_b2i, r0A6A);
                                    body.emit(assign(r0A67, expr(ir_unop_i2u, r0A6B), 0x01));


                                 body.instructions = f0A68_parent_instructions;
                                 body.emit(f0A68);

                                 /* END IF */

                                 body.emit(assign(r0A57, r0A67, 0x01));

                                 body.emit(assign(r0A58, body.constant(0u), 0x01));


                              body.instructions = f0A64_parent_instructions;
                              body.emit(f0A64);

                              /* END IF */


                           body.instructions = f0A62_parent_instructions;
                           body.emit(f0A62);

                           /* END IF */

                           body.emit(assign(r0A59, body.constant(0u), 0x01));


                        body.instructions = f0A5E_parent_instructions;
                        body.emit(f0A5E);

                        /* END IF */

                        ir_expression *const r0A6C = nequal(r0A55, body.constant(0u));
                        ir_expression *const r0A6D = expr(ir_unop_b2i, r0A6C);
                        ir_expression *const r0A6E = expr(ir_unop_i2u, r0A6D);
                        body.emit(assign(r0A57, bit_or(r0A57, r0A6E), 0x01));


                     body.instructions = f0A5C_parent_instructions;
                     body.emit(f0A5C);

                     /* END IF */

                     body.emit(assign(r0A3F, r0A59, 0x01));

                     body.emit(assign(r0A40, r0A58, 0x01));

                     body.emit(assign(r0A41, r0A57, 0x01));

                     body.emit(assign(r0A3E, body.constant(int(0)), 0x01));

                     body.emit(assign(r0A44, less(r0A57, body.constant(0u)), 0x01));


                  body.instructions = f0A53_parent_instructions;
                  body.emit(f0A53);

                  /* END IF */


               body.instructions = f0A50_parent_instructions;
               body.emit(f0A50);

               /* END IF */


            body.instructions = f0A46_parent_instructions;
            body.emit(f0A46);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0A6F = new(mem_ctx) ir_if(operand(r0A42).val);
            exec_list *const f0A6F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A6F->then_instructions;

               /* IF CONDITION */
               ir_if *f0A70 = new(mem_ctx) ir_if(operand(r0A44).val);
               exec_list *const f0A70_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A70->then_instructions;

                  ir_variable *const r0A71 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r0A71, add(r0A40, body.constant(1u)), 0x01));

                  ir_expression *const r0A72 = less(r0A71, r0A40);
                  ir_expression *const r0A73 = expr(ir_unop_b2i, r0A72);
                  ir_expression *const r0A74 = expr(ir_unop_i2u, r0A73);
                  body.emit(assign(r0A3F, add(r0A3F, r0A74), 0x01));

                  ir_expression *const r0A75 = equal(r0A41, body.constant(0u));
                  ir_expression *const r0A76 = expr(ir_unop_b2i, r0A75);
                  ir_expression *const r0A77 = expr(ir_unop_i2u, r0A76);
                  ir_expression *const r0A78 = add(r0A41, r0A77);
                  ir_expression *const r0A79 = bit_and(r0A78, body.constant(1u));
                  ir_expression *const r0A7A = expr(ir_unop_bit_not, r0A79);
                  body.emit(assign(r0A40, bit_and(r0A71, r0A7A), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A70->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0A7C = bit_or(r0A3F, r0A40);
                  ir_expression *const r0A7D = equal(r0A7C, body.constant(0u));
                  ir_if *f0A7B = new(mem_ctx) ir_if(operand(r0A7D).val);
                  exec_list *const f0A7B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A7B->then_instructions;

                     body.emit(assign(r0A3E, body.constant(int(0)), 0x01));


                  body.instructions = f0A7B_parent_instructions;
                  body.emit(f0A7B);

                  /* END IF */


               body.instructions = f0A70_parent_instructions;
               body.emit(f0A70);

               /* END IF */

               ir_variable *const r0A7E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0A7E);
               ir_expression *const r0A7F = lshift(r07EC, body.constant(int(31)));
               ir_expression *const r0A80 = expr(ir_unop_i2u, r0A3E);
               ir_expression *const r0A81 = lshift(r0A80, body.constant(int(20)));
               ir_expression *const r0A82 = add(r0A7F, r0A81);
               body.emit(assign(r0A7E, add(r0A82, r0A3F), 0x02));

               body.emit(assign(r0A7E, r0A40, 0x01));

               body.emit(assign(r0A43, r0A7E, 0x03));

               body.emit(assign(r0A42, body.constant(false), 0x01));


            body.instructions = f0A6F_parent_instructions;
            body.emit(f0A6F);

            /* END IF */

            body.emit(assign(r099A, r0A43, 0x03));


         body.instructions = f09B3_parent_instructions;
         body.emit(f09B3);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f09B1->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0A84 = less(r099B, body.constant(int(0)));
         ir_if *f0A83 = new(mem_ctx) ir_if(operand(r0A84).val);
         exec_list *const f0A83_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0A83->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0A86 = equal(r09A6, body.constant(int(2047)));
            ir_if *f0A85 = new(mem_ctx) ir_if(operand(r0A86).val);
            exec_list *const f0A85_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A85->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0A88 = bit_or(swizzle_y(r099D), swizzle_x(r099D));
               ir_expression *const r0A89 = nequal(r0A88, body.constant(0u));
               ir_if *f0A87 = new(mem_ctx) ir_if(operand(r0A89).val);
               exec_list *const f0A87_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A87->then_instructions;

                  ir_variable *const r0A8A = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r0A8A, swizzle_x(r07E9), 0x01));

                  ir_variable *const r0A8B = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r0A8B, swizzle_x(r07EA), 0x01));

                  ir_variable *const r0A8C = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0A8D = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0A8E = rshift(swizzle_y(r07E9), body.constant(int(19)));
                  ir_expression *const r0A8F = bit_and(r0A8E, body.constant(4095u));
                  ir_expression *const r0A90 = equal(r0A8F, body.constant(4094u));
                  ir_expression *const r0A91 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0A92 = bit_and(swizzle_y(r07E9), body.constant(524287u));
                  ir_expression *const r0A93 = nequal(r0A92, body.constant(0u));
                  ir_expression *const r0A94 = logic_or(r0A91, r0A93);
                  body.emit(assign(r0A8D, logic_and(r0A90, r0A94), 0x01));

                  ir_variable *const r0A95 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0A96 = lshift(swizzle_y(r07EA), body.constant(int(1)));
                  ir_expression *const r0A97 = lequal(body.constant(4292870144u), r0A96);
                  ir_expression *const r0A98 = nequal(swizzle_x(r07EA), body.constant(0u));
                  ir_expression *const r0A99 = bit_and(swizzle_y(r07EA), body.constant(1048575u));
                  ir_expression *const r0A9A = nequal(r0A99, body.constant(0u));
                  ir_expression *const r0A9B = logic_or(r0A98, r0A9A);
                  body.emit(assign(r0A95, logic_and(r0A97, r0A9B), 0x01));

                  body.emit(assign(r0A8A, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

                  body.emit(assign(r0A8B, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r0A9D = lshift(swizzle_y(r07E9), body.constant(int(1)));
                  ir_expression *const r0A9E = lequal(body.constant(4292870144u), r0A9D);
                  ir_expression *const r0A9F = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0AA0 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
                  ir_expression *const r0AA1 = nequal(r0AA0, body.constant(0u));
                  ir_expression *const r0AA2 = logic_or(r0A9F, r0AA1);
                  ir_expression *const r0AA3 = logic_and(r0A9E, r0AA2);
                  ir_if *f0A9C = new(mem_ctx) ir_if(operand(r0AA3).val);
                  exec_list *const f0A9C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A9C->then_instructions;

                     ir_variable *const r0AA4 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0AA6 = logic_and(r0A8D, r0A95);
                     ir_if *f0AA5 = new(mem_ctx) ir_if(operand(r0AA6).val);
                     exec_list *const f0AA5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0AA5->then_instructions;

                        body.emit(assign(r0AA4, r0A8B, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0AA5->else_instructions;

                        body.emit(assign(r0AA4, r0A8A, 0x03));


                     body.instructions = f0AA5_parent_instructions;
                     body.emit(f0AA5);

                     /* END IF */

                     body.emit(assign(r0A8C, r0AA4, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0A9C->else_instructions;

                     body.emit(assign(r0A8C, r0A8B, 0x03));


                  body.instructions = f0A9C_parent_instructions;
                  body.emit(f0A9C);

                  /* END IF */

                  body.emit(assign(r099A, r0A8C, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A87->else_instructions;

                  ir_variable *const r0AA7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0AA7);
                  ir_expression *const r0AA8 = bit_xor(r07EC, body.constant(1u));
                  ir_expression *const r0AA9 = lshift(r0AA8, body.constant(int(31)));
                  body.emit(assign(r0AA7, add(r0AA9, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0AA7, body.constant(0u), 0x01));

                  body.emit(assign(r099A, r0AA7, 0x03));


               body.instructions = f0A87_parent_instructions;
               body.emit(f0A87);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0A85->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0AAB = equal(r09A2, body.constant(int(0)));
               ir_if *f0AAA = new(mem_ctx) ir_if(operand(r0AAB).val);
               exec_list *const f0AAA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0AAA->then_instructions;

                  body.emit(assign(r099B, add(r099B, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0AAA->else_instructions;

                  body.emit(assign(r099F, bit_or(swizzle_y(r099F), body.constant(1073741824u)), 0x02));


               body.instructions = f0AAA_parent_instructions;
               body.emit(f0AAA);

               /* END IF */

               ir_variable *const r0AAC = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r0AAC, swizzle_y(r099F), 0x01));

               ir_variable *const r0AAD = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r0AAD, swizzle_x(r099F), 0x01));

               ir_variable *const r0AAE = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0AAE, neg(r099B), 0x01));

               ir_variable *const r0AAF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0AAF);
               ir_variable *const r0AB0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0AB0);
               ir_variable *const r0AB1 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0AB2 = neg(r0AAE);
               body.emit(assign(r0AB1, bit_and(r0AB2, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0AB4 = equal(r0AAE, body.constant(int(0)));
               ir_if *f0AB3 = new(mem_ctx) ir_if(operand(r0AB4).val);
               exec_list *const f0AB3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0AB3->then_instructions;

                  body.emit(assign(r0AAF, r0AAD, 0x01));

                  body.emit(assign(r0AB0, r0AAC, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0AB3->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0AB6 = less(r0AAE, body.constant(int(32)));
                  ir_if *f0AB5 = new(mem_ctx) ir_if(operand(r0AB6).val);
                  exec_list *const f0AB5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AB5->then_instructions;

                     ir_expression *const r0AB7 = lshift(swizzle_y(r099F), r0AB1);
                     ir_expression *const r0AB8 = rshift(r09A9, r0AAE);
                     ir_expression *const r0AB9 = bit_or(r0AB7, r0AB8);
                     ir_expression *const r0ABA = lshift(r09A9, r0AB1);
                     ir_expression *const r0ABB = nequal(r0ABA, body.constant(0u));
                     ir_expression *const r0ABC = expr(ir_unop_b2i, r0ABB);
                     ir_expression *const r0ABD = expr(ir_unop_i2u, r0ABC);
                     body.emit(assign(r0AAF, bit_or(r0AB9, r0ABD), 0x01));

                     body.emit(assign(r0AB0, rshift(swizzle_y(r099F), r0AAE), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0AB5->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0ABF = equal(r0AAE, body.constant(int(32)));
                     ir_if *f0ABE = new(mem_ctx) ir_if(operand(r0ABF).val);
                     exec_list *const f0ABE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0ABE->then_instructions;

                        ir_expression *const r0AC0 = nequal(r09A9, body.constant(0u));
                        ir_expression *const r0AC1 = expr(ir_unop_b2i, r0AC0);
                        ir_expression *const r0AC2 = expr(ir_unop_i2u, r0AC1);
                        body.emit(assign(r0AAF, bit_or(swizzle_y(r099F), r0AC2), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0ABE->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0AC4 = less(r0AAE, body.constant(int(64)));
                        ir_if *f0AC3 = new(mem_ctx) ir_if(operand(r0AC4).val);
                        exec_list *const f0AC3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0AC3->then_instructions;

                           ir_expression *const r0AC5 = bit_and(r0AAE, body.constant(int(31)));
                           ir_expression *const r0AC6 = rshift(swizzle_y(r099F), r0AC5);
                           ir_expression *const r0AC7 = lshift(swizzle_y(r099F), r0AB1);
                           ir_expression *const r0AC8 = bit_or(r0AC7, r09A9);
                           ir_expression *const r0AC9 = nequal(r0AC8, body.constant(0u));
                           ir_expression *const r0ACA = expr(ir_unop_b2i, r0AC9);
                           ir_expression *const r0ACB = expr(ir_unop_i2u, r0ACA);
                           body.emit(assign(r0AAF, bit_or(r0AC6, r0ACB), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0AC3->else_instructions;

                           ir_expression *const r0ACC = bit_or(swizzle_y(r099F), r09A9);
                           ir_expression *const r0ACD = nequal(r0ACC, body.constant(0u));
                           ir_expression *const r0ACE = expr(ir_unop_b2i, r0ACD);
                           body.emit(assign(r0AAF, expr(ir_unop_i2u, r0ACE), 0x01));


                        body.instructions = f0AC3_parent_instructions;
                        body.emit(f0AC3);

                        /* END IF */


                     body.instructions = f0ABE_parent_instructions;
                     body.emit(f0ABE);

                     /* END IF */

                     body.emit(assign(r0AB0, body.constant(0u), 0x01));


                  body.instructions = f0AB5_parent_instructions;
                  body.emit(f0AB5);

                  /* END IF */


               body.instructions = f0AB3_parent_instructions;
               body.emit(f0AB3);

               /* END IF */

               body.emit(assign(r099F, r0AB0, 0x02));

               body.emit(assign(r099F, r0AAF, 0x01));

               body.emit(assign(r099D, bit_or(swizzle_y(r099D), body.constant(1073741824u)), 0x02));

               ir_variable *const r0ACF = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r0AD0 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r0AD0, sub(swizzle_x(r099D), r0AAF), 0x01));

               ir_expression *const r0AD1 = sub(swizzle_y(r099D), r0AB0);
               ir_expression *const r0AD2 = less(swizzle_x(r099D), r0AAF);
               ir_expression *const r0AD3 = expr(ir_unop_b2i, r0AD2);
               ir_expression *const r0AD4 = expr(ir_unop_i2u, r0AD3);
               body.emit(assign(r0ACF, sub(r0AD1, r0AD4), 0x01));

               body.emit(assign(r0999, bit_xor(r07EC, body.constant(1u)), 0x01));

               body.emit(assign(r09A0, add(r09A6, body.constant(int(-1))), 0x01));

               ir_variable *const r0AD5 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r0AD5, add(r09A0, body.constant(int(-10))), 0x01));

               ir_variable *const r0AD6 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0AD6, r0ACF, 0x01));

               ir_variable *const r0AD7 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0AD7, r0AD0, 0x01));

               ir_variable *const r0AD8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r0AD8);
               ir_variable *const r0AD9 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r0AD9);
               /* IF CONDITION */
               ir_expression *const r0ADB = equal(r0ACF, body.constant(0u));
               ir_if *f0ADA = new(mem_ctx) ir_if(operand(r0ADB).val);
               exec_list *const f0ADA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0ADA->then_instructions;

                  body.emit(assign(r0AD6, r0AD0, 0x01));

                  body.emit(assign(r0AD7, body.constant(0u), 0x01));

                  body.emit(assign(r0AD5, add(r0AD5, body.constant(int(-32))), 0x01));


               body.instructions = f0ADA_parent_instructions;
               body.emit(f0ADA);

               /* END IF */

               ir_variable *const r0ADC = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r0ADC, r0AD6, 0x01));

               ir_variable *const r0ADD = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r0ADE = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r0ADE);
               /* IF CONDITION */
               ir_expression *const r0AE0 = equal(r0AD6, body.constant(0u));
               ir_if *f0ADF = new(mem_ctx) ir_if(operand(r0AE0).val);
               exec_list *const f0ADF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0ADF->then_instructions;

                  body.emit(assign(r0ADD, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0ADF->else_instructions;

                  body.emit(assign(r0ADE, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0AE2 = bit_and(r0AD6, body.constant(4294901760u));
                  ir_expression *const r0AE3 = equal(r0AE2, body.constant(0u));
                  ir_if *f0AE1 = new(mem_ctx) ir_if(operand(r0AE3).val);
                  exec_list *const f0AE1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AE1->then_instructions;

                     body.emit(assign(r0ADE, body.constant(int(16)), 0x01));

                     body.emit(assign(r0ADC, lshift(r0AD6, body.constant(int(16))), 0x01));


                  body.instructions = f0AE1_parent_instructions;
                  body.emit(f0AE1);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0AE5 = bit_and(r0ADC, body.constant(4278190080u));
                  ir_expression *const r0AE6 = equal(r0AE5, body.constant(0u));
                  ir_if *f0AE4 = new(mem_ctx) ir_if(operand(r0AE6).val);
                  exec_list *const f0AE4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AE4->then_instructions;

                     body.emit(assign(r0ADE, add(r0ADE, body.constant(int(8))), 0x01));

                     body.emit(assign(r0ADC, lshift(r0ADC, body.constant(int(8))), 0x01));


                  body.instructions = f0AE4_parent_instructions;
                  body.emit(f0AE4);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0AE8 = bit_and(r0ADC, body.constant(4026531840u));
                  ir_expression *const r0AE9 = equal(r0AE8, body.constant(0u));
                  ir_if *f0AE7 = new(mem_ctx) ir_if(operand(r0AE9).val);
                  exec_list *const f0AE7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AE7->then_instructions;

                     body.emit(assign(r0ADE, add(r0ADE, body.constant(int(4))), 0x01));

                     body.emit(assign(r0ADC, lshift(r0ADC, body.constant(int(4))), 0x01));


                  body.instructions = f0AE7_parent_instructions;
                  body.emit(f0AE7);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0AEB = bit_and(r0ADC, body.constant(3221225472u));
                  ir_expression *const r0AEC = equal(r0AEB, body.constant(0u));
                  ir_if *f0AEA = new(mem_ctx) ir_if(operand(r0AEC).val);
                  exec_list *const f0AEA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AEA->then_instructions;

                     body.emit(assign(r0ADE, add(r0ADE, body.constant(int(2))), 0x01));

                     body.emit(assign(r0ADC, lshift(r0ADC, body.constant(int(2))), 0x01));


                  body.instructions = f0AEA_parent_instructions;
                  body.emit(f0AEA);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0AEE = bit_and(r0ADC, body.constant(2147483648u));
                  ir_expression *const r0AEF = equal(r0AEE, body.constant(0u));
                  ir_if *f0AED = new(mem_ctx) ir_if(operand(r0AEF).val);
                  exec_list *const f0AED_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AED->then_instructions;

                     body.emit(assign(r0ADE, add(r0ADE, body.constant(int(1))), 0x01));


                  body.instructions = f0AED_parent_instructions;
                  body.emit(f0AED);

                  /* END IF */

                  body.emit(assign(r0ADD, r0ADE, 0x01));


               body.instructions = f0ADF_parent_instructions;
               body.emit(f0ADF);

               /* END IF */

               body.emit(assign(r0AD9, add(r0ADD, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0AF1 = lequal(body.constant(int(0)), r0AD9);
               ir_if *f0AF0 = new(mem_ctx) ir_if(operand(r0AF1).val);
               exec_list *const f0AF0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0AF0->then_instructions;

                  body.emit(assign(r0AD8, body.constant(0u), 0x01));

                  ir_variable *const r0AF2 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0AF2, lshift(r0AD7, r0AD9), 0x01));

                  ir_variable *const r0AF3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0AF5 = equal(r0AD9, body.constant(int(0)));
                  ir_if *f0AF4 = new(mem_ctx) ir_if(operand(r0AF5).val);
                  exec_list *const f0AF4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AF4->then_instructions;

                     body.emit(assign(r0AF3, r0AD6, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0AF4->else_instructions;

                     ir_expression *const r0AF6 = lshift(r0AD6, r0AD9);
                     ir_expression *const r0AF7 = neg(r0AD9);
                     ir_expression *const r0AF8 = bit_and(r0AF7, body.constant(int(31)));
                     ir_expression *const r0AF9 = rshift(r0AD7, r0AF8);
                     body.emit(assign(r0AF3, bit_or(r0AF6, r0AF9), 0x01));


                  body.instructions = f0AF4_parent_instructions;
                  body.emit(f0AF4);

                  /* END IF */

                  body.emit(assign(r0AD6, r0AF3, 0x01));

                  body.emit(assign(r0AD7, r0AF2, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0AF0->else_instructions;

                  ir_variable *const r0AFA = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r0AFA, body.constant(0u), 0x01));

                  ir_variable *const r0AFB = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r0AFB, neg(r0AD9), 0x01));

                  ir_variable *const r0AFC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r0AFC);
                  ir_variable *const r0AFD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r0AFD);
                  ir_variable *const r0AFE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r0AFE);
                  ir_variable *const r0AFF = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r0B00 = neg(r0AFB);
                  body.emit(assign(r0AFF, bit_and(r0B00, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0B02 = equal(r0AFB, body.constant(int(0)));
                  ir_if *f0B01 = new(mem_ctx) ir_if(operand(r0B02).val);
                  exec_list *const f0B01_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B01->then_instructions;

                     body.emit(assign(r0AFC, r0AFA, 0x01));

                     body.emit(assign(r0AFD, r0AD7, 0x01));

                     body.emit(assign(r0AFE, r0AD6, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B01->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0B04 = less(r0AFB, body.constant(int(32)));
                     ir_if *f0B03 = new(mem_ctx) ir_if(operand(r0B04).val);
                     exec_list *const f0B03_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B03->then_instructions;

                        body.emit(assign(r0AFC, lshift(r0AD7, r0AFF), 0x01));

                        ir_expression *const r0B05 = lshift(r0AD6, r0AFF);
                        ir_expression *const r0B06 = rshift(r0AD7, r0AFB);
                        body.emit(assign(r0AFD, bit_or(r0B05, r0B06), 0x01));

                        body.emit(assign(r0AFE, rshift(r0AD6, r0AFB), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0B03->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0B08 = equal(r0AFB, body.constant(int(32)));
                        ir_if *f0B07 = new(mem_ctx) ir_if(operand(r0B08).val);
                        exec_list *const f0B07_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0B07->then_instructions;

                           body.emit(assign(r0AFC, r0AD7, 0x01));

                           body.emit(assign(r0AFD, r0AD6, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0B07->else_instructions;

                           body.emit(assign(r0AFA, bit_or(body.constant(0u), r0AD7), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0B0A = less(r0AFB, body.constant(int(64)));
                           ir_if *f0B09 = new(mem_ctx) ir_if(operand(r0B0A).val);
                           exec_list *const f0B09_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0B09->then_instructions;

                              body.emit(assign(r0AFC, lshift(r0AD6, r0AFF), 0x01));

                              ir_expression *const r0B0B = bit_and(r0AFB, body.constant(int(31)));
                              body.emit(assign(r0AFD, rshift(r0AD6, r0B0B), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0B09->else_instructions;

                              ir_variable *const r0B0C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0B0E = equal(r0AFB, body.constant(int(64)));
                              ir_if *f0B0D = new(mem_ctx) ir_if(operand(r0B0E).val);
                              exec_list *const f0B0D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0B0D->then_instructions;

                                 body.emit(assign(r0B0C, r0AD6, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0B0D->else_instructions;

                                 ir_expression *const r0B0F = nequal(r0AD6, body.constant(0u));
                                 ir_expression *const r0B10 = expr(ir_unop_b2i, r0B0F);
                                 body.emit(assign(r0B0C, expr(ir_unop_i2u, r0B10), 0x01));


                              body.instructions = f0B0D_parent_instructions;
                              body.emit(f0B0D);

                              /* END IF */

                              body.emit(assign(r0AFC, r0B0C, 0x01));

                              body.emit(assign(r0AFD, body.constant(0u), 0x01));


                           body.instructions = f0B09_parent_instructions;
                           body.emit(f0B09);

                           /* END IF */


                        body.instructions = f0B07_parent_instructions;
                        body.emit(f0B07);

                        /* END IF */

                        body.emit(assign(r0AFE, body.constant(0u), 0x01));


                     body.instructions = f0B03_parent_instructions;
                     body.emit(f0B03);

                     /* END IF */

                     ir_expression *const r0B11 = nequal(r0AFA, body.constant(0u));
                     ir_expression *const r0B12 = expr(ir_unop_b2i, r0B11);
                     ir_expression *const r0B13 = expr(ir_unop_i2u, r0B12);
                     body.emit(assign(r0AFC, bit_or(r0AFC, r0B13), 0x01));


                  body.instructions = f0B01_parent_instructions;
                  body.emit(f0B01);

                  /* END IF */

                  body.emit(assign(r0AD6, r0AFE, 0x01));

                  body.emit(assign(r0AD7, r0AFD, 0x01));

                  body.emit(assign(r0AD8, r0AFC, 0x01));


               body.instructions = f0AF0_parent_instructions;
               body.emit(f0AF0);

               /* END IF */

               body.emit(assign(r0AD5, sub(r0AD5, r0AD9), 0x01));

               ir_variable *const r0B14 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r0B14, r0AD5, 0x01));

               ir_variable *const r0B15 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0B15, r0AD6, 0x01));

               ir_variable *const r0B16 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0B16, r0AD7, 0x01));

               ir_variable *const r0B17 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r0B17, r0AD8, 0x01));

               ir_variable *const r0B18 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r0B18, body.constant(true), 0x01));

               ir_variable *const r0B19 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0B1A = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r0B1A);
               ir_expression *const r0B1B = expr(ir_unop_u2i, r0AD8);
               body.emit(assign(r0B1A, less(r0B1B, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0B1D = lequal(body.constant(int(2045)), r0AD5);
               ir_if *f0B1C = new(mem_ctx) ir_if(operand(r0B1D).val);
               exec_list *const f0B1C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B1C->then_instructions;

                  ir_variable *const r0B1E = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0B20 = less(body.constant(int(2045)), r0AD5);
                  ir_if *f0B1F = new(mem_ctx) ir_if(operand(r0B20).val);
                  exec_list *const f0B1F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B1F->then_instructions;

                     body.emit(assign(r0B1E, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B1F->else_instructions;

                     ir_variable *const r0B21 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0B23 = equal(r0AD5, body.constant(int(2045)));
                     ir_if *f0B22 = new(mem_ctx) ir_if(operand(r0B23).val);
                     exec_list *const f0B22_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B22->then_instructions;

                        ir_expression *const r0B24 = equal(body.constant(2097151u), r0AD6);
                        ir_expression *const r0B25 = equal(body.constant(4294967295u), r0AD7);
                        body.emit(assign(r0B21, logic_and(r0B24, r0B25), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0B22->else_instructions;

                        body.emit(assign(r0B21, body.constant(false), 0x01));


                     body.instructions = f0B22_parent_instructions;
                     body.emit(f0B22);

                     /* END IF */

                     body.emit(assign(r0B1E, logic_and(r0B21, r0B1A), 0x01));


                  body.instructions = f0B1F_parent_instructions;
                  body.emit(f0B1F);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0B26 = new(mem_ctx) ir_if(operand(r0B1E).val);
                  exec_list *const f0B26_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B26->then_instructions;

                     ir_variable *const r0B27 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0B27);
                     ir_expression *const r0B28 = lshift(r0999, body.constant(int(31)));
                     body.emit(assign(r0B27, add(r0B28, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r0B27, body.constant(0u), 0x01));

                     body.emit(assign(r0B19, r0B27, 0x03));

                     body.emit(assign(r0B18, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B26->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0B2A = less(r0AD5, body.constant(int(0)));
                     ir_if *f0B29 = new(mem_ctx) ir_if(operand(r0B2A).val);
                     exec_list *const f0B29_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B29->then_instructions;

                        ir_variable *const r0B2B = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0B2B, r0AD8, 0x01));

                        ir_variable *const r0B2C = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0B2C, neg(r0AD5), 0x01));

                        ir_variable *const r0B2D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0B2D);
                        ir_variable *const r0B2E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0B2E);
                        ir_variable *const r0B2F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0B2F);
                        ir_variable *const r0B30 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r0B31 = neg(r0B2C);
                        body.emit(assign(r0B30, bit_and(r0B31, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0B33 = equal(r0B2C, body.constant(int(0)));
                        ir_if *f0B32 = new(mem_ctx) ir_if(operand(r0B33).val);
                        exec_list *const f0B32_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0B32->then_instructions;

                           body.emit(assign(r0B2D, r0AD8, 0x01));

                           body.emit(assign(r0B2E, r0AD7, 0x01));

                           body.emit(assign(r0B2F, r0AD6, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0B32->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0B35 = less(r0B2C, body.constant(int(32)));
                           ir_if *f0B34 = new(mem_ctx) ir_if(operand(r0B35).val);
                           exec_list *const f0B34_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0B34->then_instructions;

                              body.emit(assign(r0B2D, lshift(r0AD7, r0B30), 0x01));

                              ir_expression *const r0B36 = lshift(r0AD6, r0B30);
                              ir_expression *const r0B37 = rshift(r0AD7, r0B2C);
                              body.emit(assign(r0B2E, bit_or(r0B36, r0B37), 0x01));

                              body.emit(assign(r0B2F, rshift(r0AD6, r0B2C), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0B34->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0B39 = equal(r0B2C, body.constant(int(32)));
                              ir_if *f0B38 = new(mem_ctx) ir_if(operand(r0B39).val);
                              exec_list *const f0B38_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0B38->then_instructions;

                                 body.emit(assign(r0B2D, r0AD7, 0x01));

                                 body.emit(assign(r0B2E, r0AD6, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0B38->else_instructions;

                                 body.emit(assign(r0B2B, bit_or(r0AD8, r0AD7), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0B3B = less(r0B2C, body.constant(int(64)));
                                 ir_if *f0B3A = new(mem_ctx) ir_if(operand(r0B3B).val);
                                 exec_list *const f0B3A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0B3A->then_instructions;

                                    body.emit(assign(r0B2D, lshift(r0AD6, r0B30), 0x01));

                                    ir_expression *const r0B3C = bit_and(r0B2C, body.constant(int(31)));
                                    body.emit(assign(r0B2E, rshift(r0AD6, r0B3C), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0B3A->else_instructions;

                                    ir_variable *const r0B3D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r0B3F = equal(r0B2C, body.constant(int(64)));
                                    ir_if *f0B3E = new(mem_ctx) ir_if(operand(r0B3F).val);
                                    exec_list *const f0B3E_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0B3E->then_instructions;

                                       body.emit(assign(r0B3D, r0AD6, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0B3E->else_instructions;

                                       ir_expression *const r0B40 = nequal(r0AD6, body.constant(0u));
                                       ir_expression *const r0B41 = expr(ir_unop_b2i, r0B40);
                                       body.emit(assign(r0B3D, expr(ir_unop_i2u, r0B41), 0x01));


                                    body.instructions = f0B3E_parent_instructions;
                                    body.emit(f0B3E);

                                    /* END IF */

                                    body.emit(assign(r0B2D, r0B3D, 0x01));

                                    body.emit(assign(r0B2E, body.constant(0u), 0x01));


                                 body.instructions = f0B3A_parent_instructions;
                                 body.emit(f0B3A);

                                 /* END IF */


                              body.instructions = f0B38_parent_instructions;
                              body.emit(f0B38);

                              /* END IF */

                              body.emit(assign(r0B2F, body.constant(0u), 0x01));


                           body.instructions = f0B34_parent_instructions;
                           body.emit(f0B34);

                           /* END IF */

                           ir_expression *const r0B42 = nequal(r0B2B, body.constant(0u));
                           ir_expression *const r0B43 = expr(ir_unop_b2i, r0B42);
                           ir_expression *const r0B44 = expr(ir_unop_i2u, r0B43);
                           body.emit(assign(r0B2D, bit_or(r0B2D, r0B44), 0x01));


                        body.instructions = f0B32_parent_instructions;
                        body.emit(f0B32);

                        /* END IF */

                        body.emit(assign(r0B15, r0B2F, 0x01));

                        body.emit(assign(r0B16, r0B2E, 0x01));

                        body.emit(assign(r0B17, r0B2D, 0x01));

                        body.emit(assign(r0B14, body.constant(int(0)), 0x01));

                        body.emit(assign(r0B1A, less(r0B2D, body.constant(0u)), 0x01));


                     body.instructions = f0B29_parent_instructions;
                     body.emit(f0B29);

                     /* END IF */


                  body.instructions = f0B26_parent_instructions;
                  body.emit(f0B26);

                  /* END IF */


               body.instructions = f0B1C_parent_instructions;
               body.emit(f0B1C);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0B45 = new(mem_ctx) ir_if(operand(r0B18).val);
               exec_list *const f0B45_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B45->then_instructions;

                  /* IF CONDITION */
                  ir_if *f0B46 = new(mem_ctx) ir_if(operand(r0B1A).val);
                  exec_list *const f0B46_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B46->then_instructions;

                     ir_variable *const r0B47 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r0B47, add(r0B16, body.constant(1u)), 0x01));

                     ir_expression *const r0B48 = less(r0B47, r0B16);
                     ir_expression *const r0B49 = expr(ir_unop_b2i, r0B48);
                     ir_expression *const r0B4A = expr(ir_unop_i2u, r0B49);
                     body.emit(assign(r0B15, add(r0B15, r0B4A), 0x01));

                     ir_expression *const r0B4B = equal(r0B17, body.constant(0u));
                     ir_expression *const r0B4C = expr(ir_unop_b2i, r0B4B);
                     ir_expression *const r0B4D = expr(ir_unop_i2u, r0B4C);
                     ir_expression *const r0B4E = add(r0B17, r0B4D);
                     ir_expression *const r0B4F = bit_and(r0B4E, body.constant(1u));
                     ir_expression *const r0B50 = expr(ir_unop_bit_not, r0B4F);
                     body.emit(assign(r0B16, bit_and(r0B47, r0B50), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B46->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0B52 = bit_or(r0B15, r0B16);
                     ir_expression *const r0B53 = equal(r0B52, body.constant(0u));
                     ir_if *f0B51 = new(mem_ctx) ir_if(operand(r0B53).val);
                     exec_list *const f0B51_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B51->then_instructions;

                        body.emit(assign(r0B14, body.constant(int(0)), 0x01));


                     body.instructions = f0B51_parent_instructions;
                     body.emit(f0B51);

                     /* END IF */


                  body.instructions = f0B46_parent_instructions;
                  body.emit(f0B46);

                  /* END IF */

                  ir_variable *const r0B54 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0B54);
                  ir_expression *const r0B55 = lshift(r0999, body.constant(int(31)));
                  ir_expression *const r0B56 = expr(ir_unop_i2u, r0B14);
                  ir_expression *const r0B57 = lshift(r0B56, body.constant(int(20)));
                  ir_expression *const r0B58 = add(r0B55, r0B57);
                  body.emit(assign(r0B54, add(r0B58, r0B15), 0x02));

                  body.emit(assign(r0B54, r0B16, 0x01));

                  body.emit(assign(r0B19, r0B54, 0x03));

                  body.emit(assign(r0B18, body.constant(false), 0x01));


               body.instructions = f0B45_parent_instructions;
               body.emit(f0B45);

               /* END IF */

               body.emit(assign(r099A, r0B19, 0x03));


            body.instructions = f0A85_parent_instructions;
            body.emit(f0A85);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0A83->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0B5A = equal(r09A2, body.constant(int(2047)));
            ir_if *f0B59 = new(mem_ctx) ir_if(operand(r0B5A).val);
            exec_list *const f0B59_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0B59->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0B5C = bit_or(swizzle_y(r099F), swizzle_x(r099F));
               ir_expression *const r0B5D = bit_or(swizzle_y(r099D), swizzle_x(r099D));
               ir_expression *const r0B5E = bit_or(r0B5C, r0B5D);
               ir_expression *const r0B5F = nequal(r0B5E, body.constant(0u));
               ir_if *f0B5B = new(mem_ctx) ir_if(operand(r0B5F).val);
               exec_list *const f0B5B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B5B->then_instructions;

                  ir_variable *const r0B60 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r0B60, swizzle_x(r07E9), 0x01));

                  ir_variable *const r0B61 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r0B61, swizzle_x(r07EA), 0x01));

                  ir_variable *const r0B62 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0B63 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0B64 = rshift(swizzle_y(r07E9), body.constant(int(19)));
                  ir_expression *const r0B65 = bit_and(r0B64, body.constant(4095u));
                  ir_expression *const r0B66 = equal(r0B65, body.constant(4094u));
                  ir_expression *const r0B67 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0B68 = bit_and(swizzle_y(r07E9), body.constant(524287u));
                  ir_expression *const r0B69 = nequal(r0B68, body.constant(0u));
                  ir_expression *const r0B6A = logic_or(r0B67, r0B69);
                  body.emit(assign(r0B63, logic_and(r0B66, r0B6A), 0x01));

                  ir_variable *const r0B6B = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0B6C = lshift(swizzle_y(r07EA), body.constant(int(1)));
                  ir_expression *const r0B6D = lequal(body.constant(4292870144u), r0B6C);
                  ir_expression *const r0B6E = nequal(swizzle_x(r07EA), body.constant(0u));
                  ir_expression *const r0B6F = bit_and(swizzle_y(r07EA), body.constant(1048575u));
                  ir_expression *const r0B70 = nequal(r0B6F, body.constant(0u));
                  ir_expression *const r0B71 = logic_or(r0B6E, r0B70);
                  body.emit(assign(r0B6B, logic_and(r0B6D, r0B71), 0x01));

                  body.emit(assign(r0B60, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

                  body.emit(assign(r0B61, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r0B73 = lshift(swizzle_y(r07E9), body.constant(int(1)));
                  ir_expression *const r0B74 = lequal(body.constant(4292870144u), r0B73);
                  ir_expression *const r0B75 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0B76 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
                  ir_expression *const r0B77 = nequal(r0B76, body.constant(0u));
                  ir_expression *const r0B78 = logic_or(r0B75, r0B77);
                  ir_expression *const r0B79 = logic_and(r0B74, r0B78);
                  ir_if *f0B72 = new(mem_ctx) ir_if(operand(r0B79).val);
                  exec_list *const f0B72_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B72->then_instructions;

                     ir_variable *const r0B7A = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0B7C = logic_and(r0B63, r0B6B);
                     ir_if *f0B7B = new(mem_ctx) ir_if(operand(r0B7C).val);
                     exec_list *const f0B7B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B7B->then_instructions;

                        body.emit(assign(r0B7A, r0B61, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0B7B->else_instructions;

                        body.emit(assign(r0B7A, r0B60, 0x03));


                     body.instructions = f0B7B_parent_instructions;
                     body.emit(f0B7B);

                     /* END IF */

                     body.emit(assign(r0B62, r0B7A, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B72->else_instructions;

                     body.emit(assign(r0B62, r0B61, 0x03));


                  body.instructions = f0B72_parent_instructions;
                  body.emit(f0B72);

                  /* END IF */

                  body.emit(assign(r099A, r0B62, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0B5B->else_instructions;

                  ir_constant_data r0B7D_data;
                  memset(&r0B7D_data, 0, sizeof(ir_constant_data));
r0B7D_data.u[0] = 4294967295;
r0B7D_data.u[1] = 4294967295;
                  ir_constant *const r0B7D = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r0B7D_data);
                  body.emit(assign(r099A, r0B7D, 0x03));


               body.instructions = f0B5B_parent_instructions;
               body.emit(f0B5B);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0B59->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0B7F = equal(r09A2, body.constant(int(0)));
               ir_if *f0B7E = new(mem_ctx) ir_if(operand(r0B7F).val);
               exec_list *const f0B7E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B7E->then_instructions;

                  body.emit(assign(r099E, body.constant(int(1)), 0x01));

                  body.emit(assign(r099C, body.constant(int(1)), 0x01));


               body.instructions = f0B7E_parent_instructions;
               body.emit(f0B7E);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0B81 = less(swizzle_y(r099D), swizzle_y(r099F));
               ir_if *f0B80 = new(mem_ctx) ir_if(operand(r0B81).val);
               exec_list *const f0B80_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B80->then_instructions;

                  ir_variable *const r0B82 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r0B83 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0B83, sub(swizzle_x(r099F), swizzle_x(r099D)), 0x01));

                  ir_expression *const r0B84 = sub(swizzle_y(r099F), swizzle_y(r099D));
                  ir_expression *const r0B85 = less(swizzle_x(r099F), swizzle_x(r099D));
                  ir_expression *const r0B86 = expr(ir_unop_b2i, r0B85);
                  ir_expression *const r0B87 = expr(ir_unop_i2u, r0B86);
                  body.emit(assign(r0B82, sub(r0B84, r0B87), 0x01));

                  body.emit(assign(r09A0, add(r099E, body.constant(int(-1))), 0x01));

                  ir_variable *const r0B88 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r0B88, add(r09A0, body.constant(int(-10))), 0x01));

                  ir_variable *const r0B89 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r0B89, r0B82, 0x01));

                  ir_variable *const r0B8A = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r0B8A, r0B83, 0x01));

                  ir_variable *const r0B8B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r0B8B);
                  ir_variable *const r0B8C = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0B8C);
                  /* IF CONDITION */
                  ir_expression *const r0B8E = equal(r0B82, body.constant(0u));
                  ir_if *f0B8D = new(mem_ctx) ir_if(operand(r0B8E).val);
                  exec_list *const f0B8D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B8D->then_instructions;

                     body.emit(assign(r0B89, r0B83, 0x01));

                     body.emit(assign(r0B8A, body.constant(0u), 0x01));

                     body.emit(assign(r0B88, add(r0B88, body.constant(int(-32))), 0x01));


                  body.instructions = f0B8D_parent_instructions;
                  body.emit(f0B8D);

                  /* END IF */

                  ir_variable *const r0B8F = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r0B8F, r0B89, 0x01));

                  ir_variable *const r0B90 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r0B91 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0B91);
                  /* IF CONDITION */
                  ir_expression *const r0B93 = equal(r0B89, body.constant(0u));
                  ir_if *f0B92 = new(mem_ctx) ir_if(operand(r0B93).val);
                  exec_list *const f0B92_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B92->then_instructions;

                     body.emit(assign(r0B90, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B92->else_instructions;

                     body.emit(assign(r0B91, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0B95 = bit_and(r0B89, body.constant(4294901760u));
                     ir_expression *const r0B96 = equal(r0B95, body.constant(0u));
                     ir_if *f0B94 = new(mem_ctx) ir_if(operand(r0B96).val);
                     exec_list *const f0B94_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B94->then_instructions;

                        body.emit(assign(r0B91, body.constant(int(16)), 0x01));

                        body.emit(assign(r0B8F, lshift(r0B89, body.constant(int(16))), 0x01));


                     body.instructions = f0B94_parent_instructions;
                     body.emit(f0B94);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0B98 = bit_and(r0B8F, body.constant(4278190080u));
                     ir_expression *const r0B99 = equal(r0B98, body.constant(0u));
                     ir_if *f0B97 = new(mem_ctx) ir_if(operand(r0B99).val);
                     exec_list *const f0B97_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B97->then_instructions;

                        body.emit(assign(r0B91, add(r0B91, body.constant(int(8))), 0x01));

                        body.emit(assign(r0B8F, lshift(r0B8F, body.constant(int(8))), 0x01));


                     body.instructions = f0B97_parent_instructions;
                     body.emit(f0B97);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0B9B = bit_and(r0B8F, body.constant(4026531840u));
                     ir_expression *const r0B9C = equal(r0B9B, body.constant(0u));
                     ir_if *f0B9A = new(mem_ctx) ir_if(operand(r0B9C).val);
                     exec_list *const f0B9A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B9A->then_instructions;

                        body.emit(assign(r0B91, add(r0B91, body.constant(int(4))), 0x01));

                        body.emit(assign(r0B8F, lshift(r0B8F, body.constant(int(4))), 0x01));


                     body.instructions = f0B9A_parent_instructions;
                     body.emit(f0B9A);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0B9E = bit_and(r0B8F, body.constant(3221225472u));
                     ir_expression *const r0B9F = equal(r0B9E, body.constant(0u));
                     ir_if *f0B9D = new(mem_ctx) ir_if(operand(r0B9F).val);
                     exec_list *const f0B9D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B9D->then_instructions;

                        body.emit(assign(r0B91, add(r0B91, body.constant(int(2))), 0x01));

                        body.emit(assign(r0B8F, lshift(r0B8F, body.constant(int(2))), 0x01));


                     body.instructions = f0B9D_parent_instructions;
                     body.emit(f0B9D);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0BA1 = bit_and(r0B8F, body.constant(2147483648u));
                     ir_expression *const r0BA2 = equal(r0BA1, body.constant(0u));
                     ir_if *f0BA0 = new(mem_ctx) ir_if(operand(r0BA2).val);
                     exec_list *const f0BA0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BA0->then_instructions;

                        body.emit(assign(r0B91, add(r0B91, body.constant(int(1))), 0x01));


                     body.instructions = f0BA0_parent_instructions;
                     body.emit(f0BA0);

                     /* END IF */

                     body.emit(assign(r0B90, r0B91, 0x01));


                  body.instructions = f0B92_parent_instructions;
                  body.emit(f0B92);

                  /* END IF */

                  body.emit(assign(r0B8C, add(r0B90, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0BA4 = lequal(body.constant(int(0)), r0B8C);
                  ir_if *f0BA3 = new(mem_ctx) ir_if(operand(r0BA4).val);
                  exec_list *const f0BA3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0BA3->then_instructions;

                     body.emit(assign(r0B8B, body.constant(0u), 0x01));

                     ir_variable *const r0BA5 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r0BA5, lshift(r0B8A, r0B8C), 0x01));

                     ir_variable *const r0BA6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0BA8 = equal(r0B8C, body.constant(int(0)));
                     ir_if *f0BA7 = new(mem_ctx) ir_if(operand(r0BA8).val);
                     exec_list *const f0BA7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BA7->then_instructions;

                        body.emit(assign(r0BA6, r0B89, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BA7->else_instructions;

                        ir_expression *const r0BA9 = lshift(r0B89, r0B8C);
                        ir_expression *const r0BAA = neg(r0B8C);
                        ir_expression *const r0BAB = bit_and(r0BAA, body.constant(int(31)));
                        ir_expression *const r0BAC = rshift(r0B8A, r0BAB);
                        body.emit(assign(r0BA6, bit_or(r0BA9, r0BAC), 0x01));


                     body.instructions = f0BA7_parent_instructions;
                     body.emit(f0BA7);

                     /* END IF */

                     body.emit(assign(r0B89, r0BA6, 0x01));

                     body.emit(assign(r0B8A, r0BA5, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0BA3->else_instructions;

                     ir_variable *const r0BAD = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0BAD, body.constant(0u), 0x01));

                     ir_variable *const r0BAE = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0BAE, neg(r0B8C), 0x01));

                     ir_variable *const r0BAF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0BAF);
                     ir_variable *const r0BB0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0BB0);
                     ir_variable *const r0BB1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0BB1);
                     ir_variable *const r0BB2 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0BB3 = neg(r0BAE);
                     body.emit(assign(r0BB2, bit_and(r0BB3, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0BB5 = equal(r0BAE, body.constant(int(0)));
                     ir_if *f0BB4 = new(mem_ctx) ir_if(operand(r0BB5).val);
                     exec_list *const f0BB4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BB4->then_instructions;

                        body.emit(assign(r0BAF, r0BAD, 0x01));

                        body.emit(assign(r0BB0, r0B8A, 0x01));

                        body.emit(assign(r0BB1, r0B89, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BB4->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0BB7 = less(r0BAE, body.constant(int(32)));
                        ir_if *f0BB6 = new(mem_ctx) ir_if(operand(r0BB7).val);
                        exec_list *const f0BB6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0BB6->then_instructions;

                           body.emit(assign(r0BAF, lshift(r0B8A, r0BB2), 0x01));

                           ir_expression *const r0BB8 = lshift(r0B89, r0BB2);
                           ir_expression *const r0BB9 = rshift(r0B8A, r0BAE);
                           body.emit(assign(r0BB0, bit_or(r0BB8, r0BB9), 0x01));

                           body.emit(assign(r0BB1, rshift(r0B89, r0BAE), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0BB6->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0BBB = equal(r0BAE, body.constant(int(32)));
                           ir_if *f0BBA = new(mem_ctx) ir_if(operand(r0BBB).val);
                           exec_list *const f0BBA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0BBA->then_instructions;

                              body.emit(assign(r0BAF, r0B8A, 0x01));

                              body.emit(assign(r0BB0, r0B89, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0BBA->else_instructions;

                              body.emit(assign(r0BAD, bit_or(body.constant(0u), r0B8A), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0BBD = less(r0BAE, body.constant(int(64)));
                              ir_if *f0BBC = new(mem_ctx) ir_if(operand(r0BBD).val);
                              exec_list *const f0BBC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0BBC->then_instructions;

                                 body.emit(assign(r0BAF, lshift(r0B89, r0BB2), 0x01));

                                 ir_expression *const r0BBE = bit_and(r0BAE, body.constant(int(31)));
                                 body.emit(assign(r0BB0, rshift(r0B89, r0BBE), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0BBC->else_instructions;

                                 ir_variable *const r0BBF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0BC1 = equal(r0BAE, body.constant(int(64)));
                                 ir_if *f0BC0 = new(mem_ctx) ir_if(operand(r0BC1).val);
                                 exec_list *const f0BC0_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0BC0->then_instructions;

                                    body.emit(assign(r0BBF, r0B89, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0BC0->else_instructions;

                                    ir_expression *const r0BC2 = nequal(r0B89, body.constant(0u));
                                    ir_expression *const r0BC3 = expr(ir_unop_b2i, r0BC2);
                                    body.emit(assign(r0BBF, expr(ir_unop_i2u, r0BC3), 0x01));


                                 body.instructions = f0BC0_parent_instructions;
                                 body.emit(f0BC0);

                                 /* END IF */

                                 body.emit(assign(r0BAF, r0BBF, 0x01));

                                 body.emit(assign(r0BB0, body.constant(0u), 0x01));


                              body.instructions = f0BBC_parent_instructions;
                              body.emit(f0BBC);

                              /* END IF */


                           body.instructions = f0BBA_parent_instructions;
                           body.emit(f0BBA);

                           /* END IF */

                           body.emit(assign(r0BB1, body.constant(0u), 0x01));


                        body.instructions = f0BB6_parent_instructions;
                        body.emit(f0BB6);

                        /* END IF */

                        ir_expression *const r0BC4 = nequal(r0BAD, body.constant(0u));
                        ir_expression *const r0BC5 = expr(ir_unop_b2i, r0BC4);
                        ir_expression *const r0BC6 = expr(ir_unop_i2u, r0BC5);
                        body.emit(assign(r0BAF, bit_or(r0BAF, r0BC6), 0x01));


                     body.instructions = f0BB4_parent_instructions;
                     body.emit(f0BB4);

                     /* END IF */

                     body.emit(assign(r0B89, r0BB1, 0x01));

                     body.emit(assign(r0B8A, r0BB0, 0x01));

                     body.emit(assign(r0B8B, r0BAF, 0x01));


                  body.instructions = f0BA3_parent_instructions;
                  body.emit(f0BA3);

                  /* END IF */

                  body.emit(assign(r0B88, sub(r0B88, r0B8C), 0x01));

                  ir_variable *const r0BC7 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r0BC7, r0B88, 0x01));

                  ir_variable *const r0BC8 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r0BC8, r0B89, 0x01));

                  ir_variable *const r0BC9 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r0BC9, r0B8A, 0x01));

                  ir_variable *const r0BCA = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r0BCA, r0B8B, 0x01));

                  ir_variable *const r0BCB = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r0BCB, body.constant(true), 0x01));

                  ir_variable *const r0BCC = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0BCD = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r0BCD);
                  ir_expression *const r0BCE = expr(ir_unop_u2i, r0B8B);
                  body.emit(assign(r0BCD, less(r0BCE, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0BD0 = lequal(body.constant(int(2045)), r0B88);
                  ir_if *f0BCF = new(mem_ctx) ir_if(operand(r0BD0).val);
                  exec_list *const f0BCF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0BCF->then_instructions;

                     ir_variable *const r0BD1 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0BD3 = less(body.constant(int(2045)), r0B88);
                     ir_if *f0BD2 = new(mem_ctx) ir_if(operand(r0BD3).val);
                     exec_list *const f0BD2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BD2->then_instructions;

                        body.emit(assign(r0BD1, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BD2->else_instructions;

                        ir_variable *const r0BD4 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0BD6 = equal(r0B88, body.constant(int(2045)));
                        ir_if *f0BD5 = new(mem_ctx) ir_if(operand(r0BD6).val);
                        exec_list *const f0BD5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0BD5->then_instructions;

                           ir_expression *const r0BD7 = equal(body.constant(2097151u), r0B89);
                           ir_expression *const r0BD8 = equal(body.constant(4294967295u), r0B8A);
                           body.emit(assign(r0BD4, logic_and(r0BD7, r0BD8), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0BD5->else_instructions;

                           body.emit(assign(r0BD4, body.constant(false), 0x01));


                        body.instructions = f0BD5_parent_instructions;
                        body.emit(f0BD5);

                        /* END IF */

                        body.emit(assign(r0BD1, logic_and(r0BD4, r0BCD), 0x01));


                     body.instructions = f0BD2_parent_instructions;
                     body.emit(f0BD2);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f0BD9 = new(mem_ctx) ir_if(operand(r0BD1).val);
                     exec_list *const f0BD9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BD9->then_instructions;

                        ir_variable *const r0BDA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r0BDA);
                        ir_expression *const r0BDB = lshift(r0999, body.constant(int(31)));
                        body.emit(assign(r0BDA, add(r0BDB, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r0BDA, body.constant(0u), 0x01));

                        body.emit(assign(r0BCC, r0BDA, 0x03));

                        body.emit(assign(r0BCB, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BD9->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0BDD = less(r0B88, body.constant(int(0)));
                        ir_if *f0BDC = new(mem_ctx) ir_if(operand(r0BDD).val);
                        exec_list *const f0BDC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0BDC->then_instructions;

                           ir_variable *const r0BDE = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r0BDE, r0B8B, 0x01));

                           ir_variable *const r0BDF = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r0BDF, neg(r0B88), 0x01));

                           ir_variable *const r0BE0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r0BE0);
                           ir_variable *const r0BE1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r0BE1);
                           ir_variable *const r0BE2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r0BE2);
                           ir_variable *const r0BE3 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r0BE4 = neg(r0BDF);
                           body.emit(assign(r0BE3, bit_and(r0BE4, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0BE6 = equal(r0BDF, body.constant(int(0)));
                           ir_if *f0BE5 = new(mem_ctx) ir_if(operand(r0BE6).val);
                           exec_list *const f0BE5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0BE5->then_instructions;

                              body.emit(assign(r0BE0, r0B8B, 0x01));

                              body.emit(assign(r0BE1, r0B8A, 0x01));

                              body.emit(assign(r0BE2, r0B89, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0BE5->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0BE8 = less(r0BDF, body.constant(int(32)));
                              ir_if *f0BE7 = new(mem_ctx) ir_if(operand(r0BE8).val);
                              exec_list *const f0BE7_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0BE7->then_instructions;

                                 body.emit(assign(r0BE0, lshift(r0B8A, r0BE3), 0x01));

                                 ir_expression *const r0BE9 = lshift(r0B89, r0BE3);
                                 ir_expression *const r0BEA = rshift(r0B8A, r0BDF);
                                 body.emit(assign(r0BE1, bit_or(r0BE9, r0BEA), 0x01));

                                 body.emit(assign(r0BE2, rshift(r0B89, r0BDF), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0BE7->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0BEC = equal(r0BDF, body.constant(int(32)));
                                 ir_if *f0BEB = new(mem_ctx) ir_if(operand(r0BEC).val);
                                 exec_list *const f0BEB_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0BEB->then_instructions;

                                    body.emit(assign(r0BE0, r0B8A, 0x01));

                                    body.emit(assign(r0BE1, r0B89, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0BEB->else_instructions;

                                    body.emit(assign(r0BDE, bit_or(r0B8B, r0B8A), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r0BEE = less(r0BDF, body.constant(int(64)));
                                    ir_if *f0BED = new(mem_ctx) ir_if(operand(r0BEE).val);
                                    exec_list *const f0BED_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0BED->then_instructions;

                                       body.emit(assign(r0BE0, lshift(r0B89, r0BE3), 0x01));

                                       ir_expression *const r0BEF = bit_and(r0BDF, body.constant(int(31)));
                                       body.emit(assign(r0BE1, rshift(r0B89, r0BEF), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0BED->else_instructions;

                                       ir_variable *const r0BF0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r0BF2 = equal(r0BDF, body.constant(int(64)));
                                       ir_if *f0BF1 = new(mem_ctx) ir_if(operand(r0BF2).val);
                                       exec_list *const f0BF1_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0BF1->then_instructions;

                                          body.emit(assign(r0BF0, r0B89, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0BF1->else_instructions;

                                          ir_expression *const r0BF3 = nequal(r0B89, body.constant(0u));
                                          ir_expression *const r0BF4 = expr(ir_unop_b2i, r0BF3);
                                          body.emit(assign(r0BF0, expr(ir_unop_i2u, r0BF4), 0x01));


                                       body.instructions = f0BF1_parent_instructions;
                                       body.emit(f0BF1);

                                       /* END IF */

                                       body.emit(assign(r0BE0, r0BF0, 0x01));

                                       body.emit(assign(r0BE1, body.constant(0u), 0x01));


                                    body.instructions = f0BED_parent_instructions;
                                    body.emit(f0BED);

                                    /* END IF */


                                 body.instructions = f0BEB_parent_instructions;
                                 body.emit(f0BEB);

                                 /* END IF */

                                 body.emit(assign(r0BE2, body.constant(0u), 0x01));


                              body.instructions = f0BE7_parent_instructions;
                              body.emit(f0BE7);

                              /* END IF */

                              ir_expression *const r0BF5 = nequal(r0BDE, body.constant(0u));
                              ir_expression *const r0BF6 = expr(ir_unop_b2i, r0BF5);
                              ir_expression *const r0BF7 = expr(ir_unop_i2u, r0BF6);
                              body.emit(assign(r0BE0, bit_or(r0BE0, r0BF7), 0x01));


                           body.instructions = f0BE5_parent_instructions;
                           body.emit(f0BE5);

                           /* END IF */

                           body.emit(assign(r0BC8, r0BE2, 0x01));

                           body.emit(assign(r0BC9, r0BE1, 0x01));

                           body.emit(assign(r0BCA, r0BE0, 0x01));

                           body.emit(assign(r0BC7, body.constant(int(0)), 0x01));

                           body.emit(assign(r0BCD, less(r0BE0, body.constant(0u)), 0x01));


                        body.instructions = f0BDC_parent_instructions;
                        body.emit(f0BDC);

                        /* END IF */


                     body.instructions = f0BD9_parent_instructions;
                     body.emit(f0BD9);

                     /* END IF */


                  body.instructions = f0BCF_parent_instructions;
                  body.emit(f0BCF);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0BF8 = new(mem_ctx) ir_if(operand(r0BCB).val);
                  exec_list *const f0BF8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0BF8->then_instructions;

                     /* IF CONDITION */
                     ir_if *f0BF9 = new(mem_ctx) ir_if(operand(r0BCD).val);
                     exec_list *const f0BF9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BF9->then_instructions;

                        ir_variable *const r0BFA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r0BFA, add(r0BC9, body.constant(1u)), 0x01));

                        ir_expression *const r0BFB = less(r0BFA, r0BC9);
                        ir_expression *const r0BFC = expr(ir_unop_b2i, r0BFB);
                        ir_expression *const r0BFD = expr(ir_unop_i2u, r0BFC);
                        body.emit(assign(r0BC8, add(r0BC8, r0BFD), 0x01));

                        ir_expression *const r0BFE = equal(r0BCA, body.constant(0u));
                        ir_expression *const r0BFF = expr(ir_unop_b2i, r0BFE);
                        ir_expression *const r0C00 = expr(ir_unop_i2u, r0BFF);
                        ir_expression *const r0C01 = add(r0BCA, r0C00);
                        ir_expression *const r0C02 = bit_and(r0C01, body.constant(1u));
                        ir_expression *const r0C03 = expr(ir_unop_bit_not, r0C02);
                        body.emit(assign(r0BC9, bit_and(r0BFA, r0C03), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BF9->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0C05 = bit_or(r0BC8, r0BC9);
                        ir_expression *const r0C06 = equal(r0C05, body.constant(0u));
                        ir_if *f0C04 = new(mem_ctx) ir_if(operand(r0C06).val);
                        exec_list *const f0C04_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C04->then_instructions;

                           body.emit(assign(r0BC7, body.constant(int(0)), 0x01));


                        body.instructions = f0C04_parent_instructions;
                        body.emit(f0C04);

                        /* END IF */


                     body.instructions = f0BF9_parent_instructions;
                     body.emit(f0BF9);

                     /* END IF */

                     ir_variable *const r0C07 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0C07);
                     ir_expression *const r0C08 = lshift(r0999, body.constant(int(31)));
                     ir_expression *const r0C09 = expr(ir_unop_i2u, r0BC7);
                     ir_expression *const r0C0A = lshift(r0C09, body.constant(int(20)));
                     ir_expression *const r0C0B = add(r0C08, r0C0A);
                     body.emit(assign(r0C07, add(r0C0B, r0BC8), 0x02));

                     body.emit(assign(r0C07, r0BC9, 0x01));

                     body.emit(assign(r0BCC, r0C07, 0x03));

                     body.emit(assign(r0BCB, body.constant(false), 0x01));


                  body.instructions = f0BF8_parent_instructions;
                  body.emit(f0BF8);

                  /* END IF */

                  body.emit(assign(r099A, r0BCC, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0B80->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0C0D = less(swizzle_y(r099F), swizzle_y(r099D));
                  ir_if *f0C0C = new(mem_ctx) ir_if(operand(r0C0D).val);
                  exec_list *const f0C0C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0C0C->then_instructions;

                     ir_variable *const r0C0E = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r0C0F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r0C0F, sub(swizzle_x(r099D), swizzle_x(r099F)), 0x01));

                     ir_expression *const r0C10 = sub(swizzle_y(r099D), swizzle_y(r099F));
                     ir_expression *const r0C11 = less(swizzle_x(r099D), swizzle_x(r099F));
                     ir_expression *const r0C12 = expr(ir_unop_b2i, r0C11);
                     ir_expression *const r0C13 = expr(ir_unop_i2u, r0C12);
                     body.emit(assign(r0C0E, sub(r0C10, r0C13), 0x01));

                     body.emit(assign(r0999, bit_xor(r0999, body.constant(1u)), 0x01));

                     body.emit(assign(r09A0, add(r099C, body.constant(int(-1))), 0x01));

                     ir_variable *const r0C14 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r0C14, add(r09A0, body.constant(int(-10))), 0x01));

                     ir_variable *const r0C15 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r0C15, r0C0E, 0x01));

                     ir_variable *const r0C16 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r0C16, r0C0F, 0x01));

                     ir_variable *const r0C17 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r0C17);
                     ir_variable *const r0C18 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r0C18);
                     /* IF CONDITION */
                     ir_expression *const r0C1A = equal(r0C0E, body.constant(0u));
                     ir_if *f0C19 = new(mem_ctx) ir_if(operand(r0C1A).val);
                     exec_list *const f0C19_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C19->then_instructions;

                        body.emit(assign(r0C15, r0C0F, 0x01));

                        body.emit(assign(r0C16, body.constant(0u), 0x01));

                        body.emit(assign(r0C14, add(r0C14, body.constant(int(-32))), 0x01));


                     body.instructions = f0C19_parent_instructions;
                     body.emit(f0C19);

                     /* END IF */

                     ir_variable *const r0C1B = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r0C1B, r0C15, 0x01));

                     ir_variable *const r0C1C = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r0C1D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r0C1D);
                     /* IF CONDITION */
                     ir_expression *const r0C1F = equal(r0C15, body.constant(0u));
                     ir_if *f0C1E = new(mem_ctx) ir_if(operand(r0C1F).val);
                     exec_list *const f0C1E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C1E->then_instructions;

                        body.emit(assign(r0C1C, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0C1E->else_instructions;

                        body.emit(assign(r0C1D, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0C21 = bit_and(r0C15, body.constant(4294901760u));
                        ir_expression *const r0C22 = equal(r0C21, body.constant(0u));
                        ir_if *f0C20 = new(mem_ctx) ir_if(operand(r0C22).val);
                        exec_list *const f0C20_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C20->then_instructions;

                           body.emit(assign(r0C1D, body.constant(int(16)), 0x01));

                           body.emit(assign(r0C1B, lshift(r0C15, body.constant(int(16))), 0x01));


                        body.instructions = f0C20_parent_instructions;
                        body.emit(f0C20);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0C24 = bit_and(r0C1B, body.constant(4278190080u));
                        ir_expression *const r0C25 = equal(r0C24, body.constant(0u));
                        ir_if *f0C23 = new(mem_ctx) ir_if(operand(r0C25).val);
                        exec_list *const f0C23_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C23->then_instructions;

                           body.emit(assign(r0C1D, add(r0C1D, body.constant(int(8))), 0x01));

                           body.emit(assign(r0C1B, lshift(r0C1B, body.constant(int(8))), 0x01));


                        body.instructions = f0C23_parent_instructions;
                        body.emit(f0C23);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0C27 = bit_and(r0C1B, body.constant(4026531840u));
                        ir_expression *const r0C28 = equal(r0C27, body.constant(0u));
                        ir_if *f0C26 = new(mem_ctx) ir_if(operand(r0C28).val);
                        exec_list *const f0C26_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C26->then_instructions;

                           body.emit(assign(r0C1D, add(r0C1D, body.constant(int(4))), 0x01));

                           body.emit(assign(r0C1B, lshift(r0C1B, body.constant(int(4))), 0x01));


                        body.instructions = f0C26_parent_instructions;
                        body.emit(f0C26);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0C2A = bit_and(r0C1B, body.constant(3221225472u));
                        ir_expression *const r0C2B = equal(r0C2A, body.constant(0u));
                        ir_if *f0C29 = new(mem_ctx) ir_if(operand(r0C2B).val);
                        exec_list *const f0C29_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C29->then_instructions;

                           body.emit(assign(r0C1D, add(r0C1D, body.constant(int(2))), 0x01));

                           body.emit(assign(r0C1B, lshift(r0C1B, body.constant(int(2))), 0x01));


                        body.instructions = f0C29_parent_instructions;
                        body.emit(f0C29);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0C2D = bit_and(r0C1B, body.constant(2147483648u));
                        ir_expression *const r0C2E = equal(r0C2D, body.constant(0u));
                        ir_if *f0C2C = new(mem_ctx) ir_if(operand(r0C2E).val);
                        exec_list *const f0C2C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C2C->then_instructions;

                           body.emit(assign(r0C1D, add(r0C1D, body.constant(int(1))), 0x01));


                        body.instructions = f0C2C_parent_instructions;
                        body.emit(f0C2C);

                        /* END IF */

                        body.emit(assign(r0C1C, r0C1D, 0x01));


                     body.instructions = f0C1E_parent_instructions;
                     body.emit(f0C1E);

                     /* END IF */

                     body.emit(assign(r0C18, add(r0C1C, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0C30 = lequal(body.constant(int(0)), r0C18);
                     ir_if *f0C2F = new(mem_ctx) ir_if(operand(r0C30).val);
                     exec_list *const f0C2F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C2F->then_instructions;

                        body.emit(assign(r0C17, body.constant(0u), 0x01));

                        ir_variable *const r0C31 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r0C31, lshift(r0C16, r0C18), 0x01));

                        ir_variable *const r0C32 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0C34 = equal(r0C18, body.constant(int(0)));
                        ir_if *f0C33 = new(mem_ctx) ir_if(operand(r0C34).val);
                        exec_list *const f0C33_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C33->then_instructions;

                           body.emit(assign(r0C32, r0C15, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C33->else_instructions;

                           ir_expression *const r0C35 = lshift(r0C15, r0C18);
                           ir_expression *const r0C36 = neg(r0C18);
                           ir_expression *const r0C37 = bit_and(r0C36, body.constant(int(31)));
                           ir_expression *const r0C38 = rshift(r0C16, r0C37);
                           body.emit(assign(r0C32, bit_or(r0C35, r0C38), 0x01));


                        body.instructions = f0C33_parent_instructions;
                        body.emit(f0C33);

                        /* END IF */

                        body.emit(assign(r0C15, r0C32, 0x01));

                        body.emit(assign(r0C16, r0C31, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0C2F->else_instructions;

                        ir_variable *const r0C39 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0C39, body.constant(0u), 0x01));

                        ir_variable *const r0C3A = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0C3A, neg(r0C18), 0x01));

                        ir_variable *const r0C3B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0C3B);
                        ir_variable *const r0C3C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0C3C);
                        ir_variable *const r0C3D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0C3D);
                        ir_variable *const r0C3E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r0C3F = neg(r0C3A);
                        body.emit(assign(r0C3E, bit_and(r0C3F, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0C41 = equal(r0C3A, body.constant(int(0)));
                        ir_if *f0C40 = new(mem_ctx) ir_if(operand(r0C41).val);
                        exec_list *const f0C40_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C40->then_instructions;

                           body.emit(assign(r0C3B, r0C39, 0x01));

                           body.emit(assign(r0C3C, r0C16, 0x01));

                           body.emit(assign(r0C3D, r0C15, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C40->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0C43 = less(r0C3A, body.constant(int(32)));
                           ir_if *f0C42 = new(mem_ctx) ir_if(operand(r0C43).val);
                           exec_list *const f0C42_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0C42->then_instructions;

                              body.emit(assign(r0C3B, lshift(r0C16, r0C3E), 0x01));

                              ir_expression *const r0C44 = lshift(r0C15, r0C3E);
                              ir_expression *const r0C45 = rshift(r0C16, r0C3A);
                              body.emit(assign(r0C3C, bit_or(r0C44, r0C45), 0x01));

                              body.emit(assign(r0C3D, rshift(r0C15, r0C3A), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0C42->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0C47 = equal(r0C3A, body.constant(int(32)));
                              ir_if *f0C46 = new(mem_ctx) ir_if(operand(r0C47).val);
                              exec_list *const f0C46_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0C46->then_instructions;

                                 body.emit(assign(r0C3B, r0C16, 0x01));

                                 body.emit(assign(r0C3C, r0C15, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0C46->else_instructions;

                                 body.emit(assign(r0C39, bit_or(body.constant(0u), r0C16), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0C49 = less(r0C3A, body.constant(int(64)));
                                 ir_if *f0C48 = new(mem_ctx) ir_if(operand(r0C49).val);
                                 exec_list *const f0C48_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0C48->then_instructions;

                                    body.emit(assign(r0C3B, lshift(r0C15, r0C3E), 0x01));

                                    ir_expression *const r0C4A = bit_and(r0C3A, body.constant(int(31)));
                                    body.emit(assign(r0C3C, rshift(r0C15, r0C4A), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0C48->else_instructions;

                                    ir_variable *const r0C4B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r0C4D = equal(r0C3A, body.constant(int(64)));
                                    ir_if *f0C4C = new(mem_ctx) ir_if(operand(r0C4D).val);
                                    exec_list *const f0C4C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0C4C->then_instructions;

                                       body.emit(assign(r0C4B, r0C15, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0C4C->else_instructions;

                                       ir_expression *const r0C4E = nequal(r0C15, body.constant(0u));
                                       ir_expression *const r0C4F = expr(ir_unop_b2i, r0C4E);
                                       body.emit(assign(r0C4B, expr(ir_unop_i2u, r0C4F), 0x01));


                                    body.instructions = f0C4C_parent_instructions;
                                    body.emit(f0C4C);

                                    /* END IF */

                                    body.emit(assign(r0C3B, r0C4B, 0x01));

                                    body.emit(assign(r0C3C, body.constant(0u), 0x01));


                                 body.instructions = f0C48_parent_instructions;
                                 body.emit(f0C48);

                                 /* END IF */


                              body.instructions = f0C46_parent_instructions;
                              body.emit(f0C46);

                              /* END IF */

                              body.emit(assign(r0C3D, body.constant(0u), 0x01));


                           body.instructions = f0C42_parent_instructions;
                           body.emit(f0C42);

                           /* END IF */

                           ir_expression *const r0C50 = nequal(r0C39, body.constant(0u));
                           ir_expression *const r0C51 = expr(ir_unop_b2i, r0C50);
                           ir_expression *const r0C52 = expr(ir_unop_i2u, r0C51);
                           body.emit(assign(r0C3B, bit_or(r0C3B, r0C52), 0x01));


                        body.instructions = f0C40_parent_instructions;
                        body.emit(f0C40);

                        /* END IF */

                        body.emit(assign(r0C15, r0C3D, 0x01));

                        body.emit(assign(r0C16, r0C3C, 0x01));

                        body.emit(assign(r0C17, r0C3B, 0x01));


                     body.instructions = f0C2F_parent_instructions;
                     body.emit(f0C2F);

                     /* END IF */

                     body.emit(assign(r0C14, sub(r0C14, r0C18), 0x01));

                     ir_variable *const r0C53 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r0C53, r0C14, 0x01));

                     ir_variable *const r0C54 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r0C54, r0C15, 0x01));

                     ir_variable *const r0C55 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r0C55, r0C16, 0x01));

                     ir_variable *const r0C56 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r0C56, r0C17, 0x01));

                     ir_variable *const r0C57 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r0C57, body.constant(true), 0x01));

                     ir_variable *const r0C58 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r0C59 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r0C59);
                     ir_expression *const r0C5A = expr(ir_unop_u2i, r0C17);
                     body.emit(assign(r0C59, less(r0C5A, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0C5C = lequal(body.constant(int(2045)), r0C14);
                     ir_if *f0C5B = new(mem_ctx) ir_if(operand(r0C5C).val);
                     exec_list *const f0C5B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C5B->then_instructions;

                        ir_variable *const r0C5D = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0C5F = less(body.constant(int(2045)), r0C14);
                        ir_if *f0C5E = new(mem_ctx) ir_if(operand(r0C5F).val);
                        exec_list *const f0C5E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C5E->then_instructions;

                           body.emit(assign(r0C5D, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C5E->else_instructions;

                           ir_variable *const r0C60 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0C62 = equal(r0C14, body.constant(int(2045)));
                           ir_if *f0C61 = new(mem_ctx) ir_if(operand(r0C62).val);
                           exec_list *const f0C61_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0C61->then_instructions;

                              ir_expression *const r0C63 = equal(body.constant(2097151u), r0C15);
                              ir_expression *const r0C64 = equal(body.constant(4294967295u), r0C16);
                              body.emit(assign(r0C60, logic_and(r0C63, r0C64), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0C61->else_instructions;

                              body.emit(assign(r0C60, body.constant(false), 0x01));


                           body.instructions = f0C61_parent_instructions;
                           body.emit(f0C61);

                           /* END IF */

                           body.emit(assign(r0C5D, logic_and(r0C60, r0C59), 0x01));


                        body.instructions = f0C5E_parent_instructions;
                        body.emit(f0C5E);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f0C65 = new(mem_ctx) ir_if(operand(r0C5D).val);
                        exec_list *const f0C65_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C65->then_instructions;

                           ir_variable *const r0C66 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r0C66);
                           ir_expression *const r0C67 = lshift(r0999, body.constant(int(31)));
                           body.emit(assign(r0C66, add(r0C67, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r0C66, body.constant(0u), 0x01));

                           body.emit(assign(r0C58, r0C66, 0x03));

                           body.emit(assign(r0C57, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C65->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0C69 = less(r0C14, body.constant(int(0)));
                           ir_if *f0C68 = new(mem_ctx) ir_if(operand(r0C69).val);
                           exec_list *const f0C68_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0C68->then_instructions;

                              ir_variable *const r0C6A = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r0C6A, r0C17, 0x01));

                              ir_variable *const r0C6B = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r0C6B, neg(r0C14), 0x01));

                              ir_variable *const r0C6C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r0C6C);
                              ir_variable *const r0C6D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r0C6D);
                              ir_variable *const r0C6E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r0C6E);
                              ir_variable *const r0C6F = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r0C70 = neg(r0C6B);
                              body.emit(assign(r0C6F, bit_and(r0C70, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0C72 = equal(r0C6B, body.constant(int(0)));
                              ir_if *f0C71 = new(mem_ctx) ir_if(operand(r0C72).val);
                              exec_list *const f0C71_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0C71->then_instructions;

                                 body.emit(assign(r0C6C, r0C17, 0x01));

                                 body.emit(assign(r0C6D, r0C16, 0x01));

                                 body.emit(assign(r0C6E, r0C15, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0C71->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0C74 = less(r0C6B, body.constant(int(32)));
                                 ir_if *f0C73 = new(mem_ctx) ir_if(operand(r0C74).val);
                                 exec_list *const f0C73_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0C73->then_instructions;

                                    body.emit(assign(r0C6C, lshift(r0C16, r0C6F), 0x01));

                                    ir_expression *const r0C75 = lshift(r0C15, r0C6F);
                                    ir_expression *const r0C76 = rshift(r0C16, r0C6B);
                                    body.emit(assign(r0C6D, bit_or(r0C75, r0C76), 0x01));

                                    body.emit(assign(r0C6E, rshift(r0C15, r0C6B), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0C73->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r0C78 = equal(r0C6B, body.constant(int(32)));
                                    ir_if *f0C77 = new(mem_ctx) ir_if(operand(r0C78).val);
                                    exec_list *const f0C77_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0C77->then_instructions;

                                       body.emit(assign(r0C6C, r0C16, 0x01));

                                       body.emit(assign(r0C6D, r0C15, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0C77->else_instructions;

                                       body.emit(assign(r0C6A, bit_or(r0C17, r0C16), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r0C7A = less(r0C6B, body.constant(int(64)));
                                       ir_if *f0C79 = new(mem_ctx) ir_if(operand(r0C7A).val);
                                       exec_list *const f0C79_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0C79->then_instructions;

                                          body.emit(assign(r0C6C, lshift(r0C15, r0C6F), 0x01));

                                          ir_expression *const r0C7B = bit_and(r0C6B, body.constant(int(31)));
                                          body.emit(assign(r0C6D, rshift(r0C15, r0C7B), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0C79->else_instructions;

                                          ir_variable *const r0C7C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r0C7E = equal(r0C6B, body.constant(int(64)));
                                          ir_if *f0C7D = new(mem_ctx) ir_if(operand(r0C7E).val);
                                          exec_list *const f0C7D_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0C7D->then_instructions;

                                             body.emit(assign(r0C7C, r0C15, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0C7D->else_instructions;

                                             ir_expression *const r0C7F = nequal(r0C15, body.constant(0u));
                                             ir_expression *const r0C80 = expr(ir_unop_b2i, r0C7F);
                                             body.emit(assign(r0C7C, expr(ir_unop_i2u, r0C80), 0x01));


                                          body.instructions = f0C7D_parent_instructions;
                                          body.emit(f0C7D);

                                          /* END IF */

                                          body.emit(assign(r0C6C, r0C7C, 0x01));

                                          body.emit(assign(r0C6D, body.constant(0u), 0x01));


                                       body.instructions = f0C79_parent_instructions;
                                       body.emit(f0C79);

                                       /* END IF */


                                    body.instructions = f0C77_parent_instructions;
                                    body.emit(f0C77);

                                    /* END IF */

                                    body.emit(assign(r0C6E, body.constant(0u), 0x01));


                                 body.instructions = f0C73_parent_instructions;
                                 body.emit(f0C73);

                                 /* END IF */

                                 ir_expression *const r0C81 = nequal(r0C6A, body.constant(0u));
                                 ir_expression *const r0C82 = expr(ir_unop_b2i, r0C81);
                                 ir_expression *const r0C83 = expr(ir_unop_i2u, r0C82);
                                 body.emit(assign(r0C6C, bit_or(r0C6C, r0C83), 0x01));


                              body.instructions = f0C71_parent_instructions;
                              body.emit(f0C71);

                              /* END IF */

                              body.emit(assign(r0C54, r0C6E, 0x01));

                              body.emit(assign(r0C55, r0C6D, 0x01));

                              body.emit(assign(r0C56, r0C6C, 0x01));

                              body.emit(assign(r0C53, body.constant(int(0)), 0x01));

                              body.emit(assign(r0C59, less(r0C6C, body.constant(0u)), 0x01));


                           body.instructions = f0C68_parent_instructions;
                           body.emit(f0C68);

                           /* END IF */


                        body.instructions = f0C65_parent_instructions;
                        body.emit(f0C65);

                        /* END IF */


                     body.instructions = f0C5B_parent_instructions;
                     body.emit(f0C5B);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f0C84 = new(mem_ctx) ir_if(operand(r0C57).val);
                     exec_list *const f0C84_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C84->then_instructions;

                        /* IF CONDITION */
                        ir_if *f0C85 = new(mem_ctx) ir_if(operand(r0C59).val);
                        exec_list *const f0C85_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C85->then_instructions;

                           ir_variable *const r0C86 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r0C86, add(r0C55, body.constant(1u)), 0x01));

                           ir_expression *const r0C87 = less(r0C86, r0C55);
                           ir_expression *const r0C88 = expr(ir_unop_b2i, r0C87);
                           ir_expression *const r0C89 = expr(ir_unop_i2u, r0C88);
                           body.emit(assign(r0C54, add(r0C54, r0C89), 0x01));

                           ir_expression *const r0C8A = equal(r0C56, body.constant(0u));
                           ir_expression *const r0C8B = expr(ir_unop_b2i, r0C8A);
                           ir_expression *const r0C8C = expr(ir_unop_i2u, r0C8B);
                           ir_expression *const r0C8D = add(r0C56, r0C8C);
                           ir_expression *const r0C8E = bit_and(r0C8D, body.constant(1u));
                           ir_expression *const r0C8F = expr(ir_unop_bit_not, r0C8E);
                           body.emit(assign(r0C55, bit_and(r0C86, r0C8F), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C85->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0C91 = bit_or(r0C54, r0C55);
                           ir_expression *const r0C92 = equal(r0C91, body.constant(0u));
                           ir_if *f0C90 = new(mem_ctx) ir_if(operand(r0C92).val);
                           exec_list *const f0C90_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0C90->then_instructions;

                              body.emit(assign(r0C53, body.constant(int(0)), 0x01));


                           body.instructions = f0C90_parent_instructions;
                           body.emit(f0C90);

                           /* END IF */


                        body.instructions = f0C85_parent_instructions;
                        body.emit(f0C85);

                        /* END IF */

                        ir_variable *const r0C93 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r0C93);
                        ir_expression *const r0C94 = lshift(r0999, body.constant(int(31)));
                        ir_expression *const r0C95 = expr(ir_unop_i2u, r0C53);
                        ir_expression *const r0C96 = lshift(r0C95, body.constant(int(20)));
                        ir_expression *const r0C97 = add(r0C94, r0C96);
                        body.emit(assign(r0C93, add(r0C97, r0C54), 0x02));

                        body.emit(assign(r0C93, r0C55, 0x01));

                        body.emit(assign(r0C58, r0C93, 0x03));

                        body.emit(assign(r0C57, body.constant(false), 0x01));


                     body.instructions = f0C84_parent_instructions;
                     body.emit(f0C84);

                     /* END IF */

                     body.emit(assign(r099A, r0C58, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0C0C->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0C99 = less(swizzle_x(r099D), swizzle_x(r099F));
                     ir_if *f0C98 = new(mem_ctx) ir_if(operand(r0C99).val);
                     exec_list *const f0C98_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C98->then_instructions;

                        ir_variable *const r0C9A = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r0C9B = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r0C9B, sub(swizzle_x(r099F), swizzle_x(r099D)), 0x01));

                        ir_expression *const r0C9C = sub(swizzle_y(r099F), swizzle_y(r099D));
                        ir_expression *const r0C9D = less(swizzle_x(r099F), swizzle_x(r099D));
                        ir_expression *const r0C9E = expr(ir_unop_b2i, r0C9D);
                        ir_expression *const r0C9F = expr(ir_unop_i2u, r0C9E);
                        body.emit(assign(r0C9A, sub(r0C9C, r0C9F), 0x01));

                        body.emit(assign(r09A0, add(r099E, body.constant(int(-1))), 0x01));

                        ir_variable *const r0CA0 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r0CA0, add(r09A0, body.constant(int(-10))), 0x01));

                        ir_variable *const r0CA1 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r0CA1, r0C9A, 0x01));

                        ir_variable *const r0CA2 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r0CA2, r0C9B, 0x01));

                        ir_variable *const r0CA3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r0CA3);
                        ir_variable *const r0CA4 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r0CA4);
                        /* IF CONDITION */
                        ir_expression *const r0CA6 = equal(r0C9A, body.constant(0u));
                        ir_if *f0CA5 = new(mem_ctx) ir_if(operand(r0CA6).val);
                        exec_list *const f0CA5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0CA5->then_instructions;

                           body.emit(assign(r0CA1, r0C9B, 0x01));

                           body.emit(assign(r0CA2, body.constant(0u), 0x01));

                           body.emit(assign(r0CA0, add(r0CA0, body.constant(int(-32))), 0x01));


                        body.instructions = f0CA5_parent_instructions;
                        body.emit(f0CA5);

                        /* END IF */

                        ir_variable *const r0CA7 = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r0CA7, r0CA1, 0x01));

                        ir_variable *const r0CA8 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r0CA9 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r0CA9);
                        /* IF CONDITION */
                        ir_expression *const r0CAB = equal(r0CA1, body.constant(0u));
                        ir_if *f0CAA = new(mem_ctx) ir_if(operand(r0CAB).val);
                        exec_list *const f0CAA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0CAA->then_instructions;

                           body.emit(assign(r0CA8, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0CAA->else_instructions;

                           body.emit(assign(r0CA9, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0CAD = bit_and(r0CA1, body.constant(4294901760u));
                           ir_expression *const r0CAE = equal(r0CAD, body.constant(0u));
                           ir_if *f0CAC = new(mem_ctx) ir_if(operand(r0CAE).val);
                           exec_list *const f0CAC_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CAC->then_instructions;

                              body.emit(assign(r0CA9, body.constant(int(16)), 0x01));

                              body.emit(assign(r0CA7, lshift(r0CA1, body.constant(int(16))), 0x01));


                           body.instructions = f0CAC_parent_instructions;
                           body.emit(f0CAC);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0CB0 = bit_and(r0CA7, body.constant(4278190080u));
                           ir_expression *const r0CB1 = equal(r0CB0, body.constant(0u));
                           ir_if *f0CAF = new(mem_ctx) ir_if(operand(r0CB1).val);
                           exec_list *const f0CAF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CAF->then_instructions;

                              body.emit(assign(r0CA9, add(r0CA9, body.constant(int(8))), 0x01));

                              body.emit(assign(r0CA7, lshift(r0CA7, body.constant(int(8))), 0x01));


                           body.instructions = f0CAF_parent_instructions;
                           body.emit(f0CAF);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0CB3 = bit_and(r0CA7, body.constant(4026531840u));
                           ir_expression *const r0CB4 = equal(r0CB3, body.constant(0u));
                           ir_if *f0CB2 = new(mem_ctx) ir_if(operand(r0CB4).val);
                           exec_list *const f0CB2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CB2->then_instructions;

                              body.emit(assign(r0CA9, add(r0CA9, body.constant(int(4))), 0x01));

                              body.emit(assign(r0CA7, lshift(r0CA7, body.constant(int(4))), 0x01));


                           body.instructions = f0CB2_parent_instructions;
                           body.emit(f0CB2);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0CB6 = bit_and(r0CA7, body.constant(3221225472u));
                           ir_expression *const r0CB7 = equal(r0CB6, body.constant(0u));
                           ir_if *f0CB5 = new(mem_ctx) ir_if(operand(r0CB7).val);
                           exec_list *const f0CB5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CB5->then_instructions;

                              body.emit(assign(r0CA9, add(r0CA9, body.constant(int(2))), 0x01));

                              body.emit(assign(r0CA7, lshift(r0CA7, body.constant(int(2))), 0x01));


                           body.instructions = f0CB5_parent_instructions;
                           body.emit(f0CB5);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0CB9 = bit_and(r0CA7, body.constant(2147483648u));
                           ir_expression *const r0CBA = equal(r0CB9, body.constant(0u));
                           ir_if *f0CB8 = new(mem_ctx) ir_if(operand(r0CBA).val);
                           exec_list *const f0CB8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CB8->then_instructions;

                              body.emit(assign(r0CA9, add(r0CA9, body.constant(int(1))), 0x01));


                           body.instructions = f0CB8_parent_instructions;
                           body.emit(f0CB8);

                           /* END IF */

                           body.emit(assign(r0CA8, r0CA9, 0x01));


                        body.instructions = f0CAA_parent_instructions;
                        body.emit(f0CAA);

                        /* END IF */

                        body.emit(assign(r0CA4, add(r0CA8, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0CBC = lequal(body.constant(int(0)), r0CA4);
                        ir_if *f0CBB = new(mem_ctx) ir_if(operand(r0CBC).val);
                        exec_list *const f0CBB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0CBB->then_instructions;

                           body.emit(assign(r0CA3, body.constant(0u), 0x01));

                           ir_variable *const r0CBD = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r0CBD, lshift(r0CA2, r0CA4), 0x01));

                           ir_variable *const r0CBE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0CC0 = equal(r0CA4, body.constant(int(0)));
                           ir_if *f0CBF = new(mem_ctx) ir_if(operand(r0CC0).val);
                           exec_list *const f0CBF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CBF->then_instructions;

                              body.emit(assign(r0CBE, r0CA1, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0CBF->else_instructions;

                              ir_expression *const r0CC1 = lshift(r0CA1, r0CA4);
                              ir_expression *const r0CC2 = neg(r0CA4);
                              ir_expression *const r0CC3 = bit_and(r0CC2, body.constant(int(31)));
                              ir_expression *const r0CC4 = rshift(r0CA2, r0CC3);
                              body.emit(assign(r0CBE, bit_or(r0CC1, r0CC4), 0x01));


                           body.instructions = f0CBF_parent_instructions;
                           body.emit(f0CBF);

                           /* END IF */

                           body.emit(assign(r0CA1, r0CBE, 0x01));

                           body.emit(assign(r0CA2, r0CBD, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0CBB->else_instructions;

                           ir_variable *const r0CC5 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r0CC5, body.constant(0u), 0x01));

                           ir_variable *const r0CC6 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r0CC6, neg(r0CA4), 0x01));

                           ir_variable *const r0CC7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r0CC7);
                           ir_variable *const r0CC8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r0CC8);
                           ir_variable *const r0CC9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r0CC9);
                           ir_variable *const r0CCA = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r0CCB = neg(r0CC6);
                           body.emit(assign(r0CCA, bit_and(r0CCB, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0CCD = equal(r0CC6, body.constant(int(0)));
                           ir_if *f0CCC = new(mem_ctx) ir_if(operand(r0CCD).val);
                           exec_list *const f0CCC_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CCC->then_instructions;

                              body.emit(assign(r0CC7, r0CC5, 0x01));

                              body.emit(assign(r0CC8, r0CA2, 0x01));

                              body.emit(assign(r0CC9, r0CA1, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0CCC->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0CCF = less(r0CC6, body.constant(int(32)));
                              ir_if *f0CCE = new(mem_ctx) ir_if(operand(r0CCF).val);
                              exec_list *const f0CCE_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0CCE->then_instructions;

                                 body.emit(assign(r0CC7, lshift(r0CA2, r0CCA), 0x01));

                                 ir_expression *const r0CD0 = lshift(r0CA1, r0CCA);
                                 ir_expression *const r0CD1 = rshift(r0CA2, r0CC6);
                                 body.emit(assign(r0CC8, bit_or(r0CD0, r0CD1), 0x01));

                                 body.emit(assign(r0CC9, rshift(r0CA1, r0CC6), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0CCE->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0CD3 = equal(r0CC6, body.constant(int(32)));
                                 ir_if *f0CD2 = new(mem_ctx) ir_if(operand(r0CD3).val);
                                 exec_list *const f0CD2_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0CD2->then_instructions;

                                    body.emit(assign(r0CC7, r0CA2, 0x01));

                                    body.emit(assign(r0CC8, r0CA1, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0CD2->else_instructions;

                                    body.emit(assign(r0CC5, bit_or(body.constant(0u), r0CA2), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r0CD5 = less(r0CC6, body.constant(int(64)));
                                    ir_if *f0CD4 = new(mem_ctx) ir_if(operand(r0CD5).val);
                                    exec_list *const f0CD4_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0CD4->then_instructions;

                                       body.emit(assign(r0CC7, lshift(r0CA1, r0CCA), 0x01));

                                       ir_expression *const r0CD6 = bit_and(r0CC6, body.constant(int(31)));
                                       body.emit(assign(r0CC8, rshift(r0CA1, r0CD6), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0CD4->else_instructions;

                                       ir_variable *const r0CD7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r0CD9 = equal(r0CC6, body.constant(int(64)));
                                       ir_if *f0CD8 = new(mem_ctx) ir_if(operand(r0CD9).val);
                                       exec_list *const f0CD8_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0CD8->then_instructions;

                                          body.emit(assign(r0CD7, r0CA1, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0CD8->else_instructions;

                                          ir_expression *const r0CDA = nequal(r0CA1, body.constant(0u));
                                          ir_expression *const r0CDB = expr(ir_unop_b2i, r0CDA);
                                          body.emit(assign(r0CD7, expr(ir_unop_i2u, r0CDB), 0x01));


                                       body.instructions = f0CD8_parent_instructions;
                                       body.emit(f0CD8);

                                       /* END IF */

                                       body.emit(assign(r0CC7, r0CD7, 0x01));

                                       body.emit(assign(r0CC8, body.constant(0u), 0x01));


                                    body.instructions = f0CD4_parent_instructions;
                                    body.emit(f0CD4);

                                    /* END IF */


                                 body.instructions = f0CD2_parent_instructions;
                                 body.emit(f0CD2);

                                 /* END IF */

                                 body.emit(assign(r0CC9, body.constant(0u), 0x01));


                              body.instructions = f0CCE_parent_instructions;
                              body.emit(f0CCE);

                              /* END IF */

                              ir_expression *const r0CDC = nequal(r0CC5, body.constant(0u));
                              ir_expression *const r0CDD = expr(ir_unop_b2i, r0CDC);
                              ir_expression *const r0CDE = expr(ir_unop_i2u, r0CDD);
                              body.emit(assign(r0CC7, bit_or(r0CC7, r0CDE), 0x01));


                           body.instructions = f0CCC_parent_instructions;
                           body.emit(f0CCC);

                           /* END IF */

                           body.emit(assign(r0CA1, r0CC9, 0x01));

                           body.emit(assign(r0CA2, r0CC8, 0x01));

                           body.emit(assign(r0CA3, r0CC7, 0x01));


                        body.instructions = f0CBB_parent_instructions;
                        body.emit(f0CBB);

                        /* END IF */

                        body.emit(assign(r0CA0, sub(r0CA0, r0CA4), 0x01));

                        ir_variable *const r0CDF = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r0CDF, r0CA0, 0x01));

                        ir_variable *const r0CE0 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r0CE0, r0CA1, 0x01));

                        ir_variable *const r0CE1 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r0CE1, r0CA2, 0x01));

                        ir_variable *const r0CE2 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r0CE2, r0CA3, 0x01));

                        ir_variable *const r0CE3 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r0CE3, body.constant(true), 0x01));

                        ir_variable *const r0CE4 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r0CE5 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r0CE5);
                        ir_expression *const r0CE6 = expr(ir_unop_u2i, r0CA3);
                        body.emit(assign(r0CE5, less(r0CE6, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0CE8 = lequal(body.constant(int(2045)), r0CA0);
                        ir_if *f0CE7 = new(mem_ctx) ir_if(operand(r0CE8).val);
                        exec_list *const f0CE7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0CE7->then_instructions;

                           ir_variable *const r0CE9 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0CEB = less(body.constant(int(2045)), r0CA0);
                           ir_if *f0CEA = new(mem_ctx) ir_if(operand(r0CEB).val);
                           exec_list *const f0CEA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CEA->then_instructions;

                              body.emit(assign(r0CE9, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0CEA->else_instructions;

                              ir_variable *const r0CEC = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0CEE = equal(r0CA0, body.constant(int(2045)));
                              ir_if *f0CED = new(mem_ctx) ir_if(operand(r0CEE).val);
                              exec_list *const f0CED_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0CED->then_instructions;

                                 ir_expression *const r0CEF = equal(body.constant(2097151u), r0CA1);
                                 ir_expression *const r0CF0 = equal(body.constant(4294967295u), r0CA2);
                                 body.emit(assign(r0CEC, logic_and(r0CEF, r0CF0), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0CED->else_instructions;

                                 body.emit(assign(r0CEC, body.constant(false), 0x01));


                              body.instructions = f0CED_parent_instructions;
                              body.emit(f0CED);

                              /* END IF */

                              body.emit(assign(r0CE9, logic_and(r0CEC, r0CE5), 0x01));


                           body.instructions = f0CEA_parent_instructions;
                           body.emit(f0CEA);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f0CF1 = new(mem_ctx) ir_if(operand(r0CE9).val);
                           exec_list *const f0CF1_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CF1->then_instructions;

                              ir_variable *const r0CF2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r0CF2);
                              ir_expression *const r0CF3 = lshift(r0999, body.constant(int(31)));
                              body.emit(assign(r0CF2, add(r0CF3, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r0CF2, body.constant(0u), 0x01));

                              body.emit(assign(r0CE4, r0CF2, 0x03));

                              body.emit(assign(r0CE3, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0CF1->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0CF5 = less(r0CA0, body.constant(int(0)));
                              ir_if *f0CF4 = new(mem_ctx) ir_if(operand(r0CF5).val);
                              exec_list *const f0CF4_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0CF4->then_instructions;

                                 ir_variable *const r0CF6 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r0CF6, r0CA3, 0x01));

                                 ir_variable *const r0CF7 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r0CF7, neg(r0CA0), 0x01));

                                 ir_variable *const r0CF8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r0CF8);
                                 ir_variable *const r0CF9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r0CF9);
                                 ir_variable *const r0CFA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r0CFA);
                                 ir_variable *const r0CFB = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r0CFC = neg(r0CF7);
                                 body.emit(assign(r0CFB, bit_and(r0CFC, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0CFE = equal(r0CF7, body.constant(int(0)));
                                 ir_if *f0CFD = new(mem_ctx) ir_if(operand(r0CFE).val);
                                 exec_list *const f0CFD_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0CFD->then_instructions;

                                    body.emit(assign(r0CF8, r0CA3, 0x01));

                                    body.emit(assign(r0CF9, r0CA2, 0x01));

                                    body.emit(assign(r0CFA, r0CA1, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0CFD->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r0D00 = less(r0CF7, body.constant(int(32)));
                                    ir_if *f0CFF = new(mem_ctx) ir_if(operand(r0D00).val);
                                    exec_list *const f0CFF_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0CFF->then_instructions;

                                       body.emit(assign(r0CF8, lshift(r0CA2, r0CFB), 0x01));

                                       ir_expression *const r0D01 = lshift(r0CA1, r0CFB);
                                       ir_expression *const r0D02 = rshift(r0CA2, r0CF7);
                                       body.emit(assign(r0CF9, bit_or(r0D01, r0D02), 0x01));

                                       body.emit(assign(r0CFA, rshift(r0CA1, r0CF7), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0CFF->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r0D04 = equal(r0CF7, body.constant(int(32)));
                                       ir_if *f0D03 = new(mem_ctx) ir_if(operand(r0D04).val);
                                       exec_list *const f0D03_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0D03->then_instructions;

                                          body.emit(assign(r0CF8, r0CA2, 0x01));

                                          body.emit(assign(r0CF9, r0CA1, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0D03->else_instructions;

                                          body.emit(assign(r0CF6, bit_or(r0CA3, r0CA2), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r0D06 = less(r0CF7, body.constant(int(64)));
                                          ir_if *f0D05 = new(mem_ctx) ir_if(operand(r0D06).val);
                                          exec_list *const f0D05_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0D05->then_instructions;

                                             body.emit(assign(r0CF8, lshift(r0CA1, r0CFB), 0x01));

                                             ir_expression *const r0D07 = bit_and(r0CF7, body.constant(int(31)));
                                             body.emit(assign(r0CF9, rshift(r0CA1, r0D07), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0D05->else_instructions;

                                             ir_variable *const r0D08 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r0D0A = equal(r0CF7, body.constant(int(64)));
                                             ir_if *f0D09 = new(mem_ctx) ir_if(operand(r0D0A).val);
                                             exec_list *const f0D09_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f0D09->then_instructions;

                                                body.emit(assign(r0D08, r0CA1, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f0D09->else_instructions;

                                                ir_expression *const r0D0B = nequal(r0CA1, body.constant(0u));
                                                ir_expression *const r0D0C = expr(ir_unop_b2i, r0D0B);
                                                body.emit(assign(r0D08, expr(ir_unop_i2u, r0D0C), 0x01));


                                             body.instructions = f0D09_parent_instructions;
                                             body.emit(f0D09);

                                             /* END IF */

                                             body.emit(assign(r0CF8, r0D08, 0x01));

                                             body.emit(assign(r0CF9, body.constant(0u), 0x01));


                                          body.instructions = f0D05_parent_instructions;
                                          body.emit(f0D05);

                                          /* END IF */


                                       body.instructions = f0D03_parent_instructions;
                                       body.emit(f0D03);

                                       /* END IF */

                                       body.emit(assign(r0CFA, body.constant(0u), 0x01));


                                    body.instructions = f0CFF_parent_instructions;
                                    body.emit(f0CFF);

                                    /* END IF */

                                    ir_expression *const r0D0D = nequal(r0CF6, body.constant(0u));
                                    ir_expression *const r0D0E = expr(ir_unop_b2i, r0D0D);
                                    ir_expression *const r0D0F = expr(ir_unop_i2u, r0D0E);
                                    body.emit(assign(r0CF8, bit_or(r0CF8, r0D0F), 0x01));


                                 body.instructions = f0CFD_parent_instructions;
                                 body.emit(f0CFD);

                                 /* END IF */

                                 body.emit(assign(r0CE0, r0CFA, 0x01));

                                 body.emit(assign(r0CE1, r0CF9, 0x01));

                                 body.emit(assign(r0CE2, r0CF8, 0x01));

                                 body.emit(assign(r0CDF, body.constant(int(0)), 0x01));

                                 body.emit(assign(r0CE5, less(r0CF8, body.constant(0u)), 0x01));


                              body.instructions = f0CF4_parent_instructions;
                              body.emit(f0CF4);

                              /* END IF */


                           body.instructions = f0CF1_parent_instructions;
                           body.emit(f0CF1);

                           /* END IF */


                        body.instructions = f0CE7_parent_instructions;
                        body.emit(f0CE7);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f0D10 = new(mem_ctx) ir_if(operand(r0CE3).val);
                        exec_list *const f0D10_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0D10->then_instructions;

                           /* IF CONDITION */
                           ir_if *f0D11 = new(mem_ctx) ir_if(operand(r0CE5).val);
                           exec_list *const f0D11_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D11->then_instructions;

                              ir_variable *const r0D12 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r0D12, add(r0CE1, body.constant(1u)), 0x01));

                              ir_expression *const r0D13 = less(r0D12, r0CE1);
                              ir_expression *const r0D14 = expr(ir_unop_b2i, r0D13);
                              ir_expression *const r0D15 = expr(ir_unop_i2u, r0D14);
                              body.emit(assign(r0CE0, add(r0CE0, r0D15), 0x01));

                              ir_expression *const r0D16 = equal(r0CE2, body.constant(0u));
                              ir_expression *const r0D17 = expr(ir_unop_b2i, r0D16);
                              ir_expression *const r0D18 = expr(ir_unop_i2u, r0D17);
                              ir_expression *const r0D19 = add(r0CE2, r0D18);
                              ir_expression *const r0D1A = bit_and(r0D19, body.constant(1u));
                              ir_expression *const r0D1B = expr(ir_unop_bit_not, r0D1A);
                              body.emit(assign(r0CE1, bit_and(r0D12, r0D1B), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0D11->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0D1D = bit_or(r0CE0, r0CE1);
                              ir_expression *const r0D1E = equal(r0D1D, body.constant(0u));
                              ir_if *f0D1C = new(mem_ctx) ir_if(operand(r0D1E).val);
                              exec_list *const f0D1C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D1C->then_instructions;

                                 body.emit(assign(r0CDF, body.constant(int(0)), 0x01));


                              body.instructions = f0D1C_parent_instructions;
                              body.emit(f0D1C);

                              /* END IF */


                           body.instructions = f0D11_parent_instructions;
                           body.emit(f0D11);

                           /* END IF */

                           ir_variable *const r0D1F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r0D1F);
                           ir_expression *const r0D20 = lshift(r0999, body.constant(int(31)));
                           ir_expression *const r0D21 = expr(ir_unop_i2u, r0CDF);
                           ir_expression *const r0D22 = lshift(r0D21, body.constant(int(20)));
                           ir_expression *const r0D23 = add(r0D20, r0D22);
                           body.emit(assign(r0D1F, add(r0D23, r0CE0), 0x02));

                           body.emit(assign(r0D1F, r0CE1, 0x01));

                           body.emit(assign(r0CE4, r0D1F, 0x03));

                           body.emit(assign(r0CE3, body.constant(false), 0x01));


                        body.instructions = f0D10_parent_instructions;
                        body.emit(f0D10);

                        /* END IF */

                        body.emit(assign(r099A, r0CE4, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0C98->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0D25 = less(swizzle_x(r099F), swizzle_x(r099D));
                        ir_if *f0D24 = new(mem_ctx) ir_if(operand(r0D25).val);
                        exec_list *const f0D24_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0D24->then_instructions;

                           ir_variable *const r0D26 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r0D27 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r0D27, sub(swizzle_x(r099D), swizzle_x(r099F)), 0x01));

                           ir_expression *const r0D28 = sub(swizzle_y(r099D), swizzle_y(r099F));
                           ir_expression *const r0D29 = less(swizzle_x(r099D), swizzle_x(r099F));
                           ir_expression *const r0D2A = expr(ir_unop_b2i, r0D29);
                           ir_expression *const r0D2B = expr(ir_unop_i2u, r0D2A);
                           body.emit(assign(r0D26, sub(r0D28, r0D2B), 0x01));

                           body.emit(assign(r0999, bit_xor(r0999, body.constant(1u)), 0x01));

                           body.emit(assign(r09A0, add(r099C, body.constant(int(-1))), 0x01));

                           ir_variable *const r0D2C = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r0D2C, add(r09A0, body.constant(int(-10))), 0x01));

                           ir_variable *const r0D2D = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r0D2D, r0D26, 0x01));

                           ir_variable *const r0D2E = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r0D2E, r0D27, 0x01));

                           ir_variable *const r0D2F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r0D2F);
                           ir_variable *const r0D30 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r0D30);
                           /* IF CONDITION */
                           ir_expression *const r0D32 = equal(r0D26, body.constant(0u));
                           ir_if *f0D31 = new(mem_ctx) ir_if(operand(r0D32).val);
                           exec_list *const f0D31_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D31->then_instructions;

                              body.emit(assign(r0D2D, r0D27, 0x01));

                              body.emit(assign(r0D2E, body.constant(0u), 0x01));

                              body.emit(assign(r0D2C, add(r0D2C, body.constant(int(-32))), 0x01));


                           body.instructions = f0D31_parent_instructions;
                           body.emit(f0D31);

                           /* END IF */

                           ir_variable *const r0D33 = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r0D33, r0D2D, 0x01));

                           ir_variable *const r0D34 = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r0D35 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r0D35);
                           /* IF CONDITION */
                           ir_expression *const r0D37 = equal(r0D2D, body.constant(0u));
                           ir_if *f0D36 = new(mem_ctx) ir_if(operand(r0D37).val);
                           exec_list *const f0D36_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D36->then_instructions;

                              body.emit(assign(r0D34, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0D36->else_instructions;

                              body.emit(assign(r0D35, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0D39 = bit_and(r0D2D, body.constant(4294901760u));
                              ir_expression *const r0D3A = equal(r0D39, body.constant(0u));
                              ir_if *f0D38 = new(mem_ctx) ir_if(operand(r0D3A).val);
                              exec_list *const f0D38_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D38->then_instructions;

                                 body.emit(assign(r0D35, body.constant(int(16)), 0x01));

                                 body.emit(assign(r0D33, lshift(r0D2D, body.constant(int(16))), 0x01));


                              body.instructions = f0D38_parent_instructions;
                              body.emit(f0D38);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r0D3C = bit_and(r0D33, body.constant(4278190080u));
                              ir_expression *const r0D3D = equal(r0D3C, body.constant(0u));
                              ir_if *f0D3B = new(mem_ctx) ir_if(operand(r0D3D).val);
                              exec_list *const f0D3B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D3B->then_instructions;

                                 body.emit(assign(r0D35, add(r0D35, body.constant(int(8))), 0x01));

                                 body.emit(assign(r0D33, lshift(r0D33, body.constant(int(8))), 0x01));


                              body.instructions = f0D3B_parent_instructions;
                              body.emit(f0D3B);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r0D3F = bit_and(r0D33, body.constant(4026531840u));
                              ir_expression *const r0D40 = equal(r0D3F, body.constant(0u));
                              ir_if *f0D3E = new(mem_ctx) ir_if(operand(r0D40).val);
                              exec_list *const f0D3E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D3E->then_instructions;

                                 body.emit(assign(r0D35, add(r0D35, body.constant(int(4))), 0x01));

                                 body.emit(assign(r0D33, lshift(r0D33, body.constant(int(4))), 0x01));


                              body.instructions = f0D3E_parent_instructions;
                              body.emit(f0D3E);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r0D42 = bit_and(r0D33, body.constant(3221225472u));
                              ir_expression *const r0D43 = equal(r0D42, body.constant(0u));
                              ir_if *f0D41 = new(mem_ctx) ir_if(operand(r0D43).val);
                              exec_list *const f0D41_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D41->then_instructions;

                                 body.emit(assign(r0D35, add(r0D35, body.constant(int(2))), 0x01));

                                 body.emit(assign(r0D33, lshift(r0D33, body.constant(int(2))), 0x01));


                              body.instructions = f0D41_parent_instructions;
                              body.emit(f0D41);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r0D45 = bit_and(r0D33, body.constant(2147483648u));
                              ir_expression *const r0D46 = equal(r0D45, body.constant(0u));
                              ir_if *f0D44 = new(mem_ctx) ir_if(operand(r0D46).val);
                              exec_list *const f0D44_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D44->then_instructions;

                                 body.emit(assign(r0D35, add(r0D35, body.constant(int(1))), 0x01));


                              body.instructions = f0D44_parent_instructions;
                              body.emit(f0D44);

                              /* END IF */

                              body.emit(assign(r0D34, r0D35, 0x01));


                           body.instructions = f0D36_parent_instructions;
                           body.emit(f0D36);

                           /* END IF */

                           body.emit(assign(r0D30, add(r0D34, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0D48 = lequal(body.constant(int(0)), r0D30);
                           ir_if *f0D47 = new(mem_ctx) ir_if(operand(r0D48).val);
                           exec_list *const f0D47_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D47->then_instructions;

                              body.emit(assign(r0D2F, body.constant(0u), 0x01));

                              ir_variable *const r0D49 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r0D49, lshift(r0D2E, r0D30), 0x01));

                              ir_variable *const r0D4A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0D4C = equal(r0D30, body.constant(int(0)));
                              ir_if *f0D4B = new(mem_ctx) ir_if(operand(r0D4C).val);
                              exec_list *const f0D4B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D4B->then_instructions;

                                 body.emit(assign(r0D4A, r0D2D, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D4B->else_instructions;

                                 ir_expression *const r0D4D = lshift(r0D2D, r0D30);
                                 ir_expression *const r0D4E = neg(r0D30);
                                 ir_expression *const r0D4F = bit_and(r0D4E, body.constant(int(31)));
                                 ir_expression *const r0D50 = rshift(r0D2E, r0D4F);
                                 body.emit(assign(r0D4A, bit_or(r0D4D, r0D50), 0x01));


                              body.instructions = f0D4B_parent_instructions;
                              body.emit(f0D4B);

                              /* END IF */

                              body.emit(assign(r0D2D, r0D4A, 0x01));

                              body.emit(assign(r0D2E, r0D49, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0D47->else_instructions;

                              ir_variable *const r0D51 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r0D51, body.constant(0u), 0x01));

                              ir_variable *const r0D52 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r0D52, neg(r0D30), 0x01));

                              ir_variable *const r0D53 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r0D53);
                              ir_variable *const r0D54 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r0D54);
                              ir_variable *const r0D55 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r0D55);
                              ir_variable *const r0D56 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r0D57 = neg(r0D52);
                              body.emit(assign(r0D56, bit_and(r0D57, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0D59 = equal(r0D52, body.constant(int(0)));
                              ir_if *f0D58 = new(mem_ctx) ir_if(operand(r0D59).val);
                              exec_list *const f0D58_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D58->then_instructions;

                                 body.emit(assign(r0D53, r0D51, 0x01));

                                 body.emit(assign(r0D54, r0D2E, 0x01));

                                 body.emit(assign(r0D55, r0D2D, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D58->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0D5B = less(r0D52, body.constant(int(32)));
                                 ir_if *f0D5A = new(mem_ctx) ir_if(operand(r0D5B).val);
                                 exec_list *const f0D5A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0D5A->then_instructions;

                                    body.emit(assign(r0D53, lshift(r0D2E, r0D56), 0x01));

                                    ir_expression *const r0D5C = lshift(r0D2D, r0D56);
                                    ir_expression *const r0D5D = rshift(r0D2E, r0D52);
                                    body.emit(assign(r0D54, bit_or(r0D5C, r0D5D), 0x01));

                                    body.emit(assign(r0D55, rshift(r0D2D, r0D52), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0D5A->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r0D5F = equal(r0D52, body.constant(int(32)));
                                    ir_if *f0D5E = new(mem_ctx) ir_if(operand(r0D5F).val);
                                    exec_list *const f0D5E_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0D5E->then_instructions;

                                       body.emit(assign(r0D53, r0D2E, 0x01));

                                       body.emit(assign(r0D54, r0D2D, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0D5E->else_instructions;

                                       body.emit(assign(r0D51, bit_or(body.constant(0u), r0D2E), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r0D61 = less(r0D52, body.constant(int(64)));
                                       ir_if *f0D60 = new(mem_ctx) ir_if(operand(r0D61).val);
                                       exec_list *const f0D60_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0D60->then_instructions;

                                          body.emit(assign(r0D53, lshift(r0D2D, r0D56), 0x01));

                                          ir_expression *const r0D62 = bit_and(r0D52, body.constant(int(31)));
                                          body.emit(assign(r0D54, rshift(r0D2D, r0D62), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0D60->else_instructions;

                                          ir_variable *const r0D63 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r0D65 = equal(r0D52, body.constant(int(64)));
                                          ir_if *f0D64 = new(mem_ctx) ir_if(operand(r0D65).val);
                                          exec_list *const f0D64_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0D64->then_instructions;

                                             body.emit(assign(r0D63, r0D2D, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0D64->else_instructions;

                                             ir_expression *const r0D66 = nequal(r0D2D, body.constant(0u));
                                             ir_expression *const r0D67 = expr(ir_unop_b2i, r0D66);
                                             body.emit(assign(r0D63, expr(ir_unop_i2u, r0D67), 0x01));


                                          body.instructions = f0D64_parent_instructions;
                                          body.emit(f0D64);

                                          /* END IF */

                                          body.emit(assign(r0D53, r0D63, 0x01));

                                          body.emit(assign(r0D54, body.constant(0u), 0x01));


                                       body.instructions = f0D60_parent_instructions;
                                       body.emit(f0D60);

                                       /* END IF */


                                    body.instructions = f0D5E_parent_instructions;
                                    body.emit(f0D5E);

                                    /* END IF */

                                    body.emit(assign(r0D55, body.constant(0u), 0x01));


                                 body.instructions = f0D5A_parent_instructions;
                                 body.emit(f0D5A);

                                 /* END IF */

                                 ir_expression *const r0D68 = nequal(r0D51, body.constant(0u));
                                 ir_expression *const r0D69 = expr(ir_unop_b2i, r0D68);
                                 ir_expression *const r0D6A = expr(ir_unop_i2u, r0D69);
                                 body.emit(assign(r0D53, bit_or(r0D53, r0D6A), 0x01));


                              body.instructions = f0D58_parent_instructions;
                              body.emit(f0D58);

                              /* END IF */

                              body.emit(assign(r0D2D, r0D55, 0x01));

                              body.emit(assign(r0D2E, r0D54, 0x01));

                              body.emit(assign(r0D2F, r0D53, 0x01));


                           body.instructions = f0D47_parent_instructions;
                           body.emit(f0D47);

                           /* END IF */

                           body.emit(assign(r0D2C, sub(r0D2C, r0D30), 0x01));

                           ir_variable *const r0D6B = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r0D6B, r0D2C, 0x01));

                           ir_variable *const r0D6C = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r0D6C, r0D2D, 0x01));

                           ir_variable *const r0D6D = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r0D6D, r0D2E, 0x01));

                           ir_variable *const r0D6E = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r0D6E, r0D2F, 0x01));

                           ir_variable *const r0D6F = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r0D6F, body.constant(true), 0x01));

                           ir_variable *const r0D70 = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r0D71 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r0D71);
                           ir_expression *const r0D72 = expr(ir_unop_u2i, r0D2F);
                           body.emit(assign(r0D71, less(r0D72, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0D74 = lequal(body.constant(int(2045)), r0D2C);
                           ir_if *f0D73 = new(mem_ctx) ir_if(operand(r0D74).val);
                           exec_list *const f0D73_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D73->then_instructions;

                              ir_variable *const r0D75 = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0D77 = less(body.constant(int(2045)), r0D2C);
                              ir_if *f0D76 = new(mem_ctx) ir_if(operand(r0D77).val);
                              exec_list *const f0D76_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D76->then_instructions;

                                 body.emit(assign(r0D75, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D76->else_instructions;

                                 ir_variable *const r0D78 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0D7A = equal(r0D2C, body.constant(int(2045)));
                                 ir_if *f0D79 = new(mem_ctx) ir_if(operand(r0D7A).val);
                                 exec_list *const f0D79_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0D79->then_instructions;

                                    ir_expression *const r0D7B = equal(body.constant(2097151u), r0D2D);
                                    ir_expression *const r0D7C = equal(body.constant(4294967295u), r0D2E);
                                    body.emit(assign(r0D78, logic_and(r0D7B, r0D7C), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0D79->else_instructions;

                                    body.emit(assign(r0D78, body.constant(false), 0x01));


                                 body.instructions = f0D79_parent_instructions;
                                 body.emit(f0D79);

                                 /* END IF */

                                 body.emit(assign(r0D75, logic_and(r0D78, r0D71), 0x01));


                              body.instructions = f0D76_parent_instructions;
                              body.emit(f0D76);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f0D7D = new(mem_ctx) ir_if(operand(r0D75).val);
                              exec_list *const f0D7D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D7D->then_instructions;

                                 ir_variable *const r0D7E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r0D7E);
                                 ir_expression *const r0D7F = lshift(r0999, body.constant(int(31)));
                                 body.emit(assign(r0D7E, add(r0D7F, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r0D7E, body.constant(0u), 0x01));

                                 body.emit(assign(r0D70, r0D7E, 0x03));

                                 body.emit(assign(r0D6F, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D7D->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0D81 = less(r0D2C, body.constant(int(0)));
                                 ir_if *f0D80 = new(mem_ctx) ir_if(operand(r0D81).val);
                                 exec_list *const f0D80_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0D80->then_instructions;

                                    ir_variable *const r0D82 = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r0D82, r0D2F, 0x01));

                                    ir_variable *const r0D83 = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r0D83, neg(r0D2C), 0x01));

                                    ir_variable *const r0D84 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r0D84);
                                    ir_variable *const r0D85 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r0D85);
                                    ir_variable *const r0D86 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r0D86);
                                    ir_variable *const r0D87 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r0D88 = neg(r0D83);
                                    body.emit(assign(r0D87, bit_and(r0D88, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r0D8A = equal(r0D83, body.constant(int(0)));
                                    ir_if *f0D89 = new(mem_ctx) ir_if(operand(r0D8A).val);
                                    exec_list *const f0D89_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0D89->then_instructions;

                                       body.emit(assign(r0D84, r0D2F, 0x01));

                                       body.emit(assign(r0D85, r0D2E, 0x01));

                                       body.emit(assign(r0D86, r0D2D, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0D89->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r0D8C = less(r0D83, body.constant(int(32)));
                                       ir_if *f0D8B = new(mem_ctx) ir_if(operand(r0D8C).val);
                                       exec_list *const f0D8B_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0D8B->then_instructions;

                                          body.emit(assign(r0D84, lshift(r0D2E, r0D87), 0x01));

                                          ir_expression *const r0D8D = lshift(r0D2D, r0D87);
                                          ir_expression *const r0D8E = rshift(r0D2E, r0D83);
                                          body.emit(assign(r0D85, bit_or(r0D8D, r0D8E), 0x01));

                                          body.emit(assign(r0D86, rshift(r0D2D, r0D83), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0D8B->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r0D90 = equal(r0D83, body.constant(int(32)));
                                          ir_if *f0D8F = new(mem_ctx) ir_if(operand(r0D90).val);
                                          exec_list *const f0D8F_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0D8F->then_instructions;

                                             body.emit(assign(r0D84, r0D2E, 0x01));

                                             body.emit(assign(r0D85, r0D2D, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0D8F->else_instructions;

                                             body.emit(assign(r0D82, bit_or(r0D2F, r0D2E), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r0D92 = less(r0D83, body.constant(int(64)));
                                             ir_if *f0D91 = new(mem_ctx) ir_if(operand(r0D92).val);
                                             exec_list *const f0D91_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f0D91->then_instructions;

                                                body.emit(assign(r0D84, lshift(r0D2D, r0D87), 0x01));

                                                ir_expression *const r0D93 = bit_and(r0D83, body.constant(int(31)));
                                                body.emit(assign(r0D85, rshift(r0D2D, r0D93), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f0D91->else_instructions;

                                                ir_variable *const r0D94 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r0D96 = equal(r0D83, body.constant(int(64)));
                                                ir_if *f0D95 = new(mem_ctx) ir_if(operand(r0D96).val);
                                                exec_list *const f0D95_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f0D95->then_instructions;

                                                   body.emit(assign(r0D94, r0D2D, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f0D95->else_instructions;

                                                   ir_expression *const r0D97 = nequal(r0D2D, body.constant(0u));
                                                   ir_expression *const r0D98 = expr(ir_unop_b2i, r0D97);
                                                   body.emit(assign(r0D94, expr(ir_unop_i2u, r0D98), 0x01));


                                                body.instructions = f0D95_parent_instructions;
                                                body.emit(f0D95);

                                                /* END IF */

                                                body.emit(assign(r0D84, r0D94, 0x01));

                                                body.emit(assign(r0D85, body.constant(0u), 0x01));


                                             body.instructions = f0D91_parent_instructions;
                                             body.emit(f0D91);

                                             /* END IF */


                                          body.instructions = f0D8F_parent_instructions;
                                          body.emit(f0D8F);

                                          /* END IF */

                                          body.emit(assign(r0D86, body.constant(0u), 0x01));


                                       body.instructions = f0D8B_parent_instructions;
                                       body.emit(f0D8B);

                                       /* END IF */

                                       ir_expression *const r0D99 = nequal(r0D82, body.constant(0u));
                                       ir_expression *const r0D9A = expr(ir_unop_b2i, r0D99);
                                       ir_expression *const r0D9B = expr(ir_unop_i2u, r0D9A);
                                       body.emit(assign(r0D84, bit_or(r0D84, r0D9B), 0x01));


                                    body.instructions = f0D89_parent_instructions;
                                    body.emit(f0D89);

                                    /* END IF */

                                    body.emit(assign(r0D6C, r0D86, 0x01));

                                    body.emit(assign(r0D6D, r0D85, 0x01));

                                    body.emit(assign(r0D6E, r0D84, 0x01));

                                    body.emit(assign(r0D6B, body.constant(int(0)), 0x01));

                                    body.emit(assign(r0D71, less(r0D84, body.constant(0u)), 0x01));


                                 body.instructions = f0D80_parent_instructions;
                                 body.emit(f0D80);

                                 /* END IF */


                              body.instructions = f0D7D_parent_instructions;
                              body.emit(f0D7D);

                              /* END IF */


                           body.instructions = f0D73_parent_instructions;
                           body.emit(f0D73);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f0D9C = new(mem_ctx) ir_if(operand(r0D6F).val);
                           exec_list *const f0D9C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D9C->then_instructions;

                              /* IF CONDITION */
                              ir_if *f0D9D = new(mem_ctx) ir_if(operand(r0D71).val);
                              exec_list *const f0D9D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D9D->then_instructions;

                                 ir_variable *const r0D9E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r0D9E, add(r0D6D, body.constant(1u)), 0x01));

                                 ir_expression *const r0D9F = less(r0D9E, r0D6D);
                                 ir_expression *const r0DA0 = expr(ir_unop_b2i, r0D9F);
                                 ir_expression *const r0DA1 = expr(ir_unop_i2u, r0DA0);
                                 body.emit(assign(r0D6C, add(r0D6C, r0DA1), 0x01));

                                 ir_expression *const r0DA2 = equal(r0D6E, body.constant(0u));
                                 ir_expression *const r0DA3 = expr(ir_unop_b2i, r0DA2);
                                 ir_expression *const r0DA4 = expr(ir_unop_i2u, r0DA3);
                                 ir_expression *const r0DA5 = add(r0D6E, r0DA4);
                                 ir_expression *const r0DA6 = bit_and(r0DA5, body.constant(1u));
                                 ir_expression *const r0DA7 = expr(ir_unop_bit_not, r0DA6);
                                 body.emit(assign(r0D6D, bit_and(r0D9E, r0DA7), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D9D->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0DA9 = bit_or(r0D6C, r0D6D);
                                 ir_expression *const r0DAA = equal(r0DA9, body.constant(0u));
                                 ir_if *f0DA8 = new(mem_ctx) ir_if(operand(r0DAA).val);
                                 exec_list *const f0DA8_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0DA8->then_instructions;

                                    body.emit(assign(r0D6B, body.constant(int(0)), 0x01));


                                 body.instructions = f0DA8_parent_instructions;
                                 body.emit(f0DA8);

                                 /* END IF */


                              body.instructions = f0D9D_parent_instructions;
                              body.emit(f0D9D);

                              /* END IF */

                              ir_variable *const r0DAB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r0DAB);
                              ir_expression *const r0DAC = lshift(r0999, body.constant(int(31)));
                              ir_expression *const r0DAD = expr(ir_unop_i2u, r0D6B);
                              ir_expression *const r0DAE = lshift(r0DAD, body.constant(int(20)));
                              ir_expression *const r0DAF = add(r0DAC, r0DAE);
                              body.emit(assign(r0DAB, add(r0DAF, r0D6C), 0x02));

                              body.emit(assign(r0DAB, r0D6D, 0x01));

                              body.emit(assign(r0D70, r0DAB, 0x03));

                              body.emit(assign(r0D6F, body.constant(false), 0x01));


                           body.instructions = f0D9C_parent_instructions;
                           body.emit(f0D9C);

                           /* END IF */

                           body.emit(assign(r099A, r0D70, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0D24->else_instructions;

                           ir_variable *const r0DB0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r0DB0);
                           body.emit(assign(r0DB0, body.constant(0u), 0x02));

                           body.emit(assign(r0DB0, body.constant(0u), 0x01));

                           body.emit(assign(r099A, r0DB0, 0x03));


                        body.instructions = f0D24_parent_instructions;
                        body.emit(f0D24);

                        /* END IF */


                     body.instructions = f0C98_parent_instructions;
                     body.emit(f0C98);

                     /* END IF */


                  body.instructions = f0C0C_parent_instructions;
                  body.emit(f0C0C);

                  /* END IF */


               body.instructions = f0B80_parent_instructions;
               body.emit(f0B80);

               /* END IF */


            body.instructions = f0B59_parent_instructions;
            body.emit(f0B59);

            /* END IF */


         body.instructions = f0A83_parent_instructions;
         body.emit(f0A83);

         /* END IF */


      body.instructions = f09B1_parent_instructions;
      body.emit(f09B1);

      /* END IF */

      body.emit(assign(r07EB, r099A, 0x03));


   body.instructions = f07EE_parent_instructions;
   body.emit(f07EE);

   /* END IF */

   body.emit(ret(r07EB));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fsub64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0DB1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0DB1);
   ir_variable *const r0DB2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0DB2);
   ir_variable *const r0DB3 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r0DB4 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r0DB4, rshift(swizzle_y(r0DB1), body.constant(int(31))), 0x01));

   ir_variable *const r0DB5 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r0DB5, rshift(swizzle_y(r0DB2), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r0DB7 = equal(r0DB4, r0DB5);
   ir_if *f0DB6 = new(mem_ctx) ir_if(operand(r0DB7).val);
   exec_list *const f0DB6_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0DB6->then_instructions;

      ir_variable *const r0DB8 = body.make_temp(glsl_type::uint_type, "zSign");
      body.emit(assign(r0DB8, r0DB4, 0x01));

      ir_variable *const r0DB9 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r0DBA = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r0DBA);
      ir_variable *const r0DBB = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
      body.emit(r0DBB);
      ir_variable *const r0DBC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
      body.emit(r0DBC);
      ir_variable *const r0DBD = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
      body.emit(r0DBD);
      ir_variable *const r0DBE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
      body.emit(r0DBE);
      ir_variable *const r0DBF = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r0DBF);
      ir_variable *const r0DC0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r0DC0);
      body.emit(assign(r0DC0, bit_and(swizzle_y(r0DB1), body.constant(1048575u)), 0x02));

      body.emit(assign(r0DC0, swizzle_x(r0DB1), 0x01));

      ir_variable *const r0DC1 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r0DC2 = rshift(swizzle_y(r0DB1), body.constant(int(20)));
      ir_expression *const r0DC3 = bit_and(r0DC2, body.constant(2047u));
      body.emit(assign(r0DC1, expr(ir_unop_u2i, r0DC3), 0x01));

      body.emit(assign(r0DBD, r0DC1, 0x01));

      ir_variable *const r0DC4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r0DC4);
      body.emit(assign(r0DC4, bit_and(swizzle_y(r0DB2), body.constant(1048575u)), 0x02));

      body.emit(assign(r0DC4, swizzle_x(r0DB2), 0x01));

      ir_variable *const r0DC5 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r0DC6 = rshift(swizzle_y(r0DB2), body.constant(int(20)));
      ir_expression *const r0DC7 = bit_and(r0DC6, body.constant(2047u));
      body.emit(assign(r0DC5, expr(ir_unop_u2i, r0DC7), 0x01));

      body.emit(assign(r0DBB, r0DC5, 0x01));

      body.emit(assign(r0DBA, sub(r0DC1, r0DC5), 0x01));

      ir_variable *const r0DC8 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r0DC8, lshift(swizzle_x(r0DB1), body.constant(int(10))), 0x01));

      ir_variable *const r0DC9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r0DCA = lshift(swizzle_y(r0DC0), body.constant(int(10)));
      ir_expression *const r0DCB = rshift(swizzle_x(r0DB1), body.constant(int(22)));
      body.emit(assign(r0DC9, bit_or(r0DCA, r0DCB), 0x01));

      body.emit(assign(r0DBE, r0DC9, 0x02));

      body.emit(assign(r0DBE, r0DC8, 0x01));

      ir_variable *const r0DCC = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r0DCC, lshift(swizzle_x(r0DB2), body.constant(int(10))), 0x01));

      ir_variable *const r0DCD = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r0DCE = lshift(swizzle_y(r0DC4), body.constant(int(10)));
      ir_expression *const r0DCF = rshift(swizzle_x(r0DB2), body.constant(int(22)));
      body.emit(assign(r0DCD, bit_or(r0DCE, r0DCF), 0x01));

      body.emit(assign(r0DBC, r0DCD, 0x02));

      body.emit(assign(r0DBC, r0DCC, 0x01));

      /* IF CONDITION */
      ir_expression *const r0DD1 = less(body.constant(int(0)), r0DBA);
      ir_if *f0DD0 = new(mem_ctx) ir_if(operand(r0DD1).val);
      exec_list *const f0DD0_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0DD0->then_instructions;

         /* IF CONDITION */
         ir_expression *const r0DD3 = equal(r0DC1, body.constant(int(2047)));
         ir_if *f0DD2 = new(mem_ctx) ir_if(operand(r0DD3).val);
         exec_list *const f0DD2_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0DD2->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0DD5 = bit_or(r0DC9, r0DC8);
            ir_expression *const r0DD6 = nequal(r0DD5, body.constant(0u));
            ir_if *f0DD4 = new(mem_ctx) ir_if(operand(r0DD6).val);
            exec_list *const f0DD4_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0DD4->then_instructions;

               ir_variable *const r0DD7 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r0DD7, swizzle_x(r0DB1), 0x01));

               ir_variable *const r0DD8 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r0DD8, swizzle_x(r0DB2), 0x01));

               ir_variable *const r0DD9 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0DDA = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r0DDB = rshift(swizzle_y(r0DB1), body.constant(int(19)));
               ir_expression *const r0DDC = bit_and(r0DDB, body.constant(4095u));
               ir_expression *const r0DDD = equal(r0DDC, body.constant(4094u));
               ir_expression *const r0DDE = nequal(swizzle_x(r0DB1), body.constant(0u));
               ir_expression *const r0DDF = bit_and(swizzle_y(r0DB1), body.constant(524287u));
               ir_expression *const r0DE0 = nequal(r0DDF, body.constant(0u));
               ir_expression *const r0DE1 = logic_or(r0DDE, r0DE0);
               body.emit(assign(r0DDA, logic_and(r0DDD, r0DE1), 0x01));

               ir_variable *const r0DE2 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r0DE3 = lshift(swizzle_y(r0DB2), body.constant(int(1)));
               ir_expression *const r0DE4 = lequal(body.constant(4292870144u), r0DE3);
               ir_expression *const r0DE5 = nequal(swizzle_x(r0DB2), body.constant(0u));
               ir_expression *const r0DE6 = bit_and(swizzle_y(r0DB2), body.constant(1048575u));
               ir_expression *const r0DE7 = nequal(r0DE6, body.constant(0u));
               ir_expression *const r0DE8 = logic_or(r0DE5, r0DE7);
               body.emit(assign(r0DE2, logic_and(r0DE4, r0DE8), 0x01));

               body.emit(assign(r0DD7, bit_or(swizzle_y(r0DB1), body.constant(524288u)), 0x02));

               body.emit(assign(r0DD8, bit_or(swizzle_y(r0DB2), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r0DEA = lshift(swizzle_y(r0DB1), body.constant(int(1)));
               ir_expression *const r0DEB = lequal(body.constant(4292870144u), r0DEA);
               ir_expression *const r0DEC = nequal(swizzle_x(r0DB1), body.constant(0u));
               ir_expression *const r0DED = bit_and(swizzle_y(r0DB1), body.constant(1048575u));
               ir_expression *const r0DEE = nequal(r0DED, body.constant(0u));
               ir_expression *const r0DEF = logic_or(r0DEC, r0DEE);
               ir_expression *const r0DF0 = logic_and(r0DEB, r0DEF);
               ir_if *f0DE9 = new(mem_ctx) ir_if(operand(r0DF0).val);
               exec_list *const f0DE9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0DE9->then_instructions;

                  ir_variable *const r0DF1 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0DF3 = logic_and(r0DDA, r0DE2);
                  ir_if *f0DF2 = new(mem_ctx) ir_if(operand(r0DF3).val);
                  exec_list *const f0DF2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0DF2->then_instructions;

                     body.emit(assign(r0DF1, r0DD8, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0DF2->else_instructions;

                     body.emit(assign(r0DF1, r0DD7, 0x03));


                  body.instructions = f0DF2_parent_instructions;
                  body.emit(f0DF2);

                  /* END IF */

                  body.emit(assign(r0DD9, r0DF1, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0DE9->else_instructions;

                  body.emit(assign(r0DD9, r0DD8, 0x03));


               body.instructions = f0DE9_parent_instructions;
               body.emit(f0DE9);

               /* END IF */

               body.emit(assign(r0DB9, r0DD9, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0DD4->else_instructions;

               body.emit(assign(r0DB9, r0DB1, 0x03));


            body.instructions = f0DD4_parent_instructions;
            body.emit(f0DD4);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0DD2->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0DF5 = equal(r0DC5, body.constant(int(0)));
            ir_if *f0DF4 = new(mem_ctx) ir_if(operand(r0DF5).val);
            exec_list *const f0DF4_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0DF4->then_instructions;

               body.emit(assign(r0DBA, add(r0DBA, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0DF4->else_instructions;

               body.emit(assign(r0DBC, bit_or(r0DCD, body.constant(1073741824u)), 0x02));


            body.instructions = f0DF4_parent_instructions;
            body.emit(f0DF4);

            /* END IF */

            ir_variable *const r0DF6 = body.make_temp(glsl_type::uint_type, "a0");
            body.emit(assign(r0DF6, swizzle_y(r0DBC), 0x01));

            ir_variable *const r0DF7 = body.make_temp(glsl_type::uint_type, "a1");
            body.emit(assign(r0DF7, swizzle_x(r0DBC), 0x01));

            ir_variable *const r0DF8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r0DF8);
            ir_variable *const r0DF9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r0DF9);
            ir_variable *const r0DFA = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r0DFB = neg(r0DBA);
            body.emit(assign(r0DFA, bit_and(r0DFB, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0DFD = equal(r0DBA, body.constant(int(0)));
            ir_if *f0DFC = new(mem_ctx) ir_if(operand(r0DFD).val);
            exec_list *const f0DFC_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0DFC->then_instructions;

               body.emit(assign(r0DF8, r0DF7, 0x01));

               body.emit(assign(r0DF9, r0DF6, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0DFC->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0DFF = less(r0DBA, body.constant(int(32)));
               ir_if *f0DFE = new(mem_ctx) ir_if(operand(r0DFF).val);
               exec_list *const f0DFE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0DFE->then_instructions;

                  ir_expression *const r0E00 = lshift(swizzle_y(r0DBC), r0DFA);
                  ir_expression *const r0E01 = rshift(r0DCC, r0DBA);
                  ir_expression *const r0E02 = bit_or(r0E00, r0E01);
                  ir_expression *const r0E03 = lshift(r0DCC, r0DFA);
                  ir_expression *const r0E04 = nequal(r0E03, body.constant(0u));
                  ir_expression *const r0E05 = expr(ir_unop_b2i, r0E04);
                  ir_expression *const r0E06 = expr(ir_unop_i2u, r0E05);
                  body.emit(assign(r0DF8, bit_or(r0E02, r0E06), 0x01));

                  body.emit(assign(r0DF9, rshift(swizzle_y(r0DBC), r0DBA), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0DFE->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0E08 = equal(r0DBA, body.constant(int(32)));
                  ir_if *f0E07 = new(mem_ctx) ir_if(operand(r0E08).val);
                  exec_list *const f0E07_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0E07->then_instructions;

                     ir_expression *const r0E09 = nequal(r0DCC, body.constant(0u));
                     ir_expression *const r0E0A = expr(ir_unop_b2i, r0E09);
                     ir_expression *const r0E0B = expr(ir_unop_i2u, r0E0A);
                     body.emit(assign(r0DF8, bit_or(swizzle_y(r0DBC), r0E0B), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0E07->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0E0D = less(r0DBA, body.constant(int(64)));
                     ir_if *f0E0C = new(mem_ctx) ir_if(operand(r0E0D).val);
                     exec_list *const f0E0C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0E0C->then_instructions;

                        ir_expression *const r0E0E = bit_and(r0DBA, body.constant(int(31)));
                        ir_expression *const r0E0F = rshift(swizzle_y(r0DBC), r0E0E);
                        ir_expression *const r0E10 = lshift(swizzle_y(r0DBC), r0DFA);
                        ir_expression *const r0E11 = bit_or(r0E10, r0DCC);
                        ir_expression *const r0E12 = nequal(r0E11, body.constant(0u));
                        ir_expression *const r0E13 = expr(ir_unop_b2i, r0E12);
                        ir_expression *const r0E14 = expr(ir_unop_i2u, r0E13);
                        body.emit(assign(r0DF8, bit_or(r0E0F, r0E14), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0E0C->else_instructions;

                        ir_expression *const r0E15 = bit_or(swizzle_y(r0DBC), r0DCC);
                        ir_expression *const r0E16 = nequal(r0E15, body.constant(0u));
                        ir_expression *const r0E17 = expr(ir_unop_b2i, r0E16);
                        body.emit(assign(r0DF8, expr(ir_unop_i2u, r0E17), 0x01));


                     body.instructions = f0E0C_parent_instructions;
                     body.emit(f0E0C);

                     /* END IF */


                  body.instructions = f0E07_parent_instructions;
                  body.emit(f0E07);

                  /* END IF */

                  body.emit(assign(r0DF9, body.constant(0u), 0x01));


               body.instructions = f0DFE_parent_instructions;
               body.emit(f0DFE);

               /* END IF */


            body.instructions = f0DFC_parent_instructions;
            body.emit(f0DFC);

            /* END IF */

            body.emit(assign(r0DBC, r0DF9, 0x02));

            body.emit(assign(r0DBC, r0DF8, 0x01));

            body.emit(assign(r0DBE, bit_or(r0DC9, body.constant(1073741824u)), 0x02));

            ir_variable *const r0E18 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r0E19 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r0E19, sub(r0DC8, r0DF8), 0x01));

            ir_expression *const r0E1A = sub(swizzle_y(r0DBE), r0DF9);
            ir_expression *const r0E1B = less(r0DC8, r0DF8);
            ir_expression *const r0E1C = expr(ir_unop_b2i, r0E1B);
            ir_expression *const r0E1D = expr(ir_unop_i2u, r0E1C);
            body.emit(assign(r0E18, sub(r0E1A, r0E1D), 0x01));

            body.emit(assign(r0DBF, add(r0DC1, body.constant(int(-1))), 0x01));

            ir_variable *const r0E1E = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0E1E, add(r0DBF, body.constant(int(-10))), 0x01));

            ir_variable *const r0E1F = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0E1F, r0E18, 0x01));

            ir_variable *const r0E20 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0E20, r0E19, 0x01));

            ir_variable *const r0E21 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
            body.emit(r0E21);
            ir_variable *const r0E22 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0E22);
            /* IF CONDITION */
            ir_expression *const r0E24 = equal(r0E18, body.constant(0u));
            ir_if *f0E23 = new(mem_ctx) ir_if(operand(r0E24).val);
            exec_list *const f0E23_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0E23->then_instructions;

               body.emit(assign(r0E1F, r0E19, 0x01));

               body.emit(assign(r0E20, body.constant(0u), 0x01));

               body.emit(assign(r0E1E, add(r0E1E, body.constant(int(-32))), 0x01));


            body.instructions = f0E23_parent_instructions;
            body.emit(f0E23);

            /* END IF */

            ir_variable *const r0E25 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r0E25, r0E1F, 0x01));

            ir_variable *const r0E26 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r0E27 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0E27);
            /* IF CONDITION */
            ir_expression *const r0E29 = equal(r0E1F, body.constant(0u));
            ir_if *f0E28 = new(mem_ctx) ir_if(operand(r0E29).val);
            exec_list *const f0E28_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0E28->then_instructions;

               body.emit(assign(r0E26, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0E28->else_instructions;

               body.emit(assign(r0E27, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r0E2B = bit_and(r0E1F, body.constant(4294901760u));
               ir_expression *const r0E2C = equal(r0E2B, body.constant(0u));
               ir_if *f0E2A = new(mem_ctx) ir_if(operand(r0E2C).val);
               exec_list *const f0E2A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E2A->then_instructions;

                  body.emit(assign(r0E27, body.constant(int(16)), 0x01));

                  body.emit(assign(r0E25, lshift(r0E1F, body.constant(int(16))), 0x01));


               body.instructions = f0E2A_parent_instructions;
               body.emit(f0E2A);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0E2E = bit_and(r0E25, body.constant(4278190080u));
               ir_expression *const r0E2F = equal(r0E2E, body.constant(0u));
               ir_if *f0E2D = new(mem_ctx) ir_if(operand(r0E2F).val);
               exec_list *const f0E2D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E2D->then_instructions;

                  body.emit(assign(r0E27, add(r0E27, body.constant(int(8))), 0x01));

                  body.emit(assign(r0E25, lshift(r0E25, body.constant(int(8))), 0x01));


               body.instructions = f0E2D_parent_instructions;
               body.emit(f0E2D);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0E31 = bit_and(r0E25, body.constant(4026531840u));
               ir_expression *const r0E32 = equal(r0E31, body.constant(0u));
               ir_if *f0E30 = new(mem_ctx) ir_if(operand(r0E32).val);
               exec_list *const f0E30_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E30->then_instructions;

                  body.emit(assign(r0E27, add(r0E27, body.constant(int(4))), 0x01));

                  body.emit(assign(r0E25, lshift(r0E25, body.constant(int(4))), 0x01));


               body.instructions = f0E30_parent_instructions;
               body.emit(f0E30);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0E34 = bit_and(r0E25, body.constant(3221225472u));
               ir_expression *const r0E35 = equal(r0E34, body.constant(0u));
               ir_if *f0E33 = new(mem_ctx) ir_if(operand(r0E35).val);
               exec_list *const f0E33_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E33->then_instructions;

                  body.emit(assign(r0E27, add(r0E27, body.constant(int(2))), 0x01));

                  body.emit(assign(r0E25, lshift(r0E25, body.constant(int(2))), 0x01));


               body.instructions = f0E33_parent_instructions;
               body.emit(f0E33);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0E37 = bit_and(r0E25, body.constant(2147483648u));
               ir_expression *const r0E38 = equal(r0E37, body.constant(0u));
               ir_if *f0E36 = new(mem_ctx) ir_if(operand(r0E38).val);
               exec_list *const f0E36_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E36->then_instructions;

                  body.emit(assign(r0E27, add(r0E27, body.constant(int(1))), 0x01));


               body.instructions = f0E36_parent_instructions;
               body.emit(f0E36);

               /* END IF */

               body.emit(assign(r0E26, r0E27, 0x01));


            body.instructions = f0E28_parent_instructions;
            body.emit(f0E28);

            /* END IF */

            body.emit(assign(r0E22, add(r0E26, body.constant(int(-11))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0E3A = lequal(body.constant(int(0)), r0E22);
            ir_if *f0E39 = new(mem_ctx) ir_if(operand(r0E3A).val);
            exec_list *const f0E39_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0E39->then_instructions;

               body.emit(assign(r0E21, body.constant(0u), 0x01));

               ir_variable *const r0E3B = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r0E3B, lshift(r0E20, r0E22), 0x01));

               ir_variable *const r0E3C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r0E3E = equal(r0E22, body.constant(int(0)));
               ir_if *f0E3D = new(mem_ctx) ir_if(operand(r0E3E).val);
               exec_list *const f0E3D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E3D->then_instructions;

                  body.emit(assign(r0E3C, r0E1F, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0E3D->else_instructions;

                  ir_expression *const r0E3F = lshift(r0E1F, r0E22);
                  ir_expression *const r0E40 = neg(r0E22);
                  ir_expression *const r0E41 = bit_and(r0E40, body.constant(int(31)));
                  ir_expression *const r0E42 = rshift(r0E20, r0E41);
                  body.emit(assign(r0E3C, bit_or(r0E3F, r0E42), 0x01));


               body.instructions = f0E3D_parent_instructions;
               body.emit(f0E3D);

               /* END IF */

               body.emit(assign(r0E1F, r0E3C, 0x01));

               body.emit(assign(r0E20, r0E3B, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0E39->else_instructions;

               ir_variable *const r0E43 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r0E43, body.constant(0u), 0x01));

               ir_variable *const r0E44 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0E44, neg(r0E22), 0x01));

               ir_variable *const r0E45 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r0E45);
               ir_variable *const r0E46 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0E46);
               ir_variable *const r0E47 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0E47);
               ir_variable *const r0E48 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0E49 = neg(r0E44);
               body.emit(assign(r0E48, bit_and(r0E49, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0E4B = equal(r0E44, body.constant(int(0)));
               ir_if *f0E4A = new(mem_ctx) ir_if(operand(r0E4B).val);
               exec_list *const f0E4A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E4A->then_instructions;

                  body.emit(assign(r0E45, r0E43, 0x01));

                  body.emit(assign(r0E46, r0E20, 0x01));

                  body.emit(assign(r0E47, r0E1F, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0E4A->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0E4D = less(r0E44, body.constant(int(32)));
                  ir_if *f0E4C = new(mem_ctx) ir_if(operand(r0E4D).val);
                  exec_list *const f0E4C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0E4C->then_instructions;

                     body.emit(assign(r0E45, lshift(r0E20, r0E48), 0x01));

                     ir_expression *const r0E4E = lshift(r0E1F, r0E48);
                     ir_expression *const r0E4F = rshift(r0E20, r0E44);
                     body.emit(assign(r0E46, bit_or(r0E4E, r0E4F), 0x01));

                     body.emit(assign(r0E47, rshift(r0E1F, r0E44), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0E4C->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0E51 = equal(r0E44, body.constant(int(32)));
                     ir_if *f0E50 = new(mem_ctx) ir_if(operand(r0E51).val);
                     exec_list *const f0E50_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0E50->then_instructions;

                        body.emit(assign(r0E45, r0E20, 0x01));

                        body.emit(assign(r0E46, r0E1F, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0E50->else_instructions;

                        body.emit(assign(r0E43, bit_or(body.constant(0u), r0E20), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0E53 = less(r0E44, body.constant(int(64)));
                        ir_if *f0E52 = new(mem_ctx) ir_if(operand(r0E53).val);
                        exec_list *const f0E52_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0E52->then_instructions;

                           body.emit(assign(r0E45, lshift(r0E1F, r0E48), 0x01));

                           ir_expression *const r0E54 = bit_and(r0E44, body.constant(int(31)));
                           body.emit(assign(r0E46, rshift(r0E1F, r0E54), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0E52->else_instructions;

                           ir_variable *const r0E55 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0E57 = equal(r0E44, body.constant(int(64)));
                           ir_if *f0E56 = new(mem_ctx) ir_if(operand(r0E57).val);
                           exec_list *const f0E56_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0E56->then_instructions;

                              body.emit(assign(r0E55, r0E1F, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0E56->else_instructions;

                              ir_expression *const r0E58 = nequal(r0E1F, body.constant(0u));
                              ir_expression *const r0E59 = expr(ir_unop_b2i, r0E58);
                              body.emit(assign(r0E55, expr(ir_unop_i2u, r0E59), 0x01));


                           body.instructions = f0E56_parent_instructions;
                           body.emit(f0E56);

                           /* END IF */

                           body.emit(assign(r0E45, r0E55, 0x01));

                           body.emit(assign(r0E46, body.constant(0u), 0x01));


                        body.instructions = f0E52_parent_instructions;
                        body.emit(f0E52);

                        /* END IF */


                     body.instructions = f0E50_parent_instructions;
                     body.emit(f0E50);

                     /* END IF */

                     body.emit(assign(r0E47, body.constant(0u), 0x01));


                  body.instructions = f0E4C_parent_instructions;
                  body.emit(f0E4C);

                  /* END IF */

                  ir_expression *const r0E5A = nequal(r0E43, body.constant(0u));
                  ir_expression *const r0E5B = expr(ir_unop_b2i, r0E5A);
                  ir_expression *const r0E5C = expr(ir_unop_i2u, r0E5B);
                  body.emit(assign(r0E45, bit_or(r0E45, r0E5C), 0x01));


               body.instructions = f0E4A_parent_instructions;
               body.emit(f0E4A);

               /* END IF */

               body.emit(assign(r0E1F, r0E47, 0x01));

               body.emit(assign(r0E20, r0E46, 0x01));

               body.emit(assign(r0E21, r0E45, 0x01));


            body.instructions = f0E39_parent_instructions;
            body.emit(f0E39);

            /* END IF */

            body.emit(assign(r0E1E, sub(r0E1E, r0E22), 0x01));

            ir_variable *const r0E5D = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0E5D, r0E1E, 0x01));

            ir_variable *const r0E5E = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0E5E, r0E1F, 0x01));

            ir_variable *const r0E5F = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0E5F, r0E20, 0x01));

            ir_variable *const r0E60 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r0E60, r0E21, 0x01));

            ir_variable *const r0E61 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r0E61, body.constant(true), 0x01));

            ir_variable *const r0E62 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0E63 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r0E63);
            ir_expression *const r0E64 = expr(ir_unop_u2i, r0E21);
            body.emit(assign(r0E63, less(r0E64, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0E66 = lequal(body.constant(int(2045)), r0E1E);
            ir_if *f0E65 = new(mem_ctx) ir_if(operand(r0E66).val);
            exec_list *const f0E65_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0E65->then_instructions;

               ir_variable *const r0E67 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0E69 = less(body.constant(int(2045)), r0E1E);
               ir_if *f0E68 = new(mem_ctx) ir_if(operand(r0E69).val);
               exec_list *const f0E68_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E68->then_instructions;

                  body.emit(assign(r0E67, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0E68->else_instructions;

                  ir_variable *const r0E6A = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0E6C = equal(r0E1E, body.constant(int(2045)));
                  ir_if *f0E6B = new(mem_ctx) ir_if(operand(r0E6C).val);
                  exec_list *const f0E6B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0E6B->then_instructions;

                     ir_expression *const r0E6D = equal(body.constant(2097151u), r0E1F);
                     ir_expression *const r0E6E = equal(body.constant(4294967295u), r0E20);
                     body.emit(assign(r0E6A, logic_and(r0E6D, r0E6E), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0E6B->else_instructions;

                     body.emit(assign(r0E6A, body.constant(false), 0x01));


                  body.instructions = f0E6B_parent_instructions;
                  body.emit(f0E6B);

                  /* END IF */

                  body.emit(assign(r0E67, logic_and(r0E6A, r0E63), 0x01));


               body.instructions = f0E68_parent_instructions;
               body.emit(f0E68);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0E6F = new(mem_ctx) ir_if(operand(r0E67).val);
               exec_list *const f0E6F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E6F->then_instructions;

                  ir_variable *const r0E70 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0E70);
                  ir_expression *const r0E71 = lshift(r0DB4, body.constant(int(31)));
                  body.emit(assign(r0E70, add(r0E71, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0E70, body.constant(0u), 0x01));

                  body.emit(assign(r0E62, r0E70, 0x03));

                  body.emit(assign(r0E61, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0E6F->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0E73 = less(r0E1E, body.constant(int(0)));
                  ir_if *f0E72 = new(mem_ctx) ir_if(operand(r0E73).val);
                  exec_list *const f0E72_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0E72->then_instructions;

                     ir_variable *const r0E74 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0E74, r0E21, 0x01));

                     ir_variable *const r0E75 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0E75, neg(r0E1E), 0x01));

                     ir_variable *const r0E76 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0E76);
                     ir_variable *const r0E77 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0E77);
                     ir_variable *const r0E78 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0E78);
                     ir_variable *const r0E79 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0E7A = neg(r0E75);
                     body.emit(assign(r0E79, bit_and(r0E7A, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0E7C = equal(r0E75, body.constant(int(0)));
                     ir_if *f0E7B = new(mem_ctx) ir_if(operand(r0E7C).val);
                     exec_list *const f0E7B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0E7B->then_instructions;

                        body.emit(assign(r0E76, r0E21, 0x01));

                        body.emit(assign(r0E77, r0E20, 0x01));

                        body.emit(assign(r0E78, r0E1F, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0E7B->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0E7E = less(r0E75, body.constant(int(32)));
                        ir_if *f0E7D = new(mem_ctx) ir_if(operand(r0E7E).val);
                        exec_list *const f0E7D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0E7D->then_instructions;

                           body.emit(assign(r0E76, lshift(r0E20, r0E79), 0x01));

                           ir_expression *const r0E7F = lshift(r0E1F, r0E79);
                           ir_expression *const r0E80 = rshift(r0E20, r0E75);
                           body.emit(assign(r0E77, bit_or(r0E7F, r0E80), 0x01));

                           body.emit(assign(r0E78, rshift(r0E1F, r0E75), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0E7D->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0E82 = equal(r0E75, body.constant(int(32)));
                           ir_if *f0E81 = new(mem_ctx) ir_if(operand(r0E82).val);
                           exec_list *const f0E81_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0E81->then_instructions;

                              body.emit(assign(r0E76, r0E20, 0x01));

                              body.emit(assign(r0E77, r0E1F, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0E81->else_instructions;

                              body.emit(assign(r0E74, bit_or(r0E21, r0E20), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0E84 = less(r0E75, body.constant(int(64)));
                              ir_if *f0E83 = new(mem_ctx) ir_if(operand(r0E84).val);
                              exec_list *const f0E83_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0E83->then_instructions;

                                 body.emit(assign(r0E76, lshift(r0E1F, r0E79), 0x01));

                                 ir_expression *const r0E85 = bit_and(r0E75, body.constant(int(31)));
                                 body.emit(assign(r0E77, rshift(r0E1F, r0E85), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0E83->else_instructions;

                                 ir_variable *const r0E86 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0E88 = equal(r0E75, body.constant(int(64)));
                                 ir_if *f0E87 = new(mem_ctx) ir_if(operand(r0E88).val);
                                 exec_list *const f0E87_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0E87->then_instructions;

                                    body.emit(assign(r0E86, r0E1F, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0E87->else_instructions;

                                    ir_expression *const r0E89 = nequal(r0E1F, body.constant(0u));
                                    ir_expression *const r0E8A = expr(ir_unop_b2i, r0E89);
                                    body.emit(assign(r0E86, expr(ir_unop_i2u, r0E8A), 0x01));


                                 body.instructions = f0E87_parent_instructions;
                                 body.emit(f0E87);

                                 /* END IF */

                                 body.emit(assign(r0E76, r0E86, 0x01));

                                 body.emit(assign(r0E77, body.constant(0u), 0x01));


                              body.instructions = f0E83_parent_instructions;
                              body.emit(f0E83);

                              /* END IF */


                           body.instructions = f0E81_parent_instructions;
                           body.emit(f0E81);

                           /* END IF */

                           body.emit(assign(r0E78, body.constant(0u), 0x01));


                        body.instructions = f0E7D_parent_instructions;
                        body.emit(f0E7D);

                        /* END IF */

                        ir_expression *const r0E8B = nequal(r0E74, body.constant(0u));
                        ir_expression *const r0E8C = expr(ir_unop_b2i, r0E8B);
                        ir_expression *const r0E8D = expr(ir_unop_i2u, r0E8C);
                        body.emit(assign(r0E76, bit_or(r0E76, r0E8D), 0x01));


                     body.instructions = f0E7B_parent_instructions;
                     body.emit(f0E7B);

                     /* END IF */

                     body.emit(assign(r0E5E, r0E78, 0x01));

                     body.emit(assign(r0E5F, r0E77, 0x01));

                     body.emit(assign(r0E60, r0E76, 0x01));

                     body.emit(assign(r0E5D, body.constant(int(0)), 0x01));

                     body.emit(assign(r0E63, less(r0E76, body.constant(0u)), 0x01));


                  body.instructions = f0E72_parent_instructions;
                  body.emit(f0E72);

                  /* END IF */


               body.instructions = f0E6F_parent_instructions;
               body.emit(f0E6F);

               /* END IF */


            body.instructions = f0E65_parent_instructions;
            body.emit(f0E65);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0E8E = new(mem_ctx) ir_if(operand(r0E61).val);
            exec_list *const f0E8E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0E8E->then_instructions;

               /* IF CONDITION */
               ir_if *f0E8F = new(mem_ctx) ir_if(operand(r0E63).val);
               exec_list *const f0E8F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E8F->then_instructions;

                  ir_variable *const r0E90 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r0E90, add(r0E5F, body.constant(1u)), 0x01));

                  ir_expression *const r0E91 = less(r0E90, r0E5F);
                  ir_expression *const r0E92 = expr(ir_unop_b2i, r0E91);
                  ir_expression *const r0E93 = expr(ir_unop_i2u, r0E92);
                  body.emit(assign(r0E5E, add(r0E5E, r0E93), 0x01));

                  ir_expression *const r0E94 = equal(r0E60, body.constant(0u));
                  ir_expression *const r0E95 = expr(ir_unop_b2i, r0E94);
                  ir_expression *const r0E96 = expr(ir_unop_i2u, r0E95);
                  ir_expression *const r0E97 = add(r0E60, r0E96);
                  ir_expression *const r0E98 = bit_and(r0E97, body.constant(1u));
                  ir_expression *const r0E99 = expr(ir_unop_bit_not, r0E98);
                  body.emit(assign(r0E5F, bit_and(r0E90, r0E99), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0E8F->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0E9B = bit_or(r0E5E, r0E5F);
                  ir_expression *const r0E9C = equal(r0E9B, body.constant(0u));
                  ir_if *f0E9A = new(mem_ctx) ir_if(operand(r0E9C).val);
                  exec_list *const f0E9A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0E9A->then_instructions;

                     body.emit(assign(r0E5D, body.constant(int(0)), 0x01));


                  body.instructions = f0E9A_parent_instructions;
                  body.emit(f0E9A);

                  /* END IF */


               body.instructions = f0E8F_parent_instructions;
               body.emit(f0E8F);

               /* END IF */

               ir_variable *const r0E9D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0E9D);
               ir_expression *const r0E9E = lshift(r0DB4, body.constant(int(31)));
               ir_expression *const r0E9F = expr(ir_unop_i2u, r0E5D);
               ir_expression *const r0EA0 = lshift(r0E9F, body.constant(int(20)));
               ir_expression *const r0EA1 = add(r0E9E, r0EA0);
               body.emit(assign(r0E9D, add(r0EA1, r0E5E), 0x02));

               body.emit(assign(r0E9D, r0E5F, 0x01));

               body.emit(assign(r0E62, r0E9D, 0x03));

               body.emit(assign(r0E61, body.constant(false), 0x01));


            body.instructions = f0E8E_parent_instructions;
            body.emit(f0E8E);

            /* END IF */

            body.emit(assign(r0DB9, r0E62, 0x03));


         body.instructions = f0DD2_parent_instructions;
         body.emit(f0DD2);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0DD0->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0EA3 = less(r0DBA, body.constant(int(0)));
         ir_if *f0EA2 = new(mem_ctx) ir_if(operand(r0EA3).val);
         exec_list *const f0EA2_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0EA2->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0EA5 = equal(r0DC5, body.constant(int(2047)));
            ir_if *f0EA4 = new(mem_ctx) ir_if(operand(r0EA5).val);
            exec_list *const f0EA4_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0EA4->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0EA7 = bit_or(swizzle_y(r0DBC), swizzle_x(r0DBC));
               ir_expression *const r0EA8 = nequal(r0EA7, body.constant(0u));
               ir_if *f0EA6 = new(mem_ctx) ir_if(operand(r0EA8).val);
               exec_list *const f0EA6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0EA6->then_instructions;

                  ir_variable *const r0EA9 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r0EA9, swizzle_x(r0DB1), 0x01));

                  ir_variable *const r0EAA = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r0EAA, swizzle_x(r0DB2), 0x01));

                  ir_variable *const r0EAB = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0EAC = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0EAD = rshift(swizzle_y(r0DB1), body.constant(int(19)));
                  ir_expression *const r0EAE = bit_and(r0EAD, body.constant(4095u));
                  ir_expression *const r0EAF = equal(r0EAE, body.constant(4094u));
                  ir_expression *const r0EB0 = nequal(swizzle_x(r0DB1), body.constant(0u));
                  ir_expression *const r0EB1 = bit_and(swizzle_y(r0DB1), body.constant(524287u));
                  ir_expression *const r0EB2 = nequal(r0EB1, body.constant(0u));
                  ir_expression *const r0EB3 = logic_or(r0EB0, r0EB2);
                  body.emit(assign(r0EAC, logic_and(r0EAF, r0EB3), 0x01));

                  ir_variable *const r0EB4 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0EB5 = lshift(swizzle_y(r0DB2), body.constant(int(1)));
                  ir_expression *const r0EB6 = lequal(body.constant(4292870144u), r0EB5);
                  ir_expression *const r0EB7 = nequal(swizzle_x(r0DB2), body.constant(0u));
                  ir_expression *const r0EB8 = bit_and(swizzle_y(r0DB2), body.constant(1048575u));
                  ir_expression *const r0EB9 = nequal(r0EB8, body.constant(0u));
                  ir_expression *const r0EBA = logic_or(r0EB7, r0EB9);
                  body.emit(assign(r0EB4, logic_and(r0EB6, r0EBA), 0x01));

                  body.emit(assign(r0EA9, bit_or(swizzle_y(r0DB1), body.constant(524288u)), 0x02));

                  body.emit(assign(r0EAA, bit_or(swizzle_y(r0DB2), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r0EBC = lshift(swizzle_y(r0DB1), body.constant(int(1)));
                  ir_expression *const r0EBD = lequal(body.constant(4292870144u), r0EBC);
                  ir_expression *const r0EBE = nequal(swizzle_x(r0DB1), body.constant(0u));
                  ir_expression *const r0EBF = bit_and(swizzle_y(r0DB1), body.constant(1048575u));
                  ir_expression *const r0EC0 = nequal(r0EBF, body.constant(0u));
                  ir_expression *const r0EC1 = logic_or(r0EBE, r0EC0);
                  ir_expression *const r0EC2 = logic_and(r0EBD, r0EC1);
                  ir_if *f0EBB = new(mem_ctx) ir_if(operand(r0EC2).val);
                  exec_list *const f0EBB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0EBB->then_instructions;

                     ir_variable *const r0EC3 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0EC5 = logic_and(r0EAC, r0EB4);
                     ir_if *f0EC4 = new(mem_ctx) ir_if(operand(r0EC5).val);
                     exec_list *const f0EC4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0EC4->then_instructions;

                        body.emit(assign(r0EC3, r0EAA, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0EC4->else_instructions;

                        body.emit(assign(r0EC3, r0EA9, 0x03));


                     body.instructions = f0EC4_parent_instructions;
                     body.emit(f0EC4);

                     /* END IF */

                     body.emit(assign(r0EAB, r0EC3, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0EBB->else_instructions;

                     body.emit(assign(r0EAB, r0EAA, 0x03));


                  body.instructions = f0EBB_parent_instructions;
                  body.emit(f0EBB);

                  /* END IF */

                  body.emit(assign(r0DB9, r0EAB, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0EA6->else_instructions;

                  ir_variable *const r0EC6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0EC6);
                  ir_expression *const r0EC7 = bit_xor(r0DB4, body.constant(1u));
                  ir_expression *const r0EC8 = lshift(r0EC7, body.constant(int(31)));
                  body.emit(assign(r0EC6, add(r0EC8, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0EC6, body.constant(0u), 0x01));

                  body.emit(assign(r0DB9, r0EC6, 0x03));


               body.instructions = f0EA6_parent_instructions;
               body.emit(f0EA6);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0EA4->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0ECA = equal(r0DC1, body.constant(int(0)));
               ir_if *f0EC9 = new(mem_ctx) ir_if(operand(r0ECA).val);
               exec_list *const f0EC9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0EC9->then_instructions;

                  body.emit(assign(r0DBA, add(r0DBA, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0EC9->else_instructions;

                  body.emit(assign(r0DBE, bit_or(swizzle_y(r0DBE), body.constant(1073741824u)), 0x02));


               body.instructions = f0EC9_parent_instructions;
               body.emit(f0EC9);

               /* END IF */

               ir_variable *const r0ECB = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r0ECB, swizzle_y(r0DBE), 0x01));

               ir_variable *const r0ECC = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r0ECC, swizzle_x(r0DBE), 0x01));

               ir_variable *const r0ECD = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0ECD, neg(r0DBA), 0x01));

               ir_variable *const r0ECE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0ECE);
               ir_variable *const r0ECF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0ECF);
               ir_variable *const r0ED0 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0ED1 = neg(r0ECD);
               body.emit(assign(r0ED0, bit_and(r0ED1, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0ED3 = equal(r0ECD, body.constant(int(0)));
               ir_if *f0ED2 = new(mem_ctx) ir_if(operand(r0ED3).val);
               exec_list *const f0ED2_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0ED2->then_instructions;

                  body.emit(assign(r0ECE, r0ECC, 0x01));

                  body.emit(assign(r0ECF, r0ECB, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0ED2->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0ED5 = less(r0ECD, body.constant(int(32)));
                  ir_if *f0ED4 = new(mem_ctx) ir_if(operand(r0ED5).val);
                  exec_list *const f0ED4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0ED4->then_instructions;

                     ir_expression *const r0ED6 = lshift(swizzle_y(r0DBE), r0ED0);
                     ir_expression *const r0ED7 = rshift(r0DC8, r0ECD);
                     ir_expression *const r0ED8 = bit_or(r0ED6, r0ED7);
                     ir_expression *const r0ED9 = lshift(r0DC8, r0ED0);
                     ir_expression *const r0EDA = nequal(r0ED9, body.constant(0u));
                     ir_expression *const r0EDB = expr(ir_unop_b2i, r0EDA);
                     ir_expression *const r0EDC = expr(ir_unop_i2u, r0EDB);
                     body.emit(assign(r0ECE, bit_or(r0ED8, r0EDC), 0x01));

                     body.emit(assign(r0ECF, rshift(swizzle_y(r0DBE), r0ECD), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0ED4->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0EDE = equal(r0ECD, body.constant(int(32)));
                     ir_if *f0EDD = new(mem_ctx) ir_if(operand(r0EDE).val);
                     exec_list *const f0EDD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0EDD->then_instructions;

                        ir_expression *const r0EDF = nequal(r0DC8, body.constant(0u));
                        ir_expression *const r0EE0 = expr(ir_unop_b2i, r0EDF);
                        ir_expression *const r0EE1 = expr(ir_unop_i2u, r0EE0);
                        body.emit(assign(r0ECE, bit_or(swizzle_y(r0DBE), r0EE1), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0EDD->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0EE3 = less(r0ECD, body.constant(int(64)));
                        ir_if *f0EE2 = new(mem_ctx) ir_if(operand(r0EE3).val);
                        exec_list *const f0EE2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0EE2->then_instructions;

                           ir_expression *const r0EE4 = bit_and(r0ECD, body.constant(int(31)));
                           ir_expression *const r0EE5 = rshift(swizzle_y(r0DBE), r0EE4);
                           ir_expression *const r0EE6 = lshift(swizzle_y(r0DBE), r0ED0);
                           ir_expression *const r0EE7 = bit_or(r0EE6, r0DC8);
                           ir_expression *const r0EE8 = nequal(r0EE7, body.constant(0u));
                           ir_expression *const r0EE9 = expr(ir_unop_b2i, r0EE8);
                           ir_expression *const r0EEA = expr(ir_unop_i2u, r0EE9);
                           body.emit(assign(r0ECE, bit_or(r0EE5, r0EEA), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0EE2->else_instructions;

                           ir_expression *const r0EEB = bit_or(swizzle_y(r0DBE), r0DC8);
                           ir_expression *const r0EEC = nequal(r0EEB, body.constant(0u));
                           ir_expression *const r0EED = expr(ir_unop_b2i, r0EEC);
                           body.emit(assign(r0ECE, expr(ir_unop_i2u, r0EED), 0x01));


                        body.instructions = f0EE2_parent_instructions;
                        body.emit(f0EE2);

                        /* END IF */


                     body.instructions = f0EDD_parent_instructions;
                     body.emit(f0EDD);

                     /* END IF */

                     body.emit(assign(r0ECF, body.constant(0u), 0x01));


                  body.instructions = f0ED4_parent_instructions;
                  body.emit(f0ED4);

                  /* END IF */


               body.instructions = f0ED2_parent_instructions;
               body.emit(f0ED2);

               /* END IF */

               body.emit(assign(r0DBE, r0ECF, 0x02));

               body.emit(assign(r0DBE, r0ECE, 0x01));

               body.emit(assign(r0DBC, bit_or(swizzle_y(r0DBC), body.constant(1073741824u)), 0x02));

               ir_variable *const r0EEE = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r0EEF = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r0EEF, sub(swizzle_x(r0DBC), r0ECE), 0x01));

               ir_expression *const r0EF0 = sub(swizzle_y(r0DBC), r0ECF);
               ir_expression *const r0EF1 = less(swizzle_x(r0DBC), r0ECE);
               ir_expression *const r0EF2 = expr(ir_unop_b2i, r0EF1);
               ir_expression *const r0EF3 = expr(ir_unop_i2u, r0EF2);
               body.emit(assign(r0EEE, sub(r0EF0, r0EF3), 0x01));

               body.emit(assign(r0DB8, bit_xor(r0DB4, body.constant(1u)), 0x01));

               body.emit(assign(r0DBF, add(r0DC5, body.constant(int(-1))), 0x01));

               ir_variable *const r0EF4 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r0EF4, add(r0DBF, body.constant(int(-10))), 0x01));

               ir_variable *const r0EF5 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0EF5, r0EEE, 0x01));

               ir_variable *const r0EF6 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0EF6, r0EEF, 0x01));

               ir_variable *const r0EF7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r0EF7);
               ir_variable *const r0EF8 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r0EF8);
               /* IF CONDITION */
               ir_expression *const r0EFA = equal(r0EEE, body.constant(0u));
               ir_if *f0EF9 = new(mem_ctx) ir_if(operand(r0EFA).val);
               exec_list *const f0EF9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0EF9->then_instructions;

                  body.emit(assign(r0EF5, r0EEF, 0x01));

                  body.emit(assign(r0EF6, body.constant(0u), 0x01));

                  body.emit(assign(r0EF4, add(r0EF4, body.constant(int(-32))), 0x01));


               body.instructions = f0EF9_parent_instructions;
               body.emit(f0EF9);

               /* END IF */

               ir_variable *const r0EFB = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r0EFB, r0EF5, 0x01));

               ir_variable *const r0EFC = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r0EFD = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r0EFD);
               /* IF CONDITION */
               ir_expression *const r0EFF = equal(r0EF5, body.constant(0u));
               ir_if *f0EFE = new(mem_ctx) ir_if(operand(r0EFF).val);
               exec_list *const f0EFE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0EFE->then_instructions;

                  body.emit(assign(r0EFC, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0EFE->else_instructions;

                  body.emit(assign(r0EFD, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0F01 = bit_and(r0EF5, body.constant(4294901760u));
                  ir_expression *const r0F02 = equal(r0F01, body.constant(0u));
                  ir_if *f0F00 = new(mem_ctx) ir_if(operand(r0F02).val);
                  exec_list *const f0F00_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F00->then_instructions;

                     body.emit(assign(r0EFD, body.constant(int(16)), 0x01));

                     body.emit(assign(r0EFB, lshift(r0EF5, body.constant(int(16))), 0x01));


                  body.instructions = f0F00_parent_instructions;
                  body.emit(f0F00);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0F04 = bit_and(r0EFB, body.constant(4278190080u));
                  ir_expression *const r0F05 = equal(r0F04, body.constant(0u));
                  ir_if *f0F03 = new(mem_ctx) ir_if(operand(r0F05).val);
                  exec_list *const f0F03_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F03->then_instructions;

                     body.emit(assign(r0EFD, add(r0EFD, body.constant(int(8))), 0x01));

                     body.emit(assign(r0EFB, lshift(r0EFB, body.constant(int(8))), 0x01));


                  body.instructions = f0F03_parent_instructions;
                  body.emit(f0F03);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0F07 = bit_and(r0EFB, body.constant(4026531840u));
                  ir_expression *const r0F08 = equal(r0F07, body.constant(0u));
                  ir_if *f0F06 = new(mem_ctx) ir_if(operand(r0F08).val);
                  exec_list *const f0F06_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F06->then_instructions;

                     body.emit(assign(r0EFD, add(r0EFD, body.constant(int(4))), 0x01));

                     body.emit(assign(r0EFB, lshift(r0EFB, body.constant(int(4))), 0x01));


                  body.instructions = f0F06_parent_instructions;
                  body.emit(f0F06);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0F0A = bit_and(r0EFB, body.constant(3221225472u));
                  ir_expression *const r0F0B = equal(r0F0A, body.constant(0u));
                  ir_if *f0F09 = new(mem_ctx) ir_if(operand(r0F0B).val);
                  exec_list *const f0F09_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F09->then_instructions;

                     body.emit(assign(r0EFD, add(r0EFD, body.constant(int(2))), 0x01));

                     body.emit(assign(r0EFB, lshift(r0EFB, body.constant(int(2))), 0x01));


                  body.instructions = f0F09_parent_instructions;
                  body.emit(f0F09);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0F0D = bit_and(r0EFB, body.constant(2147483648u));
                  ir_expression *const r0F0E = equal(r0F0D, body.constant(0u));
                  ir_if *f0F0C = new(mem_ctx) ir_if(operand(r0F0E).val);
                  exec_list *const f0F0C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F0C->then_instructions;

                     body.emit(assign(r0EFD, add(r0EFD, body.constant(int(1))), 0x01));


                  body.instructions = f0F0C_parent_instructions;
                  body.emit(f0F0C);

                  /* END IF */

                  body.emit(assign(r0EFC, r0EFD, 0x01));


               body.instructions = f0EFE_parent_instructions;
               body.emit(f0EFE);

               /* END IF */

               body.emit(assign(r0EF8, add(r0EFC, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0F10 = lequal(body.constant(int(0)), r0EF8);
               ir_if *f0F0F = new(mem_ctx) ir_if(operand(r0F10).val);
               exec_list *const f0F0F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F0F->then_instructions;

                  body.emit(assign(r0EF7, body.constant(0u), 0x01));

                  ir_variable *const r0F11 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0F11, lshift(r0EF6, r0EF8), 0x01));

                  ir_variable *const r0F12 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0F14 = equal(r0EF8, body.constant(int(0)));
                  ir_if *f0F13 = new(mem_ctx) ir_if(operand(r0F14).val);
                  exec_list *const f0F13_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F13->then_instructions;

                     body.emit(assign(r0F12, r0EF5, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F13->else_instructions;

                     ir_expression *const r0F15 = lshift(r0EF5, r0EF8);
                     ir_expression *const r0F16 = neg(r0EF8);
                     ir_expression *const r0F17 = bit_and(r0F16, body.constant(int(31)));
                     ir_expression *const r0F18 = rshift(r0EF6, r0F17);
                     body.emit(assign(r0F12, bit_or(r0F15, r0F18), 0x01));


                  body.instructions = f0F13_parent_instructions;
                  body.emit(f0F13);

                  /* END IF */

                  body.emit(assign(r0EF5, r0F12, 0x01));

                  body.emit(assign(r0EF6, r0F11, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0F0F->else_instructions;

                  ir_variable *const r0F19 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r0F19, body.constant(0u), 0x01));

                  ir_variable *const r0F1A = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r0F1A, neg(r0EF8), 0x01));

                  ir_variable *const r0F1B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r0F1B);
                  ir_variable *const r0F1C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r0F1C);
                  ir_variable *const r0F1D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r0F1D);
                  ir_variable *const r0F1E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r0F1F = neg(r0F1A);
                  body.emit(assign(r0F1E, bit_and(r0F1F, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0F21 = equal(r0F1A, body.constant(int(0)));
                  ir_if *f0F20 = new(mem_ctx) ir_if(operand(r0F21).val);
                  exec_list *const f0F20_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F20->then_instructions;

                     body.emit(assign(r0F1B, r0F19, 0x01));

                     body.emit(assign(r0F1C, r0EF6, 0x01));

                     body.emit(assign(r0F1D, r0EF5, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F20->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0F23 = less(r0F1A, body.constant(int(32)));
                     ir_if *f0F22 = new(mem_ctx) ir_if(operand(r0F23).val);
                     exec_list *const f0F22_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F22->then_instructions;

                        body.emit(assign(r0F1B, lshift(r0EF6, r0F1E), 0x01));

                        ir_expression *const r0F24 = lshift(r0EF5, r0F1E);
                        ir_expression *const r0F25 = rshift(r0EF6, r0F1A);
                        body.emit(assign(r0F1C, bit_or(r0F24, r0F25), 0x01));

                        body.emit(assign(r0F1D, rshift(r0EF5, r0F1A), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0F22->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0F27 = equal(r0F1A, body.constant(int(32)));
                        ir_if *f0F26 = new(mem_ctx) ir_if(operand(r0F27).val);
                        exec_list *const f0F26_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F26->then_instructions;

                           body.emit(assign(r0F1B, r0EF6, 0x01));

                           body.emit(assign(r0F1C, r0EF5, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0F26->else_instructions;

                           body.emit(assign(r0F19, bit_or(body.constant(0u), r0EF6), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0F29 = less(r0F1A, body.constant(int(64)));
                           ir_if *f0F28 = new(mem_ctx) ir_if(operand(r0F29).val);
                           exec_list *const f0F28_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0F28->then_instructions;

                              body.emit(assign(r0F1B, lshift(r0EF5, r0F1E), 0x01));

                              ir_expression *const r0F2A = bit_and(r0F1A, body.constant(int(31)));
                              body.emit(assign(r0F1C, rshift(r0EF5, r0F2A), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0F28->else_instructions;

                              ir_variable *const r0F2B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0F2D = equal(r0F1A, body.constant(int(64)));
                              ir_if *f0F2C = new(mem_ctx) ir_if(operand(r0F2D).val);
                              exec_list *const f0F2C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0F2C->then_instructions;

                                 body.emit(assign(r0F2B, r0EF5, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0F2C->else_instructions;

                                 ir_expression *const r0F2E = nequal(r0EF5, body.constant(0u));
                                 ir_expression *const r0F2F = expr(ir_unop_b2i, r0F2E);
                                 body.emit(assign(r0F2B, expr(ir_unop_i2u, r0F2F), 0x01));


                              body.instructions = f0F2C_parent_instructions;
                              body.emit(f0F2C);

                              /* END IF */

                              body.emit(assign(r0F1B, r0F2B, 0x01));

                              body.emit(assign(r0F1C, body.constant(0u), 0x01));


                           body.instructions = f0F28_parent_instructions;
                           body.emit(f0F28);

                           /* END IF */


                        body.instructions = f0F26_parent_instructions;
                        body.emit(f0F26);

                        /* END IF */

                        body.emit(assign(r0F1D, body.constant(0u), 0x01));


                     body.instructions = f0F22_parent_instructions;
                     body.emit(f0F22);

                     /* END IF */

                     ir_expression *const r0F30 = nequal(r0F19, body.constant(0u));
                     ir_expression *const r0F31 = expr(ir_unop_b2i, r0F30);
                     ir_expression *const r0F32 = expr(ir_unop_i2u, r0F31);
                     body.emit(assign(r0F1B, bit_or(r0F1B, r0F32), 0x01));


                  body.instructions = f0F20_parent_instructions;
                  body.emit(f0F20);

                  /* END IF */

                  body.emit(assign(r0EF5, r0F1D, 0x01));

                  body.emit(assign(r0EF6, r0F1C, 0x01));

                  body.emit(assign(r0EF7, r0F1B, 0x01));


               body.instructions = f0F0F_parent_instructions;
               body.emit(f0F0F);

               /* END IF */

               body.emit(assign(r0EF4, sub(r0EF4, r0EF8), 0x01));

               ir_variable *const r0F33 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r0F33, r0EF4, 0x01));

               ir_variable *const r0F34 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0F34, r0EF5, 0x01));

               ir_variable *const r0F35 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0F35, r0EF6, 0x01));

               ir_variable *const r0F36 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r0F36, r0EF7, 0x01));

               ir_variable *const r0F37 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r0F37, body.constant(true), 0x01));

               ir_variable *const r0F38 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0F39 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r0F39);
               ir_expression *const r0F3A = expr(ir_unop_u2i, r0EF7);
               body.emit(assign(r0F39, less(r0F3A, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0F3C = lequal(body.constant(int(2045)), r0EF4);
               ir_if *f0F3B = new(mem_ctx) ir_if(operand(r0F3C).val);
               exec_list *const f0F3B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F3B->then_instructions;

                  ir_variable *const r0F3D = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0F3F = less(body.constant(int(2045)), r0EF4);
                  ir_if *f0F3E = new(mem_ctx) ir_if(operand(r0F3F).val);
                  exec_list *const f0F3E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F3E->then_instructions;

                     body.emit(assign(r0F3D, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F3E->else_instructions;

                     ir_variable *const r0F40 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0F42 = equal(r0EF4, body.constant(int(2045)));
                     ir_if *f0F41 = new(mem_ctx) ir_if(operand(r0F42).val);
                     exec_list *const f0F41_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F41->then_instructions;

                        ir_expression *const r0F43 = equal(body.constant(2097151u), r0EF5);
                        ir_expression *const r0F44 = equal(body.constant(4294967295u), r0EF6);
                        body.emit(assign(r0F40, logic_and(r0F43, r0F44), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0F41->else_instructions;

                        body.emit(assign(r0F40, body.constant(false), 0x01));


                     body.instructions = f0F41_parent_instructions;
                     body.emit(f0F41);

                     /* END IF */

                     body.emit(assign(r0F3D, logic_and(r0F40, r0F39), 0x01));


                  body.instructions = f0F3E_parent_instructions;
                  body.emit(f0F3E);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0F45 = new(mem_ctx) ir_if(operand(r0F3D).val);
                  exec_list *const f0F45_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F45->then_instructions;

                     ir_variable *const r0F46 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0F46);
                     ir_expression *const r0F47 = lshift(r0DB8, body.constant(int(31)));
                     body.emit(assign(r0F46, add(r0F47, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r0F46, body.constant(0u), 0x01));

                     body.emit(assign(r0F38, r0F46, 0x03));

                     body.emit(assign(r0F37, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F45->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0F49 = less(r0EF4, body.constant(int(0)));
                     ir_if *f0F48 = new(mem_ctx) ir_if(operand(r0F49).val);
                     exec_list *const f0F48_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F48->then_instructions;

                        ir_variable *const r0F4A = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0F4A, r0EF7, 0x01));

                        ir_variable *const r0F4B = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0F4B, neg(r0EF4), 0x01));

                        ir_variable *const r0F4C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0F4C);
                        ir_variable *const r0F4D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0F4D);
                        ir_variable *const r0F4E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0F4E);
                        ir_variable *const r0F4F = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r0F50 = neg(r0F4B);
                        body.emit(assign(r0F4F, bit_and(r0F50, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0F52 = equal(r0F4B, body.constant(int(0)));
                        ir_if *f0F51 = new(mem_ctx) ir_if(operand(r0F52).val);
                        exec_list *const f0F51_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F51->then_instructions;

                           body.emit(assign(r0F4C, r0EF7, 0x01));

                           body.emit(assign(r0F4D, r0EF6, 0x01));

                           body.emit(assign(r0F4E, r0EF5, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0F51->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0F54 = less(r0F4B, body.constant(int(32)));
                           ir_if *f0F53 = new(mem_ctx) ir_if(operand(r0F54).val);
                           exec_list *const f0F53_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0F53->then_instructions;

                              body.emit(assign(r0F4C, lshift(r0EF6, r0F4F), 0x01));

                              ir_expression *const r0F55 = lshift(r0EF5, r0F4F);
                              ir_expression *const r0F56 = rshift(r0EF6, r0F4B);
                              body.emit(assign(r0F4D, bit_or(r0F55, r0F56), 0x01));

                              body.emit(assign(r0F4E, rshift(r0EF5, r0F4B), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0F53->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0F58 = equal(r0F4B, body.constant(int(32)));
                              ir_if *f0F57 = new(mem_ctx) ir_if(operand(r0F58).val);
                              exec_list *const f0F57_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0F57->then_instructions;

                                 body.emit(assign(r0F4C, r0EF6, 0x01));

                                 body.emit(assign(r0F4D, r0EF5, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0F57->else_instructions;

                                 body.emit(assign(r0F4A, bit_or(r0EF7, r0EF6), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0F5A = less(r0F4B, body.constant(int(64)));
                                 ir_if *f0F59 = new(mem_ctx) ir_if(operand(r0F5A).val);
                                 exec_list *const f0F59_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0F59->then_instructions;

                                    body.emit(assign(r0F4C, lshift(r0EF5, r0F4F), 0x01));

                                    ir_expression *const r0F5B = bit_and(r0F4B, body.constant(int(31)));
                                    body.emit(assign(r0F4D, rshift(r0EF5, r0F5B), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0F59->else_instructions;

                                    ir_variable *const r0F5C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r0F5E = equal(r0F4B, body.constant(int(64)));
                                    ir_if *f0F5D = new(mem_ctx) ir_if(operand(r0F5E).val);
                                    exec_list *const f0F5D_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0F5D->then_instructions;

                                       body.emit(assign(r0F5C, r0EF5, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0F5D->else_instructions;

                                       ir_expression *const r0F5F = nequal(r0EF5, body.constant(0u));
                                       ir_expression *const r0F60 = expr(ir_unop_b2i, r0F5F);
                                       body.emit(assign(r0F5C, expr(ir_unop_i2u, r0F60), 0x01));


                                    body.instructions = f0F5D_parent_instructions;
                                    body.emit(f0F5D);

                                    /* END IF */

                                    body.emit(assign(r0F4C, r0F5C, 0x01));

                                    body.emit(assign(r0F4D, body.constant(0u), 0x01));


                                 body.instructions = f0F59_parent_instructions;
                                 body.emit(f0F59);

                                 /* END IF */


                              body.instructions = f0F57_parent_instructions;
                              body.emit(f0F57);

                              /* END IF */

                              body.emit(assign(r0F4E, body.constant(0u), 0x01));


                           body.instructions = f0F53_parent_instructions;
                           body.emit(f0F53);

                           /* END IF */

                           ir_expression *const r0F61 = nequal(r0F4A, body.constant(0u));
                           ir_expression *const r0F62 = expr(ir_unop_b2i, r0F61);
                           ir_expression *const r0F63 = expr(ir_unop_i2u, r0F62);
                           body.emit(assign(r0F4C, bit_or(r0F4C, r0F63), 0x01));


                        body.instructions = f0F51_parent_instructions;
                        body.emit(f0F51);

                        /* END IF */

                        body.emit(assign(r0F34, r0F4E, 0x01));

                        body.emit(assign(r0F35, r0F4D, 0x01));

                        body.emit(assign(r0F36, r0F4C, 0x01));

                        body.emit(assign(r0F33, body.constant(int(0)), 0x01));

                        body.emit(assign(r0F39, less(r0F4C, body.constant(0u)), 0x01));


                     body.instructions = f0F48_parent_instructions;
                     body.emit(f0F48);

                     /* END IF */


                  body.instructions = f0F45_parent_instructions;
                  body.emit(f0F45);

                  /* END IF */


               body.instructions = f0F3B_parent_instructions;
               body.emit(f0F3B);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0F64 = new(mem_ctx) ir_if(operand(r0F37).val);
               exec_list *const f0F64_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F64->then_instructions;

                  /* IF CONDITION */
                  ir_if *f0F65 = new(mem_ctx) ir_if(operand(r0F39).val);
                  exec_list *const f0F65_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F65->then_instructions;

                     ir_variable *const r0F66 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r0F66, add(r0F35, body.constant(1u)), 0x01));

                     ir_expression *const r0F67 = less(r0F66, r0F35);
                     ir_expression *const r0F68 = expr(ir_unop_b2i, r0F67);
                     ir_expression *const r0F69 = expr(ir_unop_i2u, r0F68);
                     body.emit(assign(r0F34, add(r0F34, r0F69), 0x01));

                     ir_expression *const r0F6A = equal(r0F36, body.constant(0u));
                     ir_expression *const r0F6B = expr(ir_unop_b2i, r0F6A);
                     ir_expression *const r0F6C = expr(ir_unop_i2u, r0F6B);
                     ir_expression *const r0F6D = add(r0F36, r0F6C);
                     ir_expression *const r0F6E = bit_and(r0F6D, body.constant(1u));
                     ir_expression *const r0F6F = expr(ir_unop_bit_not, r0F6E);
                     body.emit(assign(r0F35, bit_and(r0F66, r0F6F), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F65->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0F71 = bit_or(r0F34, r0F35);
                     ir_expression *const r0F72 = equal(r0F71, body.constant(0u));
                     ir_if *f0F70 = new(mem_ctx) ir_if(operand(r0F72).val);
                     exec_list *const f0F70_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F70->then_instructions;

                        body.emit(assign(r0F33, body.constant(int(0)), 0x01));


                     body.instructions = f0F70_parent_instructions;
                     body.emit(f0F70);

                     /* END IF */


                  body.instructions = f0F65_parent_instructions;
                  body.emit(f0F65);

                  /* END IF */

                  ir_variable *const r0F73 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0F73);
                  ir_expression *const r0F74 = lshift(r0DB8, body.constant(int(31)));
                  ir_expression *const r0F75 = expr(ir_unop_i2u, r0F33);
                  ir_expression *const r0F76 = lshift(r0F75, body.constant(int(20)));
                  ir_expression *const r0F77 = add(r0F74, r0F76);
                  body.emit(assign(r0F73, add(r0F77, r0F34), 0x02));

                  body.emit(assign(r0F73, r0F35, 0x01));

                  body.emit(assign(r0F38, r0F73, 0x03));

                  body.emit(assign(r0F37, body.constant(false), 0x01));


               body.instructions = f0F64_parent_instructions;
               body.emit(f0F64);

               /* END IF */

               body.emit(assign(r0DB9, r0F38, 0x03));


            body.instructions = f0EA4_parent_instructions;
            body.emit(f0EA4);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0EA2->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0F79 = equal(r0DC1, body.constant(int(2047)));
            ir_if *f0F78 = new(mem_ctx) ir_if(operand(r0F79).val);
            exec_list *const f0F78_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0F78->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0F7B = bit_or(swizzle_y(r0DBE), swizzle_x(r0DBE));
               ir_expression *const r0F7C = bit_or(swizzle_y(r0DBC), swizzle_x(r0DBC));
               ir_expression *const r0F7D = bit_or(r0F7B, r0F7C);
               ir_expression *const r0F7E = nequal(r0F7D, body.constant(0u));
               ir_if *f0F7A = new(mem_ctx) ir_if(operand(r0F7E).val);
               exec_list *const f0F7A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F7A->then_instructions;

                  ir_variable *const r0F7F = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r0F7F, swizzle_x(r0DB1), 0x01));

                  ir_variable *const r0F80 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r0F80, swizzle_x(r0DB2), 0x01));

                  ir_variable *const r0F81 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0F82 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0F83 = rshift(swizzle_y(r0DB1), body.constant(int(19)));
                  ir_expression *const r0F84 = bit_and(r0F83, body.constant(4095u));
                  ir_expression *const r0F85 = equal(r0F84, body.constant(4094u));
                  ir_expression *const r0F86 = nequal(swizzle_x(r0DB1), body.constant(0u));
                  ir_expression *const r0F87 = bit_and(swizzle_y(r0DB1), body.constant(524287u));
                  ir_expression *const r0F88 = nequal(r0F87, body.constant(0u));
                  ir_expression *const r0F89 = logic_or(r0F86, r0F88);
                  body.emit(assign(r0F82, logic_and(r0F85, r0F89), 0x01));

                  ir_variable *const r0F8A = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0F8B = lshift(swizzle_y(r0DB2), body.constant(int(1)));
                  ir_expression *const r0F8C = lequal(body.constant(4292870144u), r0F8B);
                  ir_expression *const r0F8D = nequal(swizzle_x(r0DB2), body.constant(0u));
                  ir_expression *const r0F8E = bit_and(swizzle_y(r0DB2), body.constant(1048575u));
                  ir_expression *const r0F8F = nequal(r0F8E, body.constant(0u));
                  ir_expression *const r0F90 = logic_or(r0F8D, r0F8F);
                  body.emit(assign(r0F8A, logic_and(r0F8C, r0F90), 0x01));

                  body.emit(assign(r0F7F, bit_or(swizzle_y(r0DB1), body.constant(524288u)), 0x02));

                  body.emit(assign(r0F80, bit_or(swizzle_y(r0DB2), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r0F92 = lshift(swizzle_y(r0DB1), body.constant(int(1)));
                  ir_expression *const r0F93 = lequal(body.constant(4292870144u), r0F92);
                  ir_expression *const r0F94 = nequal(swizzle_x(r0DB1), body.constant(0u));
                  ir_expression *const r0F95 = bit_and(swizzle_y(r0DB1), body.constant(1048575u));
                  ir_expression *const r0F96 = nequal(r0F95, body.constant(0u));
                  ir_expression *const r0F97 = logic_or(r0F94, r0F96);
                  ir_expression *const r0F98 = logic_and(r0F93, r0F97);
                  ir_if *f0F91 = new(mem_ctx) ir_if(operand(r0F98).val);
                  exec_list *const f0F91_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F91->then_instructions;

                     ir_variable *const r0F99 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0F9B = logic_and(r0F82, r0F8A);
                     ir_if *f0F9A = new(mem_ctx) ir_if(operand(r0F9B).val);
                     exec_list *const f0F9A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F9A->then_instructions;

                        body.emit(assign(r0F99, r0F80, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0F9A->else_instructions;

                        body.emit(assign(r0F99, r0F7F, 0x03));


                     body.instructions = f0F9A_parent_instructions;
                     body.emit(f0F9A);

                     /* END IF */

                     body.emit(assign(r0F81, r0F99, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F91->else_instructions;

                     body.emit(assign(r0F81, r0F80, 0x03));


                  body.instructions = f0F91_parent_instructions;
                  body.emit(f0F91);

                  /* END IF */

                  body.emit(assign(r0DB9, r0F81, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0F7A->else_instructions;

                  ir_constant_data r0F9C_data;
                  memset(&r0F9C_data, 0, sizeof(ir_constant_data));
r0F9C_data.u[0] = 4294967295;
r0F9C_data.u[1] = 4294967295;
                  ir_constant *const r0F9C = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r0F9C_data);
                  body.emit(assign(r0DB9, r0F9C, 0x03));


               body.instructions = f0F7A_parent_instructions;
               body.emit(f0F7A);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0F78->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0F9E = equal(r0DC1, body.constant(int(0)));
               ir_if *f0F9D = new(mem_ctx) ir_if(operand(r0F9E).val);
               exec_list *const f0F9D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F9D->then_instructions;

                  body.emit(assign(r0DBD, body.constant(int(1)), 0x01));

                  body.emit(assign(r0DBB, body.constant(int(1)), 0x01));


               body.instructions = f0F9D_parent_instructions;
               body.emit(f0F9D);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0FA0 = less(swizzle_y(r0DBC), swizzle_y(r0DBE));
               ir_if *f0F9F = new(mem_ctx) ir_if(operand(r0FA0).val);
               exec_list *const f0F9F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F9F->then_instructions;

                  ir_variable *const r0FA1 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r0FA2 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0FA2, sub(swizzle_x(r0DBE), swizzle_x(r0DBC)), 0x01));

                  ir_expression *const r0FA3 = sub(swizzle_y(r0DBE), swizzle_y(r0DBC));
                  ir_expression *const r0FA4 = less(swizzle_x(r0DBE), swizzle_x(r0DBC));
                  ir_expression *const r0FA5 = expr(ir_unop_b2i, r0FA4);
                  ir_expression *const r0FA6 = expr(ir_unop_i2u, r0FA5);
                  body.emit(assign(r0FA1, sub(r0FA3, r0FA6), 0x01));

                  body.emit(assign(r0DBF, add(r0DBD, body.constant(int(-1))), 0x01));

                  ir_variable *const r0FA7 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r0FA7, add(r0DBF, body.constant(int(-10))), 0x01));

                  ir_variable *const r0FA8 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r0FA8, r0FA1, 0x01));

                  ir_variable *const r0FA9 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r0FA9, r0FA2, 0x01));

                  ir_variable *const r0FAA = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r0FAA);
                  ir_variable *const r0FAB = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0FAB);
                  /* IF CONDITION */
                  ir_expression *const r0FAD = equal(r0FA1, body.constant(0u));
                  ir_if *f0FAC = new(mem_ctx) ir_if(operand(r0FAD).val);
                  exec_list *const f0FAC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0FAC->then_instructions;

                     body.emit(assign(r0FA8, r0FA2, 0x01));

                     body.emit(assign(r0FA9, body.constant(0u), 0x01));

                     body.emit(assign(r0FA7, add(r0FA7, body.constant(int(-32))), 0x01));


                  body.instructions = f0FAC_parent_instructions;
                  body.emit(f0FAC);

                  /* END IF */

                  ir_variable *const r0FAE = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r0FAE, r0FA8, 0x01));

                  ir_variable *const r0FAF = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r0FB0 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0FB0);
                  /* IF CONDITION */
                  ir_expression *const r0FB2 = equal(r0FA8, body.constant(0u));
                  ir_if *f0FB1 = new(mem_ctx) ir_if(operand(r0FB2).val);
                  exec_list *const f0FB1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0FB1->then_instructions;

                     body.emit(assign(r0FAF, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0FB1->else_instructions;

                     body.emit(assign(r0FB0, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0FB4 = bit_and(r0FA8, body.constant(4294901760u));
                     ir_expression *const r0FB5 = equal(r0FB4, body.constant(0u));
                     ir_if *f0FB3 = new(mem_ctx) ir_if(operand(r0FB5).val);
                     exec_list *const f0FB3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FB3->then_instructions;

                        body.emit(assign(r0FB0, body.constant(int(16)), 0x01));

                        body.emit(assign(r0FAE, lshift(r0FA8, body.constant(int(16))), 0x01));


                     body.instructions = f0FB3_parent_instructions;
                     body.emit(f0FB3);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0FB7 = bit_and(r0FAE, body.constant(4278190080u));
                     ir_expression *const r0FB8 = equal(r0FB7, body.constant(0u));
                     ir_if *f0FB6 = new(mem_ctx) ir_if(operand(r0FB8).val);
                     exec_list *const f0FB6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FB6->then_instructions;

                        body.emit(assign(r0FB0, add(r0FB0, body.constant(int(8))), 0x01));

                        body.emit(assign(r0FAE, lshift(r0FAE, body.constant(int(8))), 0x01));


                     body.instructions = f0FB6_parent_instructions;
                     body.emit(f0FB6);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0FBA = bit_and(r0FAE, body.constant(4026531840u));
                     ir_expression *const r0FBB = equal(r0FBA, body.constant(0u));
                     ir_if *f0FB9 = new(mem_ctx) ir_if(operand(r0FBB).val);
                     exec_list *const f0FB9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FB9->then_instructions;

                        body.emit(assign(r0FB0, add(r0FB0, body.constant(int(4))), 0x01));

                        body.emit(assign(r0FAE, lshift(r0FAE, body.constant(int(4))), 0x01));


                     body.instructions = f0FB9_parent_instructions;
                     body.emit(f0FB9);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0FBD = bit_and(r0FAE, body.constant(3221225472u));
                     ir_expression *const r0FBE = equal(r0FBD, body.constant(0u));
                     ir_if *f0FBC = new(mem_ctx) ir_if(operand(r0FBE).val);
                     exec_list *const f0FBC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FBC->then_instructions;

                        body.emit(assign(r0FB0, add(r0FB0, body.constant(int(2))), 0x01));

                        body.emit(assign(r0FAE, lshift(r0FAE, body.constant(int(2))), 0x01));


                     body.instructions = f0FBC_parent_instructions;
                     body.emit(f0FBC);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0FC0 = bit_and(r0FAE, body.constant(2147483648u));
                     ir_expression *const r0FC1 = equal(r0FC0, body.constant(0u));
                     ir_if *f0FBF = new(mem_ctx) ir_if(operand(r0FC1).val);
                     exec_list *const f0FBF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FBF->then_instructions;

                        body.emit(assign(r0FB0, add(r0FB0, body.constant(int(1))), 0x01));


                     body.instructions = f0FBF_parent_instructions;
                     body.emit(f0FBF);

                     /* END IF */

                     body.emit(assign(r0FAF, r0FB0, 0x01));


                  body.instructions = f0FB1_parent_instructions;
                  body.emit(f0FB1);

                  /* END IF */

                  body.emit(assign(r0FAB, add(r0FAF, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0FC3 = lequal(body.constant(int(0)), r0FAB);
                  ir_if *f0FC2 = new(mem_ctx) ir_if(operand(r0FC3).val);
                  exec_list *const f0FC2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0FC2->then_instructions;

                     body.emit(assign(r0FAA, body.constant(0u), 0x01));

                     ir_variable *const r0FC4 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r0FC4, lshift(r0FA9, r0FAB), 0x01));

                     ir_variable *const r0FC5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0FC7 = equal(r0FAB, body.constant(int(0)));
                     ir_if *f0FC6 = new(mem_ctx) ir_if(operand(r0FC7).val);
                     exec_list *const f0FC6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FC6->then_instructions;

                        body.emit(assign(r0FC5, r0FA8, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0FC6->else_instructions;

                        ir_expression *const r0FC8 = lshift(r0FA8, r0FAB);
                        ir_expression *const r0FC9 = neg(r0FAB);
                        ir_expression *const r0FCA = bit_and(r0FC9, body.constant(int(31)));
                        ir_expression *const r0FCB = rshift(r0FA9, r0FCA);
                        body.emit(assign(r0FC5, bit_or(r0FC8, r0FCB), 0x01));


                     body.instructions = f0FC6_parent_instructions;
                     body.emit(f0FC6);

                     /* END IF */

                     body.emit(assign(r0FA8, r0FC5, 0x01));

                     body.emit(assign(r0FA9, r0FC4, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0FC2->else_instructions;

                     ir_variable *const r0FCC = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0FCC, body.constant(0u), 0x01));

                     ir_variable *const r0FCD = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0FCD, neg(r0FAB), 0x01));

                     ir_variable *const r0FCE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0FCE);
                     ir_variable *const r0FCF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0FCF);
                     ir_variable *const r0FD0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0FD0);
                     ir_variable *const r0FD1 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0FD2 = neg(r0FCD);
                     body.emit(assign(r0FD1, bit_and(r0FD2, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0FD4 = equal(r0FCD, body.constant(int(0)));
                     ir_if *f0FD3 = new(mem_ctx) ir_if(operand(r0FD4).val);
                     exec_list *const f0FD3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FD3->then_instructions;

                        body.emit(assign(r0FCE, r0FCC, 0x01));

                        body.emit(assign(r0FCF, r0FA9, 0x01));

                        body.emit(assign(r0FD0, r0FA8, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0FD3->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0FD6 = less(r0FCD, body.constant(int(32)));
                        ir_if *f0FD5 = new(mem_ctx) ir_if(operand(r0FD6).val);
                        exec_list *const f0FD5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0FD5->then_instructions;

                           body.emit(assign(r0FCE, lshift(r0FA9, r0FD1), 0x01));

                           ir_expression *const r0FD7 = lshift(r0FA8, r0FD1);
                           ir_expression *const r0FD8 = rshift(r0FA9, r0FCD);
                           body.emit(assign(r0FCF, bit_or(r0FD7, r0FD8), 0x01));

                           body.emit(assign(r0FD0, rshift(r0FA8, r0FCD), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0FD5->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0FDA = equal(r0FCD, body.constant(int(32)));
                           ir_if *f0FD9 = new(mem_ctx) ir_if(operand(r0FDA).val);
                           exec_list *const f0FD9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0FD9->then_instructions;

                              body.emit(assign(r0FCE, r0FA9, 0x01));

                              body.emit(assign(r0FCF, r0FA8, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0FD9->else_instructions;

                              body.emit(assign(r0FCC, bit_or(body.constant(0u), r0FA9), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0FDC = less(r0FCD, body.constant(int(64)));
                              ir_if *f0FDB = new(mem_ctx) ir_if(operand(r0FDC).val);
                              exec_list *const f0FDB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0FDB->then_instructions;

                                 body.emit(assign(r0FCE, lshift(r0FA8, r0FD1), 0x01));

                                 ir_expression *const r0FDD = bit_and(r0FCD, body.constant(int(31)));
                                 body.emit(assign(r0FCF, rshift(r0FA8, r0FDD), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0FDB->else_instructions;

                                 ir_variable *const r0FDE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0FE0 = equal(r0FCD, body.constant(int(64)));
                                 ir_if *f0FDF = new(mem_ctx) ir_if(operand(r0FE0).val);
                                 exec_list *const f0FDF_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0FDF->then_instructions;

                                    body.emit(assign(r0FDE, r0FA8, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0FDF->else_instructions;

                                    ir_expression *const r0FE1 = nequal(r0FA8, body.constant(0u));
                                    ir_expression *const r0FE2 = expr(ir_unop_b2i, r0FE1);
                                    body.emit(assign(r0FDE, expr(ir_unop_i2u, r0FE2), 0x01));


                                 body.instructions = f0FDF_parent_instructions;
                                 body.emit(f0FDF);

                                 /* END IF */

                                 body.emit(assign(r0FCE, r0FDE, 0x01));

                                 body.emit(assign(r0FCF, body.constant(0u), 0x01));


                              body.instructions = f0FDB_parent_instructions;
                              body.emit(f0FDB);

                              /* END IF */


                           body.instructions = f0FD9_parent_instructions;
                           body.emit(f0FD9);

                           /* END IF */

                           body.emit(assign(r0FD0, body.constant(0u), 0x01));


                        body.instructions = f0FD5_parent_instructions;
                        body.emit(f0FD5);

                        /* END IF */

                        ir_expression *const r0FE3 = nequal(r0FCC, body.constant(0u));
                        ir_expression *const r0FE4 = expr(ir_unop_b2i, r0FE3);
                        ir_expression *const r0FE5 = expr(ir_unop_i2u, r0FE4);
                        body.emit(assign(r0FCE, bit_or(r0FCE, r0FE5), 0x01));


                     body.instructions = f0FD3_parent_instructions;
                     body.emit(f0FD3);

                     /* END IF */

                     body.emit(assign(r0FA8, r0FD0, 0x01));

                     body.emit(assign(r0FA9, r0FCF, 0x01));

                     body.emit(assign(r0FAA, r0FCE, 0x01));


                  body.instructions = f0FC2_parent_instructions;
                  body.emit(f0FC2);

                  /* END IF */

                  body.emit(assign(r0FA7, sub(r0FA7, r0FAB), 0x01));

                  ir_variable *const r0FE6 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r0FE6, r0FA7, 0x01));

                  ir_variable *const r0FE7 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r0FE7, r0FA8, 0x01));

                  ir_variable *const r0FE8 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r0FE8, r0FA9, 0x01));

                  ir_variable *const r0FE9 = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r0FE9, r0FAA, 0x01));

                  ir_variable *const r0FEA = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r0FEA, body.constant(true), 0x01));

                  ir_variable *const r0FEB = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0FEC = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r0FEC);
                  ir_expression *const r0FED = expr(ir_unop_u2i, r0FAA);
                  body.emit(assign(r0FEC, less(r0FED, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0FEF = lequal(body.constant(int(2045)), r0FA7);
                  ir_if *f0FEE = new(mem_ctx) ir_if(operand(r0FEF).val);
                  exec_list *const f0FEE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0FEE->then_instructions;

                     ir_variable *const r0FF0 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0FF2 = less(body.constant(int(2045)), r0FA7);
                     ir_if *f0FF1 = new(mem_ctx) ir_if(operand(r0FF2).val);
                     exec_list *const f0FF1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FF1->then_instructions;

                        body.emit(assign(r0FF0, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0FF1->else_instructions;

                        ir_variable *const r0FF3 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0FF5 = equal(r0FA7, body.constant(int(2045)));
                        ir_if *f0FF4 = new(mem_ctx) ir_if(operand(r0FF5).val);
                        exec_list *const f0FF4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0FF4->then_instructions;

                           ir_expression *const r0FF6 = equal(body.constant(2097151u), r0FA8);
                           ir_expression *const r0FF7 = equal(body.constant(4294967295u), r0FA9);
                           body.emit(assign(r0FF3, logic_and(r0FF6, r0FF7), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0FF4->else_instructions;

                           body.emit(assign(r0FF3, body.constant(false), 0x01));


                        body.instructions = f0FF4_parent_instructions;
                        body.emit(f0FF4);

                        /* END IF */

                        body.emit(assign(r0FF0, logic_and(r0FF3, r0FEC), 0x01));


                     body.instructions = f0FF1_parent_instructions;
                     body.emit(f0FF1);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f0FF8 = new(mem_ctx) ir_if(operand(r0FF0).val);
                     exec_list *const f0FF8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FF8->then_instructions;

                        ir_variable *const r0FF9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r0FF9);
                        ir_expression *const r0FFA = lshift(r0DB8, body.constant(int(31)));
                        body.emit(assign(r0FF9, add(r0FFA, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r0FF9, body.constant(0u), 0x01));

                        body.emit(assign(r0FEB, r0FF9, 0x03));

                        body.emit(assign(r0FEA, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0FF8->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0FFC = less(r0FA7, body.constant(int(0)));
                        ir_if *f0FFB = new(mem_ctx) ir_if(operand(r0FFC).val);
                        exec_list *const f0FFB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0FFB->then_instructions;

                           ir_variable *const r0FFD = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r0FFD, r0FAA, 0x01));

                           ir_variable *const r0FFE = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r0FFE, neg(r0FA7), 0x01));

                           ir_variable *const r0FFF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r0FFF);
                           ir_variable *const r1000 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r1000);
                           ir_variable *const r1001 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r1001);
                           ir_variable *const r1002 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r1003 = neg(r0FFE);
                           body.emit(assign(r1002, bit_and(r1003, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1005 = equal(r0FFE, body.constant(int(0)));
                           ir_if *f1004 = new(mem_ctx) ir_if(operand(r1005).val);
                           exec_list *const f1004_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1004->then_instructions;

                              body.emit(assign(r0FFF, r0FAA, 0x01));

                              body.emit(assign(r1000, r0FA9, 0x01));

                              body.emit(assign(r1001, r0FA8, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1004->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1007 = less(r0FFE, body.constant(int(32)));
                              ir_if *f1006 = new(mem_ctx) ir_if(operand(r1007).val);
                              exec_list *const f1006_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1006->then_instructions;

                                 body.emit(assign(r0FFF, lshift(r0FA9, r1002), 0x01));

                                 ir_expression *const r1008 = lshift(r0FA8, r1002);
                                 ir_expression *const r1009 = rshift(r0FA9, r0FFE);
                                 body.emit(assign(r1000, bit_or(r1008, r1009), 0x01));

                                 body.emit(assign(r1001, rshift(r0FA8, r0FFE), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1006->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r100B = equal(r0FFE, body.constant(int(32)));
                                 ir_if *f100A = new(mem_ctx) ir_if(operand(r100B).val);
                                 exec_list *const f100A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f100A->then_instructions;

                                    body.emit(assign(r0FFF, r0FA9, 0x01));

                                    body.emit(assign(r1000, r0FA8, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f100A->else_instructions;

                                    body.emit(assign(r0FFD, bit_or(r0FAA, r0FA9), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r100D = less(r0FFE, body.constant(int(64)));
                                    ir_if *f100C = new(mem_ctx) ir_if(operand(r100D).val);
                                    exec_list *const f100C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f100C->then_instructions;

                                       body.emit(assign(r0FFF, lshift(r0FA8, r1002), 0x01));

                                       ir_expression *const r100E = bit_and(r0FFE, body.constant(int(31)));
                                       body.emit(assign(r1000, rshift(r0FA8, r100E), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f100C->else_instructions;

                                       ir_variable *const r100F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r1011 = equal(r0FFE, body.constant(int(64)));
                                       ir_if *f1010 = new(mem_ctx) ir_if(operand(r1011).val);
                                       exec_list *const f1010_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1010->then_instructions;

                                          body.emit(assign(r100F, r0FA8, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1010->else_instructions;

                                          ir_expression *const r1012 = nequal(r0FA8, body.constant(0u));
                                          ir_expression *const r1013 = expr(ir_unop_b2i, r1012);
                                          body.emit(assign(r100F, expr(ir_unop_i2u, r1013), 0x01));


                                       body.instructions = f1010_parent_instructions;
                                       body.emit(f1010);

                                       /* END IF */

                                       body.emit(assign(r0FFF, r100F, 0x01));

                                       body.emit(assign(r1000, body.constant(0u), 0x01));


                                    body.instructions = f100C_parent_instructions;
                                    body.emit(f100C);

                                    /* END IF */


                                 body.instructions = f100A_parent_instructions;
                                 body.emit(f100A);

                                 /* END IF */

                                 body.emit(assign(r1001, body.constant(0u), 0x01));


                              body.instructions = f1006_parent_instructions;
                              body.emit(f1006);

                              /* END IF */

                              ir_expression *const r1014 = nequal(r0FFD, body.constant(0u));
                              ir_expression *const r1015 = expr(ir_unop_b2i, r1014);
                              ir_expression *const r1016 = expr(ir_unop_i2u, r1015);
                              body.emit(assign(r0FFF, bit_or(r0FFF, r1016), 0x01));


                           body.instructions = f1004_parent_instructions;
                           body.emit(f1004);

                           /* END IF */

                           body.emit(assign(r0FE7, r1001, 0x01));

                           body.emit(assign(r0FE8, r1000, 0x01));

                           body.emit(assign(r0FE9, r0FFF, 0x01));

                           body.emit(assign(r0FE6, body.constant(int(0)), 0x01));

                           body.emit(assign(r0FEC, less(r0FFF, body.constant(0u)), 0x01));


                        body.instructions = f0FFB_parent_instructions;
                        body.emit(f0FFB);

                        /* END IF */


                     body.instructions = f0FF8_parent_instructions;
                     body.emit(f0FF8);

                     /* END IF */


                  body.instructions = f0FEE_parent_instructions;
                  body.emit(f0FEE);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f1017 = new(mem_ctx) ir_if(operand(r0FEA).val);
                  exec_list *const f1017_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1017->then_instructions;

                     /* IF CONDITION */
                     ir_if *f1018 = new(mem_ctx) ir_if(operand(r0FEC).val);
                     exec_list *const f1018_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1018->then_instructions;

                        ir_variable *const r1019 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r1019, add(r0FE8, body.constant(1u)), 0x01));

                        ir_expression *const r101A = less(r1019, r0FE8);
                        ir_expression *const r101B = expr(ir_unop_b2i, r101A);
                        ir_expression *const r101C = expr(ir_unop_i2u, r101B);
                        body.emit(assign(r0FE7, add(r0FE7, r101C), 0x01));

                        ir_expression *const r101D = equal(r0FE9, body.constant(0u));
                        ir_expression *const r101E = expr(ir_unop_b2i, r101D);
                        ir_expression *const r101F = expr(ir_unop_i2u, r101E);
                        ir_expression *const r1020 = add(r0FE9, r101F);
                        ir_expression *const r1021 = bit_and(r1020, body.constant(1u));
                        ir_expression *const r1022 = expr(ir_unop_bit_not, r1021);
                        body.emit(assign(r0FE8, bit_and(r1019, r1022), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1018->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1024 = bit_or(r0FE7, r0FE8);
                        ir_expression *const r1025 = equal(r1024, body.constant(0u));
                        ir_if *f1023 = new(mem_ctx) ir_if(operand(r1025).val);
                        exec_list *const f1023_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1023->then_instructions;

                           body.emit(assign(r0FE6, body.constant(int(0)), 0x01));


                        body.instructions = f1023_parent_instructions;
                        body.emit(f1023);

                        /* END IF */


                     body.instructions = f1018_parent_instructions;
                     body.emit(f1018);

                     /* END IF */

                     ir_variable *const r1026 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r1026);
                     ir_expression *const r1027 = lshift(r0DB8, body.constant(int(31)));
                     ir_expression *const r1028 = expr(ir_unop_i2u, r0FE6);
                     ir_expression *const r1029 = lshift(r1028, body.constant(int(20)));
                     ir_expression *const r102A = add(r1027, r1029);
                     body.emit(assign(r1026, add(r102A, r0FE7), 0x02));

                     body.emit(assign(r1026, r0FE8, 0x01));

                     body.emit(assign(r0FEB, r1026, 0x03));

                     body.emit(assign(r0FEA, body.constant(false), 0x01));


                  body.instructions = f1017_parent_instructions;
                  body.emit(f1017);

                  /* END IF */

                  body.emit(assign(r0DB9, r0FEB, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0F9F->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r102C = less(swizzle_y(r0DBE), swizzle_y(r0DBC));
                  ir_if *f102B = new(mem_ctx) ir_if(operand(r102C).val);
                  exec_list *const f102B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f102B->then_instructions;

                     ir_variable *const r102D = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r102E = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r102E, sub(swizzle_x(r0DBC), swizzle_x(r0DBE)), 0x01));

                     ir_expression *const r102F = sub(swizzle_y(r0DBC), swizzle_y(r0DBE));
                     ir_expression *const r1030 = less(swizzle_x(r0DBC), swizzle_x(r0DBE));
                     ir_expression *const r1031 = expr(ir_unop_b2i, r1030);
                     ir_expression *const r1032 = expr(ir_unop_i2u, r1031);
                     body.emit(assign(r102D, sub(r102F, r1032), 0x01));

                     body.emit(assign(r0DB8, bit_xor(r0DB8, body.constant(1u)), 0x01));

                     body.emit(assign(r0DBF, add(r0DBB, body.constant(int(-1))), 0x01));

                     ir_variable *const r1033 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r1033, add(r0DBF, body.constant(int(-10))), 0x01));

                     ir_variable *const r1034 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r1034, r102D, 0x01));

                     ir_variable *const r1035 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r1035, r102E, 0x01));

                     ir_variable *const r1036 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r1036);
                     ir_variable *const r1037 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r1037);
                     /* IF CONDITION */
                     ir_expression *const r1039 = equal(r102D, body.constant(0u));
                     ir_if *f1038 = new(mem_ctx) ir_if(operand(r1039).val);
                     exec_list *const f1038_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1038->then_instructions;

                        body.emit(assign(r1034, r102E, 0x01));

                        body.emit(assign(r1035, body.constant(0u), 0x01));

                        body.emit(assign(r1033, add(r1033, body.constant(int(-32))), 0x01));


                     body.instructions = f1038_parent_instructions;
                     body.emit(f1038);

                     /* END IF */

                     ir_variable *const r103A = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r103A, r1034, 0x01));

                     ir_variable *const r103B = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r103C = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r103C);
                     /* IF CONDITION */
                     ir_expression *const r103E = equal(r1034, body.constant(0u));
                     ir_if *f103D = new(mem_ctx) ir_if(operand(r103E).val);
                     exec_list *const f103D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f103D->then_instructions;

                        body.emit(assign(r103B, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f103D->else_instructions;

                        body.emit(assign(r103C, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1040 = bit_and(r1034, body.constant(4294901760u));
                        ir_expression *const r1041 = equal(r1040, body.constant(0u));
                        ir_if *f103F = new(mem_ctx) ir_if(operand(r1041).val);
                        exec_list *const f103F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f103F->then_instructions;

                           body.emit(assign(r103C, body.constant(int(16)), 0x01));

                           body.emit(assign(r103A, lshift(r1034, body.constant(int(16))), 0x01));


                        body.instructions = f103F_parent_instructions;
                        body.emit(f103F);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1043 = bit_and(r103A, body.constant(4278190080u));
                        ir_expression *const r1044 = equal(r1043, body.constant(0u));
                        ir_if *f1042 = new(mem_ctx) ir_if(operand(r1044).val);
                        exec_list *const f1042_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1042->then_instructions;

                           body.emit(assign(r103C, add(r103C, body.constant(int(8))), 0x01));

                           body.emit(assign(r103A, lshift(r103A, body.constant(int(8))), 0x01));


                        body.instructions = f1042_parent_instructions;
                        body.emit(f1042);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1046 = bit_and(r103A, body.constant(4026531840u));
                        ir_expression *const r1047 = equal(r1046, body.constant(0u));
                        ir_if *f1045 = new(mem_ctx) ir_if(operand(r1047).val);
                        exec_list *const f1045_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1045->then_instructions;

                           body.emit(assign(r103C, add(r103C, body.constant(int(4))), 0x01));

                           body.emit(assign(r103A, lshift(r103A, body.constant(int(4))), 0x01));


                        body.instructions = f1045_parent_instructions;
                        body.emit(f1045);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1049 = bit_and(r103A, body.constant(3221225472u));
                        ir_expression *const r104A = equal(r1049, body.constant(0u));
                        ir_if *f1048 = new(mem_ctx) ir_if(operand(r104A).val);
                        exec_list *const f1048_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1048->then_instructions;

                           body.emit(assign(r103C, add(r103C, body.constant(int(2))), 0x01));

                           body.emit(assign(r103A, lshift(r103A, body.constant(int(2))), 0x01));


                        body.instructions = f1048_parent_instructions;
                        body.emit(f1048);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r104C = bit_and(r103A, body.constant(2147483648u));
                        ir_expression *const r104D = equal(r104C, body.constant(0u));
                        ir_if *f104B = new(mem_ctx) ir_if(operand(r104D).val);
                        exec_list *const f104B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f104B->then_instructions;

                           body.emit(assign(r103C, add(r103C, body.constant(int(1))), 0x01));


                        body.instructions = f104B_parent_instructions;
                        body.emit(f104B);

                        /* END IF */

                        body.emit(assign(r103B, r103C, 0x01));


                     body.instructions = f103D_parent_instructions;
                     body.emit(f103D);

                     /* END IF */

                     body.emit(assign(r1037, add(r103B, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r104F = lequal(body.constant(int(0)), r1037);
                     ir_if *f104E = new(mem_ctx) ir_if(operand(r104F).val);
                     exec_list *const f104E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f104E->then_instructions;

                        body.emit(assign(r1036, body.constant(0u), 0x01));

                        ir_variable *const r1050 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r1050, lshift(r1035, r1037), 0x01));

                        ir_variable *const r1051 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r1053 = equal(r1037, body.constant(int(0)));
                        ir_if *f1052 = new(mem_ctx) ir_if(operand(r1053).val);
                        exec_list *const f1052_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1052->then_instructions;

                           body.emit(assign(r1051, r1034, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1052->else_instructions;

                           ir_expression *const r1054 = lshift(r1034, r1037);
                           ir_expression *const r1055 = neg(r1037);
                           ir_expression *const r1056 = bit_and(r1055, body.constant(int(31)));
                           ir_expression *const r1057 = rshift(r1035, r1056);
                           body.emit(assign(r1051, bit_or(r1054, r1057), 0x01));


                        body.instructions = f1052_parent_instructions;
                        body.emit(f1052);

                        /* END IF */

                        body.emit(assign(r1034, r1051, 0x01));

                        body.emit(assign(r1035, r1050, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f104E->else_instructions;

                        ir_variable *const r1058 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r1058, body.constant(0u), 0x01));

                        ir_variable *const r1059 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r1059, neg(r1037), 0x01));

                        ir_variable *const r105A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r105A);
                        ir_variable *const r105B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r105B);
                        ir_variable *const r105C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r105C);
                        ir_variable *const r105D = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r105E = neg(r1059);
                        body.emit(assign(r105D, bit_and(r105E, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1060 = equal(r1059, body.constant(int(0)));
                        ir_if *f105F = new(mem_ctx) ir_if(operand(r1060).val);
                        exec_list *const f105F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f105F->then_instructions;

                           body.emit(assign(r105A, r1058, 0x01));

                           body.emit(assign(r105B, r1035, 0x01));

                           body.emit(assign(r105C, r1034, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f105F->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1062 = less(r1059, body.constant(int(32)));
                           ir_if *f1061 = new(mem_ctx) ir_if(operand(r1062).val);
                           exec_list *const f1061_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1061->then_instructions;

                              body.emit(assign(r105A, lshift(r1035, r105D), 0x01));

                              ir_expression *const r1063 = lshift(r1034, r105D);
                              ir_expression *const r1064 = rshift(r1035, r1059);
                              body.emit(assign(r105B, bit_or(r1063, r1064), 0x01));

                              body.emit(assign(r105C, rshift(r1034, r1059), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1061->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1066 = equal(r1059, body.constant(int(32)));
                              ir_if *f1065 = new(mem_ctx) ir_if(operand(r1066).val);
                              exec_list *const f1065_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1065->then_instructions;

                                 body.emit(assign(r105A, r1035, 0x01));

                                 body.emit(assign(r105B, r1034, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1065->else_instructions;

                                 body.emit(assign(r1058, bit_or(body.constant(0u), r1035), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1068 = less(r1059, body.constant(int(64)));
                                 ir_if *f1067 = new(mem_ctx) ir_if(operand(r1068).val);
                                 exec_list *const f1067_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1067->then_instructions;

                                    body.emit(assign(r105A, lshift(r1034, r105D), 0x01));

                                    ir_expression *const r1069 = bit_and(r1059, body.constant(int(31)));
                                    body.emit(assign(r105B, rshift(r1034, r1069), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1067->else_instructions;

                                    ir_variable *const r106A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r106C = equal(r1059, body.constant(int(64)));
                                    ir_if *f106B = new(mem_ctx) ir_if(operand(r106C).val);
                                    exec_list *const f106B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f106B->then_instructions;

                                       body.emit(assign(r106A, r1034, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f106B->else_instructions;

                                       ir_expression *const r106D = nequal(r1034, body.constant(0u));
                                       ir_expression *const r106E = expr(ir_unop_b2i, r106D);
                                       body.emit(assign(r106A, expr(ir_unop_i2u, r106E), 0x01));


                                    body.instructions = f106B_parent_instructions;
                                    body.emit(f106B);

                                    /* END IF */

                                    body.emit(assign(r105A, r106A, 0x01));

                                    body.emit(assign(r105B, body.constant(0u), 0x01));


                                 body.instructions = f1067_parent_instructions;
                                 body.emit(f1067);

                                 /* END IF */


                              body.instructions = f1065_parent_instructions;
                              body.emit(f1065);

                              /* END IF */

                              body.emit(assign(r105C, body.constant(0u), 0x01));


                           body.instructions = f1061_parent_instructions;
                           body.emit(f1061);

                           /* END IF */

                           ir_expression *const r106F = nequal(r1058, body.constant(0u));
                           ir_expression *const r1070 = expr(ir_unop_b2i, r106F);
                           ir_expression *const r1071 = expr(ir_unop_i2u, r1070);
                           body.emit(assign(r105A, bit_or(r105A, r1071), 0x01));


                        body.instructions = f105F_parent_instructions;
                        body.emit(f105F);

                        /* END IF */

                        body.emit(assign(r1034, r105C, 0x01));

                        body.emit(assign(r1035, r105B, 0x01));

                        body.emit(assign(r1036, r105A, 0x01));


                     body.instructions = f104E_parent_instructions;
                     body.emit(f104E);

                     /* END IF */

                     body.emit(assign(r1033, sub(r1033, r1037), 0x01));

                     ir_variable *const r1072 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r1072, r1033, 0x01));

                     ir_variable *const r1073 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r1073, r1034, 0x01));

                     ir_variable *const r1074 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r1074, r1035, 0x01));

                     ir_variable *const r1075 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r1075, r1036, 0x01));

                     ir_variable *const r1076 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r1076, body.constant(true), 0x01));

                     ir_variable *const r1077 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r1078 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r1078);
                     ir_expression *const r1079 = expr(ir_unop_u2i, r1036);
                     body.emit(assign(r1078, less(r1079, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r107B = lequal(body.constant(int(2045)), r1033);
                     ir_if *f107A = new(mem_ctx) ir_if(operand(r107B).val);
                     exec_list *const f107A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f107A->then_instructions;

                        ir_variable *const r107C = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r107E = less(body.constant(int(2045)), r1033);
                        ir_if *f107D = new(mem_ctx) ir_if(operand(r107E).val);
                        exec_list *const f107D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f107D->then_instructions;

                           body.emit(assign(r107C, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f107D->else_instructions;

                           ir_variable *const r107F = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r1081 = equal(r1033, body.constant(int(2045)));
                           ir_if *f1080 = new(mem_ctx) ir_if(operand(r1081).val);
                           exec_list *const f1080_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1080->then_instructions;

                              ir_expression *const r1082 = equal(body.constant(2097151u), r1034);
                              ir_expression *const r1083 = equal(body.constant(4294967295u), r1035);
                              body.emit(assign(r107F, logic_and(r1082, r1083), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1080->else_instructions;

                              body.emit(assign(r107F, body.constant(false), 0x01));


                           body.instructions = f1080_parent_instructions;
                           body.emit(f1080);

                           /* END IF */

                           body.emit(assign(r107C, logic_and(r107F, r1078), 0x01));


                        body.instructions = f107D_parent_instructions;
                        body.emit(f107D);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f1084 = new(mem_ctx) ir_if(operand(r107C).val);
                        exec_list *const f1084_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1084->then_instructions;

                           ir_variable *const r1085 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r1085);
                           ir_expression *const r1086 = lshift(r0DB8, body.constant(int(31)));
                           body.emit(assign(r1085, add(r1086, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r1085, body.constant(0u), 0x01));

                           body.emit(assign(r1077, r1085, 0x03));

                           body.emit(assign(r1076, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1084->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1088 = less(r1033, body.constant(int(0)));
                           ir_if *f1087 = new(mem_ctx) ir_if(operand(r1088).val);
                           exec_list *const f1087_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1087->then_instructions;

                              ir_variable *const r1089 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r1089, r1036, 0x01));

                              ir_variable *const r108A = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r108A, neg(r1033), 0x01));

                              ir_variable *const r108B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r108B);
                              ir_variable *const r108C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r108C);
                              ir_variable *const r108D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r108D);
                              ir_variable *const r108E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r108F = neg(r108A);
                              body.emit(assign(r108E, bit_and(r108F, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1091 = equal(r108A, body.constant(int(0)));
                              ir_if *f1090 = new(mem_ctx) ir_if(operand(r1091).val);
                              exec_list *const f1090_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1090->then_instructions;

                                 body.emit(assign(r108B, r1036, 0x01));

                                 body.emit(assign(r108C, r1035, 0x01));

                                 body.emit(assign(r108D, r1034, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1090->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1093 = less(r108A, body.constant(int(32)));
                                 ir_if *f1092 = new(mem_ctx) ir_if(operand(r1093).val);
                                 exec_list *const f1092_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1092->then_instructions;

                                    body.emit(assign(r108B, lshift(r1035, r108E), 0x01));

                                    ir_expression *const r1094 = lshift(r1034, r108E);
                                    ir_expression *const r1095 = rshift(r1035, r108A);
                                    body.emit(assign(r108C, bit_or(r1094, r1095), 0x01));

                                    body.emit(assign(r108D, rshift(r1034, r108A), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1092->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r1097 = equal(r108A, body.constant(int(32)));
                                    ir_if *f1096 = new(mem_ctx) ir_if(operand(r1097).val);
                                    exec_list *const f1096_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1096->then_instructions;

                                       body.emit(assign(r108B, r1035, 0x01));

                                       body.emit(assign(r108C, r1034, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1096->else_instructions;

                                       body.emit(assign(r1089, bit_or(r1036, r1035), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r1099 = less(r108A, body.constant(int(64)));
                                       ir_if *f1098 = new(mem_ctx) ir_if(operand(r1099).val);
                                       exec_list *const f1098_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1098->then_instructions;

                                          body.emit(assign(r108B, lshift(r1034, r108E), 0x01));

                                          ir_expression *const r109A = bit_and(r108A, body.constant(int(31)));
                                          body.emit(assign(r108C, rshift(r1034, r109A), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1098->else_instructions;

                                          ir_variable *const r109B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r109D = equal(r108A, body.constant(int(64)));
                                          ir_if *f109C = new(mem_ctx) ir_if(operand(r109D).val);
                                          exec_list *const f109C_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f109C->then_instructions;

                                             body.emit(assign(r109B, r1034, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f109C->else_instructions;

                                             ir_expression *const r109E = nequal(r1034, body.constant(0u));
                                             ir_expression *const r109F = expr(ir_unop_b2i, r109E);
                                             body.emit(assign(r109B, expr(ir_unop_i2u, r109F), 0x01));


                                          body.instructions = f109C_parent_instructions;
                                          body.emit(f109C);

                                          /* END IF */

                                          body.emit(assign(r108B, r109B, 0x01));

                                          body.emit(assign(r108C, body.constant(0u), 0x01));


                                       body.instructions = f1098_parent_instructions;
                                       body.emit(f1098);

                                       /* END IF */


                                    body.instructions = f1096_parent_instructions;
                                    body.emit(f1096);

                                    /* END IF */

                                    body.emit(assign(r108D, body.constant(0u), 0x01));


                                 body.instructions = f1092_parent_instructions;
                                 body.emit(f1092);

                                 /* END IF */

                                 ir_expression *const r10A0 = nequal(r1089, body.constant(0u));
                                 ir_expression *const r10A1 = expr(ir_unop_b2i, r10A0);
                                 ir_expression *const r10A2 = expr(ir_unop_i2u, r10A1);
                                 body.emit(assign(r108B, bit_or(r108B, r10A2), 0x01));


                              body.instructions = f1090_parent_instructions;
                              body.emit(f1090);

                              /* END IF */

                              body.emit(assign(r1073, r108D, 0x01));

                              body.emit(assign(r1074, r108C, 0x01));

                              body.emit(assign(r1075, r108B, 0x01));

                              body.emit(assign(r1072, body.constant(int(0)), 0x01));

                              body.emit(assign(r1078, less(r108B, body.constant(0u)), 0x01));


                           body.instructions = f1087_parent_instructions;
                           body.emit(f1087);

                           /* END IF */


                        body.instructions = f1084_parent_instructions;
                        body.emit(f1084);

                        /* END IF */


                     body.instructions = f107A_parent_instructions;
                     body.emit(f107A);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f10A3 = new(mem_ctx) ir_if(operand(r1076).val);
                     exec_list *const f10A3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f10A3->then_instructions;

                        /* IF CONDITION */
                        ir_if *f10A4 = new(mem_ctx) ir_if(operand(r1078).val);
                        exec_list *const f10A4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f10A4->then_instructions;

                           ir_variable *const r10A5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r10A5, add(r1074, body.constant(1u)), 0x01));

                           ir_expression *const r10A6 = less(r10A5, r1074);
                           ir_expression *const r10A7 = expr(ir_unop_b2i, r10A6);
                           ir_expression *const r10A8 = expr(ir_unop_i2u, r10A7);
                           body.emit(assign(r1073, add(r1073, r10A8), 0x01));

                           ir_expression *const r10A9 = equal(r1075, body.constant(0u));
                           ir_expression *const r10AA = expr(ir_unop_b2i, r10A9);
                           ir_expression *const r10AB = expr(ir_unop_i2u, r10AA);
                           ir_expression *const r10AC = add(r1075, r10AB);
                           ir_expression *const r10AD = bit_and(r10AC, body.constant(1u));
                           ir_expression *const r10AE = expr(ir_unop_bit_not, r10AD);
                           body.emit(assign(r1074, bit_and(r10A5, r10AE), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f10A4->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r10B0 = bit_or(r1073, r1074);
                           ir_expression *const r10B1 = equal(r10B0, body.constant(0u));
                           ir_if *f10AF = new(mem_ctx) ir_if(operand(r10B1).val);
                           exec_list *const f10AF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10AF->then_instructions;

                              body.emit(assign(r1072, body.constant(int(0)), 0x01));


                           body.instructions = f10AF_parent_instructions;
                           body.emit(f10AF);

                           /* END IF */


                        body.instructions = f10A4_parent_instructions;
                        body.emit(f10A4);

                        /* END IF */

                        ir_variable *const r10B2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r10B2);
                        ir_expression *const r10B3 = lshift(r0DB8, body.constant(int(31)));
                        ir_expression *const r10B4 = expr(ir_unop_i2u, r1072);
                        ir_expression *const r10B5 = lshift(r10B4, body.constant(int(20)));
                        ir_expression *const r10B6 = add(r10B3, r10B5);
                        body.emit(assign(r10B2, add(r10B6, r1073), 0x02));

                        body.emit(assign(r10B2, r1074, 0x01));

                        body.emit(assign(r1077, r10B2, 0x03));

                        body.emit(assign(r1076, body.constant(false), 0x01));


                     body.instructions = f10A3_parent_instructions;
                     body.emit(f10A3);

                     /* END IF */

                     body.emit(assign(r0DB9, r1077, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f102B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r10B8 = less(swizzle_x(r0DBC), swizzle_x(r0DBE));
                     ir_if *f10B7 = new(mem_ctx) ir_if(operand(r10B8).val);
                     exec_list *const f10B7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f10B7->then_instructions;

                        ir_variable *const r10B9 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r10BA = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r10BA, sub(swizzle_x(r0DBE), swizzle_x(r0DBC)), 0x01));

                        ir_expression *const r10BB = sub(swizzle_y(r0DBE), swizzle_y(r0DBC));
                        ir_expression *const r10BC = less(swizzle_x(r0DBE), swizzle_x(r0DBC));
                        ir_expression *const r10BD = expr(ir_unop_b2i, r10BC);
                        ir_expression *const r10BE = expr(ir_unop_i2u, r10BD);
                        body.emit(assign(r10B9, sub(r10BB, r10BE), 0x01));

                        body.emit(assign(r0DBF, add(r0DBD, body.constant(int(-1))), 0x01));

                        ir_variable *const r10BF = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r10BF, add(r0DBF, body.constant(int(-10))), 0x01));

                        ir_variable *const r10C0 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r10C0, r10B9, 0x01));

                        ir_variable *const r10C1 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r10C1, r10BA, 0x01));

                        ir_variable *const r10C2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r10C2);
                        ir_variable *const r10C3 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r10C3);
                        /* IF CONDITION */
                        ir_expression *const r10C5 = equal(r10B9, body.constant(0u));
                        ir_if *f10C4 = new(mem_ctx) ir_if(operand(r10C5).val);
                        exec_list *const f10C4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f10C4->then_instructions;

                           body.emit(assign(r10C0, r10BA, 0x01));

                           body.emit(assign(r10C1, body.constant(0u), 0x01));

                           body.emit(assign(r10BF, add(r10BF, body.constant(int(-32))), 0x01));


                        body.instructions = f10C4_parent_instructions;
                        body.emit(f10C4);

                        /* END IF */

                        ir_variable *const r10C6 = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r10C6, r10C0, 0x01));

                        ir_variable *const r10C7 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r10C8 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r10C8);
                        /* IF CONDITION */
                        ir_expression *const r10CA = equal(r10C0, body.constant(0u));
                        ir_if *f10C9 = new(mem_ctx) ir_if(operand(r10CA).val);
                        exec_list *const f10C9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f10C9->then_instructions;

                           body.emit(assign(r10C7, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f10C9->else_instructions;

                           body.emit(assign(r10C8, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r10CC = bit_and(r10C0, body.constant(4294901760u));
                           ir_expression *const r10CD = equal(r10CC, body.constant(0u));
                           ir_if *f10CB = new(mem_ctx) ir_if(operand(r10CD).val);
                           exec_list *const f10CB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10CB->then_instructions;

                              body.emit(assign(r10C8, body.constant(int(16)), 0x01));

                              body.emit(assign(r10C6, lshift(r10C0, body.constant(int(16))), 0x01));


                           body.instructions = f10CB_parent_instructions;
                           body.emit(f10CB);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r10CF = bit_and(r10C6, body.constant(4278190080u));
                           ir_expression *const r10D0 = equal(r10CF, body.constant(0u));
                           ir_if *f10CE = new(mem_ctx) ir_if(operand(r10D0).val);
                           exec_list *const f10CE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10CE->then_instructions;

                              body.emit(assign(r10C8, add(r10C8, body.constant(int(8))), 0x01));

                              body.emit(assign(r10C6, lshift(r10C6, body.constant(int(8))), 0x01));


                           body.instructions = f10CE_parent_instructions;
                           body.emit(f10CE);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r10D2 = bit_and(r10C6, body.constant(4026531840u));
                           ir_expression *const r10D3 = equal(r10D2, body.constant(0u));
                           ir_if *f10D1 = new(mem_ctx) ir_if(operand(r10D3).val);
                           exec_list *const f10D1_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10D1->then_instructions;

                              body.emit(assign(r10C8, add(r10C8, body.constant(int(4))), 0x01));

                              body.emit(assign(r10C6, lshift(r10C6, body.constant(int(4))), 0x01));


                           body.instructions = f10D1_parent_instructions;
                           body.emit(f10D1);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r10D5 = bit_and(r10C6, body.constant(3221225472u));
                           ir_expression *const r10D6 = equal(r10D5, body.constant(0u));
                           ir_if *f10D4 = new(mem_ctx) ir_if(operand(r10D6).val);
                           exec_list *const f10D4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10D4->then_instructions;

                              body.emit(assign(r10C8, add(r10C8, body.constant(int(2))), 0x01));

                              body.emit(assign(r10C6, lshift(r10C6, body.constant(int(2))), 0x01));


                           body.instructions = f10D4_parent_instructions;
                           body.emit(f10D4);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r10D8 = bit_and(r10C6, body.constant(2147483648u));
                           ir_expression *const r10D9 = equal(r10D8, body.constant(0u));
                           ir_if *f10D7 = new(mem_ctx) ir_if(operand(r10D9).val);
                           exec_list *const f10D7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10D7->then_instructions;

                              body.emit(assign(r10C8, add(r10C8, body.constant(int(1))), 0x01));


                           body.instructions = f10D7_parent_instructions;
                           body.emit(f10D7);

                           /* END IF */

                           body.emit(assign(r10C7, r10C8, 0x01));


                        body.instructions = f10C9_parent_instructions;
                        body.emit(f10C9);

                        /* END IF */

                        body.emit(assign(r10C3, add(r10C7, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r10DB = lequal(body.constant(int(0)), r10C3);
                        ir_if *f10DA = new(mem_ctx) ir_if(operand(r10DB).val);
                        exec_list *const f10DA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f10DA->then_instructions;

                           body.emit(assign(r10C2, body.constant(0u), 0x01));

                           ir_variable *const r10DC = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r10DC, lshift(r10C1, r10C3), 0x01));

                           ir_variable *const r10DD = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r10DF = equal(r10C3, body.constant(int(0)));
                           ir_if *f10DE = new(mem_ctx) ir_if(operand(r10DF).val);
                           exec_list *const f10DE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10DE->then_instructions;

                              body.emit(assign(r10DD, r10C0, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f10DE->else_instructions;

                              ir_expression *const r10E0 = lshift(r10C0, r10C3);
                              ir_expression *const r10E1 = neg(r10C3);
                              ir_expression *const r10E2 = bit_and(r10E1, body.constant(int(31)));
                              ir_expression *const r10E3 = rshift(r10C1, r10E2);
                              body.emit(assign(r10DD, bit_or(r10E0, r10E3), 0x01));


                           body.instructions = f10DE_parent_instructions;
                           body.emit(f10DE);

                           /* END IF */

                           body.emit(assign(r10C0, r10DD, 0x01));

                           body.emit(assign(r10C1, r10DC, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f10DA->else_instructions;

                           ir_variable *const r10E4 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r10E4, body.constant(0u), 0x01));

                           ir_variable *const r10E5 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r10E5, neg(r10C3), 0x01));

                           ir_variable *const r10E6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r10E6);
                           ir_variable *const r10E7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r10E7);
                           ir_variable *const r10E8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r10E8);
                           ir_variable *const r10E9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r10EA = neg(r10E5);
                           body.emit(assign(r10E9, bit_and(r10EA, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r10EC = equal(r10E5, body.constant(int(0)));
                           ir_if *f10EB = new(mem_ctx) ir_if(operand(r10EC).val);
                           exec_list *const f10EB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10EB->then_instructions;

                              body.emit(assign(r10E6, r10E4, 0x01));

                              body.emit(assign(r10E7, r10C1, 0x01));

                              body.emit(assign(r10E8, r10C0, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f10EB->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r10EE = less(r10E5, body.constant(int(32)));
                              ir_if *f10ED = new(mem_ctx) ir_if(operand(r10EE).val);
                              exec_list *const f10ED_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f10ED->then_instructions;

                                 body.emit(assign(r10E6, lshift(r10C1, r10E9), 0x01));

                                 ir_expression *const r10EF = lshift(r10C0, r10E9);
                                 ir_expression *const r10F0 = rshift(r10C1, r10E5);
                                 body.emit(assign(r10E7, bit_or(r10EF, r10F0), 0x01));

                                 body.emit(assign(r10E8, rshift(r10C0, r10E5), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f10ED->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r10F2 = equal(r10E5, body.constant(int(32)));
                                 ir_if *f10F1 = new(mem_ctx) ir_if(operand(r10F2).val);
                                 exec_list *const f10F1_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f10F1->then_instructions;

                                    body.emit(assign(r10E6, r10C1, 0x01));

                                    body.emit(assign(r10E7, r10C0, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f10F1->else_instructions;

                                    body.emit(assign(r10E4, bit_or(body.constant(0u), r10C1), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r10F4 = less(r10E5, body.constant(int(64)));
                                    ir_if *f10F3 = new(mem_ctx) ir_if(operand(r10F4).val);
                                    exec_list *const f10F3_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f10F3->then_instructions;

                                       body.emit(assign(r10E6, lshift(r10C0, r10E9), 0x01));

                                       ir_expression *const r10F5 = bit_and(r10E5, body.constant(int(31)));
                                       body.emit(assign(r10E7, rshift(r10C0, r10F5), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f10F3->else_instructions;

                                       ir_variable *const r10F6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r10F8 = equal(r10E5, body.constant(int(64)));
                                       ir_if *f10F7 = new(mem_ctx) ir_if(operand(r10F8).val);
                                       exec_list *const f10F7_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f10F7->then_instructions;

                                          body.emit(assign(r10F6, r10C0, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f10F7->else_instructions;

                                          ir_expression *const r10F9 = nequal(r10C0, body.constant(0u));
                                          ir_expression *const r10FA = expr(ir_unop_b2i, r10F9);
                                          body.emit(assign(r10F6, expr(ir_unop_i2u, r10FA), 0x01));


                                       body.instructions = f10F7_parent_instructions;
                                       body.emit(f10F7);

                                       /* END IF */

                                       body.emit(assign(r10E6, r10F6, 0x01));

                                       body.emit(assign(r10E7, body.constant(0u), 0x01));


                                    body.instructions = f10F3_parent_instructions;
                                    body.emit(f10F3);

                                    /* END IF */


                                 body.instructions = f10F1_parent_instructions;
                                 body.emit(f10F1);

                                 /* END IF */

                                 body.emit(assign(r10E8, body.constant(0u), 0x01));


                              body.instructions = f10ED_parent_instructions;
                              body.emit(f10ED);

                              /* END IF */

                              ir_expression *const r10FB = nequal(r10E4, body.constant(0u));
                              ir_expression *const r10FC = expr(ir_unop_b2i, r10FB);
                              ir_expression *const r10FD = expr(ir_unop_i2u, r10FC);
                              body.emit(assign(r10E6, bit_or(r10E6, r10FD), 0x01));


                           body.instructions = f10EB_parent_instructions;
                           body.emit(f10EB);

                           /* END IF */

                           body.emit(assign(r10C0, r10E8, 0x01));

                           body.emit(assign(r10C1, r10E7, 0x01));

                           body.emit(assign(r10C2, r10E6, 0x01));


                        body.instructions = f10DA_parent_instructions;
                        body.emit(f10DA);

                        /* END IF */

                        body.emit(assign(r10BF, sub(r10BF, r10C3), 0x01));

                        ir_variable *const r10FE = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r10FE, r10BF, 0x01));

                        ir_variable *const r10FF = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r10FF, r10C0, 0x01));

                        ir_variable *const r1100 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r1100, r10C1, 0x01));

                        ir_variable *const r1101 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r1101, r10C2, 0x01));

                        ir_variable *const r1102 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r1102, body.constant(true), 0x01));

                        ir_variable *const r1103 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r1104 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r1104);
                        ir_expression *const r1105 = expr(ir_unop_u2i, r10C2);
                        body.emit(assign(r1104, less(r1105, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1107 = lequal(body.constant(int(2045)), r10BF);
                        ir_if *f1106 = new(mem_ctx) ir_if(operand(r1107).val);
                        exec_list *const f1106_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1106->then_instructions;

                           ir_variable *const r1108 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r110A = less(body.constant(int(2045)), r10BF);
                           ir_if *f1109 = new(mem_ctx) ir_if(operand(r110A).val);
                           exec_list *const f1109_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1109->then_instructions;

                              body.emit(assign(r1108, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1109->else_instructions;

                              ir_variable *const r110B = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r110D = equal(r10BF, body.constant(int(2045)));
                              ir_if *f110C = new(mem_ctx) ir_if(operand(r110D).val);
                              exec_list *const f110C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f110C->then_instructions;

                                 ir_expression *const r110E = equal(body.constant(2097151u), r10C0);
                                 ir_expression *const r110F = equal(body.constant(4294967295u), r10C1);
                                 body.emit(assign(r110B, logic_and(r110E, r110F), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f110C->else_instructions;

                                 body.emit(assign(r110B, body.constant(false), 0x01));


                              body.instructions = f110C_parent_instructions;
                              body.emit(f110C);

                              /* END IF */

                              body.emit(assign(r1108, logic_and(r110B, r1104), 0x01));


                           body.instructions = f1109_parent_instructions;
                           body.emit(f1109);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f1110 = new(mem_ctx) ir_if(operand(r1108).val);
                           exec_list *const f1110_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1110->then_instructions;

                              ir_variable *const r1111 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r1111);
                              ir_expression *const r1112 = lshift(r0DB8, body.constant(int(31)));
                              body.emit(assign(r1111, add(r1112, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r1111, body.constant(0u), 0x01));

                              body.emit(assign(r1103, r1111, 0x03));

                              body.emit(assign(r1102, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1110->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1114 = less(r10BF, body.constant(int(0)));
                              ir_if *f1113 = new(mem_ctx) ir_if(operand(r1114).val);
                              exec_list *const f1113_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1113->then_instructions;

                                 ir_variable *const r1115 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r1115, r10C2, 0x01));

                                 ir_variable *const r1116 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r1116, neg(r10BF), 0x01));

                                 ir_variable *const r1117 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r1117);
                                 ir_variable *const r1118 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r1118);
                                 ir_variable *const r1119 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r1119);
                                 ir_variable *const r111A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r111B = neg(r1116);
                                 body.emit(assign(r111A, bit_and(r111B, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r111D = equal(r1116, body.constant(int(0)));
                                 ir_if *f111C = new(mem_ctx) ir_if(operand(r111D).val);
                                 exec_list *const f111C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f111C->then_instructions;

                                    body.emit(assign(r1117, r10C2, 0x01));

                                    body.emit(assign(r1118, r10C1, 0x01));

                                    body.emit(assign(r1119, r10C0, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f111C->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r111F = less(r1116, body.constant(int(32)));
                                    ir_if *f111E = new(mem_ctx) ir_if(operand(r111F).val);
                                    exec_list *const f111E_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f111E->then_instructions;

                                       body.emit(assign(r1117, lshift(r10C1, r111A), 0x01));

                                       ir_expression *const r1120 = lshift(r10C0, r111A);
                                       ir_expression *const r1121 = rshift(r10C1, r1116);
                                       body.emit(assign(r1118, bit_or(r1120, r1121), 0x01));

                                       body.emit(assign(r1119, rshift(r10C0, r1116), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f111E->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r1123 = equal(r1116, body.constant(int(32)));
                                       ir_if *f1122 = new(mem_ctx) ir_if(operand(r1123).val);
                                       exec_list *const f1122_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1122->then_instructions;

                                          body.emit(assign(r1117, r10C1, 0x01));

                                          body.emit(assign(r1118, r10C0, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1122->else_instructions;

                                          body.emit(assign(r1115, bit_or(r10C2, r10C1), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r1125 = less(r1116, body.constant(int(64)));
                                          ir_if *f1124 = new(mem_ctx) ir_if(operand(r1125).val);
                                          exec_list *const f1124_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1124->then_instructions;

                                             body.emit(assign(r1117, lshift(r10C0, r111A), 0x01));

                                             ir_expression *const r1126 = bit_and(r1116, body.constant(int(31)));
                                             body.emit(assign(r1118, rshift(r10C0, r1126), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1124->else_instructions;

                                             ir_variable *const r1127 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r1129 = equal(r1116, body.constant(int(64)));
                                             ir_if *f1128 = new(mem_ctx) ir_if(operand(r1129).val);
                                             exec_list *const f1128_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f1128->then_instructions;

                                                body.emit(assign(r1127, r10C0, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f1128->else_instructions;

                                                ir_expression *const r112A = nequal(r10C0, body.constant(0u));
                                                ir_expression *const r112B = expr(ir_unop_b2i, r112A);
                                                body.emit(assign(r1127, expr(ir_unop_i2u, r112B), 0x01));


                                             body.instructions = f1128_parent_instructions;
                                             body.emit(f1128);

                                             /* END IF */

                                             body.emit(assign(r1117, r1127, 0x01));

                                             body.emit(assign(r1118, body.constant(0u), 0x01));


                                          body.instructions = f1124_parent_instructions;
                                          body.emit(f1124);

                                          /* END IF */


                                       body.instructions = f1122_parent_instructions;
                                       body.emit(f1122);

                                       /* END IF */

                                       body.emit(assign(r1119, body.constant(0u), 0x01));


                                    body.instructions = f111E_parent_instructions;
                                    body.emit(f111E);

                                    /* END IF */

                                    ir_expression *const r112C = nequal(r1115, body.constant(0u));
                                    ir_expression *const r112D = expr(ir_unop_b2i, r112C);
                                    ir_expression *const r112E = expr(ir_unop_i2u, r112D);
                                    body.emit(assign(r1117, bit_or(r1117, r112E), 0x01));


                                 body.instructions = f111C_parent_instructions;
                                 body.emit(f111C);

                                 /* END IF */

                                 body.emit(assign(r10FF, r1119, 0x01));

                                 body.emit(assign(r1100, r1118, 0x01));

                                 body.emit(assign(r1101, r1117, 0x01));

                                 body.emit(assign(r10FE, body.constant(int(0)), 0x01));

                                 body.emit(assign(r1104, less(r1117, body.constant(0u)), 0x01));


                              body.instructions = f1113_parent_instructions;
                              body.emit(f1113);

                              /* END IF */


                           body.instructions = f1110_parent_instructions;
                           body.emit(f1110);

                           /* END IF */


                        body.instructions = f1106_parent_instructions;
                        body.emit(f1106);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f112F = new(mem_ctx) ir_if(operand(r1102).val);
                        exec_list *const f112F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f112F->then_instructions;

                           /* IF CONDITION */
                           ir_if *f1130 = new(mem_ctx) ir_if(operand(r1104).val);
                           exec_list *const f1130_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1130->then_instructions;

                              ir_variable *const r1131 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r1131, add(r1100, body.constant(1u)), 0x01));

                              ir_expression *const r1132 = less(r1131, r1100);
                              ir_expression *const r1133 = expr(ir_unop_b2i, r1132);
                              ir_expression *const r1134 = expr(ir_unop_i2u, r1133);
                              body.emit(assign(r10FF, add(r10FF, r1134), 0x01));

                              ir_expression *const r1135 = equal(r1101, body.constant(0u));
                              ir_expression *const r1136 = expr(ir_unop_b2i, r1135);
                              ir_expression *const r1137 = expr(ir_unop_i2u, r1136);
                              ir_expression *const r1138 = add(r1101, r1137);
                              ir_expression *const r1139 = bit_and(r1138, body.constant(1u));
                              ir_expression *const r113A = expr(ir_unop_bit_not, r1139);
                              body.emit(assign(r1100, bit_and(r1131, r113A), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1130->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r113C = bit_or(r10FF, r1100);
                              ir_expression *const r113D = equal(r113C, body.constant(0u));
                              ir_if *f113B = new(mem_ctx) ir_if(operand(r113D).val);
                              exec_list *const f113B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f113B->then_instructions;

                                 body.emit(assign(r10FE, body.constant(int(0)), 0x01));


                              body.instructions = f113B_parent_instructions;
                              body.emit(f113B);

                              /* END IF */


                           body.instructions = f1130_parent_instructions;
                           body.emit(f1130);

                           /* END IF */

                           ir_variable *const r113E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r113E);
                           ir_expression *const r113F = lshift(r0DB8, body.constant(int(31)));
                           ir_expression *const r1140 = expr(ir_unop_i2u, r10FE);
                           ir_expression *const r1141 = lshift(r1140, body.constant(int(20)));
                           ir_expression *const r1142 = add(r113F, r1141);
                           body.emit(assign(r113E, add(r1142, r10FF), 0x02));

                           body.emit(assign(r113E, r1100, 0x01));

                           body.emit(assign(r1103, r113E, 0x03));

                           body.emit(assign(r1102, body.constant(false), 0x01));


                        body.instructions = f112F_parent_instructions;
                        body.emit(f112F);

                        /* END IF */

                        body.emit(assign(r0DB9, r1103, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f10B7->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1144 = less(swizzle_x(r0DBE), swizzle_x(r0DBC));
                        ir_if *f1143 = new(mem_ctx) ir_if(operand(r1144).val);
                        exec_list *const f1143_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1143->then_instructions;

                           ir_variable *const r1145 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r1146 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r1146, sub(swizzle_x(r0DBC), swizzle_x(r0DBE)), 0x01));

                           ir_expression *const r1147 = sub(swizzle_y(r0DBC), swizzle_y(r0DBE));
                           ir_expression *const r1148 = less(swizzle_x(r0DBC), swizzle_x(r0DBE));
                           ir_expression *const r1149 = expr(ir_unop_b2i, r1148);
                           ir_expression *const r114A = expr(ir_unop_i2u, r1149);
                           body.emit(assign(r1145, sub(r1147, r114A), 0x01));

                           body.emit(assign(r0DB8, bit_xor(r0DB8, body.constant(1u)), 0x01));

                           body.emit(assign(r0DBF, add(r0DBB, body.constant(int(-1))), 0x01));

                           ir_variable *const r114B = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r114B, add(r0DBF, body.constant(int(-10))), 0x01));

                           ir_variable *const r114C = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r114C, r1145, 0x01));

                           ir_variable *const r114D = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r114D, r1146, 0x01));

                           ir_variable *const r114E = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r114E);
                           ir_variable *const r114F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r114F);
                           /* IF CONDITION */
                           ir_expression *const r1151 = equal(r1145, body.constant(0u));
                           ir_if *f1150 = new(mem_ctx) ir_if(operand(r1151).val);
                           exec_list *const f1150_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1150->then_instructions;

                              body.emit(assign(r114C, r1146, 0x01));

                              body.emit(assign(r114D, body.constant(0u), 0x01));

                              body.emit(assign(r114B, add(r114B, body.constant(int(-32))), 0x01));


                           body.instructions = f1150_parent_instructions;
                           body.emit(f1150);

                           /* END IF */

                           ir_variable *const r1152 = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r1152, r114C, 0x01));

                           ir_variable *const r1153 = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r1154 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r1154);
                           /* IF CONDITION */
                           ir_expression *const r1156 = equal(r114C, body.constant(0u));
                           ir_if *f1155 = new(mem_ctx) ir_if(operand(r1156).val);
                           exec_list *const f1155_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1155->then_instructions;

                              body.emit(assign(r1153, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1155->else_instructions;

                              body.emit(assign(r1154, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1158 = bit_and(r114C, body.constant(4294901760u));
                              ir_expression *const r1159 = equal(r1158, body.constant(0u));
                              ir_if *f1157 = new(mem_ctx) ir_if(operand(r1159).val);
                              exec_list *const f1157_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1157->then_instructions;

                                 body.emit(assign(r1154, body.constant(int(16)), 0x01));

                                 body.emit(assign(r1152, lshift(r114C, body.constant(int(16))), 0x01));


                              body.instructions = f1157_parent_instructions;
                              body.emit(f1157);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r115B = bit_and(r1152, body.constant(4278190080u));
                              ir_expression *const r115C = equal(r115B, body.constant(0u));
                              ir_if *f115A = new(mem_ctx) ir_if(operand(r115C).val);
                              exec_list *const f115A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f115A->then_instructions;

                                 body.emit(assign(r1154, add(r1154, body.constant(int(8))), 0x01));

                                 body.emit(assign(r1152, lshift(r1152, body.constant(int(8))), 0x01));


                              body.instructions = f115A_parent_instructions;
                              body.emit(f115A);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r115E = bit_and(r1152, body.constant(4026531840u));
                              ir_expression *const r115F = equal(r115E, body.constant(0u));
                              ir_if *f115D = new(mem_ctx) ir_if(operand(r115F).val);
                              exec_list *const f115D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f115D->then_instructions;

                                 body.emit(assign(r1154, add(r1154, body.constant(int(4))), 0x01));

                                 body.emit(assign(r1152, lshift(r1152, body.constant(int(4))), 0x01));


                              body.instructions = f115D_parent_instructions;
                              body.emit(f115D);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r1161 = bit_and(r1152, body.constant(3221225472u));
                              ir_expression *const r1162 = equal(r1161, body.constant(0u));
                              ir_if *f1160 = new(mem_ctx) ir_if(operand(r1162).val);
                              exec_list *const f1160_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1160->then_instructions;

                                 body.emit(assign(r1154, add(r1154, body.constant(int(2))), 0x01));

                                 body.emit(assign(r1152, lshift(r1152, body.constant(int(2))), 0x01));


                              body.instructions = f1160_parent_instructions;
                              body.emit(f1160);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r1164 = bit_and(r1152, body.constant(2147483648u));
                              ir_expression *const r1165 = equal(r1164, body.constant(0u));
                              ir_if *f1163 = new(mem_ctx) ir_if(operand(r1165).val);
                              exec_list *const f1163_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1163->then_instructions;

                                 body.emit(assign(r1154, add(r1154, body.constant(int(1))), 0x01));


                              body.instructions = f1163_parent_instructions;
                              body.emit(f1163);

                              /* END IF */

                              body.emit(assign(r1153, r1154, 0x01));


                           body.instructions = f1155_parent_instructions;
                           body.emit(f1155);

                           /* END IF */

                           body.emit(assign(r114F, add(r1153, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1167 = lequal(body.constant(int(0)), r114F);
                           ir_if *f1166 = new(mem_ctx) ir_if(operand(r1167).val);
                           exec_list *const f1166_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1166->then_instructions;

                              body.emit(assign(r114E, body.constant(0u), 0x01));

                              ir_variable *const r1168 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r1168, lshift(r114D, r114F), 0x01));

                              ir_variable *const r1169 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r116B = equal(r114F, body.constant(int(0)));
                              ir_if *f116A = new(mem_ctx) ir_if(operand(r116B).val);
                              exec_list *const f116A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f116A->then_instructions;

                                 body.emit(assign(r1169, r114C, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f116A->else_instructions;

                                 ir_expression *const r116C = lshift(r114C, r114F);
                                 ir_expression *const r116D = neg(r114F);
                                 ir_expression *const r116E = bit_and(r116D, body.constant(int(31)));
                                 ir_expression *const r116F = rshift(r114D, r116E);
                                 body.emit(assign(r1169, bit_or(r116C, r116F), 0x01));


                              body.instructions = f116A_parent_instructions;
                              body.emit(f116A);

                              /* END IF */

                              body.emit(assign(r114C, r1169, 0x01));

                              body.emit(assign(r114D, r1168, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1166->else_instructions;

                              ir_variable *const r1170 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r1170, body.constant(0u), 0x01));

                              ir_variable *const r1171 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r1171, neg(r114F), 0x01));

                              ir_variable *const r1172 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r1172);
                              ir_variable *const r1173 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r1173);
                              ir_variable *const r1174 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r1174);
                              ir_variable *const r1175 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r1176 = neg(r1171);
                              body.emit(assign(r1175, bit_and(r1176, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1178 = equal(r1171, body.constant(int(0)));
                              ir_if *f1177 = new(mem_ctx) ir_if(operand(r1178).val);
                              exec_list *const f1177_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1177->then_instructions;

                                 body.emit(assign(r1172, r1170, 0x01));

                                 body.emit(assign(r1173, r114D, 0x01));

                                 body.emit(assign(r1174, r114C, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1177->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r117A = less(r1171, body.constant(int(32)));
                                 ir_if *f1179 = new(mem_ctx) ir_if(operand(r117A).val);
                                 exec_list *const f1179_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1179->then_instructions;

                                    body.emit(assign(r1172, lshift(r114D, r1175), 0x01));

                                    ir_expression *const r117B = lshift(r114C, r1175);
                                    ir_expression *const r117C = rshift(r114D, r1171);
                                    body.emit(assign(r1173, bit_or(r117B, r117C), 0x01));

                                    body.emit(assign(r1174, rshift(r114C, r1171), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1179->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r117E = equal(r1171, body.constant(int(32)));
                                    ir_if *f117D = new(mem_ctx) ir_if(operand(r117E).val);
                                    exec_list *const f117D_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f117D->then_instructions;

                                       body.emit(assign(r1172, r114D, 0x01));

                                       body.emit(assign(r1173, r114C, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f117D->else_instructions;

                                       body.emit(assign(r1170, bit_or(body.constant(0u), r114D), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r1180 = less(r1171, body.constant(int(64)));
                                       ir_if *f117F = new(mem_ctx) ir_if(operand(r1180).val);
                                       exec_list *const f117F_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f117F->then_instructions;

                                          body.emit(assign(r1172, lshift(r114C, r1175), 0x01));

                                          ir_expression *const r1181 = bit_and(r1171, body.constant(int(31)));
                                          body.emit(assign(r1173, rshift(r114C, r1181), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f117F->else_instructions;

                                          ir_variable *const r1182 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r1184 = equal(r1171, body.constant(int(64)));
                                          ir_if *f1183 = new(mem_ctx) ir_if(operand(r1184).val);
                                          exec_list *const f1183_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1183->then_instructions;

                                             body.emit(assign(r1182, r114C, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1183->else_instructions;

                                             ir_expression *const r1185 = nequal(r114C, body.constant(0u));
                                             ir_expression *const r1186 = expr(ir_unop_b2i, r1185);
                                             body.emit(assign(r1182, expr(ir_unop_i2u, r1186), 0x01));


                                          body.instructions = f1183_parent_instructions;
                                          body.emit(f1183);

                                          /* END IF */

                                          body.emit(assign(r1172, r1182, 0x01));

                                          body.emit(assign(r1173, body.constant(0u), 0x01));


                                       body.instructions = f117F_parent_instructions;
                                       body.emit(f117F);

                                       /* END IF */


                                    body.instructions = f117D_parent_instructions;
                                    body.emit(f117D);

                                    /* END IF */

                                    body.emit(assign(r1174, body.constant(0u), 0x01));


                                 body.instructions = f1179_parent_instructions;
                                 body.emit(f1179);

                                 /* END IF */

                                 ir_expression *const r1187 = nequal(r1170, body.constant(0u));
                                 ir_expression *const r1188 = expr(ir_unop_b2i, r1187);
                                 ir_expression *const r1189 = expr(ir_unop_i2u, r1188);
                                 body.emit(assign(r1172, bit_or(r1172, r1189), 0x01));


                              body.instructions = f1177_parent_instructions;
                              body.emit(f1177);

                              /* END IF */

                              body.emit(assign(r114C, r1174, 0x01));

                              body.emit(assign(r114D, r1173, 0x01));

                              body.emit(assign(r114E, r1172, 0x01));


                           body.instructions = f1166_parent_instructions;
                           body.emit(f1166);

                           /* END IF */

                           body.emit(assign(r114B, sub(r114B, r114F), 0x01));

                           ir_variable *const r118A = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r118A, r114B, 0x01));

                           ir_variable *const r118B = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r118B, r114C, 0x01));

                           ir_variable *const r118C = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r118C, r114D, 0x01));

                           ir_variable *const r118D = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r118D, r114E, 0x01));

                           ir_variable *const r118E = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r118E, body.constant(true), 0x01));

                           ir_variable *const r118F = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r1190 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r1190);
                           ir_expression *const r1191 = expr(ir_unop_u2i, r114E);
                           body.emit(assign(r1190, less(r1191, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1193 = lequal(body.constant(int(2045)), r114B);
                           ir_if *f1192 = new(mem_ctx) ir_if(operand(r1193).val);
                           exec_list *const f1192_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1192->then_instructions;

                              ir_variable *const r1194 = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1196 = less(body.constant(int(2045)), r114B);
                              ir_if *f1195 = new(mem_ctx) ir_if(operand(r1196).val);
                              exec_list *const f1195_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1195->then_instructions;

                                 body.emit(assign(r1194, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1195->else_instructions;

                                 ir_variable *const r1197 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r1199 = equal(r114B, body.constant(int(2045)));
                                 ir_if *f1198 = new(mem_ctx) ir_if(operand(r1199).val);
                                 exec_list *const f1198_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1198->then_instructions;

                                    ir_expression *const r119A = equal(body.constant(2097151u), r114C);
                                    ir_expression *const r119B = equal(body.constant(4294967295u), r114D);
                                    body.emit(assign(r1197, logic_and(r119A, r119B), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1198->else_instructions;

                                    body.emit(assign(r1197, body.constant(false), 0x01));


                                 body.instructions = f1198_parent_instructions;
                                 body.emit(f1198);

                                 /* END IF */

                                 body.emit(assign(r1194, logic_and(r1197, r1190), 0x01));


                              body.instructions = f1195_parent_instructions;
                              body.emit(f1195);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f119C = new(mem_ctx) ir_if(operand(r1194).val);
                              exec_list *const f119C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f119C->then_instructions;

                                 ir_variable *const r119D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r119D);
                                 ir_expression *const r119E = lshift(r0DB8, body.constant(int(31)));
                                 body.emit(assign(r119D, add(r119E, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r119D, body.constant(0u), 0x01));

                                 body.emit(assign(r118F, r119D, 0x03));

                                 body.emit(assign(r118E, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f119C->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r11A0 = less(r114B, body.constant(int(0)));
                                 ir_if *f119F = new(mem_ctx) ir_if(operand(r11A0).val);
                                 exec_list *const f119F_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f119F->then_instructions;

                                    ir_variable *const r11A1 = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r11A1, r114E, 0x01));

                                    ir_variable *const r11A2 = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r11A2, neg(r114B), 0x01));

                                    ir_variable *const r11A3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r11A3);
                                    ir_variable *const r11A4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r11A4);
                                    ir_variable *const r11A5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r11A5);
                                    ir_variable *const r11A6 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r11A7 = neg(r11A2);
                                    body.emit(assign(r11A6, bit_and(r11A7, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r11A9 = equal(r11A2, body.constant(int(0)));
                                    ir_if *f11A8 = new(mem_ctx) ir_if(operand(r11A9).val);
                                    exec_list *const f11A8_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f11A8->then_instructions;

                                       body.emit(assign(r11A3, r114E, 0x01));

                                       body.emit(assign(r11A4, r114D, 0x01));

                                       body.emit(assign(r11A5, r114C, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f11A8->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r11AB = less(r11A2, body.constant(int(32)));
                                       ir_if *f11AA = new(mem_ctx) ir_if(operand(r11AB).val);
                                       exec_list *const f11AA_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f11AA->then_instructions;

                                          body.emit(assign(r11A3, lshift(r114D, r11A6), 0x01));

                                          ir_expression *const r11AC = lshift(r114C, r11A6);
                                          ir_expression *const r11AD = rshift(r114D, r11A2);
                                          body.emit(assign(r11A4, bit_or(r11AC, r11AD), 0x01));

                                          body.emit(assign(r11A5, rshift(r114C, r11A2), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f11AA->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r11AF = equal(r11A2, body.constant(int(32)));
                                          ir_if *f11AE = new(mem_ctx) ir_if(operand(r11AF).val);
                                          exec_list *const f11AE_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f11AE->then_instructions;

                                             body.emit(assign(r11A3, r114D, 0x01));

                                             body.emit(assign(r11A4, r114C, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f11AE->else_instructions;

                                             body.emit(assign(r11A1, bit_or(r114E, r114D), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r11B1 = less(r11A2, body.constant(int(64)));
                                             ir_if *f11B0 = new(mem_ctx) ir_if(operand(r11B1).val);
                                             exec_list *const f11B0_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f11B0->then_instructions;

                                                body.emit(assign(r11A3, lshift(r114C, r11A6), 0x01));

                                                ir_expression *const r11B2 = bit_and(r11A2, body.constant(int(31)));
                                                body.emit(assign(r11A4, rshift(r114C, r11B2), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f11B0->else_instructions;

                                                ir_variable *const r11B3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r11B5 = equal(r11A2, body.constant(int(64)));
                                                ir_if *f11B4 = new(mem_ctx) ir_if(operand(r11B5).val);
                                                exec_list *const f11B4_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f11B4->then_instructions;

                                                   body.emit(assign(r11B3, r114C, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f11B4->else_instructions;

                                                   ir_expression *const r11B6 = nequal(r114C, body.constant(0u));
                                                   ir_expression *const r11B7 = expr(ir_unop_b2i, r11B6);
                                                   body.emit(assign(r11B3, expr(ir_unop_i2u, r11B7), 0x01));


                                                body.instructions = f11B4_parent_instructions;
                                                body.emit(f11B4);

                                                /* END IF */

                                                body.emit(assign(r11A3, r11B3, 0x01));

                                                body.emit(assign(r11A4, body.constant(0u), 0x01));


                                             body.instructions = f11B0_parent_instructions;
                                             body.emit(f11B0);

                                             /* END IF */


                                          body.instructions = f11AE_parent_instructions;
                                          body.emit(f11AE);

                                          /* END IF */

                                          body.emit(assign(r11A5, body.constant(0u), 0x01));


                                       body.instructions = f11AA_parent_instructions;
                                       body.emit(f11AA);

                                       /* END IF */

                                       ir_expression *const r11B8 = nequal(r11A1, body.constant(0u));
                                       ir_expression *const r11B9 = expr(ir_unop_b2i, r11B8);
                                       ir_expression *const r11BA = expr(ir_unop_i2u, r11B9);
                                       body.emit(assign(r11A3, bit_or(r11A3, r11BA), 0x01));


                                    body.instructions = f11A8_parent_instructions;
                                    body.emit(f11A8);

                                    /* END IF */

                                    body.emit(assign(r118B, r11A5, 0x01));

                                    body.emit(assign(r118C, r11A4, 0x01));

                                    body.emit(assign(r118D, r11A3, 0x01));

                                    body.emit(assign(r118A, body.constant(int(0)), 0x01));

                                    body.emit(assign(r1190, less(r11A3, body.constant(0u)), 0x01));


                                 body.instructions = f119F_parent_instructions;
                                 body.emit(f119F);

                                 /* END IF */


                              body.instructions = f119C_parent_instructions;
                              body.emit(f119C);

                              /* END IF */


                           body.instructions = f1192_parent_instructions;
                           body.emit(f1192);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f11BB = new(mem_ctx) ir_if(operand(r118E).val);
                           exec_list *const f11BB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f11BB->then_instructions;

                              /* IF CONDITION */
                              ir_if *f11BC = new(mem_ctx) ir_if(operand(r1190).val);
                              exec_list *const f11BC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f11BC->then_instructions;

                                 ir_variable *const r11BD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r11BD, add(r118C, body.constant(1u)), 0x01));

                                 ir_expression *const r11BE = less(r11BD, r118C);
                                 ir_expression *const r11BF = expr(ir_unop_b2i, r11BE);
                                 ir_expression *const r11C0 = expr(ir_unop_i2u, r11BF);
                                 body.emit(assign(r118B, add(r118B, r11C0), 0x01));

                                 ir_expression *const r11C1 = equal(r118D, body.constant(0u));
                                 ir_expression *const r11C2 = expr(ir_unop_b2i, r11C1);
                                 ir_expression *const r11C3 = expr(ir_unop_i2u, r11C2);
                                 ir_expression *const r11C4 = add(r118D, r11C3);
                                 ir_expression *const r11C5 = bit_and(r11C4, body.constant(1u));
                                 ir_expression *const r11C6 = expr(ir_unop_bit_not, r11C5);
                                 body.emit(assign(r118C, bit_and(r11BD, r11C6), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f11BC->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r11C8 = bit_or(r118B, r118C);
                                 ir_expression *const r11C9 = equal(r11C8, body.constant(0u));
                                 ir_if *f11C7 = new(mem_ctx) ir_if(operand(r11C9).val);
                                 exec_list *const f11C7_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f11C7->then_instructions;

                                    body.emit(assign(r118A, body.constant(int(0)), 0x01));


                                 body.instructions = f11C7_parent_instructions;
                                 body.emit(f11C7);

                                 /* END IF */


                              body.instructions = f11BC_parent_instructions;
                              body.emit(f11BC);

                              /* END IF */

                              ir_variable *const r11CA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r11CA);
                              ir_expression *const r11CB = lshift(r0DB8, body.constant(int(31)));
                              ir_expression *const r11CC = expr(ir_unop_i2u, r118A);
                              ir_expression *const r11CD = lshift(r11CC, body.constant(int(20)));
                              ir_expression *const r11CE = add(r11CB, r11CD);
                              body.emit(assign(r11CA, add(r11CE, r118B), 0x02));

                              body.emit(assign(r11CA, r118C, 0x01));

                              body.emit(assign(r118F, r11CA, 0x03));

                              body.emit(assign(r118E, body.constant(false), 0x01));


                           body.instructions = f11BB_parent_instructions;
                           body.emit(f11BB);

                           /* END IF */

                           body.emit(assign(r0DB9, r118F, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1143->else_instructions;

                           ir_variable *const r11CF = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r11CF);
                           body.emit(assign(r11CF, body.constant(0u), 0x02));

                           body.emit(assign(r11CF, body.constant(0u), 0x01));

                           body.emit(assign(r0DB9, r11CF, 0x03));


                        body.instructions = f1143_parent_instructions;
                        body.emit(f1143);

                        /* END IF */


                     body.instructions = f10B7_parent_instructions;
                     body.emit(f10B7);

                     /* END IF */


                  body.instructions = f102B_parent_instructions;
                  body.emit(f102B);

                  /* END IF */


               body.instructions = f0F9F_parent_instructions;
               body.emit(f0F9F);

               /* END IF */


            body.instructions = f0F78_parent_instructions;
            body.emit(f0F78);

            /* END IF */


         body.instructions = f0EA2_parent_instructions;
         body.emit(f0EA2);

         /* END IF */


      body.instructions = f0DD0_parent_instructions;
      body.emit(f0DD0);

      /* END IF */

      body.emit(assign(r0DB3, r0DB9, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0DB6->else_instructions;

      ir_variable *const r11D0 = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r11D0, body.constant(true), 0x01));

      ir_variable *const r11D1 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r11D2 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r11D2);
      ir_variable *const r11D3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
      body.emit(r11D3);
      ir_variable *const r11D4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
      body.emit(r11D4);
      ir_variable *const r11D5 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r11D5);
      ir_variable *const r11D6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
      body.emit(r11D6);
      ir_variable *const r11D7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
      body.emit(r11D7);
      body.emit(assign(r11D7, body.constant(0u), 0x01));

      body.emit(assign(r11D6, body.constant(0u), 0x01));

      ir_variable *const r11D8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r11D8);
      body.emit(assign(r11D8, bit_and(swizzle_y(r0DB1), body.constant(1048575u)), 0x02));

      body.emit(assign(r11D8, swizzle_x(r0DB1), 0x01));

      body.emit(assign(r11D4, r11D8, 0x03));

      ir_variable *const r11D9 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r11DA = rshift(swizzle_y(r0DB1), body.constant(int(20)));
      ir_expression *const r11DB = bit_and(r11DA, body.constant(2047u));
      body.emit(assign(r11D9, expr(ir_unop_u2i, r11DB), 0x01));

      ir_variable *const r11DC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r11DC);
      body.emit(assign(r11DC, bit_and(swizzle_y(r0DB2), body.constant(1048575u)), 0x02));

      body.emit(assign(r11DC, swizzle_x(r0DB2), 0x01));

      body.emit(assign(r11D3, r11DC, 0x03));

      ir_variable *const r11DD = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r11DE = rshift(swizzle_y(r0DB2), body.constant(int(20)));
      ir_expression *const r11DF = bit_and(r11DE, body.constant(2047u));
      body.emit(assign(r11DD, expr(ir_unop_u2i, r11DF), 0x01));

      ir_variable *const r11E0 = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r11E0, sub(r11D9, r11DD), 0x01));

      body.emit(assign(r11D2, r11E0, 0x01));

      /* IF CONDITION */
      ir_expression *const r11E2 = less(body.constant(int(0)), r11E0);
      ir_if *f11E1 = new(mem_ctx) ir_if(operand(r11E2).val);
      exec_list *const f11E1_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f11E1->then_instructions;

         /* IF CONDITION */
         ir_expression *const r11E4 = equal(r11D9, body.constant(int(2047)));
         ir_if *f11E3 = new(mem_ctx) ir_if(operand(r11E4).val);
         exec_list *const f11E3_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f11E3->then_instructions;

            /* IF CONDITION */
            ir_expression *const r11E6 = bit_or(swizzle_y(r11D8), swizzle_x(r0DB1));
            ir_expression *const r11E7 = nequal(r11E6, body.constant(0u));
            ir_if *f11E5 = new(mem_ctx) ir_if(operand(r11E7).val);
            exec_list *const f11E5_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f11E5->then_instructions;

               ir_variable *const r11E8 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r11E8, swizzle_x(r0DB1), 0x01));

               ir_variable *const r11E9 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r11E9, swizzle_x(r0DB2), 0x01));

               ir_variable *const r11EA = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r11EB = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r11EC = rshift(swizzle_y(r0DB1), body.constant(int(19)));
               ir_expression *const r11ED = bit_and(r11EC, body.constant(4095u));
               ir_expression *const r11EE = equal(r11ED, body.constant(4094u));
               ir_expression *const r11EF = nequal(swizzle_x(r0DB1), body.constant(0u));
               ir_expression *const r11F0 = bit_and(swizzle_y(r0DB1), body.constant(524287u));
               ir_expression *const r11F1 = nequal(r11F0, body.constant(0u));
               ir_expression *const r11F2 = logic_or(r11EF, r11F1);
               body.emit(assign(r11EB, logic_and(r11EE, r11F2), 0x01));

               ir_variable *const r11F3 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r11F4 = lshift(swizzle_y(r0DB2), body.constant(int(1)));
               ir_expression *const r11F5 = lequal(body.constant(4292870144u), r11F4);
               ir_expression *const r11F6 = nequal(swizzle_x(r0DB2), body.constant(0u));
               ir_expression *const r11F7 = bit_and(swizzle_y(r0DB2), body.constant(1048575u));
               ir_expression *const r11F8 = nequal(r11F7, body.constant(0u));
               ir_expression *const r11F9 = logic_or(r11F6, r11F8);
               body.emit(assign(r11F3, logic_and(r11F5, r11F9), 0x01));

               body.emit(assign(r11E8, bit_or(swizzle_y(r0DB1), body.constant(524288u)), 0x02));

               body.emit(assign(r11E9, bit_or(swizzle_y(r0DB2), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r11FB = lshift(swizzle_y(r0DB1), body.constant(int(1)));
               ir_expression *const r11FC = lequal(body.constant(4292870144u), r11FB);
               ir_expression *const r11FD = nequal(swizzle_x(r0DB1), body.constant(0u));
               ir_expression *const r11FE = bit_and(swizzle_y(r0DB1), body.constant(1048575u));
               ir_expression *const r11FF = nequal(r11FE, body.constant(0u));
               ir_expression *const r1200 = logic_or(r11FD, r11FF);
               ir_expression *const r1201 = logic_and(r11FC, r1200);
               ir_if *f11FA = new(mem_ctx) ir_if(operand(r1201).val);
               exec_list *const f11FA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f11FA->then_instructions;

                  ir_variable *const r1202 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1204 = logic_and(r11EB, r11F3);
                  ir_if *f1203 = new(mem_ctx) ir_if(operand(r1204).val);
                  exec_list *const f1203_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1203->then_instructions;

                     body.emit(assign(r1202, r11E9, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1203->else_instructions;

                     body.emit(assign(r1202, r11E8, 0x03));


                  body.instructions = f1203_parent_instructions;
                  body.emit(f1203);

                  /* END IF */

                  body.emit(assign(r11EA, r1202, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f11FA->else_instructions;

                  body.emit(assign(r11EA, r11E9, 0x03));


               body.instructions = f11FA_parent_instructions;
               body.emit(f11FA);

               /* END IF */

               body.emit(assign(r11D1, r11EA, 0x03));

               body.emit(assign(r11D0, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f11E5->else_instructions;

               body.emit(assign(r11D1, r0DB1, 0x03));

               body.emit(assign(r11D0, body.constant(false), 0x01));


            body.instructions = f11E5_parent_instructions;
            body.emit(f11E5);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f11E3->else_instructions;

            /* IF CONDITION */
            ir_expression *const r1206 = equal(r11DD, body.constant(int(0)));
            ir_if *f1205 = new(mem_ctx) ir_if(operand(r1206).val);
            exec_list *const f1205_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1205->then_instructions;

               body.emit(assign(r11D2, add(r11E0, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1205->else_instructions;

               body.emit(assign(r11D3, bit_or(swizzle_y(r11DC), body.constant(1048576u)), 0x02));


            body.instructions = f1205_parent_instructions;
            body.emit(f1205);

            /* END IF */

            ir_variable *const r1207 = body.make_temp(glsl_type::uint_type, "a0");
            body.emit(assign(r1207, swizzle_y(r11D3), 0x01));

            ir_variable *const r1208 = body.make_temp(glsl_type::uint_type, "a1");
            body.emit(assign(r1208, swizzle_x(r11D3), 0x01));

            ir_variable *const r1209 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r1209, body.constant(0u), 0x01));

            ir_variable *const r120A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r120A);
            ir_variable *const r120B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r120B);
            ir_variable *const r120C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r120C);
            ir_variable *const r120D = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r120E = neg(r11D2);
            body.emit(assign(r120D, bit_and(r120E, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r1210 = equal(r11D2, body.constant(int(0)));
            ir_if *f120F = new(mem_ctx) ir_if(operand(r1210).val);
            exec_list *const f120F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f120F->then_instructions;

               body.emit(assign(r120A, r1209, 0x01));

               body.emit(assign(r120B, r1208, 0x01));

               body.emit(assign(r120C, r1207, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f120F->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1212 = less(r11D2, body.constant(int(32)));
               ir_if *f1211 = new(mem_ctx) ir_if(operand(r1212).val);
               exec_list *const f1211_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1211->then_instructions;

                  body.emit(assign(r120A, lshift(swizzle_x(r11DC), r120D), 0x01));

                  ir_expression *const r1213 = lshift(swizzle_y(r11D3), r120D);
                  ir_expression *const r1214 = rshift(swizzle_x(r11DC), r11D2);
                  body.emit(assign(r120B, bit_or(r1213, r1214), 0x01));

                  body.emit(assign(r120C, rshift(swizzle_y(r11D3), r11D2), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1211->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1216 = equal(r11D2, body.constant(int(32)));
                  ir_if *f1215 = new(mem_ctx) ir_if(operand(r1216).val);
                  exec_list *const f1215_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1215->then_instructions;

                     body.emit(assign(r120A, r1208, 0x01));

                     body.emit(assign(r120B, r1207, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1215->else_instructions;

                     body.emit(assign(r1209, bit_or(body.constant(0u), swizzle_x(r11DC)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1218 = less(r11D2, body.constant(int(64)));
                     ir_if *f1217 = new(mem_ctx) ir_if(operand(r1218).val);
                     exec_list *const f1217_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1217->then_instructions;

                        body.emit(assign(r120A, lshift(swizzle_y(r11D3), r120D), 0x01));

                        ir_expression *const r1219 = bit_and(r11D2, body.constant(int(31)));
                        body.emit(assign(r120B, rshift(swizzle_y(r11D3), r1219), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1217->else_instructions;

                        ir_variable *const r121A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r121C = equal(r11D2, body.constant(int(64)));
                        ir_if *f121B = new(mem_ctx) ir_if(operand(r121C).val);
                        exec_list *const f121B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f121B->then_instructions;

                           body.emit(assign(r121A, r1207, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f121B->else_instructions;

                           ir_expression *const r121D = nequal(swizzle_y(r11D3), body.constant(0u));
                           ir_expression *const r121E = expr(ir_unop_b2i, r121D);
                           body.emit(assign(r121A, expr(ir_unop_i2u, r121E), 0x01));


                        body.instructions = f121B_parent_instructions;
                        body.emit(f121B);

                        /* END IF */

                        body.emit(assign(r120A, r121A, 0x01));

                        body.emit(assign(r120B, body.constant(0u), 0x01));


                     body.instructions = f1217_parent_instructions;
                     body.emit(f1217);

                     /* END IF */


                  body.instructions = f1215_parent_instructions;
                  body.emit(f1215);

                  /* END IF */

                  body.emit(assign(r120C, body.constant(0u), 0x01));


               body.instructions = f1211_parent_instructions;
               body.emit(f1211);

               /* END IF */

               ir_expression *const r121F = nequal(r1209, body.constant(0u));
               ir_expression *const r1220 = expr(ir_unop_b2i, r121F);
               ir_expression *const r1221 = expr(ir_unop_i2u, r1220);
               body.emit(assign(r120A, bit_or(r120A, r1221), 0x01));


            body.instructions = f120F_parent_instructions;
            body.emit(f120F);

            /* END IF */

            body.emit(assign(r11D3, r120C, 0x02));

            body.emit(assign(r11D3, r120B, 0x01));

            body.emit(assign(r11D6, r120A, 0x01));

            body.emit(assign(r11D5, r11D9, 0x01));


         body.instructions = f11E3_parent_instructions;
         body.emit(f11E3);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f11E1->else_instructions;

         /* IF CONDITION */
         ir_expression *const r1223 = less(r11D2, body.constant(int(0)));
         ir_if *f1222 = new(mem_ctx) ir_if(operand(r1223).val);
         exec_list *const f1222_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1222->then_instructions;

            /* IF CONDITION */
            ir_expression *const r1225 = equal(r11DD, body.constant(int(2047)));
            ir_if *f1224 = new(mem_ctx) ir_if(operand(r1225).val);
            exec_list *const f1224_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1224->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1227 = bit_or(swizzle_y(r11D3), swizzle_x(r11D3));
               ir_expression *const r1228 = nequal(r1227, body.constant(0u));
               ir_if *f1226 = new(mem_ctx) ir_if(operand(r1228).val);
               exec_list *const f1226_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1226->then_instructions;

                  ir_variable *const r1229 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r1229, swizzle_x(r0DB1), 0x01));

                  ir_variable *const r122A = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r122A, swizzle_x(r0DB2), 0x01));

                  ir_variable *const r122B = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r122C = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r122D = rshift(swizzle_y(r0DB1), body.constant(int(19)));
                  ir_expression *const r122E = bit_and(r122D, body.constant(4095u));
                  ir_expression *const r122F = equal(r122E, body.constant(4094u));
                  ir_expression *const r1230 = nequal(swizzle_x(r0DB1), body.constant(0u));
                  ir_expression *const r1231 = bit_and(swizzle_y(r0DB1), body.constant(524287u));
                  ir_expression *const r1232 = nequal(r1231, body.constant(0u));
                  ir_expression *const r1233 = logic_or(r1230, r1232);
                  body.emit(assign(r122C, logic_and(r122F, r1233), 0x01));

                  ir_variable *const r1234 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r1235 = lshift(swizzle_y(r0DB2), body.constant(int(1)));
                  ir_expression *const r1236 = lequal(body.constant(4292870144u), r1235);
                  ir_expression *const r1237 = nequal(swizzle_x(r0DB2), body.constant(0u));
                  ir_expression *const r1238 = bit_and(swizzle_y(r0DB2), body.constant(1048575u));
                  ir_expression *const r1239 = nequal(r1238, body.constant(0u));
                  ir_expression *const r123A = logic_or(r1237, r1239);
                  body.emit(assign(r1234, logic_and(r1236, r123A), 0x01));

                  body.emit(assign(r1229, bit_or(swizzle_y(r0DB1), body.constant(524288u)), 0x02));

                  body.emit(assign(r122A, bit_or(swizzle_y(r0DB2), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r123C = lshift(swizzle_y(r0DB1), body.constant(int(1)));
                  ir_expression *const r123D = lequal(body.constant(4292870144u), r123C);
                  ir_expression *const r123E = nequal(swizzle_x(r0DB1), body.constant(0u));
                  ir_expression *const r123F = bit_and(swizzle_y(r0DB1), body.constant(1048575u));
                  ir_expression *const r1240 = nequal(r123F, body.constant(0u));
                  ir_expression *const r1241 = logic_or(r123E, r1240);
                  ir_expression *const r1242 = logic_and(r123D, r1241);
                  ir_if *f123B = new(mem_ctx) ir_if(operand(r1242).val);
                  exec_list *const f123B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f123B->then_instructions;

                     ir_variable *const r1243 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1245 = logic_and(r122C, r1234);
                     ir_if *f1244 = new(mem_ctx) ir_if(operand(r1245).val);
                     exec_list *const f1244_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1244->then_instructions;

                        body.emit(assign(r1243, r122A, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1244->else_instructions;

                        body.emit(assign(r1243, r1229, 0x03));


                     body.instructions = f1244_parent_instructions;
                     body.emit(f1244);

                     /* END IF */

                     body.emit(assign(r122B, r1243, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f123B->else_instructions;

                     body.emit(assign(r122B, r122A, 0x03));


                  body.instructions = f123B_parent_instructions;
                  body.emit(f123B);

                  /* END IF */

                  body.emit(assign(r11D1, r122B, 0x03));

                  body.emit(assign(r11D0, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1226->else_instructions;

                  ir_variable *const r1246 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1246);
                  ir_expression *const r1247 = lshift(r0DB4, body.constant(int(31)));
                  body.emit(assign(r1246, add(r1247, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r1246, body.constant(0u), 0x01));

                  body.emit(assign(r11D1, r1246, 0x03));

                  body.emit(assign(r11D0, body.constant(false), 0x01));


               body.instructions = f1226_parent_instructions;
               body.emit(f1226);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1224->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1249 = equal(r11D9, body.constant(int(0)));
               ir_if *f1248 = new(mem_ctx) ir_if(operand(r1249).val);
               exec_list *const f1248_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1248->then_instructions;

                  body.emit(assign(r11D2, add(r11D2, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1248->else_instructions;

                  body.emit(assign(r11D4, bit_or(swizzle_y(r11D8), body.constant(1048576u)), 0x02));


               body.instructions = f1248_parent_instructions;
               body.emit(f1248);

               /* END IF */

               ir_variable *const r124A = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r124A, swizzle_y(r11D4), 0x01));

               ir_variable *const r124B = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r124B, swizzle_x(r11D4), 0x01));

               ir_variable *const r124C = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r124C, body.constant(0u), 0x01));

               ir_variable *const r124D = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r124D, neg(r11D2), 0x01));

               ir_variable *const r124E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r124E);
               ir_variable *const r124F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r124F);
               ir_variable *const r1250 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1250);
               ir_variable *const r1251 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r1252 = neg(r124D);
               body.emit(assign(r1251, bit_and(r1252, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1254 = equal(r124D, body.constant(int(0)));
               ir_if *f1253 = new(mem_ctx) ir_if(operand(r1254).val);
               exec_list *const f1253_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1253->then_instructions;

                  body.emit(assign(r124E, r124C, 0x01));

                  body.emit(assign(r124F, r124B, 0x01));

                  body.emit(assign(r1250, r124A, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1253->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1256 = less(r124D, body.constant(int(32)));
                  ir_if *f1255 = new(mem_ctx) ir_if(operand(r1256).val);
                  exec_list *const f1255_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1255->then_instructions;

                     body.emit(assign(r124E, lshift(swizzle_x(r11D8), r1251), 0x01));

                     ir_expression *const r1257 = lshift(swizzle_y(r11D4), r1251);
                     ir_expression *const r1258 = rshift(swizzle_x(r11D8), r124D);
                     body.emit(assign(r124F, bit_or(r1257, r1258), 0x01));

                     body.emit(assign(r1250, rshift(swizzle_y(r11D4), r124D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1255->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r125A = equal(r124D, body.constant(int(32)));
                     ir_if *f1259 = new(mem_ctx) ir_if(operand(r125A).val);
                     exec_list *const f1259_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1259->then_instructions;

                        body.emit(assign(r124E, r124B, 0x01));

                        body.emit(assign(r124F, r124A, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1259->else_instructions;

                        body.emit(assign(r124C, bit_or(body.constant(0u), swizzle_x(r11D8)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r125C = less(r124D, body.constant(int(64)));
                        ir_if *f125B = new(mem_ctx) ir_if(operand(r125C).val);
                        exec_list *const f125B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f125B->then_instructions;

                           body.emit(assign(r124E, lshift(swizzle_y(r11D4), r1251), 0x01));

                           ir_expression *const r125D = bit_and(r124D, body.constant(int(31)));
                           body.emit(assign(r124F, rshift(swizzle_y(r11D4), r125D), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f125B->else_instructions;

                           ir_variable *const r125E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r1260 = equal(r124D, body.constant(int(64)));
                           ir_if *f125F = new(mem_ctx) ir_if(operand(r1260).val);
                           exec_list *const f125F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f125F->then_instructions;

                              body.emit(assign(r125E, r124A, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f125F->else_instructions;

                              ir_expression *const r1261 = nequal(swizzle_y(r11D4), body.constant(0u));
                              ir_expression *const r1262 = expr(ir_unop_b2i, r1261);
                              body.emit(assign(r125E, expr(ir_unop_i2u, r1262), 0x01));


                           body.instructions = f125F_parent_instructions;
                           body.emit(f125F);

                           /* END IF */

                           body.emit(assign(r124E, r125E, 0x01));

                           body.emit(assign(r124F, body.constant(0u), 0x01));


                        body.instructions = f125B_parent_instructions;
                        body.emit(f125B);

                        /* END IF */


                     body.instructions = f1259_parent_instructions;
                     body.emit(f1259);

                     /* END IF */

                     body.emit(assign(r1250, body.constant(0u), 0x01));


                  body.instructions = f1255_parent_instructions;
                  body.emit(f1255);

                  /* END IF */

                  ir_expression *const r1263 = nequal(r124C, body.constant(0u));
                  ir_expression *const r1264 = expr(ir_unop_b2i, r1263);
                  ir_expression *const r1265 = expr(ir_unop_i2u, r1264);
                  body.emit(assign(r124E, bit_or(r124E, r1265), 0x01));


               body.instructions = f1253_parent_instructions;
               body.emit(f1253);

               /* END IF */

               body.emit(assign(r11D4, r1250, 0x02));

               body.emit(assign(r11D4, r124F, 0x01));

               body.emit(assign(r11D6, r124E, 0x01));

               body.emit(assign(r11D5, r11DD, 0x01));


            body.instructions = f1224_parent_instructions;
            body.emit(f1224);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1222->else_instructions;

            /* IF CONDITION */
            ir_expression *const r1267 = equal(r11D9, body.constant(int(2047)));
            ir_if *f1266 = new(mem_ctx) ir_if(operand(r1267).val);
            exec_list *const f1266_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1266->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1269 = bit_or(swizzle_y(r11D4), swizzle_x(r11D4));
               ir_expression *const r126A = bit_or(swizzle_y(r11D3), swizzle_x(r11D3));
               ir_expression *const r126B = bit_or(r1269, r126A);
               ir_expression *const r126C = nequal(r126B, body.constant(0u));
               ir_if *f1268 = new(mem_ctx) ir_if(operand(r126C).val);
               exec_list *const f1268_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1268->then_instructions;

                  ir_variable *const r126D = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r126D, swizzle_x(r0DB1), 0x01));

                  ir_variable *const r126E = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r126E, swizzle_x(r0DB2), 0x01));

                  ir_variable *const r126F = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r1270 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r1271 = rshift(swizzle_y(r0DB1), body.constant(int(19)));
                  ir_expression *const r1272 = bit_and(r1271, body.constant(4095u));
                  ir_expression *const r1273 = equal(r1272, body.constant(4094u));
                  ir_expression *const r1274 = nequal(swizzle_x(r0DB1), body.constant(0u));
                  ir_expression *const r1275 = bit_and(swizzle_y(r0DB1), body.constant(524287u));
                  ir_expression *const r1276 = nequal(r1275, body.constant(0u));
                  ir_expression *const r1277 = logic_or(r1274, r1276);
                  body.emit(assign(r1270, logic_and(r1273, r1277), 0x01));

                  ir_variable *const r1278 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r1279 = lshift(swizzle_y(r0DB2), body.constant(int(1)));
                  ir_expression *const r127A = lequal(body.constant(4292870144u), r1279);
                  ir_expression *const r127B = nequal(swizzle_x(r0DB2), body.constant(0u));
                  ir_expression *const r127C = bit_and(swizzle_y(r0DB2), body.constant(1048575u));
                  ir_expression *const r127D = nequal(r127C, body.constant(0u));
                  ir_expression *const r127E = logic_or(r127B, r127D);
                  body.emit(assign(r1278, logic_and(r127A, r127E), 0x01));

                  body.emit(assign(r126D, bit_or(swizzle_y(r0DB1), body.constant(524288u)), 0x02));

                  body.emit(assign(r126E, bit_or(swizzle_y(r0DB2), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r1280 = lshift(swizzle_y(r0DB1), body.constant(int(1)));
                  ir_expression *const r1281 = lequal(body.constant(4292870144u), r1280);
                  ir_expression *const r1282 = nequal(swizzle_x(r0DB1), body.constant(0u));
                  ir_expression *const r1283 = bit_and(swizzle_y(r0DB1), body.constant(1048575u));
                  ir_expression *const r1284 = nequal(r1283, body.constant(0u));
                  ir_expression *const r1285 = logic_or(r1282, r1284);
                  ir_expression *const r1286 = logic_and(r1281, r1285);
                  ir_if *f127F = new(mem_ctx) ir_if(operand(r1286).val);
                  exec_list *const f127F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f127F->then_instructions;

                     ir_variable *const r1287 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1289 = logic_and(r1270, r1278);
                     ir_if *f1288 = new(mem_ctx) ir_if(operand(r1289).val);
                     exec_list *const f1288_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1288->then_instructions;

                        body.emit(assign(r1287, r126E, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1288->else_instructions;

                        body.emit(assign(r1287, r126D, 0x03));


                     body.instructions = f1288_parent_instructions;
                     body.emit(f1288);

                     /* END IF */

                     body.emit(assign(r126F, r1287, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f127F->else_instructions;

                     body.emit(assign(r126F, r126E, 0x03));


                  body.instructions = f127F_parent_instructions;
                  body.emit(f127F);

                  /* END IF */

                  body.emit(assign(r11D1, r126F, 0x03));

                  body.emit(assign(r11D0, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1268->else_instructions;

                  body.emit(assign(r11D1, r0DB1, 0x03));

                  body.emit(assign(r11D0, body.constant(false), 0x01));


               body.instructions = f1268_parent_instructions;
               body.emit(f1268);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1266->else_instructions;

               ir_variable *const r128A = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r128B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r128B, add(swizzle_x(r11D4), swizzle_x(r11D3)), 0x01));

               ir_expression *const r128C = add(swizzle_y(r11D4), swizzle_y(r11D3));
               ir_expression *const r128D = less(r128B, swizzle_x(r11D4));
               ir_expression *const r128E = expr(ir_unop_b2i, r128D);
               ir_expression *const r128F = expr(ir_unop_i2u, r128E);
               body.emit(assign(r128A, add(r128C, r128F), 0x01));

               body.emit(assign(r11D7, r128A, 0x01));

               /* IF CONDITION */
               ir_expression *const r1291 = equal(r11D9, body.constant(int(0)));
               ir_if *f1290 = new(mem_ctx) ir_if(operand(r1291).val);
               exec_list *const f1290_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1290->then_instructions;

                  ir_variable *const r1292 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1292);
                  ir_expression *const r1293 = lshift(r0DB4, body.constant(int(31)));
                  body.emit(assign(r1292, add(r1293, r128A), 0x02));

                  body.emit(assign(r1292, r128B, 0x01));

                  body.emit(assign(r11D1, r1292, 0x03));

                  body.emit(assign(r11D0, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1290->else_instructions;

                  body.emit(assign(r11D7, bit_or(r128A, body.constant(2097152u)), 0x01));

                  body.emit(assign(r11D5, r11D9, 0x01));

                  ir_variable *const r1294 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r1294);
                  ir_variable *const r1295 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1295);
                  ir_variable *const r1296 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1296);
                  body.emit(assign(r1294, lshift(r128B, body.constant(int(31))), 0x01));

                  ir_expression *const r1297 = lshift(r11D7, body.constant(int(31)));
                  ir_expression *const r1298 = rshift(r128B, body.constant(int(1)));
                  body.emit(assign(r1295, bit_or(r1297, r1298), 0x01));

                  body.emit(assign(r1296, rshift(r11D7, body.constant(int(1))), 0x01));

                  body.emit(assign(r1294, bit_or(r1294, body.constant(0u)), 0x01));

                  body.emit(assign(r11D7, r1296, 0x01));

                  body.emit(assign(r11D6, r1294, 0x01));

                  ir_variable *const r1299 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r1299, r11D9, 0x01));

                  ir_variable *const r129A = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r129A, r1296, 0x01));

                  ir_variable *const r129B = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r129B, r1295, 0x01));

                  ir_variable *const r129C = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r129C, r1294, 0x01));

                  ir_variable *const r129D = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r129D, body.constant(true), 0x01));

                  ir_variable *const r129E = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r129F = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r129F);
                  ir_expression *const r12A0 = expr(ir_unop_u2i, r1294);
                  body.emit(assign(r129F, less(r12A0, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r12A2 = lequal(body.constant(int(2045)), r11D9);
                  ir_if *f12A1 = new(mem_ctx) ir_if(operand(r12A2).val);
                  exec_list *const f12A1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f12A1->then_instructions;

                     ir_variable *const r12A3 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r12A5 = less(body.constant(int(2045)), r11D9);
                     ir_if *f12A4 = new(mem_ctx) ir_if(operand(r12A5).val);
                     exec_list *const f12A4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f12A4->then_instructions;

                        body.emit(assign(r12A3, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f12A4->else_instructions;

                        ir_variable *const r12A6 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r12A8 = equal(r11D9, body.constant(int(2045)));
                        ir_if *f12A7 = new(mem_ctx) ir_if(operand(r12A8).val);
                        exec_list *const f12A7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f12A7->then_instructions;

                           ir_expression *const r12A9 = equal(body.constant(2097151u), r1296);
                           ir_expression *const r12AA = equal(body.constant(4294967295u), r1295);
                           body.emit(assign(r12A6, logic_and(r12A9, r12AA), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f12A7->else_instructions;

                           body.emit(assign(r12A6, body.constant(false), 0x01));


                        body.instructions = f12A7_parent_instructions;
                        body.emit(f12A7);

                        /* END IF */

                        body.emit(assign(r12A3, logic_and(r12A6, r129F), 0x01));


                     body.instructions = f12A4_parent_instructions;
                     body.emit(f12A4);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f12AB = new(mem_ctx) ir_if(operand(r12A3).val);
                     exec_list *const f12AB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f12AB->then_instructions;

                        ir_variable *const r12AC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r12AC);
                        ir_expression *const r12AD = lshift(r0DB4, body.constant(int(31)));
                        body.emit(assign(r12AC, add(r12AD, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r12AC, body.constant(0u), 0x01));

                        body.emit(assign(r129E, r12AC, 0x03));

                        body.emit(assign(r129D, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f12AB->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r12AF = less(r11D9, body.constant(int(0)));
                        ir_if *f12AE = new(mem_ctx) ir_if(operand(r12AF).val);
                        exec_list *const f12AE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f12AE->then_instructions;

                           ir_variable *const r12B0 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r12B0, r1294, 0x01));

                           ir_variable *const r12B1 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r12B1, neg(r11D9), 0x01));

                           ir_variable *const r12B2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r12B2);
                           ir_variable *const r12B3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r12B3);
                           ir_variable *const r12B4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r12B4);
                           ir_variable *const r12B5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r12B6 = neg(r12B1);
                           body.emit(assign(r12B5, bit_and(r12B6, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r12B8 = equal(r12B1, body.constant(int(0)));
                           ir_if *f12B7 = new(mem_ctx) ir_if(operand(r12B8).val);
                           exec_list *const f12B7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f12B7->then_instructions;

                              body.emit(assign(r12B2, r1294, 0x01));

                              body.emit(assign(r12B3, r1295, 0x01));

                              body.emit(assign(r12B4, r1296, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f12B7->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r12BA = less(r12B1, body.constant(int(32)));
                              ir_if *f12B9 = new(mem_ctx) ir_if(operand(r12BA).val);
                              exec_list *const f12B9_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f12B9->then_instructions;

                                 body.emit(assign(r12B2, lshift(r1295, r12B5), 0x01));

                                 ir_expression *const r12BB = lshift(r1296, r12B5);
                                 ir_expression *const r12BC = rshift(r1295, r12B1);
                                 body.emit(assign(r12B3, bit_or(r12BB, r12BC), 0x01));

                                 body.emit(assign(r12B4, rshift(r1296, r12B1), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f12B9->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r12BE = equal(r12B1, body.constant(int(32)));
                                 ir_if *f12BD = new(mem_ctx) ir_if(operand(r12BE).val);
                                 exec_list *const f12BD_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f12BD->then_instructions;

                                    body.emit(assign(r12B2, r1295, 0x01));

                                    body.emit(assign(r12B3, r1296, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f12BD->else_instructions;

                                    body.emit(assign(r12B0, bit_or(r1294, r1295), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r12C0 = less(r12B1, body.constant(int(64)));
                                    ir_if *f12BF = new(mem_ctx) ir_if(operand(r12C0).val);
                                    exec_list *const f12BF_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f12BF->then_instructions;

                                       body.emit(assign(r12B2, lshift(r1296, r12B5), 0x01));

                                       ir_expression *const r12C1 = bit_and(r12B1, body.constant(int(31)));
                                       body.emit(assign(r12B3, rshift(r1296, r12C1), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f12BF->else_instructions;

                                       ir_variable *const r12C2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r12C4 = equal(r12B1, body.constant(int(64)));
                                       ir_if *f12C3 = new(mem_ctx) ir_if(operand(r12C4).val);
                                       exec_list *const f12C3_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f12C3->then_instructions;

                                          body.emit(assign(r12C2, r1296, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f12C3->else_instructions;

                                          ir_expression *const r12C5 = nequal(r1296, body.constant(0u));
                                          ir_expression *const r12C6 = expr(ir_unop_b2i, r12C5);
                                          body.emit(assign(r12C2, expr(ir_unop_i2u, r12C6), 0x01));


                                       body.instructions = f12C3_parent_instructions;
                                       body.emit(f12C3);

                                       /* END IF */

                                       body.emit(assign(r12B2, r12C2, 0x01));

                                       body.emit(assign(r12B3, body.constant(0u), 0x01));


                                    body.instructions = f12BF_parent_instructions;
                                    body.emit(f12BF);

                                    /* END IF */


                                 body.instructions = f12BD_parent_instructions;
                                 body.emit(f12BD);

                                 /* END IF */

                                 body.emit(assign(r12B4, body.constant(0u), 0x01));


                              body.instructions = f12B9_parent_instructions;
                              body.emit(f12B9);

                              /* END IF */

                              ir_expression *const r12C7 = nequal(r12B0, body.constant(0u));
                              ir_expression *const r12C8 = expr(ir_unop_b2i, r12C7);
                              ir_expression *const r12C9 = expr(ir_unop_i2u, r12C8);
                              body.emit(assign(r12B2, bit_or(r12B2, r12C9), 0x01));


                           body.instructions = f12B7_parent_instructions;
                           body.emit(f12B7);

                           /* END IF */

                           body.emit(assign(r129A, r12B4, 0x01));

                           body.emit(assign(r129B, r12B3, 0x01));

                           body.emit(assign(r129C, r12B2, 0x01));

                           body.emit(assign(r1299, body.constant(int(0)), 0x01));

                           body.emit(assign(r129F, less(r12B2, body.constant(0u)), 0x01));


                        body.instructions = f12AE_parent_instructions;
                        body.emit(f12AE);

                        /* END IF */


                     body.instructions = f12AB_parent_instructions;
                     body.emit(f12AB);

                     /* END IF */


                  body.instructions = f12A1_parent_instructions;
                  body.emit(f12A1);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f12CA = new(mem_ctx) ir_if(operand(r129D).val);
                  exec_list *const f12CA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f12CA->then_instructions;

                     /* IF CONDITION */
                     ir_if *f12CB = new(mem_ctx) ir_if(operand(r129F).val);
                     exec_list *const f12CB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f12CB->then_instructions;

                        ir_variable *const r12CC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r12CC, add(r129B, body.constant(1u)), 0x01));

                        ir_expression *const r12CD = less(r12CC, r129B);
                        ir_expression *const r12CE = expr(ir_unop_b2i, r12CD);
                        ir_expression *const r12CF = expr(ir_unop_i2u, r12CE);
                        body.emit(assign(r129A, add(r129A, r12CF), 0x01));

                        ir_expression *const r12D0 = equal(r129C, body.constant(0u));
                        ir_expression *const r12D1 = expr(ir_unop_b2i, r12D0);
                        ir_expression *const r12D2 = expr(ir_unop_i2u, r12D1);
                        ir_expression *const r12D3 = add(r129C, r12D2);
                        ir_expression *const r12D4 = bit_and(r12D3, body.constant(1u));
                        ir_expression *const r12D5 = expr(ir_unop_bit_not, r12D4);
                        body.emit(assign(r129B, bit_and(r12CC, r12D5), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f12CB->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r12D7 = bit_or(r129A, r129B);
                        ir_expression *const r12D8 = equal(r12D7, body.constant(0u));
                        ir_if *f12D6 = new(mem_ctx) ir_if(operand(r12D8).val);
                        exec_list *const f12D6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f12D6->then_instructions;

                           body.emit(assign(r1299, body.constant(int(0)), 0x01));


                        body.instructions = f12D6_parent_instructions;
                        body.emit(f12D6);

                        /* END IF */


                     body.instructions = f12CB_parent_instructions;
                     body.emit(f12CB);

                     /* END IF */

                     ir_variable *const r12D9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r12D9);
                     ir_expression *const r12DA = lshift(r0DB4, body.constant(int(31)));
                     ir_expression *const r12DB = expr(ir_unop_i2u, r1299);
                     ir_expression *const r12DC = lshift(r12DB, body.constant(int(20)));
                     ir_expression *const r12DD = add(r12DA, r12DC);
                     body.emit(assign(r12D9, add(r12DD, r129A), 0x02));

                     body.emit(assign(r12D9, r129B, 0x01));

                     body.emit(assign(r129E, r12D9, 0x03));

                     body.emit(assign(r129D, body.constant(false), 0x01));


                  body.instructions = f12CA_parent_instructions;
                  body.emit(f12CA);

                  /* END IF */

                  body.emit(assign(r11D1, r129E, 0x03));

                  body.emit(assign(r11D0, body.constant(false), 0x01));


               body.instructions = f1290_parent_instructions;
               body.emit(f1290);

               /* END IF */


            body.instructions = f1266_parent_instructions;
            body.emit(f1266);

            /* END IF */


         body.instructions = f1222_parent_instructions;
         body.emit(f1222);

         /* END IF */


      body.instructions = f11E1_parent_instructions;
      body.emit(f11E1);

      /* END IF */

      /* IF CONDITION */
      ir_if *f12DE = new(mem_ctx) ir_if(operand(r11D0).val);
      exec_list *const f12DE_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f12DE->then_instructions;

         body.emit(assign(r11D4, bit_or(swizzle_y(r11D4), body.constant(1048576u)), 0x02));

         ir_variable *const r12DF = body.make_temp(glsl_type::uint_type, "z0Ptr");
         ir_variable *const r12E0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r12E0, add(swizzle_x(r11D4), swizzle_x(r11D3)), 0x01));

         ir_expression *const r12E1 = add(swizzle_y(r11D4), swizzle_y(r11D3));
         ir_expression *const r12E2 = less(r12E0, swizzle_x(r11D4));
         ir_expression *const r12E3 = expr(ir_unop_b2i, r12E2);
         ir_expression *const r12E4 = expr(ir_unop_i2u, r12E3);
         body.emit(assign(r12DF, add(r12E1, r12E4), 0x01));

         body.emit(assign(r11D7, r12DF, 0x01));

         body.emit(assign(r11D5, add(r11D5, body.constant(int(-1))), 0x01));

         /* IF CONDITION */
         ir_expression *const r12E6 = less(r12DF, body.constant(2097152u));
         ir_if *f12E5 = new(mem_ctx) ir_if(operand(r12E6).val);
         exec_list *const f12E5_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f12E5->then_instructions;

            ir_variable *const r12E7 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r12E7, r11D5, 0x01));

            ir_variable *const r12E8 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r12E8, r12DF, 0x01));

            ir_variable *const r12E9 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r12E9, r12E0, 0x01));

            ir_variable *const r12EA = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r12EA, r11D6, 0x01));

            ir_variable *const r12EB = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r12EB, body.constant(true), 0x01));

            ir_variable *const r12EC = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r12ED = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r12ED);
            ir_expression *const r12EE = expr(ir_unop_u2i, r11D6);
            body.emit(assign(r12ED, less(r12EE, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r12F0 = lequal(body.constant(int(2045)), r11D5);
            ir_if *f12EF = new(mem_ctx) ir_if(operand(r12F0).val);
            exec_list *const f12EF_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f12EF->then_instructions;

               ir_variable *const r12F1 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r12F3 = less(body.constant(int(2045)), r11D5);
               ir_if *f12F2 = new(mem_ctx) ir_if(operand(r12F3).val);
               exec_list *const f12F2_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f12F2->then_instructions;

                  body.emit(assign(r12F1, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f12F2->else_instructions;

                  ir_variable *const r12F4 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r12F6 = equal(r11D5, body.constant(int(2045)));
                  ir_if *f12F5 = new(mem_ctx) ir_if(operand(r12F6).val);
                  exec_list *const f12F5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f12F5->then_instructions;

                     ir_expression *const r12F7 = equal(body.constant(2097151u), r12DF);
                     ir_expression *const r12F8 = equal(body.constant(4294967295u), r12E0);
                     body.emit(assign(r12F4, logic_and(r12F7, r12F8), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f12F5->else_instructions;

                     body.emit(assign(r12F4, body.constant(false), 0x01));


                  body.instructions = f12F5_parent_instructions;
                  body.emit(f12F5);

                  /* END IF */

                  body.emit(assign(r12F1, logic_and(r12F4, r12ED), 0x01));


               body.instructions = f12F2_parent_instructions;
               body.emit(f12F2);

               /* END IF */

               /* IF CONDITION */
               ir_if *f12F9 = new(mem_ctx) ir_if(operand(r12F1).val);
               exec_list *const f12F9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f12F9->then_instructions;

                  ir_variable *const r12FA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r12FA);
                  ir_expression *const r12FB = lshift(r0DB4, body.constant(int(31)));
                  body.emit(assign(r12FA, add(r12FB, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r12FA, body.constant(0u), 0x01));

                  body.emit(assign(r12EC, r12FA, 0x03));

                  body.emit(assign(r12EB, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f12F9->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r12FD = less(r11D5, body.constant(int(0)));
                  ir_if *f12FC = new(mem_ctx) ir_if(operand(r12FD).val);
                  exec_list *const f12FC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f12FC->then_instructions;

                     ir_variable *const r12FE = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r12FE, r11D6, 0x01));

                     ir_variable *const r12FF = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r12FF, neg(r11D5), 0x01));

                     ir_variable *const r1300 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r1300);
                     ir_variable *const r1301 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r1301);
                     ir_variable *const r1302 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r1302);
                     ir_variable *const r1303 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r1304 = neg(r12FF);
                     body.emit(assign(r1303, bit_and(r1304, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1306 = equal(r12FF, body.constant(int(0)));
                     ir_if *f1305 = new(mem_ctx) ir_if(operand(r1306).val);
                     exec_list *const f1305_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1305->then_instructions;

                        body.emit(assign(r1300, r11D6, 0x01));

                        body.emit(assign(r1301, r12E0, 0x01));

                        body.emit(assign(r1302, r12DF, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1305->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1308 = less(r12FF, body.constant(int(32)));
                        ir_if *f1307 = new(mem_ctx) ir_if(operand(r1308).val);
                        exec_list *const f1307_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1307->then_instructions;

                           body.emit(assign(r1300, lshift(r12E0, r1303), 0x01));

                           ir_expression *const r1309 = lshift(r12DF, r1303);
                           ir_expression *const r130A = rshift(r12E0, r12FF);
                           body.emit(assign(r1301, bit_or(r1309, r130A), 0x01));

                           body.emit(assign(r1302, rshift(r12DF, r12FF), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1307->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r130C = equal(r12FF, body.constant(int(32)));
                           ir_if *f130B = new(mem_ctx) ir_if(operand(r130C).val);
                           exec_list *const f130B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f130B->then_instructions;

                              body.emit(assign(r1300, r12E0, 0x01));

                              body.emit(assign(r1301, r12DF, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f130B->else_instructions;

                              body.emit(assign(r12FE, bit_or(r11D6, r12E0), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r130E = less(r12FF, body.constant(int(64)));
                              ir_if *f130D = new(mem_ctx) ir_if(operand(r130E).val);
                              exec_list *const f130D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f130D->then_instructions;

                                 body.emit(assign(r1300, lshift(r12DF, r1303), 0x01));

                                 ir_expression *const r130F = bit_and(r12FF, body.constant(int(31)));
                                 body.emit(assign(r1301, rshift(r12DF, r130F), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f130D->else_instructions;

                                 ir_variable *const r1310 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r1312 = equal(r12FF, body.constant(int(64)));
                                 ir_if *f1311 = new(mem_ctx) ir_if(operand(r1312).val);
                                 exec_list *const f1311_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1311->then_instructions;

                                    body.emit(assign(r1310, r12DF, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1311->else_instructions;

                                    ir_expression *const r1313 = nequal(r12DF, body.constant(0u));
                                    ir_expression *const r1314 = expr(ir_unop_b2i, r1313);
                                    body.emit(assign(r1310, expr(ir_unop_i2u, r1314), 0x01));


                                 body.instructions = f1311_parent_instructions;
                                 body.emit(f1311);

                                 /* END IF */

                                 body.emit(assign(r1300, r1310, 0x01));

                                 body.emit(assign(r1301, body.constant(0u), 0x01));


                              body.instructions = f130D_parent_instructions;
                              body.emit(f130D);

                              /* END IF */


                           body.instructions = f130B_parent_instructions;
                           body.emit(f130B);

                           /* END IF */

                           body.emit(assign(r1302, body.constant(0u), 0x01));


                        body.instructions = f1307_parent_instructions;
                        body.emit(f1307);

                        /* END IF */

                        ir_expression *const r1315 = nequal(r12FE, body.constant(0u));
                        ir_expression *const r1316 = expr(ir_unop_b2i, r1315);
                        ir_expression *const r1317 = expr(ir_unop_i2u, r1316);
                        body.emit(assign(r1300, bit_or(r1300, r1317), 0x01));


                     body.instructions = f1305_parent_instructions;
                     body.emit(f1305);

                     /* END IF */

                     body.emit(assign(r12E8, r1302, 0x01));

                     body.emit(assign(r12E9, r1301, 0x01));

                     body.emit(assign(r12EA, r1300, 0x01));

                     body.emit(assign(r12E7, body.constant(int(0)), 0x01));

                     body.emit(assign(r12ED, less(r1300, body.constant(0u)), 0x01));


                  body.instructions = f12FC_parent_instructions;
                  body.emit(f12FC);

                  /* END IF */


               body.instructions = f12F9_parent_instructions;
               body.emit(f12F9);

               /* END IF */


            body.instructions = f12EF_parent_instructions;
            body.emit(f12EF);

            /* END IF */

            /* IF CONDITION */
            ir_if *f1318 = new(mem_ctx) ir_if(operand(r12EB).val);
            exec_list *const f1318_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1318->then_instructions;

               /* IF CONDITION */
               ir_if *f1319 = new(mem_ctx) ir_if(operand(r12ED).val);
               exec_list *const f1319_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1319->then_instructions;

                  ir_variable *const r131A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r131A, add(r12E9, body.constant(1u)), 0x01));

                  ir_expression *const r131B = less(r131A, r12E9);
                  ir_expression *const r131C = expr(ir_unop_b2i, r131B);
                  ir_expression *const r131D = expr(ir_unop_i2u, r131C);
                  body.emit(assign(r12E8, add(r12E8, r131D), 0x01));

                  ir_expression *const r131E = equal(r12EA, body.constant(0u));
                  ir_expression *const r131F = expr(ir_unop_b2i, r131E);
                  ir_expression *const r1320 = expr(ir_unop_i2u, r131F);
                  ir_expression *const r1321 = add(r12EA, r1320);
                  ir_expression *const r1322 = bit_and(r1321, body.constant(1u));
                  ir_expression *const r1323 = expr(ir_unop_bit_not, r1322);
                  body.emit(assign(r12E9, bit_and(r131A, r1323), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1319->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1325 = bit_or(r12E8, r12E9);
                  ir_expression *const r1326 = equal(r1325, body.constant(0u));
                  ir_if *f1324 = new(mem_ctx) ir_if(operand(r1326).val);
                  exec_list *const f1324_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1324->then_instructions;

                     body.emit(assign(r12E7, body.constant(int(0)), 0x01));


                  body.instructions = f1324_parent_instructions;
                  body.emit(f1324);

                  /* END IF */


               body.instructions = f1319_parent_instructions;
               body.emit(f1319);

               /* END IF */

               ir_variable *const r1327 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r1327);
               ir_expression *const r1328 = lshift(r0DB4, body.constant(int(31)));
               ir_expression *const r1329 = expr(ir_unop_i2u, r12E7);
               ir_expression *const r132A = lshift(r1329, body.constant(int(20)));
               ir_expression *const r132B = add(r1328, r132A);
               body.emit(assign(r1327, add(r132B, r12E8), 0x02));

               body.emit(assign(r1327, r12E9, 0x01));

               body.emit(assign(r12EC, r1327, 0x03));

               body.emit(assign(r12EB, body.constant(false), 0x01));


            body.instructions = f1318_parent_instructions;
            body.emit(f1318);

            /* END IF */

            body.emit(assign(r11D1, r12EC, 0x03));

            body.emit(assign(r11D0, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f12E5->else_instructions;

            body.emit(assign(r11D5, add(r11D5, body.constant(int(1))), 0x01));

            ir_variable *const r132C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r132C);
            ir_variable *const r132D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r132D);
            ir_variable *const r132E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r132E);
            body.emit(assign(r132C, lshift(r12E0, body.constant(int(31))), 0x01));

            ir_expression *const r132F = lshift(r12DF, body.constant(int(31)));
            ir_expression *const r1330 = rshift(r12E0, body.constant(int(1)));
            body.emit(assign(r132D, bit_or(r132F, r1330), 0x01));

            body.emit(assign(r132E, rshift(r12DF, body.constant(int(1))), 0x01));

            ir_expression *const r1331 = nequal(r11D6, body.constant(0u));
            ir_expression *const r1332 = expr(ir_unop_b2i, r1331);
            ir_expression *const r1333 = expr(ir_unop_i2u, r1332);
            body.emit(assign(r132C, bit_or(r132C, r1333), 0x01));

            body.emit(assign(r11D7, r132E, 0x01));

            body.emit(assign(r11D6, r132C, 0x01));

            ir_variable *const r1334 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r1334, r11D5, 0x01));

            ir_variable *const r1335 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r1335, r132E, 0x01));

            ir_variable *const r1336 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r1336, r132D, 0x01));

            ir_variable *const r1337 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r1337, r132C, 0x01));

            ir_variable *const r1338 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r1338, body.constant(true), 0x01));

            ir_variable *const r1339 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r133A = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r133A);
            ir_expression *const r133B = expr(ir_unop_u2i, r132C);
            body.emit(assign(r133A, less(r133B, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r133D = lequal(body.constant(int(2045)), r11D5);
            ir_if *f133C = new(mem_ctx) ir_if(operand(r133D).val);
            exec_list *const f133C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f133C->then_instructions;

               ir_variable *const r133E = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r1340 = less(body.constant(int(2045)), r11D5);
               ir_if *f133F = new(mem_ctx) ir_if(operand(r1340).val);
               exec_list *const f133F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f133F->then_instructions;

                  body.emit(assign(r133E, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f133F->else_instructions;

                  ir_variable *const r1341 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1343 = equal(r11D5, body.constant(int(2045)));
                  ir_if *f1342 = new(mem_ctx) ir_if(operand(r1343).val);
                  exec_list *const f1342_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1342->then_instructions;

                     ir_expression *const r1344 = equal(body.constant(2097151u), r132E);
                     ir_expression *const r1345 = equal(body.constant(4294967295u), r132D);
                     body.emit(assign(r1341, logic_and(r1344, r1345), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1342->else_instructions;

                     body.emit(assign(r1341, body.constant(false), 0x01));


                  body.instructions = f1342_parent_instructions;
                  body.emit(f1342);

                  /* END IF */

                  body.emit(assign(r133E, logic_and(r1341, r133A), 0x01));


               body.instructions = f133F_parent_instructions;
               body.emit(f133F);

               /* END IF */

               /* IF CONDITION */
               ir_if *f1346 = new(mem_ctx) ir_if(operand(r133E).val);
               exec_list *const f1346_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1346->then_instructions;

                  ir_variable *const r1347 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1347);
                  ir_expression *const r1348 = lshift(r0DB4, body.constant(int(31)));
                  body.emit(assign(r1347, add(r1348, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r1347, body.constant(0u), 0x01));

                  body.emit(assign(r1339, r1347, 0x03));

                  body.emit(assign(r1338, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1346->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r134A = less(r11D5, body.constant(int(0)));
                  ir_if *f1349 = new(mem_ctx) ir_if(operand(r134A).val);
                  exec_list *const f1349_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1349->then_instructions;

                     ir_variable *const r134B = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r134B, r132C, 0x01));

                     ir_variable *const r134C = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r134C, neg(r11D5), 0x01));

                     ir_variable *const r134D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r134D);
                     ir_variable *const r134E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r134E);
                     ir_variable *const r134F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r134F);
                     ir_variable *const r1350 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r1351 = neg(r134C);
                     body.emit(assign(r1350, bit_and(r1351, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1353 = equal(r134C, body.constant(int(0)));
                     ir_if *f1352 = new(mem_ctx) ir_if(operand(r1353).val);
                     exec_list *const f1352_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1352->then_instructions;

                        body.emit(assign(r134D, r132C, 0x01));

                        body.emit(assign(r134E, r132D, 0x01));

                        body.emit(assign(r134F, r132E, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1352->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1355 = less(r134C, body.constant(int(32)));
                        ir_if *f1354 = new(mem_ctx) ir_if(operand(r1355).val);
                        exec_list *const f1354_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1354->then_instructions;

                           body.emit(assign(r134D, lshift(r132D, r1350), 0x01));

                           ir_expression *const r1356 = lshift(r132E, r1350);
                           ir_expression *const r1357 = rshift(r132D, r134C);
                           body.emit(assign(r134E, bit_or(r1356, r1357), 0x01));

                           body.emit(assign(r134F, rshift(r132E, r134C), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1354->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1359 = equal(r134C, body.constant(int(32)));
                           ir_if *f1358 = new(mem_ctx) ir_if(operand(r1359).val);
                           exec_list *const f1358_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1358->then_instructions;

                              body.emit(assign(r134D, r132D, 0x01));

                              body.emit(assign(r134E, r132E, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1358->else_instructions;

                              body.emit(assign(r134B, bit_or(r132C, r132D), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r135B = less(r134C, body.constant(int(64)));
                              ir_if *f135A = new(mem_ctx) ir_if(operand(r135B).val);
                              exec_list *const f135A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f135A->then_instructions;

                                 body.emit(assign(r134D, lshift(r132E, r1350), 0x01));

                                 ir_expression *const r135C = bit_and(r134C, body.constant(int(31)));
                                 body.emit(assign(r134E, rshift(r132E, r135C), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f135A->else_instructions;

                                 ir_variable *const r135D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r135F = equal(r134C, body.constant(int(64)));
                                 ir_if *f135E = new(mem_ctx) ir_if(operand(r135F).val);
                                 exec_list *const f135E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f135E->then_instructions;

                                    body.emit(assign(r135D, r132E, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f135E->else_instructions;

                                    ir_expression *const r1360 = nequal(r132E, body.constant(0u));
                                    ir_expression *const r1361 = expr(ir_unop_b2i, r1360);
                                    body.emit(assign(r135D, expr(ir_unop_i2u, r1361), 0x01));


                                 body.instructions = f135E_parent_instructions;
                                 body.emit(f135E);

                                 /* END IF */

                                 body.emit(assign(r134D, r135D, 0x01));

                                 body.emit(assign(r134E, body.constant(0u), 0x01));


                              body.instructions = f135A_parent_instructions;
                              body.emit(f135A);

                              /* END IF */


                           body.instructions = f1358_parent_instructions;
                           body.emit(f1358);

                           /* END IF */

                           body.emit(assign(r134F, body.constant(0u), 0x01));


                        body.instructions = f1354_parent_instructions;
                        body.emit(f1354);

                        /* END IF */

                        ir_expression *const r1362 = nequal(r134B, body.constant(0u));
                        ir_expression *const r1363 = expr(ir_unop_b2i, r1362);
                        ir_expression *const r1364 = expr(ir_unop_i2u, r1363);
                        body.emit(assign(r134D, bit_or(r134D, r1364), 0x01));


                     body.instructions = f1352_parent_instructions;
                     body.emit(f1352);

                     /* END IF */

                     body.emit(assign(r1335, r134F, 0x01));

                     body.emit(assign(r1336, r134E, 0x01));

                     body.emit(assign(r1337, r134D, 0x01));

                     body.emit(assign(r1334, body.constant(int(0)), 0x01));

                     body.emit(assign(r133A, less(r134D, body.constant(0u)), 0x01));


                  body.instructions = f1349_parent_instructions;
                  body.emit(f1349);

                  /* END IF */


               body.instructions = f1346_parent_instructions;
               body.emit(f1346);

               /* END IF */


            body.instructions = f133C_parent_instructions;
            body.emit(f133C);

            /* END IF */

            /* IF CONDITION */
            ir_if *f1365 = new(mem_ctx) ir_if(operand(r1338).val);
            exec_list *const f1365_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1365->then_instructions;

               /* IF CONDITION */
               ir_if *f1366 = new(mem_ctx) ir_if(operand(r133A).val);
               exec_list *const f1366_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1366->then_instructions;

                  ir_variable *const r1367 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1367, add(r1336, body.constant(1u)), 0x01));

                  ir_expression *const r1368 = less(r1367, r1336);
                  ir_expression *const r1369 = expr(ir_unop_b2i, r1368);
                  ir_expression *const r136A = expr(ir_unop_i2u, r1369);
                  body.emit(assign(r1335, add(r1335, r136A), 0x01));

                  ir_expression *const r136B = equal(r1337, body.constant(0u));
                  ir_expression *const r136C = expr(ir_unop_b2i, r136B);
                  ir_expression *const r136D = expr(ir_unop_i2u, r136C);
                  ir_expression *const r136E = add(r1337, r136D);
                  ir_expression *const r136F = bit_and(r136E, body.constant(1u));
                  ir_expression *const r1370 = expr(ir_unop_bit_not, r136F);
                  body.emit(assign(r1336, bit_and(r1367, r1370), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1366->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1372 = bit_or(r1335, r1336);
                  ir_expression *const r1373 = equal(r1372, body.constant(0u));
                  ir_if *f1371 = new(mem_ctx) ir_if(operand(r1373).val);
                  exec_list *const f1371_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1371->then_instructions;

                     body.emit(assign(r1334, body.constant(int(0)), 0x01));


                  body.instructions = f1371_parent_instructions;
                  body.emit(f1371);

                  /* END IF */


               body.instructions = f1366_parent_instructions;
               body.emit(f1366);

               /* END IF */

               ir_variable *const r1374 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r1374);
               ir_expression *const r1375 = lshift(r0DB4, body.constant(int(31)));
               ir_expression *const r1376 = expr(ir_unop_i2u, r1334);
               ir_expression *const r1377 = lshift(r1376, body.constant(int(20)));
               ir_expression *const r1378 = add(r1375, r1377);
               body.emit(assign(r1374, add(r1378, r1335), 0x02));

               body.emit(assign(r1374, r1336, 0x01));

               body.emit(assign(r1339, r1374, 0x03));

               body.emit(assign(r1338, body.constant(false), 0x01));


            body.instructions = f1365_parent_instructions;
            body.emit(f1365);

            /* END IF */

            body.emit(assign(r11D1, r1339, 0x03));

            body.emit(assign(r11D0, body.constant(false), 0x01));


         body.instructions = f12E5_parent_instructions;
         body.emit(f12E5);

         /* END IF */


      body.instructions = f12DE_parent_instructions;
      body.emit(f12DE);

      /* END IF */

      body.emit(assign(r0DB3, r11D1, 0x03));


   body.instructions = f0DB6_parent_instructions;
   body.emit(f0DB6);

   /* END IF */

   body.emit(ret(r0DB3));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
mul32To64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1379 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1379);
   ir_variable *const r137A = new(mem_ctx) ir_variable(glsl_type::uint_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r137A);
   ir_variable *const r137B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r137B);
   ir_variable *const r137C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r137C);
   ir_variable *const r137D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r137D);
   ir_variable *const r137E = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r137E);
   ir_variable *const r137F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r137F);
   ir_variable *const r1380 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1380, bit_and(r1379, body.constant(65535u)), 0x01));

   ir_variable *const r1381 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1381, rshift(r1379, body.constant(int(16))), 0x01));

   ir_variable *const r1382 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1382, bit_and(r137A, body.constant(65535u)), 0x01));

   ir_variable *const r1383 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1383, rshift(r137A, body.constant(int(16))), 0x01));

   ir_variable *const r1384 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1384, mul(r1381, r1382), 0x01));

   ir_expression *const r1385 = mul(r1380, r1383);
   body.emit(assign(r137E, add(r1385, r1384), 0x01));

   ir_expression *const r1386 = mul(r1381, r1383);
   ir_expression *const r1387 = less(r137E, r1384);
   ir_expression *const r1388 = expr(ir_unop_b2i, r1387);
   ir_expression *const r1389 = expr(ir_unop_i2u, r1388);
   ir_expression *const r138A = lshift(r1389, body.constant(int(16)));
   ir_expression *const r138B = rshift(r137E, body.constant(int(16)));
   ir_expression *const r138C = add(r138A, r138B);
   body.emit(assign(r137D, add(r1386, r138C), 0x01));

   body.emit(assign(r137E, lshift(r137E, body.constant(int(16))), 0x01));

   ir_expression *const r138D = mul(r1380, r1382);
   body.emit(assign(r137F, add(r138D, r137E), 0x01));

   ir_expression *const r138E = less(r137F, r137E);
   ir_expression *const r138F = expr(ir_unop_b2i, r138E);
   ir_expression *const r1390 = expr(ir_unop_i2u, r138F);
   body.emit(assign(r137D, add(r137D, r1390), 0x01));

   body.emit(assign(r137C, r137F, 0x01));

   body.emit(assign(r137B, r137D, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
mul64To128(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1391 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r1391);
   ir_variable *const r1392 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r1392);
   ir_variable *const r1393 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r1393);
   ir_variable *const r1394 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r1394);
   ir_variable *const r1395 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1395);
   ir_variable *const r1396 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1396);
   ir_variable *const r1397 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1397);
   ir_variable *const r1398 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z3Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1398);
   ir_variable *const r1399 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r1399);
   ir_variable *const r139A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r139A);
   ir_variable *const r139B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r139B);
   ir_variable *const r139C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r139C, bit_and(r1392, body.constant(65535u)), 0x01));

   ir_variable *const r139D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r139D, rshift(r1392, body.constant(int(16))), 0x01));

   ir_variable *const r139E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r139E, bit_and(r1394, body.constant(65535u)), 0x01));

   ir_variable *const r139F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r139F, rshift(r1394, body.constant(int(16))), 0x01));

   ir_variable *const r13A0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13A0, mul(r139D, r139E), 0x01));

   ir_expression *const r13A1 = mul(r139C, r139F);
   body.emit(assign(r139A, add(r13A1, r13A0), 0x01));

   ir_expression *const r13A2 = mul(r139D, r139F);
   ir_expression *const r13A3 = less(r139A, r13A0);
   ir_expression *const r13A4 = expr(ir_unop_b2i, r13A3);
   ir_expression *const r13A5 = expr(ir_unop_i2u, r13A4);
   ir_expression *const r13A6 = lshift(r13A5, body.constant(int(16)));
   ir_expression *const r13A7 = rshift(r139A, body.constant(int(16)));
   ir_expression *const r13A8 = add(r13A6, r13A7);
   body.emit(assign(r1399, add(r13A2, r13A8), 0x01));

   body.emit(assign(r139A, lshift(r139A, body.constant(int(16))), 0x01));

   ir_expression *const r13A9 = mul(r139C, r139E);
   body.emit(assign(r139B, add(r13A9, r139A), 0x01));

   ir_expression *const r13AA = less(r139B, r139A);
   ir_expression *const r13AB = expr(ir_unop_b2i, r13AA);
   ir_expression *const r13AC = expr(ir_unop_i2u, r13AB);
   body.emit(assign(r1399, add(r1399, r13AC), 0x01));

   ir_variable *const r13AD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r13AD);
   ir_variable *const r13AE = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r13AE);
   ir_variable *const r13AF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r13AF);
   ir_variable *const r13B0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13B0, bit_and(r1392, body.constant(65535u)), 0x01));

   ir_variable *const r13B1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13B1, rshift(r1392, body.constant(int(16))), 0x01));

   ir_variable *const r13B2 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13B2, bit_and(r1393, body.constant(65535u)), 0x01));

   ir_variable *const r13B3 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13B3, rshift(r1393, body.constant(int(16))), 0x01));

   ir_variable *const r13B4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13B4, mul(r13B1, r13B2), 0x01));

   ir_expression *const r13B5 = mul(r13B0, r13B3);
   body.emit(assign(r13AE, add(r13B5, r13B4), 0x01));

   ir_expression *const r13B6 = mul(r13B1, r13B3);
   ir_expression *const r13B7 = less(r13AE, r13B4);
   ir_expression *const r13B8 = expr(ir_unop_b2i, r13B7);
   ir_expression *const r13B9 = expr(ir_unop_i2u, r13B8);
   ir_expression *const r13BA = lshift(r13B9, body.constant(int(16)));
   ir_expression *const r13BB = rshift(r13AE, body.constant(int(16)));
   ir_expression *const r13BC = add(r13BA, r13BB);
   body.emit(assign(r13AD, add(r13B6, r13BC), 0x01));

   body.emit(assign(r13AE, lshift(r13AE, body.constant(int(16))), 0x01));

   ir_expression *const r13BD = mul(r13B0, r13B2);
   body.emit(assign(r13AF, add(r13BD, r13AE), 0x01));

   ir_expression *const r13BE = less(r13AF, r13AE);
   ir_expression *const r13BF = expr(ir_unop_b2i, r13BE);
   ir_expression *const r13C0 = expr(ir_unop_i2u, r13BF);
   body.emit(assign(r13AD, add(r13AD, r13C0), 0x01));

   ir_variable *const r13C1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13C1, add(r13AF, r1399), 0x01));

   ir_variable *const r13C2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r13C2);
   ir_variable *const r13C3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r13C3);
   ir_variable *const r13C4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r13C4);
   ir_variable *const r13C5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13C5, bit_and(r1391, body.constant(65535u)), 0x01));

   ir_variable *const r13C6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13C6, rshift(r1391, body.constant(int(16))), 0x01));

   ir_variable *const r13C7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13C7, bit_and(r1393, body.constant(65535u)), 0x01));

   ir_variable *const r13C8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13C8, rshift(r1393, body.constant(int(16))), 0x01));

   ir_variable *const r13C9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13C9, mul(r13C6, r13C7), 0x01));

   ir_expression *const r13CA = mul(r13C5, r13C8);
   body.emit(assign(r13C3, add(r13CA, r13C9), 0x01));

   ir_expression *const r13CB = mul(r13C6, r13C8);
   ir_expression *const r13CC = less(r13C3, r13C9);
   ir_expression *const r13CD = expr(ir_unop_b2i, r13CC);
   ir_expression *const r13CE = expr(ir_unop_i2u, r13CD);
   ir_expression *const r13CF = lshift(r13CE, body.constant(int(16)));
   ir_expression *const r13D0 = rshift(r13C3, body.constant(int(16)));
   ir_expression *const r13D1 = add(r13CF, r13D0);
   body.emit(assign(r13C2, add(r13CB, r13D1), 0x01));

   body.emit(assign(r13C3, lshift(r13C3, body.constant(int(16))), 0x01));

   ir_expression *const r13D2 = mul(r13C5, r13C7);
   body.emit(assign(r13C4, add(r13D2, r13C3), 0x01));

   ir_expression *const r13D3 = less(r13C4, r13C3);
   ir_expression *const r13D4 = expr(ir_unop_b2i, r13D3);
   ir_expression *const r13D5 = expr(ir_unop_i2u, r13D4);
   body.emit(assign(r13C2, add(r13C2, r13D5), 0x01));

   ir_variable *const r13D6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   ir_expression *const r13D7 = less(r13C1, r13AF);
   ir_expression *const r13D8 = expr(ir_unop_b2i, r13D7);
   ir_expression *const r13D9 = expr(ir_unop_i2u, r13D8);
   ir_expression *const r13DA = add(r13AD, r13D9);
   body.emit(assign(r13D6, add(r13C4, r13DA), 0x01));

   ir_variable *const r13DB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r13DB);
   ir_variable *const r13DC = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r13DC);
   ir_variable *const r13DD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r13DD);
   ir_variable *const r13DE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13DE, bit_and(r1391, body.constant(65535u)), 0x01));

   ir_variable *const r13DF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13DF, rshift(r1391, body.constant(int(16))), 0x01));

   ir_variable *const r13E0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13E0, bit_and(r1394, body.constant(65535u)), 0x01));

   ir_variable *const r13E1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13E1, rshift(r1394, body.constant(int(16))), 0x01));

   ir_variable *const r13E2 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13E2, mul(r13DF, r13E0), 0x01));

   ir_expression *const r13E3 = mul(r13DE, r13E1);
   body.emit(assign(r13DC, add(r13E3, r13E2), 0x01));

   ir_expression *const r13E4 = mul(r13DF, r13E1);
   ir_expression *const r13E5 = less(r13DC, r13E2);
   ir_expression *const r13E6 = expr(ir_unop_b2i, r13E5);
   ir_expression *const r13E7 = expr(ir_unop_i2u, r13E6);
   ir_expression *const r13E8 = lshift(r13E7, body.constant(int(16)));
   ir_expression *const r13E9 = rshift(r13DC, body.constant(int(16)));
   ir_expression *const r13EA = add(r13E8, r13E9);
   body.emit(assign(r13DB, add(r13E4, r13EA), 0x01));

   body.emit(assign(r13DC, lshift(r13DC, body.constant(int(16))), 0x01));

   ir_expression *const r13EB = mul(r13DE, r13E0);
   body.emit(assign(r13DD, add(r13EB, r13DC), 0x01));

   ir_expression *const r13EC = less(r13DD, r13DC);
   ir_expression *const r13ED = expr(ir_unop_b2i, r13EC);
   ir_expression *const r13EE = expr(ir_unop_i2u, r13ED);
   body.emit(assign(r13DB, add(r13DB, r13EE), 0x01));

   ir_variable *const r13EF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13EF, add(r13DD, r13C1), 0x01));

   ir_variable *const r13F0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   ir_expression *const r13F1 = less(r13EF, r13DD);
   ir_expression *const r13F2 = expr(ir_unop_b2i, r13F1);
   ir_expression *const r13F3 = expr(ir_unop_i2u, r13F2);
   ir_expression *const r13F4 = add(r13DB, r13F3);
   body.emit(assign(r13F0, add(r13D6, r13F4), 0x01));

   body.emit(assign(r1398, r139B, 0x01));

   body.emit(assign(r1397, r13EF, 0x01));

   body.emit(assign(r1396, r13F0, 0x01));

   ir_expression *const r13F5 = less(r13D6, r13C4);
   ir_expression *const r13F6 = expr(ir_unop_b2i, r13F5);
   ir_expression *const r13F7 = expr(ir_unop_i2u, r13F6);
   ir_expression *const r13F8 = add(r13C2, r13F7);
   ir_expression *const r13F9 = less(r13F0, r13D6);
   ir_expression *const r13FA = expr(ir_unop_b2i, r13F9);
   ir_expression *const r13FB = expr(ir_unop_i2u, r13FA);
   body.emit(assign(r1395, add(r13F8, r13FB), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
normalizeFloat64Subnormal(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r13FC = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac0", ir_var_function_in);
   sig_parameters.push_tail(r13FC);
   ir_variable *const r13FD = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac1", ir_var_function_in);
   sig_parameters.push_tail(r13FD);
   ir_variable *const r13FE = new(mem_ctx) ir_variable(glsl_type::int_type, "zExpPtr", ir_var_function_inout);
   sig_parameters.push_tail(r13FE);
   ir_variable *const r13FF = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r13FF);
   ir_variable *const r1400 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1400);
   ir_variable *const r1401 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r1401);
   /* IF CONDITION */
   ir_expression *const r1403 = equal(r13FC, body.constant(0u));
   ir_if *f1402 = new(mem_ctx) ir_if(operand(r1403).val);
   exec_list *const f1402_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1402->then_instructions;

      ir_variable *const r1404 = body.make_temp(glsl_type::uint_type, "a");
      body.emit(assign(r1404, r13FD, 0x01));

      ir_variable *const r1405 = body.make_temp(glsl_type::int_type, "return_value");
      ir_variable *const r1406 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
      body.emit(r1406);
      /* IF CONDITION */
      ir_expression *const r1408 = equal(r13FD, body.constant(0u));
      ir_if *f1407 = new(mem_ctx) ir_if(operand(r1408).val);
      exec_list *const f1407_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1407->then_instructions;

         body.emit(assign(r1405, body.constant(int(32)), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1407->else_instructions;

         body.emit(assign(r1406, body.constant(int(0)), 0x01));

         /* IF CONDITION */
         ir_expression *const r140A = bit_and(r13FD, body.constant(4294901760u));
         ir_expression *const r140B = equal(r140A, body.constant(0u));
         ir_if *f1409 = new(mem_ctx) ir_if(operand(r140B).val);
         exec_list *const f1409_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1409->then_instructions;

            body.emit(assign(r1406, body.constant(int(16)), 0x01));

            body.emit(assign(r1404, lshift(r13FD, body.constant(int(16))), 0x01));


         body.instructions = f1409_parent_instructions;
         body.emit(f1409);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r140D = bit_and(r1404, body.constant(4278190080u));
         ir_expression *const r140E = equal(r140D, body.constant(0u));
         ir_if *f140C = new(mem_ctx) ir_if(operand(r140E).val);
         exec_list *const f140C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f140C->then_instructions;

            body.emit(assign(r1406, add(r1406, body.constant(int(8))), 0x01));

            body.emit(assign(r1404, lshift(r1404, body.constant(int(8))), 0x01));


         body.instructions = f140C_parent_instructions;
         body.emit(f140C);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1410 = bit_and(r1404, body.constant(4026531840u));
         ir_expression *const r1411 = equal(r1410, body.constant(0u));
         ir_if *f140F = new(mem_ctx) ir_if(operand(r1411).val);
         exec_list *const f140F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f140F->then_instructions;

            body.emit(assign(r1406, add(r1406, body.constant(int(4))), 0x01));

            body.emit(assign(r1404, lshift(r1404, body.constant(int(4))), 0x01));


         body.instructions = f140F_parent_instructions;
         body.emit(f140F);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1413 = bit_and(r1404, body.constant(3221225472u));
         ir_expression *const r1414 = equal(r1413, body.constant(0u));
         ir_if *f1412 = new(mem_ctx) ir_if(operand(r1414).val);
         exec_list *const f1412_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1412->then_instructions;

            body.emit(assign(r1406, add(r1406, body.constant(int(2))), 0x01));

            body.emit(assign(r1404, lshift(r1404, body.constant(int(2))), 0x01));


         body.instructions = f1412_parent_instructions;
         body.emit(f1412);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1416 = bit_and(r1404, body.constant(2147483648u));
         ir_expression *const r1417 = equal(r1416, body.constant(0u));
         ir_if *f1415 = new(mem_ctx) ir_if(operand(r1417).val);
         exec_list *const f1415_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1415->then_instructions;

            body.emit(assign(r1406, add(r1406, body.constant(int(1))), 0x01));


         body.instructions = f1415_parent_instructions;
         body.emit(f1415);

         /* END IF */

         body.emit(assign(r1405, r1406, 0x01));


      body.instructions = f1407_parent_instructions;
      body.emit(f1407);

      /* END IF */

      body.emit(assign(r1401, add(r1405, body.constant(int(-11))), 0x01));

      /* IF CONDITION */
      ir_expression *const r1419 = less(r1401, body.constant(int(0)));
      ir_if *f1418 = new(mem_ctx) ir_if(operand(r1419).val);
      exec_list *const f1418_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1418->then_instructions;

         ir_expression *const r141A = neg(r1401);
         body.emit(assign(r13FF, rshift(r13FD, r141A), 0x01));

         ir_expression *const r141B = bit_and(r1401, body.constant(int(31)));
         body.emit(assign(r1400, lshift(r13FD, r141B), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1418->else_instructions;

         body.emit(assign(r13FF, lshift(r13FD, r1401), 0x01));

         body.emit(assign(r1400, body.constant(0u), 0x01));


      body.instructions = f1418_parent_instructions;
      body.emit(f1418);

      /* END IF */

      body.emit(assign(r13FE, sub(body.constant(int(-31)), r1401), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1402->else_instructions;

      ir_variable *const r141C = body.make_temp(glsl_type::uint_type, "a");
      body.emit(assign(r141C, r13FC, 0x01));

      ir_variable *const r141D = body.make_temp(glsl_type::int_type, "return_value");
      ir_variable *const r141E = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
      body.emit(r141E);
      /* IF CONDITION */
      ir_expression *const r1420 = equal(r13FC, body.constant(0u));
      ir_if *f141F = new(mem_ctx) ir_if(operand(r1420).val);
      exec_list *const f141F_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f141F->then_instructions;

         body.emit(assign(r141D, body.constant(int(32)), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f141F->else_instructions;

         body.emit(assign(r141E, body.constant(int(0)), 0x01));

         /* IF CONDITION */
         ir_expression *const r1422 = bit_and(r13FC, body.constant(4294901760u));
         ir_expression *const r1423 = equal(r1422, body.constant(0u));
         ir_if *f1421 = new(mem_ctx) ir_if(operand(r1423).val);
         exec_list *const f1421_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1421->then_instructions;

            body.emit(assign(r141E, body.constant(int(16)), 0x01));

            body.emit(assign(r141C, lshift(r13FC, body.constant(int(16))), 0x01));


         body.instructions = f1421_parent_instructions;
         body.emit(f1421);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1425 = bit_and(r141C, body.constant(4278190080u));
         ir_expression *const r1426 = equal(r1425, body.constant(0u));
         ir_if *f1424 = new(mem_ctx) ir_if(operand(r1426).val);
         exec_list *const f1424_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1424->then_instructions;

            body.emit(assign(r141E, add(r141E, body.constant(int(8))), 0x01));

            body.emit(assign(r141C, lshift(r141C, body.constant(int(8))), 0x01));


         body.instructions = f1424_parent_instructions;
         body.emit(f1424);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1428 = bit_and(r141C, body.constant(4026531840u));
         ir_expression *const r1429 = equal(r1428, body.constant(0u));
         ir_if *f1427 = new(mem_ctx) ir_if(operand(r1429).val);
         exec_list *const f1427_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1427->then_instructions;

            body.emit(assign(r141E, add(r141E, body.constant(int(4))), 0x01));

            body.emit(assign(r141C, lshift(r141C, body.constant(int(4))), 0x01));


         body.instructions = f1427_parent_instructions;
         body.emit(f1427);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r142B = bit_and(r141C, body.constant(3221225472u));
         ir_expression *const r142C = equal(r142B, body.constant(0u));
         ir_if *f142A = new(mem_ctx) ir_if(operand(r142C).val);
         exec_list *const f142A_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f142A->then_instructions;

            body.emit(assign(r141E, add(r141E, body.constant(int(2))), 0x01));

            body.emit(assign(r141C, lshift(r141C, body.constant(int(2))), 0x01));


         body.instructions = f142A_parent_instructions;
         body.emit(f142A);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r142E = bit_and(r141C, body.constant(2147483648u));
         ir_expression *const r142F = equal(r142E, body.constant(0u));
         ir_if *f142D = new(mem_ctx) ir_if(operand(r142F).val);
         exec_list *const f142D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f142D->then_instructions;

            body.emit(assign(r141E, add(r141E, body.constant(int(1))), 0x01));


         body.instructions = f142D_parent_instructions;
         body.emit(f142D);

         /* END IF */

         body.emit(assign(r141D, r141E, 0x01));


      body.instructions = f141F_parent_instructions;
      body.emit(f141F);

      /* END IF */

      body.emit(assign(r1401, add(r141D, body.constant(int(-11))), 0x01));

      ir_variable *const r1430 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r1430, lshift(r13FD, r1401), 0x01));

      ir_variable *const r1431 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r1433 = equal(r1401, body.constant(int(0)));
      ir_if *f1432 = new(mem_ctx) ir_if(operand(r1433).val);
      exec_list *const f1432_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1432->then_instructions;

         body.emit(assign(r1431, r13FC, 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1432->else_instructions;

         ir_expression *const r1434 = lshift(r13FC, r1401);
         ir_expression *const r1435 = neg(r1401);
         ir_expression *const r1436 = bit_and(r1435, body.constant(int(31)));
         ir_expression *const r1437 = rshift(r13FD, r1436);
         body.emit(assign(r1431, bit_or(r1434, r1437), 0x01));


      body.instructions = f1432_parent_instructions;
      body.emit(f1432);

      /* END IF */

      body.emit(assign(r13FF, r1431, 0x01));

      body.emit(assign(r1400, r1430, 0x01));

      body.emit(assign(r13FE, sub(body.constant(int(1)), r1401), 0x01));


   body.instructions = f1402_parent_instructions;
   body.emit(f1402);

   /* END IF */

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fmul64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1438 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1438);
   ir_variable *const r1439 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r1439);
   ir_variable *const r143A = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r143A, body.constant(true), 0x01));

   ir_variable *const r143B = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r143C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_auto);
   body.emit(r143C);
   ir_variable *const r143D = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
   body.emit(r143D);
   ir_variable *const r143E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
   body.emit(r143E);
   ir_variable *const r143F = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r143F);
   ir_variable *const r1440 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
   body.emit(r1440);
   ir_variable *const r1441 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r1441);
   ir_variable *const r1442 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
   body.emit(r1442);
   ir_variable *const r1443 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r1443);
   ir_variable *const r1444 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r1444);
   body.emit(assign(r1444, body.constant(0u), 0x01));

   body.emit(assign(r1443, body.constant(0u), 0x01));

   body.emit(assign(r1442, body.constant(0u), 0x01));

   ir_variable *const r1445 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r1445);
   body.emit(assign(r1445, bit_and(swizzle_y(r1438), body.constant(1048575u)), 0x02));

   body.emit(assign(r1445, swizzle_x(r1438), 0x01));

   body.emit(assign(r1440, r1445, 0x03));

   ir_variable *const r1446 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r1447 = rshift(swizzle_y(r1438), body.constant(int(20)));
   ir_expression *const r1448 = bit_and(r1447, body.constant(2047u));
   body.emit(assign(r1446, expr(ir_unop_u2i, r1448), 0x01));

   body.emit(assign(r143F, r1446, 0x01));

   ir_variable *const r1449 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r1449);
   body.emit(assign(r1449, bit_and(swizzle_y(r1439), body.constant(1048575u)), 0x02));

   body.emit(assign(r1449, swizzle_x(r1439), 0x01));

   body.emit(assign(r143E, r1449, 0x03));

   ir_variable *const r144A = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r144B = rshift(swizzle_y(r1439), body.constant(int(20)));
   ir_expression *const r144C = bit_and(r144B, body.constant(2047u));
   body.emit(assign(r144A, expr(ir_unop_u2i, r144C), 0x01));

   body.emit(assign(r143D, r144A, 0x01));

   ir_expression *const r144D = rshift(swizzle_y(r1438), body.constant(int(31)));
   ir_expression *const r144E = rshift(swizzle_y(r1439), body.constant(int(31)));
   body.emit(assign(r143C, bit_xor(r144D, r144E), 0x01));

   /* IF CONDITION */
   ir_expression *const r1450 = equal(r1446, body.constant(int(2047)));
   ir_if *f144F = new(mem_ctx) ir_if(operand(r1450).val);
   exec_list *const f144F_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f144F->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1452 = bit_or(swizzle_y(r1445), swizzle_x(r1438));
      ir_expression *const r1453 = nequal(r1452, body.constant(0u));
      ir_expression *const r1454 = equal(r144A, body.constant(int(2047)));
      ir_expression *const r1455 = bit_or(swizzle_y(r1449), swizzle_x(r1439));
      ir_expression *const r1456 = nequal(r1455, body.constant(0u));
      ir_expression *const r1457 = logic_and(r1454, r1456);
      ir_expression *const r1458 = logic_or(r1453, r1457);
      ir_if *f1451 = new(mem_ctx) ir_if(operand(r1458).val);
      exec_list *const f1451_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1451->then_instructions;

         ir_variable *const r1459 = body.make_temp(glsl_type::uvec2_type, "a");
         body.emit(assign(r1459, swizzle_x(r1438), 0x01));

         ir_variable *const r145A = body.make_temp(glsl_type::uvec2_type, "b");
         body.emit(assign(r145A, swizzle_x(r1439), 0x01));

         ir_variable *const r145B = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r145C = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
         ir_expression *const r145D = rshift(swizzle_y(r1438), body.constant(int(19)));
         ir_expression *const r145E = bit_and(r145D, body.constant(4095u));
         ir_expression *const r145F = equal(r145E, body.constant(4094u));
         ir_expression *const r1460 = nequal(swizzle_x(r1438), body.constant(0u));
         ir_expression *const r1461 = bit_and(swizzle_y(r1438), body.constant(524287u));
         ir_expression *const r1462 = nequal(r1461, body.constant(0u));
         ir_expression *const r1463 = logic_or(r1460, r1462);
         body.emit(assign(r145C, logic_and(r145F, r1463), 0x01));

         ir_variable *const r1464 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
         ir_expression *const r1465 = lshift(swizzle_y(r1439), body.constant(int(1)));
         ir_expression *const r1466 = lequal(body.constant(4292870144u), r1465);
         ir_expression *const r1467 = nequal(swizzle_x(r1439), body.constant(0u));
         ir_expression *const r1468 = bit_and(swizzle_y(r1439), body.constant(1048575u));
         ir_expression *const r1469 = nequal(r1468, body.constant(0u));
         ir_expression *const r146A = logic_or(r1467, r1469);
         body.emit(assign(r1464, logic_and(r1466, r146A), 0x01));

         body.emit(assign(r1459, bit_or(swizzle_y(r1438), body.constant(524288u)), 0x02));

         body.emit(assign(r145A, bit_or(swizzle_y(r1439), body.constant(524288u)), 0x02));

         /* IF CONDITION */
         ir_expression *const r146C = lshift(swizzle_y(r1438), body.constant(int(1)));
         ir_expression *const r146D = lequal(body.constant(4292870144u), r146C);
         ir_expression *const r146E = nequal(swizzle_x(r1438), body.constant(0u));
         ir_expression *const r146F = bit_and(swizzle_y(r1438), body.constant(1048575u));
         ir_expression *const r1470 = nequal(r146F, body.constant(0u));
         ir_expression *const r1471 = logic_or(r146E, r1470);
         ir_expression *const r1472 = logic_and(r146D, r1471);
         ir_if *f146B = new(mem_ctx) ir_if(operand(r1472).val);
         exec_list *const f146B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f146B->then_instructions;

            ir_variable *const r1473 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r1475 = logic_and(r145C, r1464);
            ir_if *f1474 = new(mem_ctx) ir_if(operand(r1475).val);
            exec_list *const f1474_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1474->then_instructions;

               body.emit(assign(r1473, r145A, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1474->else_instructions;

               body.emit(assign(r1473, r1459, 0x03));


            body.instructions = f1474_parent_instructions;
            body.emit(f1474);

            /* END IF */

            body.emit(assign(r145B, r1473, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f146B->else_instructions;

            body.emit(assign(r145B, r145A, 0x03));


         body.instructions = f146B_parent_instructions;
         body.emit(f146B);

         /* END IF */

         body.emit(assign(r143B, r145B, 0x03));

         body.emit(assign(r143A, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1451->else_instructions;

         /* IF CONDITION */
         ir_expression *const r1477 = expr(ir_unop_i2u, r144A);
         ir_expression *const r1478 = bit_or(r1477, swizzle_y(r1449));
         ir_expression *const r1479 = bit_or(r1478, swizzle_x(r1439));
         ir_expression *const r147A = equal(r1479, body.constant(0u));
         ir_if *f1476 = new(mem_ctx) ir_if(operand(r147A).val);
         exec_list *const f1476_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1476->then_instructions;

            ir_constant_data r147B_data;
            memset(&r147B_data, 0, sizeof(ir_constant_data));
r147B_data.u[0] = 4294967295;
r147B_data.u[1] = 4294967295;
            ir_constant *const r147B = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r147B_data);
            body.emit(assign(r143B, r147B, 0x03));

            body.emit(assign(r143A, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1476->else_instructions;

            ir_variable *const r147C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r147C);
            ir_expression *const r147D = lshift(r143C, body.constant(int(31)));
            body.emit(assign(r147C, add(r147D, body.constant(2146435072u)), 0x02));

            body.emit(assign(r147C, body.constant(0u), 0x01));

            body.emit(assign(r143B, r147C, 0x03));

            body.emit(assign(r143A, body.constant(false), 0x01));


         body.instructions = f1476_parent_instructions;
         body.emit(f1476);

         /* END IF */


      body.instructions = f1451_parent_instructions;
      body.emit(f1451);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f144F->else_instructions;

      /* IF CONDITION */
      ir_expression *const r147F = equal(r144A, body.constant(int(2047)));
      ir_if *f147E = new(mem_ctx) ir_if(operand(r147F).val);
      exec_list *const f147E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f147E->then_instructions;

         /* IF CONDITION */
         ir_expression *const r1481 = bit_or(swizzle_y(r1449), swizzle_x(r1439));
         ir_expression *const r1482 = nequal(r1481, body.constant(0u));
         ir_if *f1480 = new(mem_ctx) ir_if(operand(r1482).val);
         exec_list *const f1480_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1480->then_instructions;

            ir_variable *const r1483 = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r1483, swizzle_x(r1438), 0x01));

            ir_variable *const r1484 = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r1484, swizzle_x(r1439), 0x01));

            ir_variable *const r1485 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r1486 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r1487 = rshift(swizzle_y(r1438), body.constant(int(19)));
            ir_expression *const r1488 = bit_and(r1487, body.constant(4095u));
            ir_expression *const r1489 = equal(r1488, body.constant(4094u));
            ir_expression *const r148A = nequal(swizzle_x(r1438), body.constant(0u));
            ir_expression *const r148B = bit_and(swizzle_y(r1438), body.constant(524287u));
            ir_expression *const r148C = nequal(r148B, body.constant(0u));
            ir_expression *const r148D = logic_or(r148A, r148C);
            body.emit(assign(r1486, logic_and(r1489, r148D), 0x01));

            ir_variable *const r148E = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r148F = lshift(swizzle_y(r1439), body.constant(int(1)));
            ir_expression *const r1490 = lequal(body.constant(4292870144u), r148F);
            ir_expression *const r1491 = nequal(swizzle_x(r1439), body.constant(0u));
            ir_expression *const r1492 = bit_and(swizzle_y(r1439), body.constant(1048575u));
            ir_expression *const r1493 = nequal(r1492, body.constant(0u));
            ir_expression *const r1494 = logic_or(r1491, r1493);
            body.emit(assign(r148E, logic_and(r1490, r1494), 0x01));

            body.emit(assign(r1483, bit_or(swizzle_y(r1438), body.constant(524288u)), 0x02));

            body.emit(assign(r1484, bit_or(swizzle_y(r1439), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r1496 = lshift(swizzle_y(r1438), body.constant(int(1)));
            ir_expression *const r1497 = lequal(body.constant(4292870144u), r1496);
            ir_expression *const r1498 = nequal(swizzle_x(r1438), body.constant(0u));
            ir_expression *const r1499 = bit_and(swizzle_y(r1438), body.constant(1048575u));
            ir_expression *const r149A = nequal(r1499, body.constant(0u));
            ir_expression *const r149B = logic_or(r1498, r149A);
            ir_expression *const r149C = logic_and(r1497, r149B);
            ir_if *f1495 = new(mem_ctx) ir_if(operand(r149C).val);
            exec_list *const f1495_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1495->then_instructions;

               ir_variable *const r149D = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r149F = logic_and(r1486, r148E);
               ir_if *f149E = new(mem_ctx) ir_if(operand(r149F).val);
               exec_list *const f149E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f149E->then_instructions;

                  body.emit(assign(r149D, r1484, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f149E->else_instructions;

                  body.emit(assign(r149D, r1483, 0x03));


               body.instructions = f149E_parent_instructions;
               body.emit(f149E);

               /* END IF */

               body.emit(assign(r1485, r149D, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1495->else_instructions;

               body.emit(assign(r1485, r1484, 0x03));


            body.instructions = f1495_parent_instructions;
            body.emit(f1495);

            /* END IF */

            body.emit(assign(r143B, r1485, 0x03));

            body.emit(assign(r143A, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1480->else_instructions;

            /* IF CONDITION */
            ir_expression *const r14A1 = expr(ir_unop_i2u, r1446);
            ir_expression *const r14A2 = bit_or(r14A1, swizzle_y(r1445));
            ir_expression *const r14A3 = bit_or(r14A2, swizzle_x(r1438));
            ir_expression *const r14A4 = equal(r14A3, body.constant(0u));
            ir_if *f14A0 = new(mem_ctx) ir_if(operand(r14A4).val);
            exec_list *const f14A0_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f14A0->then_instructions;

               ir_constant_data r14A5_data;
               memset(&r14A5_data, 0, sizeof(ir_constant_data));
r14A5_data.u[0] = 4294967295;
r14A5_data.u[1] = 4294967295;
               ir_constant *const r14A5 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r14A5_data);
               body.emit(assign(r143B, r14A5, 0x03));

               body.emit(assign(r143A, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f14A0->else_instructions;

               ir_variable *const r14A6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r14A6);
               ir_expression *const r14A7 = lshift(r143C, body.constant(int(31)));
               body.emit(assign(r14A6, add(r14A7, body.constant(2146435072u)), 0x02));

               body.emit(assign(r14A6, body.constant(0u), 0x01));

               body.emit(assign(r143B, r14A6, 0x03));

               body.emit(assign(r143A, body.constant(false), 0x01));


            body.instructions = f14A0_parent_instructions;
            body.emit(f14A0);

            /* END IF */


         body.instructions = f1480_parent_instructions;
         body.emit(f1480);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f147E->else_instructions;

         /* IF CONDITION */
         ir_expression *const r14A9 = equal(r1446, body.constant(int(0)));
         ir_if *f14A8 = new(mem_ctx) ir_if(operand(r14A9).val);
         exec_list *const f14A8_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f14A8->then_instructions;

            /* IF CONDITION */
            ir_expression *const r14AB = bit_or(swizzle_y(r1445), swizzle_x(r1438));
            ir_expression *const r14AC = equal(r14AB, body.constant(0u));
            ir_if *f14AA = new(mem_ctx) ir_if(operand(r14AC).val);
            exec_list *const f14AA_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f14AA->then_instructions;

               ir_variable *const r14AD = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r14AD);
               body.emit(assign(r14AD, lshift(r143C, body.constant(int(31))), 0x02));

               body.emit(assign(r14AD, body.constant(0u), 0x01));

               body.emit(assign(r143B, r14AD, 0x03));

               body.emit(assign(r143A, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f14AA->else_instructions;

               ir_variable *const r14AE = body.make_temp(glsl_type::uint_type, "aFrac0");
               body.emit(assign(r14AE, swizzle_y(r1445), 0x01));

               ir_variable *const r14AF = body.make_temp(glsl_type::uint_type, "aFrac1");
               body.emit(assign(r14AF, swizzle_x(r1445), 0x01));

               ir_variable *const r14B0 = body.make_temp(glsl_type::int_type, "zExpPtr");
               body.emit(assign(r14B0, r1446, 0x01));

               ir_variable *const r14B1 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
               body.emit(assign(r14B1, swizzle_y(r1445), 0x01));

               ir_variable *const r14B2 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
               body.emit(assign(r14B2, swizzle_x(r1445), 0x01));

               ir_variable *const r14B3 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r14B3);
               /* IF CONDITION */
               ir_expression *const r14B5 = equal(swizzle_y(r1445), body.constant(0u));
               ir_if *f14B4 = new(mem_ctx) ir_if(operand(r14B5).val);
               exec_list *const f14B4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f14B4->then_instructions;

                  ir_variable *const r14B6 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r14B6, r14AF, 0x01));

                  ir_variable *const r14B7 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r14B8 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r14B8);
                  /* IF CONDITION */
                  ir_expression *const r14BA = equal(swizzle_x(r1438), body.constant(0u));
                  ir_if *f14B9 = new(mem_ctx) ir_if(operand(r14BA).val);
                  exec_list *const f14B9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f14B9->then_instructions;

                     body.emit(assign(r14B7, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f14B9->else_instructions;

                     body.emit(assign(r14B8, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r14BC = bit_and(swizzle_x(r1438), body.constant(4294901760u));
                     ir_expression *const r14BD = equal(r14BC, body.constant(0u));
                     ir_if *f14BB = new(mem_ctx) ir_if(operand(r14BD).val);
                     exec_list *const f14BB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14BB->then_instructions;

                        body.emit(assign(r14B8, body.constant(int(16)), 0x01));

                        body.emit(assign(r14B6, lshift(swizzle_x(r1438), body.constant(int(16))), 0x01));


                     body.instructions = f14BB_parent_instructions;
                     body.emit(f14BB);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14BF = bit_and(r14B6, body.constant(4278190080u));
                     ir_expression *const r14C0 = equal(r14BF, body.constant(0u));
                     ir_if *f14BE = new(mem_ctx) ir_if(operand(r14C0).val);
                     exec_list *const f14BE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14BE->then_instructions;

                        body.emit(assign(r14B8, add(r14B8, body.constant(int(8))), 0x01));

                        body.emit(assign(r14B6, lshift(r14B6, body.constant(int(8))), 0x01));


                     body.instructions = f14BE_parent_instructions;
                     body.emit(f14BE);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14C2 = bit_and(r14B6, body.constant(4026531840u));
                     ir_expression *const r14C3 = equal(r14C2, body.constant(0u));
                     ir_if *f14C1 = new(mem_ctx) ir_if(operand(r14C3).val);
                     exec_list *const f14C1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14C1->then_instructions;

                        body.emit(assign(r14B8, add(r14B8, body.constant(int(4))), 0x01));

                        body.emit(assign(r14B6, lshift(r14B6, body.constant(int(4))), 0x01));


                     body.instructions = f14C1_parent_instructions;
                     body.emit(f14C1);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14C5 = bit_and(r14B6, body.constant(3221225472u));
                     ir_expression *const r14C6 = equal(r14C5, body.constant(0u));
                     ir_if *f14C4 = new(mem_ctx) ir_if(operand(r14C6).val);
                     exec_list *const f14C4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14C4->then_instructions;

                        body.emit(assign(r14B8, add(r14B8, body.constant(int(2))), 0x01));

                        body.emit(assign(r14B6, lshift(r14B6, body.constant(int(2))), 0x01));


                     body.instructions = f14C4_parent_instructions;
                     body.emit(f14C4);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14C8 = bit_and(r14B6, body.constant(2147483648u));
                     ir_expression *const r14C9 = equal(r14C8, body.constant(0u));
                     ir_if *f14C7 = new(mem_ctx) ir_if(operand(r14C9).val);
                     exec_list *const f14C7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14C7->then_instructions;

                        body.emit(assign(r14B8, add(r14B8, body.constant(int(1))), 0x01));


                     body.instructions = f14C7_parent_instructions;
                     body.emit(f14C7);

                     /* END IF */

                     body.emit(assign(r14B7, r14B8, 0x01));


                  body.instructions = f14B9_parent_instructions;
                  body.emit(f14B9);

                  /* END IF */

                  body.emit(assign(r14B3, add(r14B7, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r14CB = less(r14B3, body.constant(int(0)));
                  ir_if *f14CA = new(mem_ctx) ir_if(operand(r14CB).val);
                  exec_list *const f14CA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f14CA->then_instructions;

                     ir_expression *const r14CC = neg(r14B3);
                     body.emit(assign(r14B1, rshift(swizzle_x(r1438), r14CC), 0x01));

                     ir_expression *const r14CD = bit_and(r14B3, body.constant(int(31)));
                     body.emit(assign(r14B2, lshift(swizzle_x(r1438), r14CD), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f14CA->else_instructions;

                     body.emit(assign(r14B1, lshift(swizzle_x(r1438), r14B3), 0x01));

                     body.emit(assign(r14B2, body.constant(0u), 0x01));


                  body.instructions = f14CA_parent_instructions;
                  body.emit(f14CA);

                  /* END IF */

                  body.emit(assign(r14B0, sub(body.constant(int(-31)), r14B3), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f14B4->else_instructions;

                  ir_variable *const r14CE = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r14CE, r14AE, 0x01));

                  ir_variable *const r14CF = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r14D0 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r14D0);
                  /* IF CONDITION */
                  ir_expression *const r14D2 = equal(swizzle_y(r1445), body.constant(0u));
                  ir_if *f14D1 = new(mem_ctx) ir_if(operand(r14D2).val);
                  exec_list *const f14D1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f14D1->then_instructions;

                     body.emit(assign(r14CF, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f14D1->else_instructions;

                     body.emit(assign(r14D0, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r14D4 = bit_and(swizzle_y(r1445), body.constant(4294901760u));
                     ir_expression *const r14D5 = equal(r14D4, body.constant(0u));
                     ir_if *f14D3 = new(mem_ctx) ir_if(operand(r14D5).val);
                     exec_list *const f14D3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14D3->then_instructions;

                        body.emit(assign(r14D0, body.constant(int(16)), 0x01));

                        body.emit(assign(r14CE, lshift(swizzle_y(r1445), body.constant(int(16))), 0x01));


                     body.instructions = f14D3_parent_instructions;
                     body.emit(f14D3);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14D7 = bit_and(r14CE, body.constant(4278190080u));
                     ir_expression *const r14D8 = equal(r14D7, body.constant(0u));
                     ir_if *f14D6 = new(mem_ctx) ir_if(operand(r14D8).val);
                     exec_list *const f14D6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14D6->then_instructions;

                        body.emit(assign(r14D0, add(r14D0, body.constant(int(8))), 0x01));

                        body.emit(assign(r14CE, lshift(r14CE, body.constant(int(8))), 0x01));


                     body.instructions = f14D6_parent_instructions;
                     body.emit(f14D6);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14DA = bit_and(r14CE, body.constant(4026531840u));
                     ir_expression *const r14DB = equal(r14DA, body.constant(0u));
                     ir_if *f14D9 = new(mem_ctx) ir_if(operand(r14DB).val);
                     exec_list *const f14D9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14D9->then_instructions;

                        body.emit(assign(r14D0, add(r14D0, body.constant(int(4))), 0x01));

                        body.emit(assign(r14CE, lshift(r14CE, body.constant(int(4))), 0x01));


                     body.instructions = f14D9_parent_instructions;
                     body.emit(f14D9);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14DD = bit_and(r14CE, body.constant(3221225472u));
                     ir_expression *const r14DE = equal(r14DD, body.constant(0u));
                     ir_if *f14DC = new(mem_ctx) ir_if(operand(r14DE).val);
                     exec_list *const f14DC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14DC->then_instructions;

                        body.emit(assign(r14D0, add(r14D0, body.constant(int(2))), 0x01));

                        body.emit(assign(r14CE, lshift(r14CE, body.constant(int(2))), 0x01));


                     body.instructions = f14DC_parent_instructions;
                     body.emit(f14DC);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14E0 = bit_and(r14CE, body.constant(2147483648u));
                     ir_expression *const r14E1 = equal(r14E0, body.constant(0u));
                     ir_if *f14DF = new(mem_ctx) ir_if(operand(r14E1).val);
                     exec_list *const f14DF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14DF->then_instructions;

                        body.emit(assign(r14D0, add(r14D0, body.constant(int(1))), 0x01));


                     body.instructions = f14DF_parent_instructions;
                     body.emit(f14DF);

                     /* END IF */

                     body.emit(assign(r14CF, r14D0, 0x01));


                  body.instructions = f14D1_parent_instructions;
                  body.emit(f14D1);

                  /* END IF */

                  body.emit(assign(r14B3, add(r14CF, body.constant(int(-11))), 0x01));

                  ir_variable *const r14E2 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r14E2, lshift(swizzle_x(r1438), r14B3), 0x01));

                  ir_variable *const r14E3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r14E5 = equal(r14B3, body.constant(int(0)));
                  ir_if *f14E4 = new(mem_ctx) ir_if(operand(r14E5).val);
                  exec_list *const f14E4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f14E4->then_instructions;

                     body.emit(assign(r14E3, r14AE, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f14E4->else_instructions;

                     ir_expression *const r14E6 = lshift(swizzle_y(r1445), r14B3);
                     ir_expression *const r14E7 = neg(r14B3);
                     ir_expression *const r14E8 = bit_and(r14E7, body.constant(int(31)));
                     ir_expression *const r14E9 = rshift(swizzle_x(r1438), r14E8);
                     body.emit(assign(r14E3, bit_or(r14E6, r14E9), 0x01));


                  body.instructions = f14E4_parent_instructions;
                  body.emit(f14E4);

                  /* END IF */

                  body.emit(assign(r14B1, r14E3, 0x01));

                  body.emit(assign(r14B2, r14E2, 0x01));

                  body.emit(assign(r14B0, sub(body.constant(int(1)), r14B3), 0x01));


               body.instructions = f14B4_parent_instructions;
               body.emit(f14B4);

               /* END IF */

               body.emit(assign(r143F, r14B0, 0x01));

               body.emit(assign(r1440, r14B1, 0x02));

               body.emit(assign(r1440, r14B2, 0x01));


            body.instructions = f14AA_parent_instructions;
            body.emit(f14AA);

            /* END IF */


         body.instructions = f14A8_parent_instructions;
         body.emit(f14A8);

         /* END IF */

         /* IF CONDITION */
         ir_if *f14EA = new(mem_ctx) ir_if(operand(r143A).val);
         exec_list *const f14EA_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f14EA->then_instructions;

            /* IF CONDITION */
            ir_expression *const r14EC = equal(r144A, body.constant(int(0)));
            ir_if *f14EB = new(mem_ctx) ir_if(operand(r14EC).val);
            exec_list *const f14EB_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f14EB->then_instructions;

               /* IF CONDITION */
               ir_expression *const r14EE = bit_or(swizzle_y(r1449), swizzle_x(r1439));
               ir_expression *const r14EF = equal(r14EE, body.constant(0u));
               ir_if *f14ED = new(mem_ctx) ir_if(operand(r14EF).val);
               exec_list *const f14ED_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f14ED->then_instructions;

                  ir_variable *const r14F0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r14F0);
                  body.emit(assign(r14F0, lshift(r143C, body.constant(int(31))), 0x02));

                  body.emit(assign(r14F0, body.constant(0u), 0x01));

                  body.emit(assign(r143B, r14F0, 0x03));

                  body.emit(assign(r143A, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f14ED->else_instructions;

                  ir_variable *const r14F1 = body.make_temp(glsl_type::uint_type, "aFrac0");
                  body.emit(assign(r14F1, swizzle_y(r1449), 0x01));

                  ir_variable *const r14F2 = body.make_temp(glsl_type::uint_type, "aFrac1");
                  body.emit(assign(r14F2, swizzle_x(r1449), 0x01));

                  ir_variable *const r14F3 = body.make_temp(glsl_type::int_type, "zExpPtr");
                  body.emit(assign(r14F3, r144A, 0x01));

                  ir_variable *const r14F4 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
                  body.emit(assign(r14F4, swizzle_y(r1449), 0x01));

                  ir_variable *const r14F5 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
                  body.emit(assign(r14F5, swizzle_x(r1449), 0x01));

                  ir_variable *const r14F6 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r14F6);
                  /* IF CONDITION */
                  ir_expression *const r14F8 = equal(swizzle_y(r1449), body.constant(0u));
                  ir_if *f14F7 = new(mem_ctx) ir_if(operand(r14F8).val);
                  exec_list *const f14F7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f14F7->then_instructions;

                     ir_variable *const r14F9 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r14F9, r14F2, 0x01));

                     ir_variable *const r14FA = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r14FB = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r14FB);
                     /* IF CONDITION */
                     ir_expression *const r14FD = equal(swizzle_x(r1439), body.constant(0u));
                     ir_if *f14FC = new(mem_ctx) ir_if(operand(r14FD).val);
                     exec_list *const f14FC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14FC->then_instructions;

                        body.emit(assign(r14FA, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f14FC->else_instructions;

                        body.emit(assign(r14FB, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r14FF = bit_and(swizzle_x(r1439), body.constant(4294901760u));
                        ir_expression *const r1500 = equal(r14FF, body.constant(0u));
                        ir_if *f14FE = new(mem_ctx) ir_if(operand(r1500).val);
                        exec_list *const f14FE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f14FE->then_instructions;

                           body.emit(assign(r14FB, body.constant(int(16)), 0x01));

                           body.emit(assign(r14F9, lshift(swizzle_x(r1439), body.constant(int(16))), 0x01));


                        body.instructions = f14FE_parent_instructions;
                        body.emit(f14FE);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1502 = bit_and(r14F9, body.constant(4278190080u));
                        ir_expression *const r1503 = equal(r1502, body.constant(0u));
                        ir_if *f1501 = new(mem_ctx) ir_if(operand(r1503).val);
                        exec_list *const f1501_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1501->then_instructions;

                           body.emit(assign(r14FB, add(r14FB, body.constant(int(8))), 0x01));

                           body.emit(assign(r14F9, lshift(r14F9, body.constant(int(8))), 0x01));


                        body.instructions = f1501_parent_instructions;
                        body.emit(f1501);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1505 = bit_and(r14F9, body.constant(4026531840u));
                        ir_expression *const r1506 = equal(r1505, body.constant(0u));
                        ir_if *f1504 = new(mem_ctx) ir_if(operand(r1506).val);
                        exec_list *const f1504_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1504->then_instructions;

                           body.emit(assign(r14FB, add(r14FB, body.constant(int(4))), 0x01));

                           body.emit(assign(r14F9, lshift(r14F9, body.constant(int(4))), 0x01));


                        body.instructions = f1504_parent_instructions;
                        body.emit(f1504);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1508 = bit_and(r14F9, body.constant(3221225472u));
                        ir_expression *const r1509 = equal(r1508, body.constant(0u));
                        ir_if *f1507 = new(mem_ctx) ir_if(operand(r1509).val);
                        exec_list *const f1507_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1507->then_instructions;

                           body.emit(assign(r14FB, add(r14FB, body.constant(int(2))), 0x01));

                           body.emit(assign(r14F9, lshift(r14F9, body.constant(int(2))), 0x01));


                        body.instructions = f1507_parent_instructions;
                        body.emit(f1507);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r150B = bit_and(r14F9, body.constant(2147483648u));
                        ir_expression *const r150C = equal(r150B, body.constant(0u));
                        ir_if *f150A = new(mem_ctx) ir_if(operand(r150C).val);
                        exec_list *const f150A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f150A->then_instructions;

                           body.emit(assign(r14FB, add(r14FB, body.constant(int(1))), 0x01));


                        body.instructions = f150A_parent_instructions;
                        body.emit(f150A);

                        /* END IF */

                        body.emit(assign(r14FA, r14FB, 0x01));


                     body.instructions = f14FC_parent_instructions;
                     body.emit(f14FC);

                     /* END IF */

                     body.emit(assign(r14F6, add(r14FA, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r150E = less(r14F6, body.constant(int(0)));
                     ir_if *f150D = new(mem_ctx) ir_if(operand(r150E).val);
                     exec_list *const f150D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f150D->then_instructions;

                        ir_expression *const r150F = neg(r14F6);
                        body.emit(assign(r14F4, rshift(swizzle_x(r1439), r150F), 0x01));

                        ir_expression *const r1510 = bit_and(r14F6, body.constant(int(31)));
                        body.emit(assign(r14F5, lshift(swizzle_x(r1439), r1510), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f150D->else_instructions;

                        body.emit(assign(r14F4, lshift(swizzle_x(r1439), r14F6), 0x01));

                        body.emit(assign(r14F5, body.constant(0u), 0x01));


                     body.instructions = f150D_parent_instructions;
                     body.emit(f150D);

                     /* END IF */

                     body.emit(assign(r14F3, sub(body.constant(int(-31)), r14F6), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f14F7->else_instructions;

                     ir_variable *const r1511 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r1511, r14F1, 0x01));

                     ir_variable *const r1512 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r1513 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r1513);
                     /* IF CONDITION */
                     ir_expression *const r1515 = equal(swizzle_y(r1449), body.constant(0u));
                     ir_if *f1514 = new(mem_ctx) ir_if(operand(r1515).val);
                     exec_list *const f1514_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1514->then_instructions;

                        body.emit(assign(r1512, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1514->else_instructions;

                        body.emit(assign(r1513, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1517 = bit_and(swizzle_y(r1449), body.constant(4294901760u));
                        ir_expression *const r1518 = equal(r1517, body.constant(0u));
                        ir_if *f1516 = new(mem_ctx) ir_if(operand(r1518).val);
                        exec_list *const f1516_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1516->then_instructions;

                           body.emit(assign(r1513, body.constant(int(16)), 0x01));

                           body.emit(assign(r1511, lshift(swizzle_y(r1449), body.constant(int(16))), 0x01));


                        body.instructions = f1516_parent_instructions;
                        body.emit(f1516);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r151A = bit_and(r1511, body.constant(4278190080u));
                        ir_expression *const r151B = equal(r151A, body.constant(0u));
                        ir_if *f1519 = new(mem_ctx) ir_if(operand(r151B).val);
                        exec_list *const f1519_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1519->then_instructions;

                           body.emit(assign(r1513, add(r1513, body.constant(int(8))), 0x01));

                           body.emit(assign(r1511, lshift(r1511, body.constant(int(8))), 0x01));


                        body.instructions = f1519_parent_instructions;
                        body.emit(f1519);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r151D = bit_and(r1511, body.constant(4026531840u));
                        ir_expression *const r151E = equal(r151D, body.constant(0u));
                        ir_if *f151C = new(mem_ctx) ir_if(operand(r151E).val);
                        exec_list *const f151C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f151C->then_instructions;

                           body.emit(assign(r1513, add(r1513, body.constant(int(4))), 0x01));

                           body.emit(assign(r1511, lshift(r1511, body.constant(int(4))), 0x01));


                        body.instructions = f151C_parent_instructions;
                        body.emit(f151C);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1520 = bit_and(r1511, body.constant(3221225472u));
                        ir_expression *const r1521 = equal(r1520, body.constant(0u));
                        ir_if *f151F = new(mem_ctx) ir_if(operand(r1521).val);
                        exec_list *const f151F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f151F->then_instructions;

                           body.emit(assign(r1513, add(r1513, body.constant(int(2))), 0x01));

                           body.emit(assign(r1511, lshift(r1511, body.constant(int(2))), 0x01));


                        body.instructions = f151F_parent_instructions;
                        body.emit(f151F);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1523 = bit_and(r1511, body.constant(2147483648u));
                        ir_expression *const r1524 = equal(r1523, body.constant(0u));
                        ir_if *f1522 = new(mem_ctx) ir_if(operand(r1524).val);
                        exec_list *const f1522_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1522->then_instructions;

                           body.emit(assign(r1513, add(r1513, body.constant(int(1))), 0x01));


                        body.instructions = f1522_parent_instructions;
                        body.emit(f1522);

                        /* END IF */

                        body.emit(assign(r1512, r1513, 0x01));


                     body.instructions = f1514_parent_instructions;
                     body.emit(f1514);

                     /* END IF */

                     body.emit(assign(r14F6, add(r1512, body.constant(int(-11))), 0x01));

                     ir_variable *const r1525 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r1525, lshift(swizzle_x(r1439), r14F6), 0x01));

                     ir_variable *const r1526 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1528 = equal(r14F6, body.constant(int(0)));
                     ir_if *f1527 = new(mem_ctx) ir_if(operand(r1528).val);
                     exec_list *const f1527_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1527->then_instructions;

                        body.emit(assign(r1526, r14F1, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1527->else_instructions;

                        ir_expression *const r1529 = lshift(swizzle_y(r1449), r14F6);
                        ir_expression *const r152A = neg(r14F6);
                        ir_expression *const r152B = bit_and(r152A, body.constant(int(31)));
                        ir_expression *const r152C = rshift(swizzle_x(r1439), r152B);
                        body.emit(assign(r1526, bit_or(r1529, r152C), 0x01));


                     body.instructions = f1527_parent_instructions;
                     body.emit(f1527);

                     /* END IF */

                     body.emit(assign(r14F4, r1526, 0x01));

                     body.emit(assign(r14F5, r1525, 0x01));

                     body.emit(assign(r14F3, sub(body.constant(int(1)), r14F6), 0x01));


                  body.instructions = f14F7_parent_instructions;
                  body.emit(f14F7);

                  /* END IF */

                  body.emit(assign(r143D, r14F3, 0x01));

                  body.emit(assign(r143E, r14F4, 0x02));

                  body.emit(assign(r143E, r14F5, 0x01));


               body.instructions = f14ED_parent_instructions;
               body.emit(f14ED);

               /* END IF */


            body.instructions = f14EB_parent_instructions;
            body.emit(f14EB);

            /* END IF */

            /* IF CONDITION */
            ir_if *f152D = new(mem_ctx) ir_if(operand(r143A).val);
            exec_list *const f152D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f152D->then_instructions;

               ir_expression *const r152E = add(r143F, r143D);
               body.emit(assign(r1441, add(r152E, body.constant(int(-1024))), 0x01));

               body.emit(assign(r1440, bit_or(swizzle_y(r1440), body.constant(1048576u)), 0x02));

               ir_variable *const r152F = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r152F, lshift(swizzle_x(r143E), body.constant(int(12))), 0x01));

               ir_variable *const r1530 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r1531 = lshift(swizzle_y(r143E), body.constant(int(12)));
               ir_expression *const r1532 = rshift(swizzle_x(r143E), body.constant(int(20)));
               body.emit(assign(r1530, bit_or(r1531, r1532), 0x01));

               body.emit(assign(r143E, r1530, 0x02));

               body.emit(assign(r143E, r152F, 0x01));

               ir_variable *const r1533 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1533);
               ir_variable *const r1534 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r1534);
               ir_variable *const r1535 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1535);
               ir_variable *const r1536 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1536, bit_and(swizzle_x(r1440), body.constant(65535u)), 0x01));

               ir_variable *const r1537 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1537, rshift(swizzle_x(r1440), body.constant(int(16))), 0x01));

               ir_variable *const r1538 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1538, bit_and(r152F, body.constant(65535u)), 0x01));

               ir_variable *const r1539 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1539, rshift(r152F, body.constant(int(16))), 0x01));

               ir_variable *const r153A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r153A, mul(r1537, r1538), 0x01));

               ir_expression *const r153B = mul(r1536, r1539);
               body.emit(assign(r1534, add(r153B, r153A), 0x01));

               ir_expression *const r153C = mul(r1537, r1539);
               ir_expression *const r153D = less(r1534, r153A);
               ir_expression *const r153E = expr(ir_unop_b2i, r153D);
               ir_expression *const r153F = expr(ir_unop_i2u, r153E);
               ir_expression *const r1540 = lshift(r153F, body.constant(int(16)));
               ir_expression *const r1541 = rshift(r1534, body.constant(int(16)));
               ir_expression *const r1542 = add(r1540, r1541);
               body.emit(assign(r1533, add(r153C, r1542), 0x01));

               body.emit(assign(r1534, lshift(r1534, body.constant(int(16))), 0x01));

               ir_expression *const r1543 = mul(r1536, r1538);
               body.emit(assign(r1535, add(r1543, r1534), 0x01));

               ir_expression *const r1544 = less(r1535, r1534);
               ir_expression *const r1545 = expr(ir_unop_b2i, r1544);
               ir_expression *const r1546 = expr(ir_unop_i2u, r1545);
               body.emit(assign(r1533, add(r1533, r1546), 0x01));

               ir_variable *const r1547 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1547);
               ir_variable *const r1548 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r1548);
               ir_variable *const r1549 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1549);
               ir_variable *const r154A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r154A, bit_and(swizzle_x(r1440), body.constant(65535u)), 0x01));

               ir_variable *const r154B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r154B, rshift(swizzle_x(r1440), body.constant(int(16))), 0x01));

               ir_variable *const r154C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r154C, bit_and(r1530, body.constant(65535u)), 0x01));

               ir_variable *const r154D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r154D, rshift(r1530, body.constant(int(16))), 0x01));

               ir_variable *const r154E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r154E, mul(r154B, r154C), 0x01));

               ir_expression *const r154F = mul(r154A, r154D);
               body.emit(assign(r1548, add(r154F, r154E), 0x01));

               ir_expression *const r1550 = mul(r154B, r154D);
               ir_expression *const r1551 = less(r1548, r154E);
               ir_expression *const r1552 = expr(ir_unop_b2i, r1551);
               ir_expression *const r1553 = expr(ir_unop_i2u, r1552);
               ir_expression *const r1554 = lshift(r1553, body.constant(int(16)));
               ir_expression *const r1555 = rshift(r1548, body.constant(int(16)));
               ir_expression *const r1556 = add(r1554, r1555);
               body.emit(assign(r1547, add(r1550, r1556), 0x01));

               body.emit(assign(r1548, lshift(r1548, body.constant(int(16))), 0x01));

               ir_expression *const r1557 = mul(r154A, r154C);
               body.emit(assign(r1549, add(r1557, r1548), 0x01));

               ir_expression *const r1558 = less(r1549, r1548);
               ir_expression *const r1559 = expr(ir_unop_b2i, r1558);
               ir_expression *const r155A = expr(ir_unop_i2u, r1559);
               body.emit(assign(r1547, add(r1547, r155A), 0x01));

               ir_variable *const r155B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r155B, add(r1549, r1533), 0x01));

               ir_variable *const r155C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r155C);
               ir_variable *const r155D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r155D);
               ir_variable *const r155E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r155E);
               ir_variable *const r155F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r155F, bit_and(swizzle_y(r1440), body.constant(65535u)), 0x01));

               ir_variable *const r1560 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1560, rshift(swizzle_y(r1440), body.constant(int(16))), 0x01));

               ir_variable *const r1561 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1561, bit_and(r1530, body.constant(65535u)), 0x01));

               ir_variable *const r1562 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1562, rshift(r1530, body.constant(int(16))), 0x01));

               ir_variable *const r1563 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1563, mul(r1560, r1561), 0x01));

               ir_expression *const r1564 = mul(r155F, r1562);
               body.emit(assign(r155D, add(r1564, r1563), 0x01));

               ir_expression *const r1565 = mul(r1560, r1562);
               ir_expression *const r1566 = less(r155D, r1563);
               ir_expression *const r1567 = expr(ir_unop_b2i, r1566);
               ir_expression *const r1568 = expr(ir_unop_i2u, r1567);
               ir_expression *const r1569 = lshift(r1568, body.constant(int(16)));
               ir_expression *const r156A = rshift(r155D, body.constant(int(16)));
               ir_expression *const r156B = add(r1569, r156A);
               body.emit(assign(r155C, add(r1565, r156B), 0x01));

               body.emit(assign(r155D, lshift(r155D, body.constant(int(16))), 0x01));

               ir_expression *const r156C = mul(r155F, r1561);
               body.emit(assign(r155E, add(r156C, r155D), 0x01));

               ir_expression *const r156D = less(r155E, r155D);
               ir_expression *const r156E = expr(ir_unop_b2i, r156D);
               ir_expression *const r156F = expr(ir_unop_i2u, r156E);
               body.emit(assign(r155C, add(r155C, r156F), 0x01));

               ir_variable *const r1570 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r1571 = less(r155B, r1549);
               ir_expression *const r1572 = expr(ir_unop_b2i, r1571);
               ir_expression *const r1573 = expr(ir_unop_i2u, r1572);
               ir_expression *const r1574 = add(r1547, r1573);
               body.emit(assign(r1570, add(r155E, r1574), 0x01));

               ir_variable *const r1575 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1575);
               ir_variable *const r1576 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r1576);
               ir_variable *const r1577 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1577);
               ir_variable *const r1578 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1578, bit_and(swizzle_y(r1440), body.constant(65535u)), 0x01));

               ir_variable *const r1579 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1579, rshift(swizzle_y(r1440), body.constant(int(16))), 0x01));

               ir_variable *const r157A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r157A, bit_and(r152F, body.constant(65535u)), 0x01));

               ir_variable *const r157B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r157B, rshift(r152F, body.constant(int(16))), 0x01));

               ir_variable *const r157C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r157C, mul(r1579, r157A), 0x01));

               ir_expression *const r157D = mul(r1578, r157B);
               body.emit(assign(r1576, add(r157D, r157C), 0x01));

               ir_expression *const r157E = mul(r1579, r157B);
               ir_expression *const r157F = less(r1576, r157C);
               ir_expression *const r1580 = expr(ir_unop_b2i, r157F);
               ir_expression *const r1581 = expr(ir_unop_i2u, r1580);
               ir_expression *const r1582 = lshift(r1581, body.constant(int(16)));
               ir_expression *const r1583 = rshift(r1576, body.constant(int(16)));
               ir_expression *const r1584 = add(r1582, r1583);
               body.emit(assign(r1575, add(r157E, r1584), 0x01));

               body.emit(assign(r1576, lshift(r1576, body.constant(int(16))), 0x01));

               ir_expression *const r1585 = mul(r1578, r157A);
               body.emit(assign(r1577, add(r1585, r1576), 0x01));

               ir_expression *const r1586 = less(r1577, r1576);
               ir_expression *const r1587 = expr(ir_unop_b2i, r1586);
               ir_expression *const r1588 = expr(ir_unop_i2u, r1587);
               body.emit(assign(r1575, add(r1575, r1588), 0x01));

               ir_variable *const r1589 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1589, add(r1577, r155B), 0x01));

               ir_variable *const r158A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r158B = less(r1589, r1577);
               ir_expression *const r158C = expr(ir_unop_b2i, r158B);
               ir_expression *const r158D = expr(ir_unop_i2u, r158C);
               ir_expression *const r158E = add(r1575, r158D);
               body.emit(assign(r158A, add(r1570, r158E), 0x01));

               ir_variable *const r158F = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r1590 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1590, add(r158A, swizzle_x(r1440)), 0x01));

               ir_expression *const r1591 = less(r1570, r155E);
               ir_expression *const r1592 = expr(ir_unop_b2i, r1591);
               ir_expression *const r1593 = expr(ir_unop_i2u, r1592);
               ir_expression *const r1594 = add(r155C, r1593);
               ir_expression *const r1595 = less(r158A, r1570);
               ir_expression *const r1596 = expr(ir_unop_b2i, r1595);
               ir_expression *const r1597 = expr(ir_unop_i2u, r1596);
               ir_expression *const r1598 = add(r1594, r1597);
               ir_expression *const r1599 = add(r1598, swizzle_y(r1440));
               ir_expression *const r159A = less(r1590, r158A);
               ir_expression *const r159B = expr(ir_unop_b2i, r159A);
               ir_expression *const r159C = expr(ir_unop_i2u, r159B);
               body.emit(assign(r158F, add(r1599, r159C), 0x01));

               body.emit(assign(r1444, r158F, 0x01));

               body.emit(assign(r1443, r1590, 0x01));

               ir_expression *const r159D = nequal(r1535, body.constant(0u));
               ir_expression *const r159E = expr(ir_unop_b2i, r159D);
               ir_expression *const r159F = expr(ir_unop_i2u, r159E);
               body.emit(assign(r1442, bit_or(r1589, r159F), 0x01));

               /* IF CONDITION */
               ir_expression *const r15A1 = lequal(body.constant(2097152u), r158F);
               ir_if *f15A0 = new(mem_ctx) ir_if(operand(r15A1).val);
               exec_list *const f15A0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f15A0->then_instructions;

                  ir_variable *const r15A2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r15A2);
                  body.emit(assign(r15A2, lshift(r1590, body.constant(int(31))), 0x01));

                  ir_expression *const r15A3 = nequal(r1442, body.constant(0u));
                  ir_expression *const r15A4 = expr(ir_unop_b2i, r15A3);
                  ir_expression *const r15A5 = expr(ir_unop_i2u, r15A4);
                  body.emit(assign(r15A2, bit_or(r15A2, r15A5), 0x01));

                  body.emit(assign(r1444, rshift(r158F, body.constant(int(1))), 0x01));

                  ir_expression *const r15A6 = lshift(r158F, body.constant(int(31)));
                  ir_expression *const r15A7 = rshift(r1590, body.constant(int(1)));
                  body.emit(assign(r1443, bit_or(r15A6, r15A7), 0x01));

                  body.emit(assign(r1442, r15A2, 0x01));

                  body.emit(assign(r1441, add(r1441, body.constant(int(1))), 0x01));


               body.instructions = f15A0_parent_instructions;
               body.emit(f15A0);

               /* END IF */

               ir_variable *const r15A8 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r15A8, r1441, 0x01));

               ir_variable *const r15A9 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r15A9, r1444, 0x01));

               ir_variable *const r15AA = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r15AA, r1443, 0x01));

               ir_variable *const r15AB = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r15AB, r1442, 0x01));

               ir_variable *const r15AC = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r15AC, body.constant(true), 0x01));

               ir_variable *const r15AD = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r15AE = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r15AE);
               ir_expression *const r15AF = expr(ir_unop_u2i, r1442);
               body.emit(assign(r15AE, less(r15AF, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r15B1 = lequal(body.constant(int(2045)), r1441);
               ir_if *f15B0 = new(mem_ctx) ir_if(operand(r15B1).val);
               exec_list *const f15B0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f15B0->then_instructions;

                  ir_variable *const r15B2 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r15B4 = less(body.constant(int(2045)), r1441);
                  ir_if *f15B3 = new(mem_ctx) ir_if(operand(r15B4).val);
                  exec_list *const f15B3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f15B3->then_instructions;

                     body.emit(assign(r15B2, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f15B3->else_instructions;

                     ir_variable *const r15B5 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r15B7 = equal(r1441, body.constant(int(2045)));
                     ir_if *f15B6 = new(mem_ctx) ir_if(operand(r15B7).val);
                     exec_list *const f15B6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f15B6->then_instructions;

                        ir_expression *const r15B8 = equal(body.constant(2097151u), r1444);
                        ir_expression *const r15B9 = equal(body.constant(4294967295u), r1443);
                        body.emit(assign(r15B5, logic_and(r15B8, r15B9), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f15B6->else_instructions;

                        body.emit(assign(r15B5, body.constant(false), 0x01));


                     body.instructions = f15B6_parent_instructions;
                     body.emit(f15B6);

                     /* END IF */

                     body.emit(assign(r15B2, logic_and(r15B5, r15AE), 0x01));


                  body.instructions = f15B3_parent_instructions;
                  body.emit(f15B3);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f15BA = new(mem_ctx) ir_if(operand(r15B2).val);
                  exec_list *const f15BA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f15BA->then_instructions;

                     ir_variable *const r15BB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r15BB);
                     ir_expression *const r15BC = lshift(r143C, body.constant(int(31)));
                     body.emit(assign(r15BB, add(r15BC, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r15BB, body.constant(0u), 0x01));

                     body.emit(assign(r15AD, r15BB, 0x03));

                     body.emit(assign(r15AC, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f15BA->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r15BE = less(r1441, body.constant(int(0)));
                     ir_if *f15BD = new(mem_ctx) ir_if(operand(r15BE).val);
                     exec_list *const f15BD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f15BD->then_instructions;

                        ir_variable *const r15BF = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r15BF, r1442, 0x01));

                        ir_variable *const r15C0 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r15C0, neg(r1441), 0x01));

                        ir_variable *const r15C1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r15C1);
                        ir_variable *const r15C2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r15C2);
                        ir_variable *const r15C3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r15C3);
                        ir_variable *const r15C4 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r15C5 = neg(r15C0);
                        body.emit(assign(r15C4, bit_and(r15C5, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r15C7 = equal(r15C0, body.constant(int(0)));
                        ir_if *f15C6 = new(mem_ctx) ir_if(operand(r15C7).val);
                        exec_list *const f15C6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f15C6->then_instructions;

                           body.emit(assign(r15C1, r1442, 0x01));

                           body.emit(assign(r15C2, r1443, 0x01));

                           body.emit(assign(r15C3, r1444, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f15C6->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r15C9 = less(r15C0, body.constant(int(32)));
                           ir_if *f15C8 = new(mem_ctx) ir_if(operand(r15C9).val);
                           exec_list *const f15C8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f15C8->then_instructions;

                              body.emit(assign(r15C1, lshift(r1443, r15C4), 0x01));

                              ir_expression *const r15CA = lshift(r1444, r15C4);
                              ir_expression *const r15CB = rshift(r1443, r15C0);
                              body.emit(assign(r15C2, bit_or(r15CA, r15CB), 0x01));

                              body.emit(assign(r15C3, rshift(r1444, r15C0), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f15C8->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r15CD = equal(r15C0, body.constant(int(32)));
                              ir_if *f15CC = new(mem_ctx) ir_if(operand(r15CD).val);
                              exec_list *const f15CC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f15CC->then_instructions;

                                 body.emit(assign(r15C1, r1443, 0x01));

                                 body.emit(assign(r15C2, r1444, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f15CC->else_instructions;

                                 body.emit(assign(r15BF, bit_or(r1442, r1443), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r15CF = less(r15C0, body.constant(int(64)));
                                 ir_if *f15CE = new(mem_ctx) ir_if(operand(r15CF).val);
                                 exec_list *const f15CE_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f15CE->then_instructions;

                                    body.emit(assign(r15C1, lshift(r1444, r15C4), 0x01));

                                    ir_expression *const r15D0 = bit_and(r15C0, body.constant(int(31)));
                                    body.emit(assign(r15C2, rshift(r1444, r15D0), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f15CE->else_instructions;

                                    ir_variable *const r15D1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r15D3 = equal(r15C0, body.constant(int(64)));
                                    ir_if *f15D2 = new(mem_ctx) ir_if(operand(r15D3).val);
                                    exec_list *const f15D2_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f15D2->then_instructions;

                                       body.emit(assign(r15D1, r1444, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f15D2->else_instructions;

                                       ir_expression *const r15D4 = nequal(r1444, body.constant(0u));
                                       ir_expression *const r15D5 = expr(ir_unop_b2i, r15D4);
                                       body.emit(assign(r15D1, expr(ir_unop_i2u, r15D5), 0x01));


                                    body.instructions = f15D2_parent_instructions;
                                    body.emit(f15D2);

                                    /* END IF */

                                    body.emit(assign(r15C1, r15D1, 0x01));

                                    body.emit(assign(r15C2, body.constant(0u), 0x01));


                                 body.instructions = f15CE_parent_instructions;
                                 body.emit(f15CE);

                                 /* END IF */


                              body.instructions = f15CC_parent_instructions;
                              body.emit(f15CC);

                              /* END IF */

                              body.emit(assign(r15C3, body.constant(0u), 0x01));


                           body.instructions = f15C8_parent_instructions;
                           body.emit(f15C8);

                           /* END IF */

                           ir_expression *const r15D6 = nequal(r15BF, body.constant(0u));
                           ir_expression *const r15D7 = expr(ir_unop_b2i, r15D6);
                           ir_expression *const r15D8 = expr(ir_unop_i2u, r15D7);
                           body.emit(assign(r15C1, bit_or(r15C1, r15D8), 0x01));


                        body.instructions = f15C6_parent_instructions;
                        body.emit(f15C6);

                        /* END IF */

                        body.emit(assign(r15A9, r15C3, 0x01));

                        body.emit(assign(r15AA, r15C2, 0x01));

                        body.emit(assign(r15AB, r15C1, 0x01));

                        body.emit(assign(r15A8, body.constant(int(0)), 0x01));

                        body.emit(assign(r15AE, less(r15C1, body.constant(0u)), 0x01));


                     body.instructions = f15BD_parent_instructions;
                     body.emit(f15BD);

                     /* END IF */


                  body.instructions = f15BA_parent_instructions;
                  body.emit(f15BA);

                  /* END IF */


               body.instructions = f15B0_parent_instructions;
               body.emit(f15B0);

               /* END IF */

               /* IF CONDITION */
               ir_if *f15D9 = new(mem_ctx) ir_if(operand(r15AC).val);
               exec_list *const f15D9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f15D9->then_instructions;

                  /* IF CONDITION */
                  ir_if *f15DA = new(mem_ctx) ir_if(operand(r15AE).val);
                  exec_list *const f15DA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f15DA->then_instructions;

                     ir_variable *const r15DB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r15DB, add(r15AA, body.constant(1u)), 0x01));

                     ir_expression *const r15DC = less(r15DB, r15AA);
                     ir_expression *const r15DD = expr(ir_unop_b2i, r15DC);
                     ir_expression *const r15DE = expr(ir_unop_i2u, r15DD);
                     body.emit(assign(r15A9, add(r15A9, r15DE), 0x01));

                     ir_expression *const r15DF = equal(r15AB, body.constant(0u));
                     ir_expression *const r15E0 = expr(ir_unop_b2i, r15DF);
                     ir_expression *const r15E1 = expr(ir_unop_i2u, r15E0);
                     ir_expression *const r15E2 = add(r15AB, r15E1);
                     ir_expression *const r15E3 = bit_and(r15E2, body.constant(1u));
                     ir_expression *const r15E4 = expr(ir_unop_bit_not, r15E3);
                     body.emit(assign(r15AA, bit_and(r15DB, r15E4), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f15DA->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r15E6 = bit_or(r15A9, r15AA);
                     ir_expression *const r15E7 = equal(r15E6, body.constant(0u));
                     ir_if *f15E5 = new(mem_ctx) ir_if(operand(r15E7).val);
                     exec_list *const f15E5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f15E5->then_instructions;

                        body.emit(assign(r15A8, body.constant(int(0)), 0x01));


                     body.instructions = f15E5_parent_instructions;
                     body.emit(f15E5);

                     /* END IF */


                  body.instructions = f15DA_parent_instructions;
                  body.emit(f15DA);

                  /* END IF */

                  ir_variable *const r15E8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r15E8);
                  ir_expression *const r15E9 = lshift(r143C, body.constant(int(31)));
                  ir_expression *const r15EA = expr(ir_unop_i2u, r15A8);
                  ir_expression *const r15EB = lshift(r15EA, body.constant(int(20)));
                  ir_expression *const r15EC = add(r15E9, r15EB);
                  body.emit(assign(r15E8, add(r15EC, r15A9), 0x02));

                  body.emit(assign(r15E8, r15AA, 0x01));

                  body.emit(assign(r15AD, r15E8, 0x03));

                  body.emit(assign(r15AC, body.constant(false), 0x01));


               body.instructions = f15D9_parent_instructions;
               body.emit(f15D9);

               /* END IF */

               body.emit(assign(r143B, r15AD, 0x03));

               body.emit(assign(r143A, body.constant(false), 0x01));


            body.instructions = f152D_parent_instructions;
            body.emit(f152D);

            /* END IF */


         body.instructions = f14EA_parent_instructions;
         body.emit(f14EA);

         /* END IF */


      body.instructions = f147E_parent_instructions;
      body.emit(f147E);

      /* END IF */


   body.instructions = f144F_parent_instructions;
   body.emit(f144F);

   /* END IF */

   body.emit(ret(r143B));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
add96(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r15ED = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r15ED);
   ir_variable *const r15EE = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r15EE);
   ir_variable *const r15EF = new(mem_ctx) ir_variable(glsl_type::uint_type, "a2", ir_var_function_in);
   sig_parameters.push_tail(r15EF);
   ir_variable *const r15F0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r15F0);
   ir_variable *const r15F1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r15F1);
   ir_variable *const r15F2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b2", ir_var_function_in);
   sig_parameters.push_tail(r15F2);
   ir_variable *const r15F3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r15F3);
   ir_variable *const r15F4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r15F4);
   ir_variable *const r15F5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r15F5);
   ir_variable *const r15F6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r15F6);
   ir_variable *const r15F7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r15F7);
   ir_variable *const r15F8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r15F8, add(r15EF, r15F2), 0x01));

   ir_variable *const r15F9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   ir_expression *const r15FA = less(r15F8, r15EF);
   ir_expression *const r15FB = expr(ir_unop_b2i, r15FA);
   body.emit(assign(r15F9, expr(ir_unop_i2u, r15FB), 0x01));

   ir_variable *const r15FC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r15FC, add(r15EE, r15F1), 0x01));

   body.emit(assign(r15F7, add(r15FC, r15F9), 0x01));

   ir_expression *const r15FD = add(r15ED, r15F0);
   ir_expression *const r15FE = less(r15F7, r15F9);
   ir_expression *const r15FF = expr(ir_unop_b2i, r15FE);
   ir_expression *const r1600 = expr(ir_unop_i2u, r15FF);
   body.emit(assign(r15F6, add(r15FD, r1600), 0x01));

   ir_expression *const r1601 = less(r15FC, r15EE);
   ir_expression *const r1602 = expr(ir_unop_b2i, r1601);
   ir_expression *const r1603 = expr(ir_unop_i2u, r1602);
   body.emit(assign(r15F6, add(r15F6, r1603), 0x01));

   body.emit(assign(r15F5, r15F8, 0x01));

   body.emit(assign(r15F4, r15F7, 0x01));

   body.emit(assign(r15F3, r15F6, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
sub96(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1604 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r1604);
   ir_variable *const r1605 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r1605);
   ir_variable *const r1606 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a2", ir_var_function_in);
   sig_parameters.push_tail(r1606);
   ir_variable *const r1607 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r1607);
   ir_variable *const r1608 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r1608);
   ir_variable *const r1609 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b2", ir_var_function_in);
   sig_parameters.push_tail(r1609);
   ir_variable *const r160A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r160A);
   ir_variable *const r160B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r160B);
   ir_variable *const r160C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r160C);
   ir_variable *const r160D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r160D);
   ir_variable *const r160E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   ir_expression *const r160F = less(r1606, r1609);
   ir_expression *const r1610 = expr(ir_unop_b2i, r160F);
   body.emit(assign(r160E, expr(ir_unop_i2u, r1610), 0x01));

   ir_variable *const r1611 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1611, sub(r1605, r1608), 0x01));

   ir_expression *const r1612 = sub(r1604, r1607);
   ir_expression *const r1613 = less(r1611, r160E);
   ir_expression *const r1614 = expr(ir_unop_b2i, r1613);
   ir_expression *const r1615 = expr(ir_unop_i2u, r1614);
   body.emit(assign(r160D, sub(r1612, r1615), 0x01));

   ir_expression *const r1616 = less(r1605, r1608);
   ir_expression *const r1617 = expr(ir_unop_b2i, r1616);
   ir_expression *const r1618 = expr(ir_unop_i2u, r1617);
   body.emit(assign(r160D, sub(r160D, r1618), 0x01));

   body.emit(assign(r160C, sub(r1606, r1609), 0x01));

   body.emit(assign(r160B, sub(r1611, r160E), 0x01));

   body.emit(assign(r160A, r160D, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift64Right(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1619 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r1619);
   ir_variable *const r161A = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r161A);
   ir_variable *const r161B = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r161B);
   ir_variable *const r161C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r161C);
   ir_variable *const r161D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r161D);
   ir_variable *const r161E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r161E);
   ir_variable *const r161F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r161F);
   ir_variable *const r1620 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r1621 = neg(r161B);
   body.emit(assign(r1620, bit_and(r1621, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1623 = equal(r161B, body.constant(int(0)));
   ir_if *f1622 = new(mem_ctx) ir_if(operand(r1623).val);
   exec_list *const f1622_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1622->then_instructions;

      body.emit(assign(r161E, r161A, 0x01));

      body.emit(assign(r161F, r1619, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1622->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1625 = less(r161B, body.constant(int(32)));
      ir_if *f1624 = new(mem_ctx) ir_if(operand(r1625).val);
      exec_list *const f1624_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1624->then_instructions;

         ir_expression *const r1626 = lshift(r1619, r1620);
         ir_expression *const r1627 = rshift(r161A, r161B);
         body.emit(assign(r161E, bit_or(r1626, r1627), 0x01));

         body.emit(assign(r161F, rshift(r1619, r161B), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1624->else_instructions;

         ir_variable *const r1628 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r162A = less(r161B, body.constant(int(64)));
         ir_if *f1629 = new(mem_ctx) ir_if(operand(r162A).val);
         exec_list *const f1629_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1629->then_instructions;

            ir_expression *const r162B = bit_and(r161B, body.constant(int(31)));
            body.emit(assign(r1628, rshift(r1619, r162B), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1629->else_instructions;

            body.emit(assign(r1628, body.constant(0u), 0x01));


         body.instructions = f1629_parent_instructions;
         body.emit(f1629);

         /* END IF */

         body.emit(assign(r161E, r1628, 0x01));

         body.emit(assign(r161F, body.constant(0u), 0x01));


      body.instructions = f1624_parent_instructions;
      body.emit(f1624);

      /* END IF */


   body.instructions = f1622_parent_instructions;
   body.emit(f1622);

   /* END IF */

   body.emit(assign(r161D, r161E, 0x01));

   body.emit(assign(r161C, r161F, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
estimateDiv64To32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r162C = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r162C);
   ir_variable *const r162D = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r162D);
   ir_variable *const r162E = new(mem_ctx) ir_variable(glsl_type::uint_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r162E);
   ir_variable *const r162F = body.make_temp(glsl_type::uint_type, "return_value");
   ir_variable *const r1630 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
   body.emit(r1630);
   ir_variable *const r1631 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
   body.emit(r1631);
   ir_variable *const r1632 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
   body.emit(r1632);
   ir_variable *const r1633 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
   body.emit(r1633);
   body.emit(assign(r1632, body.constant(0u), 0x01));

   body.emit(assign(r1631, body.constant(0u), 0x01));

   /* IF CONDITION */
   ir_expression *const r1635 = lequal(r162E, r162C);
   ir_if *f1634 = new(mem_ctx) ir_if(operand(r1635).val);
   exec_list *const f1634_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1634->then_instructions;

      body.emit(assign(r162F, body.constant(4294967295u), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1634->else_instructions;

      body.emit(assign(r1633, rshift(r162E, body.constant(int(16))), 0x01));

      ir_variable *const r1636 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r1638 = lshift(r1633, body.constant(int(16)));
      ir_expression *const r1639 = lequal(r1638, r162C);
      ir_if *f1637 = new(mem_ctx) ir_if(operand(r1639).val);
      exec_list *const f1637_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1637->then_instructions;

         body.emit(assign(r1636, body.constant(4294901760u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1637->else_instructions;

         ir_expression *const r163A = expr(ir_binop_div, r162C, r1633);
         body.emit(assign(r1636, lshift(r163A, body.constant(int(16))), 0x01));


      body.instructions = f1637_parent_instructions;
      body.emit(f1637);

      /* END IF */

      body.emit(assign(r1630, r1636, 0x01));

      ir_variable *const r163B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r163B);
      ir_variable *const r163C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
      body.emit(r163C);
      ir_variable *const r163D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r163D);
      ir_variable *const r163E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r163E, bit_and(r162E, body.constant(65535u)), 0x01));

      ir_variable *const r163F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r163F, rshift(r162E, body.constant(int(16))), 0x01));

      ir_variable *const r1640 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r1640, bit_and(r1636, body.constant(65535u)), 0x01));

      ir_variable *const r1641 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r1641, rshift(r1636, body.constant(int(16))), 0x01));

      ir_variable *const r1642 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r1642, mul(r163F, r1640), 0x01));

      ir_expression *const r1643 = mul(r163E, r1641);
      body.emit(assign(r163C, add(r1643, r1642), 0x01));

      ir_expression *const r1644 = mul(r163F, r1641);
      ir_expression *const r1645 = less(r163C, r1642);
      ir_expression *const r1646 = expr(ir_unop_b2i, r1645);
      ir_expression *const r1647 = expr(ir_unop_i2u, r1646);
      ir_expression *const r1648 = lshift(r1647, body.constant(int(16)));
      ir_expression *const r1649 = rshift(r163C, body.constant(int(16)));
      ir_expression *const r164A = add(r1648, r1649);
      body.emit(assign(r163B, add(r1644, r164A), 0x01));

      body.emit(assign(r163C, lshift(r163C, body.constant(int(16))), 0x01));

      ir_expression *const r164B = mul(r163E, r1640);
      body.emit(assign(r163D, add(r164B, r163C), 0x01));

      ir_expression *const r164C = less(r163D, r163C);
      ir_expression *const r164D = expr(ir_unop_b2i, r164C);
      ir_expression *const r164E = expr(ir_unop_i2u, r164D);
      body.emit(assign(r163B, add(r163B, r164E), 0x01));

      ir_expression *const r164F = sub(r162C, r163B);
      ir_expression *const r1650 = less(r162D, r163D);
      ir_expression *const r1651 = expr(ir_unop_b2i, r1650);
      ir_expression *const r1652 = expr(ir_unop_i2u, r1651);
      body.emit(assign(r1632, sub(r164F, r1652), 0x01));

      body.emit(assign(r1631, sub(r162D, r163D), 0x01));

      /* LOOP BEGIN */
      ir_loop *f1653 = new(mem_ctx) ir_loop();
      exec_list *const f1653_parent_instructions = body.instructions;

         body.instructions = &f1653->body_instructions;

         /* IF CONDITION */
         ir_expression *const r1655 = expr(ir_unop_u2i, r1632);
         ir_expression *const r1656 = gequal(r1655, body.constant(int(0)));
         ir_if *f1654 = new(mem_ctx) ir_if(operand(r1656).val);
         exec_list *const f1654_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1654->then_instructions;

            body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


         body.instructions = f1654_parent_instructions;
         body.emit(f1654);

         /* END IF */

         body.emit(assign(r1630, add(r1630, body.constant(4294901760u)), 0x01));

         ir_variable *const r1657 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         ir_expression *const r1658 = lshift(r162E, body.constant(int(16)));
         body.emit(assign(r1657, add(r1631, r1658), 0x01));

         ir_expression *const r1659 = add(r1632, r1633);
         ir_expression *const r165A = less(r1657, r1631);
         ir_expression *const r165B = expr(ir_unop_b2i, r165A);
         ir_expression *const r165C = expr(ir_unop_i2u, r165B);
         body.emit(assign(r1632, add(r1659, r165C), 0x01));

         body.emit(assign(r1631, r1657, 0x01));

      /* LOOP END */

      body.instructions = f1653_parent_instructions;
      body.emit(f1653);

      ir_expression *const r165D = lshift(r1632, body.constant(int(16)));
      ir_expression *const r165E = rshift(r1631, body.constant(int(16)));
      body.emit(assign(r1632, bit_or(r165D, r165E), 0x01));

      ir_variable *const r165F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r1661 = lshift(r1633, body.constant(int(16)));
      ir_expression *const r1662 = lequal(r1661, r1632);
      ir_if *f1660 = new(mem_ctx) ir_if(operand(r1662).val);
      exec_list *const f1660_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1660->then_instructions;

         body.emit(assign(r165F, body.constant(65535u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1660->else_instructions;

         body.emit(assign(r165F, expr(ir_binop_div, r1632, r1633), 0x01));


      body.instructions = f1660_parent_instructions;
      body.emit(f1660);

      /* END IF */

      body.emit(assign(r1630, bit_or(r1630, r165F), 0x01));

      body.emit(assign(r162F, r1630, 0x01));


   body.instructions = f1634_parent_instructions;
   body.emit(f1634);

   /* END IF */

   body.emit(ret(r162F));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
mul64By32To96(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1663 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r1663);
   ir_variable *const r1664 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r1664);
   ir_variable *const r1665 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r1665);
   ir_variable *const r1666 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1666);
   ir_variable *const r1667 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1667);
   ir_variable *const r1668 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1668);
   ir_variable *const r1669 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r1669);
   ir_variable *const r166A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r166A);
   ir_variable *const r166B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r166B);
   ir_variable *const r166C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r166C, bit_and(r1664, body.constant(65535u)), 0x01));

   ir_variable *const r166D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r166D, rshift(r1664, body.constant(int(16))), 0x01));

   ir_variable *const r166E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r166E, bit_and(r1665, body.constant(65535u)), 0x01));

   ir_variable *const r166F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r166F, rshift(r1665, body.constant(int(16))), 0x01));

   ir_variable *const r1670 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1670, mul(r166D, r166E), 0x01));

   ir_expression *const r1671 = mul(r166C, r166F);
   body.emit(assign(r166A, add(r1671, r1670), 0x01));

   ir_expression *const r1672 = mul(r166D, r166F);
   ir_expression *const r1673 = less(r166A, r1670);
   ir_expression *const r1674 = expr(ir_unop_b2i, r1673);
   ir_expression *const r1675 = expr(ir_unop_i2u, r1674);
   ir_expression *const r1676 = lshift(r1675, body.constant(int(16)));
   ir_expression *const r1677 = rshift(r166A, body.constant(int(16)));
   ir_expression *const r1678 = add(r1676, r1677);
   body.emit(assign(r1669, add(r1672, r1678), 0x01));

   body.emit(assign(r166A, lshift(r166A, body.constant(int(16))), 0x01));

   ir_expression *const r1679 = mul(r166C, r166E);
   body.emit(assign(r166B, add(r1679, r166A), 0x01));

   ir_expression *const r167A = less(r166B, r166A);
   ir_expression *const r167B = expr(ir_unop_b2i, r167A);
   ir_expression *const r167C = expr(ir_unop_i2u, r167B);
   body.emit(assign(r1669, add(r1669, r167C), 0x01));

   ir_variable *const r167D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r167D);
   ir_variable *const r167E = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r167E);
   ir_variable *const r167F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r167F);
   ir_variable *const r1680 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1680, bit_and(r1663, body.constant(65535u)), 0x01));

   ir_variable *const r1681 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1681, rshift(r1663, body.constant(int(16))), 0x01));

   ir_variable *const r1682 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1682, bit_and(r1665, body.constant(65535u)), 0x01));

   ir_variable *const r1683 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1683, rshift(r1665, body.constant(int(16))), 0x01));

   ir_variable *const r1684 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1684, mul(r1681, r1682), 0x01));

   ir_expression *const r1685 = mul(r1680, r1683);
   body.emit(assign(r167E, add(r1685, r1684), 0x01));

   ir_expression *const r1686 = mul(r1681, r1683);
   ir_expression *const r1687 = less(r167E, r1684);
   ir_expression *const r1688 = expr(ir_unop_b2i, r1687);
   ir_expression *const r1689 = expr(ir_unop_i2u, r1688);
   ir_expression *const r168A = lshift(r1689, body.constant(int(16)));
   ir_expression *const r168B = rshift(r167E, body.constant(int(16)));
   ir_expression *const r168C = add(r168A, r168B);
   body.emit(assign(r167D, add(r1686, r168C), 0x01));

   body.emit(assign(r167E, lshift(r167E, body.constant(int(16))), 0x01));

   ir_expression *const r168D = mul(r1680, r1682);
   body.emit(assign(r167F, add(r168D, r167E), 0x01));

   ir_expression *const r168E = less(r167F, r167E);
   ir_expression *const r168F = expr(ir_unop_b2i, r168E);
   ir_expression *const r1690 = expr(ir_unop_i2u, r168F);
   body.emit(assign(r167D, add(r167D, r1690), 0x01));

   ir_variable *const r1691 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1691, add(r167F, r1669), 0x01));

   body.emit(assign(r1668, r166B, 0x01));

   body.emit(assign(r1667, r1691, 0x01));

   ir_expression *const r1692 = less(r1691, r167F);
   ir_expression *const r1693 = expr(ir_unop_b2i, r1692);
   ir_expression *const r1694 = expr(ir_unop_i2u, r1693);
   body.emit(assign(r1666, add(r167D, r1694), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fdiv64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1695 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1695);
   ir_variable *const r1696 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r1696);
   ir_variable *const r1697 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r1697, body.constant(true), 0x01));

   ir_variable *const r1698 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1699 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_auto);
   body.emit(r1699);
   ir_variable *const r169A = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
   body.emit(r169A);
   ir_variable *const r169B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
   body.emit(r169B);
   ir_variable *const r169C = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r169C);
   ir_variable *const r169D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
   body.emit(r169D);
   ir_variable *const r169E = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem3", ir_var_auto);
   body.emit(r169E);
   ir_variable *const r169F = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem2", ir_var_auto);
   body.emit(r169F);
   ir_variable *const r16A0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
   body.emit(r16A0);
   ir_variable *const r16A1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
   body.emit(r16A1);
   ir_variable *const r16A2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r16A2);
   ir_variable *const r16A3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r16A3);
   ir_variable *const r16A4 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r16A4);
   body.emit(assign(r16A3, body.constant(0u), 0x01));

   body.emit(assign(r16A2, body.constant(0u), 0x01));

   body.emit(assign(r16A1, body.constant(0u), 0x01));

   body.emit(assign(r16A0, body.constant(0u), 0x01));

   body.emit(assign(r169F, body.constant(0u), 0x01));

   body.emit(assign(r169E, body.constant(0u), 0x01));

   ir_variable *const r16A5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r16A5);
   body.emit(assign(r16A5, bit_and(swizzle_y(r1695), body.constant(1048575u)), 0x02));

   body.emit(assign(r16A5, swizzle_x(r1695), 0x01));

   body.emit(assign(r169D, r16A5, 0x03));

   ir_variable *const r16A6 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r16A7 = rshift(swizzle_y(r1695), body.constant(int(20)));
   ir_expression *const r16A8 = bit_and(r16A7, body.constant(2047u));
   body.emit(assign(r16A6, expr(ir_unop_u2i, r16A8), 0x01));

   body.emit(assign(r169C, r16A6, 0x01));

   ir_variable *const r16A9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r16A9);
   body.emit(assign(r16A9, bit_and(swizzle_y(r1696), body.constant(1048575u)), 0x02));

   body.emit(assign(r16A9, swizzle_x(r1696), 0x01));

   body.emit(assign(r169B, r16A9, 0x03));

   ir_variable *const r16AA = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r16AB = rshift(swizzle_y(r1696), body.constant(int(20)));
   ir_expression *const r16AC = bit_and(r16AB, body.constant(2047u));
   body.emit(assign(r16AA, expr(ir_unop_u2i, r16AC), 0x01));

   body.emit(assign(r169A, r16AA, 0x01));

   ir_expression *const r16AD = rshift(swizzle_y(r1695), body.constant(int(31)));
   ir_expression *const r16AE = rshift(swizzle_y(r1696), body.constant(int(31)));
   body.emit(assign(r1699, bit_xor(r16AD, r16AE), 0x01));

   /* IF CONDITION */
   ir_expression *const r16B0 = equal(r16A6, body.constant(int(2047)));
   ir_if *f16AF = new(mem_ctx) ir_if(operand(r16B0).val);
   exec_list *const f16AF_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f16AF->then_instructions;

      /* IF CONDITION */
      ir_expression *const r16B2 = bit_or(swizzle_y(r16A5), swizzle_x(r1695));
      ir_expression *const r16B3 = nequal(r16B2, body.constant(0u));
      ir_if *f16B1 = new(mem_ctx) ir_if(operand(r16B3).val);
      exec_list *const f16B1_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f16B1->then_instructions;

         ir_variable *const r16B4 = body.make_temp(glsl_type::uvec2_type, "a");
         body.emit(assign(r16B4, swizzle_x(r1695), 0x01));

         ir_variable *const r16B5 = body.make_temp(glsl_type::uvec2_type, "b");
         body.emit(assign(r16B5, swizzle_x(r1696), 0x01));

         ir_variable *const r16B6 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r16B7 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
         ir_expression *const r16B8 = rshift(swizzle_y(r1695), body.constant(int(19)));
         ir_expression *const r16B9 = bit_and(r16B8, body.constant(4095u));
         ir_expression *const r16BA = equal(r16B9, body.constant(4094u));
         ir_expression *const r16BB = nequal(swizzle_x(r1695), body.constant(0u));
         ir_expression *const r16BC = bit_and(swizzle_y(r1695), body.constant(524287u));
         ir_expression *const r16BD = nequal(r16BC, body.constant(0u));
         ir_expression *const r16BE = logic_or(r16BB, r16BD);
         body.emit(assign(r16B7, logic_and(r16BA, r16BE), 0x01));

         ir_variable *const r16BF = body.make_temp(glsl_type::bool_type, "is_nan_retval");
         ir_expression *const r16C0 = lshift(swizzle_y(r1696), body.constant(int(1)));
         ir_expression *const r16C1 = lequal(body.constant(4292870144u), r16C0);
         ir_expression *const r16C2 = nequal(swizzle_x(r1696), body.constant(0u));
         ir_expression *const r16C3 = bit_and(swizzle_y(r1696), body.constant(1048575u));
         ir_expression *const r16C4 = nequal(r16C3, body.constant(0u));
         ir_expression *const r16C5 = logic_or(r16C2, r16C4);
         body.emit(assign(r16BF, logic_and(r16C1, r16C5), 0x01));

         body.emit(assign(r16B4, bit_or(swizzle_y(r1695), body.constant(524288u)), 0x02));

         body.emit(assign(r16B5, bit_or(swizzle_y(r1696), body.constant(524288u)), 0x02));

         /* IF CONDITION */
         ir_expression *const r16C7 = lshift(swizzle_y(r1695), body.constant(int(1)));
         ir_expression *const r16C8 = lequal(body.constant(4292870144u), r16C7);
         ir_expression *const r16C9 = nequal(swizzle_x(r1695), body.constant(0u));
         ir_expression *const r16CA = bit_and(swizzle_y(r1695), body.constant(1048575u));
         ir_expression *const r16CB = nequal(r16CA, body.constant(0u));
         ir_expression *const r16CC = logic_or(r16C9, r16CB);
         ir_expression *const r16CD = logic_and(r16C8, r16CC);
         ir_if *f16C6 = new(mem_ctx) ir_if(operand(r16CD).val);
         exec_list *const f16C6_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f16C6->then_instructions;

            ir_variable *const r16CE = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r16D0 = logic_and(r16B7, r16BF);
            ir_if *f16CF = new(mem_ctx) ir_if(operand(r16D0).val);
            exec_list *const f16CF_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f16CF->then_instructions;

               body.emit(assign(r16CE, r16B5, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f16CF->else_instructions;

               body.emit(assign(r16CE, r16B4, 0x03));


            body.instructions = f16CF_parent_instructions;
            body.emit(f16CF);

            /* END IF */

            body.emit(assign(r16B6, r16CE, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f16C6->else_instructions;

            body.emit(assign(r16B6, r16B5, 0x03));


         body.instructions = f16C6_parent_instructions;
         body.emit(f16C6);

         /* END IF */

         body.emit(assign(r1698, r16B6, 0x03));

         body.emit(assign(r1697, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f16B1->else_instructions;

         /* IF CONDITION */
         ir_expression *const r16D2 = equal(r16AA, body.constant(int(2047)));
         ir_if *f16D1 = new(mem_ctx) ir_if(operand(r16D2).val);
         exec_list *const f16D1_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f16D1->then_instructions;

            /* IF CONDITION */
            ir_expression *const r16D4 = bit_or(swizzle_y(r16A9), swizzle_x(r1696));
            ir_expression *const r16D5 = nequal(r16D4, body.constant(0u));
            ir_if *f16D3 = new(mem_ctx) ir_if(operand(r16D5).val);
            exec_list *const f16D3_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f16D3->then_instructions;

               ir_variable *const r16D6 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r16D6, swizzle_x(r1695), 0x01));

               ir_variable *const r16D7 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r16D7, swizzle_x(r1696), 0x01));

               ir_variable *const r16D8 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r16D9 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r16DA = rshift(swizzle_y(r1695), body.constant(int(19)));
               ir_expression *const r16DB = bit_and(r16DA, body.constant(4095u));
               ir_expression *const r16DC = equal(r16DB, body.constant(4094u));
               ir_expression *const r16DD = nequal(swizzle_x(r1695), body.constant(0u));
               ir_expression *const r16DE = bit_and(swizzle_y(r1695), body.constant(524287u));
               ir_expression *const r16DF = nequal(r16DE, body.constant(0u));
               ir_expression *const r16E0 = logic_or(r16DD, r16DF);
               body.emit(assign(r16D9, logic_and(r16DC, r16E0), 0x01));

               ir_variable *const r16E1 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r16E2 = lshift(swizzle_y(r1696), body.constant(int(1)));
               ir_expression *const r16E3 = lequal(body.constant(4292870144u), r16E2);
               ir_expression *const r16E4 = nequal(swizzle_x(r1696), body.constant(0u));
               ir_expression *const r16E5 = bit_and(swizzle_y(r1696), body.constant(1048575u));
               ir_expression *const r16E6 = nequal(r16E5, body.constant(0u));
               ir_expression *const r16E7 = logic_or(r16E4, r16E6);
               body.emit(assign(r16E1, logic_and(r16E3, r16E7), 0x01));

               body.emit(assign(r16D6, bit_or(swizzle_y(r1695), body.constant(524288u)), 0x02));

               body.emit(assign(r16D7, bit_or(swizzle_y(r1696), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r16E9 = lshift(swizzle_y(r1695), body.constant(int(1)));
               ir_expression *const r16EA = lequal(body.constant(4292870144u), r16E9);
               ir_expression *const r16EB = nequal(swizzle_x(r1695), body.constant(0u));
               ir_expression *const r16EC = bit_and(swizzle_y(r1695), body.constant(1048575u));
               ir_expression *const r16ED = nequal(r16EC, body.constant(0u));
               ir_expression *const r16EE = logic_or(r16EB, r16ED);
               ir_expression *const r16EF = logic_and(r16EA, r16EE);
               ir_if *f16E8 = new(mem_ctx) ir_if(operand(r16EF).val);
               exec_list *const f16E8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f16E8->then_instructions;

                  ir_variable *const r16F0 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r16F2 = logic_and(r16D9, r16E1);
                  ir_if *f16F1 = new(mem_ctx) ir_if(operand(r16F2).val);
                  exec_list *const f16F1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f16F1->then_instructions;

                     body.emit(assign(r16F0, r16D7, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f16F1->else_instructions;

                     body.emit(assign(r16F0, r16D6, 0x03));


                  body.instructions = f16F1_parent_instructions;
                  body.emit(f16F1);

                  /* END IF */

                  body.emit(assign(r16D8, r16F0, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f16E8->else_instructions;

                  body.emit(assign(r16D8, r16D7, 0x03));


               body.instructions = f16E8_parent_instructions;
               body.emit(f16E8);

               /* END IF */

               body.emit(assign(r1698, r16D8, 0x03));

               body.emit(assign(r1697, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f16D3->else_instructions;

               ir_constant_data r16F3_data;
               memset(&r16F3_data, 0, sizeof(ir_constant_data));
r16F3_data.u[0] = 4294967295;
r16F3_data.u[1] = 4294967295;
               ir_constant *const r16F3 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r16F3_data);
               body.emit(assign(r1698, r16F3, 0x03));

               body.emit(assign(r1697, body.constant(false), 0x01));


            body.instructions = f16D3_parent_instructions;
            body.emit(f16D3);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f16D1->else_instructions;

            ir_variable *const r16F4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r16F4);
            ir_expression *const r16F5 = lshift(r1699, body.constant(int(31)));
            body.emit(assign(r16F4, add(r16F5, body.constant(2146435072u)), 0x02));

            body.emit(assign(r16F4, body.constant(0u), 0x01));

            body.emit(assign(r1698, r16F4, 0x03));

            body.emit(assign(r1697, body.constant(false), 0x01));


         body.instructions = f16D1_parent_instructions;
         body.emit(f16D1);

         /* END IF */


      body.instructions = f16B1_parent_instructions;
      body.emit(f16B1);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f16AF->else_instructions;

      /* IF CONDITION */
      ir_expression *const r16F7 = equal(r16AA, body.constant(int(2047)));
      ir_if *f16F6 = new(mem_ctx) ir_if(operand(r16F7).val);
      exec_list *const f16F6_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f16F6->then_instructions;

         /* IF CONDITION */
         ir_expression *const r16F9 = bit_or(swizzle_y(r16A9), swizzle_x(r1696));
         ir_expression *const r16FA = nequal(r16F9, body.constant(0u));
         ir_if *f16F8 = new(mem_ctx) ir_if(operand(r16FA).val);
         exec_list *const f16F8_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f16F8->then_instructions;

            ir_variable *const r16FB = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r16FB, swizzle_x(r1695), 0x01));

            ir_variable *const r16FC = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r16FC, swizzle_x(r1696), 0x01));

            ir_variable *const r16FD = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r16FE = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r16FF = rshift(swizzle_y(r1695), body.constant(int(19)));
            ir_expression *const r1700 = bit_and(r16FF, body.constant(4095u));
            ir_expression *const r1701 = equal(r1700, body.constant(4094u));
            ir_expression *const r1702 = nequal(swizzle_x(r1695), body.constant(0u));
            ir_expression *const r1703 = bit_and(swizzle_y(r1695), body.constant(524287u));
            ir_expression *const r1704 = nequal(r1703, body.constant(0u));
            ir_expression *const r1705 = logic_or(r1702, r1704);
            body.emit(assign(r16FE, logic_and(r1701, r1705), 0x01));

            ir_variable *const r1706 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r1707 = lshift(swizzle_y(r1696), body.constant(int(1)));
            ir_expression *const r1708 = lequal(body.constant(4292870144u), r1707);
            ir_expression *const r1709 = nequal(swizzle_x(r1696), body.constant(0u));
            ir_expression *const r170A = bit_and(swizzle_y(r1696), body.constant(1048575u));
            ir_expression *const r170B = nequal(r170A, body.constant(0u));
            ir_expression *const r170C = logic_or(r1709, r170B);
            body.emit(assign(r1706, logic_and(r1708, r170C), 0x01));

            body.emit(assign(r16FB, bit_or(swizzle_y(r1695), body.constant(524288u)), 0x02));

            body.emit(assign(r16FC, bit_or(swizzle_y(r1696), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r170E = lshift(swizzle_y(r1695), body.constant(int(1)));
            ir_expression *const r170F = lequal(body.constant(4292870144u), r170E);
            ir_expression *const r1710 = nequal(swizzle_x(r1695), body.constant(0u));
            ir_expression *const r1711 = bit_and(swizzle_y(r1695), body.constant(1048575u));
            ir_expression *const r1712 = nequal(r1711, body.constant(0u));
            ir_expression *const r1713 = logic_or(r1710, r1712);
            ir_expression *const r1714 = logic_and(r170F, r1713);
            ir_if *f170D = new(mem_ctx) ir_if(operand(r1714).val);
            exec_list *const f170D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f170D->then_instructions;

               ir_variable *const r1715 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r1717 = logic_and(r16FE, r1706);
               ir_if *f1716 = new(mem_ctx) ir_if(operand(r1717).val);
               exec_list *const f1716_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1716->then_instructions;

                  body.emit(assign(r1715, r16FC, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1716->else_instructions;

                  body.emit(assign(r1715, r16FB, 0x03));


               body.instructions = f1716_parent_instructions;
               body.emit(f1716);

               /* END IF */

               body.emit(assign(r16FD, r1715, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f170D->else_instructions;

               body.emit(assign(r16FD, r16FC, 0x03));


            body.instructions = f170D_parent_instructions;
            body.emit(f170D);

            /* END IF */

            body.emit(assign(r1698, r16FD, 0x03));

            body.emit(assign(r1697, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f16F8->else_instructions;

            ir_variable *const r1718 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r1718);
            body.emit(assign(r1718, lshift(r1699, body.constant(int(31))), 0x02));

            body.emit(assign(r1718, body.constant(0u), 0x01));

            body.emit(assign(r1698, r1718, 0x03));

            body.emit(assign(r1697, body.constant(false), 0x01));


         body.instructions = f16F8_parent_instructions;
         body.emit(f16F8);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f16F6->else_instructions;

         /* IF CONDITION */
         ir_expression *const r171A = equal(r16AA, body.constant(int(0)));
         ir_if *f1719 = new(mem_ctx) ir_if(operand(r171A).val);
         exec_list *const f1719_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1719->then_instructions;

            /* IF CONDITION */
            ir_expression *const r171C = bit_or(swizzle_y(r16A9), swizzle_x(r1696));
            ir_expression *const r171D = equal(r171C, body.constant(0u));
            ir_if *f171B = new(mem_ctx) ir_if(operand(r171D).val);
            exec_list *const f171B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f171B->then_instructions;

               /* IF CONDITION */
               ir_expression *const r171F = expr(ir_unop_i2u, r16A6);
               ir_expression *const r1720 = bit_or(r171F, swizzle_y(r16A5));
               ir_expression *const r1721 = bit_or(r1720, swizzle_x(r1695));
               ir_expression *const r1722 = equal(r1721, body.constant(0u));
               ir_if *f171E = new(mem_ctx) ir_if(operand(r1722).val);
               exec_list *const f171E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f171E->then_instructions;

                  ir_constant_data r1723_data;
                  memset(&r1723_data, 0, sizeof(ir_constant_data));
r1723_data.u[0] = 4294967295;
r1723_data.u[1] = 4294967295;
                  ir_constant *const r1723 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r1723_data);
                  body.emit(assign(r1698, r1723, 0x03));

                  body.emit(assign(r1697, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f171E->else_instructions;

                  ir_variable *const r1724 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1724);
                  ir_expression *const r1725 = lshift(r1699, body.constant(int(31)));
                  body.emit(assign(r1724, add(r1725, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r1724, body.constant(0u), 0x01));

                  body.emit(assign(r1698, r1724, 0x03));

                  body.emit(assign(r1697, body.constant(false), 0x01));


               body.instructions = f171E_parent_instructions;
               body.emit(f171E);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f171B->else_instructions;

               ir_variable *const r1726 = body.make_temp(glsl_type::uint_type, "aFrac0");
               body.emit(assign(r1726, swizzle_y(r16A9), 0x01));

               ir_variable *const r1727 = body.make_temp(glsl_type::uint_type, "aFrac1");
               body.emit(assign(r1727, swizzle_x(r16A9), 0x01));

               ir_variable *const r1728 = body.make_temp(glsl_type::int_type, "zExpPtr");
               body.emit(assign(r1728, r16AA, 0x01));

               ir_variable *const r1729 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
               body.emit(assign(r1729, swizzle_y(r16A9), 0x01));

               ir_variable *const r172A = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
               body.emit(assign(r172A, swizzle_x(r16A9), 0x01));

               ir_variable *const r172B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r172B);
               /* IF CONDITION */
               ir_expression *const r172D = equal(swizzle_y(r16A9), body.constant(0u));
               ir_if *f172C = new(mem_ctx) ir_if(operand(r172D).val);
               exec_list *const f172C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f172C->then_instructions;

                  ir_variable *const r172E = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r172E, r1727, 0x01));

                  ir_variable *const r172F = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r1730 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r1730);
                  /* IF CONDITION */
                  ir_expression *const r1732 = equal(swizzle_x(r1696), body.constant(0u));
                  ir_if *f1731 = new(mem_ctx) ir_if(operand(r1732).val);
                  exec_list *const f1731_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1731->then_instructions;

                     body.emit(assign(r172F, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1731->else_instructions;

                     body.emit(assign(r1730, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1734 = bit_and(swizzle_x(r1696), body.constant(4294901760u));
                     ir_expression *const r1735 = equal(r1734, body.constant(0u));
                     ir_if *f1733 = new(mem_ctx) ir_if(operand(r1735).val);
                     exec_list *const f1733_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1733->then_instructions;

                        body.emit(assign(r1730, body.constant(int(16)), 0x01));

                        body.emit(assign(r172E, lshift(swizzle_x(r1696), body.constant(int(16))), 0x01));


                     body.instructions = f1733_parent_instructions;
                     body.emit(f1733);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1737 = bit_and(r172E, body.constant(4278190080u));
                     ir_expression *const r1738 = equal(r1737, body.constant(0u));
                     ir_if *f1736 = new(mem_ctx) ir_if(operand(r1738).val);
                     exec_list *const f1736_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1736->then_instructions;

                        body.emit(assign(r1730, add(r1730, body.constant(int(8))), 0x01));

                        body.emit(assign(r172E, lshift(r172E, body.constant(int(8))), 0x01));


                     body.instructions = f1736_parent_instructions;
                     body.emit(f1736);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r173A = bit_and(r172E, body.constant(4026531840u));
                     ir_expression *const r173B = equal(r173A, body.constant(0u));
                     ir_if *f1739 = new(mem_ctx) ir_if(operand(r173B).val);
                     exec_list *const f1739_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1739->then_instructions;

                        body.emit(assign(r1730, add(r1730, body.constant(int(4))), 0x01));

                        body.emit(assign(r172E, lshift(r172E, body.constant(int(4))), 0x01));


                     body.instructions = f1739_parent_instructions;
                     body.emit(f1739);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r173D = bit_and(r172E, body.constant(3221225472u));
                     ir_expression *const r173E = equal(r173D, body.constant(0u));
                     ir_if *f173C = new(mem_ctx) ir_if(operand(r173E).val);
                     exec_list *const f173C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f173C->then_instructions;

                        body.emit(assign(r1730, add(r1730, body.constant(int(2))), 0x01));

                        body.emit(assign(r172E, lshift(r172E, body.constant(int(2))), 0x01));


                     body.instructions = f173C_parent_instructions;
                     body.emit(f173C);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1740 = bit_and(r172E, body.constant(2147483648u));
                     ir_expression *const r1741 = equal(r1740, body.constant(0u));
                     ir_if *f173F = new(mem_ctx) ir_if(operand(r1741).val);
                     exec_list *const f173F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f173F->then_instructions;

                        body.emit(assign(r1730, add(r1730, body.constant(int(1))), 0x01));


                     body.instructions = f173F_parent_instructions;
                     body.emit(f173F);

                     /* END IF */

                     body.emit(assign(r172F, r1730, 0x01));


                  body.instructions = f1731_parent_instructions;
                  body.emit(f1731);

                  /* END IF */

                  body.emit(assign(r172B, add(r172F, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1743 = less(r172B, body.constant(int(0)));
                  ir_if *f1742 = new(mem_ctx) ir_if(operand(r1743).val);
                  exec_list *const f1742_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1742->then_instructions;

                     ir_expression *const r1744 = neg(r172B);
                     body.emit(assign(r1729, rshift(swizzle_x(r1696), r1744), 0x01));

                     ir_expression *const r1745 = bit_and(r172B, body.constant(int(31)));
                     body.emit(assign(r172A, lshift(swizzle_x(r1696), r1745), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1742->else_instructions;

                     body.emit(assign(r1729, lshift(swizzle_x(r1696), r172B), 0x01));

                     body.emit(assign(r172A, body.constant(0u), 0x01));


                  body.instructions = f1742_parent_instructions;
                  body.emit(f1742);

                  /* END IF */

                  body.emit(assign(r1728, sub(body.constant(int(-31)), r172B), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f172C->else_instructions;

                  ir_variable *const r1746 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r1746, r1726, 0x01));

                  ir_variable *const r1747 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r1748 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r1748);
                  /* IF CONDITION */
                  ir_expression *const r174A = equal(swizzle_y(r16A9), body.constant(0u));
                  ir_if *f1749 = new(mem_ctx) ir_if(operand(r174A).val);
                  exec_list *const f1749_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1749->then_instructions;

                     body.emit(assign(r1747, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1749->else_instructions;

                     body.emit(assign(r1748, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r174C = bit_and(swizzle_y(r16A9), body.constant(4294901760u));
                     ir_expression *const r174D = equal(r174C, body.constant(0u));
                     ir_if *f174B = new(mem_ctx) ir_if(operand(r174D).val);
                     exec_list *const f174B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f174B->then_instructions;

                        body.emit(assign(r1748, body.constant(int(16)), 0x01));

                        body.emit(assign(r1746, lshift(swizzle_y(r16A9), body.constant(int(16))), 0x01));


                     body.instructions = f174B_parent_instructions;
                     body.emit(f174B);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r174F = bit_and(r1746, body.constant(4278190080u));
                     ir_expression *const r1750 = equal(r174F, body.constant(0u));
                     ir_if *f174E = new(mem_ctx) ir_if(operand(r1750).val);
                     exec_list *const f174E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f174E->then_instructions;

                        body.emit(assign(r1748, add(r1748, body.constant(int(8))), 0x01));

                        body.emit(assign(r1746, lshift(r1746, body.constant(int(8))), 0x01));


                     body.instructions = f174E_parent_instructions;
                     body.emit(f174E);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1752 = bit_and(r1746, body.constant(4026531840u));
                     ir_expression *const r1753 = equal(r1752, body.constant(0u));
                     ir_if *f1751 = new(mem_ctx) ir_if(operand(r1753).val);
                     exec_list *const f1751_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1751->then_instructions;

                        body.emit(assign(r1748, add(r1748, body.constant(int(4))), 0x01));

                        body.emit(assign(r1746, lshift(r1746, body.constant(int(4))), 0x01));


                     body.instructions = f1751_parent_instructions;
                     body.emit(f1751);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1755 = bit_and(r1746, body.constant(3221225472u));
                     ir_expression *const r1756 = equal(r1755, body.constant(0u));
                     ir_if *f1754 = new(mem_ctx) ir_if(operand(r1756).val);
                     exec_list *const f1754_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1754->then_instructions;

                        body.emit(assign(r1748, add(r1748, body.constant(int(2))), 0x01));

                        body.emit(assign(r1746, lshift(r1746, body.constant(int(2))), 0x01));


                     body.instructions = f1754_parent_instructions;
                     body.emit(f1754);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1758 = bit_and(r1746, body.constant(2147483648u));
                     ir_expression *const r1759 = equal(r1758, body.constant(0u));
                     ir_if *f1757 = new(mem_ctx) ir_if(operand(r1759).val);
                     exec_list *const f1757_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1757->then_instructions;

                        body.emit(assign(r1748, add(r1748, body.constant(int(1))), 0x01));


                     body.instructions = f1757_parent_instructions;
                     body.emit(f1757);

                     /* END IF */

                     body.emit(assign(r1747, r1748, 0x01));


                  body.instructions = f1749_parent_instructions;
                  body.emit(f1749);

                  /* END IF */

                  body.emit(assign(r172B, add(r1747, body.constant(int(-11))), 0x01));

                  ir_variable *const r175A = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r175A, lshift(swizzle_x(r1696), r172B), 0x01));

                  ir_variable *const r175B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r175D = equal(r172B, body.constant(int(0)));
                  ir_if *f175C = new(mem_ctx) ir_if(operand(r175D).val);
                  exec_list *const f175C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f175C->then_instructions;

                     body.emit(assign(r175B, r1726, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f175C->else_instructions;

                     ir_expression *const r175E = lshift(swizzle_y(r16A9), r172B);
                     ir_expression *const r175F = neg(r172B);
                     ir_expression *const r1760 = bit_and(r175F, body.constant(int(31)));
                     ir_expression *const r1761 = rshift(swizzle_x(r1696), r1760);
                     body.emit(assign(r175B, bit_or(r175E, r1761), 0x01));


                  body.instructions = f175C_parent_instructions;
                  body.emit(f175C);

                  /* END IF */

                  body.emit(assign(r1729, r175B, 0x01));

                  body.emit(assign(r172A, r175A, 0x01));

                  body.emit(assign(r1728, sub(body.constant(int(1)), r172B), 0x01));


               body.instructions = f172C_parent_instructions;
               body.emit(f172C);

               /* END IF */

               body.emit(assign(r169A, r1728, 0x01));

               body.emit(assign(r169B, r1729, 0x02));

               body.emit(assign(r169B, r172A, 0x01));


            body.instructions = f171B_parent_instructions;
            body.emit(f171B);

            /* END IF */


         body.instructions = f1719_parent_instructions;
         body.emit(f1719);

         /* END IF */

         /* IF CONDITION */
         ir_if *f1762 = new(mem_ctx) ir_if(operand(r1697).val);
         exec_list *const f1762_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1762->then_instructions;

            /* IF CONDITION */
            ir_expression *const r1764 = equal(r16A6, body.constant(int(0)));
            ir_if *f1763 = new(mem_ctx) ir_if(operand(r1764).val);
            exec_list *const f1763_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1763->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1766 = bit_or(swizzle_y(r16A5), swizzle_x(r1695));
               ir_expression *const r1767 = equal(r1766, body.constant(0u));
               ir_if *f1765 = new(mem_ctx) ir_if(operand(r1767).val);
               exec_list *const f1765_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1765->then_instructions;

                  ir_variable *const r1768 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1768);
                  body.emit(assign(r1768, lshift(r1699, body.constant(int(31))), 0x02));

                  body.emit(assign(r1768, body.constant(0u), 0x01));

                  body.emit(assign(r1698, r1768, 0x03));

                  body.emit(assign(r1697, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1765->else_instructions;

                  ir_variable *const r1769 = body.make_temp(glsl_type::uint_type, "aFrac0");
                  body.emit(assign(r1769, swizzle_y(r16A5), 0x01));

                  ir_variable *const r176A = body.make_temp(glsl_type::uint_type, "aFrac1");
                  body.emit(assign(r176A, swizzle_x(r16A5), 0x01));

                  ir_variable *const r176B = body.make_temp(glsl_type::int_type, "zExpPtr");
                  body.emit(assign(r176B, r16A6, 0x01));

                  ir_variable *const r176C = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
                  body.emit(assign(r176C, swizzle_y(r16A5), 0x01));

                  ir_variable *const r176D = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
                  body.emit(assign(r176D, swizzle_x(r16A5), 0x01));

                  ir_variable *const r176E = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r176E);
                  /* IF CONDITION */
                  ir_expression *const r1770 = equal(swizzle_y(r16A5), body.constant(0u));
                  ir_if *f176F = new(mem_ctx) ir_if(operand(r1770).val);
                  exec_list *const f176F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f176F->then_instructions;

                     ir_variable *const r1771 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r1771, r176A, 0x01));

                     ir_variable *const r1772 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r1773 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r1773);
                     /* IF CONDITION */
                     ir_expression *const r1775 = equal(swizzle_x(r1695), body.constant(0u));
                     ir_if *f1774 = new(mem_ctx) ir_if(operand(r1775).val);
                     exec_list *const f1774_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1774->then_instructions;

                        body.emit(assign(r1772, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1774->else_instructions;

                        body.emit(assign(r1773, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1777 = bit_and(swizzle_x(r1695), body.constant(4294901760u));
                        ir_expression *const r1778 = equal(r1777, body.constant(0u));
                        ir_if *f1776 = new(mem_ctx) ir_if(operand(r1778).val);
                        exec_list *const f1776_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1776->then_instructions;

                           body.emit(assign(r1773, body.constant(int(16)), 0x01));

                           body.emit(assign(r1771, lshift(swizzle_x(r1695), body.constant(int(16))), 0x01));


                        body.instructions = f1776_parent_instructions;
                        body.emit(f1776);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r177A = bit_and(r1771, body.constant(4278190080u));
                        ir_expression *const r177B = equal(r177A, body.constant(0u));
                        ir_if *f1779 = new(mem_ctx) ir_if(operand(r177B).val);
                        exec_list *const f1779_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1779->then_instructions;

                           body.emit(assign(r1773, add(r1773, body.constant(int(8))), 0x01));

                           body.emit(assign(r1771, lshift(r1771, body.constant(int(8))), 0x01));


                        body.instructions = f1779_parent_instructions;
                        body.emit(f1779);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r177D = bit_and(r1771, body.constant(4026531840u));
                        ir_expression *const r177E = equal(r177D, body.constant(0u));
                        ir_if *f177C = new(mem_ctx) ir_if(operand(r177E).val);
                        exec_list *const f177C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f177C->then_instructions;

                           body.emit(assign(r1773, add(r1773, body.constant(int(4))), 0x01));

                           body.emit(assign(r1771, lshift(r1771, body.constant(int(4))), 0x01));


                        body.instructions = f177C_parent_instructions;
                        body.emit(f177C);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1780 = bit_and(r1771, body.constant(3221225472u));
                        ir_expression *const r1781 = equal(r1780, body.constant(0u));
                        ir_if *f177F = new(mem_ctx) ir_if(operand(r1781).val);
                        exec_list *const f177F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f177F->then_instructions;

                           body.emit(assign(r1773, add(r1773, body.constant(int(2))), 0x01));

                           body.emit(assign(r1771, lshift(r1771, body.constant(int(2))), 0x01));


                        body.instructions = f177F_parent_instructions;
                        body.emit(f177F);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1783 = bit_and(r1771, body.constant(2147483648u));
                        ir_expression *const r1784 = equal(r1783, body.constant(0u));
                        ir_if *f1782 = new(mem_ctx) ir_if(operand(r1784).val);
                        exec_list *const f1782_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1782->then_instructions;

                           body.emit(assign(r1773, add(r1773, body.constant(int(1))), 0x01));


                        body.instructions = f1782_parent_instructions;
                        body.emit(f1782);

                        /* END IF */

                        body.emit(assign(r1772, r1773, 0x01));


                     body.instructions = f1774_parent_instructions;
                     body.emit(f1774);

                     /* END IF */

                     body.emit(assign(r176E, add(r1772, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1786 = less(r176E, body.constant(int(0)));
                     ir_if *f1785 = new(mem_ctx) ir_if(operand(r1786).val);
                     exec_list *const f1785_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1785->then_instructions;

                        ir_expression *const r1787 = neg(r176E);
                        body.emit(assign(r176C, rshift(swizzle_x(r1695), r1787), 0x01));

                        ir_expression *const r1788 = bit_and(r176E, body.constant(int(31)));
                        body.emit(assign(r176D, lshift(swizzle_x(r1695), r1788), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1785->else_instructions;

                        body.emit(assign(r176C, lshift(swizzle_x(r1695), r176E), 0x01));

                        body.emit(assign(r176D, body.constant(0u), 0x01));


                     body.instructions = f1785_parent_instructions;
                     body.emit(f1785);

                     /* END IF */

                     body.emit(assign(r176B, sub(body.constant(int(-31)), r176E), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f176F->else_instructions;

                     ir_variable *const r1789 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r1789, r1769, 0x01));

                     ir_variable *const r178A = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r178B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r178B);
                     /* IF CONDITION */
                     ir_expression *const r178D = equal(swizzle_y(r16A5), body.constant(0u));
                     ir_if *f178C = new(mem_ctx) ir_if(operand(r178D).val);
                     exec_list *const f178C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f178C->then_instructions;

                        body.emit(assign(r178A, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f178C->else_instructions;

                        body.emit(assign(r178B, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r178F = bit_and(swizzle_y(r16A5), body.constant(4294901760u));
                        ir_expression *const r1790 = equal(r178F, body.constant(0u));
                        ir_if *f178E = new(mem_ctx) ir_if(operand(r1790).val);
                        exec_list *const f178E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f178E->then_instructions;

                           body.emit(assign(r178B, body.constant(int(16)), 0x01));

                           body.emit(assign(r1789, lshift(swizzle_y(r16A5), body.constant(int(16))), 0x01));


                        body.instructions = f178E_parent_instructions;
                        body.emit(f178E);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1792 = bit_and(r1789, body.constant(4278190080u));
                        ir_expression *const r1793 = equal(r1792, body.constant(0u));
                        ir_if *f1791 = new(mem_ctx) ir_if(operand(r1793).val);
                        exec_list *const f1791_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1791->then_instructions;

                           body.emit(assign(r178B, add(r178B, body.constant(int(8))), 0x01));

                           body.emit(assign(r1789, lshift(r1789, body.constant(int(8))), 0x01));


                        body.instructions = f1791_parent_instructions;
                        body.emit(f1791);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1795 = bit_and(r1789, body.constant(4026531840u));
                        ir_expression *const r1796 = equal(r1795, body.constant(0u));
                        ir_if *f1794 = new(mem_ctx) ir_if(operand(r1796).val);
                        exec_list *const f1794_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1794->then_instructions;

                           body.emit(assign(r178B, add(r178B, body.constant(int(4))), 0x01));

                           body.emit(assign(r1789, lshift(r1789, body.constant(int(4))), 0x01));


                        body.instructions = f1794_parent_instructions;
                        body.emit(f1794);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1798 = bit_and(r1789, body.constant(3221225472u));
                        ir_expression *const r1799 = equal(r1798, body.constant(0u));
                        ir_if *f1797 = new(mem_ctx) ir_if(operand(r1799).val);
                        exec_list *const f1797_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1797->then_instructions;

                           body.emit(assign(r178B, add(r178B, body.constant(int(2))), 0x01));

                           body.emit(assign(r1789, lshift(r1789, body.constant(int(2))), 0x01));


                        body.instructions = f1797_parent_instructions;
                        body.emit(f1797);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r179B = bit_and(r1789, body.constant(2147483648u));
                        ir_expression *const r179C = equal(r179B, body.constant(0u));
                        ir_if *f179A = new(mem_ctx) ir_if(operand(r179C).val);
                        exec_list *const f179A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f179A->then_instructions;

                           body.emit(assign(r178B, add(r178B, body.constant(int(1))), 0x01));


                        body.instructions = f179A_parent_instructions;
                        body.emit(f179A);

                        /* END IF */

                        body.emit(assign(r178A, r178B, 0x01));


                     body.instructions = f178C_parent_instructions;
                     body.emit(f178C);

                     /* END IF */

                     body.emit(assign(r176E, add(r178A, body.constant(int(-11))), 0x01));

                     ir_variable *const r179D = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r179D, lshift(swizzle_x(r1695), r176E), 0x01));

                     ir_variable *const r179E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r17A0 = equal(r176E, body.constant(int(0)));
                     ir_if *f179F = new(mem_ctx) ir_if(operand(r17A0).val);
                     exec_list *const f179F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f179F->then_instructions;

                        body.emit(assign(r179E, r1769, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f179F->else_instructions;

                        ir_expression *const r17A1 = lshift(swizzle_y(r16A5), r176E);
                        ir_expression *const r17A2 = neg(r176E);
                        ir_expression *const r17A3 = bit_and(r17A2, body.constant(int(31)));
                        ir_expression *const r17A4 = rshift(swizzle_x(r1695), r17A3);
                        body.emit(assign(r179E, bit_or(r17A1, r17A4), 0x01));


                     body.instructions = f179F_parent_instructions;
                     body.emit(f179F);

                     /* END IF */

                     body.emit(assign(r176C, r179E, 0x01));

                     body.emit(assign(r176D, r179D, 0x01));

                     body.emit(assign(r176B, sub(body.constant(int(1)), r176E), 0x01));


                  body.instructions = f176F_parent_instructions;
                  body.emit(f176F);

                  /* END IF */

                  body.emit(assign(r169C, r176B, 0x01));

                  body.emit(assign(r169D, r176C, 0x02));

                  body.emit(assign(r169D, r176D, 0x01));


               body.instructions = f1765_parent_instructions;
               body.emit(f1765);

               /* END IF */


            body.instructions = f1763_parent_instructions;
            body.emit(f1763);

            /* END IF */

            /* IF CONDITION */
            ir_if *f17A5 = new(mem_ctx) ir_if(operand(r1697).val);
            exec_list *const f17A5_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f17A5->then_instructions;

               ir_expression *const r17A6 = sub(r169C, r169A);
               body.emit(assign(r16A4, add(r17A6, body.constant(int(1021))), 0x01));

               ir_variable *const r17A7 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r17A7, lshift(swizzle_x(r169D), body.constant(int(11))), 0x01));

               ir_variable *const r17A8 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r17A9 = bit_or(swizzle_y(r169D), body.constant(1048576u));
               ir_expression *const r17AA = lshift(r17A9, body.constant(int(11)));
               ir_expression *const r17AB = rshift(swizzle_x(r169D), body.constant(int(21)));
               body.emit(assign(r17A8, bit_or(r17AA, r17AB), 0x01));

               body.emit(assign(r169D, r17A8, 0x02));

               body.emit(assign(r169D, r17A7, 0x01));

               ir_variable *const r17AC = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r17AC, lshift(swizzle_x(r169B), body.constant(int(11))), 0x01));

               ir_variable *const r17AD = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r17AE = bit_or(swizzle_y(r169B), body.constant(1048576u));
               ir_expression *const r17AF = lshift(r17AE, body.constant(int(11)));
               ir_expression *const r17B0 = rshift(swizzle_x(r169B), body.constant(int(21)));
               body.emit(assign(r17AD, bit_or(r17AF, r17B0), 0x01));

               body.emit(assign(r169B, r17AD, 0x02));

               body.emit(assign(r169B, r17AC, 0x01));

               /* IF CONDITION */
               ir_expression *const r17B2 = less(r17AD, r17A8);
               ir_expression *const r17B3 = equal(r17AD, r17A8);
               ir_expression *const r17B4 = lequal(r17AC, r17A7);
               ir_expression *const r17B5 = logic_and(r17B3, r17B4);
               ir_expression *const r17B6 = logic_or(r17B2, r17B5);
               ir_if *f17B1 = new(mem_ctx) ir_if(operand(r17B6).val);
               exec_list *const f17B1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f17B1->then_instructions;

                  body.emit(assign(r169D, rshift(r17A8, body.constant(int(1))), 0x02));

                  ir_expression *const r17B7 = lshift(r17A8, body.constant(int(31)));
                  ir_expression *const r17B8 = rshift(r17A7, body.constant(int(1)));
                  body.emit(assign(r169D, bit_or(r17B7, r17B8), 0x01));

                  body.emit(assign(r16A4, add(r16A4, body.constant(int(1))), 0x01));


               body.instructions = f17B1_parent_instructions;
               body.emit(f17B1);

               /* END IF */

               ir_variable *const r17B9 = body.make_temp(glsl_type::uint_type, "return_value");
               ir_variable *const r17BA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r17BA);
               ir_variable *const r17BB = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
               body.emit(r17BB);
               ir_variable *const r17BC = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
               body.emit(r17BC);
               ir_variable *const r17BD = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
               body.emit(r17BD);
               body.emit(assign(r17BC, body.constant(0u), 0x01));

               body.emit(assign(r17BB, body.constant(0u), 0x01));

               /* IF CONDITION */
               ir_expression *const r17BF = lequal(r17AD, swizzle_y(r169D));
               ir_if *f17BE = new(mem_ctx) ir_if(operand(r17BF).val);
               exec_list *const f17BE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f17BE->then_instructions;

                  body.emit(assign(r17B9, body.constant(4294967295u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f17BE->else_instructions;

                  body.emit(assign(r17BD, rshift(r17AD, body.constant(int(16))), 0x01));

                  ir_variable *const r17C0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r17C2 = lshift(r17BD, body.constant(int(16)));
                  ir_expression *const r17C3 = lequal(r17C2, swizzle_y(r169D));
                  ir_if *f17C1 = new(mem_ctx) ir_if(operand(r17C3).val);
                  exec_list *const f17C1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f17C1->then_instructions;

                     body.emit(assign(r17C0, body.constant(4294901760u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f17C1->else_instructions;

                     ir_expression *const r17C4 = expr(ir_binop_div, swizzle_y(r169D), r17BD);
                     body.emit(assign(r17C0, lshift(r17C4, body.constant(int(16))), 0x01));


                  body.instructions = f17C1_parent_instructions;
                  body.emit(f17C1);

                  /* END IF */

                  body.emit(assign(r17BA, r17C0, 0x01));

                  ir_variable *const r17C5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r17C5);
                  ir_variable *const r17C6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r17C6);
                  ir_variable *const r17C7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r17C7);
                  ir_variable *const r17C8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r17C8, bit_and(r17AD, body.constant(65535u)), 0x01));

                  ir_variable *const r17C9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r17C9, rshift(r17AD, body.constant(int(16))), 0x01));

                  ir_variable *const r17CA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r17CA, bit_and(r17C0, body.constant(65535u)), 0x01));

                  ir_variable *const r17CB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r17CB, rshift(r17C0, body.constant(int(16))), 0x01));

                  ir_variable *const r17CC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r17CC, mul(r17C9, r17CA), 0x01));

                  ir_expression *const r17CD = mul(r17C8, r17CB);
                  body.emit(assign(r17C6, add(r17CD, r17CC), 0x01));

                  ir_expression *const r17CE = mul(r17C9, r17CB);
                  ir_expression *const r17CF = less(r17C6, r17CC);
                  ir_expression *const r17D0 = expr(ir_unop_b2i, r17CF);
                  ir_expression *const r17D1 = expr(ir_unop_i2u, r17D0);
                  ir_expression *const r17D2 = lshift(r17D1, body.constant(int(16)));
                  ir_expression *const r17D3 = rshift(r17C6, body.constant(int(16)));
                  ir_expression *const r17D4 = add(r17D2, r17D3);
                  body.emit(assign(r17C5, add(r17CE, r17D4), 0x01));

                  body.emit(assign(r17C6, lshift(r17C6, body.constant(int(16))), 0x01));

                  ir_expression *const r17D5 = mul(r17C8, r17CA);
                  body.emit(assign(r17C7, add(r17D5, r17C6), 0x01));

                  ir_expression *const r17D6 = less(r17C7, r17C6);
                  ir_expression *const r17D7 = expr(ir_unop_b2i, r17D6);
                  ir_expression *const r17D8 = expr(ir_unop_i2u, r17D7);
                  body.emit(assign(r17C5, add(r17C5, r17D8), 0x01));

                  ir_expression *const r17D9 = sub(swizzle_y(r169D), r17C5);
                  ir_expression *const r17DA = less(swizzle_x(r169D), r17C7);
                  ir_expression *const r17DB = expr(ir_unop_b2i, r17DA);
                  ir_expression *const r17DC = expr(ir_unop_i2u, r17DB);
                  body.emit(assign(r17BC, sub(r17D9, r17DC), 0x01));

                  body.emit(assign(r17BB, sub(swizzle_x(r169D), r17C7), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f17DD = new(mem_ctx) ir_loop();
                  exec_list *const f17DD_parent_instructions = body.instructions;

                     body.instructions = &f17DD->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r17DF = expr(ir_unop_u2i, r17BC);
                     ir_expression *const r17E0 = gequal(r17DF, body.constant(int(0)));
                     ir_if *f17DE = new(mem_ctx) ir_if(operand(r17E0).val);
                     exec_list *const f17DE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f17DE->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f17DE_parent_instructions;
                     body.emit(f17DE);

                     /* END IF */

                     body.emit(assign(r17BA, add(r17BA, body.constant(4294901760u)), 0x01));

                     ir_variable *const r17E1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r17E2 = lshift(r17AD, body.constant(int(16)));
                     body.emit(assign(r17E1, add(r17BB, r17E2), 0x01));

                     ir_expression *const r17E3 = add(r17BC, r17BD);
                     ir_expression *const r17E4 = less(r17E1, r17BB);
                     ir_expression *const r17E5 = expr(ir_unop_b2i, r17E4);
                     ir_expression *const r17E6 = expr(ir_unop_i2u, r17E5);
                     body.emit(assign(r17BC, add(r17E3, r17E6), 0x01));

                     body.emit(assign(r17BB, r17E1, 0x01));

                  /* LOOP END */

                  body.instructions = f17DD_parent_instructions;
                  body.emit(f17DD);

                  ir_expression *const r17E7 = lshift(r17BC, body.constant(int(16)));
                  ir_expression *const r17E8 = rshift(r17BB, body.constant(int(16)));
                  body.emit(assign(r17BC, bit_or(r17E7, r17E8), 0x01));

                  ir_variable *const r17E9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r17EB = lshift(r17BD, body.constant(int(16)));
                  ir_expression *const r17EC = lequal(r17EB, r17BC);
                  ir_if *f17EA = new(mem_ctx) ir_if(operand(r17EC).val);
                  exec_list *const f17EA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f17EA->then_instructions;

                     body.emit(assign(r17E9, body.constant(65535u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f17EA->else_instructions;

                     body.emit(assign(r17E9, expr(ir_binop_div, r17BC, r17BD), 0x01));


                  body.instructions = f17EA_parent_instructions;
                  body.emit(f17EA);

                  /* END IF */

                  body.emit(assign(r17BA, bit_or(r17BA, r17E9), 0x01));

                  body.emit(assign(r17B9, r17BA, 0x01));


               body.instructions = f17BE_parent_instructions;
               body.emit(f17BE);

               /* END IF */

               body.emit(assign(r16A3, r17B9, 0x01));

               ir_variable *const r17ED = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r17ED);
               ir_variable *const r17EE = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r17EE);
               ir_variable *const r17EF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r17EF);
               ir_variable *const r17F0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r17F0, bit_and(r17AC, body.constant(65535u)), 0x01));

               ir_variable *const r17F1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r17F1, rshift(r17AC, body.constant(int(16))), 0x01));

               ir_variable *const r17F2 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r17F2, bit_and(r17B9, body.constant(65535u)), 0x01));

               ir_variable *const r17F3 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r17F3, rshift(r17B9, body.constant(int(16))), 0x01));

               ir_variable *const r17F4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r17F4, mul(r17F1, r17F2), 0x01));

               ir_expression *const r17F5 = mul(r17F0, r17F3);
               body.emit(assign(r17EE, add(r17F5, r17F4), 0x01));

               ir_expression *const r17F6 = mul(r17F1, r17F3);
               ir_expression *const r17F7 = less(r17EE, r17F4);
               ir_expression *const r17F8 = expr(ir_unop_b2i, r17F7);
               ir_expression *const r17F9 = expr(ir_unop_i2u, r17F8);
               ir_expression *const r17FA = lshift(r17F9, body.constant(int(16)));
               ir_expression *const r17FB = rshift(r17EE, body.constant(int(16)));
               ir_expression *const r17FC = add(r17FA, r17FB);
               body.emit(assign(r17ED, add(r17F6, r17FC), 0x01));

               body.emit(assign(r17EE, lshift(r17EE, body.constant(int(16))), 0x01));

               ir_expression *const r17FD = mul(r17F0, r17F2);
               body.emit(assign(r17EF, add(r17FD, r17EE), 0x01));

               ir_expression *const r17FE = less(r17EF, r17EE);
               ir_expression *const r17FF = expr(ir_unop_b2i, r17FE);
               ir_expression *const r1800 = expr(ir_unop_i2u, r17FF);
               body.emit(assign(r17ED, add(r17ED, r1800), 0x01));

               ir_variable *const r1801 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1801);
               ir_variable *const r1802 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r1802);
               ir_variable *const r1803 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1803);
               ir_variable *const r1804 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1804, bit_and(r17AD, body.constant(65535u)), 0x01));

               ir_variable *const r1805 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1805, rshift(r17AD, body.constant(int(16))), 0x01));

               ir_variable *const r1806 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1806, bit_and(r17B9, body.constant(65535u)), 0x01));

               ir_variable *const r1807 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1807, rshift(r17B9, body.constant(int(16))), 0x01));

               ir_variable *const r1808 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1808, mul(r1805, r1806), 0x01));

               ir_expression *const r1809 = mul(r1804, r1807);
               body.emit(assign(r1802, add(r1809, r1808), 0x01));

               ir_expression *const r180A = mul(r1805, r1807);
               ir_expression *const r180B = less(r1802, r1808);
               ir_expression *const r180C = expr(ir_unop_b2i, r180B);
               ir_expression *const r180D = expr(ir_unop_i2u, r180C);
               ir_expression *const r180E = lshift(r180D, body.constant(int(16)));
               ir_expression *const r180F = rshift(r1802, body.constant(int(16)));
               ir_expression *const r1810 = add(r180E, r180F);
               body.emit(assign(r1801, add(r180A, r1810), 0x01));

               body.emit(assign(r1802, lshift(r1802, body.constant(int(16))), 0x01));

               ir_expression *const r1811 = mul(r1804, r1806);
               body.emit(assign(r1803, add(r1811, r1802), 0x01));

               ir_expression *const r1812 = less(r1803, r1802);
               ir_expression *const r1813 = expr(ir_unop_b2i, r1812);
               ir_expression *const r1814 = expr(ir_unop_i2u, r1813);
               body.emit(assign(r1801, add(r1801, r1814), 0x01));

               ir_variable *const r1815 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1815, add(r1803, r17ED), 0x01));

               ir_variable *const r1816 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1816);
               ir_variable *const r1817 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r1818 = less(body.constant(0u), r17EF);
               ir_expression *const r1819 = expr(ir_unop_b2i, r1818);
               body.emit(assign(r1817, expr(ir_unop_i2u, r1819), 0x01));

               ir_variable *const r181A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r181A, sub(swizzle_x(r169D), r1815), 0x01));

               ir_expression *const r181B = less(r1815, r1803);
               ir_expression *const r181C = expr(ir_unop_b2i, r181B);
               ir_expression *const r181D = expr(ir_unop_i2u, r181C);
               ir_expression *const r181E = add(r1801, r181D);
               ir_expression *const r181F = sub(swizzle_y(r169D), r181E);
               ir_expression *const r1820 = less(r181A, r1817);
               ir_expression *const r1821 = expr(ir_unop_b2i, r1820);
               ir_expression *const r1822 = expr(ir_unop_i2u, r1821);
               body.emit(assign(r1816, sub(r181F, r1822), 0x01));

               ir_expression *const r1823 = less(swizzle_x(r169D), r1815);
               ir_expression *const r1824 = expr(ir_unop_b2i, r1823);
               ir_expression *const r1825 = expr(ir_unop_i2u, r1824);
               body.emit(assign(r1816, sub(r1816, r1825), 0x01));

               body.emit(assign(r16A1, r1816, 0x01));

               body.emit(assign(r16A0, sub(r181A, r1817), 0x01));

               body.emit(assign(r169F, neg(r17EF), 0x01));

               /* LOOP BEGIN */
               ir_loop *f1826 = new(mem_ctx) ir_loop();
               exec_list *const f1826_parent_instructions = body.instructions;

                  body.instructions = &f1826->body_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1828 = expr(ir_unop_u2i, r16A1);
                  ir_expression *const r1829 = gequal(r1828, body.constant(int(0)));
                  ir_if *f1827 = new(mem_ctx) ir_if(operand(r1829).val);
                  exec_list *const f1827_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1827->then_instructions;

                     body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                  body.instructions = f1827_parent_instructions;
                  body.emit(f1827);

                  /* END IF */

                  body.emit(assign(r16A3, add(r16A3, body.constant(4294967295u)), 0x01));

                  ir_variable *const r182A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r182A);
                  ir_variable *const r182B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r182B);
                  ir_variable *const r182C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r182C, add(r169F, r17AC), 0x01));

                  ir_variable *const r182D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  ir_expression *const r182E = less(r182C, r169F);
                  ir_expression *const r182F = expr(ir_unop_b2i, r182E);
                  body.emit(assign(r182D, expr(ir_unop_i2u, r182F), 0x01));

                  ir_variable *const r1830 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1830, add(r16A0, r17AD), 0x01));

                  body.emit(assign(r182B, add(r1830, r182D), 0x01));

                  ir_expression *const r1831 = less(r182B, r182D);
                  ir_expression *const r1832 = expr(ir_unop_b2i, r1831);
                  ir_expression *const r1833 = expr(ir_unop_i2u, r1832);
                  body.emit(assign(r182A, add(r16A1, r1833), 0x01));

                  ir_expression *const r1834 = less(r1830, r16A0);
                  ir_expression *const r1835 = expr(ir_unop_b2i, r1834);
                  ir_expression *const r1836 = expr(ir_unop_i2u, r1835);
                  body.emit(assign(r182A, add(r182A, r1836), 0x01));

                  body.emit(assign(r16A1, r182A, 0x01));

                  body.emit(assign(r16A0, r182B, 0x01));

                  body.emit(assign(r169F, r182C, 0x01));

               /* LOOP END */

               body.instructions = f1826_parent_instructions;
               body.emit(f1826);

               ir_variable *const r1837 = body.make_temp(glsl_type::uint_type, "return_value");
               ir_variable *const r1838 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r1838);
               ir_variable *const r1839 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
               body.emit(r1839);
               ir_variable *const r183A = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
               body.emit(r183A);
               ir_variable *const r183B = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
               body.emit(r183B);
               body.emit(assign(r183A, body.constant(0u), 0x01));

               body.emit(assign(r1839, body.constant(0u), 0x01));

               /* IF CONDITION */
               ir_expression *const r183D = lequal(r17AD, r16A0);
               ir_if *f183C = new(mem_ctx) ir_if(operand(r183D).val);
               exec_list *const f183C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f183C->then_instructions;

                  body.emit(assign(r1837, body.constant(4294967295u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f183C->else_instructions;

                  body.emit(assign(r183B, rshift(r17AD, body.constant(int(16))), 0x01));

                  ir_variable *const r183E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1840 = lshift(r183B, body.constant(int(16)));
                  ir_expression *const r1841 = lequal(r1840, r16A0);
                  ir_if *f183F = new(mem_ctx) ir_if(operand(r1841).val);
                  exec_list *const f183F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f183F->then_instructions;

                     body.emit(assign(r183E, body.constant(4294901760u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f183F->else_instructions;

                     ir_expression *const r1842 = expr(ir_binop_div, r16A0, r183B);
                     body.emit(assign(r183E, lshift(r1842, body.constant(int(16))), 0x01));


                  body.instructions = f183F_parent_instructions;
                  body.emit(f183F);

                  /* END IF */

                  body.emit(assign(r1838, r183E, 0x01));

                  ir_variable *const r1843 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1843);
                  ir_variable *const r1844 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r1844);
                  ir_variable *const r1845 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1845);
                  ir_variable *const r1846 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1846, bit_and(r17AD, body.constant(65535u)), 0x01));

                  ir_variable *const r1847 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1847, rshift(r17AD, body.constant(int(16))), 0x01));

                  ir_variable *const r1848 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1848, bit_and(r183E, body.constant(65535u)), 0x01));

                  ir_variable *const r1849 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1849, rshift(r183E, body.constant(int(16))), 0x01));

                  ir_variable *const r184A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r184A, mul(r1847, r1848), 0x01));

                  ir_expression *const r184B = mul(r1846, r1849);
                  body.emit(assign(r1844, add(r184B, r184A), 0x01));

                  ir_expression *const r184C = mul(r1847, r1849);
                  ir_expression *const r184D = less(r1844, r184A);
                  ir_expression *const r184E = expr(ir_unop_b2i, r184D);
                  ir_expression *const r184F = expr(ir_unop_i2u, r184E);
                  ir_expression *const r1850 = lshift(r184F, body.constant(int(16)));
                  ir_expression *const r1851 = rshift(r1844, body.constant(int(16)));
                  ir_expression *const r1852 = add(r1850, r1851);
                  body.emit(assign(r1843, add(r184C, r1852), 0x01));

                  body.emit(assign(r1844, lshift(r1844, body.constant(int(16))), 0x01));

                  ir_expression *const r1853 = mul(r1846, r1848);
                  body.emit(assign(r1845, add(r1853, r1844), 0x01));

                  ir_expression *const r1854 = less(r1845, r1844);
                  ir_expression *const r1855 = expr(ir_unop_b2i, r1854);
                  ir_expression *const r1856 = expr(ir_unop_i2u, r1855);
                  body.emit(assign(r1843, add(r1843, r1856), 0x01));

                  ir_expression *const r1857 = sub(r16A0, r1843);
                  ir_expression *const r1858 = less(r169F, r1845);
                  ir_expression *const r1859 = expr(ir_unop_b2i, r1858);
                  ir_expression *const r185A = expr(ir_unop_i2u, r1859);
                  body.emit(assign(r183A, sub(r1857, r185A), 0x01));

                  body.emit(assign(r1839, sub(r169F, r1845), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f185B = new(mem_ctx) ir_loop();
                  exec_list *const f185B_parent_instructions = body.instructions;

                     body.instructions = &f185B->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r185D = expr(ir_unop_u2i, r183A);
                     ir_expression *const r185E = gequal(r185D, body.constant(int(0)));
                     ir_if *f185C = new(mem_ctx) ir_if(operand(r185E).val);
                     exec_list *const f185C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f185C->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f185C_parent_instructions;
                     body.emit(f185C);

                     /* END IF */

                     body.emit(assign(r1838, add(r1838, body.constant(4294901760u)), 0x01));

                     ir_variable *const r185F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r1860 = lshift(r17AD, body.constant(int(16)));
                     body.emit(assign(r185F, add(r1839, r1860), 0x01));

                     ir_expression *const r1861 = add(r183A, r183B);
                     ir_expression *const r1862 = less(r185F, r1839);
                     ir_expression *const r1863 = expr(ir_unop_b2i, r1862);
                     ir_expression *const r1864 = expr(ir_unop_i2u, r1863);
                     body.emit(assign(r183A, add(r1861, r1864), 0x01));

                     body.emit(assign(r1839, r185F, 0x01));

                  /* LOOP END */

                  body.instructions = f185B_parent_instructions;
                  body.emit(f185B);

                  ir_expression *const r1865 = lshift(r183A, body.constant(int(16)));
                  ir_expression *const r1866 = rshift(r1839, body.constant(int(16)));
                  body.emit(assign(r183A, bit_or(r1865, r1866), 0x01));

                  ir_variable *const r1867 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1869 = lshift(r183B, body.constant(int(16)));
                  ir_expression *const r186A = lequal(r1869, r183A);
                  ir_if *f1868 = new(mem_ctx) ir_if(operand(r186A).val);
                  exec_list *const f1868_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1868->then_instructions;

                     body.emit(assign(r1867, body.constant(65535u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1868->else_instructions;

                     body.emit(assign(r1867, expr(ir_binop_div, r183A, r183B), 0x01));


                  body.instructions = f1868_parent_instructions;
                  body.emit(f1868);

                  /* END IF */

                  body.emit(assign(r1838, bit_or(r1838, r1867), 0x01));

                  body.emit(assign(r1837, r1838, 0x01));


               body.instructions = f183C_parent_instructions;
               body.emit(f183C);

               /* END IF */

               body.emit(assign(r16A2, r1837, 0x01));

               /* IF CONDITION */
               ir_expression *const r186C = bit_and(r1837, body.constant(1023u));
               ir_expression *const r186D = lequal(r186C, body.constant(4u));
               ir_if *f186B = new(mem_ctx) ir_if(operand(r186D).val);
               exec_list *const f186B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f186B->then_instructions;

                  ir_variable *const r186E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r186E);
                  ir_variable *const r186F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r186F);
                  ir_variable *const r1870 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1870);
                  ir_variable *const r1871 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1871, bit_and(r17AC, body.constant(65535u)), 0x01));

                  ir_variable *const r1872 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1872, rshift(r17AC, body.constant(int(16))), 0x01));

                  ir_variable *const r1873 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1873, bit_and(r1837, body.constant(65535u)), 0x01));

                  ir_variable *const r1874 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1874, rshift(r1837, body.constant(int(16))), 0x01));

                  ir_variable *const r1875 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1875, mul(r1872, r1873), 0x01));

                  ir_expression *const r1876 = mul(r1871, r1874);
                  body.emit(assign(r186F, add(r1876, r1875), 0x01));

                  ir_expression *const r1877 = mul(r1872, r1874);
                  ir_expression *const r1878 = less(r186F, r1875);
                  ir_expression *const r1879 = expr(ir_unop_b2i, r1878);
                  ir_expression *const r187A = expr(ir_unop_i2u, r1879);
                  ir_expression *const r187B = lshift(r187A, body.constant(int(16)));
                  ir_expression *const r187C = rshift(r186F, body.constant(int(16)));
                  ir_expression *const r187D = add(r187B, r187C);
                  body.emit(assign(r186E, add(r1877, r187D), 0x01));

                  body.emit(assign(r186F, lshift(r186F, body.constant(int(16))), 0x01));

                  ir_expression *const r187E = mul(r1871, r1873);
                  body.emit(assign(r1870, add(r187E, r186F), 0x01));

                  ir_expression *const r187F = less(r1870, r186F);
                  ir_expression *const r1880 = expr(ir_unop_b2i, r187F);
                  ir_expression *const r1881 = expr(ir_unop_i2u, r1880);
                  body.emit(assign(r186E, add(r186E, r1881), 0x01));

                  ir_variable *const r1882 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1882);
                  ir_variable *const r1883 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r1883);
                  ir_variable *const r1884 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1884);
                  ir_variable *const r1885 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1885, bit_and(r17AD, body.constant(65535u)), 0x01));

                  ir_variable *const r1886 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1886, rshift(r17AD, body.constant(int(16))), 0x01));

                  ir_variable *const r1887 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1887, bit_and(r1837, body.constant(65535u)), 0x01));

                  ir_variable *const r1888 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1888, rshift(r1837, body.constant(int(16))), 0x01));

                  ir_variable *const r1889 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1889, mul(r1886, r1887), 0x01));

                  ir_expression *const r188A = mul(r1885, r1888);
                  body.emit(assign(r1883, add(r188A, r1889), 0x01));

                  ir_expression *const r188B = mul(r1886, r1888);
                  ir_expression *const r188C = less(r1883, r1889);
                  ir_expression *const r188D = expr(ir_unop_b2i, r188C);
                  ir_expression *const r188E = expr(ir_unop_i2u, r188D);
                  ir_expression *const r188F = lshift(r188E, body.constant(int(16)));
                  ir_expression *const r1890 = rshift(r1883, body.constant(int(16)));
                  ir_expression *const r1891 = add(r188F, r1890);
                  body.emit(assign(r1882, add(r188B, r1891), 0x01));

                  body.emit(assign(r1883, lshift(r1883, body.constant(int(16))), 0x01));

                  ir_expression *const r1892 = mul(r1885, r1887);
                  body.emit(assign(r1884, add(r1892, r1883), 0x01));

                  ir_expression *const r1893 = less(r1884, r1883);
                  ir_expression *const r1894 = expr(ir_unop_b2i, r1893);
                  ir_expression *const r1895 = expr(ir_unop_i2u, r1894);
                  body.emit(assign(r1882, add(r1882, r1895), 0x01));

                  ir_variable *const r1896 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1896, add(r1884, r186E), 0x01));

                  ir_variable *const r1897 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1897);
                  ir_variable *const r1898 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  ir_expression *const r1899 = less(body.constant(0u), r1870);
                  ir_expression *const r189A = expr(ir_unop_b2i, r1899);
                  body.emit(assign(r1898, expr(ir_unop_i2u, r189A), 0x01));

                  ir_variable *const r189B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r189B, sub(r169F, r1896), 0x01));

                  ir_expression *const r189C = less(r1896, r1884);
                  ir_expression *const r189D = expr(ir_unop_b2i, r189C);
                  ir_expression *const r189E = expr(ir_unop_i2u, r189D);
                  ir_expression *const r189F = add(r1882, r189E);
                  ir_expression *const r18A0 = sub(r16A0, r189F);
                  ir_expression *const r18A1 = less(r189B, r1898);
                  ir_expression *const r18A2 = expr(ir_unop_b2i, r18A1);
                  ir_expression *const r18A3 = expr(ir_unop_i2u, r18A2);
                  body.emit(assign(r1897, sub(r18A0, r18A3), 0x01));

                  ir_expression *const r18A4 = less(r169F, r1896);
                  ir_expression *const r18A5 = expr(ir_unop_b2i, r18A4);
                  ir_expression *const r18A6 = expr(ir_unop_i2u, r18A5);
                  body.emit(assign(r1897, sub(r1897, r18A6), 0x01));

                  body.emit(assign(r16A0, r1897, 0x01));

                  body.emit(assign(r169F, sub(r189B, r1898), 0x01));

                  body.emit(assign(r169E, neg(r1870), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f18A7 = new(mem_ctx) ir_loop();
                  exec_list *const f18A7_parent_instructions = body.instructions;

                     body.instructions = &f18A7->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r18A9 = expr(ir_unop_u2i, r16A0);
                     ir_expression *const r18AA = gequal(r18A9, body.constant(int(0)));
                     ir_if *f18A8 = new(mem_ctx) ir_if(operand(r18AA).val);
                     exec_list *const f18A8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f18A8->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f18A8_parent_instructions;
                     body.emit(f18A8);

                     /* END IF */

                     body.emit(assign(r16A2, add(r16A2, body.constant(4294967295u)), 0x01));

                     ir_variable *const r18AB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r18AB);
                     ir_variable *const r18AC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r18AC);
                     ir_variable *const r18AD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r18AD, add(r169E, r17AC), 0x01));

                     ir_variable *const r18AE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r18AF = less(r18AD, r169E);
                     ir_expression *const r18B0 = expr(ir_unop_b2i, r18AF);
                     body.emit(assign(r18AE, expr(ir_unop_i2u, r18B0), 0x01));

                     ir_variable *const r18B1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r18B1, add(r169F, r17AD), 0x01));

                     body.emit(assign(r18AC, add(r18B1, r18AE), 0x01));

                     ir_expression *const r18B2 = less(r18AC, r18AE);
                     ir_expression *const r18B3 = expr(ir_unop_b2i, r18B2);
                     ir_expression *const r18B4 = expr(ir_unop_i2u, r18B3);
                     body.emit(assign(r18AB, add(r16A0, r18B4), 0x01));

                     ir_expression *const r18B5 = less(r18B1, r169F);
                     ir_expression *const r18B6 = expr(ir_unop_b2i, r18B5);
                     ir_expression *const r18B7 = expr(ir_unop_i2u, r18B6);
                     body.emit(assign(r18AB, add(r18AB, r18B7), 0x01));

                     body.emit(assign(r16A0, r18AB, 0x01));

                     body.emit(assign(r169F, r18AC, 0x01));

                     body.emit(assign(r169E, r18AD, 0x01));

                  /* LOOP END */

                  body.instructions = f18A7_parent_instructions;
                  body.emit(f18A7);

                  ir_expression *const r18B8 = bit_or(r16A0, r169F);
                  ir_expression *const r18B9 = bit_or(r18B8, r169E);
                  ir_expression *const r18BA = nequal(r18B9, body.constant(0u));
                  ir_expression *const r18BB = expr(ir_unop_b2i, r18BA);
                  ir_expression *const r18BC = expr(ir_unop_i2u, r18BB);
                  body.emit(assign(r16A2, bit_or(r16A2, r18BC), 0x01));


               body.instructions = f186B_parent_instructions;
               body.emit(f186B);

               /* END IF */

               ir_variable *const r18BD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r18BD);
               ir_variable *const r18BE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r18BE);
               ir_variable *const r18BF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r18BF);
               body.emit(assign(r18BD, lshift(r16A2, body.constant(int(21))), 0x01));

               ir_expression *const r18C0 = lshift(r16A3, body.constant(int(21)));
               ir_expression *const r18C1 = rshift(r16A2, body.constant(int(11)));
               body.emit(assign(r18BE, bit_or(r18C0, r18C1), 0x01));

               body.emit(assign(r18BF, rshift(r16A3, body.constant(int(11))), 0x01));

               body.emit(assign(r18BD, bit_or(r18BD, body.constant(0u)), 0x01));

               body.emit(assign(r16A3, r18BF, 0x01));

               body.emit(assign(r16A2, r18BE, 0x01));

               ir_variable *const r18C2 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r18C2, r16A4, 0x01));

               ir_variable *const r18C3 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r18C3, r18BF, 0x01));

               ir_variable *const r18C4 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r18C4, r18BE, 0x01));

               ir_variable *const r18C5 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r18C5, r18BD, 0x01));

               ir_variable *const r18C6 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r18C6, body.constant(true), 0x01));

               ir_variable *const r18C7 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r18C8 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r18C8);
               ir_expression *const r18C9 = expr(ir_unop_u2i, r18BD);
               body.emit(assign(r18C8, less(r18C9, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r18CB = lequal(body.constant(int(2045)), r16A4);
               ir_if *f18CA = new(mem_ctx) ir_if(operand(r18CB).val);
               exec_list *const f18CA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f18CA->then_instructions;

                  ir_variable *const r18CC = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r18CE = less(body.constant(int(2045)), r16A4);
                  ir_if *f18CD = new(mem_ctx) ir_if(operand(r18CE).val);
                  exec_list *const f18CD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f18CD->then_instructions;

                     body.emit(assign(r18CC, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f18CD->else_instructions;

                     ir_variable *const r18CF = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r18D1 = equal(r16A4, body.constant(int(2045)));
                     ir_if *f18D0 = new(mem_ctx) ir_if(operand(r18D1).val);
                     exec_list *const f18D0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f18D0->then_instructions;

                        ir_expression *const r18D2 = equal(body.constant(2097151u), r18BF);
                        ir_expression *const r18D3 = equal(body.constant(4294967295u), r18BE);
                        body.emit(assign(r18CF, logic_and(r18D2, r18D3), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f18D0->else_instructions;

                        body.emit(assign(r18CF, body.constant(false), 0x01));


                     body.instructions = f18D0_parent_instructions;
                     body.emit(f18D0);

                     /* END IF */

                     body.emit(assign(r18CC, logic_and(r18CF, r18C8), 0x01));


                  body.instructions = f18CD_parent_instructions;
                  body.emit(f18CD);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f18D4 = new(mem_ctx) ir_if(operand(r18CC).val);
                  exec_list *const f18D4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f18D4->then_instructions;

                     ir_variable *const r18D5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r18D5);
                     ir_expression *const r18D6 = lshift(r1699, body.constant(int(31)));
                     body.emit(assign(r18D5, add(r18D6, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r18D5, body.constant(0u), 0x01));

                     body.emit(assign(r18C7, r18D5, 0x03));

                     body.emit(assign(r18C6, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f18D4->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r18D8 = less(r16A4, body.constant(int(0)));
                     ir_if *f18D7 = new(mem_ctx) ir_if(operand(r18D8).val);
                     exec_list *const f18D7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f18D7->then_instructions;

                        ir_variable *const r18D9 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r18D9, r18BD, 0x01));

                        ir_variable *const r18DA = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r18DA, neg(r16A4), 0x01));

                        ir_variable *const r18DB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r18DB);
                        ir_variable *const r18DC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r18DC);
                        ir_variable *const r18DD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r18DD);
                        ir_variable *const r18DE = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r18DF = neg(r18DA);
                        body.emit(assign(r18DE, bit_and(r18DF, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r18E1 = equal(r18DA, body.constant(int(0)));
                        ir_if *f18E0 = new(mem_ctx) ir_if(operand(r18E1).val);
                        exec_list *const f18E0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f18E0->then_instructions;

                           body.emit(assign(r18DB, r18BD, 0x01));

                           body.emit(assign(r18DC, r18BE, 0x01));

                           body.emit(assign(r18DD, r18BF, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f18E0->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r18E3 = less(r18DA, body.constant(int(32)));
                           ir_if *f18E2 = new(mem_ctx) ir_if(operand(r18E3).val);
                           exec_list *const f18E2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f18E2->then_instructions;

                              body.emit(assign(r18DB, lshift(r18BE, r18DE), 0x01));

                              ir_expression *const r18E4 = lshift(r18BF, r18DE);
                              ir_expression *const r18E5 = rshift(r18BE, r18DA);
                              body.emit(assign(r18DC, bit_or(r18E4, r18E5), 0x01));

                              body.emit(assign(r18DD, rshift(r18BF, r18DA), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f18E2->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r18E7 = equal(r18DA, body.constant(int(32)));
                              ir_if *f18E6 = new(mem_ctx) ir_if(operand(r18E7).val);
                              exec_list *const f18E6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f18E6->then_instructions;

                                 body.emit(assign(r18DB, r18BE, 0x01));

                                 body.emit(assign(r18DC, r18BF, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f18E6->else_instructions;

                                 body.emit(assign(r18D9, bit_or(r18BD, r18BE), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r18E9 = less(r18DA, body.constant(int(64)));
                                 ir_if *f18E8 = new(mem_ctx) ir_if(operand(r18E9).val);
                                 exec_list *const f18E8_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f18E8->then_instructions;

                                    body.emit(assign(r18DB, lshift(r18BF, r18DE), 0x01));

                                    ir_expression *const r18EA = bit_and(r18DA, body.constant(int(31)));
                                    body.emit(assign(r18DC, rshift(r18BF, r18EA), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f18E8->else_instructions;

                                    ir_variable *const r18EB = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r18ED = equal(r18DA, body.constant(int(64)));
                                    ir_if *f18EC = new(mem_ctx) ir_if(operand(r18ED).val);
                                    exec_list *const f18EC_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f18EC->then_instructions;

                                       body.emit(assign(r18EB, r18BF, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f18EC->else_instructions;

                                       ir_expression *const r18EE = nequal(r18BF, body.constant(0u));
                                       ir_expression *const r18EF = expr(ir_unop_b2i, r18EE);
                                       body.emit(assign(r18EB, expr(ir_unop_i2u, r18EF), 0x01));


                                    body.instructions = f18EC_parent_instructions;
                                    body.emit(f18EC);

                                    /* END IF */

                                    body.emit(assign(r18DB, r18EB, 0x01));

                                    body.emit(assign(r18DC, body.constant(0u), 0x01));


                                 body.instructions = f18E8_parent_instructions;
                                 body.emit(f18E8);

                                 /* END IF */


                              body.instructions = f18E6_parent_instructions;
                              body.emit(f18E6);

                              /* END IF */

                              body.emit(assign(r18DD, body.constant(0u), 0x01));


                           body.instructions = f18E2_parent_instructions;
                           body.emit(f18E2);

                           /* END IF */

                           ir_expression *const r18F0 = nequal(r18D9, body.constant(0u));
                           ir_expression *const r18F1 = expr(ir_unop_b2i, r18F0);
                           ir_expression *const r18F2 = expr(ir_unop_i2u, r18F1);
                           body.emit(assign(r18DB, bit_or(r18DB, r18F2), 0x01));


                        body.instructions = f18E0_parent_instructions;
                        body.emit(f18E0);

                        /* END IF */

                        body.emit(assign(r18C3, r18DD, 0x01));

                        body.emit(assign(r18C4, r18DC, 0x01));

                        body.emit(assign(r18C5, r18DB, 0x01));

                        body.emit(assign(r18C2, body.constant(int(0)), 0x01));

                        body.emit(assign(r18C8, less(r18DB, body.constant(0u)), 0x01));


                     body.instructions = f18D7_parent_instructions;
                     body.emit(f18D7);

                     /* END IF */


                  body.instructions = f18D4_parent_instructions;
                  body.emit(f18D4);

                  /* END IF */


               body.instructions = f18CA_parent_instructions;
               body.emit(f18CA);

               /* END IF */

               /* IF CONDITION */
               ir_if *f18F3 = new(mem_ctx) ir_if(operand(r18C6).val);
               exec_list *const f18F3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f18F3->then_instructions;

                  /* IF CONDITION */
                  ir_if *f18F4 = new(mem_ctx) ir_if(operand(r18C8).val);
                  exec_list *const f18F4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f18F4->then_instructions;

                     ir_variable *const r18F5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r18F5, add(r18C4, body.constant(1u)), 0x01));

                     ir_expression *const r18F6 = less(r18F5, r18C4);
                     ir_expression *const r18F7 = expr(ir_unop_b2i, r18F6);
                     ir_expression *const r18F8 = expr(ir_unop_i2u, r18F7);
                     body.emit(assign(r18C3, add(r18C3, r18F8), 0x01));

                     ir_expression *const r18F9 = equal(r18C5, body.constant(0u));
                     ir_expression *const r18FA = expr(ir_unop_b2i, r18F9);
                     ir_expression *const r18FB = expr(ir_unop_i2u, r18FA);
                     ir_expression *const r18FC = add(r18C5, r18FB);
                     ir_expression *const r18FD = bit_and(r18FC, body.constant(1u));
                     ir_expression *const r18FE = expr(ir_unop_bit_not, r18FD);
                     body.emit(assign(r18C4, bit_and(r18F5, r18FE), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f18F4->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1900 = bit_or(r18C3, r18C4);
                     ir_expression *const r1901 = equal(r1900, body.constant(0u));
                     ir_if *f18FF = new(mem_ctx) ir_if(operand(r1901).val);
                     exec_list *const f18FF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f18FF->then_instructions;

                        body.emit(assign(r18C2, body.constant(int(0)), 0x01));


                     body.instructions = f18FF_parent_instructions;
                     body.emit(f18FF);

                     /* END IF */


                  body.instructions = f18F4_parent_instructions;
                  body.emit(f18F4);

                  /* END IF */

                  ir_variable *const r1902 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1902);
                  ir_expression *const r1903 = lshift(r1699, body.constant(int(31)));
                  ir_expression *const r1904 = expr(ir_unop_i2u, r18C2);
                  ir_expression *const r1905 = lshift(r1904, body.constant(int(20)));
                  ir_expression *const r1906 = add(r1903, r1905);
                  body.emit(assign(r1902, add(r1906, r18C3), 0x02));

                  body.emit(assign(r1902, r18C4, 0x01));

                  body.emit(assign(r18C7, r1902, 0x03));

                  body.emit(assign(r18C6, body.constant(false), 0x01));


               body.instructions = f18F3_parent_instructions;
               body.emit(f18F3);

               /* END IF */

               body.emit(assign(r1698, r18C7, 0x03));

               body.emit(assign(r1697, body.constant(false), 0x01));


            body.instructions = f17A5_parent_instructions;
            body.emit(f17A5);

            /* END IF */


         body.instructions = f1762_parent_instructions;
         body.emit(f1762);

         /* END IF */


      body.instructions = f16F6_parent_instructions;
      body.emit(f16F6);

      /* END IF */


   body.instructions = f16AF_parent_instructions;
   body.emit(f16AF);

   /* END IF */

   body.emit(ret(r1698));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
normalizeFloat32Subnormal(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1907 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac", ir_var_function_in);
   sig_parameters.push_tail(r1907);
   ir_variable *const r1908 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExpPtr", ir_var_function_inout);
   sig_parameters.push_tail(r1908);
   ir_variable *const r1909 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFracPtr", ir_var_function_inout);
   sig_parameters.push_tail(r1909);
   ir_variable *const r190A = body.make_temp(glsl_type::uint_type, "a");
   body.emit(assign(r190A, r1907, 0x01));

   ir_variable *const r190B = body.make_temp(glsl_type::int_type, "return_value");
   ir_variable *const r190C = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r190C);
   /* IF CONDITION */
   ir_expression *const r190E = equal(r1907, body.constant(0u));
   ir_if *f190D = new(mem_ctx) ir_if(operand(r190E).val);
   exec_list *const f190D_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f190D->then_instructions;

      body.emit(assign(r190B, body.constant(int(32)), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f190D->else_instructions;

      body.emit(assign(r190C, body.constant(int(0)), 0x01));

      /* IF CONDITION */
      ir_expression *const r1910 = bit_and(r1907, body.constant(4294901760u));
      ir_expression *const r1911 = equal(r1910, body.constant(0u));
      ir_if *f190F = new(mem_ctx) ir_if(operand(r1911).val);
      exec_list *const f190F_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f190F->then_instructions;

         body.emit(assign(r190C, body.constant(int(16)), 0x01));

         body.emit(assign(r190A, lshift(r1907, body.constant(int(16))), 0x01));


      body.instructions = f190F_parent_instructions;
      body.emit(f190F);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1913 = bit_and(r190A, body.constant(4278190080u));
      ir_expression *const r1914 = equal(r1913, body.constant(0u));
      ir_if *f1912 = new(mem_ctx) ir_if(operand(r1914).val);
      exec_list *const f1912_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1912->then_instructions;

         body.emit(assign(r190C, add(r190C, body.constant(int(8))), 0x01));

         body.emit(assign(r190A, lshift(r190A, body.constant(int(8))), 0x01));


      body.instructions = f1912_parent_instructions;
      body.emit(f1912);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1916 = bit_and(r190A, body.constant(4026531840u));
      ir_expression *const r1917 = equal(r1916, body.constant(0u));
      ir_if *f1915 = new(mem_ctx) ir_if(operand(r1917).val);
      exec_list *const f1915_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1915->then_instructions;

         body.emit(assign(r190C, add(r190C, body.constant(int(4))), 0x01));

         body.emit(assign(r190A, lshift(r190A, body.constant(int(4))), 0x01));


      body.instructions = f1915_parent_instructions;
      body.emit(f1915);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1919 = bit_and(r190A, body.constant(3221225472u));
      ir_expression *const r191A = equal(r1919, body.constant(0u));
      ir_if *f1918 = new(mem_ctx) ir_if(operand(r191A).val);
      exec_list *const f1918_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1918->then_instructions;

         body.emit(assign(r190C, add(r190C, body.constant(int(2))), 0x01));

         body.emit(assign(r190A, lshift(r190A, body.constant(int(2))), 0x01));


      body.instructions = f1918_parent_instructions;
      body.emit(f1918);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r191C = bit_and(r190A, body.constant(2147483648u));
      ir_expression *const r191D = equal(r191C, body.constant(0u));
      ir_if *f191B = new(mem_ctx) ir_if(operand(r191D).val);
      exec_list *const f191B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f191B->then_instructions;

         body.emit(assign(r190C, add(r190C, body.constant(int(1))), 0x01));


      body.instructions = f191B_parent_instructions;
      body.emit(f191B);

      /* END IF */

      body.emit(assign(r190B, r190C, 0x01));


   body.instructions = f190D_parent_instructions;
   body.emit(f190D);

   /* END IF */

   ir_variable *const r191E = body.make_temp(glsl_type::int_type, "assignment_tmp");
   body.emit(assign(r191E, add(r190B, body.constant(int(-8))), 0x01));

   body.emit(assign(r1909, lshift(r1907, r191E), 0x01));

   body.emit(assign(r1908, sub(body.constant(int(1)), r191E), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat32Frac(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r191F = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r191F);
   ir_expression *const r1920 = bit_and(r191F, body.constant(8388607u));
   body.emit(ret(r1920));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat32Exp(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::int_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1921 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1921);
   ir_expression *const r1922 = rshift(r1921, body.constant(int(23)));
   ir_expression *const r1923 = bit_and(r1922, body.constant(255u));
   ir_expression *const r1924 = expr(ir_unop_u2i, r1923);
   body.emit(ret(r1924));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat32Sign(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1925 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1925);
   ir_expression *const r1926 = rshift(r1925, body.constant(int(31)));
   body.emit(ret(r1926));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fp32_to_fp64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1927 = new(mem_ctx) ir_variable(glsl_type::float_type, "f", ir_var_function_in);
   sig_parameters.push_tail(r1927);
   ir_variable *const r1928 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r1928, body.constant(true), 0x01));

   ir_variable *const r1929 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r192A = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r192A);
   ir_variable *const r192B = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac", ir_var_auto);
   body.emit(r192B);
   ir_variable *const r192C = body.make_temp(glsl_type::uint_type, "floatBitsToUint_retval");
   body.emit(assign(r192C, expr(ir_unop_bitcast_f2u, r1927), 0x01));

   ir_variable *const r192D = body.make_temp(glsl_type::uint_type, "extractFloat32Frac_retval");
   body.emit(assign(r192D, bit_and(r192C, body.constant(8388607u)), 0x01));

   body.emit(assign(r192B, r192D, 0x01));

   ir_variable *const r192E = body.make_temp(glsl_type::int_type, "extractFloat32Exp_retval");
   ir_expression *const r192F = rshift(r192C, body.constant(int(23)));
   ir_expression *const r1930 = bit_and(r192F, body.constant(255u));
   body.emit(assign(r192E, expr(ir_unop_u2i, r1930), 0x01));

   body.emit(assign(r192A, r192E, 0x01));

   ir_variable *const r1931 = body.make_temp(glsl_type::uint_type, "extractFloat32Sign_retval");
   body.emit(assign(r1931, rshift(r192C, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1933 = equal(r192E, body.constant(int(255)));
   ir_if *f1932 = new(mem_ctx) ir_if(operand(r1933).val);
   exec_list *const f1932_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1932->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1935 = nequal(r192D, body.constant(0u));
      ir_if *f1934 = new(mem_ctx) ir_if(operand(r1935).val);
      exec_list *const f1934_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1934->then_instructions;

         ir_variable *const r1936 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "nan", ir_var_auto);
         body.emit(r1936);
         body.emit(assign(r1936, body.constant(0u), 0x01));

         body.emit(assign(r1936, lshift(r192C, body.constant(int(9))), 0x02));

         ir_variable *const r1937 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r1937);
         body.emit(assign(r1937, rshift(swizzle_y(r1936), body.constant(int(12))), 0x01));

         ir_expression *const r1938 = lshift(swizzle_y(r1936), body.constant(int(20)));
         body.emit(assign(r1936, bit_or(r1938, body.constant(0u)), 0x01));

         ir_expression *const r1939 = lshift(r1931, body.constant(int(31)));
         ir_expression *const r193A = bit_or(r1939, body.constant(2146959360u));
         body.emit(assign(r1936, bit_or(r1937, r193A), 0x02));

         body.emit(assign(r1929, r1936, 0x03));

         body.emit(assign(r1928, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1934->else_instructions;

         ir_variable *const r193B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r193B);
         ir_expression *const r193C = lshift(r1931, body.constant(int(31)));
         body.emit(assign(r193B, add(r193C, body.constant(2146435072u)), 0x02));

         body.emit(assign(r193B, body.constant(0u), 0x01));

         body.emit(assign(r1929, r193B, 0x03));

         body.emit(assign(r1928, body.constant(false), 0x01));


      body.instructions = f1934_parent_instructions;
      body.emit(f1934);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1932->else_instructions;

      /* IF CONDITION */
      ir_expression *const r193E = equal(r192E, body.constant(int(0)));
      ir_if *f193D = new(mem_ctx) ir_if(operand(r193E).val);
      exec_list *const f193D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f193D->then_instructions;

         /* IF CONDITION */
         ir_expression *const r1940 = equal(r192D, body.constant(0u));
         ir_if *f193F = new(mem_ctx) ir_if(operand(r1940).val);
         exec_list *const f193F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f193F->then_instructions;

            ir_variable *const r1941 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r1941);
            body.emit(assign(r1941, lshift(r1931, body.constant(int(31))), 0x02));

            body.emit(assign(r1941, body.constant(0u), 0x01));

            body.emit(assign(r1929, r1941, 0x03));

            body.emit(assign(r1928, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f193F->else_instructions;

            ir_variable *const r1942 = body.make_temp(glsl_type::int_type, "zExpPtr");
            body.emit(assign(r1942, r192E, 0x01));

            ir_variable *const r1943 = body.make_temp(glsl_type::uint_type, "zFracPtr");
            body.emit(assign(r1943, r192D, 0x01));

            ir_variable *const r1944 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r1944, r192D, 0x01));

            ir_variable *const r1945 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r1946 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r1946);
            /* IF CONDITION */
            ir_expression *const r1948 = equal(r192D, body.constant(0u));
            ir_if *f1947 = new(mem_ctx) ir_if(operand(r1948).val);
            exec_list *const f1947_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1947->then_instructions;

               body.emit(assign(r1945, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1947->else_instructions;

               body.emit(assign(r1946, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r194A = bit_and(r192D, body.constant(4294901760u));
               ir_expression *const r194B = equal(r194A, body.constant(0u));
               ir_if *f1949 = new(mem_ctx) ir_if(operand(r194B).val);
               exec_list *const f1949_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1949->then_instructions;

                  body.emit(assign(r1946, body.constant(int(16)), 0x01));

                  body.emit(assign(r1944, lshift(r192D, body.constant(int(16))), 0x01));


               body.instructions = f1949_parent_instructions;
               body.emit(f1949);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r194D = bit_and(r1944, body.constant(4278190080u));
               ir_expression *const r194E = equal(r194D, body.constant(0u));
               ir_if *f194C = new(mem_ctx) ir_if(operand(r194E).val);
               exec_list *const f194C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f194C->then_instructions;

                  body.emit(assign(r1946, add(r1946, body.constant(int(8))), 0x01));

                  body.emit(assign(r1944, lshift(r1944, body.constant(int(8))), 0x01));


               body.instructions = f194C_parent_instructions;
               body.emit(f194C);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1950 = bit_and(r1944, body.constant(4026531840u));
               ir_expression *const r1951 = equal(r1950, body.constant(0u));
               ir_if *f194F = new(mem_ctx) ir_if(operand(r1951).val);
               exec_list *const f194F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f194F->then_instructions;

                  body.emit(assign(r1946, add(r1946, body.constant(int(4))), 0x01));

                  body.emit(assign(r1944, lshift(r1944, body.constant(int(4))), 0x01));


               body.instructions = f194F_parent_instructions;
               body.emit(f194F);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1953 = bit_and(r1944, body.constant(3221225472u));
               ir_expression *const r1954 = equal(r1953, body.constant(0u));
               ir_if *f1952 = new(mem_ctx) ir_if(operand(r1954).val);
               exec_list *const f1952_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1952->then_instructions;

                  body.emit(assign(r1946, add(r1946, body.constant(int(2))), 0x01));

                  body.emit(assign(r1944, lshift(r1944, body.constant(int(2))), 0x01));


               body.instructions = f1952_parent_instructions;
               body.emit(f1952);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1956 = bit_and(r1944, body.constant(2147483648u));
               ir_expression *const r1957 = equal(r1956, body.constant(0u));
               ir_if *f1955 = new(mem_ctx) ir_if(operand(r1957).val);
               exec_list *const f1955_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1955->then_instructions;

                  body.emit(assign(r1946, add(r1946, body.constant(int(1))), 0x01));


               body.instructions = f1955_parent_instructions;
               body.emit(f1955);

               /* END IF */

               body.emit(assign(r1945, r1946, 0x01));


            body.instructions = f1947_parent_instructions;
            body.emit(f1947);

            /* END IF */

            ir_variable *const r1958 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            body.emit(assign(r1958, add(r1945, body.constant(int(-8))), 0x01));

            body.emit(assign(r1943, lshift(r192D, r1958), 0x01));

            body.emit(assign(r1942, sub(body.constant(int(1)), r1958), 0x01));

            body.emit(assign(r192B, r1943, 0x01));

            body.emit(assign(r192A, add(r1942, body.constant(int(-1))), 0x01));


         body.instructions = f193F_parent_instructions;
         body.emit(f193F);

         /* END IF */


      body.instructions = f193D_parent_instructions;
      body.emit(f193D);

      /* END IF */

      /* IF CONDITION */
      ir_if *f1959 = new(mem_ctx) ir_if(operand(r1928).val);
      exec_list *const f1959_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1959->then_instructions;

         ir_variable *const r195A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r195A);
         ir_expression *const r195B = lshift(r1931, body.constant(int(31)));
         ir_expression *const r195C = add(r192A, body.constant(int(896)));
         ir_expression *const r195D = expr(ir_unop_i2u, r195C);
         ir_expression *const r195E = lshift(r195D, body.constant(int(20)));
         ir_expression *const r195F = add(r195B, r195E);
         ir_expression *const r1960 = rshift(r192B, body.constant(int(3)));
         body.emit(assign(r195A, add(r195F, r1960), 0x02));

         ir_expression *const r1961 = lshift(r192B, body.constant(int(29)));
         body.emit(assign(r195A, bit_or(r1961, body.constant(0u)), 0x01));

         body.emit(assign(r1929, r195A, 0x03));

         body.emit(assign(r1928, body.constant(false), 0x01));


      body.instructions = f1959_parent_instructions;
      body.emit(f1959);

      /* END IF */


   body.instructions = f1932_parent_instructions;
   body.emit(f1932);

   /* END IF */

   body.emit(ret(r1929));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
packFloat32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1962 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r1962);
   ir_variable *const r1963 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r1963);
   ir_variable *const r1964 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac", ir_var_function_in);
   sig_parameters.push_tail(r1964);
   ir_expression *const r1965 = lshift(r1962, body.constant(int(31)));
   ir_expression *const r1966 = expr(ir_unop_i2u, r1963);
   ir_expression *const r1967 = lshift(r1966, body.constant(int(23)));
   ir_expression *const r1968 = add(r1965, r1967);
   ir_expression *const r1969 = add(r1968, r1964);
   body.emit(ret(r1969));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift32RightJamming(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r196A = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r196A);
   ir_variable *const r196B = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r196B);
   ir_variable *const r196C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zPtr", ir_var_function_inout);
   sig_parameters.push_tail(r196C);
   ir_variable *const r196D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
   body.emit(r196D);
   /* IF CONDITION */
   ir_expression *const r196F = equal(r196B, body.constant(int(0)));
   ir_if *f196E = new(mem_ctx) ir_if(operand(r196F).val);
   exec_list *const f196E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f196E->then_instructions;

      body.emit(assign(r196D, r196A, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f196E->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1971 = less(r196B, body.constant(int(32)));
      ir_if *f1970 = new(mem_ctx) ir_if(operand(r1971).val);
      exec_list *const f1970_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1970->then_instructions;

         ir_expression *const r1972 = rshift(r196A, r196B);
         ir_expression *const r1973 = neg(r196B);
         ir_expression *const r1974 = bit_and(r1973, body.constant(int(31)));
         ir_expression *const r1975 = lshift(r196A, r1974);
         ir_expression *const r1976 = nequal(r1975, body.constant(0u));
         ir_expression *const r1977 = expr(ir_unop_b2i, r1976);
         ir_expression *const r1978 = expr(ir_unop_i2u, r1977);
         body.emit(assign(r196D, bit_or(r1972, r1978), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1970->else_instructions;

         ir_expression *const r1979 = nequal(r196A, body.constant(0u));
         ir_expression *const r197A = expr(ir_unop_b2i, r1979);
         body.emit(assign(r196D, expr(ir_unop_i2u, r197A), 0x01));


      body.instructions = f1970_parent_instructions;
      body.emit(f1970);

      /* END IF */


   body.instructions = f196E_parent_instructions;
   body.emit(f196E);

   /* END IF */

   body.emit(assign(r196C, r196D, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
roundAndPackFloat32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r197B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r197B);
   ir_variable *const r197C = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r197C);
   ir_variable *const r197D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac", ir_var_function_in);
   sig_parameters.push_tail(r197D);
   ir_variable *const r197E = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r197E, body.constant(true), 0x01));

   ir_variable *const r197F = body.make_temp(glsl_type::uint_type, "return_value");
   ir_variable *const r1980 = new(mem_ctx) ir_variable(glsl_type::int_type, "roundBits", ir_var_auto);
   body.emit(r1980);
   ir_expression *const r1981 = expr(ir_unop_u2i, r197D);
   body.emit(assign(r1980, bit_and(r1981, body.constant(int(127))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1983 = expr(ir_unop_i2u, r197C);
   ir_expression *const r1984 = lequal(body.constant(253u), r1983);
   ir_if *f1982 = new(mem_ctx) ir_if(operand(r1984).val);
   exec_list *const f1982_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1982->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1986 = less(body.constant(int(253)), r197C);
      ir_expression *const r1987 = equal(r197C, body.constant(int(253)));
      ir_expression *const r1988 = add(r197D, body.constant(64u));
      ir_expression *const r1989 = expr(ir_unop_u2i, r1988);
      ir_expression *const r198A = less(r1989, body.constant(int(0)));
      ir_expression *const r198B = logic_and(r1987, r198A);
      ir_expression *const r198C = logic_or(r1986, r198B);
      ir_if *f1985 = new(mem_ctx) ir_if(operand(r198C).val);
      exec_list *const f1985_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1985->then_instructions;

         ir_expression *const r198D = lshift(r197B, body.constant(int(31)));
         body.emit(assign(r197F, add(r198D, body.constant(2139095040u)), 0x01));

         body.emit(assign(r197E, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1985->else_instructions;

         /* IF CONDITION */
         ir_expression *const r198F = less(r197C, body.constant(int(0)));
         ir_if *f198E = new(mem_ctx) ir_if(operand(r198F).val);
         exec_list *const f198E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f198E->then_instructions;

            ir_variable *const r1990 = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r1990, neg(r197C), 0x01));

            ir_variable *const r1991 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
            body.emit(r1991);
            /* IF CONDITION */
            ir_expression *const r1993 = equal(r1990, body.constant(int(0)));
            ir_if *f1992 = new(mem_ctx) ir_if(operand(r1993).val);
            exec_list *const f1992_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1992->then_instructions;

               body.emit(assign(r1991, r197D, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1992->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1995 = less(r1990, body.constant(int(32)));
               ir_if *f1994 = new(mem_ctx) ir_if(operand(r1995).val);
               exec_list *const f1994_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1994->then_instructions;

                  ir_expression *const r1996 = rshift(r197D, r1990);
                  ir_expression *const r1997 = neg(r1990);
                  ir_expression *const r1998 = bit_and(r1997, body.constant(int(31)));
                  ir_expression *const r1999 = lshift(r197D, r1998);
                  ir_expression *const r199A = nequal(r1999, body.constant(0u));
                  ir_expression *const r199B = expr(ir_unop_b2i, r199A);
                  ir_expression *const r199C = expr(ir_unop_i2u, r199B);
                  body.emit(assign(r1991, bit_or(r1996, r199C), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1994->else_instructions;

                  ir_expression *const r199D = nequal(r197D, body.constant(0u));
                  ir_expression *const r199E = expr(ir_unop_b2i, r199D);
                  body.emit(assign(r1991, expr(ir_unop_i2u, r199E), 0x01));


               body.instructions = f1994_parent_instructions;
               body.emit(f1994);

               /* END IF */


            body.instructions = f1992_parent_instructions;
            body.emit(f1992);

            /* END IF */

            body.emit(assign(r197D, r1991, 0x01));

            body.emit(assign(r197C, body.constant(int(0)), 0x01));

            ir_expression *const r199F = expr(ir_unop_u2i, r1991);
            body.emit(assign(r1980, bit_and(r199F, body.constant(int(127))), 0x01));


         body.instructions = f198E_parent_instructions;
         body.emit(f198E);

         /* END IF */


      body.instructions = f1985_parent_instructions;
      body.emit(f1985);

      /* END IF */


   body.instructions = f1982_parent_instructions;
   body.emit(f1982);

   /* END IF */

   /* IF CONDITION */
   ir_if *f19A0 = new(mem_ctx) ir_if(operand(r197E).val);
   exec_list *const f19A0_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f19A0->then_instructions;

      ir_expression *const r19A1 = add(r197D, body.constant(64u));
      body.emit(assign(r197D, rshift(r19A1, body.constant(int(7))), 0x01));

      ir_expression *const r19A2 = bit_xor(r1980, body.constant(int(64)));
      ir_expression *const r19A3 = equal(r19A2, body.constant(int(0)));
      ir_expression *const r19A4 = expr(ir_unop_b2i, r19A3);
      ir_expression *const r19A5 = expr(ir_unop_i2u, r19A4);
      ir_expression *const r19A6 = bit_and(r19A5, body.constant(1u));
      ir_expression *const r19A7 = expr(ir_unop_bit_not, r19A6);
      body.emit(assign(r197D, bit_and(r197D, r19A7), 0x01));

      /* IF CONDITION */
      ir_expression *const r19A9 = equal(r197D, body.constant(0u));
      ir_if *f19A8 = new(mem_ctx) ir_if(operand(r19A9).val);
      exec_list *const f19A8_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f19A8->then_instructions;

         body.emit(assign(r197C, body.constant(int(0)), 0x01));


      body.instructions = f19A8_parent_instructions;
      body.emit(f19A8);

      /* END IF */

      ir_expression *const r19AA = lshift(r197B, body.constant(int(31)));
      ir_expression *const r19AB = expr(ir_unop_i2u, r197C);
      ir_expression *const r19AC = lshift(r19AB, body.constant(int(23)));
      ir_expression *const r19AD = add(r19AA, r19AC);
      body.emit(assign(r197F, add(r19AD, r197D), 0x01));

      body.emit(assign(r197E, body.constant(false), 0x01));


   body.instructions = f19A0_parent_instructions;
   body.emit(f19A0);

   /* END IF */

   body.emit(ret(r197F));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fp64_to_fp32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::float_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r19AE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r19AE);
   ir_variable *const r19AF = body.make_temp(glsl_type::float_type, "return_value");
   ir_variable *const r19B0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac", ir_var_auto);
   body.emit(r19B0);
   body.emit(assign(r19B0, body.constant(0u), 0x01));

   ir_variable *const r19B1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r19B1);
   body.emit(assign(r19B1, bit_and(swizzle_y(r19AE), body.constant(1048575u)), 0x02));

   body.emit(assign(r19B1, swizzle_x(r19AE), 0x01));

   ir_variable *const r19B2 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r19B3 = rshift(swizzle_y(r19AE), body.constant(int(20)));
   ir_expression *const r19B4 = bit_and(r19B3, body.constant(2047u));
   body.emit(assign(r19B2, expr(ir_unop_u2i, r19B4), 0x01));

   ir_variable *const r19B5 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r19B5, rshift(swizzle_y(r19AE), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r19B7 = equal(r19B2, body.constant(int(2047)));
   ir_if *f19B6 = new(mem_ctx) ir_if(operand(r19B7).val);
   exec_list *const f19B6_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f19B6->then_instructions;

      /* IF CONDITION */
      ir_expression *const r19B9 = bit_or(swizzle_y(r19B1), swizzle_x(r19AE));
      ir_expression *const r19BA = nequal(r19B9, body.constant(0u));
      ir_if *f19B8 = new(mem_ctx) ir_if(operand(r19BA).val);
      exec_list *const f19B8_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f19B8->then_instructions;

         ir_variable *const r19BB = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r19BB, lshift(swizzle_x(r19AE), body.constant(int(12))), 0x01));

         ir_variable *const r19BC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         ir_expression *const r19BD = lshift(swizzle_y(r19AE), body.constant(int(12)));
         ir_expression *const r19BE = rshift(swizzle_x(r19AE), body.constant(int(20)));
         body.emit(assign(r19BC, bit_or(r19BD, r19BE), 0x01));

         body.emit(assign(r19AE, r19BC, 0x02));

         body.emit(assign(r19AE, r19BB, 0x01));

         ir_expression *const r19BF = lshift(r19B5, body.constant(int(31)));
         ir_expression *const r19C0 = bit_or(r19BF, body.constant(2143289344u));
         ir_expression *const r19C1 = rshift(r19BC, body.constant(int(9)));
         ir_expression *const r19C2 = bit_or(r19C0, r19C1);
         body.emit(assign(r19AF, expr(ir_unop_bitcast_u2f, r19C2), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f19B8->else_instructions;

         ir_expression *const r19C3 = lshift(r19B5, body.constant(int(31)));
         ir_expression *const r19C4 = add(r19C3, body.constant(2139095040u));
         body.emit(assign(r19AF, expr(ir_unop_bitcast_u2f, r19C4), 0x01));


      body.instructions = f19B8_parent_instructions;
      body.emit(f19B8);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f19B6->else_instructions;

      ir_variable *const r19C5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r19C5);
      ir_variable *const r19C6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r19C6);
      ir_expression *const r19C7 = lshift(swizzle_y(r19B1), body.constant(int(10)));
      ir_expression *const r19C8 = rshift(swizzle_x(r19B1), body.constant(int(22)));
      ir_expression *const r19C9 = bit_or(r19C7, r19C8);
      ir_expression *const r19CA = lshift(swizzle_x(r19B1), body.constant(int(10)));
      ir_expression *const r19CB = nequal(r19CA, body.constant(0u));
      ir_expression *const r19CC = expr(ir_unop_b2i, r19CB);
      ir_expression *const r19CD = expr(ir_unop_i2u, r19CC);
      body.emit(assign(r19C5, bit_or(r19C9, r19CD), 0x01));

      body.emit(assign(r19C6, rshift(swizzle_y(r19B1), body.constant(int(22))), 0x01));

      body.emit(assign(r19B0, r19C5, 0x01));

      /* IF CONDITION */
      ir_expression *const r19CF = nequal(r19B2, body.constant(int(0)));
      ir_if *f19CE = new(mem_ctx) ir_if(operand(r19CF).val);
      exec_list *const f19CE_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f19CE->then_instructions;

         body.emit(assign(r19B0, bit_or(r19C5, body.constant(1073741824u)), 0x01));


      body.instructions = f19CE_parent_instructions;
      body.emit(f19CE);

      /* END IF */

      ir_variable *const r19D0 = body.make_temp(glsl_type::int_type, "zExp");
      body.emit(assign(r19D0, add(r19B2, body.constant(int(-897))), 0x01));

      ir_variable *const r19D1 = body.make_temp(glsl_type::uint_type, "zFrac");
      body.emit(assign(r19D1, r19B0, 0x01));

      ir_variable *const r19D2 = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r19D2, body.constant(true), 0x01));

      ir_variable *const r19D3 = body.make_temp(glsl_type::uint_type, "return_value");
      ir_variable *const r19D4 = new(mem_ctx) ir_variable(glsl_type::int_type, "roundBits", ir_var_auto);
      body.emit(r19D4);
      ir_expression *const r19D5 = expr(ir_unop_u2i, r19B0);
      body.emit(assign(r19D4, bit_and(r19D5, body.constant(int(127))), 0x01));

      /* IF CONDITION */
      ir_expression *const r19D7 = expr(ir_unop_i2u, r19D0);
      ir_expression *const r19D8 = lequal(body.constant(253u), r19D7);
      ir_if *f19D6 = new(mem_ctx) ir_if(operand(r19D8).val);
      exec_list *const f19D6_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f19D6->then_instructions;

         /* IF CONDITION */
         ir_expression *const r19DA = less(body.constant(int(253)), r19D0);
         ir_expression *const r19DB = equal(r19D0, body.constant(int(253)));
         ir_expression *const r19DC = add(r19B0, body.constant(64u));
         ir_expression *const r19DD = expr(ir_unop_u2i, r19DC);
         ir_expression *const r19DE = less(r19DD, body.constant(int(0)));
         ir_expression *const r19DF = logic_and(r19DB, r19DE);
         ir_expression *const r19E0 = logic_or(r19DA, r19DF);
         ir_if *f19D9 = new(mem_ctx) ir_if(operand(r19E0).val);
         exec_list *const f19D9_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f19D9->then_instructions;

            ir_expression *const r19E1 = lshift(r19B5, body.constant(int(31)));
            body.emit(assign(r19D3, add(r19E1, body.constant(2139095040u)), 0x01));

            body.emit(assign(r19D2, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f19D9->else_instructions;

            /* IF CONDITION */
            ir_expression *const r19E3 = less(r19D0, body.constant(int(0)));
            ir_if *f19E2 = new(mem_ctx) ir_if(operand(r19E3).val);
            exec_list *const f19E2_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f19E2->then_instructions;

               ir_variable *const r19E4 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r19E4, neg(r19D0), 0x01));

               ir_variable *const r19E5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r19E5);
               /* IF CONDITION */
               ir_expression *const r19E7 = equal(r19E4, body.constant(int(0)));
               ir_if *f19E6 = new(mem_ctx) ir_if(operand(r19E7).val);
               exec_list *const f19E6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f19E6->then_instructions;

                  body.emit(assign(r19E5, r19B0, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f19E6->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r19E9 = less(r19E4, body.constant(int(32)));
                  ir_if *f19E8 = new(mem_ctx) ir_if(operand(r19E9).val);
                  exec_list *const f19E8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f19E8->then_instructions;

                     ir_expression *const r19EA = rshift(r19B0, r19E4);
                     ir_expression *const r19EB = neg(r19E4);
                     ir_expression *const r19EC = bit_and(r19EB, body.constant(int(31)));
                     ir_expression *const r19ED = lshift(r19B0, r19EC);
                     ir_expression *const r19EE = nequal(r19ED, body.constant(0u));
                     ir_expression *const r19EF = expr(ir_unop_b2i, r19EE);
                     ir_expression *const r19F0 = expr(ir_unop_i2u, r19EF);
                     body.emit(assign(r19E5, bit_or(r19EA, r19F0), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f19E8->else_instructions;

                     ir_expression *const r19F1 = nequal(r19B0, body.constant(0u));
                     ir_expression *const r19F2 = expr(ir_unop_b2i, r19F1);
                     body.emit(assign(r19E5, expr(ir_unop_i2u, r19F2), 0x01));


                  body.instructions = f19E8_parent_instructions;
                  body.emit(f19E8);

                  /* END IF */


               body.instructions = f19E6_parent_instructions;
               body.emit(f19E6);

               /* END IF */

               body.emit(assign(r19D1, r19E5, 0x01));

               body.emit(assign(r19D0, body.constant(int(0)), 0x01));

               ir_expression *const r19F3 = expr(ir_unop_u2i, r19E5);
               body.emit(assign(r19D4, bit_and(r19F3, body.constant(int(127))), 0x01));


            body.instructions = f19E2_parent_instructions;
            body.emit(f19E2);

            /* END IF */


         body.instructions = f19D9_parent_instructions;
         body.emit(f19D9);

         /* END IF */


      body.instructions = f19D6_parent_instructions;
      body.emit(f19D6);

      /* END IF */

      /* IF CONDITION */
      ir_if *f19F4 = new(mem_ctx) ir_if(operand(r19D2).val);
      exec_list *const f19F4_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f19F4->then_instructions;

         ir_expression *const r19F5 = add(r19D1, body.constant(64u));
         body.emit(assign(r19D1, rshift(r19F5, body.constant(int(7))), 0x01));

         ir_expression *const r19F6 = bit_xor(r19D4, body.constant(int(64)));
         ir_expression *const r19F7 = equal(r19F6, body.constant(int(0)));
         ir_expression *const r19F8 = expr(ir_unop_b2i, r19F7);
         ir_expression *const r19F9 = expr(ir_unop_i2u, r19F8);
         ir_expression *const r19FA = bit_and(r19F9, body.constant(1u));
         ir_expression *const r19FB = expr(ir_unop_bit_not, r19FA);
         body.emit(assign(r19D1, bit_and(r19D1, r19FB), 0x01));

         /* IF CONDITION */
         ir_expression *const r19FD = equal(r19D1, body.constant(0u));
         ir_if *f19FC = new(mem_ctx) ir_if(operand(r19FD).val);
         exec_list *const f19FC_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f19FC->then_instructions;

            body.emit(assign(r19D0, body.constant(int(0)), 0x01));


         body.instructions = f19FC_parent_instructions;
         body.emit(f19FC);

         /* END IF */

         ir_expression *const r19FE = lshift(r19B5, body.constant(int(31)));
         ir_expression *const r19FF = expr(ir_unop_i2u, r19D0);
         ir_expression *const r1A00 = lshift(r19FF, body.constant(int(23)));
         ir_expression *const r1A01 = add(r19FE, r1A00);
         body.emit(assign(r19D3, add(r1A01, r19D1), 0x01));

         body.emit(assign(r19D2, body.constant(false), 0x01));


      body.instructions = f19F4_parent_instructions;
      body.emit(f19F4);

      /* END IF */

      body.emit(assign(r19AF, expr(ir_unop_bitcast_u2f, r19D3), 0x01));


   body.instructions = f19B6_parent_instructions;
   body.emit(f19B6);

   /* END IF */

   body.emit(ret(r19AF));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fp64_to_int(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::int_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1A02 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1A02);
   ir_variable *const r1A03 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r1A03, body.constant(true), 0x01));

   ir_variable *const r1A04 = body.make_temp(glsl_type::int_type, "return_value");
   ir_variable *const r1A05 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracExtra", ir_var_auto);
   body.emit(r1A05);
   ir_variable *const r1A06 = new(mem_ctx) ir_variable(glsl_type::uint_type, "absZ", ir_var_auto);
   body.emit(r1A06);
   ir_variable *const r1A07 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aSign", ir_var_auto);
   body.emit(r1A07);
   ir_variable *const r1A08 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
   body.emit(r1A08);
   ir_variable *const r1A09 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r1A09);
   body.emit(assign(r1A09, bit_and(swizzle_y(r1A02), body.constant(1048575u)), 0x02));

   body.emit(assign(r1A09, swizzle_x(r1A02), 0x01));

   body.emit(assign(r1A08, r1A09, 0x03));

   ir_variable *const r1A0A = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r1A0B = rshift(swizzle_y(r1A02), body.constant(int(20)));
   ir_expression *const r1A0C = bit_and(r1A0B, body.constant(2047u));
   body.emit(assign(r1A0A, expr(ir_unop_u2i, r1A0C), 0x01));

   body.emit(assign(r1A07, rshift(swizzle_y(r1A02), body.constant(int(31))), 0x01));

   body.emit(assign(r1A06, body.constant(0u), 0x01));

   body.emit(assign(r1A05, body.constant(0u), 0x01));

   ir_variable *const r1A0D = body.make_temp(glsl_type::int_type, "assignment_tmp");
   body.emit(assign(r1A0D, add(r1A0A, body.constant(int(-1043))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1A0F = lequal(body.constant(int(0)), r1A0D);
   ir_if *f1A0E = new(mem_ctx) ir_if(operand(r1A0F).val);
   exec_list *const f1A0E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A0E->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1A11 = less(body.constant(int(1054)), r1A0A);
      ir_if *f1A10 = new(mem_ctx) ir_if(operand(r1A11).val);
      exec_list *const f1A10_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A10->then_instructions;

         /* IF CONDITION */
         ir_expression *const r1A13 = equal(r1A0A, body.constant(int(2047)));
         ir_expression *const r1A14 = bit_or(swizzle_y(r1A09), swizzle_x(r1A02));
         ir_expression *const r1A15 = nequal(r1A14, body.constant(0u));
         ir_expression *const r1A16 = logic_and(r1A13, r1A15);
         ir_if *f1A12 = new(mem_ctx) ir_if(operand(r1A16).val);
         exec_list *const f1A12_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A12->then_instructions;

            body.emit(assign(r1A07, body.constant(0u), 0x01));


         body.instructions = f1A12_parent_instructions;
         body.emit(f1A12);

         /* END IF */

         ir_variable *const r1A17 = body.make_temp(glsl_type::int_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1A19 = nequal(r1A07, body.constant(0u));
         ir_if *f1A18 = new(mem_ctx) ir_if(operand(r1A19).val);
         exec_list *const f1A18_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A18->then_instructions;

            body.emit(assign(r1A17, body.constant(int(-2147483648)), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1A18->else_instructions;

            body.emit(assign(r1A17, body.constant(int(2147483647)), 0x01));


         body.instructions = f1A18_parent_instructions;
         body.emit(f1A18);

         /* END IF */

         body.emit(assign(r1A04, r1A17, 0x01));

         body.emit(assign(r1A03, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A10->else_instructions;

         ir_variable *const r1A1A = body.make_temp(glsl_type::uint_type, "a0");
         body.emit(assign(r1A1A, bit_or(swizzle_y(r1A09), body.constant(1048576u)), 0x01));

         ir_variable *const r1A1B = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r1A1B, lshift(swizzle_x(r1A02), r1A0D), 0x01));

         ir_variable *const r1A1C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1A1E = equal(r1A0D, body.constant(int(0)));
         ir_if *f1A1D = new(mem_ctx) ir_if(operand(r1A1E).val);
         exec_list *const f1A1D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A1D->then_instructions;

            body.emit(assign(r1A1C, r1A1A, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1A1D->else_instructions;

            ir_expression *const r1A1F = lshift(r1A1A, r1A0D);
            ir_expression *const r1A20 = neg(r1A0D);
            ir_expression *const r1A21 = bit_and(r1A20, body.constant(int(31)));
            ir_expression *const r1A22 = rshift(swizzle_x(r1A02), r1A21);
            body.emit(assign(r1A1C, bit_or(r1A1F, r1A22), 0x01));


         body.instructions = f1A1D_parent_instructions;
         body.emit(f1A1D);

         /* END IF */

         body.emit(assign(r1A06, r1A1C, 0x01));

         body.emit(assign(r1A05, r1A1B, 0x01));

         /* IF CONDITION */
         ir_expression *const r1A24 = less(body.constant(2147483648u), r1A1C);
         ir_if *f1A23 = new(mem_ctx) ir_if(operand(r1A24).val);
         exec_list *const f1A23_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A23->then_instructions;

            ir_variable *const r1A25 = body.make_temp(glsl_type::int_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r1A27 = nequal(r1A07, body.constant(0u));
            ir_if *f1A26 = new(mem_ctx) ir_if(operand(r1A27).val);
            exec_list *const f1A26_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1A26->then_instructions;

               body.emit(assign(r1A25, body.constant(int(-2147483648)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1A26->else_instructions;

               body.emit(assign(r1A25, body.constant(int(2147483647)), 0x01));


            body.instructions = f1A26_parent_instructions;
            body.emit(f1A26);

            /* END IF */

            body.emit(assign(r1A04, r1A25, 0x01));

            body.emit(assign(r1A03, body.constant(false), 0x01));


         body.instructions = f1A23_parent_instructions;
         body.emit(f1A23);

         /* END IF */


      body.instructions = f1A10_parent_instructions;
      body.emit(f1A10);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1A0E->else_instructions;

      ir_expression *const r1A28 = nequal(swizzle_x(r1A02), body.constant(0u));
      ir_expression *const r1A29 = expr(ir_unop_b2i, r1A28);
      body.emit(assign(r1A08, expr(ir_unop_i2u, r1A29), 0x01));

      /* IF CONDITION */
      ir_expression *const r1A2B = less(r1A0A, body.constant(int(1022)));
      ir_if *f1A2A = new(mem_ctx) ir_if(operand(r1A2B).val);
      exec_list *const f1A2A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A2A->then_instructions;

         ir_expression *const r1A2C = expr(ir_unop_i2u, r1A0A);
         ir_expression *const r1A2D = bit_or(r1A2C, swizzle_y(r1A09));
         body.emit(assign(r1A05, bit_or(r1A2D, swizzle_x(r1A08)), 0x01));

         body.emit(assign(r1A06, body.constant(0u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A2A->else_instructions;

         body.emit(assign(r1A08, bit_or(swizzle_y(r1A09), body.constant(1048576u)), 0x02));

         ir_expression *const r1A2E = bit_and(r1A0D, body.constant(int(31)));
         ir_expression *const r1A2F = lshift(swizzle_y(r1A08), r1A2E);
         body.emit(assign(r1A05, bit_or(r1A2F, swizzle_x(r1A08)), 0x01));

         ir_expression *const r1A30 = neg(r1A0D);
         body.emit(assign(r1A06, rshift(swizzle_y(r1A08), r1A30), 0x01));


      body.instructions = f1A2A_parent_instructions;
      body.emit(f1A2A);

      /* END IF */


   body.instructions = f1A0E_parent_instructions;
   body.emit(f1A0E);

   /* END IF */

   /* IF CONDITION */
   ir_if *f1A31 = new(mem_ctx) ir_if(operand(r1A03).val);
   exec_list *const f1A31_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A31->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1A33 = expr(ir_unop_u2i, r1A05);
      ir_expression *const r1A34 = less(r1A33, body.constant(int(0)));
      ir_if *f1A32 = new(mem_ctx) ir_if(operand(r1A34).val);
      exec_list *const f1A32_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A32->then_instructions;

         body.emit(assign(r1A06, add(r1A06, body.constant(1u)), 0x01));

         /* IF CONDITION */
         ir_expression *const r1A36 = lshift(r1A05, body.constant(int(1)));
         ir_expression *const r1A37 = equal(r1A36, body.constant(0u));
         ir_if *f1A35 = new(mem_ctx) ir_if(operand(r1A37).val);
         exec_list *const f1A35_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A35->then_instructions;

            body.emit(assign(r1A06, bit_and(r1A06, body.constant(4294967294u)), 0x01));


         body.instructions = f1A35_parent_instructions;
         body.emit(f1A35);

         /* END IF */


      body.instructions = f1A32_parent_instructions;
      body.emit(f1A32);

      /* END IF */

      ir_variable *const r1A38 = body.make_temp(glsl_type::int_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r1A3A = nequal(r1A07, body.constant(0u));
      ir_if *f1A39 = new(mem_ctx) ir_if(operand(r1A3A).val);
      exec_list *const f1A39_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A39->then_instructions;

         ir_expression *const r1A3B = expr(ir_unop_u2i, r1A06);
         body.emit(assign(r1A38, neg(r1A3B), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A39->else_instructions;

         body.emit(assign(r1A38, expr(ir_unop_u2i, r1A06), 0x01));


      body.instructions = f1A39_parent_instructions;
      body.emit(f1A39);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1A3D = less(r1A38, body.constant(int(0)));
      ir_expression *const r1A3E = expr(ir_unop_b2i, r1A3D);
      ir_expression *const r1A3F = expr(ir_unop_i2u, r1A3E);
      ir_expression *const r1A40 = bit_xor(r1A07, r1A3F);
      ir_expression *const r1A41 = expr(ir_unop_u2i, r1A40);
      ir_expression *const r1A42 = expr(ir_unop_i2b, r1A41);
      ir_expression *const r1A43 = expr(ir_unop_i2b, r1A38);
      ir_expression *const r1A44 = logic_and(r1A42, r1A43);
      ir_if *f1A3C = new(mem_ctx) ir_if(operand(r1A44).val);
      exec_list *const f1A3C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A3C->then_instructions;

         ir_variable *const r1A45 = body.make_temp(glsl_type::int_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1A47 = expr(ir_unop_u2i, r1A07);
         ir_expression *const r1A48 = expr(ir_unop_i2b, r1A47);
         ir_if *f1A46 = new(mem_ctx) ir_if(operand(r1A48).val);
         exec_list *const f1A46_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A46->then_instructions;

            body.emit(assign(r1A45, body.constant(int(-2147483648)), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1A46->else_instructions;

            body.emit(assign(r1A45, body.constant(int(2147483647)), 0x01));


         body.instructions = f1A46_parent_instructions;
         body.emit(f1A46);

         /* END IF */

         body.emit(assign(r1A04, r1A45, 0x01));

         body.emit(assign(r1A03, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A3C->else_instructions;

         body.emit(assign(r1A04, r1A38, 0x01));

         body.emit(assign(r1A03, body.constant(false), 0x01));


      body.instructions = f1A3C_parent_instructions;
      body.emit(f1A3C);

      /* END IF */


   body.instructions = f1A31_parent_instructions;
   body.emit(f1A31);

   /* END IF */

   body.emit(ret(r1A04));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
int_to_fp64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1A49 = new(mem_ctx) ir_variable(glsl_type::int_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1A49);
   ir_variable *const r1A4A = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1A4B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_auto);
   body.emit(r1A4B);
   ir_variable *const r1A4C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r1A4C);
   ir_variable *const r1A4D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r1A4D);
   body.emit(assign(r1A4D, body.constant(0u), 0x01));

   body.emit(assign(r1A4C, body.constant(0u), 0x01));

   /* IF CONDITION */
   ir_expression *const r1A4F = equal(r1A49, body.constant(int(0)));
   ir_if *f1A4E = new(mem_ctx) ir_if(operand(r1A4F).val);
   exec_list *const f1A4E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A4E->then_instructions;

      ir_variable *const r1A50 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r1A50);
      body.emit(assign(r1A50, body.constant(0u), 0x02));

      body.emit(assign(r1A50, body.constant(0u), 0x01));

      body.emit(assign(r1A4A, r1A50, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1A4E->else_instructions;

      ir_expression *const r1A51 = less(r1A49, body.constant(int(0)));
      ir_expression *const r1A52 = expr(ir_unop_b2i, r1A51);
      body.emit(assign(r1A4B, expr(ir_unop_i2u, r1A52), 0x01));

      ir_variable *const r1A53 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r1A55 = less(r1A49, body.constant(int(0)));
      ir_if *f1A54 = new(mem_ctx) ir_if(operand(r1A55).val);
      exec_list *const f1A54_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A54->then_instructions;

         ir_expression *const r1A56 = neg(r1A49);
         body.emit(assign(r1A53, expr(ir_unop_i2u, r1A56), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A54->else_instructions;

         body.emit(assign(r1A53, expr(ir_unop_i2u, r1A49), 0x01));


      body.instructions = f1A54_parent_instructions;
      body.emit(f1A54);

      /* END IF */

      ir_variable *const r1A57 = body.make_temp(glsl_type::uint_type, "a");
      body.emit(assign(r1A57, r1A53, 0x01));

      ir_variable *const r1A58 = body.make_temp(glsl_type::int_type, "return_value");
      ir_variable *const r1A59 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
      body.emit(r1A59);
      /* IF CONDITION */
      ir_expression *const r1A5B = equal(r1A53, body.constant(0u));
      ir_if *f1A5A = new(mem_ctx) ir_if(operand(r1A5B).val);
      exec_list *const f1A5A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A5A->then_instructions;

         body.emit(assign(r1A58, body.constant(int(32)), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A5A->else_instructions;

         body.emit(assign(r1A59, body.constant(int(0)), 0x01));

         /* IF CONDITION */
         ir_expression *const r1A5D = bit_and(r1A53, body.constant(4294901760u));
         ir_expression *const r1A5E = equal(r1A5D, body.constant(0u));
         ir_if *f1A5C = new(mem_ctx) ir_if(operand(r1A5E).val);
         exec_list *const f1A5C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A5C->then_instructions;

            body.emit(assign(r1A59, body.constant(int(16)), 0x01));

            body.emit(assign(r1A57, lshift(r1A53, body.constant(int(16))), 0x01));


         body.instructions = f1A5C_parent_instructions;
         body.emit(f1A5C);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1A60 = bit_and(r1A57, body.constant(4278190080u));
         ir_expression *const r1A61 = equal(r1A60, body.constant(0u));
         ir_if *f1A5F = new(mem_ctx) ir_if(operand(r1A61).val);
         exec_list *const f1A5F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A5F->then_instructions;

            body.emit(assign(r1A59, add(r1A59, body.constant(int(8))), 0x01));

            body.emit(assign(r1A57, lshift(r1A57, body.constant(int(8))), 0x01));


         body.instructions = f1A5F_parent_instructions;
         body.emit(f1A5F);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1A63 = bit_and(r1A57, body.constant(4026531840u));
         ir_expression *const r1A64 = equal(r1A63, body.constant(0u));
         ir_if *f1A62 = new(mem_ctx) ir_if(operand(r1A64).val);
         exec_list *const f1A62_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A62->then_instructions;

            body.emit(assign(r1A59, add(r1A59, body.constant(int(4))), 0x01));

            body.emit(assign(r1A57, lshift(r1A57, body.constant(int(4))), 0x01));


         body.instructions = f1A62_parent_instructions;
         body.emit(f1A62);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1A66 = bit_and(r1A57, body.constant(3221225472u));
         ir_expression *const r1A67 = equal(r1A66, body.constant(0u));
         ir_if *f1A65 = new(mem_ctx) ir_if(operand(r1A67).val);
         exec_list *const f1A65_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A65->then_instructions;

            body.emit(assign(r1A59, add(r1A59, body.constant(int(2))), 0x01));

            body.emit(assign(r1A57, lshift(r1A57, body.constant(int(2))), 0x01));


         body.instructions = f1A65_parent_instructions;
         body.emit(f1A65);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1A69 = bit_and(r1A57, body.constant(2147483648u));
         ir_expression *const r1A6A = equal(r1A69, body.constant(0u));
         ir_if *f1A68 = new(mem_ctx) ir_if(operand(r1A6A).val);
         exec_list *const f1A68_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A68->then_instructions;

            body.emit(assign(r1A59, add(r1A59, body.constant(int(1))), 0x01));


         body.instructions = f1A68_parent_instructions;
         body.emit(f1A68);

         /* END IF */

         body.emit(assign(r1A58, r1A59, 0x01));


      body.instructions = f1A5A_parent_instructions;
      body.emit(f1A5A);

      /* END IF */

      ir_variable *const r1A6B = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r1A6B, add(r1A58, body.constant(int(-11))), 0x01));

      /* IF CONDITION */
      ir_expression *const r1A6D = lequal(body.constant(int(0)), r1A6B);
      ir_if *f1A6C = new(mem_ctx) ir_if(operand(r1A6D).val);
      exec_list *const f1A6C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A6C->then_instructions;

         body.emit(assign(r1A4D, lshift(r1A53, r1A6B), 0x01));

         body.emit(assign(r1A4C, body.constant(0u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A6C->else_instructions;

         ir_variable *const r1A6E = body.make_temp(glsl_type::uint_type, "a1");
         body.emit(assign(r1A6E, body.constant(0u), 0x01));

         ir_variable *const r1A6F = body.make_temp(glsl_type::int_type, "count");
         body.emit(assign(r1A6F, neg(r1A6B), 0x01));

         ir_variable *const r1A70 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r1A70);
         ir_variable *const r1A71 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r1A71);
         ir_variable *const r1A72 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         ir_expression *const r1A73 = neg(r1A6F);
         body.emit(assign(r1A72, bit_and(r1A73, body.constant(int(31))), 0x01));

         /* IF CONDITION */
         ir_expression *const r1A75 = equal(r1A6F, body.constant(int(0)));
         ir_if *f1A74 = new(mem_ctx) ir_if(operand(r1A75).val);
         exec_list *const f1A74_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A74->then_instructions;

            body.emit(assign(r1A70, body.constant(0u), 0x01));

            body.emit(assign(r1A71, r1A53, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1A74->else_instructions;

            /* IF CONDITION */
            ir_expression *const r1A77 = less(r1A6F, body.constant(int(32)));
            ir_if *f1A76 = new(mem_ctx) ir_if(operand(r1A77).val);
            exec_list *const f1A76_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1A76->then_instructions;

               ir_expression *const r1A78 = lshift(r1A53, r1A72);
               body.emit(assign(r1A70, bit_or(r1A78, body.constant(0u)), 0x01));

               body.emit(assign(r1A71, rshift(r1A53, r1A6F), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1A76->else_instructions;

               ir_variable *const r1A79 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r1A7B = less(r1A6F, body.constant(int(64)));
               ir_if *f1A7A = new(mem_ctx) ir_if(operand(r1A7B).val);
               exec_list *const f1A7A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1A7A->then_instructions;

                  ir_expression *const r1A7C = bit_and(r1A6F, body.constant(int(31)));
                  body.emit(assign(r1A79, rshift(r1A53, r1A7C), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1A7A->else_instructions;

                  body.emit(assign(r1A79, body.constant(0u), 0x01));


               body.instructions = f1A7A_parent_instructions;
               body.emit(f1A7A);

               /* END IF */

               body.emit(assign(r1A70, r1A79, 0x01));

               body.emit(assign(r1A71, body.constant(0u), 0x01));


            body.instructions = f1A76_parent_instructions;
            body.emit(f1A76);

            /* END IF */


         body.instructions = f1A74_parent_instructions;
         body.emit(f1A74);

         /* END IF */

         body.emit(assign(r1A4D, r1A71, 0x01));

         body.emit(assign(r1A4C, r1A70, 0x01));


      body.instructions = f1A6C_parent_instructions;
      body.emit(f1A6C);

      /* END IF */

      ir_variable *const r1A7D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r1A7D);
      ir_expression *const r1A7E = lshift(r1A4B, body.constant(int(31)));
      ir_expression *const r1A7F = sub(body.constant(int(1042)), r1A6B);
      ir_expression *const r1A80 = expr(ir_unop_i2u, r1A7F);
      ir_expression *const r1A81 = lshift(r1A80, body.constant(int(20)));
      ir_expression *const r1A82 = add(r1A7E, r1A81);
      body.emit(assign(r1A7D, add(r1A82, r1A4D), 0x02));

      body.emit(assign(r1A7D, r1A4C, 0x01));

      body.emit(assign(r1A4A, r1A7D, 0x03));


   body.instructions = f1A4E_parent_instructions;
   body.emit(f1A4E);

   /* END IF */

   body.emit(ret(r1A4A));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fgt64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1A83 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1A83);
   ir_variable *const r1A84 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r1A84);
   ir_variable *const r1A85 = body.make_temp(glsl_type::bool_type, "return_value");
   ir_variable *const r1A86 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
   body.emit(r1A86);
   ir_variable *const r1A87 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
   body.emit(r1A87);
   ir_variable *const r1A88 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r1A88);
   body.emit(assign(r1A88, bit_and(swizzle_y(r1A84), body.constant(1048575u)), 0x02));

   body.emit(assign(r1A88, swizzle_x(r1A84), 0x01));

   ir_variable *const r1A89 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r1A89);
   body.emit(assign(r1A89, bit_and(swizzle_y(r1A83), body.constant(1048575u)), 0x02));

   body.emit(assign(r1A89, swizzle_x(r1A83), 0x01));

   ir_expression *const r1A8A = rshift(swizzle_y(r1A84), body.constant(int(20)));
   ir_expression *const r1A8B = bit_and(r1A8A, body.constant(2047u));
   ir_expression *const r1A8C = expr(ir_unop_u2i, r1A8B);
   ir_expression *const r1A8D = equal(r1A8C, body.constant(int(2047)));
   ir_expression *const r1A8E = bit_or(swizzle_y(r1A88), swizzle_x(r1A84));
   ir_expression *const r1A8F = nequal(r1A8E, body.constant(0u));
   body.emit(assign(r1A87, logic_and(r1A8D, r1A8F), 0x01));

   ir_expression *const r1A90 = rshift(swizzle_y(r1A83), body.constant(int(20)));
   ir_expression *const r1A91 = bit_and(r1A90, body.constant(2047u));
   ir_expression *const r1A92 = expr(ir_unop_u2i, r1A91);
   ir_expression *const r1A93 = equal(r1A92, body.constant(int(2047)));
   ir_expression *const r1A94 = bit_or(swizzle_y(r1A89), swizzle_x(r1A83));
   ir_expression *const r1A95 = nequal(r1A94, body.constant(0u));
   body.emit(assign(r1A86, logic_and(r1A93, r1A95), 0x01));

   /* IF CONDITION */
   ir_expression *const r1A97 = logic_or(r1A87, r1A86);
   ir_if *f1A96 = new(mem_ctx) ir_if(operand(r1A97).val);
   exec_list *const f1A96_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A96->then_instructions;

      body.emit(assign(r1A85, body.constant(false), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1A96->else_instructions;

      ir_variable *const r1A98 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r1A98, rshift(swizzle_y(r1A84), body.constant(int(31))), 0x01));

      ir_variable *const r1A99 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r1A99, rshift(swizzle_y(r1A83), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r1A9B = nequal(r1A98, r1A99);
      ir_if *f1A9A = new(mem_ctx) ir_if(operand(r1A9B).val);
      exec_list *const f1A9A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A9A->then_instructions;

         ir_expression *const r1A9C = nequal(r1A98, body.constant(0u));
         ir_expression *const r1A9D = bit_or(swizzle_y(r1A84), swizzle_y(r1A83));
         ir_expression *const r1A9E = lshift(r1A9D, body.constant(int(1)));
         ir_expression *const r1A9F = bit_or(r1A9E, swizzle_x(r1A84));
         ir_expression *const r1AA0 = bit_or(r1A9F, swizzle_x(r1A83));
         ir_expression *const r1AA1 = nequal(r1AA0, body.constant(0u));
         body.emit(assign(r1A85, logic_and(r1A9C, r1AA1), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A9A->else_instructions;

         ir_variable *const r1AA2 = body.make_temp(glsl_type::bool_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1AA4 = nequal(r1A98, body.constant(0u));
         ir_if *f1AA3 = new(mem_ctx) ir_if(operand(r1AA4).val);
         exec_list *const f1AA3_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1AA3->then_instructions;

            ir_expression *const r1AA5 = less(swizzle_y(r1A83), swizzle_y(r1A84));
            ir_expression *const r1AA6 = equal(swizzle_y(r1A83), swizzle_y(r1A84));
            ir_expression *const r1AA7 = less(swizzle_x(r1A83), swizzle_x(r1A84));
            ir_expression *const r1AA8 = logic_and(r1AA6, r1AA7);
            body.emit(assign(r1AA2, logic_or(r1AA5, r1AA8), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1AA3->else_instructions;

            ir_expression *const r1AA9 = less(swizzle_y(r1A84), swizzle_y(r1A83));
            ir_expression *const r1AAA = equal(swizzle_y(r1A84), swizzle_y(r1A83));
            ir_expression *const r1AAB = less(swizzle_x(r1A84), swizzle_x(r1A83));
            ir_expression *const r1AAC = logic_and(r1AAA, r1AAB);
            body.emit(assign(r1AA2, logic_or(r1AA9, r1AAC), 0x01));


         body.instructions = f1AA3_parent_instructions;
         body.emit(f1AA3);

         /* END IF */

         body.emit(assign(r1A85, r1AA2, 0x01));


      body.instructions = f1A9A_parent_instructions;
      body.emit(f1A9A);

      /* END IF */


   body.instructions = f1A96_parent_instructions;
   body.emit(f1A96);

   /* END IF */

   body.emit(ret(r1A85));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
