ir_function_signature *
fabs64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r000B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r000B);
   body.emit(assign(r000B, bit_and(swizzle_y(r000B), body.constant(2147483647u)), 0x02));

   body.emit(ret(r000B));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
is_nan(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r000C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r000C);
   ir_expression *const r000D = lshift(swizzle_y(r000C), body.constant(int(1)));
   ir_expression *const r000E = lequal(body.constant(4292870144u), r000D);
   ir_expression *const r000F = nequal(swizzle_x(r000C), body.constant(0u));
   ir_expression *const r0010 = bit_and(swizzle_y(r000C), body.constant(1048575u));
   ir_expression *const r0011 = nequal(r0010, body.constant(0u));
   ir_expression *const r0012 = logic_or(r000F, r0011);
   ir_expression *const r0013 = logic_and(r000E, r0012);
   body.emit(ret(r0013));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fneg64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0014 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0014);
   ir_variable *const r0015 = body.make_temp(glsl_type::uvec2_type, "return_value");
   /* IF CONDITION */
   ir_expression *const r0017 = lshift(swizzle_y(r0014), body.constant(int(1)));
   ir_expression *const r0018 = lequal(body.constant(4292870144u), r0017);
   ir_expression *const r0019 = nequal(swizzle_x(r0014), body.constant(0u));
   ir_expression *const r001A = bit_and(swizzle_y(r0014), body.constant(1048575u));
   ir_expression *const r001B = nequal(r001A, body.constant(0u));
   ir_expression *const r001C = logic_or(r0019, r001B);
   ir_expression *const r001D = logic_and(r0018, r001C);
   ir_if *f0016 = new(mem_ctx) ir_if(operand(r001D).val);
   exec_list *const f0016_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0016->then_instructions;

      body.emit(assign(r0015, r0014, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0016->else_instructions;

      body.emit(assign(r0014, bit_xor(swizzle_y(r0014), body.constant(2147483648u)), 0x02));

      body.emit(assign(r0015, r0014, 0x03));


   body.instructions = f0016_parent_instructions;
   body.emit(f0016);

   /* END IF */

   body.emit(ret(r0015));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat64Frac(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r001E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r001E);
   ir_variable *const r001F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r001F);
   body.emit(assign(r001F, bit_and(swizzle_y(r001E), body.constant(1048575u)), 0x02));

   body.emit(assign(r001F, swizzle_x(r001E), 0x01));

   body.emit(ret(r001F));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat64Exp(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::int_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0020 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0020);
   ir_expression *const r0021 = rshift(swizzle_y(r0020), body.constant(int(20)));
   ir_expression *const r0022 = bit_and(r0021, body.constant(2047u));
   ir_expression *const r0023 = expr(ir_unop_u2i, r0022);
   body.emit(ret(r0023));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
feq64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0024 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0024);
   ir_variable *const r0025 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0025);
   ir_variable *const r0026 = body.make_temp(glsl_type::bool_type, "return_value");
   ir_variable *const r0027 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
   body.emit(r0027);
   ir_variable *const r0028 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
   body.emit(r0028);
   ir_variable *const r0029 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r0029);
   body.emit(assign(r0029, bit_and(swizzle_y(r0024), body.constant(1048575u)), 0x02));

   body.emit(assign(r0029, swizzle_x(r0024), 0x01));

   ir_variable *const r002A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r002A);
   body.emit(assign(r002A, bit_and(swizzle_y(r0025), body.constant(1048575u)), 0x02));

   body.emit(assign(r002A, swizzle_x(r0025), 0x01));

   ir_expression *const r002B = rshift(swizzle_y(r0024), body.constant(int(20)));
   ir_expression *const r002C = bit_and(r002B, body.constant(2047u));
   ir_expression *const r002D = expr(ir_unop_u2i, r002C);
   ir_expression *const r002E = equal(r002D, body.constant(int(2047)));
   ir_expression *const r002F = bit_or(swizzle_y(r0029), swizzle_x(r0024));
   ir_expression *const r0030 = nequal(r002F, body.constant(0u));
   body.emit(assign(r0028, logic_and(r002E, r0030), 0x01));

   ir_expression *const r0031 = rshift(swizzle_y(r0025), body.constant(int(20)));
   ir_expression *const r0032 = bit_and(r0031, body.constant(2047u));
   ir_expression *const r0033 = expr(ir_unop_u2i, r0032);
   ir_expression *const r0034 = equal(r0033, body.constant(int(2047)));
   ir_expression *const r0035 = bit_or(swizzle_y(r002A), swizzle_x(r0025));
   ir_expression *const r0036 = nequal(r0035, body.constant(0u));
   body.emit(assign(r0027, logic_and(r0034, r0036), 0x01));

   /* IF CONDITION */
   ir_expression *const r0038 = logic_or(r0028, r0027);
   ir_if *f0037 = new(mem_ctx) ir_if(operand(r0038).val);
   exec_list *const f0037_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0037->then_instructions;

      body.emit(assign(r0026, body.constant(false), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0037->else_instructions;

      ir_expression *const r0039 = equal(swizzle_x(r0024), swizzle_x(r0025));
      ir_expression *const r003A = equal(swizzle_y(r0024), swizzle_y(r0025));
      ir_expression *const r003B = equal(swizzle_x(r0024), body.constant(0u));
      ir_expression *const r003C = bit_or(swizzle_y(r0024), swizzle_y(r0025));
      ir_expression *const r003D = lshift(r003C, body.constant(int(1)));
      ir_expression *const r003E = equal(r003D, body.constant(0u));
      ir_expression *const r003F = logic_and(r003B, r003E);
      ir_expression *const r0040 = logic_or(r003A, r003F);
      body.emit(assign(r0026, logic_and(r0039, r0040), 0x01));


   body.instructions = f0037_parent_instructions;
   body.emit(f0037);

   /* END IF */

   body.emit(ret(r0026));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat64Sign(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0041 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0041);
   ir_expression *const r0042 = rshift(swizzle_y(r0041), body.constant(int(31)));
   body.emit(ret(r0042));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
le64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0043 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r0043);
   ir_variable *const r0044 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r0044);
   ir_variable *const r0045 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r0045);
   ir_variable *const r0046 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r0046);
   ir_expression *const r0047 = less(r0043, r0045);
   ir_expression *const r0048 = equal(r0043, r0045);
   ir_expression *const r0049 = lequal(r0044, r0046);
   ir_expression *const r004A = logic_and(r0048, r0049);
   ir_expression *const r004B = logic_or(r0047, r004A);
   body.emit(ret(r004B));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fle64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r004C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r004C);
   ir_variable *const r004D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r004D);
   ir_variable *const r004E = body.make_temp(glsl_type::bool_type, "return_value");
   ir_variable *const r004F = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
   body.emit(r004F);
   ir_variable *const r0050 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
   body.emit(r0050);
   ir_variable *const r0051 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r0051);
   body.emit(assign(r0051, bit_and(swizzle_y(r004C), body.constant(1048575u)), 0x02));

   body.emit(assign(r0051, swizzle_x(r004C), 0x01));

   ir_variable *const r0052 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r0052);
   body.emit(assign(r0052, bit_and(swizzle_y(r004D), body.constant(1048575u)), 0x02));

   body.emit(assign(r0052, swizzle_x(r004D), 0x01));

   ir_expression *const r0053 = rshift(swizzle_y(r004C), body.constant(int(20)));
   ir_expression *const r0054 = bit_and(r0053, body.constant(2047u));
   ir_expression *const r0055 = expr(ir_unop_u2i, r0054);
   ir_expression *const r0056 = equal(r0055, body.constant(int(2047)));
   ir_expression *const r0057 = bit_or(swizzle_y(r0051), swizzle_x(r004C));
   ir_expression *const r0058 = nequal(r0057, body.constant(0u));
   body.emit(assign(r0050, logic_and(r0056, r0058), 0x01));

   ir_expression *const r0059 = rshift(swizzle_y(r004D), body.constant(int(20)));
   ir_expression *const r005A = bit_and(r0059, body.constant(2047u));
   ir_expression *const r005B = expr(ir_unop_u2i, r005A);
   ir_expression *const r005C = equal(r005B, body.constant(int(2047)));
   ir_expression *const r005D = bit_or(swizzle_y(r0052), swizzle_x(r004D));
   ir_expression *const r005E = nequal(r005D, body.constant(0u));
   body.emit(assign(r004F, logic_and(r005C, r005E), 0x01));

   /* IF CONDITION */
   ir_expression *const r0060 = logic_or(r0050, r004F);
   ir_if *f005F = new(mem_ctx) ir_if(operand(r0060).val);
   exec_list *const f005F_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f005F->then_instructions;

      body.emit(assign(r004E, body.constant(false), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f005F->else_instructions;

      ir_variable *const r0061 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r0061, rshift(swizzle_y(r004C), body.constant(int(31))), 0x01));

      ir_variable *const r0062 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r0062, rshift(swizzle_y(r004D), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r0064 = nequal(r0061, r0062);
      ir_if *f0063 = new(mem_ctx) ir_if(operand(r0064).val);
      exec_list *const f0063_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0063->then_instructions;

         ir_expression *const r0065 = nequal(r0061, body.constant(0u));
         ir_expression *const r0066 = bit_or(swizzle_y(r004C), swizzle_y(r004D));
         ir_expression *const r0067 = lshift(r0066, body.constant(int(1)));
         ir_expression *const r0068 = bit_or(r0067, swizzle_x(r004C));
         ir_expression *const r0069 = bit_or(r0068, swizzle_x(r004D));
         ir_expression *const r006A = equal(r0069, body.constant(0u));
         body.emit(assign(r004E, logic_or(r0065, r006A), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0063->else_instructions;

         ir_variable *const r006B = body.make_temp(glsl_type::bool_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r006D = nequal(r0061, body.constant(0u));
         ir_if *f006C = new(mem_ctx) ir_if(operand(r006D).val);
         exec_list *const f006C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f006C->then_instructions;

            ir_expression *const r006E = less(swizzle_y(r004D), swizzle_y(r004C));
            ir_expression *const r006F = equal(swizzle_y(r004D), swizzle_y(r004C));
            ir_expression *const r0070 = lequal(swizzle_x(r004D), swizzle_x(r004C));
            ir_expression *const r0071 = logic_and(r006F, r0070);
            body.emit(assign(r006B, logic_or(r006E, r0071), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f006C->else_instructions;

            ir_expression *const r0072 = less(swizzle_y(r004C), swizzle_y(r004D));
            ir_expression *const r0073 = equal(swizzle_y(r004C), swizzle_y(r004D));
            ir_expression *const r0074 = lequal(swizzle_x(r004C), swizzle_x(r004D));
            ir_expression *const r0075 = logic_and(r0073, r0074);
            body.emit(assign(r006B, logic_or(r0072, r0075), 0x01));


         body.instructions = f006C_parent_instructions;
         body.emit(f006C);

         /* END IF */

         body.emit(assign(r004E, r006B, 0x01));


      body.instructions = f0063_parent_instructions;
      body.emit(f0063);

      /* END IF */


   body.instructions = f005F_parent_instructions;
   body.emit(f005F);

   /* END IF */

   body.emit(ret(r004E));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
lt64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0076 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r0076);
   ir_variable *const r0077 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r0077);
   ir_variable *const r0078 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r0078);
   ir_variable *const r0079 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r0079);
   ir_expression *const r007A = less(r0076, r0078);
   ir_expression *const r007B = equal(r0076, r0078);
   ir_expression *const r007C = less(r0077, r0079);
   ir_expression *const r007D = logic_and(r007B, r007C);
   ir_expression *const r007E = logic_or(r007A, r007D);
   body.emit(ret(r007E));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
flt64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r007F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r007F);
   ir_variable *const r0080 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0080);
   ir_variable *const r0081 = body.make_temp(glsl_type::bool_type, "return_value");
   ir_variable *const r0082 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
   body.emit(r0082);
   ir_variable *const r0083 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
   body.emit(r0083);
   ir_variable *const r0084 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r0084);
   body.emit(assign(r0084, bit_and(swizzle_y(r007F), body.constant(1048575u)), 0x02));

   body.emit(assign(r0084, swizzle_x(r007F), 0x01));

   ir_variable *const r0085 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r0085);
   body.emit(assign(r0085, bit_and(swizzle_y(r0080), body.constant(1048575u)), 0x02));

   body.emit(assign(r0085, swizzle_x(r0080), 0x01));

   ir_expression *const r0086 = rshift(swizzle_y(r007F), body.constant(int(20)));
   ir_expression *const r0087 = bit_and(r0086, body.constant(2047u));
   ir_expression *const r0088 = expr(ir_unop_u2i, r0087);
   ir_expression *const r0089 = equal(r0088, body.constant(int(2047)));
   ir_expression *const r008A = bit_or(swizzle_y(r0084), swizzle_x(r007F));
   ir_expression *const r008B = nequal(r008A, body.constant(0u));
   body.emit(assign(r0083, logic_and(r0089, r008B), 0x01));

   ir_expression *const r008C = rshift(swizzle_y(r0080), body.constant(int(20)));
   ir_expression *const r008D = bit_and(r008C, body.constant(2047u));
   ir_expression *const r008E = expr(ir_unop_u2i, r008D);
   ir_expression *const r008F = equal(r008E, body.constant(int(2047)));
   ir_expression *const r0090 = bit_or(swizzle_y(r0085), swizzle_x(r0080));
   ir_expression *const r0091 = nequal(r0090, body.constant(0u));
   body.emit(assign(r0082, logic_and(r008F, r0091), 0x01));

   /* IF CONDITION */
   ir_expression *const r0093 = logic_or(r0083, r0082);
   ir_if *f0092 = new(mem_ctx) ir_if(operand(r0093).val);
   exec_list *const f0092_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0092->then_instructions;

      body.emit(assign(r0081, body.constant(false), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0092->else_instructions;

      ir_variable *const r0094 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r0094, rshift(swizzle_y(r007F), body.constant(int(31))), 0x01));

      ir_variable *const r0095 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r0095, rshift(swizzle_y(r0080), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r0097 = nequal(r0094, r0095);
      ir_if *f0096 = new(mem_ctx) ir_if(operand(r0097).val);
      exec_list *const f0096_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0096->then_instructions;

         ir_expression *const r0098 = nequal(r0094, body.constant(0u));
         ir_expression *const r0099 = bit_or(swizzle_y(r007F), swizzle_y(r0080));
         ir_expression *const r009A = lshift(r0099, body.constant(int(1)));
         ir_expression *const r009B = bit_or(r009A, swizzle_x(r007F));
         ir_expression *const r009C = bit_or(r009B, swizzle_x(r0080));
         ir_expression *const r009D = nequal(r009C, body.constant(0u));
         body.emit(assign(r0081, logic_and(r0098, r009D), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0096->else_instructions;

         ir_variable *const r009E = body.make_temp(glsl_type::bool_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r00A0 = nequal(r0094, body.constant(0u));
         ir_if *f009F = new(mem_ctx) ir_if(operand(r00A0).val);
         exec_list *const f009F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f009F->then_instructions;

            ir_expression *const r00A1 = less(swizzle_y(r0080), swizzle_y(r007F));
            ir_expression *const r00A2 = equal(swizzle_y(r0080), swizzle_y(r007F));
            ir_expression *const r00A3 = less(swizzle_x(r0080), swizzle_x(r007F));
            ir_expression *const r00A4 = logic_and(r00A2, r00A3);
            body.emit(assign(r009E, logic_or(r00A1, r00A4), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f009F->else_instructions;

            ir_expression *const r00A5 = less(swizzle_y(r007F), swizzle_y(r0080));
            ir_expression *const r00A6 = equal(swizzle_y(r007F), swizzle_y(r0080));
            ir_expression *const r00A7 = less(swizzle_x(r007F), swizzle_x(r0080));
            ir_expression *const r00A8 = logic_and(r00A6, r00A7);
            body.emit(assign(r009E, logic_or(r00A5, r00A8), 0x01));


         body.instructions = f009F_parent_instructions;
         body.emit(f009F);

         /* END IF */

         body.emit(assign(r0081, r009E, 0x01));


      body.instructions = f0096_parent_instructions;
      body.emit(f0096);

      /* END IF */


   body.instructions = f0092_parent_instructions;
   body.emit(f0092);

   /* END IF */

   body.emit(ret(r0081));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
add64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00A9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00A9);
   ir_variable *const r00AA = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00AA);
   ir_variable *const r00AB = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r00AB);
   ir_variable *const r00AC = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r00AC);
   ir_variable *const r00AD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00AD);
   ir_variable *const r00AE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00AE);
   ir_variable *const r00AF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r00AF, add(r00AA, r00AC), 0x01));

   body.emit(assign(r00AE, r00AF, 0x01));

   ir_expression *const r00B0 = add(r00A9, r00AB);
   ir_expression *const r00B1 = less(r00AF, r00AA);
   ir_expression *const r00B2 = expr(ir_unop_b2i, r00B1);
   ir_expression *const r00B3 = expr(ir_unop_i2u, r00B2);
   body.emit(assign(r00AD, add(r00B0, r00B3), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
sub64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00B4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00B4);
   ir_variable *const r00B5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00B5);
   ir_variable *const r00B6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r00B6);
   ir_variable *const r00B7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r00B7);
   ir_variable *const r00B8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00B8);
   ir_variable *const r00B9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00B9);
   body.emit(assign(r00B9, sub(r00B5, r00B7), 0x01));

   ir_expression *const r00BA = sub(r00B4, r00B6);
   ir_expression *const r00BB = less(r00B5, r00B7);
   ir_expression *const r00BC = expr(ir_unop_b2i, r00BB);
   ir_expression *const r00BD = expr(ir_unop_i2u, r00BC);
   body.emit(assign(r00B8, sub(r00BA, r00BD), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
eq64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00BE = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00BE);
   ir_variable *const r00BF = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00BF);
   ir_variable *const r00C0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r00C0);
   ir_variable *const r00C1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r00C1);
   ir_expression *const r00C2 = equal(r00BE, r00C0);
   ir_expression *const r00C3 = equal(r00BF, r00C1);
   ir_expression *const r00C4 = logic_and(r00C2, r00C3);
   body.emit(ret(r00C4));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
float64_is_signaling_nan(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00C5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r00C5);
   ir_expression *const r00C6 = rshift(swizzle_y(r00C5), body.constant(int(19)));
   ir_expression *const r00C7 = bit_and(r00C6, body.constant(4095u));
   ir_expression *const r00C8 = equal(r00C7, body.constant(4094u));
   ir_expression *const r00C9 = nequal(swizzle_x(r00C5), body.constant(0u));
   ir_expression *const r00CA = bit_and(swizzle_y(r00C5), body.constant(524287u));
   ir_expression *const r00CB = nequal(r00CA, body.constant(0u));
   ir_expression *const r00CC = logic_or(r00C9, r00CB);
   ir_expression *const r00CD = logic_and(r00C8, r00CC);
   body.emit(ret(r00CD));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift64RightJamming(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00CE = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00CE);
   ir_variable *const r00CF = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00CF);
   ir_variable *const r00D0 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r00D0);
   ir_variable *const r00D1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00D1);
   ir_variable *const r00D2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00D2);
   ir_variable *const r00D3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r00D3);
   ir_variable *const r00D4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r00D4);
   ir_variable *const r00D5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r00D6 = neg(r00D0);
   body.emit(assign(r00D5, bit_and(r00D6, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r00D8 = equal(r00D0, body.constant(int(0)));
   ir_if *f00D7 = new(mem_ctx) ir_if(operand(r00D8).val);
   exec_list *const f00D7_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f00D7->then_instructions;

      body.emit(assign(r00D3, r00CF, 0x01));

      body.emit(assign(r00D4, r00CE, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f00D7->else_instructions;

      /* IF CONDITION */
      ir_expression *const r00DA = less(r00D0, body.constant(int(32)));
      ir_if *f00D9 = new(mem_ctx) ir_if(operand(r00DA).val);
      exec_list *const f00D9_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f00D9->then_instructions;

         ir_expression *const r00DB = lshift(r00CE, r00D5);
         ir_expression *const r00DC = rshift(r00CF, r00D0);
         ir_expression *const r00DD = bit_or(r00DB, r00DC);
         ir_expression *const r00DE = lshift(r00CF, r00D5);
         ir_expression *const r00DF = nequal(r00DE, body.constant(0u));
         ir_expression *const r00E0 = expr(ir_unop_b2i, r00DF);
         ir_expression *const r00E1 = expr(ir_unop_i2u, r00E0);
         body.emit(assign(r00D3, bit_or(r00DD, r00E1), 0x01));

         body.emit(assign(r00D4, rshift(r00CE, r00D0), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f00D9->else_instructions;

         /* IF CONDITION */
         ir_expression *const r00E3 = equal(r00D0, body.constant(int(32)));
         ir_if *f00E2 = new(mem_ctx) ir_if(operand(r00E3).val);
         exec_list *const f00E2_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f00E2->then_instructions;

            ir_expression *const r00E4 = nequal(r00CF, body.constant(0u));
            ir_expression *const r00E5 = expr(ir_unop_b2i, r00E4);
            ir_expression *const r00E6 = expr(ir_unop_i2u, r00E5);
            body.emit(assign(r00D3, bit_or(r00CE, r00E6), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f00E2->else_instructions;

            /* IF CONDITION */
            ir_expression *const r00E8 = less(r00D0, body.constant(int(64)));
            ir_if *f00E7 = new(mem_ctx) ir_if(operand(r00E8).val);
            exec_list *const f00E7_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f00E7->then_instructions;

               ir_expression *const r00E9 = bit_and(r00D0, body.constant(int(31)));
               ir_expression *const r00EA = rshift(r00CE, r00E9);
               ir_expression *const r00EB = lshift(r00CE, r00D5);
               ir_expression *const r00EC = bit_or(r00EB, r00CF);
               ir_expression *const r00ED = nequal(r00EC, body.constant(0u));
               ir_expression *const r00EE = expr(ir_unop_b2i, r00ED);
               ir_expression *const r00EF = expr(ir_unop_i2u, r00EE);
               body.emit(assign(r00D3, bit_or(r00EA, r00EF), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f00E7->else_instructions;

               ir_expression *const r00F0 = bit_or(r00CE, r00CF);
               ir_expression *const r00F1 = nequal(r00F0, body.constant(0u));
               ir_expression *const r00F2 = expr(ir_unop_b2i, r00F1);
               body.emit(assign(r00D3, expr(ir_unop_i2u, r00F2), 0x01));


            body.instructions = f00E7_parent_instructions;
            body.emit(f00E7);

            /* END IF */


         body.instructions = f00E2_parent_instructions;
         body.emit(f00E2);

         /* END IF */

         body.emit(assign(r00D4, body.constant(0u), 0x01));


      body.instructions = f00D9_parent_instructions;
      body.emit(f00D9);

      /* END IF */


   body.instructions = f00D7_parent_instructions;
   body.emit(f00D7);

   /* END IF */

   body.emit(assign(r00D2, r00D3, 0x01));

   body.emit(assign(r00D1, r00D4, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift64ExtraRightJamming(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00F3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00F3);
   ir_variable *const r00F4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00F4);
   ir_variable *const r00F5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a2", ir_var_function_in);
   sig_parameters.push_tail(r00F5);
   ir_variable *const r00F6 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r00F6);
   ir_variable *const r00F7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00F7);
   ir_variable *const r00F8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00F8);
   ir_variable *const r00F9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00F9);
   ir_variable *const r00FA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
   body.emit(r00FA);
   ir_variable *const r00FB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r00FB);
   ir_variable *const r00FC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r00FC);
   ir_variable *const r00FD = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r00FE = neg(r00F6);
   body.emit(assign(r00FD, bit_and(r00FE, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r0100 = equal(r00F6, body.constant(int(0)));
   ir_if *f00FF = new(mem_ctx) ir_if(operand(r0100).val);
   exec_list *const f00FF_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f00FF->then_instructions;

      body.emit(assign(r00FA, r00F5, 0x01));

      body.emit(assign(r00FB, r00F4, 0x01));

      body.emit(assign(r00FC, r00F3, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f00FF->else_instructions;

      /* IF CONDITION */
      ir_expression *const r0102 = less(r00F6, body.constant(int(32)));
      ir_if *f0101 = new(mem_ctx) ir_if(operand(r0102).val);
      exec_list *const f0101_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0101->then_instructions;

         body.emit(assign(r00FA, lshift(r00F4, r00FD), 0x01));

         ir_expression *const r0103 = lshift(r00F3, r00FD);
         ir_expression *const r0104 = rshift(r00F4, r00F6);
         body.emit(assign(r00FB, bit_or(r0103, r0104), 0x01));

         body.emit(assign(r00FC, rshift(r00F3, r00F6), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0101->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0106 = equal(r00F6, body.constant(int(32)));
         ir_if *f0105 = new(mem_ctx) ir_if(operand(r0106).val);
         exec_list *const f0105_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0105->then_instructions;

            body.emit(assign(r00FA, r00F4, 0x01));

            body.emit(assign(r00FB, r00F3, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0105->else_instructions;

            body.emit(assign(r00F5, bit_or(r00F5, r00F4), 0x01));

            /* IF CONDITION */
            ir_expression *const r0108 = less(r00F6, body.constant(int(64)));
            ir_if *f0107 = new(mem_ctx) ir_if(operand(r0108).val);
            exec_list *const f0107_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0107->then_instructions;

               body.emit(assign(r00FA, lshift(r00F3, r00FD), 0x01));

               ir_expression *const r0109 = bit_and(r00F6, body.constant(int(31)));
               body.emit(assign(r00FB, rshift(r00F3, r0109), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0107->else_instructions;

               ir_variable *const r010A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r010C = equal(r00F6, body.constant(int(64)));
               ir_if *f010B = new(mem_ctx) ir_if(operand(r010C).val);
               exec_list *const f010B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f010B->then_instructions;

                  body.emit(assign(r010A, r00F3, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f010B->else_instructions;

                  ir_expression *const r010D = nequal(r00F3, body.constant(0u));
                  ir_expression *const r010E = expr(ir_unop_b2i, r010D);
                  body.emit(assign(r010A, expr(ir_unop_i2u, r010E), 0x01));


               body.instructions = f010B_parent_instructions;
               body.emit(f010B);

               /* END IF */

               body.emit(assign(r00FA, r010A, 0x01));

               body.emit(assign(r00FB, body.constant(0u), 0x01));


            body.instructions = f0107_parent_instructions;
            body.emit(f0107);

            /* END IF */


         body.instructions = f0105_parent_instructions;
         body.emit(f0105);

         /* END IF */

         body.emit(assign(r00FC, body.constant(0u), 0x01));


      body.instructions = f0101_parent_instructions;
      body.emit(f0101);

      /* END IF */

      ir_expression *const r010F = nequal(r00F5, body.constant(0u));
      ir_expression *const r0110 = expr(ir_unop_b2i, r010F);
      ir_expression *const r0111 = expr(ir_unop_i2u, r0110);
      body.emit(assign(r00FA, bit_or(r00FA, r0111), 0x01));


   body.instructions = f00FF_parent_instructions;
   body.emit(f00FF);

   /* END IF */

   body.emit(assign(r00F9, r00FA, 0x01));

   body.emit(assign(r00F8, r00FB, 0x01));

   body.emit(assign(r00F7, r00FC, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shortShift64Left(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0112 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r0112);
   ir_variable *const r0113 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r0113);
   ir_variable *const r0114 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r0114);
   ir_variable *const r0115 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0115);
   ir_variable *const r0116 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0116);
   body.emit(assign(r0116, lshift(r0113, r0114), 0x01));

   ir_variable *const r0117 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
   /* IF CONDITION */
   ir_expression *const r0119 = equal(r0114, body.constant(int(0)));
   ir_if *f0118 = new(mem_ctx) ir_if(operand(r0119).val);
   exec_list *const f0118_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0118->then_instructions;

      body.emit(assign(r0117, r0112, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0118->else_instructions;

      ir_expression *const r011A = lshift(r0112, r0114);
      ir_expression *const r011B = neg(r0114);
      ir_expression *const r011C = bit_and(r011B, body.constant(int(31)));
      ir_expression *const r011D = rshift(r0113, r011C);
      body.emit(assign(r0117, bit_or(r011A, r011D), 0x01));


   body.instructions = f0118_parent_instructions;
   body.emit(f0118);

   /* END IF */

   body.emit(assign(r0115, r0117, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
packFloat64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r011E = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r011E);
   ir_variable *const r011F = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r011F);
   ir_variable *const r0120 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_function_in);
   sig_parameters.push_tail(r0120);
   ir_variable *const r0121 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_function_in);
   sig_parameters.push_tail(r0121);
   ir_variable *const r0122 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
   body.emit(r0122);
   ir_expression *const r0123 = lshift(r011E, body.constant(int(31)));
   ir_expression *const r0124 = expr(ir_unop_i2u, r011F);
   ir_expression *const r0125 = lshift(r0124, body.constant(int(20)));
   ir_expression *const r0126 = add(r0123, r0125);
   body.emit(assign(r0122, add(r0126, r0120), 0x02));

   body.emit(assign(r0122, r0121, 0x01));

   body.emit(ret(r0122));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
roundAndPackFloat64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0127 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r0127);
   ir_variable *const r0128 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r0128);
   ir_variable *const r0129 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_function_in);
   sig_parameters.push_tail(r0129);
   ir_variable *const r012A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_function_in);
   sig_parameters.push_tail(r012A);
   ir_variable *const r012B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_function_in);
   sig_parameters.push_tail(r012B);
   ir_variable *const r012C = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r012C, body.constant(true), 0x01));

   ir_variable *const r012D = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r012E = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
   body.emit(r012E);
   ir_expression *const r012F = expr(ir_unop_u2i, r012B);
   body.emit(assign(r012E, less(r012F, body.constant(int(0))), 0x01));

   /* IF CONDITION */
   ir_expression *const r0131 = lequal(body.constant(int(2045)), r0128);
   ir_if *f0130 = new(mem_ctx) ir_if(operand(r0131).val);
   exec_list *const f0130_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0130->then_instructions;

      ir_variable *const r0132 = body.make_temp(glsl_type::bool_type, "or_tmp");
      /* IF CONDITION */
      ir_expression *const r0134 = less(body.constant(int(2045)), r0128);
      ir_if *f0133 = new(mem_ctx) ir_if(operand(r0134).val);
      exec_list *const f0133_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0133->then_instructions;

         body.emit(assign(r0132, body.constant(true), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0133->else_instructions;

         ir_variable *const r0135 = body.make_temp(glsl_type::bool_type, "and_tmp");
         /* IF CONDITION */
         ir_expression *const r0137 = equal(r0128, body.constant(int(2045)));
         ir_if *f0136 = new(mem_ctx) ir_if(operand(r0137).val);
         exec_list *const f0136_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0136->then_instructions;

            ir_expression *const r0138 = equal(body.constant(2097151u), r0129);
            ir_expression *const r0139 = equal(body.constant(4294967295u), r012A);
            body.emit(assign(r0135, logic_and(r0138, r0139), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0136->else_instructions;

            body.emit(assign(r0135, body.constant(false), 0x01));


         body.instructions = f0136_parent_instructions;
         body.emit(f0136);

         /* END IF */

         body.emit(assign(r0132, logic_and(r0135, r012E), 0x01));


      body.instructions = f0133_parent_instructions;
      body.emit(f0133);

      /* END IF */

      /* IF CONDITION */
      ir_if *f013A = new(mem_ctx) ir_if(operand(r0132).val);
      exec_list *const f013A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f013A->then_instructions;

         ir_variable *const r013B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r013B);
         ir_expression *const r013C = lshift(r0127, body.constant(int(31)));
         body.emit(assign(r013B, add(r013C, body.constant(2146435072u)), 0x02));

         body.emit(assign(r013B, body.constant(0u), 0x01));

         body.emit(assign(r012D, r013B, 0x03));

         body.emit(assign(r012C, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f013A->else_instructions;

         /* IF CONDITION */
         ir_expression *const r013E = less(r0128, body.constant(int(0)));
         ir_if *f013D = new(mem_ctx) ir_if(operand(r013E).val);
         exec_list *const f013D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f013D->then_instructions;

            ir_variable *const r013F = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r013F, r012B, 0x01));

            ir_variable *const r0140 = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r0140, neg(r0128), 0x01));

            ir_variable *const r0141 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r0141);
            ir_variable *const r0142 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r0142);
            ir_variable *const r0143 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r0143);
            ir_variable *const r0144 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r0145 = neg(r0140);
            body.emit(assign(r0144, bit_and(r0145, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0147 = equal(r0140, body.constant(int(0)));
            ir_if *f0146 = new(mem_ctx) ir_if(operand(r0147).val);
            exec_list *const f0146_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0146->then_instructions;

               body.emit(assign(r0141, r012B, 0x01));

               body.emit(assign(r0142, r012A, 0x01));

               body.emit(assign(r0143, r0129, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0146->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0149 = less(r0140, body.constant(int(32)));
               ir_if *f0148 = new(mem_ctx) ir_if(operand(r0149).val);
               exec_list *const f0148_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0148->then_instructions;

                  body.emit(assign(r0141, lshift(r012A, r0144), 0x01));

                  ir_expression *const r014A = lshift(r0129, r0144);
                  ir_expression *const r014B = rshift(r012A, r0140);
                  body.emit(assign(r0142, bit_or(r014A, r014B), 0x01));

                  body.emit(assign(r0143, rshift(r0129, r0140), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0148->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r014D = equal(r0140, body.constant(int(32)));
                  ir_if *f014C = new(mem_ctx) ir_if(operand(r014D).val);
                  exec_list *const f014C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f014C->then_instructions;

                     body.emit(assign(r0141, r012A, 0x01));

                     body.emit(assign(r0142, r0129, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f014C->else_instructions;

                     body.emit(assign(r013F, bit_or(r012B, r012A), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r014F = less(r0140, body.constant(int(64)));
                     ir_if *f014E = new(mem_ctx) ir_if(operand(r014F).val);
                     exec_list *const f014E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f014E->then_instructions;

                        body.emit(assign(r0141, lshift(r0129, r0144), 0x01));

                        ir_expression *const r0150 = bit_and(r0140, body.constant(int(31)));
                        body.emit(assign(r0142, rshift(r0129, r0150), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f014E->else_instructions;

                        ir_variable *const r0151 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0153 = equal(r0140, body.constant(int(64)));
                        ir_if *f0152 = new(mem_ctx) ir_if(operand(r0153).val);
                        exec_list *const f0152_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0152->then_instructions;

                           body.emit(assign(r0151, r0129, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0152->else_instructions;

                           ir_expression *const r0154 = nequal(r0129, body.constant(0u));
                           ir_expression *const r0155 = expr(ir_unop_b2i, r0154);
                           body.emit(assign(r0151, expr(ir_unop_i2u, r0155), 0x01));


                        body.instructions = f0152_parent_instructions;
                        body.emit(f0152);

                        /* END IF */

                        body.emit(assign(r0141, r0151, 0x01));

                        body.emit(assign(r0142, body.constant(0u), 0x01));


                     body.instructions = f014E_parent_instructions;
                     body.emit(f014E);

                     /* END IF */


                  body.instructions = f014C_parent_instructions;
                  body.emit(f014C);

                  /* END IF */

                  body.emit(assign(r0143, body.constant(0u), 0x01));


               body.instructions = f0148_parent_instructions;
               body.emit(f0148);

               /* END IF */

               ir_expression *const r0156 = nequal(r013F, body.constant(0u));
               ir_expression *const r0157 = expr(ir_unop_b2i, r0156);
               ir_expression *const r0158 = expr(ir_unop_i2u, r0157);
               body.emit(assign(r0141, bit_or(r0141, r0158), 0x01));


            body.instructions = f0146_parent_instructions;
            body.emit(f0146);

            /* END IF */

            body.emit(assign(r0129, r0143, 0x01));

            body.emit(assign(r012A, r0142, 0x01));

            body.emit(assign(r012B, r0141, 0x01));

            body.emit(assign(r0128, body.constant(int(0)), 0x01));

            body.emit(assign(r012E, less(r0141, body.constant(0u)), 0x01));


         body.instructions = f013D_parent_instructions;
         body.emit(f013D);

         /* END IF */


      body.instructions = f013A_parent_instructions;
      body.emit(f013A);

      /* END IF */


   body.instructions = f0130_parent_instructions;
   body.emit(f0130);

   /* END IF */

   /* IF CONDITION */
   ir_if *f0159 = new(mem_ctx) ir_if(operand(r012C).val);
   exec_list *const f0159_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0159->then_instructions;

      /* IF CONDITION */
      ir_if *f015A = new(mem_ctx) ir_if(operand(r012E).val);
      exec_list *const f015A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f015A->then_instructions;

         ir_variable *const r015B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r015B, add(r012A, body.constant(1u)), 0x01));

         ir_expression *const r015C = less(r015B, r012A);
         ir_expression *const r015D = expr(ir_unop_b2i, r015C);
         ir_expression *const r015E = expr(ir_unop_i2u, r015D);
         body.emit(assign(r0129, add(r0129, r015E), 0x01));

         ir_expression *const r015F = equal(r012B, body.constant(0u));
         ir_expression *const r0160 = expr(ir_unop_b2i, r015F);
         ir_expression *const r0161 = expr(ir_unop_i2u, r0160);
         ir_expression *const r0162 = add(r012B, r0161);
         ir_expression *const r0163 = bit_and(r0162, body.constant(1u));
         ir_expression *const r0164 = expr(ir_unop_bit_not, r0163);
         body.emit(assign(r012A, bit_and(r015B, r0164), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f015A->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0166 = bit_or(r0129, r012A);
         ir_expression *const r0167 = equal(r0166, body.constant(0u));
         ir_if *f0165 = new(mem_ctx) ir_if(operand(r0167).val);
         exec_list *const f0165_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0165->then_instructions;

            body.emit(assign(r0128, body.constant(int(0)), 0x01));


         body.instructions = f0165_parent_instructions;
         body.emit(f0165);

         /* END IF */


      body.instructions = f015A_parent_instructions;
      body.emit(f015A);

      /* END IF */

      ir_variable *const r0168 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r0168);
      ir_expression *const r0169 = lshift(r0127, body.constant(int(31)));
      ir_expression *const r016A = expr(ir_unop_i2u, r0128);
      ir_expression *const r016B = lshift(r016A, body.constant(int(20)));
      ir_expression *const r016C = add(r0169, r016B);
      body.emit(assign(r0168, add(r016C, r0129), 0x02));

      body.emit(assign(r0168, r012A, 0x01));

      body.emit(assign(r012D, r0168, 0x03));

      body.emit(assign(r012C, body.constant(false), 0x01));


   body.instructions = f0159_parent_instructions;
   body.emit(f0159);

   /* END IF */

   body.emit(ret(r012D));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
countLeadingZeros32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::int_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r016D = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r016D);
   ir_variable *const r016E = body.make_temp(glsl_type::int_type, "return_value");
   ir_variable *const r016F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r016F);
   /* IF CONDITION */
   ir_expression *const r0171 = equal(r016D, body.constant(0u));
   ir_if *f0170 = new(mem_ctx) ir_if(operand(r0171).val);
   exec_list *const f0170_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0170->then_instructions;

      body.emit(assign(r016E, body.constant(int(32)), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0170->else_instructions;

      body.emit(assign(r016F, body.constant(int(0)), 0x01));

      /* IF CONDITION */
      ir_expression *const r0173 = bit_and(r016D, body.constant(4294901760u));
      ir_expression *const r0174 = equal(r0173, body.constant(0u));
      ir_if *f0172 = new(mem_ctx) ir_if(operand(r0174).val);
      exec_list *const f0172_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0172->then_instructions;

         body.emit(assign(r016F, body.constant(int(16)), 0x01));

         body.emit(assign(r016D, lshift(r016D, body.constant(int(16))), 0x01));


      body.instructions = f0172_parent_instructions;
      body.emit(f0172);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0176 = bit_and(r016D, body.constant(4278190080u));
      ir_expression *const r0177 = equal(r0176, body.constant(0u));
      ir_if *f0175 = new(mem_ctx) ir_if(operand(r0177).val);
      exec_list *const f0175_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0175->then_instructions;

         body.emit(assign(r016F, add(r016F, body.constant(int(8))), 0x01));

         body.emit(assign(r016D, lshift(r016D, body.constant(int(8))), 0x01));


      body.instructions = f0175_parent_instructions;
      body.emit(f0175);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0179 = bit_and(r016D, body.constant(4026531840u));
      ir_expression *const r017A = equal(r0179, body.constant(0u));
      ir_if *f0178 = new(mem_ctx) ir_if(operand(r017A).val);
      exec_list *const f0178_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0178->then_instructions;

         body.emit(assign(r016F, add(r016F, body.constant(int(4))), 0x01));

         body.emit(assign(r016D, lshift(r016D, body.constant(int(4))), 0x01));


      body.instructions = f0178_parent_instructions;
      body.emit(f0178);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r017C = bit_and(r016D, body.constant(3221225472u));
      ir_expression *const r017D = equal(r017C, body.constant(0u));
      ir_if *f017B = new(mem_ctx) ir_if(operand(r017D).val);
      exec_list *const f017B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f017B->then_instructions;

         body.emit(assign(r016F, add(r016F, body.constant(int(2))), 0x01));

         body.emit(assign(r016D, lshift(r016D, body.constant(int(2))), 0x01));


      body.instructions = f017B_parent_instructions;
      body.emit(f017B);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r017F = bit_and(r016D, body.constant(2147483648u));
      ir_expression *const r0180 = equal(r017F, body.constant(0u));
      ir_if *f017E = new(mem_ctx) ir_if(operand(r0180).val);
      exec_list *const f017E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f017E->then_instructions;

         body.emit(assign(r016F, add(r016F, body.constant(int(1))), 0x01));


      body.instructions = f017E_parent_instructions;
      body.emit(f017E);

      /* END IF */

      body.emit(assign(r016E, r016F, 0x01));


   body.instructions = f0170_parent_instructions;
   body.emit(f0170);

   /* END IF */

   body.emit(ret(r016E));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
normalizeRoundAndPackFloat64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0181 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r0181);
   ir_variable *const r0182 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r0182);
   ir_variable *const r0183 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_function_in);
   sig_parameters.push_tail(r0183);
   ir_variable *const r0184 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_function_in);
   sig_parameters.push_tail(r0184);
   ir_variable *const r0185 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
   body.emit(r0185);
   ir_variable *const r0186 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r0186);
   /* IF CONDITION */
   ir_expression *const r0188 = equal(r0183, body.constant(0u));
   ir_if *f0187 = new(mem_ctx) ir_if(operand(r0188).val);
   exec_list *const f0187_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0187->then_instructions;

      body.emit(assign(r0183, r0184, 0x01));

      body.emit(assign(r0184, body.constant(0u), 0x01));

      body.emit(assign(r0182, add(r0182, body.constant(int(-32))), 0x01));


   body.instructions = f0187_parent_instructions;
   body.emit(f0187);

   /* END IF */

   ir_variable *const r0189 = body.make_temp(glsl_type::uint_type, "a");
   body.emit(assign(r0189, r0183, 0x01));

   ir_variable *const r018A = body.make_temp(glsl_type::int_type, "return_value");
   ir_variable *const r018B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r018B);
   /* IF CONDITION */
   ir_expression *const r018D = equal(r0183, body.constant(0u));
   ir_if *f018C = new(mem_ctx) ir_if(operand(r018D).val);
   exec_list *const f018C_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f018C->then_instructions;

      body.emit(assign(r018A, body.constant(int(32)), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f018C->else_instructions;

      body.emit(assign(r018B, body.constant(int(0)), 0x01));

      /* IF CONDITION */
      ir_expression *const r018F = bit_and(r0183, body.constant(4294901760u));
      ir_expression *const r0190 = equal(r018F, body.constant(0u));
      ir_if *f018E = new(mem_ctx) ir_if(operand(r0190).val);
      exec_list *const f018E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f018E->then_instructions;

         body.emit(assign(r018B, body.constant(int(16)), 0x01));

         body.emit(assign(r0189, lshift(r0183, body.constant(int(16))), 0x01));


      body.instructions = f018E_parent_instructions;
      body.emit(f018E);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0192 = bit_and(r0189, body.constant(4278190080u));
      ir_expression *const r0193 = equal(r0192, body.constant(0u));
      ir_if *f0191 = new(mem_ctx) ir_if(operand(r0193).val);
      exec_list *const f0191_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0191->then_instructions;

         body.emit(assign(r018B, add(r018B, body.constant(int(8))), 0x01));

         body.emit(assign(r0189, lshift(r0189, body.constant(int(8))), 0x01));


      body.instructions = f0191_parent_instructions;
      body.emit(f0191);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0195 = bit_and(r0189, body.constant(4026531840u));
      ir_expression *const r0196 = equal(r0195, body.constant(0u));
      ir_if *f0194 = new(mem_ctx) ir_if(operand(r0196).val);
      exec_list *const f0194_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0194->then_instructions;

         body.emit(assign(r018B, add(r018B, body.constant(int(4))), 0x01));

         body.emit(assign(r0189, lshift(r0189, body.constant(int(4))), 0x01));


      body.instructions = f0194_parent_instructions;
      body.emit(f0194);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0198 = bit_and(r0189, body.constant(3221225472u));
      ir_expression *const r0199 = equal(r0198, body.constant(0u));
      ir_if *f0197 = new(mem_ctx) ir_if(operand(r0199).val);
      exec_list *const f0197_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0197->then_instructions;

         body.emit(assign(r018B, add(r018B, body.constant(int(2))), 0x01));

         body.emit(assign(r0189, lshift(r0189, body.constant(int(2))), 0x01));


      body.instructions = f0197_parent_instructions;
      body.emit(f0197);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r019B = bit_and(r0189, body.constant(2147483648u));
      ir_expression *const r019C = equal(r019B, body.constant(0u));
      ir_if *f019A = new(mem_ctx) ir_if(operand(r019C).val);
      exec_list *const f019A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f019A->then_instructions;

         body.emit(assign(r018B, add(r018B, body.constant(int(1))), 0x01));


      body.instructions = f019A_parent_instructions;
      body.emit(f019A);

      /* END IF */

      body.emit(assign(r018A, r018B, 0x01));


   body.instructions = f018C_parent_instructions;
   body.emit(f018C);

   /* END IF */

   body.emit(assign(r0186, add(r018A, body.constant(int(-11))), 0x01));

   /* IF CONDITION */
   ir_expression *const r019E = lequal(body.constant(int(0)), r0186);
   ir_if *f019D = new(mem_ctx) ir_if(operand(r019E).val);
   exec_list *const f019D_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f019D->then_instructions;

      body.emit(assign(r0185, body.constant(0u), 0x01));

      ir_variable *const r019F = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r019F, lshift(r0184, r0186), 0x01));

      ir_variable *const r01A0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r01A2 = equal(r0186, body.constant(int(0)));
      ir_if *f01A1 = new(mem_ctx) ir_if(operand(r01A2).val);
      exec_list *const f01A1_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01A1->then_instructions;

         body.emit(assign(r01A0, r0183, 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01A1->else_instructions;

         ir_expression *const r01A3 = lshift(r0183, r0186);
         ir_expression *const r01A4 = neg(r0186);
         ir_expression *const r01A5 = bit_and(r01A4, body.constant(int(31)));
         ir_expression *const r01A6 = rshift(r0184, r01A5);
         body.emit(assign(r01A0, bit_or(r01A3, r01A6), 0x01));


      body.instructions = f01A1_parent_instructions;
      body.emit(f01A1);

      /* END IF */

      body.emit(assign(r0183, r01A0, 0x01));

      body.emit(assign(r0184, r019F, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f019D->else_instructions;

      ir_variable *const r01A7 = body.make_temp(glsl_type::uint_type, "a2");
      body.emit(assign(r01A7, body.constant(0u), 0x01));

      ir_variable *const r01A8 = body.make_temp(glsl_type::int_type, "count");
      body.emit(assign(r01A8, neg(r0186), 0x01));

      ir_variable *const r01A9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
      body.emit(r01A9);
      ir_variable *const r01AA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r01AA);
      ir_variable *const r01AB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r01AB);
      ir_variable *const r01AC = body.make_temp(glsl_type::int_type, "assignment_tmp");
      ir_expression *const r01AD = neg(r01A8);
      body.emit(assign(r01AC, bit_and(r01AD, body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r01AF = equal(r01A8, body.constant(int(0)));
      ir_if *f01AE = new(mem_ctx) ir_if(operand(r01AF).val);
      exec_list *const f01AE_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01AE->then_instructions;

         body.emit(assign(r01A9, r01A7, 0x01));

         body.emit(assign(r01AA, r0184, 0x01));

         body.emit(assign(r01AB, r0183, 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01AE->else_instructions;

         /* IF CONDITION */
         ir_expression *const r01B1 = less(r01A8, body.constant(int(32)));
         ir_if *f01B0 = new(mem_ctx) ir_if(operand(r01B1).val);
         exec_list *const f01B0_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f01B0->then_instructions;

            body.emit(assign(r01A9, lshift(r0184, r01AC), 0x01));

            ir_expression *const r01B2 = lshift(r0183, r01AC);
            ir_expression *const r01B3 = rshift(r0184, r01A8);
            body.emit(assign(r01AA, bit_or(r01B2, r01B3), 0x01));

            body.emit(assign(r01AB, rshift(r0183, r01A8), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f01B0->else_instructions;

            /* IF CONDITION */
            ir_expression *const r01B5 = equal(r01A8, body.constant(int(32)));
            ir_if *f01B4 = new(mem_ctx) ir_if(operand(r01B5).val);
            exec_list *const f01B4_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f01B4->then_instructions;

               body.emit(assign(r01A9, r0184, 0x01));

               body.emit(assign(r01AA, r0183, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f01B4->else_instructions;

               body.emit(assign(r01A7, bit_or(body.constant(0u), r0184), 0x01));

               /* IF CONDITION */
               ir_expression *const r01B7 = less(r01A8, body.constant(int(64)));
               ir_if *f01B6 = new(mem_ctx) ir_if(operand(r01B7).val);
               exec_list *const f01B6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f01B6->then_instructions;

                  body.emit(assign(r01A9, lshift(r0183, r01AC), 0x01));

                  ir_expression *const r01B8 = bit_and(r01A8, body.constant(int(31)));
                  body.emit(assign(r01AA, rshift(r0183, r01B8), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f01B6->else_instructions;

                  ir_variable *const r01B9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r01BB = equal(r01A8, body.constant(int(64)));
                  ir_if *f01BA = new(mem_ctx) ir_if(operand(r01BB).val);
                  exec_list *const f01BA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f01BA->then_instructions;

                     body.emit(assign(r01B9, r0183, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f01BA->else_instructions;

                     ir_expression *const r01BC = nequal(r0183, body.constant(0u));
                     ir_expression *const r01BD = expr(ir_unop_b2i, r01BC);
                     body.emit(assign(r01B9, expr(ir_unop_i2u, r01BD), 0x01));


                  body.instructions = f01BA_parent_instructions;
                  body.emit(f01BA);

                  /* END IF */

                  body.emit(assign(r01A9, r01B9, 0x01));

                  body.emit(assign(r01AA, body.constant(0u), 0x01));


               body.instructions = f01B6_parent_instructions;
               body.emit(f01B6);

               /* END IF */


            body.instructions = f01B4_parent_instructions;
            body.emit(f01B4);

            /* END IF */

            body.emit(assign(r01AB, body.constant(0u), 0x01));


         body.instructions = f01B0_parent_instructions;
         body.emit(f01B0);

         /* END IF */

         ir_expression *const r01BE = nequal(r01A7, body.constant(0u));
         ir_expression *const r01BF = expr(ir_unop_b2i, r01BE);
         ir_expression *const r01C0 = expr(ir_unop_i2u, r01BF);
         body.emit(assign(r01A9, bit_or(r01A9, r01C0), 0x01));


      body.instructions = f01AE_parent_instructions;
      body.emit(f01AE);

      /* END IF */

      body.emit(assign(r0183, r01AB, 0x01));

      body.emit(assign(r0184, r01AA, 0x01));

      body.emit(assign(r0185, r01A9, 0x01));


   body.instructions = f019D_parent_instructions;
   body.emit(f019D);

   /* END IF */

   body.emit(assign(r0182, sub(r0182, r0186), 0x01));

   ir_variable *const r01C1 = body.make_temp(glsl_type::int_type, "zExp");
   body.emit(assign(r01C1, r0182, 0x01));

   ir_variable *const r01C2 = body.make_temp(glsl_type::uint_type, "zFrac0");
   body.emit(assign(r01C2, r0183, 0x01));

   ir_variable *const r01C3 = body.make_temp(glsl_type::uint_type, "zFrac1");
   body.emit(assign(r01C3, r0184, 0x01));

   ir_variable *const r01C4 = body.make_temp(glsl_type::uint_type, "zFrac2");
   body.emit(assign(r01C4, r0185, 0x01));

   ir_variable *const r01C5 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r01C5, body.constant(true), 0x01));

   ir_variable *const r01C6 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r01C7 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
   body.emit(r01C7);
   ir_expression *const r01C8 = expr(ir_unop_u2i, r0185);
   body.emit(assign(r01C7, less(r01C8, body.constant(int(0))), 0x01));

   /* IF CONDITION */
   ir_expression *const r01CA = lequal(body.constant(int(2045)), r0182);
   ir_if *f01C9 = new(mem_ctx) ir_if(operand(r01CA).val);
   exec_list *const f01C9_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f01C9->then_instructions;

      ir_variable *const r01CB = body.make_temp(glsl_type::bool_type, "or_tmp");
      /* IF CONDITION */
      ir_expression *const r01CD = less(body.constant(int(2045)), r0182);
      ir_if *f01CC = new(mem_ctx) ir_if(operand(r01CD).val);
      exec_list *const f01CC_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01CC->then_instructions;

         body.emit(assign(r01CB, body.constant(true), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01CC->else_instructions;

         ir_variable *const r01CE = body.make_temp(glsl_type::bool_type, "and_tmp");
         /* IF CONDITION */
         ir_expression *const r01D0 = equal(r0182, body.constant(int(2045)));
         ir_if *f01CF = new(mem_ctx) ir_if(operand(r01D0).val);
         exec_list *const f01CF_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f01CF->then_instructions;

            ir_expression *const r01D1 = equal(body.constant(2097151u), r0183);
            ir_expression *const r01D2 = equal(body.constant(4294967295u), r0184);
            body.emit(assign(r01CE, logic_and(r01D1, r01D2), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f01CF->else_instructions;

            body.emit(assign(r01CE, body.constant(false), 0x01));


         body.instructions = f01CF_parent_instructions;
         body.emit(f01CF);

         /* END IF */

         body.emit(assign(r01CB, logic_and(r01CE, r01C7), 0x01));


      body.instructions = f01CC_parent_instructions;
      body.emit(f01CC);

      /* END IF */

      /* IF CONDITION */
      ir_if *f01D3 = new(mem_ctx) ir_if(operand(r01CB).val);
      exec_list *const f01D3_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01D3->then_instructions;

         ir_variable *const r01D4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r01D4);
         ir_expression *const r01D5 = lshift(r0181, body.constant(int(31)));
         body.emit(assign(r01D4, add(r01D5, body.constant(2146435072u)), 0x02));

         body.emit(assign(r01D4, body.constant(0u), 0x01));

         body.emit(assign(r01C6, r01D4, 0x03));

         body.emit(assign(r01C5, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01D3->else_instructions;

         /* IF CONDITION */
         ir_expression *const r01D7 = less(r0182, body.constant(int(0)));
         ir_if *f01D6 = new(mem_ctx) ir_if(operand(r01D7).val);
         exec_list *const f01D6_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f01D6->then_instructions;

            ir_variable *const r01D8 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r01D8, r0185, 0x01));

            ir_variable *const r01D9 = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r01D9, neg(r0182), 0x01));

            ir_variable *const r01DA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r01DA);
            ir_variable *const r01DB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r01DB);
            ir_variable *const r01DC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r01DC);
            ir_variable *const r01DD = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r01DE = neg(r01D9);
            body.emit(assign(r01DD, bit_and(r01DE, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r01E0 = equal(r01D9, body.constant(int(0)));
            ir_if *f01DF = new(mem_ctx) ir_if(operand(r01E0).val);
            exec_list *const f01DF_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f01DF->then_instructions;

               body.emit(assign(r01DA, r0185, 0x01));

               body.emit(assign(r01DB, r0184, 0x01));

               body.emit(assign(r01DC, r0183, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f01DF->else_instructions;

               /* IF CONDITION */
               ir_expression *const r01E2 = less(r01D9, body.constant(int(32)));
               ir_if *f01E1 = new(mem_ctx) ir_if(operand(r01E2).val);
               exec_list *const f01E1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f01E1->then_instructions;

                  body.emit(assign(r01DA, lshift(r0184, r01DD), 0x01));

                  ir_expression *const r01E3 = lshift(r0183, r01DD);
                  ir_expression *const r01E4 = rshift(r0184, r01D9);
                  body.emit(assign(r01DB, bit_or(r01E3, r01E4), 0x01));

                  body.emit(assign(r01DC, rshift(r0183, r01D9), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f01E1->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r01E6 = equal(r01D9, body.constant(int(32)));
                  ir_if *f01E5 = new(mem_ctx) ir_if(operand(r01E6).val);
                  exec_list *const f01E5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f01E5->then_instructions;

                     body.emit(assign(r01DA, r0184, 0x01));

                     body.emit(assign(r01DB, r0183, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f01E5->else_instructions;

                     body.emit(assign(r01D8, bit_or(r0185, r0184), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r01E8 = less(r01D9, body.constant(int(64)));
                     ir_if *f01E7 = new(mem_ctx) ir_if(operand(r01E8).val);
                     exec_list *const f01E7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f01E7->then_instructions;

                        body.emit(assign(r01DA, lshift(r0183, r01DD), 0x01));

                        ir_expression *const r01E9 = bit_and(r01D9, body.constant(int(31)));
                        body.emit(assign(r01DB, rshift(r0183, r01E9), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f01E7->else_instructions;

                        ir_variable *const r01EA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r01EC = equal(r01D9, body.constant(int(64)));
                        ir_if *f01EB = new(mem_ctx) ir_if(operand(r01EC).val);
                        exec_list *const f01EB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f01EB->then_instructions;

                           body.emit(assign(r01EA, r0183, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f01EB->else_instructions;

                           ir_expression *const r01ED = nequal(r0183, body.constant(0u));
                           ir_expression *const r01EE = expr(ir_unop_b2i, r01ED);
                           body.emit(assign(r01EA, expr(ir_unop_i2u, r01EE), 0x01));


                        body.instructions = f01EB_parent_instructions;
                        body.emit(f01EB);

                        /* END IF */

                        body.emit(assign(r01DA, r01EA, 0x01));

                        body.emit(assign(r01DB, body.constant(0u), 0x01));


                     body.instructions = f01E7_parent_instructions;
                     body.emit(f01E7);

                     /* END IF */


                  body.instructions = f01E5_parent_instructions;
                  body.emit(f01E5);

                  /* END IF */

                  body.emit(assign(r01DC, body.constant(0u), 0x01));


               body.instructions = f01E1_parent_instructions;
               body.emit(f01E1);

               /* END IF */

               ir_expression *const r01EF = nequal(r01D8, body.constant(0u));
               ir_expression *const r01F0 = expr(ir_unop_b2i, r01EF);
               ir_expression *const r01F1 = expr(ir_unop_i2u, r01F0);
               body.emit(assign(r01DA, bit_or(r01DA, r01F1), 0x01));


            body.instructions = f01DF_parent_instructions;
            body.emit(f01DF);

            /* END IF */

            body.emit(assign(r01C2, r01DC, 0x01));

            body.emit(assign(r01C3, r01DB, 0x01));

            body.emit(assign(r01C4, r01DA, 0x01));

            body.emit(assign(r01C1, body.constant(int(0)), 0x01));

            body.emit(assign(r01C7, less(r01DA, body.constant(0u)), 0x01));


         body.instructions = f01D6_parent_instructions;
         body.emit(f01D6);

         /* END IF */


      body.instructions = f01D3_parent_instructions;
      body.emit(f01D3);

      /* END IF */


   body.instructions = f01C9_parent_instructions;
   body.emit(f01C9);

   /* END IF */

   /* IF CONDITION */
   ir_if *f01F2 = new(mem_ctx) ir_if(operand(r01C5).val);
   exec_list *const f01F2_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f01F2->then_instructions;

      /* IF CONDITION */
      ir_if *f01F3 = new(mem_ctx) ir_if(operand(r01C7).val);
      exec_list *const f01F3_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01F3->then_instructions;

         ir_variable *const r01F4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r01F4, add(r01C3, body.constant(1u)), 0x01));

         ir_expression *const r01F5 = less(r01F4, r01C3);
         ir_expression *const r01F6 = expr(ir_unop_b2i, r01F5);
         ir_expression *const r01F7 = expr(ir_unop_i2u, r01F6);
         body.emit(assign(r01C2, add(r01C2, r01F7), 0x01));

         ir_expression *const r01F8 = equal(r01C4, body.constant(0u));
         ir_expression *const r01F9 = expr(ir_unop_b2i, r01F8);
         ir_expression *const r01FA = expr(ir_unop_i2u, r01F9);
         ir_expression *const r01FB = add(r01C4, r01FA);
         ir_expression *const r01FC = bit_and(r01FB, body.constant(1u));
         ir_expression *const r01FD = expr(ir_unop_bit_not, r01FC);
         body.emit(assign(r01C3, bit_and(r01F4, r01FD), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01F3->else_instructions;

         /* IF CONDITION */
         ir_expression *const r01FF = bit_or(r01C2, r01C3);
         ir_expression *const r0200 = equal(r01FF, body.constant(0u));
         ir_if *f01FE = new(mem_ctx) ir_if(operand(r0200).val);
         exec_list *const f01FE_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f01FE->then_instructions;

            body.emit(assign(r01C1, body.constant(int(0)), 0x01));


         body.instructions = f01FE_parent_instructions;
         body.emit(f01FE);

         /* END IF */


      body.instructions = f01F3_parent_instructions;
      body.emit(f01F3);

      /* END IF */

      ir_variable *const r0201 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r0201);
      ir_expression *const r0202 = lshift(r0181, body.constant(int(31)));
      ir_expression *const r0203 = expr(ir_unop_i2u, r01C1);
      ir_expression *const r0204 = lshift(r0203, body.constant(int(20)));
      ir_expression *const r0205 = add(r0202, r0204);
      body.emit(assign(r0201, add(r0205, r01C2), 0x02));

      body.emit(assign(r0201, r01C3, 0x01));

      body.emit(assign(r01C6, r0201, 0x03));

      body.emit(assign(r01C5, body.constant(false), 0x01));


   body.instructions = f01F2_parent_instructions;
   body.emit(f01F2);

   /* END IF */

   body.emit(ret(r01C6));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
propagateFloat64NaN(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0206 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0206);
   ir_variable *const r0207 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0207);
   ir_variable *const r0208 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r0209 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
   ir_expression *const r020A = lshift(swizzle_y(r0206), body.constant(int(1)));
   ir_expression *const r020B = lequal(body.constant(4292870144u), r020A);
   ir_expression *const r020C = nequal(swizzle_x(r0206), body.constant(0u));
   ir_expression *const r020D = bit_and(swizzle_y(r0206), body.constant(1048575u));
   ir_expression *const r020E = nequal(r020D, body.constant(0u));
   ir_expression *const r020F = logic_or(r020C, r020E);
   body.emit(assign(r0209, logic_and(r020B, r020F), 0x01));

   ir_variable *const r0210 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
   ir_expression *const r0211 = rshift(swizzle_y(r0206), body.constant(int(19)));
   ir_expression *const r0212 = bit_and(r0211, body.constant(4095u));
   ir_expression *const r0213 = equal(r0212, body.constant(4094u));
   ir_expression *const r0214 = nequal(swizzle_x(r0206), body.constant(0u));
   ir_expression *const r0215 = bit_and(swizzle_y(r0206), body.constant(524287u));
   ir_expression *const r0216 = nequal(r0215, body.constant(0u));
   ir_expression *const r0217 = logic_or(r0214, r0216);
   body.emit(assign(r0210, logic_and(r0213, r0217), 0x01));

   ir_variable *const r0218 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
   ir_expression *const r0219 = lshift(swizzle_y(r0207), body.constant(int(1)));
   ir_expression *const r021A = lequal(body.constant(4292870144u), r0219);
   ir_expression *const r021B = nequal(swizzle_x(r0207), body.constant(0u));
   ir_expression *const r021C = bit_and(swizzle_y(r0207), body.constant(1048575u));
   ir_expression *const r021D = nequal(r021C, body.constant(0u));
   ir_expression *const r021E = logic_or(r021B, r021D);
   body.emit(assign(r0218, logic_and(r021A, r021E), 0x01));

   body.emit(assign(r0206, bit_or(swizzle_y(r0206), body.constant(524288u)), 0x02));

   body.emit(assign(r0207, bit_or(swizzle_y(r0207), body.constant(524288u)), 0x02));

   /* IF CONDITION */
   ir_if *f021F = new(mem_ctx) ir_if(operand(r0209).val);
   exec_list *const f021F_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f021F->then_instructions;

      ir_variable *const r0220 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r0222 = logic_and(r0210, r0218);
      ir_if *f0221 = new(mem_ctx) ir_if(operand(r0222).val);
      exec_list *const f0221_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0221->then_instructions;

         body.emit(assign(r0220, r0207, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0221->else_instructions;

         body.emit(assign(r0220, r0206, 0x03));


      body.instructions = f0221_parent_instructions;
      body.emit(f0221);

      /* END IF */

      body.emit(assign(r0208, r0220, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f021F->else_instructions;

      body.emit(assign(r0208, r0207, 0x03));


   body.instructions = f021F_parent_instructions;
   body.emit(f021F);

   /* END IF */

   body.emit(ret(r0208));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
addFloat64Fracs(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0223 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0223);
   ir_variable *const r0224 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0224);
   ir_variable *const r0225 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r0225);
   ir_variable *const r0226 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r0226, body.constant(true), 0x01));

   ir_variable *const r0227 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r0228 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
   body.emit(r0228);
   ir_variable *const r0229 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
   body.emit(r0229);
   ir_variable *const r022A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
   body.emit(r022A);
   ir_variable *const r022B = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r022B);
   ir_variable *const r022C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
   body.emit(r022C);
   ir_variable *const r022D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r022D);
   body.emit(assign(r022D, body.constant(0u), 0x01));

   body.emit(assign(r022C, body.constant(0u), 0x01));

   ir_variable *const r022E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r022E);
   body.emit(assign(r022E, bit_and(swizzle_y(r0223), body.constant(1048575u)), 0x02));

   body.emit(assign(r022E, swizzle_x(r0223), 0x01));

   body.emit(assign(r022A, r022E, 0x03));

   ir_variable *const r022F = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r0230 = rshift(swizzle_y(r0223), body.constant(int(20)));
   ir_expression *const r0231 = bit_and(r0230, body.constant(2047u));
   body.emit(assign(r022F, expr(ir_unop_u2i, r0231), 0x01));

   ir_variable *const r0232 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r0232);
   body.emit(assign(r0232, bit_and(swizzle_y(r0224), body.constant(1048575u)), 0x02));

   body.emit(assign(r0232, swizzle_x(r0224), 0x01));

   body.emit(assign(r0229, r0232, 0x03));

   ir_variable *const r0233 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r0234 = rshift(swizzle_y(r0224), body.constant(int(20)));
   ir_expression *const r0235 = bit_and(r0234, body.constant(2047u));
   body.emit(assign(r0233, expr(ir_unop_u2i, r0235), 0x01));

   ir_variable *const r0236 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   body.emit(assign(r0236, sub(r022F, r0233), 0x01));

   body.emit(assign(r0228, r0236, 0x01));

   /* IF CONDITION */
   ir_expression *const r0238 = less(body.constant(int(0)), r0236);
   ir_if *f0237 = new(mem_ctx) ir_if(operand(r0238).val);
   exec_list *const f0237_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0237->then_instructions;

      /* IF CONDITION */
      ir_expression *const r023A = equal(r022F, body.constant(int(2047)));
      ir_if *f0239 = new(mem_ctx) ir_if(operand(r023A).val);
      exec_list *const f0239_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0239->then_instructions;

         /* IF CONDITION */
         ir_expression *const r023C = bit_or(swizzle_y(r022E), swizzle_x(r0223));
         ir_expression *const r023D = nequal(r023C, body.constant(0u));
         ir_if *f023B = new(mem_ctx) ir_if(operand(r023D).val);
         exec_list *const f023B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f023B->then_instructions;

            ir_variable *const r023E = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r023E, swizzle_x(r0223), 0x01));

            ir_variable *const r023F = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r023F, swizzle_x(r0224), 0x01));

            ir_variable *const r0240 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0241 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r0242 = rshift(swizzle_y(r0223), body.constant(int(19)));
            ir_expression *const r0243 = bit_and(r0242, body.constant(4095u));
            ir_expression *const r0244 = equal(r0243, body.constant(4094u));
            ir_expression *const r0245 = nequal(swizzle_x(r0223), body.constant(0u));
            ir_expression *const r0246 = bit_and(swizzle_y(r0223), body.constant(524287u));
            ir_expression *const r0247 = nequal(r0246, body.constant(0u));
            ir_expression *const r0248 = logic_or(r0245, r0247);
            body.emit(assign(r0241, logic_and(r0244, r0248), 0x01));

            ir_variable *const r0249 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r024A = lshift(swizzle_y(r0224), body.constant(int(1)));
            ir_expression *const r024B = lequal(body.constant(4292870144u), r024A);
            ir_expression *const r024C = nequal(swizzle_x(r0224), body.constant(0u));
            ir_expression *const r024D = bit_and(swizzle_y(r0224), body.constant(1048575u));
            ir_expression *const r024E = nequal(r024D, body.constant(0u));
            ir_expression *const r024F = logic_or(r024C, r024E);
            body.emit(assign(r0249, logic_and(r024B, r024F), 0x01));

            body.emit(assign(r023E, bit_or(swizzle_y(r0223), body.constant(524288u)), 0x02));

            body.emit(assign(r023F, bit_or(swizzle_y(r0224), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r0251 = lshift(swizzle_y(r0223), body.constant(int(1)));
            ir_expression *const r0252 = lequal(body.constant(4292870144u), r0251);
            ir_expression *const r0253 = nequal(swizzle_x(r0223), body.constant(0u));
            ir_expression *const r0254 = bit_and(swizzle_y(r0223), body.constant(1048575u));
            ir_expression *const r0255 = nequal(r0254, body.constant(0u));
            ir_expression *const r0256 = logic_or(r0253, r0255);
            ir_expression *const r0257 = logic_and(r0252, r0256);
            ir_if *f0250 = new(mem_ctx) ir_if(operand(r0257).val);
            exec_list *const f0250_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0250->then_instructions;

               ir_variable *const r0258 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r025A = logic_and(r0241, r0249);
               ir_if *f0259 = new(mem_ctx) ir_if(operand(r025A).val);
               exec_list *const f0259_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0259->then_instructions;

                  body.emit(assign(r0258, r023F, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0259->else_instructions;

                  body.emit(assign(r0258, r023E, 0x03));


               body.instructions = f0259_parent_instructions;
               body.emit(f0259);

               /* END IF */

               body.emit(assign(r0240, r0258, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0250->else_instructions;

               body.emit(assign(r0240, r023F, 0x03));


            body.instructions = f0250_parent_instructions;
            body.emit(f0250);

            /* END IF */

            body.emit(assign(r0227, r0240, 0x03));

            body.emit(assign(r0226, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f023B->else_instructions;

            body.emit(assign(r0227, r0223, 0x03));

            body.emit(assign(r0226, body.constant(false), 0x01));


         body.instructions = f023B_parent_instructions;
         body.emit(f023B);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0239->else_instructions;

         /* IF CONDITION */
         ir_expression *const r025C = equal(r0233, body.constant(int(0)));
         ir_if *f025B = new(mem_ctx) ir_if(operand(r025C).val);
         exec_list *const f025B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f025B->then_instructions;

            body.emit(assign(r0228, add(r0236, body.constant(int(-1))), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f025B->else_instructions;

            body.emit(assign(r0229, bit_or(swizzle_y(r0232), body.constant(1048576u)), 0x02));


         body.instructions = f025B_parent_instructions;
         body.emit(f025B);

         /* END IF */

         ir_variable *const r025D = body.make_temp(glsl_type::uint_type, "a0");
         body.emit(assign(r025D, swizzle_y(r0229), 0x01));

         ir_variable *const r025E = body.make_temp(glsl_type::uint_type, "a1");
         body.emit(assign(r025E, swizzle_x(r0229), 0x01));

         ir_variable *const r025F = body.make_temp(glsl_type::uint_type, "a2");
         body.emit(assign(r025F, body.constant(0u), 0x01));

         ir_variable *const r0260 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
         body.emit(r0260);
         ir_variable *const r0261 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r0261);
         ir_variable *const r0262 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r0262);
         ir_variable *const r0263 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         ir_expression *const r0264 = neg(r0228);
         body.emit(assign(r0263, bit_and(r0264, body.constant(int(31))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0266 = equal(r0228, body.constant(int(0)));
         ir_if *f0265 = new(mem_ctx) ir_if(operand(r0266).val);
         exec_list *const f0265_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0265->then_instructions;

            body.emit(assign(r0260, r025F, 0x01));

            body.emit(assign(r0261, r025E, 0x01));

            body.emit(assign(r0262, r025D, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0265->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0268 = less(r0228, body.constant(int(32)));
            ir_if *f0267 = new(mem_ctx) ir_if(operand(r0268).val);
            exec_list *const f0267_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0267->then_instructions;

               body.emit(assign(r0260, lshift(swizzle_x(r0232), r0263), 0x01));

               ir_expression *const r0269 = lshift(swizzle_y(r0229), r0263);
               ir_expression *const r026A = rshift(swizzle_x(r0232), r0228);
               body.emit(assign(r0261, bit_or(r0269, r026A), 0x01));

               body.emit(assign(r0262, rshift(swizzle_y(r0229), r0228), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0267->else_instructions;

               /* IF CONDITION */
               ir_expression *const r026C = equal(r0228, body.constant(int(32)));
               ir_if *f026B = new(mem_ctx) ir_if(operand(r026C).val);
               exec_list *const f026B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f026B->then_instructions;

                  body.emit(assign(r0260, r025E, 0x01));

                  body.emit(assign(r0261, r025D, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f026B->else_instructions;

                  body.emit(assign(r025F, bit_or(body.constant(0u), swizzle_x(r0232)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r026E = less(r0228, body.constant(int(64)));
                  ir_if *f026D = new(mem_ctx) ir_if(operand(r026E).val);
                  exec_list *const f026D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f026D->then_instructions;

                     body.emit(assign(r0260, lshift(swizzle_y(r0229), r0263), 0x01));

                     ir_expression *const r026F = bit_and(r0228, body.constant(int(31)));
                     body.emit(assign(r0261, rshift(swizzle_y(r0229), r026F), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f026D->else_instructions;

                     ir_variable *const r0270 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0272 = equal(r0228, body.constant(int(64)));
                     ir_if *f0271 = new(mem_ctx) ir_if(operand(r0272).val);
                     exec_list *const f0271_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0271->then_instructions;

                        body.emit(assign(r0270, r025D, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0271->else_instructions;

                        ir_expression *const r0273 = nequal(swizzle_y(r0229), body.constant(0u));
                        ir_expression *const r0274 = expr(ir_unop_b2i, r0273);
                        body.emit(assign(r0270, expr(ir_unop_i2u, r0274), 0x01));


                     body.instructions = f0271_parent_instructions;
                     body.emit(f0271);

                     /* END IF */

                     body.emit(assign(r0260, r0270, 0x01));

                     body.emit(assign(r0261, body.constant(0u), 0x01));


                  body.instructions = f026D_parent_instructions;
                  body.emit(f026D);

                  /* END IF */


               body.instructions = f026B_parent_instructions;
               body.emit(f026B);

               /* END IF */

               body.emit(assign(r0262, body.constant(0u), 0x01));


            body.instructions = f0267_parent_instructions;
            body.emit(f0267);

            /* END IF */

            ir_expression *const r0275 = nequal(r025F, body.constant(0u));
            ir_expression *const r0276 = expr(ir_unop_b2i, r0275);
            ir_expression *const r0277 = expr(ir_unop_i2u, r0276);
            body.emit(assign(r0260, bit_or(r0260, r0277), 0x01));


         body.instructions = f0265_parent_instructions;
         body.emit(f0265);

         /* END IF */

         body.emit(assign(r0229, r0262, 0x02));

         body.emit(assign(r0229, r0261, 0x01));

         body.emit(assign(r022C, r0260, 0x01));

         body.emit(assign(r022B, r022F, 0x01));


      body.instructions = f0239_parent_instructions;
      body.emit(f0239);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0237->else_instructions;

      /* IF CONDITION */
      ir_expression *const r0279 = less(r0228, body.constant(int(0)));
      ir_if *f0278 = new(mem_ctx) ir_if(operand(r0279).val);
      exec_list *const f0278_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0278->then_instructions;

         /* IF CONDITION */
         ir_expression *const r027B = equal(r0233, body.constant(int(2047)));
         ir_if *f027A = new(mem_ctx) ir_if(operand(r027B).val);
         exec_list *const f027A_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f027A->then_instructions;

            /* IF CONDITION */
            ir_expression *const r027D = bit_or(swizzle_y(r0229), swizzle_x(r0229));
            ir_expression *const r027E = nequal(r027D, body.constant(0u));
            ir_if *f027C = new(mem_ctx) ir_if(operand(r027E).val);
            exec_list *const f027C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f027C->then_instructions;

               ir_variable *const r027F = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r027F, swizzle_x(r0223), 0x01));

               ir_variable *const r0280 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r0280, swizzle_x(r0224), 0x01));

               ir_variable *const r0281 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0282 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r0283 = rshift(swizzle_y(r0223), body.constant(int(19)));
               ir_expression *const r0284 = bit_and(r0283, body.constant(4095u));
               ir_expression *const r0285 = equal(r0284, body.constant(4094u));
               ir_expression *const r0286 = nequal(swizzle_x(r0223), body.constant(0u));
               ir_expression *const r0287 = bit_and(swizzle_y(r0223), body.constant(524287u));
               ir_expression *const r0288 = nequal(r0287, body.constant(0u));
               ir_expression *const r0289 = logic_or(r0286, r0288);
               body.emit(assign(r0282, logic_and(r0285, r0289), 0x01));

               ir_variable *const r028A = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r028B = lshift(swizzle_y(r0224), body.constant(int(1)));
               ir_expression *const r028C = lequal(body.constant(4292870144u), r028B);
               ir_expression *const r028D = nequal(swizzle_x(r0224), body.constant(0u));
               ir_expression *const r028E = bit_and(swizzle_y(r0224), body.constant(1048575u));
               ir_expression *const r028F = nequal(r028E, body.constant(0u));
               ir_expression *const r0290 = logic_or(r028D, r028F);
               body.emit(assign(r028A, logic_and(r028C, r0290), 0x01));

               body.emit(assign(r027F, bit_or(swizzle_y(r0223), body.constant(524288u)), 0x02));

               body.emit(assign(r0280, bit_or(swizzle_y(r0224), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r0292 = lshift(swizzle_y(r0223), body.constant(int(1)));
               ir_expression *const r0293 = lequal(body.constant(4292870144u), r0292);
               ir_expression *const r0294 = nequal(swizzle_x(r0223), body.constant(0u));
               ir_expression *const r0295 = bit_and(swizzle_y(r0223), body.constant(1048575u));
               ir_expression *const r0296 = nequal(r0295, body.constant(0u));
               ir_expression *const r0297 = logic_or(r0294, r0296);
               ir_expression *const r0298 = logic_and(r0293, r0297);
               ir_if *f0291 = new(mem_ctx) ir_if(operand(r0298).val);
               exec_list *const f0291_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0291->then_instructions;

                  ir_variable *const r0299 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r029B = logic_and(r0282, r028A);
                  ir_if *f029A = new(mem_ctx) ir_if(operand(r029B).val);
                  exec_list *const f029A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f029A->then_instructions;

                     body.emit(assign(r0299, r0280, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f029A->else_instructions;

                     body.emit(assign(r0299, r027F, 0x03));


                  body.instructions = f029A_parent_instructions;
                  body.emit(f029A);

                  /* END IF */

                  body.emit(assign(r0281, r0299, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0291->else_instructions;

                  body.emit(assign(r0281, r0280, 0x03));


               body.instructions = f0291_parent_instructions;
               body.emit(f0291);

               /* END IF */

               body.emit(assign(r0227, r0281, 0x03));

               body.emit(assign(r0226, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f027C->else_instructions;

               ir_variable *const r029C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r029C);
               ir_expression *const r029D = lshift(r0225, body.constant(int(31)));
               body.emit(assign(r029C, add(r029D, body.constant(2146435072u)), 0x02));

               body.emit(assign(r029C, body.constant(0u), 0x01));

               body.emit(assign(r0227, r029C, 0x03));

               body.emit(assign(r0226, body.constant(false), 0x01));


            body.instructions = f027C_parent_instructions;
            body.emit(f027C);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f027A->else_instructions;

            /* IF CONDITION */
            ir_expression *const r029F = equal(r022F, body.constant(int(0)));
            ir_if *f029E = new(mem_ctx) ir_if(operand(r029F).val);
            exec_list *const f029E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f029E->then_instructions;

               body.emit(assign(r0228, add(r0228, body.constant(int(1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f029E->else_instructions;

               body.emit(assign(r022A, bit_or(swizzle_y(r022E), body.constant(1048576u)), 0x02));


            body.instructions = f029E_parent_instructions;
            body.emit(f029E);

            /* END IF */

            ir_variable *const r02A0 = body.make_temp(glsl_type::uint_type, "a0");
            body.emit(assign(r02A0, swizzle_y(r022A), 0x01));

            ir_variable *const r02A1 = body.make_temp(glsl_type::uint_type, "a1");
            body.emit(assign(r02A1, swizzle_x(r022A), 0x01));

            ir_variable *const r02A2 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r02A2, body.constant(0u), 0x01));

            ir_variable *const r02A3 = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r02A3, neg(r0228), 0x01));

            ir_variable *const r02A4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r02A4);
            ir_variable *const r02A5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r02A5);
            ir_variable *const r02A6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r02A6);
            ir_variable *const r02A7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r02A8 = neg(r02A3);
            body.emit(assign(r02A7, bit_and(r02A8, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r02AA = equal(r02A3, body.constant(int(0)));
            ir_if *f02A9 = new(mem_ctx) ir_if(operand(r02AA).val);
            exec_list *const f02A9_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f02A9->then_instructions;

               body.emit(assign(r02A4, r02A2, 0x01));

               body.emit(assign(r02A5, r02A1, 0x01));

               body.emit(assign(r02A6, r02A0, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f02A9->else_instructions;

               /* IF CONDITION */
               ir_expression *const r02AC = less(r02A3, body.constant(int(32)));
               ir_if *f02AB = new(mem_ctx) ir_if(operand(r02AC).val);
               exec_list *const f02AB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f02AB->then_instructions;

                  body.emit(assign(r02A4, lshift(swizzle_x(r022E), r02A7), 0x01));

                  ir_expression *const r02AD = lshift(swizzle_y(r022A), r02A7);
                  ir_expression *const r02AE = rshift(swizzle_x(r022E), r02A3);
                  body.emit(assign(r02A5, bit_or(r02AD, r02AE), 0x01));

                  body.emit(assign(r02A6, rshift(swizzle_y(r022A), r02A3), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f02AB->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r02B0 = equal(r02A3, body.constant(int(32)));
                  ir_if *f02AF = new(mem_ctx) ir_if(operand(r02B0).val);
                  exec_list *const f02AF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f02AF->then_instructions;

                     body.emit(assign(r02A4, r02A1, 0x01));

                     body.emit(assign(r02A5, r02A0, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f02AF->else_instructions;

                     body.emit(assign(r02A2, bit_or(body.constant(0u), swizzle_x(r022E)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r02B2 = less(r02A3, body.constant(int(64)));
                     ir_if *f02B1 = new(mem_ctx) ir_if(operand(r02B2).val);
                     exec_list *const f02B1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f02B1->then_instructions;

                        body.emit(assign(r02A4, lshift(swizzle_y(r022A), r02A7), 0x01));

                        ir_expression *const r02B3 = bit_and(r02A3, body.constant(int(31)));
                        body.emit(assign(r02A5, rshift(swizzle_y(r022A), r02B3), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f02B1->else_instructions;

                        ir_variable *const r02B4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r02B6 = equal(r02A3, body.constant(int(64)));
                        ir_if *f02B5 = new(mem_ctx) ir_if(operand(r02B6).val);
                        exec_list *const f02B5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f02B5->then_instructions;

                           body.emit(assign(r02B4, r02A0, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f02B5->else_instructions;

                           ir_expression *const r02B7 = nequal(swizzle_y(r022A), body.constant(0u));
                           ir_expression *const r02B8 = expr(ir_unop_b2i, r02B7);
                           body.emit(assign(r02B4, expr(ir_unop_i2u, r02B8), 0x01));


                        body.instructions = f02B5_parent_instructions;
                        body.emit(f02B5);

                        /* END IF */

                        body.emit(assign(r02A4, r02B4, 0x01));

                        body.emit(assign(r02A5, body.constant(0u), 0x01));


                     body.instructions = f02B1_parent_instructions;
                     body.emit(f02B1);

                     /* END IF */


                  body.instructions = f02AF_parent_instructions;
                  body.emit(f02AF);

                  /* END IF */

                  body.emit(assign(r02A6, body.constant(0u), 0x01));


               body.instructions = f02AB_parent_instructions;
               body.emit(f02AB);

               /* END IF */

               ir_expression *const r02B9 = nequal(r02A2, body.constant(0u));
               ir_expression *const r02BA = expr(ir_unop_b2i, r02B9);
               ir_expression *const r02BB = expr(ir_unop_i2u, r02BA);
               body.emit(assign(r02A4, bit_or(r02A4, r02BB), 0x01));


            body.instructions = f02A9_parent_instructions;
            body.emit(f02A9);

            /* END IF */

            body.emit(assign(r022A, r02A6, 0x02));

            body.emit(assign(r022A, r02A5, 0x01));

            body.emit(assign(r022C, r02A4, 0x01));

            body.emit(assign(r022B, r0233, 0x01));


         body.instructions = f027A_parent_instructions;
         body.emit(f027A);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0278->else_instructions;

         /* IF CONDITION */
         ir_expression *const r02BD = equal(r022F, body.constant(int(2047)));
         ir_if *f02BC = new(mem_ctx) ir_if(operand(r02BD).val);
         exec_list *const f02BC_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f02BC->then_instructions;

            /* IF CONDITION */
            ir_expression *const r02BF = bit_or(swizzle_y(r022A), swizzle_x(r022A));
            ir_expression *const r02C0 = bit_or(swizzle_y(r0229), swizzle_x(r0229));
            ir_expression *const r02C1 = bit_or(r02BF, r02C0);
            ir_expression *const r02C2 = nequal(r02C1, body.constant(0u));
            ir_if *f02BE = new(mem_ctx) ir_if(operand(r02C2).val);
            exec_list *const f02BE_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f02BE->then_instructions;

               ir_variable *const r02C3 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r02C3, swizzle_x(r0223), 0x01));

               ir_variable *const r02C4 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r02C4, swizzle_x(r0224), 0x01));

               ir_variable *const r02C5 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r02C6 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r02C7 = rshift(swizzle_y(r0223), body.constant(int(19)));
               ir_expression *const r02C8 = bit_and(r02C7, body.constant(4095u));
               ir_expression *const r02C9 = equal(r02C8, body.constant(4094u));
               ir_expression *const r02CA = nequal(swizzle_x(r0223), body.constant(0u));
               ir_expression *const r02CB = bit_and(swizzle_y(r0223), body.constant(524287u));
               ir_expression *const r02CC = nequal(r02CB, body.constant(0u));
               ir_expression *const r02CD = logic_or(r02CA, r02CC);
               body.emit(assign(r02C6, logic_and(r02C9, r02CD), 0x01));

               ir_variable *const r02CE = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r02CF = lshift(swizzle_y(r0224), body.constant(int(1)));
               ir_expression *const r02D0 = lequal(body.constant(4292870144u), r02CF);
               ir_expression *const r02D1 = nequal(swizzle_x(r0224), body.constant(0u));
               ir_expression *const r02D2 = bit_and(swizzle_y(r0224), body.constant(1048575u));
               ir_expression *const r02D3 = nequal(r02D2, body.constant(0u));
               ir_expression *const r02D4 = logic_or(r02D1, r02D3);
               body.emit(assign(r02CE, logic_and(r02D0, r02D4), 0x01));

               body.emit(assign(r02C3, bit_or(swizzle_y(r0223), body.constant(524288u)), 0x02));

               body.emit(assign(r02C4, bit_or(swizzle_y(r0224), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r02D6 = lshift(swizzle_y(r0223), body.constant(int(1)));
               ir_expression *const r02D7 = lequal(body.constant(4292870144u), r02D6);
               ir_expression *const r02D8 = nequal(swizzle_x(r0223), body.constant(0u));
               ir_expression *const r02D9 = bit_and(swizzle_y(r0223), body.constant(1048575u));
               ir_expression *const r02DA = nequal(r02D9, body.constant(0u));
               ir_expression *const r02DB = logic_or(r02D8, r02DA);
               ir_expression *const r02DC = logic_and(r02D7, r02DB);
               ir_if *f02D5 = new(mem_ctx) ir_if(operand(r02DC).val);
               exec_list *const f02D5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f02D5->then_instructions;

                  ir_variable *const r02DD = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r02DF = logic_and(r02C6, r02CE);
                  ir_if *f02DE = new(mem_ctx) ir_if(operand(r02DF).val);
                  exec_list *const f02DE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f02DE->then_instructions;

                     body.emit(assign(r02DD, r02C4, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f02DE->else_instructions;

                     body.emit(assign(r02DD, r02C3, 0x03));


                  body.instructions = f02DE_parent_instructions;
                  body.emit(f02DE);

                  /* END IF */

                  body.emit(assign(r02C5, r02DD, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f02D5->else_instructions;

                  body.emit(assign(r02C5, r02C4, 0x03));


               body.instructions = f02D5_parent_instructions;
               body.emit(f02D5);

               /* END IF */

               body.emit(assign(r0227, r02C5, 0x03));

               body.emit(assign(r0226, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f02BE->else_instructions;

               body.emit(assign(r0227, r0223, 0x03));

               body.emit(assign(r0226, body.constant(false), 0x01));


            body.instructions = f02BE_parent_instructions;
            body.emit(f02BE);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f02BC->else_instructions;

            ir_variable *const r02E0 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r02E1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r02E1, add(swizzle_x(r022A), swizzle_x(r0229)), 0x01));

            ir_expression *const r02E2 = add(swizzle_y(r022A), swizzle_y(r0229));
            ir_expression *const r02E3 = less(r02E1, swizzle_x(r022A));
            ir_expression *const r02E4 = expr(ir_unop_b2i, r02E3);
            ir_expression *const r02E5 = expr(ir_unop_i2u, r02E4);
            body.emit(assign(r02E0, add(r02E2, r02E5), 0x01));

            body.emit(assign(r022D, r02E0, 0x01));

            /* IF CONDITION */
            ir_expression *const r02E7 = equal(r022F, body.constant(int(0)));
            ir_if *f02E6 = new(mem_ctx) ir_if(operand(r02E7).val);
            exec_list *const f02E6_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f02E6->then_instructions;

               ir_variable *const r02E8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r02E8);
               ir_expression *const r02E9 = lshift(r0225, body.constant(int(31)));
               body.emit(assign(r02E8, add(r02E9, r02E0), 0x02));

               body.emit(assign(r02E8, r02E1, 0x01));

               body.emit(assign(r0227, r02E8, 0x03));

               body.emit(assign(r0226, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f02E6->else_instructions;

               body.emit(assign(r022D, bit_or(r02E0, body.constant(2097152u)), 0x01));

               body.emit(assign(r022B, r022F, 0x01));

               ir_variable *const r02EA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r02EA);
               ir_variable *const r02EB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r02EB);
               ir_variable *const r02EC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r02EC);
               body.emit(assign(r02EA, lshift(r02E1, body.constant(int(31))), 0x01));

               ir_expression *const r02ED = lshift(r022D, body.constant(int(31)));
               ir_expression *const r02EE = rshift(r02E1, body.constant(int(1)));
               body.emit(assign(r02EB, bit_or(r02ED, r02EE), 0x01));

               body.emit(assign(r02EC, rshift(r022D, body.constant(int(1))), 0x01));

               body.emit(assign(r02EA, bit_or(r02EA, body.constant(0u)), 0x01));

               body.emit(assign(r022D, r02EC, 0x01));

               body.emit(assign(r022C, r02EA, 0x01));

               ir_variable *const r02EF = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r02EF, r022F, 0x01));

               ir_variable *const r02F0 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r02F0, r02EC, 0x01));

               ir_variable *const r02F1 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r02F1, r02EB, 0x01));

               ir_variable *const r02F2 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r02F2, r02EA, 0x01));

               ir_variable *const r02F3 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r02F3, body.constant(true), 0x01));

               ir_variable *const r02F4 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r02F5 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r02F5);
               ir_expression *const r02F6 = expr(ir_unop_u2i, r02EA);
               body.emit(assign(r02F5, less(r02F6, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r02F8 = lequal(body.constant(int(2045)), r022F);
               ir_if *f02F7 = new(mem_ctx) ir_if(operand(r02F8).val);
               exec_list *const f02F7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f02F7->then_instructions;

                  ir_variable *const r02F9 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r02FB = less(body.constant(int(2045)), r022F);
                  ir_if *f02FA = new(mem_ctx) ir_if(operand(r02FB).val);
                  exec_list *const f02FA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f02FA->then_instructions;

                     body.emit(assign(r02F9, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f02FA->else_instructions;

                     ir_variable *const r02FC = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r02FE = equal(r022F, body.constant(int(2045)));
                     ir_if *f02FD = new(mem_ctx) ir_if(operand(r02FE).val);
                     exec_list *const f02FD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f02FD->then_instructions;

                        ir_expression *const r02FF = equal(body.constant(2097151u), r02EC);
                        ir_expression *const r0300 = equal(body.constant(4294967295u), r02EB);
                        body.emit(assign(r02FC, logic_and(r02FF, r0300), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f02FD->else_instructions;

                        body.emit(assign(r02FC, body.constant(false), 0x01));


                     body.instructions = f02FD_parent_instructions;
                     body.emit(f02FD);

                     /* END IF */

                     body.emit(assign(r02F9, logic_and(r02FC, r02F5), 0x01));


                  body.instructions = f02FA_parent_instructions;
                  body.emit(f02FA);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0301 = new(mem_ctx) ir_if(operand(r02F9).val);
                  exec_list *const f0301_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0301->then_instructions;

                     ir_variable *const r0302 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0302);
                     ir_expression *const r0303 = lshift(r0225, body.constant(int(31)));
                     body.emit(assign(r0302, add(r0303, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r0302, body.constant(0u), 0x01));

                     body.emit(assign(r02F4, r0302, 0x03));

                     body.emit(assign(r02F3, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0301->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0305 = less(r022F, body.constant(int(0)));
                     ir_if *f0304 = new(mem_ctx) ir_if(operand(r0305).val);
                     exec_list *const f0304_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0304->then_instructions;

                        ir_variable *const r0306 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0306, r02EA, 0x01));

                        ir_variable *const r0307 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0307, neg(r022F), 0x01));

                        ir_variable *const r0308 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0308);
                        ir_variable *const r0309 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0309);
                        ir_variable *const r030A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r030A);
                        ir_variable *const r030B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r030C = neg(r0307);
                        body.emit(assign(r030B, bit_and(r030C, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r030E = equal(r0307, body.constant(int(0)));
                        ir_if *f030D = new(mem_ctx) ir_if(operand(r030E).val);
                        exec_list *const f030D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f030D->then_instructions;

                           body.emit(assign(r0308, r02EA, 0x01));

                           body.emit(assign(r0309, r02EB, 0x01));

                           body.emit(assign(r030A, r02EC, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f030D->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0310 = less(r0307, body.constant(int(32)));
                           ir_if *f030F = new(mem_ctx) ir_if(operand(r0310).val);
                           exec_list *const f030F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f030F->then_instructions;

                              body.emit(assign(r0308, lshift(r02EB, r030B), 0x01));

                              ir_expression *const r0311 = lshift(r02EC, r030B);
                              ir_expression *const r0312 = rshift(r02EB, r0307);
                              body.emit(assign(r0309, bit_or(r0311, r0312), 0x01));

                              body.emit(assign(r030A, rshift(r02EC, r0307), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f030F->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0314 = equal(r0307, body.constant(int(32)));
                              ir_if *f0313 = new(mem_ctx) ir_if(operand(r0314).val);
                              exec_list *const f0313_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0313->then_instructions;

                                 body.emit(assign(r0308, r02EB, 0x01));

                                 body.emit(assign(r0309, r02EC, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0313->else_instructions;

                                 body.emit(assign(r0306, bit_or(r02EA, r02EB), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0316 = less(r0307, body.constant(int(64)));
                                 ir_if *f0315 = new(mem_ctx) ir_if(operand(r0316).val);
                                 exec_list *const f0315_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0315->then_instructions;

                                    body.emit(assign(r0308, lshift(r02EC, r030B), 0x01));

                                    ir_expression *const r0317 = bit_and(r0307, body.constant(int(31)));
                                    body.emit(assign(r0309, rshift(r02EC, r0317), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0315->else_instructions;

                                    ir_variable *const r0318 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r031A = equal(r0307, body.constant(int(64)));
                                    ir_if *f0319 = new(mem_ctx) ir_if(operand(r031A).val);
                                    exec_list *const f0319_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0319->then_instructions;

                                       body.emit(assign(r0318, r02EC, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0319->else_instructions;

                                       ir_expression *const r031B = nequal(r02EC, body.constant(0u));
                                       ir_expression *const r031C = expr(ir_unop_b2i, r031B);
                                       body.emit(assign(r0318, expr(ir_unop_i2u, r031C), 0x01));


                                    body.instructions = f0319_parent_instructions;
                                    body.emit(f0319);

                                    /* END IF */

                                    body.emit(assign(r0308, r0318, 0x01));

                                    body.emit(assign(r0309, body.constant(0u), 0x01));


                                 body.instructions = f0315_parent_instructions;
                                 body.emit(f0315);

                                 /* END IF */


                              body.instructions = f0313_parent_instructions;
                              body.emit(f0313);

                              /* END IF */

                              body.emit(assign(r030A, body.constant(0u), 0x01));


                           body.instructions = f030F_parent_instructions;
                           body.emit(f030F);

                           /* END IF */

                           ir_expression *const r031D = nequal(r0306, body.constant(0u));
                           ir_expression *const r031E = expr(ir_unop_b2i, r031D);
                           ir_expression *const r031F = expr(ir_unop_i2u, r031E);
                           body.emit(assign(r0308, bit_or(r0308, r031F), 0x01));


                        body.instructions = f030D_parent_instructions;
                        body.emit(f030D);

                        /* END IF */

                        body.emit(assign(r02F0, r030A, 0x01));

                        body.emit(assign(r02F1, r0309, 0x01));

                        body.emit(assign(r02F2, r0308, 0x01));

                        body.emit(assign(r02EF, body.constant(int(0)), 0x01));

                        body.emit(assign(r02F5, less(r0308, body.constant(0u)), 0x01));


                     body.instructions = f0304_parent_instructions;
                     body.emit(f0304);

                     /* END IF */


                  body.instructions = f0301_parent_instructions;
                  body.emit(f0301);

                  /* END IF */


               body.instructions = f02F7_parent_instructions;
               body.emit(f02F7);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0320 = new(mem_ctx) ir_if(operand(r02F3).val);
               exec_list *const f0320_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0320->then_instructions;

                  /* IF CONDITION */
                  ir_if *f0321 = new(mem_ctx) ir_if(operand(r02F5).val);
                  exec_list *const f0321_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0321->then_instructions;

                     ir_variable *const r0322 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r0322, add(r02F1, body.constant(1u)), 0x01));

                     ir_expression *const r0323 = less(r0322, r02F1);
                     ir_expression *const r0324 = expr(ir_unop_b2i, r0323);
                     ir_expression *const r0325 = expr(ir_unop_i2u, r0324);
                     body.emit(assign(r02F0, add(r02F0, r0325), 0x01));

                     ir_expression *const r0326 = equal(r02F2, body.constant(0u));
                     ir_expression *const r0327 = expr(ir_unop_b2i, r0326);
                     ir_expression *const r0328 = expr(ir_unop_i2u, r0327);
                     ir_expression *const r0329 = add(r02F2, r0328);
                     ir_expression *const r032A = bit_and(r0329, body.constant(1u));
                     ir_expression *const r032B = expr(ir_unop_bit_not, r032A);
                     body.emit(assign(r02F1, bit_and(r0322, r032B), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0321->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r032D = bit_or(r02F0, r02F1);
                     ir_expression *const r032E = equal(r032D, body.constant(0u));
                     ir_if *f032C = new(mem_ctx) ir_if(operand(r032E).val);
                     exec_list *const f032C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f032C->then_instructions;

                        body.emit(assign(r02EF, body.constant(int(0)), 0x01));


                     body.instructions = f032C_parent_instructions;
                     body.emit(f032C);

                     /* END IF */


                  body.instructions = f0321_parent_instructions;
                  body.emit(f0321);

                  /* END IF */

                  ir_variable *const r032F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r032F);
                  ir_expression *const r0330 = lshift(r0225, body.constant(int(31)));
                  ir_expression *const r0331 = expr(ir_unop_i2u, r02EF);
                  ir_expression *const r0332 = lshift(r0331, body.constant(int(20)));
                  ir_expression *const r0333 = add(r0330, r0332);
                  body.emit(assign(r032F, add(r0333, r02F0), 0x02));

                  body.emit(assign(r032F, r02F1, 0x01));

                  body.emit(assign(r02F4, r032F, 0x03));

                  body.emit(assign(r02F3, body.constant(false), 0x01));


               body.instructions = f0320_parent_instructions;
               body.emit(f0320);

               /* END IF */

               body.emit(assign(r0227, r02F4, 0x03));

               body.emit(assign(r0226, body.constant(false), 0x01));


            body.instructions = f02E6_parent_instructions;
            body.emit(f02E6);

            /* END IF */


         body.instructions = f02BC_parent_instructions;
         body.emit(f02BC);

         /* END IF */


      body.instructions = f0278_parent_instructions;
      body.emit(f0278);

      /* END IF */


   body.instructions = f0237_parent_instructions;
   body.emit(f0237);

   /* END IF */

   /* IF CONDITION */
   ir_if *f0334 = new(mem_ctx) ir_if(operand(r0226).val);
   exec_list *const f0334_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0334->then_instructions;

      body.emit(assign(r022A, bit_or(swizzle_y(r022A), body.constant(1048576u)), 0x02));

      ir_variable *const r0335 = body.make_temp(glsl_type::uint_type, "z0Ptr");
      ir_variable *const r0336 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r0336, add(swizzle_x(r022A), swizzle_x(r0229)), 0x01));

      ir_expression *const r0337 = add(swizzle_y(r022A), swizzle_y(r0229));
      ir_expression *const r0338 = less(r0336, swizzle_x(r022A));
      ir_expression *const r0339 = expr(ir_unop_b2i, r0338);
      ir_expression *const r033A = expr(ir_unop_i2u, r0339);
      body.emit(assign(r0335, add(r0337, r033A), 0x01));

      body.emit(assign(r022D, r0335, 0x01));

      body.emit(assign(r022B, add(r022B, body.constant(int(-1))), 0x01));

      /* IF CONDITION */
      ir_expression *const r033C = less(r0335, body.constant(2097152u));
      ir_if *f033B = new(mem_ctx) ir_if(operand(r033C).val);
      exec_list *const f033B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f033B->then_instructions;

         ir_variable *const r033D = body.make_temp(glsl_type::int_type, "zExp");
         body.emit(assign(r033D, r022B, 0x01));

         ir_variable *const r033E = body.make_temp(glsl_type::uint_type, "zFrac0");
         body.emit(assign(r033E, r0335, 0x01));

         ir_variable *const r033F = body.make_temp(glsl_type::uint_type, "zFrac1");
         body.emit(assign(r033F, r0336, 0x01));

         ir_variable *const r0340 = body.make_temp(glsl_type::uint_type, "zFrac2");
         body.emit(assign(r0340, r022C, 0x01));

         ir_variable *const r0341 = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r0341, body.constant(true), 0x01));

         ir_variable *const r0342 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r0343 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
         body.emit(r0343);
         ir_expression *const r0344 = expr(ir_unop_u2i, r022C);
         body.emit(assign(r0343, less(r0344, body.constant(int(0))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0346 = lequal(body.constant(int(2045)), r022B);
         ir_if *f0345 = new(mem_ctx) ir_if(operand(r0346).val);
         exec_list *const f0345_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0345->then_instructions;

            ir_variable *const r0347 = body.make_temp(glsl_type::bool_type, "or_tmp");
            /* IF CONDITION */
            ir_expression *const r0349 = less(body.constant(int(2045)), r022B);
            ir_if *f0348 = new(mem_ctx) ir_if(operand(r0349).val);
            exec_list *const f0348_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0348->then_instructions;

               body.emit(assign(r0347, body.constant(true), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0348->else_instructions;

               ir_variable *const r034A = body.make_temp(glsl_type::bool_type, "and_tmp");
               /* IF CONDITION */
               ir_expression *const r034C = equal(r022B, body.constant(int(2045)));
               ir_if *f034B = new(mem_ctx) ir_if(operand(r034C).val);
               exec_list *const f034B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f034B->then_instructions;

                  ir_expression *const r034D = equal(body.constant(2097151u), r0335);
                  ir_expression *const r034E = equal(body.constant(4294967295u), r0336);
                  body.emit(assign(r034A, logic_and(r034D, r034E), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f034B->else_instructions;

                  body.emit(assign(r034A, body.constant(false), 0x01));


               body.instructions = f034B_parent_instructions;
               body.emit(f034B);

               /* END IF */

               body.emit(assign(r0347, logic_and(r034A, r0343), 0x01));


            body.instructions = f0348_parent_instructions;
            body.emit(f0348);

            /* END IF */

            /* IF CONDITION */
            ir_if *f034F = new(mem_ctx) ir_if(operand(r0347).val);
            exec_list *const f034F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f034F->then_instructions;

               ir_variable *const r0350 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0350);
               ir_expression *const r0351 = lshift(r0225, body.constant(int(31)));
               body.emit(assign(r0350, add(r0351, body.constant(2146435072u)), 0x02));

               body.emit(assign(r0350, body.constant(0u), 0x01));

               body.emit(assign(r0342, r0350, 0x03));

               body.emit(assign(r0341, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f034F->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0353 = less(r022B, body.constant(int(0)));
               ir_if *f0352 = new(mem_ctx) ir_if(operand(r0353).val);
               exec_list *const f0352_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0352->then_instructions;

                  ir_variable *const r0354 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r0354, r022C, 0x01));

                  ir_variable *const r0355 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r0355, neg(r022B), 0x01));

                  ir_variable *const r0356 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r0356);
                  ir_variable *const r0357 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r0357);
                  ir_variable *const r0358 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r0358);
                  ir_variable *const r0359 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r035A = neg(r0355);
                  body.emit(assign(r0359, bit_and(r035A, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r035C = equal(r0355, body.constant(int(0)));
                  ir_if *f035B = new(mem_ctx) ir_if(operand(r035C).val);
                  exec_list *const f035B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f035B->then_instructions;

                     body.emit(assign(r0356, r022C, 0x01));

                     body.emit(assign(r0357, r0336, 0x01));

                     body.emit(assign(r0358, r0335, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f035B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r035E = less(r0355, body.constant(int(32)));
                     ir_if *f035D = new(mem_ctx) ir_if(operand(r035E).val);
                     exec_list *const f035D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f035D->then_instructions;

                        body.emit(assign(r0356, lshift(r0336, r0359), 0x01));

                        ir_expression *const r035F = lshift(r0335, r0359);
                        ir_expression *const r0360 = rshift(r0336, r0355);
                        body.emit(assign(r0357, bit_or(r035F, r0360), 0x01));

                        body.emit(assign(r0358, rshift(r0335, r0355), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f035D->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0362 = equal(r0355, body.constant(int(32)));
                        ir_if *f0361 = new(mem_ctx) ir_if(operand(r0362).val);
                        exec_list *const f0361_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0361->then_instructions;

                           body.emit(assign(r0356, r0336, 0x01));

                           body.emit(assign(r0357, r0335, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0361->else_instructions;

                           body.emit(assign(r0354, bit_or(r022C, r0336), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0364 = less(r0355, body.constant(int(64)));
                           ir_if *f0363 = new(mem_ctx) ir_if(operand(r0364).val);
                           exec_list *const f0363_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0363->then_instructions;

                              body.emit(assign(r0356, lshift(r0335, r0359), 0x01));

                              ir_expression *const r0365 = bit_and(r0355, body.constant(int(31)));
                              body.emit(assign(r0357, rshift(r0335, r0365), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0363->else_instructions;

                              ir_variable *const r0366 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0368 = equal(r0355, body.constant(int(64)));
                              ir_if *f0367 = new(mem_ctx) ir_if(operand(r0368).val);
                              exec_list *const f0367_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0367->then_instructions;

                                 body.emit(assign(r0366, r0335, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0367->else_instructions;

                                 ir_expression *const r0369 = nequal(r0335, body.constant(0u));
                                 ir_expression *const r036A = expr(ir_unop_b2i, r0369);
                                 body.emit(assign(r0366, expr(ir_unop_i2u, r036A), 0x01));


                              body.instructions = f0367_parent_instructions;
                              body.emit(f0367);

                              /* END IF */

                              body.emit(assign(r0356, r0366, 0x01));

                              body.emit(assign(r0357, body.constant(0u), 0x01));


                           body.instructions = f0363_parent_instructions;
                           body.emit(f0363);

                           /* END IF */


                        body.instructions = f0361_parent_instructions;
                        body.emit(f0361);

                        /* END IF */

                        body.emit(assign(r0358, body.constant(0u), 0x01));


                     body.instructions = f035D_parent_instructions;
                     body.emit(f035D);

                     /* END IF */

                     ir_expression *const r036B = nequal(r0354, body.constant(0u));
                     ir_expression *const r036C = expr(ir_unop_b2i, r036B);
                     ir_expression *const r036D = expr(ir_unop_i2u, r036C);
                     body.emit(assign(r0356, bit_or(r0356, r036D), 0x01));


                  body.instructions = f035B_parent_instructions;
                  body.emit(f035B);

                  /* END IF */

                  body.emit(assign(r033E, r0358, 0x01));

                  body.emit(assign(r033F, r0357, 0x01));

                  body.emit(assign(r0340, r0356, 0x01));

                  body.emit(assign(r033D, body.constant(int(0)), 0x01));

                  body.emit(assign(r0343, less(r0356, body.constant(0u)), 0x01));


               body.instructions = f0352_parent_instructions;
               body.emit(f0352);

               /* END IF */


            body.instructions = f034F_parent_instructions;
            body.emit(f034F);

            /* END IF */


         body.instructions = f0345_parent_instructions;
         body.emit(f0345);

         /* END IF */

         /* IF CONDITION */
         ir_if *f036E = new(mem_ctx) ir_if(operand(r0341).val);
         exec_list *const f036E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f036E->then_instructions;

            /* IF CONDITION */
            ir_if *f036F = new(mem_ctx) ir_if(operand(r0343).val);
            exec_list *const f036F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f036F->then_instructions;

               ir_variable *const r0370 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0370, add(r033F, body.constant(1u)), 0x01));

               ir_expression *const r0371 = less(r0370, r033F);
               ir_expression *const r0372 = expr(ir_unop_b2i, r0371);
               ir_expression *const r0373 = expr(ir_unop_i2u, r0372);
               body.emit(assign(r033E, add(r033E, r0373), 0x01));

               ir_expression *const r0374 = equal(r0340, body.constant(0u));
               ir_expression *const r0375 = expr(ir_unop_b2i, r0374);
               ir_expression *const r0376 = expr(ir_unop_i2u, r0375);
               ir_expression *const r0377 = add(r0340, r0376);
               ir_expression *const r0378 = bit_and(r0377, body.constant(1u));
               ir_expression *const r0379 = expr(ir_unop_bit_not, r0378);
               body.emit(assign(r033F, bit_and(r0370, r0379), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f036F->else_instructions;

               /* IF CONDITION */
               ir_expression *const r037B = bit_or(r033E, r033F);
               ir_expression *const r037C = equal(r037B, body.constant(0u));
               ir_if *f037A = new(mem_ctx) ir_if(operand(r037C).val);
               exec_list *const f037A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f037A->then_instructions;

                  body.emit(assign(r033D, body.constant(int(0)), 0x01));


               body.instructions = f037A_parent_instructions;
               body.emit(f037A);

               /* END IF */


            body.instructions = f036F_parent_instructions;
            body.emit(f036F);

            /* END IF */

            ir_variable *const r037D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r037D);
            ir_expression *const r037E = lshift(r0225, body.constant(int(31)));
            ir_expression *const r037F = expr(ir_unop_i2u, r033D);
            ir_expression *const r0380 = lshift(r037F, body.constant(int(20)));
            ir_expression *const r0381 = add(r037E, r0380);
            body.emit(assign(r037D, add(r0381, r033E), 0x02));

            body.emit(assign(r037D, r033F, 0x01));

            body.emit(assign(r0342, r037D, 0x03));

            body.emit(assign(r0341, body.constant(false), 0x01));


         body.instructions = f036E_parent_instructions;
         body.emit(f036E);

         /* END IF */

         body.emit(assign(r0227, r0342, 0x03));

         body.emit(assign(r0226, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f033B->else_instructions;

         body.emit(assign(r022B, add(r022B, body.constant(int(1))), 0x01));

         ir_variable *const r0382 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
         body.emit(r0382);
         ir_variable *const r0383 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r0383);
         ir_variable *const r0384 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r0384);
         body.emit(assign(r0382, lshift(r0336, body.constant(int(31))), 0x01));

         ir_expression *const r0385 = lshift(r0335, body.constant(int(31)));
         ir_expression *const r0386 = rshift(r0336, body.constant(int(1)));
         body.emit(assign(r0383, bit_or(r0385, r0386), 0x01));

         body.emit(assign(r0384, rshift(r0335, body.constant(int(1))), 0x01));

         ir_expression *const r0387 = nequal(r022C, body.constant(0u));
         ir_expression *const r0388 = expr(ir_unop_b2i, r0387);
         ir_expression *const r0389 = expr(ir_unop_i2u, r0388);
         body.emit(assign(r0382, bit_or(r0382, r0389), 0x01));

         body.emit(assign(r022D, r0384, 0x01));

         body.emit(assign(r022C, r0382, 0x01));

         ir_variable *const r038A = body.make_temp(glsl_type::int_type, "zExp");
         body.emit(assign(r038A, r022B, 0x01));

         ir_variable *const r038B = body.make_temp(glsl_type::uint_type, "zFrac0");
         body.emit(assign(r038B, r0384, 0x01));

         ir_variable *const r038C = body.make_temp(glsl_type::uint_type, "zFrac1");
         body.emit(assign(r038C, r0383, 0x01));

         ir_variable *const r038D = body.make_temp(glsl_type::uint_type, "zFrac2");
         body.emit(assign(r038D, r0382, 0x01));

         ir_variable *const r038E = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r038E, body.constant(true), 0x01));

         ir_variable *const r038F = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r0390 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
         body.emit(r0390);
         ir_expression *const r0391 = expr(ir_unop_u2i, r0382);
         body.emit(assign(r0390, less(r0391, body.constant(int(0))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0393 = lequal(body.constant(int(2045)), r022B);
         ir_if *f0392 = new(mem_ctx) ir_if(operand(r0393).val);
         exec_list *const f0392_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0392->then_instructions;

            ir_variable *const r0394 = body.make_temp(glsl_type::bool_type, "or_tmp");
            /* IF CONDITION */
            ir_expression *const r0396 = less(body.constant(int(2045)), r022B);
            ir_if *f0395 = new(mem_ctx) ir_if(operand(r0396).val);
            exec_list *const f0395_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0395->then_instructions;

               body.emit(assign(r0394, body.constant(true), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0395->else_instructions;

               ir_variable *const r0397 = body.make_temp(glsl_type::bool_type, "and_tmp");
               /* IF CONDITION */
               ir_expression *const r0399 = equal(r022B, body.constant(int(2045)));
               ir_if *f0398 = new(mem_ctx) ir_if(operand(r0399).val);
               exec_list *const f0398_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0398->then_instructions;

                  ir_expression *const r039A = equal(body.constant(2097151u), r0384);
                  ir_expression *const r039B = equal(body.constant(4294967295u), r0383);
                  body.emit(assign(r0397, logic_and(r039A, r039B), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0398->else_instructions;

                  body.emit(assign(r0397, body.constant(false), 0x01));


               body.instructions = f0398_parent_instructions;
               body.emit(f0398);

               /* END IF */

               body.emit(assign(r0394, logic_and(r0397, r0390), 0x01));


            body.instructions = f0395_parent_instructions;
            body.emit(f0395);

            /* END IF */

            /* IF CONDITION */
            ir_if *f039C = new(mem_ctx) ir_if(operand(r0394).val);
            exec_list *const f039C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f039C->then_instructions;

               ir_variable *const r039D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r039D);
               ir_expression *const r039E = lshift(r0225, body.constant(int(31)));
               body.emit(assign(r039D, add(r039E, body.constant(2146435072u)), 0x02));

               body.emit(assign(r039D, body.constant(0u), 0x01));

               body.emit(assign(r038F, r039D, 0x03));

               body.emit(assign(r038E, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f039C->else_instructions;

               /* IF CONDITION */
               ir_expression *const r03A0 = less(r022B, body.constant(int(0)));
               ir_if *f039F = new(mem_ctx) ir_if(operand(r03A0).val);
               exec_list *const f039F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f039F->then_instructions;

                  ir_variable *const r03A1 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r03A1, r0382, 0x01));

                  ir_variable *const r03A2 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r03A2, neg(r022B), 0x01));

                  ir_variable *const r03A3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r03A3);
                  ir_variable *const r03A4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r03A4);
                  ir_variable *const r03A5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r03A5);
                  ir_variable *const r03A6 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r03A7 = neg(r03A2);
                  body.emit(assign(r03A6, bit_and(r03A7, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r03A9 = equal(r03A2, body.constant(int(0)));
                  ir_if *f03A8 = new(mem_ctx) ir_if(operand(r03A9).val);
                  exec_list *const f03A8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f03A8->then_instructions;

                     body.emit(assign(r03A3, r0382, 0x01));

                     body.emit(assign(r03A4, r0383, 0x01));

                     body.emit(assign(r03A5, r0384, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f03A8->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r03AB = less(r03A2, body.constant(int(32)));
                     ir_if *f03AA = new(mem_ctx) ir_if(operand(r03AB).val);
                     exec_list *const f03AA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f03AA->then_instructions;

                        body.emit(assign(r03A3, lshift(r0383, r03A6), 0x01));

                        ir_expression *const r03AC = lshift(r0384, r03A6);
                        ir_expression *const r03AD = rshift(r0383, r03A2);
                        body.emit(assign(r03A4, bit_or(r03AC, r03AD), 0x01));

                        body.emit(assign(r03A5, rshift(r0384, r03A2), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f03AA->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r03AF = equal(r03A2, body.constant(int(32)));
                        ir_if *f03AE = new(mem_ctx) ir_if(operand(r03AF).val);
                        exec_list *const f03AE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f03AE->then_instructions;

                           body.emit(assign(r03A3, r0383, 0x01));

                           body.emit(assign(r03A4, r0384, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f03AE->else_instructions;

                           body.emit(assign(r03A1, bit_or(r0382, r0383), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r03B1 = less(r03A2, body.constant(int(64)));
                           ir_if *f03B0 = new(mem_ctx) ir_if(operand(r03B1).val);
                           exec_list *const f03B0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f03B0->then_instructions;

                              body.emit(assign(r03A3, lshift(r0384, r03A6), 0x01));

                              ir_expression *const r03B2 = bit_and(r03A2, body.constant(int(31)));
                              body.emit(assign(r03A4, rshift(r0384, r03B2), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f03B0->else_instructions;

                              ir_variable *const r03B3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r03B5 = equal(r03A2, body.constant(int(64)));
                              ir_if *f03B4 = new(mem_ctx) ir_if(operand(r03B5).val);
                              exec_list *const f03B4_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f03B4->then_instructions;

                                 body.emit(assign(r03B3, r0384, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f03B4->else_instructions;

                                 ir_expression *const r03B6 = nequal(r0384, body.constant(0u));
                                 ir_expression *const r03B7 = expr(ir_unop_b2i, r03B6);
                                 body.emit(assign(r03B3, expr(ir_unop_i2u, r03B7), 0x01));


                              body.instructions = f03B4_parent_instructions;
                              body.emit(f03B4);

                              /* END IF */

                              body.emit(assign(r03A3, r03B3, 0x01));

                              body.emit(assign(r03A4, body.constant(0u), 0x01));


                           body.instructions = f03B0_parent_instructions;
                           body.emit(f03B0);

                           /* END IF */


                        body.instructions = f03AE_parent_instructions;
                        body.emit(f03AE);

                        /* END IF */

                        body.emit(assign(r03A5, body.constant(0u), 0x01));


                     body.instructions = f03AA_parent_instructions;
                     body.emit(f03AA);

                     /* END IF */

                     ir_expression *const r03B8 = nequal(r03A1, body.constant(0u));
                     ir_expression *const r03B9 = expr(ir_unop_b2i, r03B8);
                     ir_expression *const r03BA = expr(ir_unop_i2u, r03B9);
                     body.emit(assign(r03A3, bit_or(r03A3, r03BA), 0x01));


                  body.instructions = f03A8_parent_instructions;
                  body.emit(f03A8);

                  /* END IF */

                  body.emit(assign(r038B, r03A5, 0x01));

                  body.emit(assign(r038C, r03A4, 0x01));

                  body.emit(assign(r038D, r03A3, 0x01));

                  body.emit(assign(r038A, body.constant(int(0)), 0x01));

                  body.emit(assign(r0390, less(r03A3, body.constant(0u)), 0x01));


               body.instructions = f039F_parent_instructions;
               body.emit(f039F);

               /* END IF */


            body.instructions = f039C_parent_instructions;
            body.emit(f039C);

            /* END IF */


         body.instructions = f0392_parent_instructions;
         body.emit(f0392);

         /* END IF */

         /* IF CONDITION */
         ir_if *f03BB = new(mem_ctx) ir_if(operand(r038E).val);
         exec_list *const f03BB_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f03BB->then_instructions;

            /* IF CONDITION */
            ir_if *f03BC = new(mem_ctx) ir_if(operand(r0390).val);
            exec_list *const f03BC_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f03BC->then_instructions;

               ir_variable *const r03BD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r03BD, add(r038C, body.constant(1u)), 0x01));

               ir_expression *const r03BE = less(r03BD, r038C);
               ir_expression *const r03BF = expr(ir_unop_b2i, r03BE);
               ir_expression *const r03C0 = expr(ir_unop_i2u, r03BF);
               body.emit(assign(r038B, add(r038B, r03C0), 0x01));

               ir_expression *const r03C1 = equal(r038D, body.constant(0u));
               ir_expression *const r03C2 = expr(ir_unop_b2i, r03C1);
               ir_expression *const r03C3 = expr(ir_unop_i2u, r03C2);
               ir_expression *const r03C4 = add(r038D, r03C3);
               ir_expression *const r03C5 = bit_and(r03C4, body.constant(1u));
               ir_expression *const r03C6 = expr(ir_unop_bit_not, r03C5);
               body.emit(assign(r038C, bit_and(r03BD, r03C6), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f03BC->else_instructions;

               /* IF CONDITION */
               ir_expression *const r03C8 = bit_or(r038B, r038C);
               ir_expression *const r03C9 = equal(r03C8, body.constant(0u));
               ir_if *f03C7 = new(mem_ctx) ir_if(operand(r03C9).val);
               exec_list *const f03C7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f03C7->then_instructions;

                  body.emit(assign(r038A, body.constant(int(0)), 0x01));


               body.instructions = f03C7_parent_instructions;
               body.emit(f03C7);

               /* END IF */


            body.instructions = f03BC_parent_instructions;
            body.emit(f03BC);

            /* END IF */

            ir_variable *const r03CA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r03CA);
            ir_expression *const r03CB = lshift(r0225, body.constant(int(31)));
            ir_expression *const r03CC = expr(ir_unop_i2u, r038A);
            ir_expression *const r03CD = lshift(r03CC, body.constant(int(20)));
            ir_expression *const r03CE = add(r03CB, r03CD);
            body.emit(assign(r03CA, add(r03CE, r038B), 0x02));

            body.emit(assign(r03CA, r038C, 0x01));

            body.emit(assign(r038F, r03CA, 0x03));

            body.emit(assign(r038E, body.constant(false), 0x01));


         body.instructions = f03BB_parent_instructions;
         body.emit(f03BB);

         /* END IF */

         body.emit(assign(r0227, r038F, 0x03));

         body.emit(assign(r0226, body.constant(false), 0x01));


      body.instructions = f033B_parent_instructions;
      body.emit(f033B);

      /* END IF */


   body.instructions = f0334_parent_instructions;
   body.emit(f0334);

   /* END IF */

   body.emit(ret(r0227));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
subFloat64Fracs(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r03CF = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r03CF);
   ir_variable *const r03D0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r03D0);
   ir_variable *const r03D1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r03D1);
   ir_variable *const r03D2 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r03D3 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
   body.emit(r03D3);
   ir_variable *const r03D4 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
   body.emit(r03D4);
   ir_variable *const r03D5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
   body.emit(r03D5);
   ir_variable *const r03D6 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r03D6);
   ir_variable *const r03D7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
   body.emit(r03D7);
   ir_variable *const r03D8 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r03D8);
   ir_variable *const r03D9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r03D9);
   body.emit(assign(r03D9, bit_and(swizzle_y(r03CF), body.constant(1048575u)), 0x02));

   body.emit(assign(r03D9, swizzle_x(r03CF), 0x01));

   ir_variable *const r03DA = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r03DB = rshift(swizzle_y(r03CF), body.constant(int(20)));
   ir_expression *const r03DC = bit_and(r03DB, body.constant(2047u));
   body.emit(assign(r03DA, expr(ir_unop_u2i, r03DC), 0x01));

   body.emit(assign(r03D6, r03DA, 0x01));

   ir_variable *const r03DD = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r03DD);
   body.emit(assign(r03DD, bit_and(swizzle_y(r03D0), body.constant(1048575u)), 0x02));

   body.emit(assign(r03DD, swizzle_x(r03D0), 0x01));

   ir_variable *const r03DE = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r03DF = rshift(swizzle_y(r03D0), body.constant(int(20)));
   ir_expression *const r03E0 = bit_and(r03DF, body.constant(2047u));
   body.emit(assign(r03DE, expr(ir_unop_u2i, r03E0), 0x01));

   body.emit(assign(r03D4, r03DE, 0x01));

   body.emit(assign(r03D3, sub(r03DA, r03DE), 0x01));

   ir_variable *const r03E1 = body.make_temp(glsl_type::uint_type, "z1Ptr");
   body.emit(assign(r03E1, lshift(swizzle_x(r03CF), body.constant(int(10))), 0x01));

   ir_variable *const r03E2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
   ir_expression *const r03E3 = lshift(swizzle_y(r03D9), body.constant(int(10)));
   ir_expression *const r03E4 = rshift(swizzle_x(r03CF), body.constant(int(22)));
   body.emit(assign(r03E2, bit_or(r03E3, r03E4), 0x01));

   body.emit(assign(r03D7, r03E2, 0x02));

   body.emit(assign(r03D7, r03E1, 0x01));

   ir_variable *const r03E5 = body.make_temp(glsl_type::uint_type, "z1Ptr");
   body.emit(assign(r03E5, lshift(swizzle_x(r03D0), body.constant(int(10))), 0x01));

   ir_variable *const r03E6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
   ir_expression *const r03E7 = lshift(swizzle_y(r03DD), body.constant(int(10)));
   ir_expression *const r03E8 = rshift(swizzle_x(r03D0), body.constant(int(22)));
   body.emit(assign(r03E6, bit_or(r03E7, r03E8), 0x01));

   body.emit(assign(r03D5, r03E6, 0x02));

   body.emit(assign(r03D5, r03E5, 0x01));

   /* IF CONDITION */
   ir_expression *const r03EA = less(body.constant(int(0)), r03D3);
   ir_if *f03E9 = new(mem_ctx) ir_if(operand(r03EA).val);
   exec_list *const f03E9_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f03E9->then_instructions;

      /* IF CONDITION */
      ir_expression *const r03EC = equal(r03DA, body.constant(int(2047)));
      ir_if *f03EB = new(mem_ctx) ir_if(operand(r03EC).val);
      exec_list *const f03EB_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f03EB->then_instructions;

         /* IF CONDITION */
         ir_expression *const r03EE = bit_or(r03E2, r03E1);
         ir_expression *const r03EF = nequal(r03EE, body.constant(0u));
         ir_if *f03ED = new(mem_ctx) ir_if(operand(r03EF).val);
         exec_list *const f03ED_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f03ED->then_instructions;

            ir_variable *const r03F0 = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r03F0, swizzle_x(r03CF), 0x01));

            ir_variable *const r03F1 = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r03F1, swizzle_x(r03D0), 0x01));

            ir_variable *const r03F2 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r03F3 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r03F4 = rshift(swizzle_y(r03CF), body.constant(int(19)));
            ir_expression *const r03F5 = bit_and(r03F4, body.constant(4095u));
            ir_expression *const r03F6 = equal(r03F5, body.constant(4094u));
            ir_expression *const r03F7 = nequal(swizzle_x(r03CF), body.constant(0u));
            ir_expression *const r03F8 = bit_and(swizzle_y(r03CF), body.constant(524287u));
            ir_expression *const r03F9 = nequal(r03F8, body.constant(0u));
            ir_expression *const r03FA = logic_or(r03F7, r03F9);
            body.emit(assign(r03F3, logic_and(r03F6, r03FA), 0x01));

            ir_variable *const r03FB = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r03FC = lshift(swizzle_y(r03D0), body.constant(int(1)));
            ir_expression *const r03FD = lequal(body.constant(4292870144u), r03FC);
            ir_expression *const r03FE = nequal(swizzle_x(r03D0), body.constant(0u));
            ir_expression *const r03FF = bit_and(swizzle_y(r03D0), body.constant(1048575u));
            ir_expression *const r0400 = nequal(r03FF, body.constant(0u));
            ir_expression *const r0401 = logic_or(r03FE, r0400);
            body.emit(assign(r03FB, logic_and(r03FD, r0401), 0x01));

            body.emit(assign(r03F0, bit_or(swizzle_y(r03CF), body.constant(524288u)), 0x02));

            body.emit(assign(r03F1, bit_or(swizzle_y(r03D0), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r0403 = lshift(swizzle_y(r03CF), body.constant(int(1)));
            ir_expression *const r0404 = lequal(body.constant(4292870144u), r0403);
            ir_expression *const r0405 = nequal(swizzle_x(r03CF), body.constant(0u));
            ir_expression *const r0406 = bit_and(swizzle_y(r03CF), body.constant(1048575u));
            ir_expression *const r0407 = nequal(r0406, body.constant(0u));
            ir_expression *const r0408 = logic_or(r0405, r0407);
            ir_expression *const r0409 = logic_and(r0404, r0408);
            ir_if *f0402 = new(mem_ctx) ir_if(operand(r0409).val);
            exec_list *const f0402_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0402->then_instructions;

               ir_variable *const r040A = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r040C = logic_and(r03F3, r03FB);
               ir_if *f040B = new(mem_ctx) ir_if(operand(r040C).val);
               exec_list *const f040B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f040B->then_instructions;

                  body.emit(assign(r040A, r03F1, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f040B->else_instructions;

                  body.emit(assign(r040A, r03F0, 0x03));


               body.instructions = f040B_parent_instructions;
               body.emit(f040B);

               /* END IF */

               body.emit(assign(r03F2, r040A, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0402->else_instructions;

               body.emit(assign(r03F2, r03F1, 0x03));


            body.instructions = f0402_parent_instructions;
            body.emit(f0402);

            /* END IF */

            body.emit(assign(r03D2, r03F2, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f03ED->else_instructions;

            body.emit(assign(r03D2, r03CF, 0x03));


         body.instructions = f03ED_parent_instructions;
         body.emit(f03ED);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f03EB->else_instructions;

         /* IF CONDITION */
         ir_expression *const r040E = equal(r03DE, body.constant(int(0)));
         ir_if *f040D = new(mem_ctx) ir_if(operand(r040E).val);
         exec_list *const f040D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f040D->then_instructions;

            body.emit(assign(r03D3, add(r03D3, body.constant(int(-1))), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f040D->else_instructions;

            body.emit(assign(r03D5, bit_or(r03E6, body.constant(1073741824u)), 0x02));


         body.instructions = f040D_parent_instructions;
         body.emit(f040D);

         /* END IF */

         ir_variable *const r040F = body.make_temp(glsl_type::uint_type, "a0");
         body.emit(assign(r040F, swizzle_y(r03D5), 0x01));

         ir_variable *const r0410 = body.make_temp(glsl_type::uint_type, "a1");
         body.emit(assign(r0410, swizzle_x(r03D5), 0x01));

         ir_variable *const r0411 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r0411);
         ir_variable *const r0412 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r0412);
         ir_variable *const r0413 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         ir_expression *const r0414 = neg(r03D3);
         body.emit(assign(r0413, bit_and(r0414, body.constant(int(31))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0416 = equal(r03D3, body.constant(int(0)));
         ir_if *f0415 = new(mem_ctx) ir_if(operand(r0416).val);
         exec_list *const f0415_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0415->then_instructions;

            body.emit(assign(r0411, r0410, 0x01));

            body.emit(assign(r0412, r040F, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0415->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0418 = less(r03D3, body.constant(int(32)));
            ir_if *f0417 = new(mem_ctx) ir_if(operand(r0418).val);
            exec_list *const f0417_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0417->then_instructions;

               ir_expression *const r0419 = lshift(swizzle_y(r03D5), r0413);
               ir_expression *const r041A = rshift(r03E5, r03D3);
               ir_expression *const r041B = bit_or(r0419, r041A);
               ir_expression *const r041C = lshift(r03E5, r0413);
               ir_expression *const r041D = nequal(r041C, body.constant(0u));
               ir_expression *const r041E = expr(ir_unop_b2i, r041D);
               ir_expression *const r041F = expr(ir_unop_i2u, r041E);
               body.emit(assign(r0411, bit_or(r041B, r041F), 0x01));

               body.emit(assign(r0412, rshift(swizzle_y(r03D5), r03D3), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0417->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0421 = equal(r03D3, body.constant(int(32)));
               ir_if *f0420 = new(mem_ctx) ir_if(operand(r0421).val);
               exec_list *const f0420_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0420->then_instructions;

                  ir_expression *const r0422 = nequal(r03E5, body.constant(0u));
                  ir_expression *const r0423 = expr(ir_unop_b2i, r0422);
                  ir_expression *const r0424 = expr(ir_unop_i2u, r0423);
                  body.emit(assign(r0411, bit_or(swizzle_y(r03D5), r0424), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0420->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0426 = less(r03D3, body.constant(int(64)));
                  ir_if *f0425 = new(mem_ctx) ir_if(operand(r0426).val);
                  exec_list *const f0425_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0425->then_instructions;

                     ir_expression *const r0427 = bit_and(r03D3, body.constant(int(31)));
                     ir_expression *const r0428 = rshift(swizzle_y(r03D5), r0427);
                     ir_expression *const r0429 = lshift(swizzle_y(r03D5), r0413);
                     ir_expression *const r042A = bit_or(r0429, r03E5);
                     ir_expression *const r042B = nequal(r042A, body.constant(0u));
                     ir_expression *const r042C = expr(ir_unop_b2i, r042B);
                     ir_expression *const r042D = expr(ir_unop_i2u, r042C);
                     body.emit(assign(r0411, bit_or(r0428, r042D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0425->else_instructions;

                     ir_expression *const r042E = bit_or(swizzle_y(r03D5), r03E5);
                     ir_expression *const r042F = nequal(r042E, body.constant(0u));
                     ir_expression *const r0430 = expr(ir_unop_b2i, r042F);
                     body.emit(assign(r0411, expr(ir_unop_i2u, r0430), 0x01));


                  body.instructions = f0425_parent_instructions;
                  body.emit(f0425);

                  /* END IF */


               body.instructions = f0420_parent_instructions;
               body.emit(f0420);

               /* END IF */

               body.emit(assign(r0412, body.constant(0u), 0x01));


            body.instructions = f0417_parent_instructions;
            body.emit(f0417);

            /* END IF */


         body.instructions = f0415_parent_instructions;
         body.emit(f0415);

         /* END IF */

         body.emit(assign(r03D5, r0412, 0x02));

         body.emit(assign(r03D5, r0411, 0x01));

         body.emit(assign(r03D7, bit_or(r03E2, body.constant(1073741824u)), 0x02));

         ir_variable *const r0431 = body.make_temp(glsl_type::uint_type, "z0Ptr");
         ir_variable *const r0432 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r0432, sub(r03E1, r0411), 0x01));

         ir_expression *const r0433 = sub(swizzle_y(r03D7), r0412);
         ir_expression *const r0434 = less(r03E1, r0411);
         ir_expression *const r0435 = expr(ir_unop_b2i, r0434);
         ir_expression *const r0436 = expr(ir_unop_i2u, r0435);
         body.emit(assign(r0431, sub(r0433, r0436), 0x01));

         body.emit(assign(r03D8, add(r03DA, body.constant(int(-1))), 0x01));

         ir_variable *const r0437 = body.make_temp(glsl_type::int_type, "zExp");
         body.emit(assign(r0437, add(r03D8, body.constant(int(-10))), 0x01));

         ir_variable *const r0438 = body.make_temp(glsl_type::uint_type, "zFrac0");
         body.emit(assign(r0438, r0431, 0x01));

         ir_variable *const r0439 = body.make_temp(glsl_type::uint_type, "zFrac1");
         body.emit(assign(r0439, r0432, 0x01));

         ir_variable *const r043A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
         body.emit(r043A);
         ir_variable *const r043B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
         body.emit(r043B);
         /* IF CONDITION */
         ir_expression *const r043D = equal(r0431, body.constant(0u));
         ir_if *f043C = new(mem_ctx) ir_if(operand(r043D).val);
         exec_list *const f043C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f043C->then_instructions;

            body.emit(assign(r0438, r0432, 0x01));

            body.emit(assign(r0439, body.constant(0u), 0x01));

            body.emit(assign(r0437, add(r0437, body.constant(int(-32))), 0x01));


         body.instructions = f043C_parent_instructions;
         body.emit(f043C);

         /* END IF */

         ir_variable *const r043E = body.make_temp(glsl_type::uint_type, "a");
         body.emit(assign(r043E, r0438, 0x01));

         ir_variable *const r043F = body.make_temp(glsl_type::int_type, "return_value");
         ir_variable *const r0440 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
         body.emit(r0440);
         /* IF CONDITION */
         ir_expression *const r0442 = equal(r0438, body.constant(0u));
         ir_if *f0441 = new(mem_ctx) ir_if(operand(r0442).val);
         exec_list *const f0441_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0441->then_instructions;

            body.emit(assign(r043F, body.constant(int(32)), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0441->else_instructions;

            body.emit(assign(r0440, body.constant(int(0)), 0x01));

            /* IF CONDITION */
            ir_expression *const r0444 = bit_and(r0438, body.constant(4294901760u));
            ir_expression *const r0445 = equal(r0444, body.constant(0u));
            ir_if *f0443 = new(mem_ctx) ir_if(operand(r0445).val);
            exec_list *const f0443_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0443->then_instructions;

               body.emit(assign(r0440, body.constant(int(16)), 0x01));

               body.emit(assign(r043E, lshift(r0438, body.constant(int(16))), 0x01));


            body.instructions = f0443_parent_instructions;
            body.emit(f0443);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r0447 = bit_and(r043E, body.constant(4278190080u));
            ir_expression *const r0448 = equal(r0447, body.constant(0u));
            ir_if *f0446 = new(mem_ctx) ir_if(operand(r0448).val);
            exec_list *const f0446_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0446->then_instructions;

               body.emit(assign(r0440, add(r0440, body.constant(int(8))), 0x01));

               body.emit(assign(r043E, lshift(r043E, body.constant(int(8))), 0x01));


            body.instructions = f0446_parent_instructions;
            body.emit(f0446);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r044A = bit_and(r043E, body.constant(4026531840u));
            ir_expression *const r044B = equal(r044A, body.constant(0u));
            ir_if *f0449 = new(mem_ctx) ir_if(operand(r044B).val);
            exec_list *const f0449_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0449->then_instructions;

               body.emit(assign(r0440, add(r0440, body.constant(int(4))), 0x01));

               body.emit(assign(r043E, lshift(r043E, body.constant(int(4))), 0x01));


            body.instructions = f0449_parent_instructions;
            body.emit(f0449);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r044D = bit_and(r043E, body.constant(3221225472u));
            ir_expression *const r044E = equal(r044D, body.constant(0u));
            ir_if *f044C = new(mem_ctx) ir_if(operand(r044E).val);
            exec_list *const f044C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f044C->then_instructions;

               body.emit(assign(r0440, add(r0440, body.constant(int(2))), 0x01));

               body.emit(assign(r043E, lshift(r043E, body.constant(int(2))), 0x01));


            body.instructions = f044C_parent_instructions;
            body.emit(f044C);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r0450 = bit_and(r043E, body.constant(2147483648u));
            ir_expression *const r0451 = equal(r0450, body.constant(0u));
            ir_if *f044F = new(mem_ctx) ir_if(operand(r0451).val);
            exec_list *const f044F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f044F->then_instructions;

               body.emit(assign(r0440, add(r0440, body.constant(int(1))), 0x01));


            body.instructions = f044F_parent_instructions;
            body.emit(f044F);

            /* END IF */

            body.emit(assign(r043F, r0440, 0x01));


         body.instructions = f0441_parent_instructions;
         body.emit(f0441);

         /* END IF */

         body.emit(assign(r043B, add(r043F, body.constant(int(-11))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0453 = lequal(body.constant(int(0)), r043B);
         ir_if *f0452 = new(mem_ctx) ir_if(operand(r0453).val);
         exec_list *const f0452_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0452->then_instructions;

            body.emit(assign(r043A, body.constant(0u), 0x01));

            ir_variable *const r0454 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r0454, lshift(r0439, r043B), 0x01));

            ir_variable *const r0455 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r0457 = equal(r043B, body.constant(int(0)));
            ir_if *f0456 = new(mem_ctx) ir_if(operand(r0457).val);
            exec_list *const f0456_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0456->then_instructions;

               body.emit(assign(r0455, r0438, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0456->else_instructions;

               ir_expression *const r0458 = lshift(r0438, r043B);
               ir_expression *const r0459 = neg(r043B);
               ir_expression *const r045A = bit_and(r0459, body.constant(int(31)));
               ir_expression *const r045B = rshift(r0439, r045A);
               body.emit(assign(r0455, bit_or(r0458, r045B), 0x01));


            body.instructions = f0456_parent_instructions;
            body.emit(f0456);

            /* END IF */

            body.emit(assign(r0438, r0455, 0x01));

            body.emit(assign(r0439, r0454, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0452->else_instructions;

            ir_variable *const r045C = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r045C, body.constant(0u), 0x01));

            ir_variable *const r045D = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r045D, neg(r043B), 0x01));

            ir_variable *const r045E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r045E);
            ir_variable *const r045F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r045F);
            ir_variable *const r0460 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r0460);
            ir_variable *const r0461 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r0462 = neg(r045D);
            body.emit(assign(r0461, bit_and(r0462, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0464 = equal(r045D, body.constant(int(0)));
            ir_if *f0463 = new(mem_ctx) ir_if(operand(r0464).val);
            exec_list *const f0463_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0463->then_instructions;

               body.emit(assign(r045E, r045C, 0x01));

               body.emit(assign(r045F, r0439, 0x01));

               body.emit(assign(r0460, r0438, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0463->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0466 = less(r045D, body.constant(int(32)));
               ir_if *f0465 = new(mem_ctx) ir_if(operand(r0466).val);
               exec_list *const f0465_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0465->then_instructions;

                  body.emit(assign(r045E, lshift(r0439, r0461), 0x01));

                  ir_expression *const r0467 = lshift(r0438, r0461);
                  ir_expression *const r0468 = rshift(r0439, r045D);
                  body.emit(assign(r045F, bit_or(r0467, r0468), 0x01));

                  body.emit(assign(r0460, rshift(r0438, r045D), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0465->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r046A = equal(r045D, body.constant(int(32)));
                  ir_if *f0469 = new(mem_ctx) ir_if(operand(r046A).val);
                  exec_list *const f0469_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0469->then_instructions;

                     body.emit(assign(r045E, r0439, 0x01));

                     body.emit(assign(r045F, r0438, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0469->else_instructions;

                     body.emit(assign(r045C, bit_or(body.constant(0u), r0439), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r046C = less(r045D, body.constant(int(64)));
                     ir_if *f046B = new(mem_ctx) ir_if(operand(r046C).val);
                     exec_list *const f046B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f046B->then_instructions;

                        body.emit(assign(r045E, lshift(r0438, r0461), 0x01));

                        ir_expression *const r046D = bit_and(r045D, body.constant(int(31)));
                        body.emit(assign(r045F, rshift(r0438, r046D), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f046B->else_instructions;

                        ir_variable *const r046E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0470 = equal(r045D, body.constant(int(64)));
                        ir_if *f046F = new(mem_ctx) ir_if(operand(r0470).val);
                        exec_list *const f046F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f046F->then_instructions;

                           body.emit(assign(r046E, r0438, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f046F->else_instructions;

                           ir_expression *const r0471 = nequal(r0438, body.constant(0u));
                           ir_expression *const r0472 = expr(ir_unop_b2i, r0471);
                           body.emit(assign(r046E, expr(ir_unop_i2u, r0472), 0x01));


                        body.instructions = f046F_parent_instructions;
                        body.emit(f046F);

                        /* END IF */

                        body.emit(assign(r045E, r046E, 0x01));

                        body.emit(assign(r045F, body.constant(0u), 0x01));


                     body.instructions = f046B_parent_instructions;
                     body.emit(f046B);

                     /* END IF */


                  body.instructions = f0469_parent_instructions;
                  body.emit(f0469);

                  /* END IF */

                  body.emit(assign(r0460, body.constant(0u), 0x01));


               body.instructions = f0465_parent_instructions;
               body.emit(f0465);

               /* END IF */

               ir_expression *const r0473 = nequal(r045C, body.constant(0u));
               ir_expression *const r0474 = expr(ir_unop_b2i, r0473);
               ir_expression *const r0475 = expr(ir_unop_i2u, r0474);
               body.emit(assign(r045E, bit_or(r045E, r0475), 0x01));


            body.instructions = f0463_parent_instructions;
            body.emit(f0463);

            /* END IF */

            body.emit(assign(r0438, r0460, 0x01));

            body.emit(assign(r0439, r045F, 0x01));

            body.emit(assign(r043A, r045E, 0x01));


         body.instructions = f0452_parent_instructions;
         body.emit(f0452);

         /* END IF */

         body.emit(assign(r0437, sub(r0437, r043B), 0x01));

         ir_variable *const r0476 = body.make_temp(glsl_type::int_type, "zExp");
         body.emit(assign(r0476, r0437, 0x01));

         ir_variable *const r0477 = body.make_temp(glsl_type::uint_type, "zFrac0");
         body.emit(assign(r0477, r0438, 0x01));

         ir_variable *const r0478 = body.make_temp(glsl_type::uint_type, "zFrac1");
         body.emit(assign(r0478, r0439, 0x01));

         ir_variable *const r0479 = body.make_temp(glsl_type::uint_type, "zFrac2");
         body.emit(assign(r0479, r043A, 0x01));

         ir_variable *const r047A = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r047A, body.constant(true), 0x01));

         ir_variable *const r047B = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r047C = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
         body.emit(r047C);
         ir_expression *const r047D = expr(ir_unop_u2i, r043A);
         body.emit(assign(r047C, less(r047D, body.constant(int(0))), 0x01));

         /* IF CONDITION */
         ir_expression *const r047F = lequal(body.constant(int(2045)), r0437);
         ir_if *f047E = new(mem_ctx) ir_if(operand(r047F).val);
         exec_list *const f047E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f047E->then_instructions;

            ir_variable *const r0480 = body.make_temp(glsl_type::bool_type, "or_tmp");
            /* IF CONDITION */
            ir_expression *const r0482 = less(body.constant(int(2045)), r0437);
            ir_if *f0481 = new(mem_ctx) ir_if(operand(r0482).val);
            exec_list *const f0481_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0481->then_instructions;

               body.emit(assign(r0480, body.constant(true), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0481->else_instructions;

               ir_variable *const r0483 = body.make_temp(glsl_type::bool_type, "and_tmp");
               /* IF CONDITION */
               ir_expression *const r0485 = equal(r0437, body.constant(int(2045)));
               ir_if *f0484 = new(mem_ctx) ir_if(operand(r0485).val);
               exec_list *const f0484_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0484->then_instructions;

                  ir_expression *const r0486 = equal(body.constant(2097151u), r0438);
                  ir_expression *const r0487 = equal(body.constant(4294967295u), r0439);
                  body.emit(assign(r0483, logic_and(r0486, r0487), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0484->else_instructions;

                  body.emit(assign(r0483, body.constant(false), 0x01));


               body.instructions = f0484_parent_instructions;
               body.emit(f0484);

               /* END IF */

               body.emit(assign(r0480, logic_and(r0483, r047C), 0x01));


            body.instructions = f0481_parent_instructions;
            body.emit(f0481);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0488 = new(mem_ctx) ir_if(operand(r0480).val);
            exec_list *const f0488_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0488->then_instructions;

               ir_variable *const r0489 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0489);
               ir_expression *const r048A = lshift(r03D1, body.constant(int(31)));
               body.emit(assign(r0489, add(r048A, body.constant(2146435072u)), 0x02));

               body.emit(assign(r0489, body.constant(0u), 0x01));

               body.emit(assign(r047B, r0489, 0x03));

               body.emit(assign(r047A, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0488->else_instructions;

               /* IF CONDITION */
               ir_expression *const r048C = less(r0437, body.constant(int(0)));
               ir_if *f048B = new(mem_ctx) ir_if(operand(r048C).val);
               exec_list *const f048B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f048B->then_instructions;

                  ir_variable *const r048D = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r048D, r043A, 0x01));

                  ir_variable *const r048E = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r048E, neg(r0437), 0x01));

                  ir_variable *const r048F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r048F);
                  ir_variable *const r0490 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r0490);
                  ir_variable *const r0491 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r0491);
                  ir_variable *const r0492 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r0493 = neg(r048E);
                  body.emit(assign(r0492, bit_and(r0493, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0495 = equal(r048E, body.constant(int(0)));
                  ir_if *f0494 = new(mem_ctx) ir_if(operand(r0495).val);
                  exec_list *const f0494_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0494->then_instructions;

                     body.emit(assign(r048F, r043A, 0x01));

                     body.emit(assign(r0490, r0439, 0x01));

                     body.emit(assign(r0491, r0438, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0494->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0497 = less(r048E, body.constant(int(32)));
                     ir_if *f0496 = new(mem_ctx) ir_if(operand(r0497).val);
                     exec_list *const f0496_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0496->then_instructions;

                        body.emit(assign(r048F, lshift(r0439, r0492), 0x01));

                        ir_expression *const r0498 = lshift(r0438, r0492);
                        ir_expression *const r0499 = rshift(r0439, r048E);
                        body.emit(assign(r0490, bit_or(r0498, r0499), 0x01));

                        body.emit(assign(r0491, rshift(r0438, r048E), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0496->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r049B = equal(r048E, body.constant(int(32)));
                        ir_if *f049A = new(mem_ctx) ir_if(operand(r049B).val);
                        exec_list *const f049A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f049A->then_instructions;

                           body.emit(assign(r048F, r0439, 0x01));

                           body.emit(assign(r0490, r0438, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f049A->else_instructions;

                           body.emit(assign(r048D, bit_or(r043A, r0439), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r049D = less(r048E, body.constant(int(64)));
                           ir_if *f049C = new(mem_ctx) ir_if(operand(r049D).val);
                           exec_list *const f049C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f049C->then_instructions;

                              body.emit(assign(r048F, lshift(r0438, r0492), 0x01));

                              ir_expression *const r049E = bit_and(r048E, body.constant(int(31)));
                              body.emit(assign(r0490, rshift(r0438, r049E), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f049C->else_instructions;

                              ir_variable *const r049F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r04A1 = equal(r048E, body.constant(int(64)));
                              ir_if *f04A0 = new(mem_ctx) ir_if(operand(r04A1).val);
                              exec_list *const f04A0_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f04A0->then_instructions;

                                 body.emit(assign(r049F, r0438, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f04A0->else_instructions;

                                 ir_expression *const r04A2 = nequal(r0438, body.constant(0u));
                                 ir_expression *const r04A3 = expr(ir_unop_b2i, r04A2);
                                 body.emit(assign(r049F, expr(ir_unop_i2u, r04A3), 0x01));


                              body.instructions = f04A0_parent_instructions;
                              body.emit(f04A0);

                              /* END IF */

                              body.emit(assign(r048F, r049F, 0x01));

                              body.emit(assign(r0490, body.constant(0u), 0x01));


                           body.instructions = f049C_parent_instructions;
                           body.emit(f049C);

                           /* END IF */


                        body.instructions = f049A_parent_instructions;
                        body.emit(f049A);

                        /* END IF */

                        body.emit(assign(r0491, body.constant(0u), 0x01));


                     body.instructions = f0496_parent_instructions;
                     body.emit(f0496);

                     /* END IF */

                     ir_expression *const r04A4 = nequal(r048D, body.constant(0u));
                     ir_expression *const r04A5 = expr(ir_unop_b2i, r04A4);
                     ir_expression *const r04A6 = expr(ir_unop_i2u, r04A5);
                     body.emit(assign(r048F, bit_or(r048F, r04A6), 0x01));


                  body.instructions = f0494_parent_instructions;
                  body.emit(f0494);

                  /* END IF */

                  body.emit(assign(r0477, r0491, 0x01));

                  body.emit(assign(r0478, r0490, 0x01));

                  body.emit(assign(r0479, r048F, 0x01));

                  body.emit(assign(r0476, body.constant(int(0)), 0x01));

                  body.emit(assign(r047C, less(r048F, body.constant(0u)), 0x01));


               body.instructions = f048B_parent_instructions;
               body.emit(f048B);

               /* END IF */


            body.instructions = f0488_parent_instructions;
            body.emit(f0488);

            /* END IF */


         body.instructions = f047E_parent_instructions;
         body.emit(f047E);

         /* END IF */

         /* IF CONDITION */
         ir_if *f04A7 = new(mem_ctx) ir_if(operand(r047A).val);
         exec_list *const f04A7_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f04A7->then_instructions;

            /* IF CONDITION */
            ir_if *f04A8 = new(mem_ctx) ir_if(operand(r047C).val);
            exec_list *const f04A8_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f04A8->then_instructions;

               ir_variable *const r04A9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r04A9, add(r0478, body.constant(1u)), 0x01));

               ir_expression *const r04AA = less(r04A9, r0478);
               ir_expression *const r04AB = expr(ir_unop_b2i, r04AA);
               ir_expression *const r04AC = expr(ir_unop_i2u, r04AB);
               body.emit(assign(r0477, add(r0477, r04AC), 0x01));

               ir_expression *const r04AD = equal(r0479, body.constant(0u));
               ir_expression *const r04AE = expr(ir_unop_b2i, r04AD);
               ir_expression *const r04AF = expr(ir_unop_i2u, r04AE);
               ir_expression *const r04B0 = add(r0479, r04AF);
               ir_expression *const r04B1 = bit_and(r04B0, body.constant(1u));
               ir_expression *const r04B2 = expr(ir_unop_bit_not, r04B1);
               body.emit(assign(r0478, bit_and(r04A9, r04B2), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f04A8->else_instructions;

               /* IF CONDITION */
               ir_expression *const r04B4 = bit_or(r0477, r0478);
               ir_expression *const r04B5 = equal(r04B4, body.constant(0u));
               ir_if *f04B3 = new(mem_ctx) ir_if(operand(r04B5).val);
               exec_list *const f04B3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f04B3->then_instructions;

                  body.emit(assign(r0476, body.constant(int(0)), 0x01));


               body.instructions = f04B3_parent_instructions;
               body.emit(f04B3);

               /* END IF */


            body.instructions = f04A8_parent_instructions;
            body.emit(f04A8);

            /* END IF */

            ir_variable *const r04B6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r04B6);
            ir_expression *const r04B7 = lshift(r03D1, body.constant(int(31)));
            ir_expression *const r04B8 = expr(ir_unop_i2u, r0476);
            ir_expression *const r04B9 = lshift(r04B8, body.constant(int(20)));
            ir_expression *const r04BA = add(r04B7, r04B9);
            body.emit(assign(r04B6, add(r04BA, r0477), 0x02));

            body.emit(assign(r04B6, r0478, 0x01));

            body.emit(assign(r047B, r04B6, 0x03));

            body.emit(assign(r047A, body.constant(false), 0x01));


         body.instructions = f04A7_parent_instructions;
         body.emit(f04A7);

         /* END IF */

         body.emit(assign(r03D2, r047B, 0x03));


      body.instructions = f03EB_parent_instructions;
      body.emit(f03EB);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f03E9->else_instructions;

      /* IF CONDITION */
      ir_expression *const r04BC = less(r03D3, body.constant(int(0)));
      ir_if *f04BB = new(mem_ctx) ir_if(operand(r04BC).val);
      exec_list *const f04BB_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f04BB->then_instructions;

         /* IF CONDITION */
         ir_expression *const r04BE = equal(r03DE, body.constant(int(2047)));
         ir_if *f04BD = new(mem_ctx) ir_if(operand(r04BE).val);
         exec_list *const f04BD_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f04BD->then_instructions;

            /* IF CONDITION */
            ir_expression *const r04C0 = bit_or(swizzle_y(r03D5), swizzle_x(r03D5));
            ir_expression *const r04C1 = nequal(r04C0, body.constant(0u));
            ir_if *f04BF = new(mem_ctx) ir_if(operand(r04C1).val);
            exec_list *const f04BF_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f04BF->then_instructions;

               ir_variable *const r04C2 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r04C2, swizzle_x(r03CF), 0x01));

               ir_variable *const r04C3 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r04C3, swizzle_x(r03D0), 0x01));

               ir_variable *const r04C4 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r04C5 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r04C6 = rshift(swizzle_y(r03CF), body.constant(int(19)));
               ir_expression *const r04C7 = bit_and(r04C6, body.constant(4095u));
               ir_expression *const r04C8 = equal(r04C7, body.constant(4094u));
               ir_expression *const r04C9 = nequal(swizzle_x(r03CF), body.constant(0u));
               ir_expression *const r04CA = bit_and(swizzle_y(r03CF), body.constant(524287u));
               ir_expression *const r04CB = nequal(r04CA, body.constant(0u));
               ir_expression *const r04CC = logic_or(r04C9, r04CB);
               body.emit(assign(r04C5, logic_and(r04C8, r04CC), 0x01));

               ir_variable *const r04CD = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r04CE = lshift(swizzle_y(r03D0), body.constant(int(1)));
               ir_expression *const r04CF = lequal(body.constant(4292870144u), r04CE);
               ir_expression *const r04D0 = nequal(swizzle_x(r03D0), body.constant(0u));
               ir_expression *const r04D1 = bit_and(swizzle_y(r03D0), body.constant(1048575u));
               ir_expression *const r04D2 = nequal(r04D1, body.constant(0u));
               ir_expression *const r04D3 = logic_or(r04D0, r04D2);
               body.emit(assign(r04CD, logic_and(r04CF, r04D3), 0x01));

               body.emit(assign(r04C2, bit_or(swizzle_y(r03CF), body.constant(524288u)), 0x02));

               body.emit(assign(r04C3, bit_or(swizzle_y(r03D0), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r04D5 = lshift(swizzle_y(r03CF), body.constant(int(1)));
               ir_expression *const r04D6 = lequal(body.constant(4292870144u), r04D5);
               ir_expression *const r04D7 = nequal(swizzle_x(r03CF), body.constant(0u));
               ir_expression *const r04D8 = bit_and(swizzle_y(r03CF), body.constant(1048575u));
               ir_expression *const r04D9 = nequal(r04D8, body.constant(0u));
               ir_expression *const r04DA = logic_or(r04D7, r04D9);
               ir_expression *const r04DB = logic_and(r04D6, r04DA);
               ir_if *f04D4 = new(mem_ctx) ir_if(operand(r04DB).val);
               exec_list *const f04D4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f04D4->then_instructions;

                  ir_variable *const r04DC = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r04DE = logic_and(r04C5, r04CD);
                  ir_if *f04DD = new(mem_ctx) ir_if(operand(r04DE).val);
                  exec_list *const f04DD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f04DD->then_instructions;

                     body.emit(assign(r04DC, r04C3, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f04DD->else_instructions;

                     body.emit(assign(r04DC, r04C2, 0x03));


                  body.instructions = f04DD_parent_instructions;
                  body.emit(f04DD);

                  /* END IF */

                  body.emit(assign(r04C4, r04DC, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f04D4->else_instructions;

                  body.emit(assign(r04C4, r04C3, 0x03));


               body.instructions = f04D4_parent_instructions;
               body.emit(f04D4);

               /* END IF */

               body.emit(assign(r03D2, r04C4, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f04BF->else_instructions;

               ir_variable *const r04DF = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r04DF);
               ir_expression *const r04E0 = bit_xor(r03D1, body.constant(1u));
               ir_expression *const r04E1 = lshift(r04E0, body.constant(int(31)));
               body.emit(assign(r04DF, add(r04E1, body.constant(2146435072u)), 0x02));

               body.emit(assign(r04DF, body.constant(0u), 0x01));

               body.emit(assign(r03D2, r04DF, 0x03));


            body.instructions = f04BF_parent_instructions;
            body.emit(f04BF);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f04BD->else_instructions;

            /* IF CONDITION */
            ir_expression *const r04E3 = equal(r03DA, body.constant(int(0)));
            ir_if *f04E2 = new(mem_ctx) ir_if(operand(r04E3).val);
            exec_list *const f04E2_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f04E2->then_instructions;

               body.emit(assign(r03D3, add(r03D3, body.constant(int(1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f04E2->else_instructions;

               body.emit(assign(r03D7, bit_or(swizzle_y(r03D7), body.constant(1073741824u)), 0x02));


            body.instructions = f04E2_parent_instructions;
            body.emit(f04E2);

            /* END IF */

            ir_variable *const r04E4 = body.make_temp(glsl_type::uint_type, "a0");
            body.emit(assign(r04E4, swizzle_y(r03D7), 0x01));

            ir_variable *const r04E5 = body.make_temp(glsl_type::uint_type, "a1");
            body.emit(assign(r04E5, swizzle_x(r03D7), 0x01));

            ir_variable *const r04E6 = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r04E6, neg(r03D3), 0x01));

            ir_variable *const r04E7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r04E7);
            ir_variable *const r04E8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r04E8);
            ir_variable *const r04E9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r04EA = neg(r04E6);
            body.emit(assign(r04E9, bit_and(r04EA, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r04EC = equal(r04E6, body.constant(int(0)));
            ir_if *f04EB = new(mem_ctx) ir_if(operand(r04EC).val);
            exec_list *const f04EB_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f04EB->then_instructions;

               body.emit(assign(r04E7, r04E5, 0x01));

               body.emit(assign(r04E8, r04E4, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f04EB->else_instructions;

               /* IF CONDITION */
               ir_expression *const r04EE = less(r04E6, body.constant(int(32)));
               ir_if *f04ED = new(mem_ctx) ir_if(operand(r04EE).val);
               exec_list *const f04ED_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f04ED->then_instructions;

                  ir_expression *const r04EF = lshift(swizzle_y(r03D7), r04E9);
                  ir_expression *const r04F0 = rshift(r03E1, r04E6);
                  ir_expression *const r04F1 = bit_or(r04EF, r04F0);
                  ir_expression *const r04F2 = lshift(r03E1, r04E9);
                  ir_expression *const r04F3 = nequal(r04F2, body.constant(0u));
                  ir_expression *const r04F4 = expr(ir_unop_b2i, r04F3);
                  ir_expression *const r04F5 = expr(ir_unop_i2u, r04F4);
                  body.emit(assign(r04E7, bit_or(r04F1, r04F5), 0x01));

                  body.emit(assign(r04E8, rshift(swizzle_y(r03D7), r04E6), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f04ED->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r04F7 = equal(r04E6, body.constant(int(32)));
                  ir_if *f04F6 = new(mem_ctx) ir_if(operand(r04F7).val);
                  exec_list *const f04F6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f04F6->then_instructions;

                     ir_expression *const r04F8 = nequal(r03E1, body.constant(0u));
                     ir_expression *const r04F9 = expr(ir_unop_b2i, r04F8);
                     ir_expression *const r04FA = expr(ir_unop_i2u, r04F9);
                     body.emit(assign(r04E7, bit_or(swizzle_y(r03D7), r04FA), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f04F6->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r04FC = less(r04E6, body.constant(int(64)));
                     ir_if *f04FB = new(mem_ctx) ir_if(operand(r04FC).val);
                     exec_list *const f04FB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f04FB->then_instructions;

                        ir_expression *const r04FD = bit_and(r04E6, body.constant(int(31)));
                        ir_expression *const r04FE = rshift(swizzle_y(r03D7), r04FD);
                        ir_expression *const r04FF = lshift(swizzle_y(r03D7), r04E9);
                        ir_expression *const r0500 = bit_or(r04FF, r03E1);
                        ir_expression *const r0501 = nequal(r0500, body.constant(0u));
                        ir_expression *const r0502 = expr(ir_unop_b2i, r0501);
                        ir_expression *const r0503 = expr(ir_unop_i2u, r0502);
                        body.emit(assign(r04E7, bit_or(r04FE, r0503), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f04FB->else_instructions;

                        ir_expression *const r0504 = bit_or(swizzle_y(r03D7), r03E1);
                        ir_expression *const r0505 = nequal(r0504, body.constant(0u));
                        ir_expression *const r0506 = expr(ir_unop_b2i, r0505);
                        body.emit(assign(r04E7, expr(ir_unop_i2u, r0506), 0x01));


                     body.instructions = f04FB_parent_instructions;
                     body.emit(f04FB);

                     /* END IF */


                  body.instructions = f04F6_parent_instructions;
                  body.emit(f04F6);

                  /* END IF */

                  body.emit(assign(r04E8, body.constant(0u), 0x01));


               body.instructions = f04ED_parent_instructions;
               body.emit(f04ED);

               /* END IF */


            body.instructions = f04EB_parent_instructions;
            body.emit(f04EB);

            /* END IF */

            body.emit(assign(r03D7, r04E8, 0x02));

            body.emit(assign(r03D7, r04E7, 0x01));

            body.emit(assign(r03D5, bit_or(swizzle_y(r03D5), body.constant(1073741824u)), 0x02));

            ir_variable *const r0507 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r0508 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r0508, sub(swizzle_x(r03D5), r04E7), 0x01));

            ir_expression *const r0509 = sub(swizzle_y(r03D5), r04E8);
            ir_expression *const r050A = less(swizzle_x(r03D5), r04E7);
            ir_expression *const r050B = expr(ir_unop_b2i, r050A);
            ir_expression *const r050C = expr(ir_unop_i2u, r050B);
            body.emit(assign(r0507, sub(r0509, r050C), 0x01));

            body.emit(assign(r03D1, bit_xor(r03D1, body.constant(1u)), 0x01));

            body.emit(assign(r03D8, add(r03DE, body.constant(int(-1))), 0x01));

            ir_variable *const r050D = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r050D, add(r03D8, body.constant(int(-10))), 0x01));

            ir_variable *const r050E = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r050E, r0507, 0x01));

            ir_variable *const r050F = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r050F, r0508, 0x01));

            ir_variable *const r0510 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
            body.emit(r0510);
            ir_variable *const r0511 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0511);
            /* IF CONDITION */
            ir_expression *const r0513 = equal(r0507, body.constant(0u));
            ir_if *f0512 = new(mem_ctx) ir_if(operand(r0513).val);
            exec_list *const f0512_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0512->then_instructions;

               body.emit(assign(r050E, r0508, 0x01));

               body.emit(assign(r050F, body.constant(0u), 0x01));

               body.emit(assign(r050D, add(r050D, body.constant(int(-32))), 0x01));


            body.instructions = f0512_parent_instructions;
            body.emit(f0512);

            /* END IF */

            ir_variable *const r0514 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r0514, r050E, 0x01));

            ir_variable *const r0515 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r0516 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0516);
            /* IF CONDITION */
            ir_expression *const r0518 = equal(r050E, body.constant(0u));
            ir_if *f0517 = new(mem_ctx) ir_if(operand(r0518).val);
            exec_list *const f0517_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0517->then_instructions;

               body.emit(assign(r0515, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0517->else_instructions;

               body.emit(assign(r0516, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r051A = bit_and(r050E, body.constant(4294901760u));
               ir_expression *const r051B = equal(r051A, body.constant(0u));
               ir_if *f0519 = new(mem_ctx) ir_if(operand(r051B).val);
               exec_list *const f0519_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0519->then_instructions;

                  body.emit(assign(r0516, body.constant(int(16)), 0x01));

                  body.emit(assign(r0514, lshift(r050E, body.constant(int(16))), 0x01));


               body.instructions = f0519_parent_instructions;
               body.emit(f0519);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r051D = bit_and(r0514, body.constant(4278190080u));
               ir_expression *const r051E = equal(r051D, body.constant(0u));
               ir_if *f051C = new(mem_ctx) ir_if(operand(r051E).val);
               exec_list *const f051C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f051C->then_instructions;

                  body.emit(assign(r0516, add(r0516, body.constant(int(8))), 0x01));

                  body.emit(assign(r0514, lshift(r0514, body.constant(int(8))), 0x01));


               body.instructions = f051C_parent_instructions;
               body.emit(f051C);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0520 = bit_and(r0514, body.constant(4026531840u));
               ir_expression *const r0521 = equal(r0520, body.constant(0u));
               ir_if *f051F = new(mem_ctx) ir_if(operand(r0521).val);
               exec_list *const f051F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f051F->then_instructions;

                  body.emit(assign(r0516, add(r0516, body.constant(int(4))), 0x01));

                  body.emit(assign(r0514, lshift(r0514, body.constant(int(4))), 0x01));


               body.instructions = f051F_parent_instructions;
               body.emit(f051F);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0523 = bit_and(r0514, body.constant(3221225472u));
               ir_expression *const r0524 = equal(r0523, body.constant(0u));
               ir_if *f0522 = new(mem_ctx) ir_if(operand(r0524).val);
               exec_list *const f0522_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0522->then_instructions;

                  body.emit(assign(r0516, add(r0516, body.constant(int(2))), 0x01));

                  body.emit(assign(r0514, lshift(r0514, body.constant(int(2))), 0x01));


               body.instructions = f0522_parent_instructions;
               body.emit(f0522);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0526 = bit_and(r0514, body.constant(2147483648u));
               ir_expression *const r0527 = equal(r0526, body.constant(0u));
               ir_if *f0525 = new(mem_ctx) ir_if(operand(r0527).val);
               exec_list *const f0525_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0525->then_instructions;

                  body.emit(assign(r0516, add(r0516, body.constant(int(1))), 0x01));


               body.instructions = f0525_parent_instructions;
               body.emit(f0525);

               /* END IF */

               body.emit(assign(r0515, r0516, 0x01));


            body.instructions = f0517_parent_instructions;
            body.emit(f0517);

            /* END IF */

            body.emit(assign(r0511, add(r0515, body.constant(int(-11))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0529 = lequal(body.constant(int(0)), r0511);
            ir_if *f0528 = new(mem_ctx) ir_if(operand(r0529).val);
            exec_list *const f0528_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0528->then_instructions;

               body.emit(assign(r0510, body.constant(0u), 0x01));

               ir_variable *const r052A = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r052A, lshift(r050F, r0511), 0x01));

               ir_variable *const r052B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r052D = equal(r0511, body.constant(int(0)));
               ir_if *f052C = new(mem_ctx) ir_if(operand(r052D).val);
               exec_list *const f052C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f052C->then_instructions;

                  body.emit(assign(r052B, r050E, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f052C->else_instructions;

                  ir_expression *const r052E = lshift(r050E, r0511);
                  ir_expression *const r052F = neg(r0511);
                  ir_expression *const r0530 = bit_and(r052F, body.constant(int(31)));
                  ir_expression *const r0531 = rshift(r050F, r0530);
                  body.emit(assign(r052B, bit_or(r052E, r0531), 0x01));


               body.instructions = f052C_parent_instructions;
               body.emit(f052C);

               /* END IF */

               body.emit(assign(r050E, r052B, 0x01));

               body.emit(assign(r050F, r052A, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0528->else_instructions;

               ir_variable *const r0532 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r0532, body.constant(0u), 0x01));

               ir_variable *const r0533 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0533, neg(r0511), 0x01));

               ir_variable *const r0534 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r0534);
               ir_variable *const r0535 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0535);
               ir_variable *const r0536 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0536);
               ir_variable *const r0537 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0538 = neg(r0533);
               body.emit(assign(r0537, bit_and(r0538, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r053A = equal(r0533, body.constant(int(0)));
               ir_if *f0539 = new(mem_ctx) ir_if(operand(r053A).val);
               exec_list *const f0539_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0539->then_instructions;

                  body.emit(assign(r0534, r0532, 0x01));

                  body.emit(assign(r0535, r050F, 0x01));

                  body.emit(assign(r0536, r050E, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0539->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r053C = less(r0533, body.constant(int(32)));
                  ir_if *f053B = new(mem_ctx) ir_if(operand(r053C).val);
                  exec_list *const f053B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f053B->then_instructions;

                     body.emit(assign(r0534, lshift(r050F, r0537), 0x01));

                     ir_expression *const r053D = lshift(r050E, r0537);
                     ir_expression *const r053E = rshift(r050F, r0533);
                     body.emit(assign(r0535, bit_or(r053D, r053E), 0x01));

                     body.emit(assign(r0536, rshift(r050E, r0533), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f053B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0540 = equal(r0533, body.constant(int(32)));
                     ir_if *f053F = new(mem_ctx) ir_if(operand(r0540).val);
                     exec_list *const f053F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f053F->then_instructions;

                        body.emit(assign(r0534, r050F, 0x01));

                        body.emit(assign(r0535, r050E, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f053F->else_instructions;

                        body.emit(assign(r0532, bit_or(body.constant(0u), r050F), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0542 = less(r0533, body.constant(int(64)));
                        ir_if *f0541 = new(mem_ctx) ir_if(operand(r0542).val);
                        exec_list *const f0541_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0541->then_instructions;

                           body.emit(assign(r0534, lshift(r050E, r0537), 0x01));

                           ir_expression *const r0543 = bit_and(r0533, body.constant(int(31)));
                           body.emit(assign(r0535, rshift(r050E, r0543), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0541->else_instructions;

                           ir_variable *const r0544 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0546 = equal(r0533, body.constant(int(64)));
                           ir_if *f0545 = new(mem_ctx) ir_if(operand(r0546).val);
                           exec_list *const f0545_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0545->then_instructions;

                              body.emit(assign(r0544, r050E, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0545->else_instructions;

                              ir_expression *const r0547 = nequal(r050E, body.constant(0u));
                              ir_expression *const r0548 = expr(ir_unop_b2i, r0547);
                              body.emit(assign(r0544, expr(ir_unop_i2u, r0548), 0x01));


                           body.instructions = f0545_parent_instructions;
                           body.emit(f0545);

                           /* END IF */

                           body.emit(assign(r0534, r0544, 0x01));

                           body.emit(assign(r0535, body.constant(0u), 0x01));


                        body.instructions = f0541_parent_instructions;
                        body.emit(f0541);

                        /* END IF */


                     body.instructions = f053F_parent_instructions;
                     body.emit(f053F);

                     /* END IF */

                     body.emit(assign(r0536, body.constant(0u), 0x01));


                  body.instructions = f053B_parent_instructions;
                  body.emit(f053B);

                  /* END IF */

                  ir_expression *const r0549 = nequal(r0532, body.constant(0u));
                  ir_expression *const r054A = expr(ir_unop_b2i, r0549);
                  ir_expression *const r054B = expr(ir_unop_i2u, r054A);
                  body.emit(assign(r0534, bit_or(r0534, r054B), 0x01));


               body.instructions = f0539_parent_instructions;
               body.emit(f0539);

               /* END IF */

               body.emit(assign(r050E, r0536, 0x01));

               body.emit(assign(r050F, r0535, 0x01));

               body.emit(assign(r0510, r0534, 0x01));


            body.instructions = f0528_parent_instructions;
            body.emit(f0528);

            /* END IF */

            body.emit(assign(r050D, sub(r050D, r0511), 0x01));

            ir_variable *const r054C = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r054C, r050D, 0x01));

            ir_variable *const r054D = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r054D, r050E, 0x01));

            ir_variable *const r054E = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r054E, r050F, 0x01));

            ir_variable *const r054F = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r054F, r0510, 0x01));

            ir_variable *const r0550 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r0550, body.constant(true), 0x01));

            ir_variable *const r0551 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0552 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r0552);
            ir_expression *const r0553 = expr(ir_unop_u2i, r0510);
            body.emit(assign(r0552, less(r0553, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0555 = lequal(body.constant(int(2045)), r050D);
            ir_if *f0554 = new(mem_ctx) ir_if(operand(r0555).val);
            exec_list *const f0554_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0554->then_instructions;

               ir_variable *const r0556 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0558 = less(body.constant(int(2045)), r050D);
               ir_if *f0557 = new(mem_ctx) ir_if(operand(r0558).val);
               exec_list *const f0557_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0557->then_instructions;

                  body.emit(assign(r0556, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0557->else_instructions;

                  ir_variable *const r0559 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r055B = equal(r050D, body.constant(int(2045)));
                  ir_if *f055A = new(mem_ctx) ir_if(operand(r055B).val);
                  exec_list *const f055A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f055A->then_instructions;

                     ir_expression *const r055C = equal(body.constant(2097151u), r050E);
                     ir_expression *const r055D = equal(body.constant(4294967295u), r050F);
                     body.emit(assign(r0559, logic_and(r055C, r055D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f055A->else_instructions;

                     body.emit(assign(r0559, body.constant(false), 0x01));


                  body.instructions = f055A_parent_instructions;
                  body.emit(f055A);

                  /* END IF */

                  body.emit(assign(r0556, logic_and(r0559, r0552), 0x01));


               body.instructions = f0557_parent_instructions;
               body.emit(f0557);

               /* END IF */

               /* IF CONDITION */
               ir_if *f055E = new(mem_ctx) ir_if(operand(r0556).val);
               exec_list *const f055E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f055E->then_instructions;

                  ir_variable *const r055F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r055F);
                  ir_expression *const r0560 = lshift(r03D1, body.constant(int(31)));
                  body.emit(assign(r055F, add(r0560, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r055F, body.constant(0u), 0x01));

                  body.emit(assign(r0551, r055F, 0x03));

                  body.emit(assign(r0550, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f055E->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0562 = less(r050D, body.constant(int(0)));
                  ir_if *f0561 = new(mem_ctx) ir_if(operand(r0562).val);
                  exec_list *const f0561_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0561->then_instructions;

                     ir_variable *const r0563 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0563, r0510, 0x01));

                     ir_variable *const r0564 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0564, neg(r050D), 0x01));

                     ir_variable *const r0565 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0565);
                     ir_variable *const r0566 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0566);
                     ir_variable *const r0567 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0567);
                     ir_variable *const r0568 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0569 = neg(r0564);
                     body.emit(assign(r0568, bit_and(r0569, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r056B = equal(r0564, body.constant(int(0)));
                     ir_if *f056A = new(mem_ctx) ir_if(operand(r056B).val);
                     exec_list *const f056A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f056A->then_instructions;

                        body.emit(assign(r0565, r0510, 0x01));

                        body.emit(assign(r0566, r050F, 0x01));

                        body.emit(assign(r0567, r050E, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f056A->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r056D = less(r0564, body.constant(int(32)));
                        ir_if *f056C = new(mem_ctx) ir_if(operand(r056D).val);
                        exec_list *const f056C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f056C->then_instructions;

                           body.emit(assign(r0565, lshift(r050F, r0568), 0x01));

                           ir_expression *const r056E = lshift(r050E, r0568);
                           ir_expression *const r056F = rshift(r050F, r0564);
                           body.emit(assign(r0566, bit_or(r056E, r056F), 0x01));

                           body.emit(assign(r0567, rshift(r050E, r0564), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f056C->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0571 = equal(r0564, body.constant(int(32)));
                           ir_if *f0570 = new(mem_ctx) ir_if(operand(r0571).val);
                           exec_list *const f0570_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0570->then_instructions;

                              body.emit(assign(r0565, r050F, 0x01));

                              body.emit(assign(r0566, r050E, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0570->else_instructions;

                              body.emit(assign(r0563, bit_or(r0510, r050F), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0573 = less(r0564, body.constant(int(64)));
                              ir_if *f0572 = new(mem_ctx) ir_if(operand(r0573).val);
                              exec_list *const f0572_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0572->then_instructions;

                                 body.emit(assign(r0565, lshift(r050E, r0568), 0x01));

                                 ir_expression *const r0574 = bit_and(r0564, body.constant(int(31)));
                                 body.emit(assign(r0566, rshift(r050E, r0574), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0572->else_instructions;

                                 ir_variable *const r0575 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0577 = equal(r0564, body.constant(int(64)));
                                 ir_if *f0576 = new(mem_ctx) ir_if(operand(r0577).val);
                                 exec_list *const f0576_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0576->then_instructions;

                                    body.emit(assign(r0575, r050E, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0576->else_instructions;

                                    ir_expression *const r0578 = nequal(r050E, body.constant(0u));
                                    ir_expression *const r0579 = expr(ir_unop_b2i, r0578);
                                    body.emit(assign(r0575, expr(ir_unop_i2u, r0579), 0x01));


                                 body.instructions = f0576_parent_instructions;
                                 body.emit(f0576);

                                 /* END IF */

                                 body.emit(assign(r0565, r0575, 0x01));

                                 body.emit(assign(r0566, body.constant(0u), 0x01));


                              body.instructions = f0572_parent_instructions;
                              body.emit(f0572);

                              /* END IF */


                           body.instructions = f0570_parent_instructions;
                           body.emit(f0570);

                           /* END IF */

                           body.emit(assign(r0567, body.constant(0u), 0x01));


                        body.instructions = f056C_parent_instructions;
                        body.emit(f056C);

                        /* END IF */

                        ir_expression *const r057A = nequal(r0563, body.constant(0u));
                        ir_expression *const r057B = expr(ir_unop_b2i, r057A);
                        ir_expression *const r057C = expr(ir_unop_i2u, r057B);
                        body.emit(assign(r0565, bit_or(r0565, r057C), 0x01));


                     body.instructions = f056A_parent_instructions;
                     body.emit(f056A);

                     /* END IF */

                     body.emit(assign(r054D, r0567, 0x01));

                     body.emit(assign(r054E, r0566, 0x01));

                     body.emit(assign(r054F, r0565, 0x01));

                     body.emit(assign(r054C, body.constant(int(0)), 0x01));

                     body.emit(assign(r0552, less(r0565, body.constant(0u)), 0x01));


                  body.instructions = f0561_parent_instructions;
                  body.emit(f0561);

                  /* END IF */


               body.instructions = f055E_parent_instructions;
               body.emit(f055E);

               /* END IF */


            body.instructions = f0554_parent_instructions;
            body.emit(f0554);

            /* END IF */

            /* IF CONDITION */
            ir_if *f057D = new(mem_ctx) ir_if(operand(r0550).val);
            exec_list *const f057D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f057D->then_instructions;

               /* IF CONDITION */
               ir_if *f057E = new(mem_ctx) ir_if(operand(r0552).val);
               exec_list *const f057E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f057E->then_instructions;

                  ir_variable *const r057F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r057F, add(r054E, body.constant(1u)), 0x01));

                  ir_expression *const r0580 = less(r057F, r054E);
                  ir_expression *const r0581 = expr(ir_unop_b2i, r0580);
                  ir_expression *const r0582 = expr(ir_unop_i2u, r0581);
                  body.emit(assign(r054D, add(r054D, r0582), 0x01));

                  ir_expression *const r0583 = equal(r054F, body.constant(0u));
                  ir_expression *const r0584 = expr(ir_unop_b2i, r0583);
                  ir_expression *const r0585 = expr(ir_unop_i2u, r0584);
                  ir_expression *const r0586 = add(r054F, r0585);
                  ir_expression *const r0587 = bit_and(r0586, body.constant(1u));
                  ir_expression *const r0588 = expr(ir_unop_bit_not, r0587);
                  body.emit(assign(r054E, bit_and(r057F, r0588), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f057E->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r058A = bit_or(r054D, r054E);
                  ir_expression *const r058B = equal(r058A, body.constant(0u));
                  ir_if *f0589 = new(mem_ctx) ir_if(operand(r058B).val);
                  exec_list *const f0589_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0589->then_instructions;

                     body.emit(assign(r054C, body.constant(int(0)), 0x01));


                  body.instructions = f0589_parent_instructions;
                  body.emit(f0589);

                  /* END IF */


               body.instructions = f057E_parent_instructions;
               body.emit(f057E);

               /* END IF */

               ir_variable *const r058C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r058C);
               ir_expression *const r058D = lshift(r03D1, body.constant(int(31)));
               ir_expression *const r058E = expr(ir_unop_i2u, r054C);
               ir_expression *const r058F = lshift(r058E, body.constant(int(20)));
               ir_expression *const r0590 = add(r058D, r058F);
               body.emit(assign(r058C, add(r0590, r054D), 0x02));

               body.emit(assign(r058C, r054E, 0x01));

               body.emit(assign(r0551, r058C, 0x03));

               body.emit(assign(r0550, body.constant(false), 0x01));


            body.instructions = f057D_parent_instructions;
            body.emit(f057D);

            /* END IF */

            body.emit(assign(r03D2, r0551, 0x03));


         body.instructions = f04BD_parent_instructions;
         body.emit(f04BD);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f04BB->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0592 = equal(r03DA, body.constant(int(2047)));
         ir_if *f0591 = new(mem_ctx) ir_if(operand(r0592).val);
         exec_list *const f0591_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0591->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0594 = bit_or(swizzle_y(r03D7), swizzle_x(r03D7));
            ir_expression *const r0595 = bit_or(swizzle_y(r03D5), swizzle_x(r03D5));
            ir_expression *const r0596 = bit_or(r0594, r0595);
            ir_expression *const r0597 = nequal(r0596, body.constant(0u));
            ir_if *f0593 = new(mem_ctx) ir_if(operand(r0597).val);
            exec_list *const f0593_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0593->then_instructions;

               ir_variable *const r0598 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r0598, swizzle_x(r03CF), 0x01));

               ir_variable *const r0599 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r0599, swizzle_x(r03D0), 0x01));

               ir_variable *const r059A = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r059B = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r059C = rshift(swizzle_y(r03CF), body.constant(int(19)));
               ir_expression *const r059D = bit_and(r059C, body.constant(4095u));
               ir_expression *const r059E = equal(r059D, body.constant(4094u));
               ir_expression *const r059F = nequal(swizzle_x(r03CF), body.constant(0u));
               ir_expression *const r05A0 = bit_and(swizzle_y(r03CF), body.constant(524287u));
               ir_expression *const r05A1 = nequal(r05A0, body.constant(0u));
               ir_expression *const r05A2 = logic_or(r059F, r05A1);
               body.emit(assign(r059B, logic_and(r059E, r05A2), 0x01));

               ir_variable *const r05A3 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r05A4 = lshift(swizzle_y(r03D0), body.constant(int(1)));
               ir_expression *const r05A5 = lequal(body.constant(4292870144u), r05A4);
               ir_expression *const r05A6 = nequal(swizzle_x(r03D0), body.constant(0u));
               ir_expression *const r05A7 = bit_and(swizzle_y(r03D0), body.constant(1048575u));
               ir_expression *const r05A8 = nequal(r05A7, body.constant(0u));
               ir_expression *const r05A9 = logic_or(r05A6, r05A8);
               body.emit(assign(r05A3, logic_and(r05A5, r05A9), 0x01));

               body.emit(assign(r0598, bit_or(swizzle_y(r03CF), body.constant(524288u)), 0x02));

               body.emit(assign(r0599, bit_or(swizzle_y(r03D0), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r05AB = lshift(swizzle_y(r03CF), body.constant(int(1)));
               ir_expression *const r05AC = lequal(body.constant(4292870144u), r05AB);
               ir_expression *const r05AD = nequal(swizzle_x(r03CF), body.constant(0u));
               ir_expression *const r05AE = bit_and(swizzle_y(r03CF), body.constant(1048575u));
               ir_expression *const r05AF = nequal(r05AE, body.constant(0u));
               ir_expression *const r05B0 = logic_or(r05AD, r05AF);
               ir_expression *const r05B1 = logic_and(r05AC, r05B0);
               ir_if *f05AA = new(mem_ctx) ir_if(operand(r05B1).val);
               exec_list *const f05AA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f05AA->then_instructions;

                  ir_variable *const r05B2 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r05B4 = logic_and(r059B, r05A3);
                  ir_if *f05B3 = new(mem_ctx) ir_if(operand(r05B4).val);
                  exec_list *const f05B3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05B3->then_instructions;

                     body.emit(assign(r05B2, r0599, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f05B3->else_instructions;

                     body.emit(assign(r05B2, r0598, 0x03));


                  body.instructions = f05B3_parent_instructions;
                  body.emit(f05B3);

                  /* END IF */

                  body.emit(assign(r059A, r05B2, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f05AA->else_instructions;

                  body.emit(assign(r059A, r0599, 0x03));


               body.instructions = f05AA_parent_instructions;
               body.emit(f05AA);

               /* END IF */

               body.emit(assign(r03D2, r059A, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0593->else_instructions;

               ir_constant_data r05B5_data;
               memset(&r05B5_data, 0, sizeof(ir_constant_data));
               r05B5_data.u[0] = 4294967295;
               r05B5_data.u[1] = 4294967295;
               ir_constant *const r05B5 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r05B5_data);
               body.emit(assign(r03D2, r05B5, 0x03));


            body.instructions = f0593_parent_instructions;
            body.emit(f0593);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0591->else_instructions;

            /* IF CONDITION */
            ir_expression *const r05B7 = equal(r03DA, body.constant(int(0)));
            ir_if *f05B6 = new(mem_ctx) ir_if(operand(r05B7).val);
            exec_list *const f05B6_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f05B6->then_instructions;

               body.emit(assign(r03D6, body.constant(int(1)), 0x01));

               body.emit(assign(r03D4, body.constant(int(1)), 0x01));


            body.instructions = f05B6_parent_instructions;
            body.emit(f05B6);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r05B9 = less(swizzle_y(r03D5), swizzle_y(r03D7));
            ir_if *f05B8 = new(mem_ctx) ir_if(operand(r05B9).val);
            exec_list *const f05B8_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f05B8->then_instructions;

               ir_variable *const r05BA = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r05BB = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r05BB, sub(swizzle_x(r03D7), swizzle_x(r03D5)), 0x01));

               ir_expression *const r05BC = sub(swizzle_y(r03D7), swizzle_y(r03D5));
               ir_expression *const r05BD = less(swizzle_x(r03D7), swizzle_x(r03D5));
               ir_expression *const r05BE = expr(ir_unop_b2i, r05BD);
               ir_expression *const r05BF = expr(ir_unop_i2u, r05BE);
               body.emit(assign(r05BA, sub(r05BC, r05BF), 0x01));

               body.emit(assign(r03D8, add(r03D6, body.constant(int(-1))), 0x01));

               ir_variable *const r05C0 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r05C0, add(r03D8, body.constant(int(-10))), 0x01));

               ir_variable *const r05C1 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r05C1, r05BA, 0x01));

               ir_variable *const r05C2 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r05C2, r05BB, 0x01));

               ir_variable *const r05C3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r05C3);
               ir_variable *const r05C4 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r05C4);
               /* IF CONDITION */
               ir_expression *const r05C6 = equal(r05BA, body.constant(0u));
               ir_if *f05C5 = new(mem_ctx) ir_if(operand(r05C6).val);
               exec_list *const f05C5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f05C5->then_instructions;

                  body.emit(assign(r05C1, r05BB, 0x01));

                  body.emit(assign(r05C2, body.constant(0u), 0x01));

                  body.emit(assign(r05C0, add(r05C0, body.constant(int(-32))), 0x01));


               body.instructions = f05C5_parent_instructions;
               body.emit(f05C5);

               /* END IF */

               ir_variable *const r05C7 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r05C7, r05C1, 0x01));

               ir_variable *const r05C8 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r05C9 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r05C9);
               /* IF CONDITION */
               ir_expression *const r05CB = equal(r05C1, body.constant(0u));
               ir_if *f05CA = new(mem_ctx) ir_if(operand(r05CB).val);
               exec_list *const f05CA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f05CA->then_instructions;

                  body.emit(assign(r05C8, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f05CA->else_instructions;

                  body.emit(assign(r05C9, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r05CD = bit_and(r05C1, body.constant(4294901760u));
                  ir_expression *const r05CE = equal(r05CD, body.constant(0u));
                  ir_if *f05CC = new(mem_ctx) ir_if(operand(r05CE).val);
                  exec_list *const f05CC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05CC->then_instructions;

                     body.emit(assign(r05C9, body.constant(int(16)), 0x01));

                     body.emit(assign(r05C7, lshift(r05C1, body.constant(int(16))), 0x01));


                  body.instructions = f05CC_parent_instructions;
                  body.emit(f05CC);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r05D0 = bit_and(r05C7, body.constant(4278190080u));
                  ir_expression *const r05D1 = equal(r05D0, body.constant(0u));
                  ir_if *f05CF = new(mem_ctx) ir_if(operand(r05D1).val);
                  exec_list *const f05CF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05CF->then_instructions;

                     body.emit(assign(r05C9, add(r05C9, body.constant(int(8))), 0x01));

                     body.emit(assign(r05C7, lshift(r05C7, body.constant(int(8))), 0x01));


                  body.instructions = f05CF_parent_instructions;
                  body.emit(f05CF);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r05D3 = bit_and(r05C7, body.constant(4026531840u));
                  ir_expression *const r05D4 = equal(r05D3, body.constant(0u));
                  ir_if *f05D2 = new(mem_ctx) ir_if(operand(r05D4).val);
                  exec_list *const f05D2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05D2->then_instructions;

                     body.emit(assign(r05C9, add(r05C9, body.constant(int(4))), 0x01));

                     body.emit(assign(r05C7, lshift(r05C7, body.constant(int(4))), 0x01));


                  body.instructions = f05D2_parent_instructions;
                  body.emit(f05D2);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r05D6 = bit_and(r05C7, body.constant(3221225472u));
                  ir_expression *const r05D7 = equal(r05D6, body.constant(0u));
                  ir_if *f05D5 = new(mem_ctx) ir_if(operand(r05D7).val);
                  exec_list *const f05D5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05D5->then_instructions;

                     body.emit(assign(r05C9, add(r05C9, body.constant(int(2))), 0x01));

                     body.emit(assign(r05C7, lshift(r05C7, body.constant(int(2))), 0x01));


                  body.instructions = f05D5_parent_instructions;
                  body.emit(f05D5);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r05D9 = bit_and(r05C7, body.constant(2147483648u));
                  ir_expression *const r05DA = equal(r05D9, body.constant(0u));
                  ir_if *f05D8 = new(mem_ctx) ir_if(operand(r05DA).val);
                  exec_list *const f05D8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05D8->then_instructions;

                     body.emit(assign(r05C9, add(r05C9, body.constant(int(1))), 0x01));


                  body.instructions = f05D8_parent_instructions;
                  body.emit(f05D8);

                  /* END IF */

                  body.emit(assign(r05C8, r05C9, 0x01));


               body.instructions = f05CA_parent_instructions;
               body.emit(f05CA);

               /* END IF */

               body.emit(assign(r05C4, add(r05C8, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r05DC = lequal(body.constant(int(0)), r05C4);
               ir_if *f05DB = new(mem_ctx) ir_if(operand(r05DC).val);
               exec_list *const f05DB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f05DB->then_instructions;

                  body.emit(assign(r05C3, body.constant(0u), 0x01));

                  ir_variable *const r05DD = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r05DD, lshift(r05C2, r05C4), 0x01));

                  ir_variable *const r05DE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r05E0 = equal(r05C4, body.constant(int(0)));
                  ir_if *f05DF = new(mem_ctx) ir_if(operand(r05E0).val);
                  exec_list *const f05DF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05DF->then_instructions;

                     body.emit(assign(r05DE, r05C1, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f05DF->else_instructions;

                     ir_expression *const r05E1 = lshift(r05C1, r05C4);
                     ir_expression *const r05E2 = neg(r05C4);
                     ir_expression *const r05E3 = bit_and(r05E2, body.constant(int(31)));
                     ir_expression *const r05E4 = rshift(r05C2, r05E3);
                     body.emit(assign(r05DE, bit_or(r05E1, r05E4), 0x01));


                  body.instructions = f05DF_parent_instructions;
                  body.emit(f05DF);

                  /* END IF */

                  body.emit(assign(r05C1, r05DE, 0x01));

                  body.emit(assign(r05C2, r05DD, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f05DB->else_instructions;

                  ir_variable *const r05E5 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r05E5, body.constant(0u), 0x01));

                  ir_variable *const r05E6 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r05E6, neg(r05C4), 0x01));

                  ir_variable *const r05E7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r05E7);
                  ir_variable *const r05E8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r05E8);
                  ir_variable *const r05E9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r05E9);
                  ir_variable *const r05EA = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r05EB = neg(r05E6);
                  body.emit(assign(r05EA, bit_and(r05EB, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r05ED = equal(r05E6, body.constant(int(0)));
                  ir_if *f05EC = new(mem_ctx) ir_if(operand(r05ED).val);
                  exec_list *const f05EC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05EC->then_instructions;

                     body.emit(assign(r05E7, r05E5, 0x01));

                     body.emit(assign(r05E8, r05C2, 0x01));

                     body.emit(assign(r05E9, r05C1, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f05EC->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r05EF = less(r05E6, body.constant(int(32)));
                     ir_if *f05EE = new(mem_ctx) ir_if(operand(r05EF).val);
                     exec_list *const f05EE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f05EE->then_instructions;

                        body.emit(assign(r05E7, lshift(r05C2, r05EA), 0x01));

                        ir_expression *const r05F0 = lshift(r05C1, r05EA);
                        ir_expression *const r05F1 = rshift(r05C2, r05E6);
                        body.emit(assign(r05E8, bit_or(r05F0, r05F1), 0x01));

                        body.emit(assign(r05E9, rshift(r05C1, r05E6), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f05EE->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r05F3 = equal(r05E6, body.constant(int(32)));
                        ir_if *f05F2 = new(mem_ctx) ir_if(operand(r05F3).val);
                        exec_list *const f05F2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f05F2->then_instructions;

                           body.emit(assign(r05E7, r05C2, 0x01));

                           body.emit(assign(r05E8, r05C1, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f05F2->else_instructions;

                           body.emit(assign(r05E5, bit_or(body.constant(0u), r05C2), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r05F5 = less(r05E6, body.constant(int(64)));
                           ir_if *f05F4 = new(mem_ctx) ir_if(operand(r05F5).val);
                           exec_list *const f05F4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f05F4->then_instructions;

                              body.emit(assign(r05E7, lshift(r05C1, r05EA), 0x01));

                              ir_expression *const r05F6 = bit_and(r05E6, body.constant(int(31)));
                              body.emit(assign(r05E8, rshift(r05C1, r05F6), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f05F4->else_instructions;

                              ir_variable *const r05F7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r05F9 = equal(r05E6, body.constant(int(64)));
                              ir_if *f05F8 = new(mem_ctx) ir_if(operand(r05F9).val);
                              exec_list *const f05F8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f05F8->then_instructions;

                                 body.emit(assign(r05F7, r05C1, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f05F8->else_instructions;

                                 ir_expression *const r05FA = nequal(r05C1, body.constant(0u));
                                 ir_expression *const r05FB = expr(ir_unop_b2i, r05FA);
                                 body.emit(assign(r05F7, expr(ir_unop_i2u, r05FB), 0x01));


                              body.instructions = f05F8_parent_instructions;
                              body.emit(f05F8);

                              /* END IF */

                              body.emit(assign(r05E7, r05F7, 0x01));

                              body.emit(assign(r05E8, body.constant(0u), 0x01));


                           body.instructions = f05F4_parent_instructions;
                           body.emit(f05F4);

                           /* END IF */


                        body.instructions = f05F2_parent_instructions;
                        body.emit(f05F2);

                        /* END IF */

                        body.emit(assign(r05E9, body.constant(0u), 0x01));


                     body.instructions = f05EE_parent_instructions;
                     body.emit(f05EE);

                     /* END IF */

                     ir_expression *const r05FC = nequal(r05E5, body.constant(0u));
                     ir_expression *const r05FD = expr(ir_unop_b2i, r05FC);
                     ir_expression *const r05FE = expr(ir_unop_i2u, r05FD);
                     body.emit(assign(r05E7, bit_or(r05E7, r05FE), 0x01));


                  body.instructions = f05EC_parent_instructions;
                  body.emit(f05EC);

                  /* END IF */

                  body.emit(assign(r05C1, r05E9, 0x01));

                  body.emit(assign(r05C2, r05E8, 0x01));

                  body.emit(assign(r05C3, r05E7, 0x01));


               body.instructions = f05DB_parent_instructions;
               body.emit(f05DB);

               /* END IF */

               body.emit(assign(r05C0, sub(r05C0, r05C4), 0x01));

               ir_variable *const r05FF = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r05FF, r05C0, 0x01));

               ir_variable *const r0600 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0600, r05C1, 0x01));

               ir_variable *const r0601 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0601, r05C2, 0x01));

               ir_variable *const r0602 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r0602, r05C3, 0x01));

               ir_variable *const r0603 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r0603, body.constant(true), 0x01));

               ir_variable *const r0604 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0605 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r0605);
               ir_expression *const r0606 = expr(ir_unop_u2i, r05C3);
               body.emit(assign(r0605, less(r0606, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0608 = lequal(body.constant(int(2045)), r05C0);
               ir_if *f0607 = new(mem_ctx) ir_if(operand(r0608).val);
               exec_list *const f0607_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0607->then_instructions;

                  ir_variable *const r0609 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r060B = less(body.constant(int(2045)), r05C0);
                  ir_if *f060A = new(mem_ctx) ir_if(operand(r060B).val);
                  exec_list *const f060A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f060A->then_instructions;

                     body.emit(assign(r0609, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f060A->else_instructions;

                     ir_variable *const r060C = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r060E = equal(r05C0, body.constant(int(2045)));
                     ir_if *f060D = new(mem_ctx) ir_if(operand(r060E).val);
                     exec_list *const f060D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f060D->then_instructions;

                        ir_expression *const r060F = equal(body.constant(2097151u), r05C1);
                        ir_expression *const r0610 = equal(body.constant(4294967295u), r05C2);
                        body.emit(assign(r060C, logic_and(r060F, r0610), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f060D->else_instructions;

                        body.emit(assign(r060C, body.constant(false), 0x01));


                     body.instructions = f060D_parent_instructions;
                     body.emit(f060D);

                     /* END IF */

                     body.emit(assign(r0609, logic_and(r060C, r0605), 0x01));


                  body.instructions = f060A_parent_instructions;
                  body.emit(f060A);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0611 = new(mem_ctx) ir_if(operand(r0609).val);
                  exec_list *const f0611_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0611->then_instructions;

                     ir_variable *const r0612 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0612);
                     ir_expression *const r0613 = lshift(r03D1, body.constant(int(31)));
                     body.emit(assign(r0612, add(r0613, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r0612, body.constant(0u), 0x01));

                     body.emit(assign(r0604, r0612, 0x03));

                     body.emit(assign(r0603, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0611->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0615 = less(r05C0, body.constant(int(0)));
                     ir_if *f0614 = new(mem_ctx) ir_if(operand(r0615).val);
                     exec_list *const f0614_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0614->then_instructions;

                        ir_variable *const r0616 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0616, r05C3, 0x01));

                        ir_variable *const r0617 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0617, neg(r05C0), 0x01));

                        ir_variable *const r0618 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0618);
                        ir_variable *const r0619 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0619);
                        ir_variable *const r061A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r061A);
                        ir_variable *const r061B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r061C = neg(r0617);
                        body.emit(assign(r061B, bit_and(r061C, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r061E = equal(r0617, body.constant(int(0)));
                        ir_if *f061D = new(mem_ctx) ir_if(operand(r061E).val);
                        exec_list *const f061D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f061D->then_instructions;

                           body.emit(assign(r0618, r05C3, 0x01));

                           body.emit(assign(r0619, r05C2, 0x01));

                           body.emit(assign(r061A, r05C1, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f061D->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0620 = less(r0617, body.constant(int(32)));
                           ir_if *f061F = new(mem_ctx) ir_if(operand(r0620).val);
                           exec_list *const f061F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f061F->then_instructions;

                              body.emit(assign(r0618, lshift(r05C2, r061B), 0x01));

                              ir_expression *const r0621 = lshift(r05C1, r061B);
                              ir_expression *const r0622 = rshift(r05C2, r0617);
                              body.emit(assign(r0619, bit_or(r0621, r0622), 0x01));

                              body.emit(assign(r061A, rshift(r05C1, r0617), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f061F->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0624 = equal(r0617, body.constant(int(32)));
                              ir_if *f0623 = new(mem_ctx) ir_if(operand(r0624).val);
                              exec_list *const f0623_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0623->then_instructions;

                                 body.emit(assign(r0618, r05C2, 0x01));

                                 body.emit(assign(r0619, r05C1, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0623->else_instructions;

                                 body.emit(assign(r0616, bit_or(r05C3, r05C2), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0626 = less(r0617, body.constant(int(64)));
                                 ir_if *f0625 = new(mem_ctx) ir_if(operand(r0626).val);
                                 exec_list *const f0625_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0625->then_instructions;

                                    body.emit(assign(r0618, lshift(r05C1, r061B), 0x01));

                                    ir_expression *const r0627 = bit_and(r0617, body.constant(int(31)));
                                    body.emit(assign(r0619, rshift(r05C1, r0627), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0625->else_instructions;

                                    ir_variable *const r0628 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r062A = equal(r0617, body.constant(int(64)));
                                    ir_if *f0629 = new(mem_ctx) ir_if(operand(r062A).val);
                                    exec_list *const f0629_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0629->then_instructions;

                                       body.emit(assign(r0628, r05C1, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0629->else_instructions;

                                       ir_expression *const r062B = nequal(r05C1, body.constant(0u));
                                       ir_expression *const r062C = expr(ir_unop_b2i, r062B);
                                       body.emit(assign(r0628, expr(ir_unop_i2u, r062C), 0x01));


                                    body.instructions = f0629_parent_instructions;
                                    body.emit(f0629);

                                    /* END IF */

                                    body.emit(assign(r0618, r0628, 0x01));

                                    body.emit(assign(r0619, body.constant(0u), 0x01));


                                 body.instructions = f0625_parent_instructions;
                                 body.emit(f0625);

                                 /* END IF */


                              body.instructions = f0623_parent_instructions;
                              body.emit(f0623);

                              /* END IF */

                              body.emit(assign(r061A, body.constant(0u), 0x01));


                           body.instructions = f061F_parent_instructions;
                           body.emit(f061F);

                           /* END IF */

                           ir_expression *const r062D = nequal(r0616, body.constant(0u));
                           ir_expression *const r062E = expr(ir_unop_b2i, r062D);
                           ir_expression *const r062F = expr(ir_unop_i2u, r062E);
                           body.emit(assign(r0618, bit_or(r0618, r062F), 0x01));


                        body.instructions = f061D_parent_instructions;
                        body.emit(f061D);

                        /* END IF */

                        body.emit(assign(r0600, r061A, 0x01));

                        body.emit(assign(r0601, r0619, 0x01));

                        body.emit(assign(r0602, r0618, 0x01));

                        body.emit(assign(r05FF, body.constant(int(0)), 0x01));

                        body.emit(assign(r0605, less(r0618, body.constant(0u)), 0x01));


                     body.instructions = f0614_parent_instructions;
                     body.emit(f0614);

                     /* END IF */


                  body.instructions = f0611_parent_instructions;
                  body.emit(f0611);

                  /* END IF */


               body.instructions = f0607_parent_instructions;
               body.emit(f0607);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0630 = new(mem_ctx) ir_if(operand(r0603).val);
               exec_list *const f0630_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0630->then_instructions;

                  /* IF CONDITION */
                  ir_if *f0631 = new(mem_ctx) ir_if(operand(r0605).val);
                  exec_list *const f0631_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0631->then_instructions;

                     ir_variable *const r0632 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r0632, add(r0601, body.constant(1u)), 0x01));

                     ir_expression *const r0633 = less(r0632, r0601);
                     ir_expression *const r0634 = expr(ir_unop_b2i, r0633);
                     ir_expression *const r0635 = expr(ir_unop_i2u, r0634);
                     body.emit(assign(r0600, add(r0600, r0635), 0x01));

                     ir_expression *const r0636 = equal(r0602, body.constant(0u));
                     ir_expression *const r0637 = expr(ir_unop_b2i, r0636);
                     ir_expression *const r0638 = expr(ir_unop_i2u, r0637);
                     ir_expression *const r0639 = add(r0602, r0638);
                     ir_expression *const r063A = bit_and(r0639, body.constant(1u));
                     ir_expression *const r063B = expr(ir_unop_bit_not, r063A);
                     body.emit(assign(r0601, bit_and(r0632, r063B), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0631->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r063D = bit_or(r0600, r0601);
                     ir_expression *const r063E = equal(r063D, body.constant(0u));
                     ir_if *f063C = new(mem_ctx) ir_if(operand(r063E).val);
                     exec_list *const f063C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f063C->then_instructions;

                        body.emit(assign(r05FF, body.constant(int(0)), 0x01));


                     body.instructions = f063C_parent_instructions;
                     body.emit(f063C);

                     /* END IF */


                  body.instructions = f0631_parent_instructions;
                  body.emit(f0631);

                  /* END IF */

                  ir_variable *const r063F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r063F);
                  ir_expression *const r0640 = lshift(r03D1, body.constant(int(31)));
                  ir_expression *const r0641 = expr(ir_unop_i2u, r05FF);
                  ir_expression *const r0642 = lshift(r0641, body.constant(int(20)));
                  ir_expression *const r0643 = add(r0640, r0642);
                  body.emit(assign(r063F, add(r0643, r0600), 0x02));

                  body.emit(assign(r063F, r0601, 0x01));

                  body.emit(assign(r0604, r063F, 0x03));

                  body.emit(assign(r0603, body.constant(false), 0x01));


               body.instructions = f0630_parent_instructions;
               body.emit(f0630);

               /* END IF */

               body.emit(assign(r03D2, r0604, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f05B8->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0645 = less(swizzle_y(r03D7), swizzle_y(r03D5));
               ir_if *f0644 = new(mem_ctx) ir_if(operand(r0645).val);
               exec_list *const f0644_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0644->then_instructions;

                  ir_variable *const r0646 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r0647 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0647, sub(swizzle_x(r03D5), swizzle_x(r03D7)), 0x01));

                  ir_expression *const r0648 = sub(swizzle_y(r03D5), swizzle_y(r03D7));
                  ir_expression *const r0649 = less(swizzle_x(r03D5), swizzle_x(r03D7));
                  ir_expression *const r064A = expr(ir_unop_b2i, r0649);
                  ir_expression *const r064B = expr(ir_unop_i2u, r064A);
                  body.emit(assign(r0646, sub(r0648, r064B), 0x01));

                  body.emit(assign(r03D1, bit_xor(r03D1, body.constant(1u)), 0x01));

                  body.emit(assign(r03D8, add(r03D4, body.constant(int(-1))), 0x01));

                  ir_variable *const r064C = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r064C, add(r03D8, body.constant(int(-10))), 0x01));

                  ir_variable *const r064D = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r064D, r0646, 0x01));

                  ir_variable *const r064E = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r064E, r0647, 0x01));

                  ir_variable *const r064F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r064F);
                  ir_variable *const r0650 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0650);
                  /* IF CONDITION */
                  ir_expression *const r0652 = equal(r0646, body.constant(0u));
                  ir_if *f0651 = new(mem_ctx) ir_if(operand(r0652).val);
                  exec_list *const f0651_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0651->then_instructions;

                     body.emit(assign(r064D, r0647, 0x01));

                     body.emit(assign(r064E, body.constant(0u), 0x01));

                     body.emit(assign(r064C, add(r064C, body.constant(int(-32))), 0x01));


                  body.instructions = f0651_parent_instructions;
                  body.emit(f0651);

                  /* END IF */

                  ir_variable *const r0653 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r0653, r064D, 0x01));

                  ir_variable *const r0654 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r0655 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0655);
                  /* IF CONDITION */
                  ir_expression *const r0657 = equal(r064D, body.constant(0u));
                  ir_if *f0656 = new(mem_ctx) ir_if(operand(r0657).val);
                  exec_list *const f0656_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0656->then_instructions;

                     body.emit(assign(r0654, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0656->else_instructions;

                     body.emit(assign(r0655, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0659 = bit_and(r064D, body.constant(4294901760u));
                     ir_expression *const r065A = equal(r0659, body.constant(0u));
                     ir_if *f0658 = new(mem_ctx) ir_if(operand(r065A).val);
                     exec_list *const f0658_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0658->then_instructions;

                        body.emit(assign(r0655, body.constant(int(16)), 0x01));

                        body.emit(assign(r0653, lshift(r064D, body.constant(int(16))), 0x01));


                     body.instructions = f0658_parent_instructions;
                     body.emit(f0658);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r065C = bit_and(r0653, body.constant(4278190080u));
                     ir_expression *const r065D = equal(r065C, body.constant(0u));
                     ir_if *f065B = new(mem_ctx) ir_if(operand(r065D).val);
                     exec_list *const f065B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f065B->then_instructions;

                        body.emit(assign(r0655, add(r0655, body.constant(int(8))), 0x01));

                        body.emit(assign(r0653, lshift(r0653, body.constant(int(8))), 0x01));


                     body.instructions = f065B_parent_instructions;
                     body.emit(f065B);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r065F = bit_and(r0653, body.constant(4026531840u));
                     ir_expression *const r0660 = equal(r065F, body.constant(0u));
                     ir_if *f065E = new(mem_ctx) ir_if(operand(r0660).val);
                     exec_list *const f065E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f065E->then_instructions;

                        body.emit(assign(r0655, add(r0655, body.constant(int(4))), 0x01));

                        body.emit(assign(r0653, lshift(r0653, body.constant(int(4))), 0x01));


                     body.instructions = f065E_parent_instructions;
                     body.emit(f065E);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0662 = bit_and(r0653, body.constant(3221225472u));
                     ir_expression *const r0663 = equal(r0662, body.constant(0u));
                     ir_if *f0661 = new(mem_ctx) ir_if(operand(r0663).val);
                     exec_list *const f0661_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0661->then_instructions;

                        body.emit(assign(r0655, add(r0655, body.constant(int(2))), 0x01));

                        body.emit(assign(r0653, lshift(r0653, body.constant(int(2))), 0x01));


                     body.instructions = f0661_parent_instructions;
                     body.emit(f0661);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0665 = bit_and(r0653, body.constant(2147483648u));
                     ir_expression *const r0666 = equal(r0665, body.constant(0u));
                     ir_if *f0664 = new(mem_ctx) ir_if(operand(r0666).val);
                     exec_list *const f0664_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0664->then_instructions;

                        body.emit(assign(r0655, add(r0655, body.constant(int(1))), 0x01));


                     body.instructions = f0664_parent_instructions;
                     body.emit(f0664);

                     /* END IF */

                     body.emit(assign(r0654, r0655, 0x01));


                  body.instructions = f0656_parent_instructions;
                  body.emit(f0656);

                  /* END IF */

                  body.emit(assign(r0650, add(r0654, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0668 = lequal(body.constant(int(0)), r0650);
                  ir_if *f0667 = new(mem_ctx) ir_if(operand(r0668).val);
                  exec_list *const f0667_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0667->then_instructions;

                     body.emit(assign(r064F, body.constant(0u), 0x01));

                     ir_variable *const r0669 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r0669, lshift(r064E, r0650), 0x01));

                     ir_variable *const r066A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r066C = equal(r0650, body.constant(int(0)));
                     ir_if *f066B = new(mem_ctx) ir_if(operand(r066C).val);
                     exec_list *const f066B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f066B->then_instructions;

                        body.emit(assign(r066A, r064D, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f066B->else_instructions;

                        ir_expression *const r066D = lshift(r064D, r0650);
                        ir_expression *const r066E = neg(r0650);
                        ir_expression *const r066F = bit_and(r066E, body.constant(int(31)));
                        ir_expression *const r0670 = rshift(r064E, r066F);
                        body.emit(assign(r066A, bit_or(r066D, r0670), 0x01));


                     body.instructions = f066B_parent_instructions;
                     body.emit(f066B);

                     /* END IF */

                     body.emit(assign(r064D, r066A, 0x01));

                     body.emit(assign(r064E, r0669, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0667->else_instructions;

                     ir_variable *const r0671 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0671, body.constant(0u), 0x01));

                     ir_variable *const r0672 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0672, neg(r0650), 0x01));

                     ir_variable *const r0673 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0673);
                     ir_variable *const r0674 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0674);
                     ir_variable *const r0675 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0675);
                     ir_variable *const r0676 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0677 = neg(r0672);
                     body.emit(assign(r0676, bit_and(r0677, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0679 = equal(r0672, body.constant(int(0)));
                     ir_if *f0678 = new(mem_ctx) ir_if(operand(r0679).val);
                     exec_list *const f0678_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0678->then_instructions;

                        body.emit(assign(r0673, r0671, 0x01));

                        body.emit(assign(r0674, r064E, 0x01));

                        body.emit(assign(r0675, r064D, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0678->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r067B = less(r0672, body.constant(int(32)));
                        ir_if *f067A = new(mem_ctx) ir_if(operand(r067B).val);
                        exec_list *const f067A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f067A->then_instructions;

                           body.emit(assign(r0673, lshift(r064E, r0676), 0x01));

                           ir_expression *const r067C = lshift(r064D, r0676);
                           ir_expression *const r067D = rshift(r064E, r0672);
                           body.emit(assign(r0674, bit_or(r067C, r067D), 0x01));

                           body.emit(assign(r0675, rshift(r064D, r0672), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f067A->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r067F = equal(r0672, body.constant(int(32)));
                           ir_if *f067E = new(mem_ctx) ir_if(operand(r067F).val);
                           exec_list *const f067E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f067E->then_instructions;

                              body.emit(assign(r0673, r064E, 0x01));

                              body.emit(assign(r0674, r064D, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f067E->else_instructions;

                              body.emit(assign(r0671, bit_or(body.constant(0u), r064E), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0681 = less(r0672, body.constant(int(64)));
                              ir_if *f0680 = new(mem_ctx) ir_if(operand(r0681).val);
                              exec_list *const f0680_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0680->then_instructions;

                                 body.emit(assign(r0673, lshift(r064D, r0676), 0x01));

                                 ir_expression *const r0682 = bit_and(r0672, body.constant(int(31)));
                                 body.emit(assign(r0674, rshift(r064D, r0682), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0680->else_instructions;

                                 ir_variable *const r0683 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0685 = equal(r0672, body.constant(int(64)));
                                 ir_if *f0684 = new(mem_ctx) ir_if(operand(r0685).val);
                                 exec_list *const f0684_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0684->then_instructions;

                                    body.emit(assign(r0683, r064D, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0684->else_instructions;

                                    ir_expression *const r0686 = nequal(r064D, body.constant(0u));
                                    ir_expression *const r0687 = expr(ir_unop_b2i, r0686);
                                    body.emit(assign(r0683, expr(ir_unop_i2u, r0687), 0x01));


                                 body.instructions = f0684_parent_instructions;
                                 body.emit(f0684);

                                 /* END IF */

                                 body.emit(assign(r0673, r0683, 0x01));

                                 body.emit(assign(r0674, body.constant(0u), 0x01));


                              body.instructions = f0680_parent_instructions;
                              body.emit(f0680);

                              /* END IF */


                           body.instructions = f067E_parent_instructions;
                           body.emit(f067E);

                           /* END IF */

                           body.emit(assign(r0675, body.constant(0u), 0x01));


                        body.instructions = f067A_parent_instructions;
                        body.emit(f067A);

                        /* END IF */

                        ir_expression *const r0688 = nequal(r0671, body.constant(0u));
                        ir_expression *const r0689 = expr(ir_unop_b2i, r0688);
                        ir_expression *const r068A = expr(ir_unop_i2u, r0689);
                        body.emit(assign(r0673, bit_or(r0673, r068A), 0x01));


                     body.instructions = f0678_parent_instructions;
                     body.emit(f0678);

                     /* END IF */

                     body.emit(assign(r064D, r0675, 0x01));

                     body.emit(assign(r064E, r0674, 0x01));

                     body.emit(assign(r064F, r0673, 0x01));


                  body.instructions = f0667_parent_instructions;
                  body.emit(f0667);

                  /* END IF */

                  body.emit(assign(r064C, sub(r064C, r0650), 0x01));

                  ir_variable *const r068B = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r068B, r064C, 0x01));

                  ir_variable *const r068C = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r068C, r064D, 0x01));

                  ir_variable *const r068D = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r068D, r064E, 0x01));

                  ir_variable *const r068E = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r068E, r064F, 0x01));

                  ir_variable *const r068F = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r068F, body.constant(true), 0x01));

                  ir_variable *const r0690 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0691 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r0691);
                  ir_expression *const r0692 = expr(ir_unop_u2i, r064F);
                  body.emit(assign(r0691, less(r0692, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0694 = lequal(body.constant(int(2045)), r064C);
                  ir_if *f0693 = new(mem_ctx) ir_if(operand(r0694).val);
                  exec_list *const f0693_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0693->then_instructions;

                     ir_variable *const r0695 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0697 = less(body.constant(int(2045)), r064C);
                     ir_if *f0696 = new(mem_ctx) ir_if(operand(r0697).val);
                     exec_list *const f0696_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0696->then_instructions;

                        body.emit(assign(r0695, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0696->else_instructions;

                        ir_variable *const r0698 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r069A = equal(r064C, body.constant(int(2045)));
                        ir_if *f0699 = new(mem_ctx) ir_if(operand(r069A).val);
                        exec_list *const f0699_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0699->then_instructions;

                           ir_expression *const r069B = equal(body.constant(2097151u), r064D);
                           ir_expression *const r069C = equal(body.constant(4294967295u), r064E);
                           body.emit(assign(r0698, logic_and(r069B, r069C), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0699->else_instructions;

                           body.emit(assign(r0698, body.constant(false), 0x01));


                        body.instructions = f0699_parent_instructions;
                        body.emit(f0699);

                        /* END IF */

                        body.emit(assign(r0695, logic_and(r0698, r0691), 0x01));


                     body.instructions = f0696_parent_instructions;
                     body.emit(f0696);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f069D = new(mem_ctx) ir_if(operand(r0695).val);
                     exec_list *const f069D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f069D->then_instructions;

                        ir_variable *const r069E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r069E);
                        ir_expression *const r069F = lshift(r03D1, body.constant(int(31)));
                        body.emit(assign(r069E, add(r069F, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r069E, body.constant(0u), 0x01));

                        body.emit(assign(r0690, r069E, 0x03));

                        body.emit(assign(r068F, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f069D->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r06A1 = less(r064C, body.constant(int(0)));
                        ir_if *f06A0 = new(mem_ctx) ir_if(operand(r06A1).val);
                        exec_list *const f06A0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06A0->then_instructions;

                           ir_variable *const r06A2 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r06A2, r064F, 0x01));

                           ir_variable *const r06A3 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r06A3, neg(r064C), 0x01));

                           ir_variable *const r06A4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r06A4);
                           ir_variable *const r06A5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r06A5);
                           ir_variable *const r06A6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r06A6);
                           ir_variable *const r06A7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r06A8 = neg(r06A3);
                           body.emit(assign(r06A7, bit_and(r06A8, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r06AA = equal(r06A3, body.constant(int(0)));
                           ir_if *f06A9 = new(mem_ctx) ir_if(operand(r06AA).val);
                           exec_list *const f06A9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f06A9->then_instructions;

                              body.emit(assign(r06A4, r064F, 0x01));

                              body.emit(assign(r06A5, r064E, 0x01));

                              body.emit(assign(r06A6, r064D, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f06A9->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r06AC = less(r06A3, body.constant(int(32)));
                              ir_if *f06AB = new(mem_ctx) ir_if(operand(r06AC).val);
                              exec_list *const f06AB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f06AB->then_instructions;

                                 body.emit(assign(r06A4, lshift(r064E, r06A7), 0x01));

                                 ir_expression *const r06AD = lshift(r064D, r06A7);
                                 ir_expression *const r06AE = rshift(r064E, r06A3);
                                 body.emit(assign(r06A5, bit_or(r06AD, r06AE), 0x01));

                                 body.emit(assign(r06A6, rshift(r064D, r06A3), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f06AB->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r06B0 = equal(r06A3, body.constant(int(32)));
                                 ir_if *f06AF = new(mem_ctx) ir_if(operand(r06B0).val);
                                 exec_list *const f06AF_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f06AF->then_instructions;

                                    body.emit(assign(r06A4, r064E, 0x01));

                                    body.emit(assign(r06A5, r064D, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f06AF->else_instructions;

                                    body.emit(assign(r06A2, bit_or(r064F, r064E), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r06B2 = less(r06A3, body.constant(int(64)));
                                    ir_if *f06B1 = new(mem_ctx) ir_if(operand(r06B2).val);
                                    exec_list *const f06B1_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f06B1->then_instructions;

                                       body.emit(assign(r06A4, lshift(r064D, r06A7), 0x01));

                                       ir_expression *const r06B3 = bit_and(r06A3, body.constant(int(31)));
                                       body.emit(assign(r06A5, rshift(r064D, r06B3), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f06B1->else_instructions;

                                       ir_variable *const r06B4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r06B6 = equal(r06A3, body.constant(int(64)));
                                       ir_if *f06B5 = new(mem_ctx) ir_if(operand(r06B6).val);
                                       exec_list *const f06B5_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f06B5->then_instructions;

                                          body.emit(assign(r06B4, r064D, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f06B5->else_instructions;

                                          ir_expression *const r06B7 = nequal(r064D, body.constant(0u));
                                          ir_expression *const r06B8 = expr(ir_unop_b2i, r06B7);
                                          body.emit(assign(r06B4, expr(ir_unop_i2u, r06B8), 0x01));


                                       body.instructions = f06B5_parent_instructions;
                                       body.emit(f06B5);

                                       /* END IF */

                                       body.emit(assign(r06A4, r06B4, 0x01));

                                       body.emit(assign(r06A5, body.constant(0u), 0x01));


                                    body.instructions = f06B1_parent_instructions;
                                    body.emit(f06B1);

                                    /* END IF */


                                 body.instructions = f06AF_parent_instructions;
                                 body.emit(f06AF);

                                 /* END IF */

                                 body.emit(assign(r06A6, body.constant(0u), 0x01));


                              body.instructions = f06AB_parent_instructions;
                              body.emit(f06AB);

                              /* END IF */

                              ir_expression *const r06B9 = nequal(r06A2, body.constant(0u));
                              ir_expression *const r06BA = expr(ir_unop_b2i, r06B9);
                              ir_expression *const r06BB = expr(ir_unop_i2u, r06BA);
                              body.emit(assign(r06A4, bit_or(r06A4, r06BB), 0x01));


                           body.instructions = f06A9_parent_instructions;
                           body.emit(f06A9);

                           /* END IF */

                           body.emit(assign(r068C, r06A6, 0x01));

                           body.emit(assign(r068D, r06A5, 0x01));

                           body.emit(assign(r068E, r06A4, 0x01));

                           body.emit(assign(r068B, body.constant(int(0)), 0x01));

                           body.emit(assign(r0691, less(r06A4, body.constant(0u)), 0x01));


                        body.instructions = f06A0_parent_instructions;
                        body.emit(f06A0);

                        /* END IF */


                     body.instructions = f069D_parent_instructions;
                     body.emit(f069D);

                     /* END IF */


                  body.instructions = f0693_parent_instructions;
                  body.emit(f0693);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f06BC = new(mem_ctx) ir_if(operand(r068F).val);
                  exec_list *const f06BC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f06BC->then_instructions;

                     /* IF CONDITION */
                     ir_if *f06BD = new(mem_ctx) ir_if(operand(r0691).val);
                     exec_list *const f06BD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f06BD->then_instructions;

                        ir_variable *const r06BE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r06BE, add(r068D, body.constant(1u)), 0x01));

                        ir_expression *const r06BF = less(r06BE, r068D);
                        ir_expression *const r06C0 = expr(ir_unop_b2i, r06BF);
                        ir_expression *const r06C1 = expr(ir_unop_i2u, r06C0);
                        body.emit(assign(r068C, add(r068C, r06C1), 0x01));

                        ir_expression *const r06C2 = equal(r068E, body.constant(0u));
                        ir_expression *const r06C3 = expr(ir_unop_b2i, r06C2);
                        ir_expression *const r06C4 = expr(ir_unop_i2u, r06C3);
                        ir_expression *const r06C5 = add(r068E, r06C4);
                        ir_expression *const r06C6 = bit_and(r06C5, body.constant(1u));
                        ir_expression *const r06C7 = expr(ir_unop_bit_not, r06C6);
                        body.emit(assign(r068D, bit_and(r06BE, r06C7), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f06BD->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r06C9 = bit_or(r068C, r068D);
                        ir_expression *const r06CA = equal(r06C9, body.constant(0u));
                        ir_if *f06C8 = new(mem_ctx) ir_if(operand(r06CA).val);
                        exec_list *const f06C8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06C8->then_instructions;

                           body.emit(assign(r068B, body.constant(int(0)), 0x01));


                        body.instructions = f06C8_parent_instructions;
                        body.emit(f06C8);

                        /* END IF */


                     body.instructions = f06BD_parent_instructions;
                     body.emit(f06BD);

                     /* END IF */

                     ir_variable *const r06CB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r06CB);
                     ir_expression *const r06CC = lshift(r03D1, body.constant(int(31)));
                     ir_expression *const r06CD = expr(ir_unop_i2u, r068B);
                     ir_expression *const r06CE = lshift(r06CD, body.constant(int(20)));
                     ir_expression *const r06CF = add(r06CC, r06CE);
                     body.emit(assign(r06CB, add(r06CF, r068C), 0x02));

                     body.emit(assign(r06CB, r068D, 0x01));

                     body.emit(assign(r0690, r06CB, 0x03));

                     body.emit(assign(r068F, body.constant(false), 0x01));


                  body.instructions = f06BC_parent_instructions;
                  body.emit(f06BC);

                  /* END IF */

                  body.emit(assign(r03D2, r0690, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0644->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r06D1 = less(swizzle_x(r03D5), swizzle_x(r03D7));
                  ir_if *f06D0 = new(mem_ctx) ir_if(operand(r06D1).val);
                  exec_list *const f06D0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f06D0->then_instructions;

                     ir_variable *const r06D2 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r06D3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r06D3, sub(swizzle_x(r03D7), swizzle_x(r03D5)), 0x01));

                     ir_expression *const r06D4 = sub(swizzle_y(r03D7), swizzle_y(r03D5));
                     ir_expression *const r06D5 = less(swizzle_x(r03D7), swizzle_x(r03D5));
                     ir_expression *const r06D6 = expr(ir_unop_b2i, r06D5);
                     ir_expression *const r06D7 = expr(ir_unop_i2u, r06D6);
                     body.emit(assign(r06D2, sub(r06D4, r06D7), 0x01));

                     body.emit(assign(r03D8, add(r03D6, body.constant(int(-1))), 0x01));

                     ir_variable *const r06D8 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r06D8, add(r03D8, body.constant(int(-10))), 0x01));

                     ir_variable *const r06D9 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r06D9, r06D2, 0x01));

                     ir_variable *const r06DA = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r06DA, r06D3, 0x01));

                     ir_variable *const r06DB = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r06DB);
                     ir_variable *const r06DC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r06DC);
                     /* IF CONDITION */
                     ir_expression *const r06DE = equal(r06D2, body.constant(0u));
                     ir_if *f06DD = new(mem_ctx) ir_if(operand(r06DE).val);
                     exec_list *const f06DD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f06DD->then_instructions;

                        body.emit(assign(r06D9, r06D3, 0x01));

                        body.emit(assign(r06DA, body.constant(0u), 0x01));

                        body.emit(assign(r06D8, add(r06D8, body.constant(int(-32))), 0x01));


                     body.instructions = f06DD_parent_instructions;
                     body.emit(f06DD);

                     /* END IF */

                     ir_variable *const r06DF = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r06DF, r06D9, 0x01));

                     ir_variable *const r06E0 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r06E1 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r06E1);
                     /* IF CONDITION */
                     ir_expression *const r06E3 = equal(r06D9, body.constant(0u));
                     ir_if *f06E2 = new(mem_ctx) ir_if(operand(r06E3).val);
                     exec_list *const f06E2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f06E2->then_instructions;

                        body.emit(assign(r06E0, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f06E2->else_instructions;

                        body.emit(assign(r06E1, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r06E5 = bit_and(r06D9, body.constant(4294901760u));
                        ir_expression *const r06E6 = equal(r06E5, body.constant(0u));
                        ir_if *f06E4 = new(mem_ctx) ir_if(operand(r06E6).val);
                        exec_list *const f06E4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06E4->then_instructions;

                           body.emit(assign(r06E1, body.constant(int(16)), 0x01));

                           body.emit(assign(r06DF, lshift(r06D9, body.constant(int(16))), 0x01));


                        body.instructions = f06E4_parent_instructions;
                        body.emit(f06E4);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r06E8 = bit_and(r06DF, body.constant(4278190080u));
                        ir_expression *const r06E9 = equal(r06E8, body.constant(0u));
                        ir_if *f06E7 = new(mem_ctx) ir_if(operand(r06E9).val);
                        exec_list *const f06E7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06E7->then_instructions;

                           body.emit(assign(r06E1, add(r06E1, body.constant(int(8))), 0x01));

                           body.emit(assign(r06DF, lshift(r06DF, body.constant(int(8))), 0x01));


                        body.instructions = f06E7_parent_instructions;
                        body.emit(f06E7);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r06EB = bit_and(r06DF, body.constant(4026531840u));
                        ir_expression *const r06EC = equal(r06EB, body.constant(0u));
                        ir_if *f06EA = new(mem_ctx) ir_if(operand(r06EC).val);
                        exec_list *const f06EA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06EA->then_instructions;

                           body.emit(assign(r06E1, add(r06E1, body.constant(int(4))), 0x01));

                           body.emit(assign(r06DF, lshift(r06DF, body.constant(int(4))), 0x01));


                        body.instructions = f06EA_parent_instructions;
                        body.emit(f06EA);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r06EE = bit_and(r06DF, body.constant(3221225472u));
                        ir_expression *const r06EF = equal(r06EE, body.constant(0u));
                        ir_if *f06ED = new(mem_ctx) ir_if(operand(r06EF).val);
                        exec_list *const f06ED_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06ED->then_instructions;

                           body.emit(assign(r06E1, add(r06E1, body.constant(int(2))), 0x01));

                           body.emit(assign(r06DF, lshift(r06DF, body.constant(int(2))), 0x01));


                        body.instructions = f06ED_parent_instructions;
                        body.emit(f06ED);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r06F1 = bit_and(r06DF, body.constant(2147483648u));
                        ir_expression *const r06F2 = equal(r06F1, body.constant(0u));
                        ir_if *f06F0 = new(mem_ctx) ir_if(operand(r06F2).val);
                        exec_list *const f06F0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06F0->then_instructions;

                           body.emit(assign(r06E1, add(r06E1, body.constant(int(1))), 0x01));


                        body.instructions = f06F0_parent_instructions;
                        body.emit(f06F0);

                        /* END IF */

                        body.emit(assign(r06E0, r06E1, 0x01));


                     body.instructions = f06E2_parent_instructions;
                     body.emit(f06E2);

                     /* END IF */

                     body.emit(assign(r06DC, add(r06E0, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r06F4 = lequal(body.constant(int(0)), r06DC);
                     ir_if *f06F3 = new(mem_ctx) ir_if(operand(r06F4).val);
                     exec_list *const f06F3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f06F3->then_instructions;

                        body.emit(assign(r06DB, body.constant(0u), 0x01));

                        ir_variable *const r06F5 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r06F5, lshift(r06DA, r06DC), 0x01));

                        ir_variable *const r06F6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r06F8 = equal(r06DC, body.constant(int(0)));
                        ir_if *f06F7 = new(mem_ctx) ir_if(operand(r06F8).val);
                        exec_list *const f06F7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06F7->then_instructions;

                           body.emit(assign(r06F6, r06D9, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f06F7->else_instructions;

                           ir_expression *const r06F9 = lshift(r06D9, r06DC);
                           ir_expression *const r06FA = neg(r06DC);
                           ir_expression *const r06FB = bit_and(r06FA, body.constant(int(31)));
                           ir_expression *const r06FC = rshift(r06DA, r06FB);
                           body.emit(assign(r06F6, bit_or(r06F9, r06FC), 0x01));


                        body.instructions = f06F7_parent_instructions;
                        body.emit(f06F7);

                        /* END IF */

                        body.emit(assign(r06D9, r06F6, 0x01));

                        body.emit(assign(r06DA, r06F5, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f06F3->else_instructions;

                        ir_variable *const r06FD = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r06FD, body.constant(0u), 0x01));

                        ir_variable *const r06FE = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r06FE, neg(r06DC), 0x01));

                        ir_variable *const r06FF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r06FF);
                        ir_variable *const r0700 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0700);
                        ir_variable *const r0701 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0701);
                        ir_variable *const r0702 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r0703 = neg(r06FE);
                        body.emit(assign(r0702, bit_and(r0703, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0705 = equal(r06FE, body.constant(int(0)));
                        ir_if *f0704 = new(mem_ctx) ir_if(operand(r0705).val);
                        exec_list *const f0704_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0704->then_instructions;

                           body.emit(assign(r06FF, r06FD, 0x01));

                           body.emit(assign(r0700, r06DA, 0x01));

                           body.emit(assign(r0701, r06D9, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0704->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0707 = less(r06FE, body.constant(int(32)));
                           ir_if *f0706 = new(mem_ctx) ir_if(operand(r0707).val);
                           exec_list *const f0706_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0706->then_instructions;

                              body.emit(assign(r06FF, lshift(r06DA, r0702), 0x01));

                              ir_expression *const r0708 = lshift(r06D9, r0702);
                              ir_expression *const r0709 = rshift(r06DA, r06FE);
                              body.emit(assign(r0700, bit_or(r0708, r0709), 0x01));

                              body.emit(assign(r0701, rshift(r06D9, r06FE), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0706->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r070B = equal(r06FE, body.constant(int(32)));
                              ir_if *f070A = new(mem_ctx) ir_if(operand(r070B).val);
                              exec_list *const f070A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f070A->then_instructions;

                                 body.emit(assign(r06FF, r06DA, 0x01));

                                 body.emit(assign(r0700, r06D9, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f070A->else_instructions;

                                 body.emit(assign(r06FD, bit_or(body.constant(0u), r06DA), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r070D = less(r06FE, body.constant(int(64)));
                                 ir_if *f070C = new(mem_ctx) ir_if(operand(r070D).val);
                                 exec_list *const f070C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f070C->then_instructions;

                                    body.emit(assign(r06FF, lshift(r06D9, r0702), 0x01));

                                    ir_expression *const r070E = bit_and(r06FE, body.constant(int(31)));
                                    body.emit(assign(r0700, rshift(r06D9, r070E), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f070C->else_instructions;

                                    ir_variable *const r070F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r0711 = equal(r06FE, body.constant(int(64)));
                                    ir_if *f0710 = new(mem_ctx) ir_if(operand(r0711).val);
                                    exec_list *const f0710_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0710->then_instructions;

                                       body.emit(assign(r070F, r06D9, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0710->else_instructions;

                                       ir_expression *const r0712 = nequal(r06D9, body.constant(0u));
                                       ir_expression *const r0713 = expr(ir_unop_b2i, r0712);
                                       body.emit(assign(r070F, expr(ir_unop_i2u, r0713), 0x01));


                                    body.instructions = f0710_parent_instructions;
                                    body.emit(f0710);

                                    /* END IF */

                                    body.emit(assign(r06FF, r070F, 0x01));

                                    body.emit(assign(r0700, body.constant(0u), 0x01));


                                 body.instructions = f070C_parent_instructions;
                                 body.emit(f070C);

                                 /* END IF */


                              body.instructions = f070A_parent_instructions;
                              body.emit(f070A);

                              /* END IF */

                              body.emit(assign(r0701, body.constant(0u), 0x01));


                           body.instructions = f0706_parent_instructions;
                           body.emit(f0706);

                           /* END IF */

                           ir_expression *const r0714 = nequal(r06FD, body.constant(0u));
                           ir_expression *const r0715 = expr(ir_unop_b2i, r0714);
                           ir_expression *const r0716 = expr(ir_unop_i2u, r0715);
                           body.emit(assign(r06FF, bit_or(r06FF, r0716), 0x01));


                        body.instructions = f0704_parent_instructions;
                        body.emit(f0704);

                        /* END IF */

                        body.emit(assign(r06D9, r0701, 0x01));

                        body.emit(assign(r06DA, r0700, 0x01));

                        body.emit(assign(r06DB, r06FF, 0x01));


                     body.instructions = f06F3_parent_instructions;
                     body.emit(f06F3);

                     /* END IF */

                     body.emit(assign(r06D8, sub(r06D8, r06DC), 0x01));

                     ir_variable *const r0717 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r0717, r06D8, 0x01));

                     ir_variable *const r0718 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r0718, r06D9, 0x01));

                     ir_variable *const r0719 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r0719, r06DA, 0x01));

                     ir_variable *const r071A = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r071A, r06DB, 0x01));

                     ir_variable *const r071B = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r071B, body.constant(true), 0x01));

                     ir_variable *const r071C = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r071D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r071D);
                     ir_expression *const r071E = expr(ir_unop_u2i, r06DB);
                     body.emit(assign(r071D, less(r071E, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0720 = lequal(body.constant(int(2045)), r06D8);
                     ir_if *f071F = new(mem_ctx) ir_if(operand(r0720).val);
                     exec_list *const f071F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f071F->then_instructions;

                        ir_variable *const r0721 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0723 = less(body.constant(int(2045)), r06D8);
                        ir_if *f0722 = new(mem_ctx) ir_if(operand(r0723).val);
                        exec_list *const f0722_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0722->then_instructions;

                           body.emit(assign(r0721, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0722->else_instructions;

                           ir_variable *const r0724 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0726 = equal(r06D8, body.constant(int(2045)));
                           ir_if *f0725 = new(mem_ctx) ir_if(operand(r0726).val);
                           exec_list *const f0725_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0725->then_instructions;

                              ir_expression *const r0727 = equal(body.constant(2097151u), r06D9);
                              ir_expression *const r0728 = equal(body.constant(4294967295u), r06DA);
                              body.emit(assign(r0724, logic_and(r0727, r0728), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0725->else_instructions;

                              body.emit(assign(r0724, body.constant(false), 0x01));


                           body.instructions = f0725_parent_instructions;
                           body.emit(f0725);

                           /* END IF */

                           body.emit(assign(r0721, logic_and(r0724, r071D), 0x01));


                        body.instructions = f0722_parent_instructions;
                        body.emit(f0722);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f0729 = new(mem_ctx) ir_if(operand(r0721).val);
                        exec_list *const f0729_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0729->then_instructions;

                           ir_variable *const r072A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r072A);
                           ir_expression *const r072B = lshift(r03D1, body.constant(int(31)));
                           body.emit(assign(r072A, add(r072B, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r072A, body.constant(0u), 0x01));

                           body.emit(assign(r071C, r072A, 0x03));

                           body.emit(assign(r071B, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0729->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r072D = less(r06D8, body.constant(int(0)));
                           ir_if *f072C = new(mem_ctx) ir_if(operand(r072D).val);
                           exec_list *const f072C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f072C->then_instructions;

                              ir_variable *const r072E = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r072E, r06DB, 0x01));

                              ir_variable *const r072F = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r072F, neg(r06D8), 0x01));

                              ir_variable *const r0730 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r0730);
                              ir_variable *const r0731 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r0731);
                              ir_variable *const r0732 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r0732);
                              ir_variable *const r0733 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r0734 = neg(r072F);
                              body.emit(assign(r0733, bit_and(r0734, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0736 = equal(r072F, body.constant(int(0)));
                              ir_if *f0735 = new(mem_ctx) ir_if(operand(r0736).val);
                              exec_list *const f0735_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0735->then_instructions;

                                 body.emit(assign(r0730, r06DB, 0x01));

                                 body.emit(assign(r0731, r06DA, 0x01));

                                 body.emit(assign(r0732, r06D9, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0735->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0738 = less(r072F, body.constant(int(32)));
                                 ir_if *f0737 = new(mem_ctx) ir_if(operand(r0738).val);
                                 exec_list *const f0737_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0737->then_instructions;

                                    body.emit(assign(r0730, lshift(r06DA, r0733), 0x01));

                                    ir_expression *const r0739 = lshift(r06D9, r0733);
                                    ir_expression *const r073A = rshift(r06DA, r072F);
                                    body.emit(assign(r0731, bit_or(r0739, r073A), 0x01));

                                    body.emit(assign(r0732, rshift(r06D9, r072F), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0737->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r073C = equal(r072F, body.constant(int(32)));
                                    ir_if *f073B = new(mem_ctx) ir_if(operand(r073C).val);
                                    exec_list *const f073B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f073B->then_instructions;

                                       body.emit(assign(r0730, r06DA, 0x01));

                                       body.emit(assign(r0731, r06D9, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f073B->else_instructions;

                                       body.emit(assign(r072E, bit_or(r06DB, r06DA), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r073E = less(r072F, body.constant(int(64)));
                                       ir_if *f073D = new(mem_ctx) ir_if(operand(r073E).val);
                                       exec_list *const f073D_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f073D->then_instructions;

                                          body.emit(assign(r0730, lshift(r06D9, r0733), 0x01));

                                          ir_expression *const r073F = bit_and(r072F, body.constant(int(31)));
                                          body.emit(assign(r0731, rshift(r06D9, r073F), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f073D->else_instructions;

                                          ir_variable *const r0740 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r0742 = equal(r072F, body.constant(int(64)));
                                          ir_if *f0741 = new(mem_ctx) ir_if(operand(r0742).val);
                                          exec_list *const f0741_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0741->then_instructions;

                                             body.emit(assign(r0740, r06D9, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0741->else_instructions;

                                             ir_expression *const r0743 = nequal(r06D9, body.constant(0u));
                                             ir_expression *const r0744 = expr(ir_unop_b2i, r0743);
                                             body.emit(assign(r0740, expr(ir_unop_i2u, r0744), 0x01));


                                          body.instructions = f0741_parent_instructions;
                                          body.emit(f0741);

                                          /* END IF */

                                          body.emit(assign(r0730, r0740, 0x01));

                                          body.emit(assign(r0731, body.constant(0u), 0x01));


                                       body.instructions = f073D_parent_instructions;
                                       body.emit(f073D);

                                       /* END IF */


                                    body.instructions = f073B_parent_instructions;
                                    body.emit(f073B);

                                    /* END IF */

                                    body.emit(assign(r0732, body.constant(0u), 0x01));


                                 body.instructions = f0737_parent_instructions;
                                 body.emit(f0737);

                                 /* END IF */

                                 ir_expression *const r0745 = nequal(r072E, body.constant(0u));
                                 ir_expression *const r0746 = expr(ir_unop_b2i, r0745);
                                 ir_expression *const r0747 = expr(ir_unop_i2u, r0746);
                                 body.emit(assign(r0730, bit_or(r0730, r0747), 0x01));


                              body.instructions = f0735_parent_instructions;
                              body.emit(f0735);

                              /* END IF */

                              body.emit(assign(r0718, r0732, 0x01));

                              body.emit(assign(r0719, r0731, 0x01));

                              body.emit(assign(r071A, r0730, 0x01));

                              body.emit(assign(r0717, body.constant(int(0)), 0x01));

                              body.emit(assign(r071D, less(r0730, body.constant(0u)), 0x01));


                           body.instructions = f072C_parent_instructions;
                           body.emit(f072C);

                           /* END IF */


                        body.instructions = f0729_parent_instructions;
                        body.emit(f0729);

                        /* END IF */


                     body.instructions = f071F_parent_instructions;
                     body.emit(f071F);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f0748 = new(mem_ctx) ir_if(operand(r071B).val);
                     exec_list *const f0748_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0748->then_instructions;

                        /* IF CONDITION */
                        ir_if *f0749 = new(mem_ctx) ir_if(operand(r071D).val);
                        exec_list *const f0749_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0749->then_instructions;

                           ir_variable *const r074A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r074A, add(r0719, body.constant(1u)), 0x01));

                           ir_expression *const r074B = less(r074A, r0719);
                           ir_expression *const r074C = expr(ir_unop_b2i, r074B);
                           ir_expression *const r074D = expr(ir_unop_i2u, r074C);
                           body.emit(assign(r0718, add(r0718, r074D), 0x01));

                           ir_expression *const r074E = equal(r071A, body.constant(0u));
                           ir_expression *const r074F = expr(ir_unop_b2i, r074E);
                           ir_expression *const r0750 = expr(ir_unop_i2u, r074F);
                           ir_expression *const r0751 = add(r071A, r0750);
                           ir_expression *const r0752 = bit_and(r0751, body.constant(1u));
                           ir_expression *const r0753 = expr(ir_unop_bit_not, r0752);
                           body.emit(assign(r0719, bit_and(r074A, r0753), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0749->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0755 = bit_or(r0718, r0719);
                           ir_expression *const r0756 = equal(r0755, body.constant(0u));
                           ir_if *f0754 = new(mem_ctx) ir_if(operand(r0756).val);
                           exec_list *const f0754_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0754->then_instructions;

                              body.emit(assign(r0717, body.constant(int(0)), 0x01));


                           body.instructions = f0754_parent_instructions;
                           body.emit(f0754);

                           /* END IF */


                        body.instructions = f0749_parent_instructions;
                        body.emit(f0749);

                        /* END IF */

                        ir_variable *const r0757 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r0757);
                        ir_expression *const r0758 = lshift(r03D1, body.constant(int(31)));
                        ir_expression *const r0759 = expr(ir_unop_i2u, r0717);
                        ir_expression *const r075A = lshift(r0759, body.constant(int(20)));
                        ir_expression *const r075B = add(r0758, r075A);
                        body.emit(assign(r0757, add(r075B, r0718), 0x02));

                        body.emit(assign(r0757, r0719, 0x01));

                        body.emit(assign(r071C, r0757, 0x03));

                        body.emit(assign(r071B, body.constant(false), 0x01));


                     body.instructions = f0748_parent_instructions;
                     body.emit(f0748);

                     /* END IF */

                     body.emit(assign(r03D2, r071C, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f06D0->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r075D = less(swizzle_x(r03D7), swizzle_x(r03D5));
                     ir_if *f075C = new(mem_ctx) ir_if(operand(r075D).val);
                     exec_list *const f075C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f075C->then_instructions;

                        ir_variable *const r075E = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r075F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r075F, sub(swizzle_x(r03D5), swizzle_x(r03D7)), 0x01));

                        ir_expression *const r0760 = sub(swizzle_y(r03D5), swizzle_y(r03D7));
                        ir_expression *const r0761 = less(swizzle_x(r03D5), swizzle_x(r03D7));
                        ir_expression *const r0762 = expr(ir_unop_b2i, r0761);
                        ir_expression *const r0763 = expr(ir_unop_i2u, r0762);
                        body.emit(assign(r075E, sub(r0760, r0763), 0x01));

                        body.emit(assign(r03D1, bit_xor(r03D1, body.constant(1u)), 0x01));

                        body.emit(assign(r03D8, add(r03D4, body.constant(int(-1))), 0x01));

                        ir_variable *const r0764 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r0764, add(r03D8, body.constant(int(-10))), 0x01));

                        ir_variable *const r0765 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r0765, r075E, 0x01));

                        ir_variable *const r0766 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r0766, r075F, 0x01));

                        ir_variable *const r0767 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r0767);
                        ir_variable *const r0768 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r0768);
                        /* IF CONDITION */
                        ir_expression *const r076A = equal(r075E, body.constant(0u));
                        ir_if *f0769 = new(mem_ctx) ir_if(operand(r076A).val);
                        exec_list *const f0769_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0769->then_instructions;

                           body.emit(assign(r0765, r075F, 0x01));

                           body.emit(assign(r0766, body.constant(0u), 0x01));

                           body.emit(assign(r0764, add(r0764, body.constant(int(-32))), 0x01));


                        body.instructions = f0769_parent_instructions;
                        body.emit(f0769);

                        /* END IF */

                        ir_variable *const r076B = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r076B, r0765, 0x01));

                        ir_variable *const r076C = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r076D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r076D);
                        /* IF CONDITION */
                        ir_expression *const r076F = equal(r0765, body.constant(0u));
                        ir_if *f076E = new(mem_ctx) ir_if(operand(r076F).val);
                        exec_list *const f076E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f076E->then_instructions;

                           body.emit(assign(r076C, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f076E->else_instructions;

                           body.emit(assign(r076D, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0771 = bit_and(r0765, body.constant(4294901760u));
                           ir_expression *const r0772 = equal(r0771, body.constant(0u));
                           ir_if *f0770 = new(mem_ctx) ir_if(operand(r0772).val);
                           exec_list *const f0770_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0770->then_instructions;

                              body.emit(assign(r076D, body.constant(int(16)), 0x01));

                              body.emit(assign(r076B, lshift(r0765, body.constant(int(16))), 0x01));


                           body.instructions = f0770_parent_instructions;
                           body.emit(f0770);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0774 = bit_and(r076B, body.constant(4278190080u));
                           ir_expression *const r0775 = equal(r0774, body.constant(0u));
                           ir_if *f0773 = new(mem_ctx) ir_if(operand(r0775).val);
                           exec_list *const f0773_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0773->then_instructions;

                              body.emit(assign(r076D, add(r076D, body.constant(int(8))), 0x01));

                              body.emit(assign(r076B, lshift(r076B, body.constant(int(8))), 0x01));


                           body.instructions = f0773_parent_instructions;
                           body.emit(f0773);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0777 = bit_and(r076B, body.constant(4026531840u));
                           ir_expression *const r0778 = equal(r0777, body.constant(0u));
                           ir_if *f0776 = new(mem_ctx) ir_if(operand(r0778).val);
                           exec_list *const f0776_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0776->then_instructions;

                              body.emit(assign(r076D, add(r076D, body.constant(int(4))), 0x01));

                              body.emit(assign(r076B, lshift(r076B, body.constant(int(4))), 0x01));


                           body.instructions = f0776_parent_instructions;
                           body.emit(f0776);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r077A = bit_and(r076B, body.constant(3221225472u));
                           ir_expression *const r077B = equal(r077A, body.constant(0u));
                           ir_if *f0779 = new(mem_ctx) ir_if(operand(r077B).val);
                           exec_list *const f0779_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0779->then_instructions;

                              body.emit(assign(r076D, add(r076D, body.constant(int(2))), 0x01));

                              body.emit(assign(r076B, lshift(r076B, body.constant(int(2))), 0x01));


                           body.instructions = f0779_parent_instructions;
                           body.emit(f0779);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r077D = bit_and(r076B, body.constant(2147483648u));
                           ir_expression *const r077E = equal(r077D, body.constant(0u));
                           ir_if *f077C = new(mem_ctx) ir_if(operand(r077E).val);
                           exec_list *const f077C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f077C->then_instructions;

                              body.emit(assign(r076D, add(r076D, body.constant(int(1))), 0x01));


                           body.instructions = f077C_parent_instructions;
                           body.emit(f077C);

                           /* END IF */

                           body.emit(assign(r076C, r076D, 0x01));


                        body.instructions = f076E_parent_instructions;
                        body.emit(f076E);

                        /* END IF */

                        body.emit(assign(r0768, add(r076C, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0780 = lequal(body.constant(int(0)), r0768);
                        ir_if *f077F = new(mem_ctx) ir_if(operand(r0780).val);
                        exec_list *const f077F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f077F->then_instructions;

                           body.emit(assign(r0767, body.constant(0u), 0x01));

                           ir_variable *const r0781 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r0781, lshift(r0766, r0768), 0x01));

                           ir_variable *const r0782 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0784 = equal(r0768, body.constant(int(0)));
                           ir_if *f0783 = new(mem_ctx) ir_if(operand(r0784).val);
                           exec_list *const f0783_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0783->then_instructions;

                              body.emit(assign(r0782, r0765, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0783->else_instructions;

                              ir_expression *const r0785 = lshift(r0765, r0768);
                              ir_expression *const r0786 = neg(r0768);
                              ir_expression *const r0787 = bit_and(r0786, body.constant(int(31)));
                              ir_expression *const r0788 = rshift(r0766, r0787);
                              body.emit(assign(r0782, bit_or(r0785, r0788), 0x01));


                           body.instructions = f0783_parent_instructions;
                           body.emit(f0783);

                           /* END IF */

                           body.emit(assign(r0765, r0782, 0x01));

                           body.emit(assign(r0766, r0781, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f077F->else_instructions;

                           ir_variable *const r0789 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r0789, body.constant(0u), 0x01));

                           ir_variable *const r078A = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r078A, neg(r0768), 0x01));

                           ir_variable *const r078B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r078B);
                           ir_variable *const r078C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r078C);
                           ir_variable *const r078D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r078D);
                           ir_variable *const r078E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r078F = neg(r078A);
                           body.emit(assign(r078E, bit_and(r078F, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0791 = equal(r078A, body.constant(int(0)));
                           ir_if *f0790 = new(mem_ctx) ir_if(operand(r0791).val);
                           exec_list *const f0790_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0790->then_instructions;

                              body.emit(assign(r078B, r0789, 0x01));

                              body.emit(assign(r078C, r0766, 0x01));

                              body.emit(assign(r078D, r0765, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0790->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0793 = less(r078A, body.constant(int(32)));
                              ir_if *f0792 = new(mem_ctx) ir_if(operand(r0793).val);
                              exec_list *const f0792_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0792->then_instructions;

                                 body.emit(assign(r078B, lshift(r0766, r078E), 0x01));

                                 ir_expression *const r0794 = lshift(r0765, r078E);
                                 ir_expression *const r0795 = rshift(r0766, r078A);
                                 body.emit(assign(r078C, bit_or(r0794, r0795), 0x01));

                                 body.emit(assign(r078D, rshift(r0765, r078A), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0792->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0797 = equal(r078A, body.constant(int(32)));
                                 ir_if *f0796 = new(mem_ctx) ir_if(operand(r0797).val);
                                 exec_list *const f0796_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0796->then_instructions;

                                    body.emit(assign(r078B, r0766, 0x01));

                                    body.emit(assign(r078C, r0765, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0796->else_instructions;

                                    body.emit(assign(r0789, bit_or(body.constant(0u), r0766), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r0799 = less(r078A, body.constant(int(64)));
                                    ir_if *f0798 = new(mem_ctx) ir_if(operand(r0799).val);
                                    exec_list *const f0798_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0798->then_instructions;

                                       body.emit(assign(r078B, lshift(r0765, r078E), 0x01));

                                       ir_expression *const r079A = bit_and(r078A, body.constant(int(31)));
                                       body.emit(assign(r078C, rshift(r0765, r079A), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0798->else_instructions;

                                       ir_variable *const r079B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r079D = equal(r078A, body.constant(int(64)));
                                       ir_if *f079C = new(mem_ctx) ir_if(operand(r079D).val);
                                       exec_list *const f079C_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f079C->then_instructions;

                                          body.emit(assign(r079B, r0765, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f079C->else_instructions;

                                          ir_expression *const r079E = nequal(r0765, body.constant(0u));
                                          ir_expression *const r079F = expr(ir_unop_b2i, r079E);
                                          body.emit(assign(r079B, expr(ir_unop_i2u, r079F), 0x01));


                                       body.instructions = f079C_parent_instructions;
                                       body.emit(f079C);

                                       /* END IF */

                                       body.emit(assign(r078B, r079B, 0x01));

                                       body.emit(assign(r078C, body.constant(0u), 0x01));


                                    body.instructions = f0798_parent_instructions;
                                    body.emit(f0798);

                                    /* END IF */


                                 body.instructions = f0796_parent_instructions;
                                 body.emit(f0796);

                                 /* END IF */

                                 body.emit(assign(r078D, body.constant(0u), 0x01));


                              body.instructions = f0792_parent_instructions;
                              body.emit(f0792);

                              /* END IF */

                              ir_expression *const r07A0 = nequal(r0789, body.constant(0u));
                              ir_expression *const r07A1 = expr(ir_unop_b2i, r07A0);
                              ir_expression *const r07A2 = expr(ir_unop_i2u, r07A1);
                              body.emit(assign(r078B, bit_or(r078B, r07A2), 0x01));


                           body.instructions = f0790_parent_instructions;
                           body.emit(f0790);

                           /* END IF */

                           body.emit(assign(r0765, r078D, 0x01));

                           body.emit(assign(r0766, r078C, 0x01));

                           body.emit(assign(r0767, r078B, 0x01));


                        body.instructions = f077F_parent_instructions;
                        body.emit(f077F);

                        /* END IF */

                        body.emit(assign(r0764, sub(r0764, r0768), 0x01));

                        ir_variable *const r07A3 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r07A3, r0764, 0x01));

                        ir_variable *const r07A4 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r07A4, r0765, 0x01));

                        ir_variable *const r07A5 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r07A5, r0766, 0x01));

                        ir_variable *const r07A6 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r07A6, r0767, 0x01));

                        ir_variable *const r07A7 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r07A7, body.constant(true), 0x01));

                        ir_variable *const r07A8 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r07A9 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r07A9);
                        ir_expression *const r07AA = expr(ir_unop_u2i, r0767);
                        body.emit(assign(r07A9, less(r07AA, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r07AC = lequal(body.constant(int(2045)), r0764);
                        ir_if *f07AB = new(mem_ctx) ir_if(operand(r07AC).val);
                        exec_list *const f07AB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f07AB->then_instructions;

                           ir_variable *const r07AD = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r07AF = less(body.constant(int(2045)), r0764);
                           ir_if *f07AE = new(mem_ctx) ir_if(operand(r07AF).val);
                           exec_list *const f07AE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f07AE->then_instructions;

                              body.emit(assign(r07AD, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f07AE->else_instructions;

                              ir_variable *const r07B0 = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r07B2 = equal(r0764, body.constant(int(2045)));
                              ir_if *f07B1 = new(mem_ctx) ir_if(operand(r07B2).val);
                              exec_list *const f07B1_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f07B1->then_instructions;

                                 ir_expression *const r07B3 = equal(body.constant(2097151u), r0765);
                                 ir_expression *const r07B4 = equal(body.constant(4294967295u), r0766);
                                 body.emit(assign(r07B0, logic_and(r07B3, r07B4), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f07B1->else_instructions;

                                 body.emit(assign(r07B0, body.constant(false), 0x01));


                              body.instructions = f07B1_parent_instructions;
                              body.emit(f07B1);

                              /* END IF */

                              body.emit(assign(r07AD, logic_and(r07B0, r07A9), 0x01));


                           body.instructions = f07AE_parent_instructions;
                           body.emit(f07AE);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f07B5 = new(mem_ctx) ir_if(operand(r07AD).val);
                           exec_list *const f07B5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f07B5->then_instructions;

                              ir_variable *const r07B6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r07B6);
                              ir_expression *const r07B7 = lshift(r03D1, body.constant(int(31)));
                              body.emit(assign(r07B6, add(r07B7, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r07B6, body.constant(0u), 0x01));

                              body.emit(assign(r07A8, r07B6, 0x03));

                              body.emit(assign(r07A7, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f07B5->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r07B9 = less(r0764, body.constant(int(0)));
                              ir_if *f07B8 = new(mem_ctx) ir_if(operand(r07B9).val);
                              exec_list *const f07B8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f07B8->then_instructions;

                                 ir_variable *const r07BA = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r07BA, r0767, 0x01));

                                 ir_variable *const r07BB = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r07BB, neg(r0764), 0x01));

                                 ir_variable *const r07BC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r07BC);
                                 ir_variable *const r07BD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r07BD);
                                 ir_variable *const r07BE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r07BE);
                                 ir_variable *const r07BF = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r07C0 = neg(r07BB);
                                 body.emit(assign(r07BF, bit_and(r07C0, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r07C2 = equal(r07BB, body.constant(int(0)));
                                 ir_if *f07C1 = new(mem_ctx) ir_if(operand(r07C2).val);
                                 exec_list *const f07C1_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f07C1->then_instructions;

                                    body.emit(assign(r07BC, r0767, 0x01));

                                    body.emit(assign(r07BD, r0766, 0x01));

                                    body.emit(assign(r07BE, r0765, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f07C1->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r07C4 = less(r07BB, body.constant(int(32)));
                                    ir_if *f07C3 = new(mem_ctx) ir_if(operand(r07C4).val);
                                    exec_list *const f07C3_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f07C3->then_instructions;

                                       body.emit(assign(r07BC, lshift(r0766, r07BF), 0x01));

                                       ir_expression *const r07C5 = lshift(r0765, r07BF);
                                       ir_expression *const r07C6 = rshift(r0766, r07BB);
                                       body.emit(assign(r07BD, bit_or(r07C5, r07C6), 0x01));

                                       body.emit(assign(r07BE, rshift(r0765, r07BB), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f07C3->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r07C8 = equal(r07BB, body.constant(int(32)));
                                       ir_if *f07C7 = new(mem_ctx) ir_if(operand(r07C8).val);
                                       exec_list *const f07C7_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f07C7->then_instructions;

                                          body.emit(assign(r07BC, r0766, 0x01));

                                          body.emit(assign(r07BD, r0765, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f07C7->else_instructions;

                                          body.emit(assign(r07BA, bit_or(r0767, r0766), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r07CA = less(r07BB, body.constant(int(64)));
                                          ir_if *f07C9 = new(mem_ctx) ir_if(operand(r07CA).val);
                                          exec_list *const f07C9_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f07C9->then_instructions;

                                             body.emit(assign(r07BC, lshift(r0765, r07BF), 0x01));

                                             ir_expression *const r07CB = bit_and(r07BB, body.constant(int(31)));
                                             body.emit(assign(r07BD, rshift(r0765, r07CB), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f07C9->else_instructions;

                                             ir_variable *const r07CC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r07CE = equal(r07BB, body.constant(int(64)));
                                             ir_if *f07CD = new(mem_ctx) ir_if(operand(r07CE).val);
                                             exec_list *const f07CD_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f07CD->then_instructions;

                                                body.emit(assign(r07CC, r0765, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f07CD->else_instructions;

                                                ir_expression *const r07CF = nequal(r0765, body.constant(0u));
                                                ir_expression *const r07D0 = expr(ir_unop_b2i, r07CF);
                                                body.emit(assign(r07CC, expr(ir_unop_i2u, r07D0), 0x01));


                                             body.instructions = f07CD_parent_instructions;
                                             body.emit(f07CD);

                                             /* END IF */

                                             body.emit(assign(r07BC, r07CC, 0x01));

                                             body.emit(assign(r07BD, body.constant(0u), 0x01));


                                          body.instructions = f07C9_parent_instructions;
                                          body.emit(f07C9);

                                          /* END IF */


                                       body.instructions = f07C7_parent_instructions;
                                       body.emit(f07C7);

                                       /* END IF */

                                       body.emit(assign(r07BE, body.constant(0u), 0x01));


                                    body.instructions = f07C3_parent_instructions;
                                    body.emit(f07C3);

                                    /* END IF */

                                    ir_expression *const r07D1 = nequal(r07BA, body.constant(0u));
                                    ir_expression *const r07D2 = expr(ir_unop_b2i, r07D1);
                                    ir_expression *const r07D3 = expr(ir_unop_i2u, r07D2);
                                    body.emit(assign(r07BC, bit_or(r07BC, r07D3), 0x01));


                                 body.instructions = f07C1_parent_instructions;
                                 body.emit(f07C1);

                                 /* END IF */

                                 body.emit(assign(r07A4, r07BE, 0x01));

                                 body.emit(assign(r07A5, r07BD, 0x01));

                                 body.emit(assign(r07A6, r07BC, 0x01));

                                 body.emit(assign(r07A3, body.constant(int(0)), 0x01));

                                 body.emit(assign(r07A9, less(r07BC, body.constant(0u)), 0x01));


                              body.instructions = f07B8_parent_instructions;
                              body.emit(f07B8);

                              /* END IF */


                           body.instructions = f07B5_parent_instructions;
                           body.emit(f07B5);

                           /* END IF */


                        body.instructions = f07AB_parent_instructions;
                        body.emit(f07AB);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f07D4 = new(mem_ctx) ir_if(operand(r07A7).val);
                        exec_list *const f07D4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f07D4->then_instructions;

                           /* IF CONDITION */
                           ir_if *f07D5 = new(mem_ctx) ir_if(operand(r07A9).val);
                           exec_list *const f07D5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f07D5->then_instructions;

                              ir_variable *const r07D6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r07D6, add(r07A5, body.constant(1u)), 0x01));

                              ir_expression *const r07D7 = less(r07D6, r07A5);
                              ir_expression *const r07D8 = expr(ir_unop_b2i, r07D7);
                              ir_expression *const r07D9 = expr(ir_unop_i2u, r07D8);
                              body.emit(assign(r07A4, add(r07A4, r07D9), 0x01));

                              ir_expression *const r07DA = equal(r07A6, body.constant(0u));
                              ir_expression *const r07DB = expr(ir_unop_b2i, r07DA);
                              ir_expression *const r07DC = expr(ir_unop_i2u, r07DB);
                              ir_expression *const r07DD = add(r07A6, r07DC);
                              ir_expression *const r07DE = bit_and(r07DD, body.constant(1u));
                              ir_expression *const r07DF = expr(ir_unop_bit_not, r07DE);
                              body.emit(assign(r07A5, bit_and(r07D6, r07DF), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f07D5->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r07E1 = bit_or(r07A4, r07A5);
                              ir_expression *const r07E2 = equal(r07E1, body.constant(0u));
                              ir_if *f07E0 = new(mem_ctx) ir_if(operand(r07E2).val);
                              exec_list *const f07E0_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f07E0->then_instructions;

                                 body.emit(assign(r07A3, body.constant(int(0)), 0x01));


                              body.instructions = f07E0_parent_instructions;
                              body.emit(f07E0);

                              /* END IF */


                           body.instructions = f07D5_parent_instructions;
                           body.emit(f07D5);

                           /* END IF */

                           ir_variable *const r07E3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r07E3);
                           ir_expression *const r07E4 = lshift(r03D1, body.constant(int(31)));
                           ir_expression *const r07E5 = expr(ir_unop_i2u, r07A3);
                           ir_expression *const r07E6 = lshift(r07E5, body.constant(int(20)));
                           ir_expression *const r07E7 = add(r07E4, r07E6);
                           body.emit(assign(r07E3, add(r07E7, r07A4), 0x02));

                           body.emit(assign(r07E3, r07A5, 0x01));

                           body.emit(assign(r07A8, r07E3, 0x03));

                           body.emit(assign(r07A7, body.constant(false), 0x01));


                        body.instructions = f07D4_parent_instructions;
                        body.emit(f07D4);

                        /* END IF */

                        body.emit(assign(r03D2, r07A8, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f075C->else_instructions;

                        ir_variable *const r07E8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r07E8);
                        body.emit(assign(r07E8, body.constant(0u), 0x02));

                        body.emit(assign(r07E8, body.constant(0u), 0x01));

                        body.emit(assign(r03D2, r07E8, 0x03));


                     body.instructions = f075C_parent_instructions;
                     body.emit(f075C);

                     /* END IF */


                  body.instructions = f06D0_parent_instructions;
                  body.emit(f06D0);

                  /* END IF */


               body.instructions = f0644_parent_instructions;
               body.emit(f0644);

               /* END IF */


            body.instructions = f05B8_parent_instructions;
            body.emit(f05B8);

            /* END IF */


         body.instructions = f0591_parent_instructions;
         body.emit(f0591);

         /* END IF */


      body.instructions = f04BB_parent_instructions;
      body.emit(f04BB);

      /* END IF */


   body.instructions = f03E9_parent_instructions;
   body.emit(f03E9);

   /* END IF */

   body.emit(ret(r03D2));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fadd64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r07E9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r07E9);
   ir_variable *const r07EA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r07EA);
   ir_variable *const r07EB = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r07EC = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r07EC, rshift(swizzle_y(r07E9), body.constant(int(31))), 0x01));

   ir_variable *const r07ED = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r07ED, rshift(swizzle_y(r07EA), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r07EF = equal(r07EC, r07ED);
   ir_if *f07EE = new(mem_ctx) ir_if(operand(r07EF).val);
   exec_list *const f07EE_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f07EE->then_instructions;

      ir_variable *const r07F0 = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r07F0, body.constant(true), 0x01));

      ir_variable *const r07F1 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r07F2 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r07F2);
      ir_variable *const r07F3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
      body.emit(r07F3);
      ir_variable *const r07F4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
      body.emit(r07F4);
      ir_variable *const r07F5 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r07F5);
      ir_variable *const r07F6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
      body.emit(r07F6);
      ir_variable *const r07F7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
      body.emit(r07F7);
      body.emit(assign(r07F7, body.constant(0u), 0x01));

      body.emit(assign(r07F6, body.constant(0u), 0x01));

      ir_variable *const r07F8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r07F8);
      body.emit(assign(r07F8, bit_and(swizzle_y(r07E9), body.constant(1048575u)), 0x02));

      body.emit(assign(r07F8, swizzle_x(r07E9), 0x01));

      body.emit(assign(r07F4, r07F8, 0x03));

      ir_variable *const r07F9 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r07FA = rshift(swizzle_y(r07E9), body.constant(int(20)));
      ir_expression *const r07FB = bit_and(r07FA, body.constant(2047u));
      body.emit(assign(r07F9, expr(ir_unop_u2i, r07FB), 0x01));

      ir_variable *const r07FC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r07FC);
      body.emit(assign(r07FC, bit_and(swizzle_y(r07EA), body.constant(1048575u)), 0x02));

      body.emit(assign(r07FC, swizzle_x(r07EA), 0x01));

      body.emit(assign(r07F3, r07FC, 0x03));

      ir_variable *const r07FD = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r07FE = rshift(swizzle_y(r07EA), body.constant(int(20)));
      ir_expression *const r07FF = bit_and(r07FE, body.constant(2047u));
      body.emit(assign(r07FD, expr(ir_unop_u2i, r07FF), 0x01));

      ir_variable *const r0800 = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r0800, sub(r07F9, r07FD), 0x01));

      body.emit(assign(r07F2, r0800, 0x01));

      /* IF CONDITION */
      ir_expression *const r0802 = less(body.constant(int(0)), r0800);
      ir_if *f0801 = new(mem_ctx) ir_if(operand(r0802).val);
      exec_list *const f0801_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0801->then_instructions;

         /* IF CONDITION */
         ir_expression *const r0804 = equal(r07F9, body.constant(int(2047)));
         ir_if *f0803 = new(mem_ctx) ir_if(operand(r0804).val);
         exec_list *const f0803_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0803->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0806 = bit_or(swizzle_y(r07F8), swizzle_x(r07E9));
            ir_expression *const r0807 = nequal(r0806, body.constant(0u));
            ir_if *f0805 = new(mem_ctx) ir_if(operand(r0807).val);
            exec_list *const f0805_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0805->then_instructions;

               ir_variable *const r0808 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r0808, swizzle_x(r07E9), 0x01));

               ir_variable *const r0809 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r0809, swizzle_x(r07EA), 0x01));

               ir_variable *const r080A = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r080B = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r080C = rshift(swizzle_y(r07E9), body.constant(int(19)));
               ir_expression *const r080D = bit_and(r080C, body.constant(4095u));
               ir_expression *const r080E = equal(r080D, body.constant(4094u));
               ir_expression *const r080F = nequal(swizzle_x(r07E9), body.constant(0u));
               ir_expression *const r0810 = bit_and(swizzle_y(r07E9), body.constant(524287u));
               ir_expression *const r0811 = nequal(r0810, body.constant(0u));
               ir_expression *const r0812 = logic_or(r080F, r0811);
               body.emit(assign(r080B, logic_and(r080E, r0812), 0x01));

               ir_variable *const r0813 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r0814 = lshift(swizzle_y(r07EA), body.constant(int(1)));
               ir_expression *const r0815 = lequal(body.constant(4292870144u), r0814);
               ir_expression *const r0816 = nequal(swizzle_x(r07EA), body.constant(0u));
               ir_expression *const r0817 = bit_and(swizzle_y(r07EA), body.constant(1048575u));
               ir_expression *const r0818 = nequal(r0817, body.constant(0u));
               ir_expression *const r0819 = logic_or(r0816, r0818);
               body.emit(assign(r0813, logic_and(r0815, r0819), 0x01));

               body.emit(assign(r0808, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

               body.emit(assign(r0809, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r081B = lshift(swizzle_y(r07E9), body.constant(int(1)));
               ir_expression *const r081C = lequal(body.constant(4292870144u), r081B);
               ir_expression *const r081D = nequal(swizzle_x(r07E9), body.constant(0u));
               ir_expression *const r081E = bit_and(swizzle_y(r07E9), body.constant(1048575u));
               ir_expression *const r081F = nequal(r081E, body.constant(0u));
               ir_expression *const r0820 = logic_or(r081D, r081F);
               ir_expression *const r0821 = logic_and(r081C, r0820);
               ir_if *f081A = new(mem_ctx) ir_if(operand(r0821).val);
               exec_list *const f081A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f081A->then_instructions;

                  ir_variable *const r0822 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0824 = logic_and(r080B, r0813);
                  ir_if *f0823 = new(mem_ctx) ir_if(operand(r0824).val);
                  exec_list *const f0823_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0823->then_instructions;

                     body.emit(assign(r0822, r0809, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0823->else_instructions;

                     body.emit(assign(r0822, r0808, 0x03));


                  body.instructions = f0823_parent_instructions;
                  body.emit(f0823);

                  /* END IF */

                  body.emit(assign(r080A, r0822, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f081A->else_instructions;

                  body.emit(assign(r080A, r0809, 0x03));


               body.instructions = f081A_parent_instructions;
               body.emit(f081A);

               /* END IF */

               body.emit(assign(r07F1, r080A, 0x03));

               body.emit(assign(r07F0, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0805->else_instructions;

               body.emit(assign(r07F1, r07E9, 0x03));

               body.emit(assign(r07F0, body.constant(false), 0x01));


            body.instructions = f0805_parent_instructions;
            body.emit(f0805);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0803->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0826 = equal(r07FD, body.constant(int(0)));
            ir_if *f0825 = new(mem_ctx) ir_if(operand(r0826).val);
            exec_list *const f0825_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0825->then_instructions;

               body.emit(assign(r07F2, add(r0800, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0825->else_instructions;

               body.emit(assign(r07F3, bit_or(swizzle_y(r07FC), body.constant(1048576u)), 0x02));


            body.instructions = f0825_parent_instructions;
            body.emit(f0825);

            /* END IF */

            ir_variable *const r0827 = body.make_temp(glsl_type::uint_type, "a0");
            body.emit(assign(r0827, swizzle_y(r07F3), 0x01));

            ir_variable *const r0828 = body.make_temp(glsl_type::uint_type, "a1");
            body.emit(assign(r0828, swizzle_x(r07F3), 0x01));

            ir_variable *const r0829 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r0829, body.constant(0u), 0x01));

            ir_variable *const r082A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r082A);
            ir_variable *const r082B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r082B);
            ir_variable *const r082C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r082C);
            ir_variable *const r082D = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r082E = neg(r07F2);
            body.emit(assign(r082D, bit_and(r082E, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0830 = equal(r07F2, body.constant(int(0)));
            ir_if *f082F = new(mem_ctx) ir_if(operand(r0830).val);
            exec_list *const f082F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f082F->then_instructions;

               body.emit(assign(r082A, r0829, 0x01));

               body.emit(assign(r082B, r0828, 0x01));

               body.emit(assign(r082C, r0827, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f082F->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0832 = less(r07F2, body.constant(int(32)));
               ir_if *f0831 = new(mem_ctx) ir_if(operand(r0832).val);
               exec_list *const f0831_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0831->then_instructions;

                  body.emit(assign(r082A, lshift(swizzle_x(r07FC), r082D), 0x01));

                  ir_expression *const r0833 = lshift(swizzle_y(r07F3), r082D);
                  ir_expression *const r0834 = rshift(swizzle_x(r07FC), r07F2);
                  body.emit(assign(r082B, bit_or(r0833, r0834), 0x01));

                  body.emit(assign(r082C, rshift(swizzle_y(r07F3), r07F2), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0831->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0836 = equal(r07F2, body.constant(int(32)));
                  ir_if *f0835 = new(mem_ctx) ir_if(operand(r0836).val);
                  exec_list *const f0835_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0835->then_instructions;

                     body.emit(assign(r082A, r0828, 0x01));

                     body.emit(assign(r082B, r0827, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0835->else_instructions;

                     body.emit(assign(r0829, bit_or(body.constant(0u), swizzle_x(r07FC)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0838 = less(r07F2, body.constant(int(64)));
                     ir_if *f0837 = new(mem_ctx) ir_if(operand(r0838).val);
                     exec_list *const f0837_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0837->then_instructions;

                        body.emit(assign(r082A, lshift(swizzle_y(r07F3), r082D), 0x01));

                        ir_expression *const r0839 = bit_and(r07F2, body.constant(int(31)));
                        body.emit(assign(r082B, rshift(swizzle_y(r07F3), r0839), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0837->else_instructions;

                        ir_variable *const r083A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r083C = equal(r07F2, body.constant(int(64)));
                        ir_if *f083B = new(mem_ctx) ir_if(operand(r083C).val);
                        exec_list *const f083B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f083B->then_instructions;

                           body.emit(assign(r083A, r0827, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f083B->else_instructions;

                           ir_expression *const r083D = nequal(swizzle_y(r07F3), body.constant(0u));
                           ir_expression *const r083E = expr(ir_unop_b2i, r083D);
                           body.emit(assign(r083A, expr(ir_unop_i2u, r083E), 0x01));


                        body.instructions = f083B_parent_instructions;
                        body.emit(f083B);

                        /* END IF */

                        body.emit(assign(r082A, r083A, 0x01));

                        body.emit(assign(r082B, body.constant(0u), 0x01));


                     body.instructions = f0837_parent_instructions;
                     body.emit(f0837);

                     /* END IF */


                  body.instructions = f0835_parent_instructions;
                  body.emit(f0835);

                  /* END IF */

                  body.emit(assign(r082C, body.constant(0u), 0x01));


               body.instructions = f0831_parent_instructions;
               body.emit(f0831);

               /* END IF */

               ir_expression *const r083F = nequal(r0829, body.constant(0u));
               ir_expression *const r0840 = expr(ir_unop_b2i, r083F);
               ir_expression *const r0841 = expr(ir_unop_i2u, r0840);
               body.emit(assign(r082A, bit_or(r082A, r0841), 0x01));


            body.instructions = f082F_parent_instructions;
            body.emit(f082F);

            /* END IF */

            body.emit(assign(r07F3, r082C, 0x02));

            body.emit(assign(r07F3, r082B, 0x01));

            body.emit(assign(r07F6, r082A, 0x01));

            body.emit(assign(r07F5, r07F9, 0x01));


         body.instructions = f0803_parent_instructions;
         body.emit(f0803);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0801->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0843 = less(r07F2, body.constant(int(0)));
         ir_if *f0842 = new(mem_ctx) ir_if(operand(r0843).val);
         exec_list *const f0842_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0842->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0845 = equal(r07FD, body.constant(int(2047)));
            ir_if *f0844 = new(mem_ctx) ir_if(operand(r0845).val);
            exec_list *const f0844_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0844->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0847 = bit_or(swizzle_y(r07F3), swizzle_x(r07F3));
               ir_expression *const r0848 = nequal(r0847, body.constant(0u));
               ir_if *f0846 = new(mem_ctx) ir_if(operand(r0848).val);
               exec_list *const f0846_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0846->then_instructions;

                  ir_variable *const r0849 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r0849, swizzle_x(r07E9), 0x01));

                  ir_variable *const r084A = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r084A, swizzle_x(r07EA), 0x01));

                  ir_variable *const r084B = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r084C = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r084D = rshift(swizzle_y(r07E9), body.constant(int(19)));
                  ir_expression *const r084E = bit_and(r084D, body.constant(4095u));
                  ir_expression *const r084F = equal(r084E, body.constant(4094u));
                  ir_expression *const r0850 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0851 = bit_and(swizzle_y(r07E9), body.constant(524287u));
                  ir_expression *const r0852 = nequal(r0851, body.constant(0u));
                  ir_expression *const r0853 = logic_or(r0850, r0852);
                  body.emit(assign(r084C, logic_and(r084F, r0853), 0x01));

                  ir_variable *const r0854 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0855 = lshift(swizzle_y(r07EA), body.constant(int(1)));
                  ir_expression *const r0856 = lequal(body.constant(4292870144u), r0855);
                  ir_expression *const r0857 = nequal(swizzle_x(r07EA), body.constant(0u));
                  ir_expression *const r0858 = bit_and(swizzle_y(r07EA), body.constant(1048575u));
                  ir_expression *const r0859 = nequal(r0858, body.constant(0u));
                  ir_expression *const r085A = logic_or(r0857, r0859);
                  body.emit(assign(r0854, logic_and(r0856, r085A), 0x01));

                  body.emit(assign(r0849, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

                  body.emit(assign(r084A, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r085C = lshift(swizzle_y(r07E9), body.constant(int(1)));
                  ir_expression *const r085D = lequal(body.constant(4292870144u), r085C);
                  ir_expression *const r085E = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r085F = bit_and(swizzle_y(r07E9), body.constant(1048575u));
                  ir_expression *const r0860 = nequal(r085F, body.constant(0u));
                  ir_expression *const r0861 = logic_or(r085E, r0860);
                  ir_expression *const r0862 = logic_and(r085D, r0861);
                  ir_if *f085B = new(mem_ctx) ir_if(operand(r0862).val);
                  exec_list *const f085B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f085B->then_instructions;

                     ir_variable *const r0863 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0865 = logic_and(r084C, r0854);
                     ir_if *f0864 = new(mem_ctx) ir_if(operand(r0865).val);
                     exec_list *const f0864_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0864->then_instructions;

                        body.emit(assign(r0863, r084A, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0864->else_instructions;

                        body.emit(assign(r0863, r0849, 0x03));


                     body.instructions = f0864_parent_instructions;
                     body.emit(f0864);

                     /* END IF */

                     body.emit(assign(r084B, r0863, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f085B->else_instructions;

                     body.emit(assign(r084B, r084A, 0x03));


                  body.instructions = f085B_parent_instructions;
                  body.emit(f085B);

                  /* END IF */

                  body.emit(assign(r07F1, r084B, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0846->else_instructions;

                  ir_variable *const r0866 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0866);
                  ir_expression *const r0867 = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r0866, add(r0867, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0866, body.constant(0u), 0x01));

                  body.emit(assign(r07F1, r0866, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


               body.instructions = f0846_parent_instructions;
               body.emit(f0846);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0844->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0869 = equal(r07F9, body.constant(int(0)));
               ir_if *f0868 = new(mem_ctx) ir_if(operand(r0869).val);
               exec_list *const f0868_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0868->then_instructions;

                  body.emit(assign(r07F2, add(r07F2, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0868->else_instructions;

                  body.emit(assign(r07F4, bit_or(swizzle_y(r07F8), body.constant(1048576u)), 0x02));


               body.instructions = f0868_parent_instructions;
               body.emit(f0868);

               /* END IF */

               ir_variable *const r086A = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r086A, swizzle_y(r07F4), 0x01));

               ir_variable *const r086B = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r086B, swizzle_x(r07F4), 0x01));

               ir_variable *const r086C = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r086C, body.constant(0u), 0x01));

               ir_variable *const r086D = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r086D, neg(r07F2), 0x01));

               ir_variable *const r086E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r086E);
               ir_variable *const r086F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r086F);
               ir_variable *const r0870 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0870);
               ir_variable *const r0871 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0872 = neg(r086D);
               body.emit(assign(r0871, bit_and(r0872, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0874 = equal(r086D, body.constant(int(0)));
               ir_if *f0873 = new(mem_ctx) ir_if(operand(r0874).val);
               exec_list *const f0873_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0873->then_instructions;

                  body.emit(assign(r086E, r086C, 0x01));

                  body.emit(assign(r086F, r086B, 0x01));

                  body.emit(assign(r0870, r086A, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0873->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0876 = less(r086D, body.constant(int(32)));
                  ir_if *f0875 = new(mem_ctx) ir_if(operand(r0876).val);
                  exec_list *const f0875_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0875->then_instructions;

                     body.emit(assign(r086E, lshift(swizzle_x(r07F8), r0871), 0x01));

                     ir_expression *const r0877 = lshift(swizzle_y(r07F4), r0871);
                     ir_expression *const r0878 = rshift(swizzle_x(r07F8), r086D);
                     body.emit(assign(r086F, bit_or(r0877, r0878), 0x01));

                     body.emit(assign(r0870, rshift(swizzle_y(r07F4), r086D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0875->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r087A = equal(r086D, body.constant(int(32)));
                     ir_if *f0879 = new(mem_ctx) ir_if(operand(r087A).val);
                     exec_list *const f0879_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0879->then_instructions;

                        body.emit(assign(r086E, r086B, 0x01));

                        body.emit(assign(r086F, r086A, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0879->else_instructions;

                        body.emit(assign(r086C, bit_or(body.constant(0u), swizzle_x(r07F8)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r087C = less(r086D, body.constant(int(64)));
                        ir_if *f087B = new(mem_ctx) ir_if(operand(r087C).val);
                        exec_list *const f087B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f087B->then_instructions;

                           body.emit(assign(r086E, lshift(swizzle_y(r07F4), r0871), 0x01));

                           ir_expression *const r087D = bit_and(r086D, body.constant(int(31)));
                           body.emit(assign(r086F, rshift(swizzle_y(r07F4), r087D), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f087B->else_instructions;

                           ir_variable *const r087E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0880 = equal(r086D, body.constant(int(64)));
                           ir_if *f087F = new(mem_ctx) ir_if(operand(r0880).val);
                           exec_list *const f087F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f087F->then_instructions;

                              body.emit(assign(r087E, r086A, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f087F->else_instructions;

                              ir_expression *const r0881 = nequal(swizzle_y(r07F4), body.constant(0u));
                              ir_expression *const r0882 = expr(ir_unop_b2i, r0881);
                              body.emit(assign(r087E, expr(ir_unop_i2u, r0882), 0x01));


                           body.instructions = f087F_parent_instructions;
                           body.emit(f087F);

                           /* END IF */

                           body.emit(assign(r086E, r087E, 0x01));

                           body.emit(assign(r086F, body.constant(0u), 0x01));


                        body.instructions = f087B_parent_instructions;
                        body.emit(f087B);

                        /* END IF */


                     body.instructions = f0879_parent_instructions;
                     body.emit(f0879);

                     /* END IF */

                     body.emit(assign(r0870, body.constant(0u), 0x01));


                  body.instructions = f0875_parent_instructions;
                  body.emit(f0875);

                  /* END IF */

                  ir_expression *const r0883 = nequal(r086C, body.constant(0u));
                  ir_expression *const r0884 = expr(ir_unop_b2i, r0883);
                  ir_expression *const r0885 = expr(ir_unop_i2u, r0884);
                  body.emit(assign(r086E, bit_or(r086E, r0885), 0x01));


               body.instructions = f0873_parent_instructions;
               body.emit(f0873);

               /* END IF */

               body.emit(assign(r07F4, r0870, 0x02));

               body.emit(assign(r07F4, r086F, 0x01));

               body.emit(assign(r07F6, r086E, 0x01));

               body.emit(assign(r07F5, r07FD, 0x01));


            body.instructions = f0844_parent_instructions;
            body.emit(f0844);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0842->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0887 = equal(r07F9, body.constant(int(2047)));
            ir_if *f0886 = new(mem_ctx) ir_if(operand(r0887).val);
            exec_list *const f0886_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0886->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0889 = bit_or(swizzle_y(r07F4), swizzle_x(r07F4));
               ir_expression *const r088A = bit_or(swizzle_y(r07F3), swizzle_x(r07F3));
               ir_expression *const r088B = bit_or(r0889, r088A);
               ir_expression *const r088C = nequal(r088B, body.constant(0u));
               ir_if *f0888 = new(mem_ctx) ir_if(operand(r088C).val);
               exec_list *const f0888_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0888->then_instructions;

                  ir_variable *const r088D = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r088D, swizzle_x(r07E9), 0x01));

                  ir_variable *const r088E = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r088E, swizzle_x(r07EA), 0x01));

                  ir_variable *const r088F = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0890 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0891 = rshift(swizzle_y(r07E9), body.constant(int(19)));
                  ir_expression *const r0892 = bit_and(r0891, body.constant(4095u));
                  ir_expression *const r0893 = equal(r0892, body.constant(4094u));
                  ir_expression *const r0894 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0895 = bit_and(swizzle_y(r07E9), body.constant(524287u));
                  ir_expression *const r0896 = nequal(r0895, body.constant(0u));
                  ir_expression *const r0897 = logic_or(r0894, r0896);
                  body.emit(assign(r0890, logic_and(r0893, r0897), 0x01));

                  ir_variable *const r0898 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0899 = lshift(swizzle_y(r07EA), body.constant(int(1)));
                  ir_expression *const r089A = lequal(body.constant(4292870144u), r0899);
                  ir_expression *const r089B = nequal(swizzle_x(r07EA), body.constant(0u));
                  ir_expression *const r089C = bit_and(swizzle_y(r07EA), body.constant(1048575u));
                  ir_expression *const r089D = nequal(r089C, body.constant(0u));
                  ir_expression *const r089E = logic_or(r089B, r089D);
                  body.emit(assign(r0898, logic_and(r089A, r089E), 0x01));

                  body.emit(assign(r088D, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

                  body.emit(assign(r088E, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r08A0 = lshift(swizzle_y(r07E9), body.constant(int(1)));
                  ir_expression *const r08A1 = lequal(body.constant(4292870144u), r08A0);
                  ir_expression *const r08A2 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r08A3 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
                  ir_expression *const r08A4 = nequal(r08A3, body.constant(0u));
                  ir_expression *const r08A5 = logic_or(r08A2, r08A4);
                  ir_expression *const r08A6 = logic_and(r08A1, r08A5);
                  ir_if *f089F = new(mem_ctx) ir_if(operand(r08A6).val);
                  exec_list *const f089F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f089F->then_instructions;

                     ir_variable *const r08A7 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r08A9 = logic_and(r0890, r0898);
                     ir_if *f08A8 = new(mem_ctx) ir_if(operand(r08A9).val);
                     exec_list *const f08A8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f08A8->then_instructions;

                        body.emit(assign(r08A7, r088E, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f08A8->else_instructions;

                        body.emit(assign(r08A7, r088D, 0x03));


                     body.instructions = f08A8_parent_instructions;
                     body.emit(f08A8);

                     /* END IF */

                     body.emit(assign(r088F, r08A7, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f089F->else_instructions;

                     body.emit(assign(r088F, r088E, 0x03));


                  body.instructions = f089F_parent_instructions;
                  body.emit(f089F);

                  /* END IF */

                  body.emit(assign(r07F1, r088F, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0888->else_instructions;

                  body.emit(assign(r07F1, r07E9, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


               body.instructions = f0888_parent_instructions;
               body.emit(f0888);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0886->else_instructions;

               ir_variable *const r08AA = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r08AB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r08AB, add(swizzle_x(r07F4), swizzle_x(r07F3)), 0x01));

               ir_expression *const r08AC = add(swizzle_y(r07F4), swizzle_y(r07F3));
               ir_expression *const r08AD = less(r08AB, swizzle_x(r07F4));
               ir_expression *const r08AE = expr(ir_unop_b2i, r08AD);
               ir_expression *const r08AF = expr(ir_unop_i2u, r08AE);
               body.emit(assign(r08AA, add(r08AC, r08AF), 0x01));

               body.emit(assign(r07F7, r08AA, 0x01));

               /* IF CONDITION */
               ir_expression *const r08B1 = equal(r07F9, body.constant(int(0)));
               ir_if *f08B0 = new(mem_ctx) ir_if(operand(r08B1).val);
               exec_list *const f08B0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f08B0->then_instructions;

                  ir_variable *const r08B2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r08B2);
                  ir_expression *const r08B3 = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r08B2, add(r08B3, r08AA), 0x02));

                  body.emit(assign(r08B2, r08AB, 0x01));

                  body.emit(assign(r07F1, r08B2, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f08B0->else_instructions;

                  body.emit(assign(r07F7, bit_or(r08AA, body.constant(2097152u)), 0x01));

                  body.emit(assign(r07F5, r07F9, 0x01));

                  ir_variable *const r08B4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r08B4);
                  ir_variable *const r08B5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r08B5);
                  ir_variable *const r08B6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r08B6);
                  body.emit(assign(r08B4, lshift(r08AB, body.constant(int(31))), 0x01));

                  ir_expression *const r08B7 = lshift(r07F7, body.constant(int(31)));
                  ir_expression *const r08B8 = rshift(r08AB, body.constant(int(1)));
                  body.emit(assign(r08B5, bit_or(r08B7, r08B8), 0x01));

                  body.emit(assign(r08B6, rshift(r07F7, body.constant(int(1))), 0x01));

                  body.emit(assign(r08B4, bit_or(r08B4, body.constant(0u)), 0x01));

                  body.emit(assign(r07F7, r08B6, 0x01));

                  body.emit(assign(r07F6, r08B4, 0x01));

                  ir_variable *const r08B9 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r08B9, r07F9, 0x01));

                  ir_variable *const r08BA = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r08BA, r08B6, 0x01));

                  ir_variable *const r08BB = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r08BB, r08B5, 0x01));

                  ir_variable *const r08BC = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r08BC, r08B4, 0x01));

                  ir_variable *const r08BD = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r08BD, body.constant(true), 0x01));

                  ir_variable *const r08BE = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r08BF = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r08BF);
                  ir_expression *const r08C0 = expr(ir_unop_u2i, r08B4);
                  body.emit(assign(r08BF, less(r08C0, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r08C2 = lequal(body.constant(int(2045)), r07F9);
                  ir_if *f08C1 = new(mem_ctx) ir_if(operand(r08C2).val);
                  exec_list *const f08C1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f08C1->then_instructions;

                     ir_variable *const r08C3 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r08C5 = less(body.constant(int(2045)), r07F9);
                     ir_if *f08C4 = new(mem_ctx) ir_if(operand(r08C5).val);
                     exec_list *const f08C4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f08C4->then_instructions;

                        body.emit(assign(r08C3, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f08C4->else_instructions;

                        ir_variable *const r08C6 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r08C8 = equal(r07F9, body.constant(int(2045)));
                        ir_if *f08C7 = new(mem_ctx) ir_if(operand(r08C8).val);
                        exec_list *const f08C7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f08C7->then_instructions;

                           ir_expression *const r08C9 = equal(body.constant(2097151u), r08B6);
                           ir_expression *const r08CA = equal(body.constant(4294967295u), r08B5);
                           body.emit(assign(r08C6, logic_and(r08C9, r08CA), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f08C7->else_instructions;

                           body.emit(assign(r08C6, body.constant(false), 0x01));


                        body.instructions = f08C7_parent_instructions;
                        body.emit(f08C7);

                        /* END IF */

                        body.emit(assign(r08C3, logic_and(r08C6, r08BF), 0x01));


                     body.instructions = f08C4_parent_instructions;
                     body.emit(f08C4);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f08CB = new(mem_ctx) ir_if(operand(r08C3).val);
                     exec_list *const f08CB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f08CB->then_instructions;

                        ir_variable *const r08CC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r08CC);
                        ir_expression *const r08CD = lshift(r07EC, body.constant(int(31)));
                        body.emit(assign(r08CC, add(r08CD, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r08CC, body.constant(0u), 0x01));

                        body.emit(assign(r08BE, r08CC, 0x03));

                        body.emit(assign(r08BD, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f08CB->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r08CF = less(r07F9, body.constant(int(0)));
                        ir_if *f08CE = new(mem_ctx) ir_if(operand(r08CF).val);
                        exec_list *const f08CE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f08CE->then_instructions;

                           ir_variable *const r08D0 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r08D0, r08B4, 0x01));

                           ir_variable *const r08D1 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r08D1, neg(r07F9), 0x01));

                           ir_variable *const r08D2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r08D2);
                           ir_variable *const r08D3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r08D3);
                           ir_variable *const r08D4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r08D4);
                           ir_variable *const r08D5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r08D6 = neg(r08D1);
                           body.emit(assign(r08D5, bit_and(r08D6, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r08D8 = equal(r08D1, body.constant(int(0)));
                           ir_if *f08D7 = new(mem_ctx) ir_if(operand(r08D8).val);
                           exec_list *const f08D7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f08D7->then_instructions;

                              body.emit(assign(r08D2, r08B4, 0x01));

                              body.emit(assign(r08D3, r08B5, 0x01));

                              body.emit(assign(r08D4, r08B6, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f08D7->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r08DA = less(r08D1, body.constant(int(32)));
                              ir_if *f08D9 = new(mem_ctx) ir_if(operand(r08DA).val);
                              exec_list *const f08D9_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f08D9->then_instructions;

                                 body.emit(assign(r08D2, lshift(r08B5, r08D5), 0x01));

                                 ir_expression *const r08DB = lshift(r08B6, r08D5);
                                 ir_expression *const r08DC = rshift(r08B5, r08D1);
                                 body.emit(assign(r08D3, bit_or(r08DB, r08DC), 0x01));

                                 body.emit(assign(r08D4, rshift(r08B6, r08D1), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f08D9->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r08DE = equal(r08D1, body.constant(int(32)));
                                 ir_if *f08DD = new(mem_ctx) ir_if(operand(r08DE).val);
                                 exec_list *const f08DD_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f08DD->then_instructions;

                                    body.emit(assign(r08D2, r08B5, 0x01));

                                    body.emit(assign(r08D3, r08B6, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f08DD->else_instructions;

                                    body.emit(assign(r08D0, bit_or(r08B4, r08B5), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r08E0 = less(r08D1, body.constant(int(64)));
                                    ir_if *f08DF = new(mem_ctx) ir_if(operand(r08E0).val);
                                    exec_list *const f08DF_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f08DF->then_instructions;

                                       body.emit(assign(r08D2, lshift(r08B6, r08D5), 0x01));

                                       ir_expression *const r08E1 = bit_and(r08D1, body.constant(int(31)));
                                       body.emit(assign(r08D3, rshift(r08B6, r08E1), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f08DF->else_instructions;

                                       ir_variable *const r08E2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r08E4 = equal(r08D1, body.constant(int(64)));
                                       ir_if *f08E3 = new(mem_ctx) ir_if(operand(r08E4).val);
                                       exec_list *const f08E3_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f08E3->then_instructions;

                                          body.emit(assign(r08E2, r08B6, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f08E3->else_instructions;

                                          ir_expression *const r08E5 = nequal(r08B6, body.constant(0u));
                                          ir_expression *const r08E6 = expr(ir_unop_b2i, r08E5);
                                          body.emit(assign(r08E2, expr(ir_unop_i2u, r08E6), 0x01));


                                       body.instructions = f08E3_parent_instructions;
                                       body.emit(f08E3);

                                       /* END IF */

                                       body.emit(assign(r08D2, r08E2, 0x01));

                                       body.emit(assign(r08D3, body.constant(0u), 0x01));


                                    body.instructions = f08DF_parent_instructions;
                                    body.emit(f08DF);

                                    /* END IF */


                                 body.instructions = f08DD_parent_instructions;
                                 body.emit(f08DD);

                                 /* END IF */

                                 body.emit(assign(r08D4, body.constant(0u), 0x01));


                              body.instructions = f08D9_parent_instructions;
                              body.emit(f08D9);

                              /* END IF */

                              ir_expression *const r08E7 = nequal(r08D0, body.constant(0u));
                              ir_expression *const r08E8 = expr(ir_unop_b2i, r08E7);
                              ir_expression *const r08E9 = expr(ir_unop_i2u, r08E8);
                              body.emit(assign(r08D2, bit_or(r08D2, r08E9), 0x01));


                           body.instructions = f08D7_parent_instructions;
                           body.emit(f08D7);

                           /* END IF */

                           body.emit(assign(r08BA, r08D4, 0x01));

                           body.emit(assign(r08BB, r08D3, 0x01));

                           body.emit(assign(r08BC, r08D2, 0x01));

                           body.emit(assign(r08B9, body.constant(int(0)), 0x01));

                           body.emit(assign(r08BF, less(r08D2, body.constant(0u)), 0x01));


                        body.instructions = f08CE_parent_instructions;
                        body.emit(f08CE);

                        /* END IF */


                     body.instructions = f08CB_parent_instructions;
                     body.emit(f08CB);

                     /* END IF */


                  body.instructions = f08C1_parent_instructions;
                  body.emit(f08C1);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f08EA = new(mem_ctx) ir_if(operand(r08BD).val);
                  exec_list *const f08EA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f08EA->then_instructions;

                     /* IF CONDITION */
                     ir_if *f08EB = new(mem_ctx) ir_if(operand(r08BF).val);
                     exec_list *const f08EB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f08EB->then_instructions;

                        ir_variable *const r08EC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r08EC, add(r08BB, body.constant(1u)), 0x01));

                        ir_expression *const r08ED = less(r08EC, r08BB);
                        ir_expression *const r08EE = expr(ir_unop_b2i, r08ED);
                        ir_expression *const r08EF = expr(ir_unop_i2u, r08EE);
                        body.emit(assign(r08BA, add(r08BA, r08EF), 0x01));

                        ir_expression *const r08F0 = equal(r08BC, body.constant(0u));
                        ir_expression *const r08F1 = expr(ir_unop_b2i, r08F0);
                        ir_expression *const r08F2 = expr(ir_unop_i2u, r08F1);
                        ir_expression *const r08F3 = add(r08BC, r08F2);
                        ir_expression *const r08F4 = bit_and(r08F3, body.constant(1u));
                        ir_expression *const r08F5 = expr(ir_unop_bit_not, r08F4);
                        body.emit(assign(r08BB, bit_and(r08EC, r08F5), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f08EB->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r08F7 = bit_or(r08BA, r08BB);
                        ir_expression *const r08F8 = equal(r08F7, body.constant(0u));
                        ir_if *f08F6 = new(mem_ctx) ir_if(operand(r08F8).val);
                        exec_list *const f08F6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f08F6->then_instructions;

                           body.emit(assign(r08B9, body.constant(int(0)), 0x01));


                        body.instructions = f08F6_parent_instructions;
                        body.emit(f08F6);

                        /* END IF */


                     body.instructions = f08EB_parent_instructions;
                     body.emit(f08EB);

                     /* END IF */

                     ir_variable *const r08F9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r08F9);
                     ir_expression *const r08FA = lshift(r07EC, body.constant(int(31)));
                     ir_expression *const r08FB = expr(ir_unop_i2u, r08B9);
                     ir_expression *const r08FC = lshift(r08FB, body.constant(int(20)));
                     ir_expression *const r08FD = add(r08FA, r08FC);
                     body.emit(assign(r08F9, add(r08FD, r08BA), 0x02));

                     body.emit(assign(r08F9, r08BB, 0x01));

                     body.emit(assign(r08BE, r08F9, 0x03));

                     body.emit(assign(r08BD, body.constant(false), 0x01));


                  body.instructions = f08EA_parent_instructions;
                  body.emit(f08EA);

                  /* END IF */

                  body.emit(assign(r07F1, r08BE, 0x03));

                  body.emit(assign(r07F0, body.constant(false), 0x01));


               body.instructions = f08B0_parent_instructions;
               body.emit(f08B0);

               /* END IF */


            body.instructions = f0886_parent_instructions;
            body.emit(f0886);

            /* END IF */


         body.instructions = f0842_parent_instructions;
         body.emit(f0842);

         /* END IF */


      body.instructions = f0801_parent_instructions;
      body.emit(f0801);

      /* END IF */

      /* IF CONDITION */
      ir_if *f08FE = new(mem_ctx) ir_if(operand(r07F0).val);
      exec_list *const f08FE_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f08FE->then_instructions;

         body.emit(assign(r07F4, bit_or(swizzle_y(r07F4), body.constant(1048576u)), 0x02));

         ir_variable *const r08FF = body.make_temp(glsl_type::uint_type, "z0Ptr");
         ir_variable *const r0900 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r0900, add(swizzle_x(r07F4), swizzle_x(r07F3)), 0x01));

         ir_expression *const r0901 = add(swizzle_y(r07F4), swizzle_y(r07F3));
         ir_expression *const r0902 = less(r0900, swizzle_x(r07F4));
         ir_expression *const r0903 = expr(ir_unop_b2i, r0902);
         ir_expression *const r0904 = expr(ir_unop_i2u, r0903);
         body.emit(assign(r08FF, add(r0901, r0904), 0x01));

         body.emit(assign(r07F7, r08FF, 0x01));

         body.emit(assign(r07F5, add(r07F5, body.constant(int(-1))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0906 = less(r08FF, body.constant(2097152u));
         ir_if *f0905 = new(mem_ctx) ir_if(operand(r0906).val);
         exec_list *const f0905_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0905->then_instructions;

            ir_variable *const r0907 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0907, r07F5, 0x01));

            ir_variable *const r0908 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0908, r08FF, 0x01));

            ir_variable *const r0909 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0909, r0900, 0x01));

            ir_variable *const r090A = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r090A, r07F6, 0x01));

            ir_variable *const r090B = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r090B, body.constant(true), 0x01));

            ir_variable *const r090C = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r090D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r090D);
            ir_expression *const r090E = expr(ir_unop_u2i, r07F6);
            body.emit(assign(r090D, less(r090E, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0910 = lequal(body.constant(int(2045)), r07F5);
            ir_if *f090F = new(mem_ctx) ir_if(operand(r0910).val);
            exec_list *const f090F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f090F->then_instructions;

               ir_variable *const r0911 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0913 = less(body.constant(int(2045)), r07F5);
               ir_if *f0912 = new(mem_ctx) ir_if(operand(r0913).val);
               exec_list *const f0912_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0912->then_instructions;

                  body.emit(assign(r0911, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0912->else_instructions;

                  ir_variable *const r0914 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0916 = equal(r07F5, body.constant(int(2045)));
                  ir_if *f0915 = new(mem_ctx) ir_if(operand(r0916).val);
                  exec_list *const f0915_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0915->then_instructions;

                     ir_expression *const r0917 = equal(body.constant(2097151u), r08FF);
                     ir_expression *const r0918 = equal(body.constant(4294967295u), r0900);
                     body.emit(assign(r0914, logic_and(r0917, r0918), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0915->else_instructions;

                     body.emit(assign(r0914, body.constant(false), 0x01));


                  body.instructions = f0915_parent_instructions;
                  body.emit(f0915);

                  /* END IF */

                  body.emit(assign(r0911, logic_and(r0914, r090D), 0x01));


               body.instructions = f0912_parent_instructions;
               body.emit(f0912);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0919 = new(mem_ctx) ir_if(operand(r0911).val);
               exec_list *const f0919_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0919->then_instructions;

                  ir_variable *const r091A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r091A);
                  ir_expression *const r091B = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r091A, add(r091B, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r091A, body.constant(0u), 0x01));

                  body.emit(assign(r090C, r091A, 0x03));

                  body.emit(assign(r090B, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0919->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r091D = less(r07F5, body.constant(int(0)));
                  ir_if *f091C = new(mem_ctx) ir_if(operand(r091D).val);
                  exec_list *const f091C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f091C->then_instructions;

                     ir_variable *const r091E = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r091E, r07F6, 0x01));

                     ir_variable *const r091F = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r091F, neg(r07F5), 0x01));

                     ir_variable *const r0920 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0920);
                     ir_variable *const r0921 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0921);
                     ir_variable *const r0922 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0922);
                     ir_variable *const r0923 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0924 = neg(r091F);
                     body.emit(assign(r0923, bit_and(r0924, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0926 = equal(r091F, body.constant(int(0)));
                     ir_if *f0925 = new(mem_ctx) ir_if(operand(r0926).val);
                     exec_list *const f0925_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0925->then_instructions;

                        body.emit(assign(r0920, r07F6, 0x01));

                        body.emit(assign(r0921, r0900, 0x01));

                        body.emit(assign(r0922, r08FF, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0925->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0928 = less(r091F, body.constant(int(32)));
                        ir_if *f0927 = new(mem_ctx) ir_if(operand(r0928).val);
                        exec_list *const f0927_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0927->then_instructions;

                           body.emit(assign(r0920, lshift(r0900, r0923), 0x01));

                           ir_expression *const r0929 = lshift(r08FF, r0923);
                           ir_expression *const r092A = rshift(r0900, r091F);
                           body.emit(assign(r0921, bit_or(r0929, r092A), 0x01));

                           body.emit(assign(r0922, rshift(r08FF, r091F), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0927->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r092C = equal(r091F, body.constant(int(32)));
                           ir_if *f092B = new(mem_ctx) ir_if(operand(r092C).val);
                           exec_list *const f092B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f092B->then_instructions;

                              body.emit(assign(r0920, r0900, 0x01));

                              body.emit(assign(r0921, r08FF, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f092B->else_instructions;

                              body.emit(assign(r091E, bit_or(r07F6, r0900), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r092E = less(r091F, body.constant(int(64)));
                              ir_if *f092D = new(mem_ctx) ir_if(operand(r092E).val);
                              exec_list *const f092D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f092D->then_instructions;

                                 body.emit(assign(r0920, lshift(r08FF, r0923), 0x01));

                                 ir_expression *const r092F = bit_and(r091F, body.constant(int(31)));
                                 body.emit(assign(r0921, rshift(r08FF, r092F), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f092D->else_instructions;

                                 ir_variable *const r0930 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0932 = equal(r091F, body.constant(int(64)));
                                 ir_if *f0931 = new(mem_ctx) ir_if(operand(r0932).val);
                                 exec_list *const f0931_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0931->then_instructions;

                                    body.emit(assign(r0930, r08FF, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0931->else_instructions;

                                    ir_expression *const r0933 = nequal(r08FF, body.constant(0u));
                                    ir_expression *const r0934 = expr(ir_unop_b2i, r0933);
                                    body.emit(assign(r0930, expr(ir_unop_i2u, r0934), 0x01));


                                 body.instructions = f0931_parent_instructions;
                                 body.emit(f0931);

                                 /* END IF */

                                 body.emit(assign(r0920, r0930, 0x01));

                                 body.emit(assign(r0921, body.constant(0u), 0x01));


                              body.instructions = f092D_parent_instructions;
                              body.emit(f092D);

                              /* END IF */


                           body.instructions = f092B_parent_instructions;
                           body.emit(f092B);

                           /* END IF */

                           body.emit(assign(r0922, body.constant(0u), 0x01));


                        body.instructions = f0927_parent_instructions;
                        body.emit(f0927);

                        /* END IF */

                        ir_expression *const r0935 = nequal(r091E, body.constant(0u));
                        ir_expression *const r0936 = expr(ir_unop_b2i, r0935);
                        ir_expression *const r0937 = expr(ir_unop_i2u, r0936);
                        body.emit(assign(r0920, bit_or(r0920, r0937), 0x01));


                     body.instructions = f0925_parent_instructions;
                     body.emit(f0925);

                     /* END IF */

                     body.emit(assign(r0908, r0922, 0x01));

                     body.emit(assign(r0909, r0921, 0x01));

                     body.emit(assign(r090A, r0920, 0x01));

                     body.emit(assign(r0907, body.constant(int(0)), 0x01));

                     body.emit(assign(r090D, less(r0920, body.constant(0u)), 0x01));


                  body.instructions = f091C_parent_instructions;
                  body.emit(f091C);

                  /* END IF */


               body.instructions = f0919_parent_instructions;
               body.emit(f0919);

               /* END IF */


            body.instructions = f090F_parent_instructions;
            body.emit(f090F);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0938 = new(mem_ctx) ir_if(operand(r090B).val);
            exec_list *const f0938_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0938->then_instructions;

               /* IF CONDITION */
               ir_if *f0939 = new(mem_ctx) ir_if(operand(r090D).val);
               exec_list *const f0939_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0939->then_instructions;

                  ir_variable *const r093A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r093A, add(r0909, body.constant(1u)), 0x01));

                  ir_expression *const r093B = less(r093A, r0909);
                  ir_expression *const r093C = expr(ir_unop_b2i, r093B);
                  ir_expression *const r093D = expr(ir_unop_i2u, r093C);
                  body.emit(assign(r0908, add(r0908, r093D), 0x01));

                  ir_expression *const r093E = equal(r090A, body.constant(0u));
                  ir_expression *const r093F = expr(ir_unop_b2i, r093E);
                  ir_expression *const r0940 = expr(ir_unop_i2u, r093F);
                  ir_expression *const r0941 = add(r090A, r0940);
                  ir_expression *const r0942 = bit_and(r0941, body.constant(1u));
                  ir_expression *const r0943 = expr(ir_unop_bit_not, r0942);
                  body.emit(assign(r0909, bit_and(r093A, r0943), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0939->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0945 = bit_or(r0908, r0909);
                  ir_expression *const r0946 = equal(r0945, body.constant(0u));
                  ir_if *f0944 = new(mem_ctx) ir_if(operand(r0946).val);
                  exec_list *const f0944_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0944->then_instructions;

                     body.emit(assign(r0907, body.constant(int(0)), 0x01));


                  body.instructions = f0944_parent_instructions;
                  body.emit(f0944);

                  /* END IF */


               body.instructions = f0939_parent_instructions;
               body.emit(f0939);

               /* END IF */

               ir_variable *const r0947 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0947);
               ir_expression *const r0948 = lshift(r07EC, body.constant(int(31)));
               ir_expression *const r0949 = expr(ir_unop_i2u, r0907);
               ir_expression *const r094A = lshift(r0949, body.constant(int(20)));
               ir_expression *const r094B = add(r0948, r094A);
               body.emit(assign(r0947, add(r094B, r0908), 0x02));

               body.emit(assign(r0947, r0909, 0x01));

               body.emit(assign(r090C, r0947, 0x03));

               body.emit(assign(r090B, body.constant(false), 0x01));


            body.instructions = f0938_parent_instructions;
            body.emit(f0938);

            /* END IF */

            body.emit(assign(r07F1, r090C, 0x03));

            body.emit(assign(r07F0, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0905->else_instructions;

            body.emit(assign(r07F5, add(r07F5, body.constant(int(1))), 0x01));

            ir_variable *const r094C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r094C);
            ir_variable *const r094D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r094D);
            ir_variable *const r094E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r094E);
            body.emit(assign(r094C, lshift(r0900, body.constant(int(31))), 0x01));

            ir_expression *const r094F = lshift(r08FF, body.constant(int(31)));
            ir_expression *const r0950 = rshift(r0900, body.constant(int(1)));
            body.emit(assign(r094D, bit_or(r094F, r0950), 0x01));

            body.emit(assign(r094E, rshift(r08FF, body.constant(int(1))), 0x01));

            ir_expression *const r0951 = nequal(r07F6, body.constant(0u));
            ir_expression *const r0952 = expr(ir_unop_b2i, r0951);
            ir_expression *const r0953 = expr(ir_unop_i2u, r0952);
            body.emit(assign(r094C, bit_or(r094C, r0953), 0x01));

            body.emit(assign(r07F7, r094E, 0x01));

            body.emit(assign(r07F6, r094C, 0x01));

            ir_variable *const r0954 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0954, r07F5, 0x01));

            ir_variable *const r0955 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0955, r094E, 0x01));

            ir_variable *const r0956 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0956, r094D, 0x01));

            ir_variable *const r0957 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r0957, r094C, 0x01));

            ir_variable *const r0958 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r0958, body.constant(true), 0x01));

            ir_variable *const r0959 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r095A = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r095A);
            ir_expression *const r095B = expr(ir_unop_u2i, r094C);
            body.emit(assign(r095A, less(r095B, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r095D = lequal(body.constant(int(2045)), r07F5);
            ir_if *f095C = new(mem_ctx) ir_if(operand(r095D).val);
            exec_list *const f095C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f095C->then_instructions;

               ir_variable *const r095E = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0960 = less(body.constant(int(2045)), r07F5);
               ir_if *f095F = new(mem_ctx) ir_if(operand(r0960).val);
               exec_list *const f095F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f095F->then_instructions;

                  body.emit(assign(r095E, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f095F->else_instructions;

                  ir_variable *const r0961 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0963 = equal(r07F5, body.constant(int(2045)));
                  ir_if *f0962 = new(mem_ctx) ir_if(operand(r0963).val);
                  exec_list *const f0962_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0962->then_instructions;

                     ir_expression *const r0964 = equal(body.constant(2097151u), r094E);
                     ir_expression *const r0965 = equal(body.constant(4294967295u), r094D);
                     body.emit(assign(r0961, logic_and(r0964, r0965), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0962->else_instructions;

                     body.emit(assign(r0961, body.constant(false), 0x01));


                  body.instructions = f0962_parent_instructions;
                  body.emit(f0962);

                  /* END IF */

                  body.emit(assign(r095E, logic_and(r0961, r095A), 0x01));


               body.instructions = f095F_parent_instructions;
               body.emit(f095F);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0966 = new(mem_ctx) ir_if(operand(r095E).val);
               exec_list *const f0966_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0966->then_instructions;

                  ir_variable *const r0967 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0967);
                  ir_expression *const r0968 = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r0967, add(r0968, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0967, body.constant(0u), 0x01));

                  body.emit(assign(r0959, r0967, 0x03));

                  body.emit(assign(r0958, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0966->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r096A = less(r07F5, body.constant(int(0)));
                  ir_if *f0969 = new(mem_ctx) ir_if(operand(r096A).val);
                  exec_list *const f0969_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0969->then_instructions;

                     ir_variable *const r096B = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r096B, r094C, 0x01));

                     ir_variable *const r096C = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r096C, neg(r07F5), 0x01));

                     ir_variable *const r096D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r096D);
                     ir_variable *const r096E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r096E);
                     ir_variable *const r096F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r096F);
                     ir_variable *const r0970 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0971 = neg(r096C);
                     body.emit(assign(r0970, bit_and(r0971, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0973 = equal(r096C, body.constant(int(0)));
                     ir_if *f0972 = new(mem_ctx) ir_if(operand(r0973).val);
                     exec_list *const f0972_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0972->then_instructions;

                        body.emit(assign(r096D, r094C, 0x01));

                        body.emit(assign(r096E, r094D, 0x01));

                        body.emit(assign(r096F, r094E, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0972->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0975 = less(r096C, body.constant(int(32)));
                        ir_if *f0974 = new(mem_ctx) ir_if(operand(r0975).val);
                        exec_list *const f0974_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0974->then_instructions;

                           body.emit(assign(r096D, lshift(r094D, r0970), 0x01));

                           ir_expression *const r0976 = lshift(r094E, r0970);
                           ir_expression *const r0977 = rshift(r094D, r096C);
                           body.emit(assign(r096E, bit_or(r0976, r0977), 0x01));

                           body.emit(assign(r096F, rshift(r094E, r096C), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0974->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0979 = equal(r096C, body.constant(int(32)));
                           ir_if *f0978 = new(mem_ctx) ir_if(operand(r0979).val);
                           exec_list *const f0978_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0978->then_instructions;

                              body.emit(assign(r096D, r094D, 0x01));

                              body.emit(assign(r096E, r094E, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0978->else_instructions;

                              body.emit(assign(r096B, bit_or(r094C, r094D), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r097B = less(r096C, body.constant(int(64)));
                              ir_if *f097A = new(mem_ctx) ir_if(operand(r097B).val);
                              exec_list *const f097A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f097A->then_instructions;

                                 body.emit(assign(r096D, lshift(r094E, r0970), 0x01));

                                 ir_expression *const r097C = bit_and(r096C, body.constant(int(31)));
                                 body.emit(assign(r096E, rshift(r094E, r097C), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f097A->else_instructions;

                                 ir_variable *const r097D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r097F = equal(r096C, body.constant(int(64)));
                                 ir_if *f097E = new(mem_ctx) ir_if(operand(r097F).val);
                                 exec_list *const f097E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f097E->then_instructions;

                                    body.emit(assign(r097D, r094E, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f097E->else_instructions;

                                    ir_expression *const r0980 = nequal(r094E, body.constant(0u));
                                    ir_expression *const r0981 = expr(ir_unop_b2i, r0980);
                                    body.emit(assign(r097D, expr(ir_unop_i2u, r0981), 0x01));


                                 body.instructions = f097E_parent_instructions;
                                 body.emit(f097E);

                                 /* END IF */

                                 body.emit(assign(r096D, r097D, 0x01));

                                 body.emit(assign(r096E, body.constant(0u), 0x01));


                              body.instructions = f097A_parent_instructions;
                              body.emit(f097A);

                              /* END IF */


                           body.instructions = f0978_parent_instructions;
                           body.emit(f0978);

                           /* END IF */

                           body.emit(assign(r096F, body.constant(0u), 0x01));


                        body.instructions = f0974_parent_instructions;
                        body.emit(f0974);

                        /* END IF */

                        ir_expression *const r0982 = nequal(r096B, body.constant(0u));
                        ir_expression *const r0983 = expr(ir_unop_b2i, r0982);
                        ir_expression *const r0984 = expr(ir_unop_i2u, r0983);
                        body.emit(assign(r096D, bit_or(r096D, r0984), 0x01));


                     body.instructions = f0972_parent_instructions;
                     body.emit(f0972);

                     /* END IF */

                     body.emit(assign(r0955, r096F, 0x01));

                     body.emit(assign(r0956, r096E, 0x01));

                     body.emit(assign(r0957, r096D, 0x01));

                     body.emit(assign(r0954, body.constant(int(0)), 0x01));

                     body.emit(assign(r095A, less(r096D, body.constant(0u)), 0x01));


                  body.instructions = f0969_parent_instructions;
                  body.emit(f0969);

                  /* END IF */


               body.instructions = f0966_parent_instructions;
               body.emit(f0966);

               /* END IF */


            body.instructions = f095C_parent_instructions;
            body.emit(f095C);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0985 = new(mem_ctx) ir_if(operand(r0958).val);
            exec_list *const f0985_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0985->then_instructions;

               /* IF CONDITION */
               ir_if *f0986 = new(mem_ctx) ir_if(operand(r095A).val);
               exec_list *const f0986_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0986->then_instructions;

                  ir_variable *const r0987 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r0987, add(r0956, body.constant(1u)), 0x01));

                  ir_expression *const r0988 = less(r0987, r0956);
                  ir_expression *const r0989 = expr(ir_unop_b2i, r0988);
                  ir_expression *const r098A = expr(ir_unop_i2u, r0989);
                  body.emit(assign(r0955, add(r0955, r098A), 0x01));

                  ir_expression *const r098B = equal(r0957, body.constant(0u));
                  ir_expression *const r098C = expr(ir_unop_b2i, r098B);
                  ir_expression *const r098D = expr(ir_unop_i2u, r098C);
                  ir_expression *const r098E = add(r0957, r098D);
                  ir_expression *const r098F = bit_and(r098E, body.constant(1u));
                  ir_expression *const r0990 = expr(ir_unop_bit_not, r098F);
                  body.emit(assign(r0956, bit_and(r0987, r0990), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0986->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0992 = bit_or(r0955, r0956);
                  ir_expression *const r0993 = equal(r0992, body.constant(0u));
                  ir_if *f0991 = new(mem_ctx) ir_if(operand(r0993).val);
                  exec_list *const f0991_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0991->then_instructions;

                     body.emit(assign(r0954, body.constant(int(0)), 0x01));


                  body.instructions = f0991_parent_instructions;
                  body.emit(f0991);

                  /* END IF */


               body.instructions = f0986_parent_instructions;
               body.emit(f0986);

               /* END IF */

               ir_variable *const r0994 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0994);
               ir_expression *const r0995 = lshift(r07EC, body.constant(int(31)));
               ir_expression *const r0996 = expr(ir_unop_i2u, r0954);
               ir_expression *const r0997 = lshift(r0996, body.constant(int(20)));
               ir_expression *const r0998 = add(r0995, r0997);
               body.emit(assign(r0994, add(r0998, r0955), 0x02));

               body.emit(assign(r0994, r0956, 0x01));

               body.emit(assign(r0959, r0994, 0x03));

               body.emit(assign(r0958, body.constant(false), 0x01));


            body.instructions = f0985_parent_instructions;
            body.emit(f0985);

            /* END IF */

            body.emit(assign(r07F1, r0959, 0x03));

            body.emit(assign(r07F0, body.constant(false), 0x01));


         body.instructions = f0905_parent_instructions;
         body.emit(f0905);

         /* END IF */


      body.instructions = f08FE_parent_instructions;
      body.emit(f08FE);

      /* END IF */

      body.emit(assign(r07EB, r07F1, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f07EE->else_instructions;

      ir_variable *const r0999 = body.make_temp(glsl_type::uint_type, "zSign");
      body.emit(assign(r0999, r07EC, 0x01));

      ir_variable *const r099A = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r099B = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r099B);
      ir_variable *const r099C = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
      body.emit(r099C);
      ir_variable *const r099D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
      body.emit(r099D);
      ir_variable *const r099E = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
      body.emit(r099E);
      ir_variable *const r099F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
      body.emit(r099F);
      ir_variable *const r09A0 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r09A0);
      ir_variable *const r09A1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r09A1);
      body.emit(assign(r09A1, bit_and(swizzle_y(r07E9), body.constant(1048575u)), 0x02));

      body.emit(assign(r09A1, swizzle_x(r07E9), 0x01));

      ir_variable *const r09A2 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r09A3 = rshift(swizzle_y(r07E9), body.constant(int(20)));
      ir_expression *const r09A4 = bit_and(r09A3, body.constant(2047u));
      body.emit(assign(r09A2, expr(ir_unop_u2i, r09A4), 0x01));

      body.emit(assign(r099E, r09A2, 0x01));

      ir_variable *const r09A5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r09A5);
      body.emit(assign(r09A5, bit_and(swizzle_y(r07EA), body.constant(1048575u)), 0x02));

      body.emit(assign(r09A5, swizzle_x(r07EA), 0x01));

      ir_variable *const r09A6 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r09A7 = rshift(swizzle_y(r07EA), body.constant(int(20)));
      ir_expression *const r09A8 = bit_and(r09A7, body.constant(2047u));
      body.emit(assign(r09A6, expr(ir_unop_u2i, r09A8), 0x01));

      body.emit(assign(r099C, r09A6, 0x01));

      body.emit(assign(r099B, sub(r09A2, r09A6), 0x01));

      ir_variable *const r09A9 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r09A9, lshift(swizzle_x(r07E9), body.constant(int(10))), 0x01));

      ir_variable *const r09AA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r09AB = lshift(swizzle_y(r09A1), body.constant(int(10)));
      ir_expression *const r09AC = rshift(swizzle_x(r07E9), body.constant(int(22)));
      body.emit(assign(r09AA, bit_or(r09AB, r09AC), 0x01));

      body.emit(assign(r099F, r09AA, 0x02));

      body.emit(assign(r099F, r09A9, 0x01));

      ir_variable *const r09AD = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r09AD, lshift(swizzle_x(r07EA), body.constant(int(10))), 0x01));

      ir_variable *const r09AE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r09AF = lshift(swizzle_y(r09A5), body.constant(int(10)));
      ir_expression *const r09B0 = rshift(swizzle_x(r07EA), body.constant(int(22)));
      body.emit(assign(r09AE, bit_or(r09AF, r09B0), 0x01));

      body.emit(assign(r099D, r09AE, 0x02));

      body.emit(assign(r099D, r09AD, 0x01));

      /* IF CONDITION */
      ir_expression *const r09B2 = less(body.constant(int(0)), r099B);
      ir_if *f09B1 = new(mem_ctx) ir_if(operand(r09B2).val);
      exec_list *const f09B1_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f09B1->then_instructions;

         /* IF CONDITION */
         ir_expression *const r09B4 = equal(r09A2, body.constant(int(2047)));
         ir_if *f09B3 = new(mem_ctx) ir_if(operand(r09B4).val);
         exec_list *const f09B3_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f09B3->then_instructions;

            /* IF CONDITION */
            ir_expression *const r09B6 = bit_or(r09AA, r09A9);
            ir_expression *const r09B7 = nequal(r09B6, body.constant(0u));
            ir_if *f09B5 = new(mem_ctx) ir_if(operand(r09B7).val);
            exec_list *const f09B5_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f09B5->then_instructions;

               ir_variable *const r09B8 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r09B8, swizzle_x(r07E9), 0x01));

               ir_variable *const r09B9 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r09B9, swizzle_x(r07EA), 0x01));

               ir_variable *const r09BA = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r09BB = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r09BC = rshift(swizzle_y(r07E9), body.constant(int(19)));
               ir_expression *const r09BD = bit_and(r09BC, body.constant(4095u));
               ir_expression *const r09BE = equal(r09BD, body.constant(4094u));
               ir_expression *const r09BF = nequal(swizzle_x(r07E9), body.constant(0u));
               ir_expression *const r09C0 = bit_and(swizzle_y(r07E9), body.constant(524287u));
               ir_expression *const r09C1 = nequal(r09C0, body.constant(0u));
               ir_expression *const r09C2 = logic_or(r09BF, r09C1);
               body.emit(assign(r09BB, logic_and(r09BE, r09C2), 0x01));

               ir_variable *const r09C3 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r09C4 = lshift(swizzle_y(r07EA), body.constant(int(1)));
               ir_expression *const r09C5 = lequal(body.constant(4292870144u), r09C4);
               ir_expression *const r09C6 = nequal(swizzle_x(r07EA), body.constant(0u));
               ir_expression *const r09C7 = bit_and(swizzle_y(r07EA), body.constant(1048575u));
               ir_expression *const r09C8 = nequal(r09C7, body.constant(0u));
               ir_expression *const r09C9 = logic_or(r09C6, r09C8);
               body.emit(assign(r09C3, logic_and(r09C5, r09C9), 0x01));

               body.emit(assign(r09B8, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

               body.emit(assign(r09B9, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r09CB = lshift(swizzle_y(r07E9), body.constant(int(1)));
               ir_expression *const r09CC = lequal(body.constant(4292870144u), r09CB);
               ir_expression *const r09CD = nequal(swizzle_x(r07E9), body.constant(0u));
               ir_expression *const r09CE = bit_and(swizzle_y(r07E9), body.constant(1048575u));
               ir_expression *const r09CF = nequal(r09CE, body.constant(0u));
               ir_expression *const r09D0 = logic_or(r09CD, r09CF);
               ir_expression *const r09D1 = logic_and(r09CC, r09D0);
               ir_if *f09CA = new(mem_ctx) ir_if(operand(r09D1).val);
               exec_list *const f09CA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f09CA->then_instructions;

                  ir_variable *const r09D2 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r09D4 = logic_and(r09BB, r09C3);
                  ir_if *f09D3 = new(mem_ctx) ir_if(operand(r09D4).val);
                  exec_list *const f09D3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f09D3->then_instructions;

                     body.emit(assign(r09D2, r09B9, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f09D3->else_instructions;

                     body.emit(assign(r09D2, r09B8, 0x03));


                  body.instructions = f09D3_parent_instructions;
                  body.emit(f09D3);

                  /* END IF */

                  body.emit(assign(r09BA, r09D2, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f09CA->else_instructions;

                  body.emit(assign(r09BA, r09B9, 0x03));


               body.instructions = f09CA_parent_instructions;
               body.emit(f09CA);

               /* END IF */

               body.emit(assign(r099A, r09BA, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f09B5->else_instructions;

               body.emit(assign(r099A, r07E9, 0x03));


            body.instructions = f09B5_parent_instructions;
            body.emit(f09B5);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f09B3->else_instructions;

            /* IF CONDITION */
            ir_expression *const r09D6 = equal(r09A6, body.constant(int(0)));
            ir_if *f09D5 = new(mem_ctx) ir_if(operand(r09D6).val);
            exec_list *const f09D5_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f09D5->then_instructions;

               body.emit(assign(r099B, add(r099B, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f09D5->else_instructions;

               body.emit(assign(r099D, bit_or(r09AE, body.constant(1073741824u)), 0x02));


            body.instructions = f09D5_parent_instructions;
            body.emit(f09D5);

            /* END IF */

            ir_variable *const r09D7 = body.make_temp(glsl_type::uint_type, "a0");
            body.emit(assign(r09D7, swizzle_y(r099D), 0x01));

            ir_variable *const r09D8 = body.make_temp(glsl_type::uint_type, "a1");
            body.emit(assign(r09D8, swizzle_x(r099D), 0x01));

            ir_variable *const r09D9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r09D9);
            ir_variable *const r09DA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r09DA);
            ir_variable *const r09DB = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r09DC = neg(r099B);
            body.emit(assign(r09DB, bit_and(r09DC, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r09DE = equal(r099B, body.constant(int(0)));
            ir_if *f09DD = new(mem_ctx) ir_if(operand(r09DE).val);
            exec_list *const f09DD_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f09DD->then_instructions;

               body.emit(assign(r09D9, r09D8, 0x01));

               body.emit(assign(r09DA, r09D7, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f09DD->else_instructions;

               /* IF CONDITION */
               ir_expression *const r09E0 = less(r099B, body.constant(int(32)));
               ir_if *f09DF = new(mem_ctx) ir_if(operand(r09E0).val);
               exec_list *const f09DF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f09DF->then_instructions;

                  ir_expression *const r09E1 = lshift(swizzle_y(r099D), r09DB);
                  ir_expression *const r09E2 = rshift(r09AD, r099B);
                  ir_expression *const r09E3 = bit_or(r09E1, r09E2);
                  ir_expression *const r09E4 = lshift(r09AD, r09DB);
                  ir_expression *const r09E5 = nequal(r09E4, body.constant(0u));
                  ir_expression *const r09E6 = expr(ir_unop_b2i, r09E5);
                  ir_expression *const r09E7 = expr(ir_unop_i2u, r09E6);
                  body.emit(assign(r09D9, bit_or(r09E3, r09E7), 0x01));

                  body.emit(assign(r09DA, rshift(swizzle_y(r099D), r099B), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f09DF->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r09E9 = equal(r099B, body.constant(int(32)));
                  ir_if *f09E8 = new(mem_ctx) ir_if(operand(r09E9).val);
                  exec_list *const f09E8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f09E8->then_instructions;

                     ir_expression *const r09EA = nequal(r09AD, body.constant(0u));
                     ir_expression *const r09EB = expr(ir_unop_b2i, r09EA);
                     ir_expression *const r09EC = expr(ir_unop_i2u, r09EB);
                     body.emit(assign(r09D9, bit_or(swizzle_y(r099D), r09EC), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f09E8->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r09EE = less(r099B, body.constant(int(64)));
                     ir_if *f09ED = new(mem_ctx) ir_if(operand(r09EE).val);
                     exec_list *const f09ED_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f09ED->then_instructions;

                        ir_expression *const r09EF = bit_and(r099B, body.constant(int(31)));
                        ir_expression *const r09F0 = rshift(swizzle_y(r099D), r09EF);
                        ir_expression *const r09F1 = lshift(swizzle_y(r099D), r09DB);
                        ir_expression *const r09F2 = bit_or(r09F1, r09AD);
                        ir_expression *const r09F3 = nequal(r09F2, body.constant(0u));
                        ir_expression *const r09F4 = expr(ir_unop_b2i, r09F3);
                        ir_expression *const r09F5 = expr(ir_unop_i2u, r09F4);
                        body.emit(assign(r09D9, bit_or(r09F0, r09F5), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f09ED->else_instructions;

                        ir_expression *const r09F6 = bit_or(swizzle_y(r099D), r09AD);
                        ir_expression *const r09F7 = nequal(r09F6, body.constant(0u));
                        ir_expression *const r09F8 = expr(ir_unop_b2i, r09F7);
                        body.emit(assign(r09D9, expr(ir_unop_i2u, r09F8), 0x01));


                     body.instructions = f09ED_parent_instructions;
                     body.emit(f09ED);

                     /* END IF */


                  body.instructions = f09E8_parent_instructions;
                  body.emit(f09E8);

                  /* END IF */

                  body.emit(assign(r09DA, body.constant(0u), 0x01));


               body.instructions = f09DF_parent_instructions;
               body.emit(f09DF);

               /* END IF */


            body.instructions = f09DD_parent_instructions;
            body.emit(f09DD);

            /* END IF */

            body.emit(assign(r099D, r09DA, 0x02));

            body.emit(assign(r099D, r09D9, 0x01));

            body.emit(assign(r099F, bit_or(r09AA, body.constant(1073741824u)), 0x02));

            ir_variable *const r09F9 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r09FA = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r09FA, sub(r09A9, r09D9), 0x01));

            ir_expression *const r09FB = sub(swizzle_y(r099F), r09DA);
            ir_expression *const r09FC = less(r09A9, r09D9);
            ir_expression *const r09FD = expr(ir_unop_b2i, r09FC);
            ir_expression *const r09FE = expr(ir_unop_i2u, r09FD);
            body.emit(assign(r09F9, sub(r09FB, r09FE), 0x01));

            body.emit(assign(r09A0, add(r09A2, body.constant(int(-1))), 0x01));

            ir_variable *const r09FF = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r09FF, add(r09A0, body.constant(int(-10))), 0x01));

            ir_variable *const r0A00 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0A00, r09F9, 0x01));

            ir_variable *const r0A01 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0A01, r09FA, 0x01));

            ir_variable *const r0A02 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
            body.emit(r0A02);
            ir_variable *const r0A03 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0A03);
            /* IF CONDITION */
            ir_expression *const r0A05 = equal(r09F9, body.constant(0u));
            ir_if *f0A04 = new(mem_ctx) ir_if(operand(r0A05).val);
            exec_list *const f0A04_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A04->then_instructions;

               body.emit(assign(r0A00, r09FA, 0x01));

               body.emit(assign(r0A01, body.constant(0u), 0x01));

               body.emit(assign(r09FF, add(r09FF, body.constant(int(-32))), 0x01));


            body.instructions = f0A04_parent_instructions;
            body.emit(f0A04);

            /* END IF */

            ir_variable *const r0A06 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r0A06, r0A00, 0x01));

            ir_variable *const r0A07 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r0A08 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0A08);
            /* IF CONDITION */
            ir_expression *const r0A0A = equal(r0A00, body.constant(0u));
            ir_if *f0A09 = new(mem_ctx) ir_if(operand(r0A0A).val);
            exec_list *const f0A09_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A09->then_instructions;

               body.emit(assign(r0A07, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0A09->else_instructions;

               body.emit(assign(r0A08, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r0A0C = bit_and(r0A00, body.constant(4294901760u));
               ir_expression *const r0A0D = equal(r0A0C, body.constant(0u));
               ir_if *f0A0B = new(mem_ctx) ir_if(operand(r0A0D).val);
               exec_list *const f0A0B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A0B->then_instructions;

                  body.emit(assign(r0A08, body.constant(int(16)), 0x01));

                  body.emit(assign(r0A06, lshift(r0A00, body.constant(int(16))), 0x01));


               body.instructions = f0A0B_parent_instructions;
               body.emit(f0A0B);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0A0F = bit_and(r0A06, body.constant(4278190080u));
               ir_expression *const r0A10 = equal(r0A0F, body.constant(0u));
               ir_if *f0A0E = new(mem_ctx) ir_if(operand(r0A10).val);
               exec_list *const f0A0E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A0E->then_instructions;

                  body.emit(assign(r0A08, add(r0A08, body.constant(int(8))), 0x01));

                  body.emit(assign(r0A06, lshift(r0A06, body.constant(int(8))), 0x01));


               body.instructions = f0A0E_parent_instructions;
               body.emit(f0A0E);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0A12 = bit_and(r0A06, body.constant(4026531840u));
               ir_expression *const r0A13 = equal(r0A12, body.constant(0u));
               ir_if *f0A11 = new(mem_ctx) ir_if(operand(r0A13).val);
               exec_list *const f0A11_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A11->then_instructions;

                  body.emit(assign(r0A08, add(r0A08, body.constant(int(4))), 0x01));

                  body.emit(assign(r0A06, lshift(r0A06, body.constant(int(4))), 0x01));


               body.instructions = f0A11_parent_instructions;
               body.emit(f0A11);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0A15 = bit_and(r0A06, body.constant(3221225472u));
               ir_expression *const r0A16 = equal(r0A15, body.constant(0u));
               ir_if *f0A14 = new(mem_ctx) ir_if(operand(r0A16).val);
               exec_list *const f0A14_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A14->then_instructions;

                  body.emit(assign(r0A08, add(r0A08, body.constant(int(2))), 0x01));

                  body.emit(assign(r0A06, lshift(r0A06, body.constant(int(2))), 0x01));


               body.instructions = f0A14_parent_instructions;
               body.emit(f0A14);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0A18 = bit_and(r0A06, body.constant(2147483648u));
               ir_expression *const r0A19 = equal(r0A18, body.constant(0u));
               ir_if *f0A17 = new(mem_ctx) ir_if(operand(r0A19).val);
               exec_list *const f0A17_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A17->then_instructions;

                  body.emit(assign(r0A08, add(r0A08, body.constant(int(1))), 0x01));


               body.instructions = f0A17_parent_instructions;
               body.emit(f0A17);

               /* END IF */

               body.emit(assign(r0A07, r0A08, 0x01));


            body.instructions = f0A09_parent_instructions;
            body.emit(f0A09);

            /* END IF */

            body.emit(assign(r0A03, add(r0A07, body.constant(int(-11))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0A1B = lequal(body.constant(int(0)), r0A03);
            ir_if *f0A1A = new(mem_ctx) ir_if(operand(r0A1B).val);
            exec_list *const f0A1A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A1A->then_instructions;

               body.emit(assign(r0A02, body.constant(0u), 0x01));

               ir_variable *const r0A1C = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r0A1C, lshift(r0A01, r0A03), 0x01));

               ir_variable *const r0A1D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r0A1F = equal(r0A03, body.constant(int(0)));
               ir_if *f0A1E = new(mem_ctx) ir_if(operand(r0A1F).val);
               exec_list *const f0A1E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A1E->then_instructions;

                  body.emit(assign(r0A1D, r0A00, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A1E->else_instructions;

                  ir_expression *const r0A20 = lshift(r0A00, r0A03);
                  ir_expression *const r0A21 = neg(r0A03);
                  ir_expression *const r0A22 = bit_and(r0A21, body.constant(int(31)));
                  ir_expression *const r0A23 = rshift(r0A01, r0A22);
                  body.emit(assign(r0A1D, bit_or(r0A20, r0A23), 0x01));


               body.instructions = f0A1E_parent_instructions;
               body.emit(f0A1E);

               /* END IF */

               body.emit(assign(r0A00, r0A1D, 0x01));

               body.emit(assign(r0A01, r0A1C, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0A1A->else_instructions;

               ir_variable *const r0A24 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r0A24, body.constant(0u), 0x01));

               ir_variable *const r0A25 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0A25, neg(r0A03), 0x01));

               ir_variable *const r0A26 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r0A26);
               ir_variable *const r0A27 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0A27);
               ir_variable *const r0A28 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0A28);
               ir_variable *const r0A29 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0A2A = neg(r0A25);
               body.emit(assign(r0A29, bit_and(r0A2A, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0A2C = equal(r0A25, body.constant(int(0)));
               ir_if *f0A2B = new(mem_ctx) ir_if(operand(r0A2C).val);
               exec_list *const f0A2B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A2B->then_instructions;

                  body.emit(assign(r0A26, r0A24, 0x01));

                  body.emit(assign(r0A27, r0A01, 0x01));

                  body.emit(assign(r0A28, r0A00, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A2B->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0A2E = less(r0A25, body.constant(int(32)));
                  ir_if *f0A2D = new(mem_ctx) ir_if(operand(r0A2E).val);
                  exec_list *const f0A2D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A2D->then_instructions;

                     body.emit(assign(r0A26, lshift(r0A01, r0A29), 0x01));

                     ir_expression *const r0A2F = lshift(r0A00, r0A29);
                     ir_expression *const r0A30 = rshift(r0A01, r0A25);
                     body.emit(assign(r0A27, bit_or(r0A2F, r0A30), 0x01));

                     body.emit(assign(r0A28, rshift(r0A00, r0A25), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0A2D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0A32 = equal(r0A25, body.constant(int(32)));
                     ir_if *f0A31 = new(mem_ctx) ir_if(operand(r0A32).val);
                     exec_list *const f0A31_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0A31->then_instructions;

                        body.emit(assign(r0A26, r0A01, 0x01));

                        body.emit(assign(r0A27, r0A00, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0A31->else_instructions;

                        body.emit(assign(r0A24, bit_or(body.constant(0u), r0A01), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0A34 = less(r0A25, body.constant(int(64)));
                        ir_if *f0A33 = new(mem_ctx) ir_if(operand(r0A34).val);
                        exec_list *const f0A33_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0A33->then_instructions;

                           body.emit(assign(r0A26, lshift(r0A00, r0A29), 0x01));

                           ir_expression *const r0A35 = bit_and(r0A25, body.constant(int(31)));
                           body.emit(assign(r0A27, rshift(r0A00, r0A35), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0A33->else_instructions;

                           ir_variable *const r0A36 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0A38 = equal(r0A25, body.constant(int(64)));
                           ir_if *f0A37 = new(mem_ctx) ir_if(operand(r0A38).val);
                           exec_list *const f0A37_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0A37->then_instructions;

                              body.emit(assign(r0A36, r0A00, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0A37->else_instructions;

                              ir_expression *const r0A39 = nequal(r0A00, body.constant(0u));
                              ir_expression *const r0A3A = expr(ir_unop_b2i, r0A39);
                              body.emit(assign(r0A36, expr(ir_unop_i2u, r0A3A), 0x01));


                           body.instructions = f0A37_parent_instructions;
                           body.emit(f0A37);

                           /* END IF */

                           body.emit(assign(r0A26, r0A36, 0x01));

                           body.emit(assign(r0A27, body.constant(0u), 0x01));


                        body.instructions = f0A33_parent_instructions;
                        body.emit(f0A33);

                        /* END IF */


                     body.instructions = f0A31_parent_instructions;
                     body.emit(f0A31);

                     /* END IF */

                     body.emit(assign(r0A28, body.constant(0u), 0x01));


                  body.instructions = f0A2D_parent_instructions;
                  body.emit(f0A2D);

                  /* END IF */

                  ir_expression *const r0A3B = nequal(r0A24, body.constant(0u));
                  ir_expression *const r0A3C = expr(ir_unop_b2i, r0A3B);
                  ir_expression *const r0A3D = expr(ir_unop_i2u, r0A3C);
                  body.emit(assign(r0A26, bit_or(r0A26, r0A3D), 0x01));


               body.instructions = f0A2B_parent_instructions;
               body.emit(f0A2B);

               /* END IF */

               body.emit(assign(r0A00, r0A28, 0x01));

               body.emit(assign(r0A01, r0A27, 0x01));

               body.emit(assign(r0A02, r0A26, 0x01));


            body.instructions = f0A1A_parent_instructions;
            body.emit(f0A1A);

            /* END IF */

            body.emit(assign(r09FF, sub(r09FF, r0A03), 0x01));

            ir_variable *const r0A3E = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0A3E, r09FF, 0x01));

            ir_variable *const r0A3F = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0A3F, r0A00, 0x01));

            ir_variable *const r0A40 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0A40, r0A01, 0x01));

            ir_variable *const r0A41 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r0A41, r0A02, 0x01));

            ir_variable *const r0A42 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r0A42, body.constant(true), 0x01));

            ir_variable *const r0A43 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0A44 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r0A44);
            ir_expression *const r0A45 = expr(ir_unop_u2i, r0A02);
            body.emit(assign(r0A44, less(r0A45, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0A47 = lequal(body.constant(int(2045)), r09FF);
            ir_if *f0A46 = new(mem_ctx) ir_if(operand(r0A47).val);
            exec_list *const f0A46_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A46->then_instructions;

               ir_variable *const r0A48 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0A4A = less(body.constant(int(2045)), r09FF);
               ir_if *f0A49 = new(mem_ctx) ir_if(operand(r0A4A).val);
               exec_list *const f0A49_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A49->then_instructions;

                  body.emit(assign(r0A48, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A49->else_instructions;

                  ir_variable *const r0A4B = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0A4D = equal(r09FF, body.constant(int(2045)));
                  ir_if *f0A4C = new(mem_ctx) ir_if(operand(r0A4D).val);
                  exec_list *const f0A4C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A4C->then_instructions;

                     ir_expression *const r0A4E = equal(body.constant(2097151u), r0A00);
                     ir_expression *const r0A4F = equal(body.constant(4294967295u), r0A01);
                     body.emit(assign(r0A4B, logic_and(r0A4E, r0A4F), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0A4C->else_instructions;

                     body.emit(assign(r0A4B, body.constant(false), 0x01));


                  body.instructions = f0A4C_parent_instructions;
                  body.emit(f0A4C);

                  /* END IF */

                  body.emit(assign(r0A48, logic_and(r0A4B, r0A44), 0x01));


               body.instructions = f0A49_parent_instructions;
               body.emit(f0A49);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0A50 = new(mem_ctx) ir_if(operand(r0A48).val);
               exec_list *const f0A50_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A50->then_instructions;

                  ir_variable *const r0A51 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0A51);
                  ir_expression *const r0A52 = lshift(r07EC, body.constant(int(31)));
                  body.emit(assign(r0A51, add(r0A52, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0A51, body.constant(0u), 0x01));

                  body.emit(assign(r0A43, r0A51, 0x03));

                  body.emit(assign(r0A42, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A50->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0A54 = less(r09FF, body.constant(int(0)));
                  ir_if *f0A53 = new(mem_ctx) ir_if(operand(r0A54).val);
                  exec_list *const f0A53_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A53->then_instructions;

                     ir_variable *const r0A55 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0A55, r0A02, 0x01));

                     ir_variable *const r0A56 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0A56, neg(r09FF), 0x01));

                     ir_variable *const r0A57 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0A57);
                     ir_variable *const r0A58 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0A58);
                     ir_variable *const r0A59 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0A59);
                     ir_variable *const r0A5A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0A5B = neg(r0A56);
                     body.emit(assign(r0A5A, bit_and(r0A5B, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0A5D = equal(r0A56, body.constant(int(0)));
                     ir_if *f0A5C = new(mem_ctx) ir_if(operand(r0A5D).val);
                     exec_list *const f0A5C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0A5C->then_instructions;

                        body.emit(assign(r0A57, r0A02, 0x01));

                        body.emit(assign(r0A58, r0A01, 0x01));

                        body.emit(assign(r0A59, r0A00, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0A5C->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0A5F = less(r0A56, body.constant(int(32)));
                        ir_if *f0A5E = new(mem_ctx) ir_if(operand(r0A5F).val);
                        exec_list *const f0A5E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0A5E->then_instructions;

                           body.emit(assign(r0A57, lshift(r0A01, r0A5A), 0x01));

                           ir_expression *const r0A60 = lshift(r0A00, r0A5A);
                           ir_expression *const r0A61 = rshift(r0A01, r0A56);
                           body.emit(assign(r0A58, bit_or(r0A60, r0A61), 0x01));

                           body.emit(assign(r0A59, rshift(r0A00, r0A56), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0A5E->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0A63 = equal(r0A56, body.constant(int(32)));
                           ir_if *f0A62 = new(mem_ctx) ir_if(operand(r0A63).val);
                           exec_list *const f0A62_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0A62->then_instructions;

                              body.emit(assign(r0A57, r0A01, 0x01));

                              body.emit(assign(r0A58, r0A00, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0A62->else_instructions;

                              body.emit(assign(r0A55, bit_or(r0A02, r0A01), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0A65 = less(r0A56, body.constant(int(64)));
                              ir_if *f0A64 = new(mem_ctx) ir_if(operand(r0A65).val);
                              exec_list *const f0A64_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0A64->then_instructions;

                                 body.emit(assign(r0A57, lshift(r0A00, r0A5A), 0x01));

                                 ir_expression *const r0A66 = bit_and(r0A56, body.constant(int(31)));
                                 body.emit(assign(r0A58, rshift(r0A00, r0A66), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0A64->else_instructions;

                                 ir_variable *const r0A67 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0A69 = equal(r0A56, body.constant(int(64)));
                                 ir_if *f0A68 = new(mem_ctx) ir_if(operand(r0A69).val);
                                 exec_list *const f0A68_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0A68->then_instructions;

                                    body.emit(assign(r0A67, r0A00, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0A68->else_instructions;

                                    ir_expression *const r0A6A = nequal(r0A00, body.constant(0u));
                                    ir_expression *const r0A6B = expr(ir_unop_b2i, r0A6A);
                                    body.emit(assign(r0A67, expr(ir_unop_i2u, r0A6B), 0x01));


                                 body.instructions = f0A68_parent_instructions;
                                 body.emit(f0A68);

                                 /* END IF */

                                 body.emit(assign(r0A57, r0A67, 0x01));

                                 body.emit(assign(r0A58, body.constant(0u), 0x01));


                              body.instructions = f0A64_parent_instructions;
                              body.emit(f0A64);

                              /* END IF */


                           body.instructions = f0A62_parent_instructions;
                           body.emit(f0A62);

                           /* END IF */

                           body.emit(assign(r0A59, body.constant(0u), 0x01));


                        body.instructions = f0A5E_parent_instructions;
                        body.emit(f0A5E);

                        /* END IF */

                        ir_expression *const r0A6C = nequal(r0A55, body.constant(0u));
                        ir_expression *const r0A6D = expr(ir_unop_b2i, r0A6C);
                        ir_expression *const r0A6E = expr(ir_unop_i2u, r0A6D);
                        body.emit(assign(r0A57, bit_or(r0A57, r0A6E), 0x01));


                     body.instructions = f0A5C_parent_instructions;
                     body.emit(f0A5C);

                     /* END IF */

                     body.emit(assign(r0A3F, r0A59, 0x01));

                     body.emit(assign(r0A40, r0A58, 0x01));

                     body.emit(assign(r0A41, r0A57, 0x01));

                     body.emit(assign(r0A3E, body.constant(int(0)), 0x01));

                     body.emit(assign(r0A44, less(r0A57, body.constant(0u)), 0x01));


                  body.instructions = f0A53_parent_instructions;
                  body.emit(f0A53);

                  /* END IF */


               body.instructions = f0A50_parent_instructions;
               body.emit(f0A50);

               /* END IF */


            body.instructions = f0A46_parent_instructions;
            body.emit(f0A46);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0A6F = new(mem_ctx) ir_if(operand(r0A42).val);
            exec_list *const f0A6F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A6F->then_instructions;

               /* IF CONDITION */
               ir_if *f0A70 = new(mem_ctx) ir_if(operand(r0A44).val);
               exec_list *const f0A70_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A70->then_instructions;

                  ir_variable *const r0A71 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r0A71, add(r0A40, body.constant(1u)), 0x01));

                  ir_expression *const r0A72 = less(r0A71, r0A40);
                  ir_expression *const r0A73 = expr(ir_unop_b2i, r0A72);
                  ir_expression *const r0A74 = expr(ir_unop_i2u, r0A73);
                  body.emit(assign(r0A3F, add(r0A3F, r0A74), 0x01));

                  ir_expression *const r0A75 = equal(r0A41, body.constant(0u));
                  ir_expression *const r0A76 = expr(ir_unop_b2i, r0A75);
                  ir_expression *const r0A77 = expr(ir_unop_i2u, r0A76);
                  ir_expression *const r0A78 = add(r0A41, r0A77);
                  ir_expression *const r0A79 = bit_and(r0A78, body.constant(1u));
                  ir_expression *const r0A7A = expr(ir_unop_bit_not, r0A79);
                  body.emit(assign(r0A40, bit_and(r0A71, r0A7A), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A70->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0A7C = bit_or(r0A3F, r0A40);
                  ir_expression *const r0A7D = equal(r0A7C, body.constant(0u));
                  ir_if *f0A7B = new(mem_ctx) ir_if(operand(r0A7D).val);
                  exec_list *const f0A7B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A7B->then_instructions;

                     body.emit(assign(r0A3E, body.constant(int(0)), 0x01));


                  body.instructions = f0A7B_parent_instructions;
                  body.emit(f0A7B);

                  /* END IF */


               body.instructions = f0A70_parent_instructions;
               body.emit(f0A70);

               /* END IF */

               ir_variable *const r0A7E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0A7E);
               ir_expression *const r0A7F = lshift(r07EC, body.constant(int(31)));
               ir_expression *const r0A80 = expr(ir_unop_i2u, r0A3E);
               ir_expression *const r0A81 = lshift(r0A80, body.constant(int(20)));
               ir_expression *const r0A82 = add(r0A7F, r0A81);
               body.emit(assign(r0A7E, add(r0A82, r0A3F), 0x02));

               body.emit(assign(r0A7E, r0A40, 0x01));

               body.emit(assign(r0A43, r0A7E, 0x03));

               body.emit(assign(r0A42, body.constant(false), 0x01));


            body.instructions = f0A6F_parent_instructions;
            body.emit(f0A6F);

            /* END IF */

            body.emit(assign(r099A, r0A43, 0x03));


         body.instructions = f09B3_parent_instructions;
         body.emit(f09B3);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f09B1->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0A84 = less(r099B, body.constant(int(0)));
         ir_if *f0A83 = new(mem_ctx) ir_if(operand(r0A84).val);
         exec_list *const f0A83_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0A83->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0A86 = equal(r09A6, body.constant(int(2047)));
            ir_if *f0A85 = new(mem_ctx) ir_if(operand(r0A86).val);
            exec_list *const f0A85_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A85->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0A88 = bit_or(swizzle_y(r099D), swizzle_x(r099D));
               ir_expression *const r0A89 = nequal(r0A88, body.constant(0u));
               ir_if *f0A87 = new(mem_ctx) ir_if(operand(r0A89).val);
               exec_list *const f0A87_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A87->then_instructions;

                  ir_variable *const r0A8A = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r0A8A, swizzle_x(r07E9), 0x01));

                  ir_variable *const r0A8B = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r0A8B, swizzle_x(r07EA), 0x01));

                  ir_variable *const r0A8C = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0A8D = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0A8E = rshift(swizzle_y(r07E9), body.constant(int(19)));
                  ir_expression *const r0A8F = bit_and(r0A8E, body.constant(4095u));
                  ir_expression *const r0A90 = equal(r0A8F, body.constant(4094u));
                  ir_expression *const r0A91 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0A92 = bit_and(swizzle_y(r07E9), body.constant(524287u));
                  ir_expression *const r0A93 = nequal(r0A92, body.constant(0u));
                  ir_expression *const r0A94 = logic_or(r0A91, r0A93);
                  body.emit(assign(r0A8D, logic_and(r0A90, r0A94), 0x01));

                  ir_variable *const r0A95 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0A96 = lshift(swizzle_y(r07EA), body.constant(int(1)));
                  ir_expression *const r0A97 = lequal(body.constant(4292870144u), r0A96);
                  ir_expression *const r0A98 = nequal(swizzle_x(r07EA), body.constant(0u));
                  ir_expression *const r0A99 = bit_and(swizzle_y(r07EA), body.constant(1048575u));
                  ir_expression *const r0A9A = nequal(r0A99, body.constant(0u));
                  ir_expression *const r0A9B = logic_or(r0A98, r0A9A);
                  body.emit(assign(r0A95, logic_and(r0A97, r0A9B), 0x01));

                  body.emit(assign(r0A8A, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

                  body.emit(assign(r0A8B, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r0A9D = lshift(swizzle_y(r07E9), body.constant(int(1)));
                  ir_expression *const r0A9E = lequal(body.constant(4292870144u), r0A9D);
                  ir_expression *const r0A9F = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0AA0 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
                  ir_expression *const r0AA1 = nequal(r0AA0, body.constant(0u));
                  ir_expression *const r0AA2 = logic_or(r0A9F, r0AA1);
                  ir_expression *const r0AA3 = logic_and(r0A9E, r0AA2);
                  ir_if *f0A9C = new(mem_ctx) ir_if(operand(r0AA3).val);
                  exec_list *const f0A9C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A9C->then_instructions;

                     ir_variable *const r0AA4 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0AA6 = logic_and(r0A8D, r0A95);
                     ir_if *f0AA5 = new(mem_ctx) ir_if(operand(r0AA6).val);
                     exec_list *const f0AA5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0AA5->then_instructions;

                        body.emit(assign(r0AA4, r0A8B, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0AA5->else_instructions;

                        body.emit(assign(r0AA4, r0A8A, 0x03));


                     body.instructions = f0AA5_parent_instructions;
                     body.emit(f0AA5);

                     /* END IF */

                     body.emit(assign(r0A8C, r0AA4, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0A9C->else_instructions;

                     body.emit(assign(r0A8C, r0A8B, 0x03));


                  body.instructions = f0A9C_parent_instructions;
                  body.emit(f0A9C);

                  /* END IF */

                  body.emit(assign(r099A, r0A8C, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A87->else_instructions;

                  ir_variable *const r0AA7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0AA7);
                  ir_expression *const r0AA8 = bit_xor(r07EC, body.constant(1u));
                  ir_expression *const r0AA9 = lshift(r0AA8, body.constant(int(31)));
                  body.emit(assign(r0AA7, add(r0AA9, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0AA7, body.constant(0u), 0x01));

                  body.emit(assign(r099A, r0AA7, 0x03));


               body.instructions = f0A87_parent_instructions;
               body.emit(f0A87);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0A85->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0AAB = equal(r09A2, body.constant(int(0)));
               ir_if *f0AAA = new(mem_ctx) ir_if(operand(r0AAB).val);
               exec_list *const f0AAA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0AAA->then_instructions;

                  body.emit(assign(r099B, add(r099B, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0AAA->else_instructions;

                  body.emit(assign(r099F, bit_or(swizzle_y(r099F), body.constant(1073741824u)), 0x02));


               body.instructions = f0AAA_parent_instructions;
               body.emit(f0AAA);

               /* END IF */

               ir_variable *const r0AAC = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r0AAC, swizzle_y(r099F), 0x01));

               ir_variable *const r0AAD = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r0AAD, swizzle_x(r099F), 0x01));

               ir_variable *const r0AAE = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0AAE, neg(r099B), 0x01));

               ir_variable *const r0AAF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0AAF);
               ir_variable *const r0AB0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0AB0);
               ir_variable *const r0AB1 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0AB2 = neg(r0AAE);
               body.emit(assign(r0AB1, bit_and(r0AB2, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0AB4 = equal(r0AAE, body.constant(int(0)));
               ir_if *f0AB3 = new(mem_ctx) ir_if(operand(r0AB4).val);
               exec_list *const f0AB3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0AB3->then_instructions;

                  body.emit(assign(r0AAF, r0AAD, 0x01));

                  body.emit(assign(r0AB0, r0AAC, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0AB3->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0AB6 = less(r0AAE, body.constant(int(32)));
                  ir_if *f0AB5 = new(mem_ctx) ir_if(operand(r0AB6).val);
                  exec_list *const f0AB5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AB5->then_instructions;

                     ir_expression *const r0AB7 = lshift(swizzle_y(r099F), r0AB1);
                     ir_expression *const r0AB8 = rshift(r09A9, r0AAE);
                     ir_expression *const r0AB9 = bit_or(r0AB7, r0AB8);
                     ir_expression *const r0ABA = lshift(r09A9, r0AB1);
                     ir_expression *const r0ABB = nequal(r0ABA, body.constant(0u));
                     ir_expression *const r0ABC = expr(ir_unop_b2i, r0ABB);
                     ir_expression *const r0ABD = expr(ir_unop_i2u, r0ABC);
                     body.emit(assign(r0AAF, bit_or(r0AB9, r0ABD), 0x01));

                     body.emit(assign(r0AB0, rshift(swizzle_y(r099F), r0AAE), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0AB5->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0ABF = equal(r0AAE, body.constant(int(32)));
                     ir_if *f0ABE = new(mem_ctx) ir_if(operand(r0ABF).val);
                     exec_list *const f0ABE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0ABE->then_instructions;

                        ir_expression *const r0AC0 = nequal(r09A9, body.constant(0u));
                        ir_expression *const r0AC1 = expr(ir_unop_b2i, r0AC0);
                        ir_expression *const r0AC2 = expr(ir_unop_i2u, r0AC1);
                        body.emit(assign(r0AAF, bit_or(swizzle_y(r099F), r0AC2), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0ABE->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0AC4 = less(r0AAE, body.constant(int(64)));
                        ir_if *f0AC3 = new(mem_ctx) ir_if(operand(r0AC4).val);
                        exec_list *const f0AC3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0AC3->then_instructions;

                           ir_expression *const r0AC5 = bit_and(r0AAE, body.constant(int(31)));
                           ir_expression *const r0AC6 = rshift(swizzle_y(r099F), r0AC5);
                           ir_expression *const r0AC7 = lshift(swizzle_y(r099F), r0AB1);
                           ir_expression *const r0AC8 = bit_or(r0AC7, r09A9);
                           ir_expression *const r0AC9 = nequal(r0AC8, body.constant(0u));
                           ir_expression *const r0ACA = expr(ir_unop_b2i, r0AC9);
                           ir_expression *const r0ACB = expr(ir_unop_i2u, r0ACA);
                           body.emit(assign(r0AAF, bit_or(r0AC6, r0ACB), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0AC3->else_instructions;

                           ir_expression *const r0ACC = bit_or(swizzle_y(r099F), r09A9);
                           ir_expression *const r0ACD = nequal(r0ACC, body.constant(0u));
                           ir_expression *const r0ACE = expr(ir_unop_b2i, r0ACD);
                           body.emit(assign(r0AAF, expr(ir_unop_i2u, r0ACE), 0x01));


                        body.instructions = f0AC3_parent_instructions;
                        body.emit(f0AC3);

                        /* END IF */


                     body.instructions = f0ABE_parent_instructions;
                     body.emit(f0ABE);

                     /* END IF */

                     body.emit(assign(r0AB0, body.constant(0u), 0x01));


                  body.instructions = f0AB5_parent_instructions;
                  body.emit(f0AB5);

                  /* END IF */


               body.instructions = f0AB3_parent_instructions;
               body.emit(f0AB3);

               /* END IF */

               body.emit(assign(r099F, r0AB0, 0x02));

               body.emit(assign(r099F, r0AAF, 0x01));

               body.emit(assign(r099D, bit_or(swizzle_y(r099D), body.constant(1073741824u)), 0x02));

               ir_variable *const r0ACF = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r0AD0 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r0AD0, sub(swizzle_x(r099D), r0AAF), 0x01));

               ir_expression *const r0AD1 = sub(swizzle_y(r099D), r0AB0);
               ir_expression *const r0AD2 = less(swizzle_x(r099D), r0AAF);
               ir_expression *const r0AD3 = expr(ir_unop_b2i, r0AD2);
               ir_expression *const r0AD4 = expr(ir_unop_i2u, r0AD3);
               body.emit(assign(r0ACF, sub(r0AD1, r0AD4), 0x01));

               body.emit(assign(r0999, bit_xor(r07EC, body.constant(1u)), 0x01));

               body.emit(assign(r09A0, add(r09A6, body.constant(int(-1))), 0x01));

               ir_variable *const r0AD5 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r0AD5, add(r09A0, body.constant(int(-10))), 0x01));

               ir_variable *const r0AD6 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0AD6, r0ACF, 0x01));

               ir_variable *const r0AD7 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0AD7, r0AD0, 0x01));

               ir_variable *const r0AD8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r0AD8);
               ir_variable *const r0AD9 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r0AD9);
               /* IF CONDITION */
               ir_expression *const r0ADB = equal(r0ACF, body.constant(0u));
               ir_if *f0ADA = new(mem_ctx) ir_if(operand(r0ADB).val);
               exec_list *const f0ADA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0ADA->then_instructions;

                  body.emit(assign(r0AD6, r0AD0, 0x01));

                  body.emit(assign(r0AD7, body.constant(0u), 0x01));

                  body.emit(assign(r0AD5, add(r0AD5, body.constant(int(-32))), 0x01));


               body.instructions = f0ADA_parent_instructions;
               body.emit(f0ADA);

               /* END IF */

               ir_variable *const r0ADC = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r0ADC, r0AD6, 0x01));

               ir_variable *const r0ADD = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r0ADE = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r0ADE);
               /* IF CONDITION */
               ir_expression *const r0AE0 = equal(r0AD6, body.constant(0u));
               ir_if *f0ADF = new(mem_ctx) ir_if(operand(r0AE0).val);
               exec_list *const f0ADF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0ADF->then_instructions;

                  body.emit(assign(r0ADD, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0ADF->else_instructions;

                  body.emit(assign(r0ADE, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0AE2 = bit_and(r0AD6, body.constant(4294901760u));
                  ir_expression *const r0AE3 = equal(r0AE2, body.constant(0u));
                  ir_if *f0AE1 = new(mem_ctx) ir_if(operand(r0AE3).val);
                  exec_list *const f0AE1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AE1->then_instructions;

                     body.emit(assign(r0ADE, body.constant(int(16)), 0x01));

                     body.emit(assign(r0ADC, lshift(r0AD6, body.constant(int(16))), 0x01));


                  body.instructions = f0AE1_parent_instructions;
                  body.emit(f0AE1);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0AE5 = bit_and(r0ADC, body.constant(4278190080u));
                  ir_expression *const r0AE6 = equal(r0AE5, body.constant(0u));
                  ir_if *f0AE4 = new(mem_ctx) ir_if(operand(r0AE6).val);
                  exec_list *const f0AE4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AE4->then_instructions;

                     body.emit(assign(r0ADE, add(r0ADE, body.constant(int(8))), 0x01));

                     body.emit(assign(r0ADC, lshift(r0ADC, body.constant(int(8))), 0x01));


                  body.instructions = f0AE4_parent_instructions;
                  body.emit(f0AE4);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0AE8 = bit_and(r0ADC, body.constant(4026531840u));
                  ir_expression *const r0AE9 = equal(r0AE8, body.constant(0u));
                  ir_if *f0AE7 = new(mem_ctx) ir_if(operand(r0AE9).val);
                  exec_list *const f0AE7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AE7->then_instructions;

                     body.emit(assign(r0ADE, add(r0ADE, body.constant(int(4))), 0x01));

                     body.emit(assign(r0ADC, lshift(r0ADC, body.constant(int(4))), 0x01));


                  body.instructions = f0AE7_parent_instructions;
                  body.emit(f0AE7);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0AEB = bit_and(r0ADC, body.constant(3221225472u));
                  ir_expression *const r0AEC = equal(r0AEB, body.constant(0u));
                  ir_if *f0AEA = new(mem_ctx) ir_if(operand(r0AEC).val);
                  exec_list *const f0AEA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AEA->then_instructions;

                     body.emit(assign(r0ADE, add(r0ADE, body.constant(int(2))), 0x01));

                     body.emit(assign(r0ADC, lshift(r0ADC, body.constant(int(2))), 0x01));


                  body.instructions = f0AEA_parent_instructions;
                  body.emit(f0AEA);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0AEE = bit_and(r0ADC, body.constant(2147483648u));
                  ir_expression *const r0AEF = equal(r0AEE, body.constant(0u));
                  ir_if *f0AED = new(mem_ctx) ir_if(operand(r0AEF).val);
                  exec_list *const f0AED_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AED->then_instructions;

                     body.emit(assign(r0ADE, add(r0ADE, body.constant(int(1))), 0x01));


                  body.instructions = f0AED_parent_instructions;
                  body.emit(f0AED);

                  /* END IF */

                  body.emit(assign(r0ADD, r0ADE, 0x01));


               body.instructions = f0ADF_parent_instructions;
               body.emit(f0ADF);

               /* END IF */

               body.emit(assign(r0AD9, add(r0ADD, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0AF1 = lequal(body.constant(int(0)), r0AD9);
               ir_if *f0AF0 = new(mem_ctx) ir_if(operand(r0AF1).val);
               exec_list *const f0AF0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0AF0->then_instructions;

                  body.emit(assign(r0AD8, body.constant(0u), 0x01));

                  ir_variable *const r0AF2 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0AF2, lshift(r0AD7, r0AD9), 0x01));

                  ir_variable *const r0AF3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0AF5 = equal(r0AD9, body.constant(int(0)));
                  ir_if *f0AF4 = new(mem_ctx) ir_if(operand(r0AF5).val);
                  exec_list *const f0AF4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AF4->then_instructions;

                     body.emit(assign(r0AF3, r0AD6, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0AF4->else_instructions;

                     ir_expression *const r0AF6 = lshift(r0AD6, r0AD9);
                     ir_expression *const r0AF7 = neg(r0AD9);
                     ir_expression *const r0AF8 = bit_and(r0AF7, body.constant(int(31)));
                     ir_expression *const r0AF9 = rshift(r0AD7, r0AF8);
                     body.emit(assign(r0AF3, bit_or(r0AF6, r0AF9), 0x01));


                  body.instructions = f0AF4_parent_instructions;
                  body.emit(f0AF4);

                  /* END IF */

                  body.emit(assign(r0AD6, r0AF3, 0x01));

                  body.emit(assign(r0AD7, r0AF2, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0AF0->else_instructions;

                  ir_variable *const r0AFA = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r0AFA, body.constant(0u), 0x01));

                  ir_variable *const r0AFB = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r0AFB, neg(r0AD9), 0x01));

                  ir_variable *const r0AFC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r0AFC);
                  ir_variable *const r0AFD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r0AFD);
                  ir_variable *const r0AFE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r0AFE);
                  ir_variable *const r0AFF = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r0B00 = neg(r0AFB);
                  body.emit(assign(r0AFF, bit_and(r0B00, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0B02 = equal(r0AFB, body.constant(int(0)));
                  ir_if *f0B01 = new(mem_ctx) ir_if(operand(r0B02).val);
                  exec_list *const f0B01_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B01->then_instructions;

                     body.emit(assign(r0AFC, r0AFA, 0x01));

                     body.emit(assign(r0AFD, r0AD7, 0x01));

                     body.emit(assign(r0AFE, r0AD6, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B01->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0B04 = less(r0AFB, body.constant(int(32)));
                     ir_if *f0B03 = new(mem_ctx) ir_if(operand(r0B04).val);
                     exec_list *const f0B03_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B03->then_instructions;

                        body.emit(assign(r0AFC, lshift(r0AD7, r0AFF), 0x01));

                        ir_expression *const r0B05 = lshift(r0AD6, r0AFF);
                        ir_expression *const r0B06 = rshift(r0AD7, r0AFB);
                        body.emit(assign(r0AFD, bit_or(r0B05, r0B06), 0x01));

                        body.emit(assign(r0AFE, rshift(r0AD6, r0AFB), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0B03->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0B08 = equal(r0AFB, body.constant(int(32)));
                        ir_if *f0B07 = new(mem_ctx) ir_if(operand(r0B08).val);
                        exec_list *const f0B07_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0B07->then_instructions;

                           body.emit(assign(r0AFC, r0AD7, 0x01));

                           body.emit(assign(r0AFD, r0AD6, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0B07->else_instructions;

                           body.emit(assign(r0AFA, bit_or(body.constant(0u), r0AD7), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0B0A = less(r0AFB, body.constant(int(64)));
                           ir_if *f0B09 = new(mem_ctx) ir_if(operand(r0B0A).val);
                           exec_list *const f0B09_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0B09->then_instructions;

                              body.emit(assign(r0AFC, lshift(r0AD6, r0AFF), 0x01));

                              ir_expression *const r0B0B = bit_and(r0AFB, body.constant(int(31)));
                              body.emit(assign(r0AFD, rshift(r0AD6, r0B0B), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0B09->else_instructions;

                              ir_variable *const r0B0C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0B0E = equal(r0AFB, body.constant(int(64)));
                              ir_if *f0B0D = new(mem_ctx) ir_if(operand(r0B0E).val);
                              exec_list *const f0B0D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0B0D->then_instructions;

                                 body.emit(assign(r0B0C, r0AD6, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0B0D->else_instructions;

                                 ir_expression *const r0B0F = nequal(r0AD6, body.constant(0u));
                                 ir_expression *const r0B10 = expr(ir_unop_b2i, r0B0F);
                                 body.emit(assign(r0B0C, expr(ir_unop_i2u, r0B10), 0x01));


                              body.instructions = f0B0D_parent_instructions;
                              body.emit(f0B0D);

                              /* END IF */

                              body.emit(assign(r0AFC, r0B0C, 0x01));

                              body.emit(assign(r0AFD, body.constant(0u), 0x01));


                           body.instructions = f0B09_parent_instructions;
                           body.emit(f0B09);

                           /* END IF */


                        body.instructions = f0B07_parent_instructions;
                        body.emit(f0B07);

                        /* END IF */

                        body.emit(assign(r0AFE, body.constant(0u), 0x01));


                     body.instructions = f0B03_parent_instructions;
                     body.emit(f0B03);

                     /* END IF */

                     ir_expression *const r0B11 = nequal(r0AFA, body.constant(0u));
                     ir_expression *const r0B12 = expr(ir_unop_b2i, r0B11);
                     ir_expression *const r0B13 = expr(ir_unop_i2u, r0B12);
                     body.emit(assign(r0AFC, bit_or(r0AFC, r0B13), 0x01));


                  body.instructions = f0B01_parent_instructions;
                  body.emit(f0B01);

                  /* END IF */

                  body.emit(assign(r0AD6, r0AFE, 0x01));

                  body.emit(assign(r0AD7, r0AFD, 0x01));

                  body.emit(assign(r0AD8, r0AFC, 0x01));


               body.instructions = f0AF0_parent_instructions;
               body.emit(f0AF0);

               /* END IF */

               body.emit(assign(r0AD5, sub(r0AD5, r0AD9), 0x01));

               ir_variable *const r0B14 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r0B14, r0AD5, 0x01));

               ir_variable *const r0B15 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0B15, r0AD6, 0x01));

               ir_variable *const r0B16 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0B16, r0AD7, 0x01));

               ir_variable *const r0B17 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r0B17, r0AD8, 0x01));

               ir_variable *const r0B18 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r0B18, body.constant(true), 0x01));

               ir_variable *const r0B19 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0B1A = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r0B1A);
               ir_expression *const r0B1B = expr(ir_unop_u2i, r0AD8);
               body.emit(assign(r0B1A, less(r0B1B, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0B1D = lequal(body.constant(int(2045)), r0AD5);
               ir_if *f0B1C = new(mem_ctx) ir_if(operand(r0B1D).val);
               exec_list *const f0B1C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B1C->then_instructions;

                  ir_variable *const r0B1E = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0B20 = less(body.constant(int(2045)), r0AD5);
                  ir_if *f0B1F = new(mem_ctx) ir_if(operand(r0B20).val);
                  exec_list *const f0B1F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B1F->then_instructions;

                     body.emit(assign(r0B1E, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B1F->else_instructions;

                     ir_variable *const r0B21 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0B23 = equal(r0AD5, body.constant(int(2045)));
                     ir_if *f0B22 = new(mem_ctx) ir_if(operand(r0B23).val);
                     exec_list *const f0B22_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B22->then_instructions;

                        ir_expression *const r0B24 = equal(body.constant(2097151u), r0AD6);
                        ir_expression *const r0B25 = equal(body.constant(4294967295u), r0AD7);
                        body.emit(assign(r0B21, logic_and(r0B24, r0B25), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0B22->else_instructions;

                        body.emit(assign(r0B21, body.constant(false), 0x01));


                     body.instructions = f0B22_parent_instructions;
                     body.emit(f0B22);

                     /* END IF */

                     body.emit(assign(r0B1E, logic_and(r0B21, r0B1A), 0x01));


                  body.instructions = f0B1F_parent_instructions;
                  body.emit(f0B1F);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0B26 = new(mem_ctx) ir_if(operand(r0B1E).val);
                  exec_list *const f0B26_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B26->then_instructions;

                     ir_variable *const r0B27 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0B27);
                     ir_expression *const r0B28 = lshift(r0999, body.constant(int(31)));
                     body.emit(assign(r0B27, add(r0B28, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r0B27, body.constant(0u), 0x01));

                     body.emit(assign(r0B19, r0B27, 0x03));

                     body.emit(assign(r0B18, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B26->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0B2A = less(r0AD5, body.constant(int(0)));
                     ir_if *f0B29 = new(mem_ctx) ir_if(operand(r0B2A).val);
                     exec_list *const f0B29_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B29->then_instructions;

                        ir_variable *const r0B2B = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0B2B, r0AD8, 0x01));

                        ir_variable *const r0B2C = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0B2C, neg(r0AD5), 0x01));

                        ir_variable *const r0B2D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0B2D);
                        ir_variable *const r0B2E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0B2E);
                        ir_variable *const r0B2F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0B2F);
                        ir_variable *const r0B30 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r0B31 = neg(r0B2C);
                        body.emit(assign(r0B30, bit_and(r0B31, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0B33 = equal(r0B2C, body.constant(int(0)));
                        ir_if *f0B32 = new(mem_ctx) ir_if(operand(r0B33).val);
                        exec_list *const f0B32_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0B32->then_instructions;

                           body.emit(assign(r0B2D, r0AD8, 0x01));

                           body.emit(assign(r0B2E, r0AD7, 0x01));

                           body.emit(assign(r0B2F, r0AD6, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0B32->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0B35 = less(r0B2C, body.constant(int(32)));
                           ir_if *f0B34 = new(mem_ctx) ir_if(operand(r0B35).val);
                           exec_list *const f0B34_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0B34->then_instructions;

                              body.emit(assign(r0B2D, lshift(r0AD7, r0B30), 0x01));

                              ir_expression *const r0B36 = lshift(r0AD6, r0B30);
                              ir_expression *const r0B37 = rshift(r0AD7, r0B2C);
                              body.emit(assign(r0B2E, bit_or(r0B36, r0B37), 0x01));

                              body.emit(assign(r0B2F, rshift(r0AD6, r0B2C), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0B34->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0B39 = equal(r0B2C, body.constant(int(32)));
                              ir_if *f0B38 = new(mem_ctx) ir_if(operand(r0B39).val);
                              exec_list *const f0B38_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0B38->then_instructions;

                                 body.emit(assign(r0B2D, r0AD7, 0x01));

                                 body.emit(assign(r0B2E, r0AD6, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0B38->else_instructions;

                                 body.emit(assign(r0B2B, bit_or(r0AD8, r0AD7), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0B3B = less(r0B2C, body.constant(int(64)));
                                 ir_if *f0B3A = new(mem_ctx) ir_if(operand(r0B3B).val);
                                 exec_list *const f0B3A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0B3A->then_instructions;

                                    body.emit(assign(r0B2D, lshift(r0AD6, r0B30), 0x01));

                                    ir_expression *const r0B3C = bit_and(r0B2C, body.constant(int(31)));
                                    body.emit(assign(r0B2E, rshift(r0AD6, r0B3C), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0B3A->else_instructions;

                                    ir_variable *const r0B3D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r0B3F = equal(r0B2C, body.constant(int(64)));
                                    ir_if *f0B3E = new(mem_ctx) ir_if(operand(r0B3F).val);
                                    exec_list *const f0B3E_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0B3E->then_instructions;

                                       body.emit(assign(r0B3D, r0AD6, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0B3E->else_instructions;

                                       ir_expression *const r0B40 = nequal(r0AD6, body.constant(0u));
                                       ir_expression *const r0B41 = expr(ir_unop_b2i, r0B40);
                                       body.emit(assign(r0B3D, expr(ir_unop_i2u, r0B41), 0x01));


                                    body.instructions = f0B3E_parent_instructions;
                                    body.emit(f0B3E);

                                    /* END IF */

                                    body.emit(assign(r0B2D, r0B3D, 0x01));

                                    body.emit(assign(r0B2E, body.constant(0u), 0x01));


                                 body.instructions = f0B3A_parent_instructions;
                                 body.emit(f0B3A);

                                 /* END IF */


                              body.instructions = f0B38_parent_instructions;
                              body.emit(f0B38);

                              /* END IF */

                              body.emit(assign(r0B2F, body.constant(0u), 0x01));


                           body.instructions = f0B34_parent_instructions;
                           body.emit(f0B34);

                           /* END IF */

                           ir_expression *const r0B42 = nequal(r0B2B, body.constant(0u));
                           ir_expression *const r0B43 = expr(ir_unop_b2i, r0B42);
                           ir_expression *const r0B44 = expr(ir_unop_i2u, r0B43);
                           body.emit(assign(r0B2D, bit_or(r0B2D, r0B44), 0x01));


                        body.instructions = f0B32_parent_instructions;
                        body.emit(f0B32);

                        /* END IF */

                        body.emit(assign(r0B15, r0B2F, 0x01));

                        body.emit(assign(r0B16, r0B2E, 0x01));

                        body.emit(assign(r0B17, r0B2D, 0x01));

                        body.emit(assign(r0B14, body.constant(int(0)), 0x01));

                        body.emit(assign(r0B1A, less(r0B2D, body.constant(0u)), 0x01));


                     body.instructions = f0B29_parent_instructions;
                     body.emit(f0B29);

                     /* END IF */


                  body.instructions = f0B26_parent_instructions;
                  body.emit(f0B26);

                  /* END IF */


               body.instructions = f0B1C_parent_instructions;
               body.emit(f0B1C);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0B45 = new(mem_ctx) ir_if(operand(r0B18).val);
               exec_list *const f0B45_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B45->then_instructions;

                  /* IF CONDITION */
                  ir_if *f0B46 = new(mem_ctx) ir_if(operand(r0B1A).val);
                  exec_list *const f0B46_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B46->then_instructions;

                     ir_variable *const r0B47 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r0B47, add(r0B16, body.constant(1u)), 0x01));

                     ir_expression *const r0B48 = less(r0B47, r0B16);
                     ir_expression *const r0B49 = expr(ir_unop_b2i, r0B48);
                     ir_expression *const r0B4A = expr(ir_unop_i2u, r0B49);
                     body.emit(assign(r0B15, add(r0B15, r0B4A), 0x01));

                     ir_expression *const r0B4B = equal(r0B17, body.constant(0u));
                     ir_expression *const r0B4C = expr(ir_unop_b2i, r0B4B);
                     ir_expression *const r0B4D = expr(ir_unop_i2u, r0B4C);
                     ir_expression *const r0B4E = add(r0B17, r0B4D);
                     ir_expression *const r0B4F = bit_and(r0B4E, body.constant(1u));
                     ir_expression *const r0B50 = expr(ir_unop_bit_not, r0B4F);
                     body.emit(assign(r0B16, bit_and(r0B47, r0B50), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B46->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0B52 = bit_or(r0B15, r0B16);
                     ir_expression *const r0B53 = equal(r0B52, body.constant(0u));
                     ir_if *f0B51 = new(mem_ctx) ir_if(operand(r0B53).val);
                     exec_list *const f0B51_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B51->then_instructions;

                        body.emit(assign(r0B14, body.constant(int(0)), 0x01));


                     body.instructions = f0B51_parent_instructions;
                     body.emit(f0B51);

                     /* END IF */


                  body.instructions = f0B46_parent_instructions;
                  body.emit(f0B46);

                  /* END IF */

                  ir_variable *const r0B54 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0B54);
                  ir_expression *const r0B55 = lshift(r0999, body.constant(int(31)));
                  ir_expression *const r0B56 = expr(ir_unop_i2u, r0B14);
                  ir_expression *const r0B57 = lshift(r0B56, body.constant(int(20)));
                  ir_expression *const r0B58 = add(r0B55, r0B57);
                  body.emit(assign(r0B54, add(r0B58, r0B15), 0x02));

                  body.emit(assign(r0B54, r0B16, 0x01));

                  body.emit(assign(r0B19, r0B54, 0x03));

                  body.emit(assign(r0B18, body.constant(false), 0x01));


               body.instructions = f0B45_parent_instructions;
               body.emit(f0B45);

               /* END IF */

               body.emit(assign(r099A, r0B19, 0x03));


            body.instructions = f0A85_parent_instructions;
            body.emit(f0A85);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0A83->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0B5A = equal(r09A2, body.constant(int(2047)));
            ir_if *f0B59 = new(mem_ctx) ir_if(operand(r0B5A).val);
            exec_list *const f0B59_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0B59->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0B5C = bit_or(swizzle_y(r099F), swizzle_x(r099F));
               ir_expression *const r0B5D = bit_or(swizzle_y(r099D), swizzle_x(r099D));
               ir_expression *const r0B5E = bit_or(r0B5C, r0B5D);
               ir_expression *const r0B5F = nequal(r0B5E, body.constant(0u));
               ir_if *f0B5B = new(mem_ctx) ir_if(operand(r0B5F).val);
               exec_list *const f0B5B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B5B->then_instructions;

                  ir_variable *const r0B60 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r0B60, swizzle_x(r07E9), 0x01));

                  ir_variable *const r0B61 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r0B61, swizzle_x(r07EA), 0x01));

                  ir_variable *const r0B62 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0B63 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0B64 = rshift(swizzle_y(r07E9), body.constant(int(19)));
                  ir_expression *const r0B65 = bit_and(r0B64, body.constant(4095u));
                  ir_expression *const r0B66 = equal(r0B65, body.constant(4094u));
                  ir_expression *const r0B67 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0B68 = bit_and(swizzle_y(r07E9), body.constant(524287u));
                  ir_expression *const r0B69 = nequal(r0B68, body.constant(0u));
                  ir_expression *const r0B6A = logic_or(r0B67, r0B69);
                  body.emit(assign(r0B63, logic_and(r0B66, r0B6A), 0x01));

                  ir_variable *const r0B6B = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0B6C = lshift(swizzle_y(r07EA), body.constant(int(1)));
                  ir_expression *const r0B6D = lequal(body.constant(4292870144u), r0B6C);
                  ir_expression *const r0B6E = nequal(swizzle_x(r07EA), body.constant(0u));
                  ir_expression *const r0B6F = bit_and(swizzle_y(r07EA), body.constant(1048575u));
                  ir_expression *const r0B70 = nequal(r0B6F, body.constant(0u));
                  ir_expression *const r0B71 = logic_or(r0B6E, r0B70);
                  body.emit(assign(r0B6B, logic_and(r0B6D, r0B71), 0x01));

                  body.emit(assign(r0B60, bit_or(swizzle_y(r07E9), body.constant(524288u)), 0x02));

                  body.emit(assign(r0B61, bit_or(swizzle_y(r07EA), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r0B73 = lshift(swizzle_y(r07E9), body.constant(int(1)));
                  ir_expression *const r0B74 = lequal(body.constant(4292870144u), r0B73);
                  ir_expression *const r0B75 = nequal(swizzle_x(r07E9), body.constant(0u));
                  ir_expression *const r0B76 = bit_and(swizzle_y(r07E9), body.constant(1048575u));
                  ir_expression *const r0B77 = nequal(r0B76, body.constant(0u));
                  ir_expression *const r0B78 = logic_or(r0B75, r0B77);
                  ir_expression *const r0B79 = logic_and(r0B74, r0B78);
                  ir_if *f0B72 = new(mem_ctx) ir_if(operand(r0B79).val);
                  exec_list *const f0B72_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B72->then_instructions;

                     ir_variable *const r0B7A = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0B7C = logic_and(r0B63, r0B6B);
                     ir_if *f0B7B = new(mem_ctx) ir_if(operand(r0B7C).val);
                     exec_list *const f0B7B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B7B->then_instructions;

                        body.emit(assign(r0B7A, r0B61, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0B7B->else_instructions;

                        body.emit(assign(r0B7A, r0B60, 0x03));


                     body.instructions = f0B7B_parent_instructions;
                     body.emit(f0B7B);

                     /* END IF */

                     body.emit(assign(r0B62, r0B7A, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B72->else_instructions;

                     body.emit(assign(r0B62, r0B61, 0x03));


                  body.instructions = f0B72_parent_instructions;
                  body.emit(f0B72);

                  /* END IF */

                  body.emit(assign(r099A, r0B62, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0B5B->else_instructions;

                  ir_constant_data r0B7D_data;
                  memset(&r0B7D_data, 0, sizeof(ir_constant_data));
                  r0B7D_data.u[0] = 4294967295;
                  r0B7D_data.u[1] = 4294967295;
                  ir_constant *const r0B7D = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r0B7D_data);
                  body.emit(assign(r099A, r0B7D, 0x03));


               body.instructions = f0B5B_parent_instructions;
               body.emit(f0B5B);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0B59->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0B7F = equal(r09A2, body.constant(int(0)));
               ir_if *f0B7E = new(mem_ctx) ir_if(operand(r0B7F).val);
               exec_list *const f0B7E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B7E->then_instructions;

                  body.emit(assign(r099E, body.constant(int(1)), 0x01));

                  body.emit(assign(r099C, body.constant(int(1)), 0x01));


               body.instructions = f0B7E_parent_instructions;
               body.emit(f0B7E);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0B81 = less(swizzle_y(r099D), swizzle_y(r099F));
               ir_if *f0B80 = new(mem_ctx) ir_if(operand(r0B81).val);
               exec_list *const f0B80_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B80->then_instructions;

                  ir_variable *const r0B82 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r0B83 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0B83, sub(swizzle_x(r099F), swizzle_x(r099D)), 0x01));

                  ir_expression *const r0B84 = sub(swizzle_y(r099F), swizzle_y(r099D));
                  ir_expression *const r0B85 = less(swizzle_x(r099F), swizzle_x(r099D));
                  ir_expression *const r0B86 = expr(ir_unop_b2i, r0B85);
                  ir_expression *const r0B87 = expr(ir_unop_i2u, r0B86);
                  body.emit(assign(r0B82, sub(r0B84, r0B87), 0x01));

                  body.emit(assign(r09A0, add(r099E, body.constant(int(-1))), 0x01));

                  ir_variable *const r0B88 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r0B88, add(r09A0, body.constant(int(-10))), 0x01));

                  ir_variable *const r0B89 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r0B89, r0B82, 0x01));

                  ir_variable *const r0B8A = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r0B8A, r0B83, 0x01));

                  ir_variable *const r0B8B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r0B8B);
                  ir_variable *const r0B8C = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0B8C);
                  /* IF CONDITION */
                  ir_expression *const r0B8E = equal(r0B82, body.constant(0u));
                  ir_if *f0B8D = new(mem_ctx) ir_if(operand(r0B8E).val);
                  exec_list *const f0B8D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B8D->then_instructions;

                     body.emit(assign(r0B89, r0B83, 0x01));

                     body.emit(assign(r0B8A, body.constant(0u), 0x01));

                     body.emit(assign(r0B88, add(r0B88, body.constant(int(-32))), 0x01));


                  body.instructions = f0B8D_parent_instructions;
                  body.emit(f0B8D);

                  /* END IF */

                  ir_variable *const r0B8F = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r0B8F, r0B89, 0x01));

                  ir_variable *const r0B90 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r0B91 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0B91);
                  /* IF CONDITION */
                  ir_expression *const r0B93 = equal(r0B89, body.constant(0u));
                  ir_if *f0B92 = new(mem_ctx) ir_if(operand(r0B93).val);
                  exec_list *const f0B92_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B92->then_instructions;

                     body.emit(assign(r0B90, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B92->else_instructions;

                     body.emit(assign(r0B91, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0B95 = bit_and(r0B89, body.constant(4294901760u));
                     ir_expression *const r0B96 = equal(r0B95, body.constant(0u));
                     ir_if *f0B94 = new(mem_ctx) ir_if(operand(r0B96).val);
                     exec_list *const f0B94_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B94->then_instructions;

                        body.emit(assign(r0B91, body.constant(int(16)), 0x01));

                        body.emit(assign(r0B8F, lshift(r0B89, body.constant(int(16))), 0x01));


                     body.instructions = f0B94_parent_instructions;
                     body.emit(f0B94);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0B98 = bit_and(r0B8F, body.constant(4278190080u));
                     ir_expression *const r0B99 = equal(r0B98, body.constant(0u));
                     ir_if *f0B97 = new(mem_ctx) ir_if(operand(r0B99).val);
                     exec_list *const f0B97_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B97->then_instructions;

                        body.emit(assign(r0B91, add(r0B91, body.constant(int(8))), 0x01));

                        body.emit(assign(r0B8F, lshift(r0B8F, body.constant(int(8))), 0x01));


                     body.instructions = f0B97_parent_instructions;
                     body.emit(f0B97);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0B9B = bit_and(r0B8F, body.constant(4026531840u));
                     ir_expression *const r0B9C = equal(r0B9B, body.constant(0u));
                     ir_if *f0B9A = new(mem_ctx) ir_if(operand(r0B9C).val);
                     exec_list *const f0B9A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B9A->then_instructions;

                        body.emit(assign(r0B91, add(r0B91, body.constant(int(4))), 0x01));

                        body.emit(assign(r0B8F, lshift(r0B8F, body.constant(int(4))), 0x01));


                     body.instructions = f0B9A_parent_instructions;
                     body.emit(f0B9A);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0B9E = bit_and(r0B8F, body.constant(3221225472u));
                     ir_expression *const r0B9F = equal(r0B9E, body.constant(0u));
                     ir_if *f0B9D = new(mem_ctx) ir_if(operand(r0B9F).val);
                     exec_list *const f0B9D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B9D->then_instructions;

                        body.emit(assign(r0B91, add(r0B91, body.constant(int(2))), 0x01));

                        body.emit(assign(r0B8F, lshift(r0B8F, body.constant(int(2))), 0x01));


                     body.instructions = f0B9D_parent_instructions;
                     body.emit(f0B9D);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0BA1 = bit_and(r0B8F, body.constant(2147483648u));
                     ir_expression *const r0BA2 = equal(r0BA1, body.constant(0u));
                     ir_if *f0BA0 = new(mem_ctx) ir_if(operand(r0BA2).val);
                     exec_list *const f0BA0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BA0->then_instructions;

                        body.emit(assign(r0B91, add(r0B91, body.constant(int(1))), 0x01));


                     body.instructions = f0BA0_parent_instructions;
                     body.emit(f0BA0);

                     /* END IF */

                     body.emit(assign(r0B90, r0B91, 0x01));


                  body.instructions = f0B92_parent_instructions;
                  body.emit(f0B92);

                  /* END IF */

                  body.emit(assign(r0B8C, add(r0B90, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0BA4 = lequal(body.constant(int(0)), r0B8C);
                  ir_if *f0BA3 = new(mem_ctx) ir_if(operand(r0BA4).val);
                  exec_list *const f0BA3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0BA3->then_instructions;

                     body.emit(assign(r0B8B, body.constant(0u), 0x01));

                     ir_variable *const r0BA5 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r0BA5, lshift(r0B8A, r0B8C), 0x01));

                     ir_variable *const r0BA6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0BA8 = equal(r0B8C, body.constant(int(0)));
                     ir_if *f0BA7 = new(mem_ctx) ir_if(operand(r0BA8).val);
                     exec_list *const f0BA7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BA7->then_instructions;

                        body.emit(assign(r0BA6, r0B89, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BA7->else_instructions;

                        ir_expression *const r0BA9 = lshift(r0B89, r0B8C);
                        ir_expression *const r0BAA = neg(r0B8C);
                        ir_expression *const r0BAB = bit_and(r0BAA, body.constant(int(31)));
                        ir_expression *const r0BAC = rshift(r0B8A, r0BAB);
                        body.emit(assign(r0BA6, bit_or(r0BA9, r0BAC), 0x01));


                     body.instructions = f0BA7_parent_instructions;
                     body.emit(f0BA7);

                     /* END IF */

                     body.emit(assign(r0B89, r0BA6, 0x01));

                     body.emit(assign(r0B8A, r0BA5, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0BA3->else_instructions;

                     ir_variable *const r0BAD = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0BAD, body.constant(0u), 0x01));

                     ir_variable *const r0BAE = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0BAE, neg(r0B8C), 0x01));

                     ir_variable *const r0BAF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0BAF);
                     ir_variable *const r0BB0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0BB0);
                     ir_variable *const r0BB1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0BB1);
                     ir_variable *const r0BB2 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0BB3 = neg(r0BAE);
                     body.emit(assign(r0BB2, bit_and(r0BB3, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0BB5 = equal(r0BAE, body.constant(int(0)));
                     ir_if *f0BB4 = new(mem_ctx) ir_if(operand(r0BB5).val);
                     exec_list *const f0BB4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BB4->then_instructions;

                        body.emit(assign(r0BAF, r0BAD, 0x01));

                        body.emit(assign(r0BB0, r0B8A, 0x01));

                        body.emit(assign(r0BB1, r0B89, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BB4->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0BB7 = less(r0BAE, body.constant(int(32)));
                        ir_if *f0BB6 = new(mem_ctx) ir_if(operand(r0BB7).val);
                        exec_list *const f0BB6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0BB6->then_instructions;

                           body.emit(assign(r0BAF, lshift(r0B8A, r0BB2), 0x01));

                           ir_expression *const r0BB8 = lshift(r0B89, r0BB2);
                           ir_expression *const r0BB9 = rshift(r0B8A, r0BAE);
                           body.emit(assign(r0BB0, bit_or(r0BB8, r0BB9), 0x01));

                           body.emit(assign(r0BB1, rshift(r0B89, r0BAE), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0BB6->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0BBB = equal(r0BAE, body.constant(int(32)));
                           ir_if *f0BBA = new(mem_ctx) ir_if(operand(r0BBB).val);
                           exec_list *const f0BBA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0BBA->then_instructions;

                              body.emit(assign(r0BAF, r0B8A, 0x01));

                              body.emit(assign(r0BB0, r0B89, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0BBA->else_instructions;

                              body.emit(assign(r0BAD, bit_or(body.constant(0u), r0B8A), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0BBD = less(r0BAE, body.constant(int(64)));
                              ir_if *f0BBC = new(mem_ctx) ir_if(operand(r0BBD).val);
                              exec_list *const f0BBC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0BBC->then_instructions;

                                 body.emit(assign(r0BAF, lshift(r0B89, r0BB2), 0x01));

                                 ir_expression *const r0BBE = bit_and(r0BAE, body.constant(int(31)));
                                 body.emit(assign(r0BB0, rshift(r0B89, r0BBE), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0BBC->else_instructions;

                                 ir_variable *const r0BBF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0BC1 = equal(r0BAE, body.constant(int(64)));
                                 ir_if *f0BC0 = new(mem_ctx) ir_if(operand(r0BC1).val);
                                 exec_list *const f0BC0_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0BC0->then_instructions;

                                    body.emit(assign(r0BBF, r0B89, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0BC0->else_instructions;

                                    ir_expression *const r0BC2 = nequal(r0B89, body.constant(0u));
                                    ir_expression *const r0BC3 = expr(ir_unop_b2i, r0BC2);
                                    body.emit(assign(r0BBF, expr(ir_unop_i2u, r0BC3), 0x01));


                                 body.instructions = f0BC0_parent_instructions;
                                 body.emit(f0BC0);

                                 /* END IF */

                                 body.emit(assign(r0BAF, r0BBF, 0x01));

                                 body.emit(assign(r0BB0, body.constant(0u), 0x01));


                              body.instructions = f0BBC_parent_instructions;
                              body.emit(f0BBC);

                              /* END IF */


                           body.instructions = f0BBA_parent_instructions;
                           body.emit(f0BBA);

                           /* END IF */

                           body.emit(assign(r0BB1, body.constant(0u), 0x01));


                        body.instructions = f0BB6_parent_instructions;
                        body.emit(f0BB6);

                        /* END IF */

                        ir_expression *const r0BC4 = nequal(r0BAD, body.constant(0u));
                        ir_expression *const r0BC5 = expr(ir_unop_b2i, r0BC4);
                        ir_expression *const r0BC6 = expr(ir_unop_i2u, r0BC5);
                        body.emit(assign(r0BAF, bit_or(r0BAF, r0BC6), 0x01));


                     body.instructions = f0BB4_parent_instructions;
                     body.emit(f0BB4);

                     /* END IF */

                     body.emit(assign(r0B89, r0BB1, 0x01));

                     body.emit(assign(r0B8A, r0BB0, 0x01));

                     body.emit(assign(r0B8B, r0BAF, 0x01));


                  body.instructions = f0BA3_parent_instructions;
                  body.emit(f0BA3);

                  /* END IF */

                  body.emit(assign(r0B88, sub(r0B88, r0B8C), 0x01));

                  ir_variable *const r0BC7 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r0BC7, r0B88, 0x01));

                  ir_variable *const r0BC8 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r0BC8, r0B89, 0x01));

                  ir_variable *const r0BC9 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r0BC9, r0B8A, 0x01));

                  ir_variable *const r0BCA = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r0BCA, r0B8B, 0x01));

                  ir_variable *const r0BCB = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r0BCB, body.constant(true), 0x01));

                  ir_variable *const r0BCC = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0BCD = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r0BCD);
                  ir_expression *const r0BCE = expr(ir_unop_u2i, r0B8B);
                  body.emit(assign(r0BCD, less(r0BCE, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0BD0 = lequal(body.constant(int(2045)), r0B88);
                  ir_if *f0BCF = new(mem_ctx) ir_if(operand(r0BD0).val);
                  exec_list *const f0BCF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0BCF->then_instructions;

                     ir_variable *const r0BD1 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0BD3 = less(body.constant(int(2045)), r0B88);
                     ir_if *f0BD2 = new(mem_ctx) ir_if(operand(r0BD3).val);
                     exec_list *const f0BD2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BD2->then_instructions;

                        body.emit(assign(r0BD1, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BD2->else_instructions;

                        ir_variable *const r0BD4 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0BD6 = equal(r0B88, body.constant(int(2045)));
                        ir_if *f0BD5 = new(mem_ctx) ir_if(operand(r0BD6).val);
                        exec_list *const f0BD5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0BD5->then_instructions;

                           ir_expression *const r0BD7 = equal(body.constant(2097151u), r0B89);
                           ir_expression *const r0BD8 = equal(body.constant(4294967295u), r0B8A);
                           body.emit(assign(r0BD4, logic_and(r0BD7, r0BD8), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0BD5->else_instructions;

                           body.emit(assign(r0BD4, body.constant(false), 0x01));


                        body.instructions = f0BD5_parent_instructions;
                        body.emit(f0BD5);

                        /* END IF */

                        body.emit(assign(r0BD1, logic_and(r0BD4, r0BCD), 0x01));


                     body.instructions = f0BD2_parent_instructions;
                     body.emit(f0BD2);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f0BD9 = new(mem_ctx) ir_if(operand(r0BD1).val);
                     exec_list *const f0BD9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BD9->then_instructions;

                        ir_variable *const r0BDA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r0BDA);
                        ir_expression *const r0BDB = lshift(r0999, body.constant(int(31)));
                        body.emit(assign(r0BDA, add(r0BDB, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r0BDA, body.constant(0u), 0x01));

                        body.emit(assign(r0BCC, r0BDA, 0x03));

                        body.emit(assign(r0BCB, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BD9->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0BDD = less(r0B88, body.constant(int(0)));
                        ir_if *f0BDC = new(mem_ctx) ir_if(operand(r0BDD).val);
                        exec_list *const f0BDC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0BDC->then_instructions;

                           ir_variable *const r0BDE = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r0BDE, r0B8B, 0x01));

                           ir_variable *const r0BDF = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r0BDF, neg(r0B88), 0x01));

                           ir_variable *const r0BE0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r0BE0);
                           ir_variable *const r0BE1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r0BE1);
                           ir_variable *const r0BE2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r0BE2);
                           ir_variable *const r0BE3 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r0BE4 = neg(r0BDF);
                           body.emit(assign(r0BE3, bit_and(r0BE4, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0BE6 = equal(r0BDF, body.constant(int(0)));
                           ir_if *f0BE5 = new(mem_ctx) ir_if(operand(r0BE6).val);
                           exec_list *const f0BE5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0BE5->then_instructions;

                              body.emit(assign(r0BE0, r0B8B, 0x01));

                              body.emit(assign(r0BE1, r0B8A, 0x01));

                              body.emit(assign(r0BE2, r0B89, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0BE5->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0BE8 = less(r0BDF, body.constant(int(32)));
                              ir_if *f0BE7 = new(mem_ctx) ir_if(operand(r0BE8).val);
                              exec_list *const f0BE7_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0BE7->then_instructions;

                                 body.emit(assign(r0BE0, lshift(r0B8A, r0BE3), 0x01));

                                 ir_expression *const r0BE9 = lshift(r0B89, r0BE3);
                                 ir_expression *const r0BEA = rshift(r0B8A, r0BDF);
                                 body.emit(assign(r0BE1, bit_or(r0BE9, r0BEA), 0x01));

                                 body.emit(assign(r0BE2, rshift(r0B89, r0BDF), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0BE7->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0BEC = equal(r0BDF, body.constant(int(32)));
                                 ir_if *f0BEB = new(mem_ctx) ir_if(operand(r0BEC).val);
                                 exec_list *const f0BEB_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0BEB->then_instructions;

                                    body.emit(assign(r0BE0, r0B8A, 0x01));

                                    body.emit(assign(r0BE1, r0B89, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0BEB->else_instructions;

                                    body.emit(assign(r0BDE, bit_or(r0B8B, r0B8A), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r0BEE = less(r0BDF, body.constant(int(64)));
                                    ir_if *f0BED = new(mem_ctx) ir_if(operand(r0BEE).val);
                                    exec_list *const f0BED_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0BED->then_instructions;

                                       body.emit(assign(r0BE0, lshift(r0B89, r0BE3), 0x01));

                                       ir_expression *const r0BEF = bit_and(r0BDF, body.constant(int(31)));
                                       body.emit(assign(r0BE1, rshift(r0B89, r0BEF), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0BED->else_instructions;

                                       ir_variable *const r0BF0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r0BF2 = equal(r0BDF, body.constant(int(64)));
                                       ir_if *f0BF1 = new(mem_ctx) ir_if(operand(r0BF2).val);
                                       exec_list *const f0BF1_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0BF1->then_instructions;

                                          body.emit(assign(r0BF0, r0B89, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0BF1->else_instructions;

                                          ir_expression *const r0BF3 = nequal(r0B89, body.constant(0u));
                                          ir_expression *const r0BF4 = expr(ir_unop_b2i, r0BF3);
                                          body.emit(assign(r0BF0, expr(ir_unop_i2u, r0BF4), 0x01));


                                       body.instructions = f0BF1_parent_instructions;
                                       body.emit(f0BF1);

                                       /* END IF */

                                       body.emit(assign(r0BE0, r0BF0, 0x01));

                                       body.emit(assign(r0BE1, body.constant(0u), 0x01));


                                    body.instructions = f0BED_parent_instructions;
                                    body.emit(f0BED);

                                    /* END IF */


                                 body.instructions = f0BEB_parent_instructions;
                                 body.emit(f0BEB);

                                 /* END IF */

                                 body.emit(assign(r0BE2, body.constant(0u), 0x01));


                              body.instructions = f0BE7_parent_instructions;
                              body.emit(f0BE7);

                              /* END IF */

                              ir_expression *const r0BF5 = nequal(r0BDE, body.constant(0u));
                              ir_expression *const r0BF6 = expr(ir_unop_b2i, r0BF5);
                              ir_expression *const r0BF7 = expr(ir_unop_i2u, r0BF6);
                              body.emit(assign(r0BE0, bit_or(r0BE0, r0BF7), 0x01));


                           body.instructions = f0BE5_parent_instructions;
                           body.emit(f0BE5);

                           /* END IF */

                           body.emit(assign(r0BC8, r0BE2, 0x01));

                           body.emit(assign(r0BC9, r0BE1, 0x01));

                           body.emit(assign(r0BCA, r0BE0, 0x01));

                           body.emit(assign(r0BC7, body.constant(int(0)), 0x01));

                           body.emit(assign(r0BCD, less(r0BE0, body.constant(0u)), 0x01));


                        body.instructions = f0BDC_parent_instructions;
                        body.emit(f0BDC);

                        /* END IF */


                     body.instructions = f0BD9_parent_instructions;
                     body.emit(f0BD9);

                     /* END IF */


                  body.instructions = f0BCF_parent_instructions;
                  body.emit(f0BCF);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0BF8 = new(mem_ctx) ir_if(operand(r0BCB).val);
                  exec_list *const f0BF8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0BF8->then_instructions;

                     /* IF CONDITION */
                     ir_if *f0BF9 = new(mem_ctx) ir_if(operand(r0BCD).val);
                     exec_list *const f0BF9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BF9->then_instructions;

                        ir_variable *const r0BFA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r0BFA, add(r0BC9, body.constant(1u)), 0x01));

                        ir_expression *const r0BFB = less(r0BFA, r0BC9);
                        ir_expression *const r0BFC = expr(ir_unop_b2i, r0BFB);
                        ir_expression *const r0BFD = expr(ir_unop_i2u, r0BFC);
                        body.emit(assign(r0BC8, add(r0BC8, r0BFD), 0x01));

                        ir_expression *const r0BFE = equal(r0BCA, body.constant(0u));
                        ir_expression *const r0BFF = expr(ir_unop_b2i, r0BFE);
                        ir_expression *const r0C00 = expr(ir_unop_i2u, r0BFF);
                        ir_expression *const r0C01 = add(r0BCA, r0C00);
                        ir_expression *const r0C02 = bit_and(r0C01, body.constant(1u));
                        ir_expression *const r0C03 = expr(ir_unop_bit_not, r0C02);
                        body.emit(assign(r0BC9, bit_and(r0BFA, r0C03), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BF9->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0C05 = bit_or(r0BC8, r0BC9);
                        ir_expression *const r0C06 = equal(r0C05, body.constant(0u));
                        ir_if *f0C04 = new(mem_ctx) ir_if(operand(r0C06).val);
                        exec_list *const f0C04_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C04->then_instructions;

                           body.emit(assign(r0BC7, body.constant(int(0)), 0x01));


                        body.instructions = f0C04_parent_instructions;
                        body.emit(f0C04);

                        /* END IF */


                     body.instructions = f0BF9_parent_instructions;
                     body.emit(f0BF9);

                     /* END IF */

                     ir_variable *const r0C07 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0C07);
                     ir_expression *const r0C08 = lshift(r0999, body.constant(int(31)));
                     ir_expression *const r0C09 = expr(ir_unop_i2u, r0BC7);
                     ir_expression *const r0C0A = lshift(r0C09, body.constant(int(20)));
                     ir_expression *const r0C0B = add(r0C08, r0C0A);
                     body.emit(assign(r0C07, add(r0C0B, r0BC8), 0x02));

                     body.emit(assign(r0C07, r0BC9, 0x01));

                     body.emit(assign(r0BCC, r0C07, 0x03));

                     body.emit(assign(r0BCB, body.constant(false), 0x01));


                  body.instructions = f0BF8_parent_instructions;
                  body.emit(f0BF8);

                  /* END IF */

                  body.emit(assign(r099A, r0BCC, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0B80->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0C0D = less(swizzle_y(r099F), swizzle_y(r099D));
                  ir_if *f0C0C = new(mem_ctx) ir_if(operand(r0C0D).val);
                  exec_list *const f0C0C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0C0C->then_instructions;

                     ir_variable *const r0C0E = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r0C0F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r0C0F, sub(swizzle_x(r099D), swizzle_x(r099F)), 0x01));

                     ir_expression *const r0C10 = sub(swizzle_y(r099D), swizzle_y(r099F));
                     ir_expression *const r0C11 = less(swizzle_x(r099D), swizzle_x(r099F));
                     ir_expression *const r0C12 = expr(ir_unop_b2i, r0C11);
                     ir_expression *const r0C13 = expr(ir_unop_i2u, r0C12);
                     body.emit(assign(r0C0E, sub(r0C10, r0C13), 0x01));

                     body.emit(assign(r0999, bit_xor(r0999, body.constant(1u)), 0x01));

                     body.emit(assign(r09A0, add(r099C, body.constant(int(-1))), 0x01));

                     ir_variable *const r0C14 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r0C14, add(r09A0, body.constant(int(-10))), 0x01));

                     ir_variable *const r0C15 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r0C15, r0C0E, 0x01));

                     ir_variable *const r0C16 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r0C16, r0C0F, 0x01));

                     ir_variable *const r0C17 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r0C17);
                     ir_variable *const r0C18 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r0C18);
                     /* IF CONDITION */
                     ir_expression *const r0C1A = equal(r0C0E, body.constant(0u));
                     ir_if *f0C19 = new(mem_ctx) ir_if(operand(r0C1A).val);
                     exec_list *const f0C19_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C19->then_instructions;

                        body.emit(assign(r0C15, r0C0F, 0x01));

                        body.emit(assign(r0C16, body.constant(0u), 0x01));

                        body.emit(assign(r0C14, add(r0C14, body.constant(int(-32))), 0x01));


                     body.instructions = f0C19_parent_instructions;
                     body.emit(f0C19);

                     /* END IF */

                     ir_variable *const r0C1B = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r0C1B, r0C15, 0x01));

                     ir_variable *const r0C1C = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r0C1D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r0C1D);
                     /* IF CONDITION */
                     ir_expression *const r0C1F = equal(r0C15, body.constant(0u));
                     ir_if *f0C1E = new(mem_ctx) ir_if(operand(r0C1F).val);
                     exec_list *const f0C1E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C1E->then_instructions;

                        body.emit(assign(r0C1C, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0C1E->else_instructions;

                        body.emit(assign(r0C1D, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0C21 = bit_and(r0C15, body.constant(4294901760u));
                        ir_expression *const r0C22 = equal(r0C21, body.constant(0u));
                        ir_if *f0C20 = new(mem_ctx) ir_if(operand(r0C22).val);
                        exec_list *const f0C20_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C20->then_instructions;

                           body.emit(assign(r0C1D, body.constant(int(16)), 0x01));

                           body.emit(assign(r0C1B, lshift(r0C15, body.constant(int(16))), 0x01));


                        body.instructions = f0C20_parent_instructions;
                        body.emit(f0C20);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0C24 = bit_and(r0C1B, body.constant(4278190080u));
                        ir_expression *const r0C25 = equal(r0C24, body.constant(0u));
                        ir_if *f0C23 = new(mem_ctx) ir_if(operand(r0C25).val);
                        exec_list *const f0C23_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C23->then_instructions;

                           body.emit(assign(r0C1D, add(r0C1D, body.constant(int(8))), 0x01));

                           body.emit(assign(r0C1B, lshift(r0C1B, body.constant(int(8))), 0x01));


                        body.instructions = f0C23_parent_instructions;
                        body.emit(f0C23);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0C27 = bit_and(r0C1B, body.constant(4026531840u));
                        ir_expression *const r0C28 = equal(r0C27, body.constant(0u));
                        ir_if *f0C26 = new(mem_ctx) ir_if(operand(r0C28).val);
                        exec_list *const f0C26_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C26->then_instructions;

                           body.emit(assign(r0C1D, add(r0C1D, body.constant(int(4))), 0x01));

                           body.emit(assign(r0C1B, lshift(r0C1B, body.constant(int(4))), 0x01));


                        body.instructions = f0C26_parent_instructions;
                        body.emit(f0C26);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0C2A = bit_and(r0C1B, body.constant(3221225472u));
                        ir_expression *const r0C2B = equal(r0C2A, body.constant(0u));
                        ir_if *f0C29 = new(mem_ctx) ir_if(operand(r0C2B).val);
                        exec_list *const f0C29_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C29->then_instructions;

                           body.emit(assign(r0C1D, add(r0C1D, body.constant(int(2))), 0x01));

                           body.emit(assign(r0C1B, lshift(r0C1B, body.constant(int(2))), 0x01));


                        body.instructions = f0C29_parent_instructions;
                        body.emit(f0C29);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0C2D = bit_and(r0C1B, body.constant(2147483648u));
                        ir_expression *const r0C2E = equal(r0C2D, body.constant(0u));
                        ir_if *f0C2C = new(mem_ctx) ir_if(operand(r0C2E).val);
                        exec_list *const f0C2C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C2C->then_instructions;

                           body.emit(assign(r0C1D, add(r0C1D, body.constant(int(1))), 0x01));


                        body.instructions = f0C2C_parent_instructions;
                        body.emit(f0C2C);

                        /* END IF */

                        body.emit(assign(r0C1C, r0C1D, 0x01));


                     body.instructions = f0C1E_parent_instructions;
                     body.emit(f0C1E);

                     /* END IF */

                     body.emit(assign(r0C18, add(r0C1C, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0C30 = lequal(body.constant(int(0)), r0C18);
                     ir_if *f0C2F = new(mem_ctx) ir_if(operand(r0C30).val);
                     exec_list *const f0C2F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C2F->then_instructions;

                        body.emit(assign(r0C17, body.constant(0u), 0x01));

                        ir_variable *const r0C31 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r0C31, lshift(r0C16, r0C18), 0x01));

                        ir_variable *const r0C32 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0C34 = equal(r0C18, body.constant(int(0)));
                        ir_if *f0C33 = new(mem_ctx) ir_if(operand(r0C34).val);
                        exec_list *const f0C33_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C33->then_instructions;

                           body.emit(assign(r0C32, r0C15, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C33->else_instructions;

                           ir_expression *const r0C35 = lshift(r0C15, r0C18);
                           ir_expression *const r0C36 = neg(r0C18);
                           ir_expression *const r0C37 = bit_and(r0C36, body.constant(int(31)));
                           ir_expression *const r0C38 = rshift(r0C16, r0C37);
                           body.emit(assign(r0C32, bit_or(r0C35, r0C38), 0x01));


                        body.instructions = f0C33_parent_instructions;
                        body.emit(f0C33);

                        /* END IF */

                        body.emit(assign(r0C15, r0C32, 0x01));

                        body.emit(assign(r0C16, r0C31, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0C2F->else_instructions;

                        ir_variable *const r0C39 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0C39, body.constant(0u), 0x01));

                        ir_variable *const r0C3A = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0C3A, neg(r0C18), 0x01));

                        ir_variable *const r0C3B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0C3B);
                        ir_variable *const r0C3C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0C3C);
                        ir_variable *const r0C3D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0C3D);
                        ir_variable *const r0C3E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r0C3F = neg(r0C3A);
                        body.emit(assign(r0C3E, bit_and(r0C3F, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0C41 = equal(r0C3A, body.constant(int(0)));
                        ir_if *f0C40 = new(mem_ctx) ir_if(operand(r0C41).val);
                        exec_list *const f0C40_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C40->then_instructions;

                           body.emit(assign(r0C3B, r0C39, 0x01));

                           body.emit(assign(r0C3C, r0C16, 0x01));

                           body.emit(assign(r0C3D, r0C15, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C40->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0C43 = less(r0C3A, body.constant(int(32)));
                           ir_if *f0C42 = new(mem_ctx) ir_if(operand(r0C43).val);
                           exec_list *const f0C42_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0C42->then_instructions;

                              body.emit(assign(r0C3B, lshift(r0C16, r0C3E), 0x01));

                              ir_expression *const r0C44 = lshift(r0C15, r0C3E);
                              ir_expression *const r0C45 = rshift(r0C16, r0C3A);
                              body.emit(assign(r0C3C, bit_or(r0C44, r0C45), 0x01));

                              body.emit(assign(r0C3D, rshift(r0C15, r0C3A), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0C42->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0C47 = equal(r0C3A, body.constant(int(32)));
                              ir_if *f0C46 = new(mem_ctx) ir_if(operand(r0C47).val);
                              exec_list *const f0C46_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0C46->then_instructions;

                                 body.emit(assign(r0C3B, r0C16, 0x01));

                                 body.emit(assign(r0C3C, r0C15, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0C46->else_instructions;

                                 body.emit(assign(r0C39, bit_or(body.constant(0u), r0C16), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0C49 = less(r0C3A, body.constant(int(64)));
                                 ir_if *f0C48 = new(mem_ctx) ir_if(operand(r0C49).val);
                                 exec_list *const f0C48_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0C48->then_instructions;

                                    body.emit(assign(r0C3B, lshift(r0C15, r0C3E), 0x01));

                                    ir_expression *const r0C4A = bit_and(r0C3A, body.constant(int(31)));
                                    body.emit(assign(r0C3C, rshift(r0C15, r0C4A), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0C48->else_instructions;

                                    ir_variable *const r0C4B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r0C4D = equal(r0C3A, body.constant(int(64)));
                                    ir_if *f0C4C = new(mem_ctx) ir_if(operand(r0C4D).val);
                                    exec_list *const f0C4C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0C4C->then_instructions;

                                       body.emit(assign(r0C4B, r0C15, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0C4C->else_instructions;

                                       ir_expression *const r0C4E = nequal(r0C15, body.constant(0u));
                                       ir_expression *const r0C4F = expr(ir_unop_b2i, r0C4E);
                                       body.emit(assign(r0C4B, expr(ir_unop_i2u, r0C4F), 0x01));


                                    body.instructions = f0C4C_parent_instructions;
                                    body.emit(f0C4C);

                                    /* END IF */

                                    body.emit(assign(r0C3B, r0C4B, 0x01));

                                    body.emit(assign(r0C3C, body.constant(0u), 0x01));


                                 body.instructions = f0C48_parent_instructions;
                                 body.emit(f0C48);

                                 /* END IF */


                              body.instructions = f0C46_parent_instructions;
                              body.emit(f0C46);

                              /* END IF */

                              body.emit(assign(r0C3D, body.constant(0u), 0x01));


                           body.instructions = f0C42_parent_instructions;
                           body.emit(f0C42);

                           /* END IF */

                           ir_expression *const r0C50 = nequal(r0C39, body.constant(0u));
                           ir_expression *const r0C51 = expr(ir_unop_b2i, r0C50);
                           ir_expression *const r0C52 = expr(ir_unop_i2u, r0C51);
                           body.emit(assign(r0C3B, bit_or(r0C3B, r0C52), 0x01));


                        body.instructions = f0C40_parent_instructions;
                        body.emit(f0C40);

                        /* END IF */

                        body.emit(assign(r0C15, r0C3D, 0x01));

                        body.emit(assign(r0C16, r0C3C, 0x01));

                        body.emit(assign(r0C17, r0C3B, 0x01));


                     body.instructions = f0C2F_parent_instructions;
                     body.emit(f0C2F);

                     /* END IF */

                     body.emit(assign(r0C14, sub(r0C14, r0C18), 0x01));

                     ir_variable *const r0C53 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r0C53, r0C14, 0x01));

                     ir_variable *const r0C54 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r0C54, r0C15, 0x01));

                     ir_variable *const r0C55 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r0C55, r0C16, 0x01));

                     ir_variable *const r0C56 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r0C56, r0C17, 0x01));

                     ir_variable *const r0C57 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r0C57, body.constant(true), 0x01));

                     ir_variable *const r0C58 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r0C59 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r0C59);
                     ir_expression *const r0C5A = expr(ir_unop_u2i, r0C17);
                     body.emit(assign(r0C59, less(r0C5A, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0C5C = lequal(body.constant(int(2045)), r0C14);
                     ir_if *f0C5B = new(mem_ctx) ir_if(operand(r0C5C).val);
                     exec_list *const f0C5B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C5B->then_instructions;

                        ir_variable *const r0C5D = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0C5F = less(body.constant(int(2045)), r0C14);
                        ir_if *f0C5E = new(mem_ctx) ir_if(operand(r0C5F).val);
                        exec_list *const f0C5E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C5E->then_instructions;

                           body.emit(assign(r0C5D, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C5E->else_instructions;

                           ir_variable *const r0C60 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0C62 = equal(r0C14, body.constant(int(2045)));
                           ir_if *f0C61 = new(mem_ctx) ir_if(operand(r0C62).val);
                           exec_list *const f0C61_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0C61->then_instructions;

                              ir_expression *const r0C63 = equal(body.constant(2097151u), r0C15);
                              ir_expression *const r0C64 = equal(body.constant(4294967295u), r0C16);
                              body.emit(assign(r0C60, logic_and(r0C63, r0C64), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0C61->else_instructions;

                              body.emit(assign(r0C60, body.constant(false), 0x01));


                           body.instructions = f0C61_parent_instructions;
                           body.emit(f0C61);

                           /* END IF */

                           body.emit(assign(r0C5D, logic_and(r0C60, r0C59), 0x01));


                        body.instructions = f0C5E_parent_instructions;
                        body.emit(f0C5E);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f0C65 = new(mem_ctx) ir_if(operand(r0C5D).val);
                        exec_list *const f0C65_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C65->then_instructions;

                           ir_variable *const r0C66 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r0C66);
                           ir_expression *const r0C67 = lshift(r0999, body.constant(int(31)));
                           body.emit(assign(r0C66, add(r0C67, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r0C66, body.constant(0u), 0x01));

                           body.emit(assign(r0C58, r0C66, 0x03));

                           body.emit(assign(r0C57, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C65->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0C69 = less(r0C14, body.constant(int(0)));
                           ir_if *f0C68 = new(mem_ctx) ir_if(operand(r0C69).val);
                           exec_list *const f0C68_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0C68->then_instructions;

                              ir_variable *const r0C6A = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r0C6A, r0C17, 0x01));

                              ir_variable *const r0C6B = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r0C6B, neg(r0C14), 0x01));

                              ir_variable *const r0C6C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r0C6C);
                              ir_variable *const r0C6D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r0C6D);
                              ir_variable *const r0C6E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r0C6E);
                              ir_variable *const r0C6F = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r0C70 = neg(r0C6B);
                              body.emit(assign(r0C6F, bit_and(r0C70, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0C72 = equal(r0C6B, body.constant(int(0)));
                              ir_if *f0C71 = new(mem_ctx) ir_if(operand(r0C72).val);
                              exec_list *const f0C71_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0C71->then_instructions;

                                 body.emit(assign(r0C6C, r0C17, 0x01));

                                 body.emit(assign(r0C6D, r0C16, 0x01));

                                 body.emit(assign(r0C6E, r0C15, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0C71->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0C74 = less(r0C6B, body.constant(int(32)));
                                 ir_if *f0C73 = new(mem_ctx) ir_if(operand(r0C74).val);
                                 exec_list *const f0C73_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0C73->then_instructions;

                                    body.emit(assign(r0C6C, lshift(r0C16, r0C6F), 0x01));

                                    ir_expression *const r0C75 = lshift(r0C15, r0C6F);
                                    ir_expression *const r0C76 = rshift(r0C16, r0C6B);
                                    body.emit(assign(r0C6D, bit_or(r0C75, r0C76), 0x01));

                                    body.emit(assign(r0C6E, rshift(r0C15, r0C6B), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0C73->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r0C78 = equal(r0C6B, body.constant(int(32)));
                                    ir_if *f0C77 = new(mem_ctx) ir_if(operand(r0C78).val);
                                    exec_list *const f0C77_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0C77->then_instructions;

                                       body.emit(assign(r0C6C, r0C16, 0x01));

                                       body.emit(assign(r0C6D, r0C15, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0C77->else_instructions;

                                       body.emit(assign(r0C6A, bit_or(r0C17, r0C16), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r0C7A = less(r0C6B, body.constant(int(64)));
                                       ir_if *f0C79 = new(mem_ctx) ir_if(operand(r0C7A).val);
                                       exec_list *const f0C79_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0C79->then_instructions;

                                          body.emit(assign(r0C6C, lshift(r0C15, r0C6F), 0x01));

                                          ir_expression *const r0C7B = bit_and(r0C6B, body.constant(int(31)));
                                          body.emit(assign(r0C6D, rshift(r0C15, r0C7B), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0C79->else_instructions;

                                          ir_variable *const r0C7C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r0C7E = equal(r0C6B, body.constant(int(64)));
                                          ir_if *f0C7D = new(mem_ctx) ir_if(operand(r0C7E).val);
                                          exec_list *const f0C7D_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0C7D->then_instructions;

                                             body.emit(assign(r0C7C, r0C15, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0C7D->else_instructions;

                                             ir_expression *const r0C7F = nequal(r0C15, body.constant(0u));
                                             ir_expression *const r0C80 = expr(ir_unop_b2i, r0C7F);
                                             body.emit(assign(r0C7C, expr(ir_unop_i2u, r0C80), 0x01));


                                          body.instructions = f0C7D_parent_instructions;
                                          body.emit(f0C7D);

                                          /* END IF */

                                          body.emit(assign(r0C6C, r0C7C, 0x01));

                                          body.emit(assign(r0C6D, body.constant(0u), 0x01));


                                       body.instructions = f0C79_parent_instructions;
                                       body.emit(f0C79);

                                       /* END IF */


                                    body.instructions = f0C77_parent_instructions;
                                    body.emit(f0C77);

                                    /* END IF */

                                    body.emit(assign(r0C6E, body.constant(0u), 0x01));


                                 body.instructions = f0C73_parent_instructions;
                                 body.emit(f0C73);

                                 /* END IF */

                                 ir_expression *const r0C81 = nequal(r0C6A, body.constant(0u));
                                 ir_expression *const r0C82 = expr(ir_unop_b2i, r0C81);
                                 ir_expression *const r0C83 = expr(ir_unop_i2u, r0C82);
                                 body.emit(assign(r0C6C, bit_or(r0C6C, r0C83), 0x01));


                              body.instructions = f0C71_parent_instructions;
                              body.emit(f0C71);

                              /* END IF */

                              body.emit(assign(r0C54, r0C6E, 0x01));

                              body.emit(assign(r0C55, r0C6D, 0x01));

                              body.emit(assign(r0C56, r0C6C, 0x01));

                              body.emit(assign(r0C53, body.constant(int(0)), 0x01));

                              body.emit(assign(r0C59, less(r0C6C, body.constant(0u)), 0x01));


                           body.instructions = f0C68_parent_instructions;
                           body.emit(f0C68);

                           /* END IF */


                        body.instructions = f0C65_parent_instructions;
                        body.emit(f0C65);

                        /* END IF */


                     body.instructions = f0C5B_parent_instructions;
                     body.emit(f0C5B);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f0C84 = new(mem_ctx) ir_if(operand(r0C57).val);
                     exec_list *const f0C84_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C84->then_instructions;

                        /* IF CONDITION */
                        ir_if *f0C85 = new(mem_ctx) ir_if(operand(r0C59).val);
                        exec_list *const f0C85_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C85->then_instructions;

                           ir_variable *const r0C86 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r0C86, add(r0C55, body.constant(1u)), 0x01));

                           ir_expression *const r0C87 = less(r0C86, r0C55);
                           ir_expression *const r0C88 = expr(ir_unop_b2i, r0C87);
                           ir_expression *const r0C89 = expr(ir_unop_i2u, r0C88);
                           body.emit(assign(r0C54, add(r0C54, r0C89), 0x01));

                           ir_expression *const r0C8A = equal(r0C56, body.constant(0u));
                           ir_expression *const r0C8B = expr(ir_unop_b2i, r0C8A);
                           ir_expression *const r0C8C = expr(ir_unop_i2u, r0C8B);
                           ir_expression *const r0C8D = add(r0C56, r0C8C);
                           ir_expression *const r0C8E = bit_and(r0C8D, body.constant(1u));
                           ir_expression *const r0C8F = expr(ir_unop_bit_not, r0C8E);
                           body.emit(assign(r0C55, bit_and(r0C86, r0C8F), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C85->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0C91 = bit_or(r0C54, r0C55);
                           ir_expression *const r0C92 = equal(r0C91, body.constant(0u));
                           ir_if *f0C90 = new(mem_ctx) ir_if(operand(r0C92).val);
                           exec_list *const f0C90_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0C90->then_instructions;

                              body.emit(assign(r0C53, body.constant(int(0)), 0x01));


                           body.instructions = f0C90_parent_instructions;
                           body.emit(f0C90);

                           /* END IF */


                        body.instructions = f0C85_parent_instructions;
                        body.emit(f0C85);

                        /* END IF */

                        ir_variable *const r0C93 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r0C93);
                        ir_expression *const r0C94 = lshift(r0999, body.constant(int(31)));
                        ir_expression *const r0C95 = expr(ir_unop_i2u, r0C53);
                        ir_expression *const r0C96 = lshift(r0C95, body.constant(int(20)));
                        ir_expression *const r0C97 = add(r0C94, r0C96);
                        body.emit(assign(r0C93, add(r0C97, r0C54), 0x02));

                        body.emit(assign(r0C93, r0C55, 0x01));

                        body.emit(assign(r0C58, r0C93, 0x03));

                        body.emit(assign(r0C57, body.constant(false), 0x01));


                     body.instructions = f0C84_parent_instructions;
                     body.emit(f0C84);

                     /* END IF */

                     body.emit(assign(r099A, r0C58, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0C0C->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0C99 = less(swizzle_x(r099D), swizzle_x(r099F));
                     ir_if *f0C98 = new(mem_ctx) ir_if(operand(r0C99).val);
                     exec_list *const f0C98_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C98->then_instructions;

                        ir_variable *const r0C9A = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r0C9B = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r0C9B, sub(swizzle_x(r099F), swizzle_x(r099D)), 0x01));

                        ir_expression *const r0C9C = sub(swizzle_y(r099F), swizzle_y(r099D));
                        ir_expression *const r0C9D = less(swizzle_x(r099F), swizzle_x(r099D));
                        ir_expression *const r0C9E = expr(ir_unop_b2i, r0C9D);
                        ir_expression *const r0C9F = expr(ir_unop_i2u, r0C9E);
                        body.emit(assign(r0C9A, sub(r0C9C, r0C9F), 0x01));

                        body.emit(assign(r09A0, add(r099E, body.constant(int(-1))), 0x01));

                        ir_variable *const r0CA0 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r0CA0, add(r09A0, body.constant(int(-10))), 0x01));

                        ir_variable *const r0CA1 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r0CA1, r0C9A, 0x01));

                        ir_variable *const r0CA2 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r0CA2, r0C9B, 0x01));

                        ir_variable *const r0CA3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r0CA3);
                        ir_variable *const r0CA4 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r0CA4);
                        /* IF CONDITION */
                        ir_expression *const r0CA6 = equal(r0C9A, body.constant(0u));
                        ir_if *f0CA5 = new(mem_ctx) ir_if(operand(r0CA6).val);
                        exec_list *const f0CA5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0CA5->then_instructions;

                           body.emit(assign(r0CA1, r0C9B, 0x01));

                           body.emit(assign(r0CA2, body.constant(0u), 0x01));

                           body.emit(assign(r0CA0, add(r0CA0, body.constant(int(-32))), 0x01));


                        body.instructions = f0CA5_parent_instructions;
                        body.emit(f0CA5);

                        /* END IF */

                        ir_variable *const r0CA7 = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r0CA7, r0CA1, 0x01));

                        ir_variable *const r0CA8 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r0CA9 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r0CA9);
                        /* IF CONDITION */
                        ir_expression *const r0CAB = equal(r0CA1, body.constant(0u));
                        ir_if *f0CAA = new(mem_ctx) ir_if(operand(r0CAB).val);
                        exec_list *const f0CAA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0CAA->then_instructions;

                           body.emit(assign(r0CA8, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0CAA->else_instructions;

                           body.emit(assign(r0CA9, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0CAD = bit_and(r0CA1, body.constant(4294901760u));
                           ir_expression *const r0CAE = equal(r0CAD, body.constant(0u));
                           ir_if *f0CAC = new(mem_ctx) ir_if(operand(r0CAE).val);
                           exec_list *const f0CAC_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CAC->then_instructions;

                              body.emit(assign(r0CA9, body.constant(int(16)), 0x01));

                              body.emit(assign(r0CA7, lshift(r0CA1, body.constant(int(16))), 0x01));


                           body.instructions = f0CAC_parent_instructions;
                           body.emit(f0CAC);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0CB0 = bit_and(r0CA7, body.constant(4278190080u));
                           ir_expression *const r0CB1 = equal(r0CB0, body.constant(0u));
                           ir_if *f0CAF = new(mem_ctx) ir_if(operand(r0CB1).val);
                           exec_list *const f0CAF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CAF->then_instructions;

                              body.emit(assign(r0CA9, add(r0CA9, body.constant(int(8))), 0x01));

                              body.emit(assign(r0CA7, lshift(r0CA7, body.constant(int(8))), 0x01));


                           body.instructions = f0CAF_parent_instructions;
                           body.emit(f0CAF);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0CB3 = bit_and(r0CA7, body.constant(4026531840u));
                           ir_expression *const r0CB4 = equal(r0CB3, body.constant(0u));
                           ir_if *f0CB2 = new(mem_ctx) ir_if(operand(r0CB4).val);
                           exec_list *const f0CB2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CB2->then_instructions;

                              body.emit(assign(r0CA9, add(r0CA9, body.constant(int(4))), 0x01));

                              body.emit(assign(r0CA7, lshift(r0CA7, body.constant(int(4))), 0x01));


                           body.instructions = f0CB2_parent_instructions;
                           body.emit(f0CB2);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0CB6 = bit_and(r0CA7, body.constant(3221225472u));
                           ir_expression *const r0CB7 = equal(r0CB6, body.constant(0u));
                           ir_if *f0CB5 = new(mem_ctx) ir_if(operand(r0CB7).val);
                           exec_list *const f0CB5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CB5->then_instructions;

                              body.emit(assign(r0CA9, add(r0CA9, body.constant(int(2))), 0x01));

                              body.emit(assign(r0CA7, lshift(r0CA7, body.constant(int(2))), 0x01));


                           body.instructions = f0CB5_parent_instructions;
                           body.emit(f0CB5);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0CB9 = bit_and(r0CA7, body.constant(2147483648u));
                           ir_expression *const r0CBA = equal(r0CB9, body.constant(0u));
                           ir_if *f0CB8 = new(mem_ctx) ir_if(operand(r0CBA).val);
                           exec_list *const f0CB8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CB8->then_instructions;

                              body.emit(assign(r0CA9, add(r0CA9, body.constant(int(1))), 0x01));


                           body.instructions = f0CB8_parent_instructions;
                           body.emit(f0CB8);

                           /* END IF */

                           body.emit(assign(r0CA8, r0CA9, 0x01));


                        body.instructions = f0CAA_parent_instructions;
                        body.emit(f0CAA);

                        /* END IF */

                        body.emit(assign(r0CA4, add(r0CA8, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0CBC = lequal(body.constant(int(0)), r0CA4);
                        ir_if *f0CBB = new(mem_ctx) ir_if(operand(r0CBC).val);
                        exec_list *const f0CBB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0CBB->then_instructions;

                           body.emit(assign(r0CA3, body.constant(0u), 0x01));

                           ir_variable *const r0CBD = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r0CBD, lshift(r0CA2, r0CA4), 0x01));

                           ir_variable *const r0CBE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0CC0 = equal(r0CA4, body.constant(int(0)));
                           ir_if *f0CBF = new(mem_ctx) ir_if(operand(r0CC0).val);
                           exec_list *const f0CBF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CBF->then_instructions;

                              body.emit(assign(r0CBE, r0CA1, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0CBF->else_instructions;

                              ir_expression *const r0CC1 = lshift(r0CA1, r0CA4);
                              ir_expression *const r0CC2 = neg(r0CA4);
                              ir_expression *const r0CC3 = bit_and(r0CC2, body.constant(int(31)));
                              ir_expression *const r0CC4 = rshift(r0CA2, r0CC3);
                              body.emit(assign(r0CBE, bit_or(r0CC1, r0CC4), 0x01));


                           body.instructions = f0CBF_parent_instructions;
                           body.emit(f0CBF);

                           /* END IF */

                           body.emit(assign(r0CA1, r0CBE, 0x01));

                           body.emit(assign(r0CA2, r0CBD, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0CBB->else_instructions;

                           ir_variable *const r0CC5 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r0CC5, body.constant(0u), 0x01));

                           ir_variable *const r0CC6 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r0CC6, neg(r0CA4), 0x01));

                           ir_variable *const r0CC7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r0CC7);
                           ir_variable *const r0CC8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r0CC8);
                           ir_variable *const r0CC9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r0CC9);
                           ir_variable *const r0CCA = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r0CCB = neg(r0CC6);
                           body.emit(assign(r0CCA, bit_and(r0CCB, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0CCD = equal(r0CC6, body.constant(int(0)));
                           ir_if *f0CCC = new(mem_ctx) ir_if(operand(r0CCD).val);
                           exec_list *const f0CCC_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CCC->then_instructions;

                              body.emit(assign(r0CC7, r0CC5, 0x01));

                              body.emit(assign(r0CC8, r0CA2, 0x01));

                              body.emit(assign(r0CC9, r0CA1, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0CCC->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0CCF = less(r0CC6, body.constant(int(32)));
                              ir_if *f0CCE = new(mem_ctx) ir_if(operand(r0CCF).val);
                              exec_list *const f0CCE_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0CCE->then_instructions;

                                 body.emit(assign(r0CC7, lshift(r0CA2, r0CCA), 0x01));

                                 ir_expression *const r0CD0 = lshift(r0CA1, r0CCA);
                                 ir_expression *const r0CD1 = rshift(r0CA2, r0CC6);
                                 body.emit(assign(r0CC8, bit_or(r0CD0, r0CD1), 0x01));

                                 body.emit(assign(r0CC9, rshift(r0CA1, r0CC6), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0CCE->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0CD3 = equal(r0CC6, body.constant(int(32)));
                                 ir_if *f0CD2 = new(mem_ctx) ir_if(operand(r0CD3).val);
                                 exec_list *const f0CD2_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0CD2->then_instructions;

                                    body.emit(assign(r0CC7, r0CA2, 0x01));

                                    body.emit(assign(r0CC8, r0CA1, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0CD2->else_instructions;

                                    body.emit(assign(r0CC5, bit_or(body.constant(0u), r0CA2), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r0CD5 = less(r0CC6, body.constant(int(64)));
                                    ir_if *f0CD4 = new(mem_ctx) ir_if(operand(r0CD5).val);
                                    exec_list *const f0CD4_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0CD4->then_instructions;

                                       body.emit(assign(r0CC7, lshift(r0CA1, r0CCA), 0x01));

                                       ir_expression *const r0CD6 = bit_and(r0CC6, body.constant(int(31)));
                                       body.emit(assign(r0CC8, rshift(r0CA1, r0CD6), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0CD4->else_instructions;

                                       ir_variable *const r0CD7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r0CD9 = equal(r0CC6, body.constant(int(64)));
                                       ir_if *f0CD8 = new(mem_ctx) ir_if(operand(r0CD9).val);
                                       exec_list *const f0CD8_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0CD8->then_instructions;

                                          body.emit(assign(r0CD7, r0CA1, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0CD8->else_instructions;

                                          ir_expression *const r0CDA = nequal(r0CA1, body.constant(0u));
                                          ir_expression *const r0CDB = expr(ir_unop_b2i, r0CDA);
                                          body.emit(assign(r0CD7, expr(ir_unop_i2u, r0CDB), 0x01));


                                       body.instructions = f0CD8_parent_instructions;
                                       body.emit(f0CD8);

                                       /* END IF */

                                       body.emit(assign(r0CC7, r0CD7, 0x01));

                                       body.emit(assign(r0CC8, body.constant(0u), 0x01));


                                    body.instructions = f0CD4_parent_instructions;
                                    body.emit(f0CD4);

                                    /* END IF */


                                 body.instructions = f0CD2_parent_instructions;
                                 body.emit(f0CD2);

                                 /* END IF */

                                 body.emit(assign(r0CC9, body.constant(0u), 0x01));


                              body.instructions = f0CCE_parent_instructions;
                              body.emit(f0CCE);

                              /* END IF */

                              ir_expression *const r0CDC = nequal(r0CC5, body.constant(0u));
                              ir_expression *const r0CDD = expr(ir_unop_b2i, r0CDC);
                              ir_expression *const r0CDE = expr(ir_unop_i2u, r0CDD);
                              body.emit(assign(r0CC7, bit_or(r0CC7, r0CDE), 0x01));


                           body.instructions = f0CCC_parent_instructions;
                           body.emit(f0CCC);

                           /* END IF */

                           body.emit(assign(r0CA1, r0CC9, 0x01));

                           body.emit(assign(r0CA2, r0CC8, 0x01));

                           body.emit(assign(r0CA3, r0CC7, 0x01));


                        body.instructions = f0CBB_parent_instructions;
                        body.emit(f0CBB);

                        /* END IF */

                        body.emit(assign(r0CA0, sub(r0CA0, r0CA4), 0x01));

                        ir_variable *const r0CDF = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r0CDF, r0CA0, 0x01));

                        ir_variable *const r0CE0 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r0CE0, r0CA1, 0x01));

                        ir_variable *const r0CE1 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r0CE1, r0CA2, 0x01));

                        ir_variable *const r0CE2 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r0CE2, r0CA3, 0x01));

                        ir_variable *const r0CE3 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r0CE3, body.constant(true), 0x01));

                        ir_variable *const r0CE4 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r0CE5 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r0CE5);
                        ir_expression *const r0CE6 = expr(ir_unop_u2i, r0CA3);
                        body.emit(assign(r0CE5, less(r0CE6, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0CE8 = lequal(body.constant(int(2045)), r0CA0);
                        ir_if *f0CE7 = new(mem_ctx) ir_if(operand(r0CE8).val);
                        exec_list *const f0CE7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0CE7->then_instructions;

                           ir_variable *const r0CE9 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0CEB = less(body.constant(int(2045)), r0CA0);
                           ir_if *f0CEA = new(mem_ctx) ir_if(operand(r0CEB).val);
                           exec_list *const f0CEA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CEA->then_instructions;

                              body.emit(assign(r0CE9, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0CEA->else_instructions;

                              ir_variable *const r0CEC = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0CEE = equal(r0CA0, body.constant(int(2045)));
                              ir_if *f0CED = new(mem_ctx) ir_if(operand(r0CEE).val);
                              exec_list *const f0CED_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0CED->then_instructions;

                                 ir_expression *const r0CEF = equal(body.constant(2097151u), r0CA1);
                                 ir_expression *const r0CF0 = equal(body.constant(4294967295u), r0CA2);
                                 body.emit(assign(r0CEC, logic_and(r0CEF, r0CF0), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0CED->else_instructions;

                                 body.emit(assign(r0CEC, body.constant(false), 0x01));


                              body.instructions = f0CED_parent_instructions;
                              body.emit(f0CED);

                              /* END IF */

                              body.emit(assign(r0CE9, logic_and(r0CEC, r0CE5), 0x01));


                           body.instructions = f0CEA_parent_instructions;
                           body.emit(f0CEA);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f0CF1 = new(mem_ctx) ir_if(operand(r0CE9).val);
                           exec_list *const f0CF1_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CF1->then_instructions;

                              ir_variable *const r0CF2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r0CF2);
                              ir_expression *const r0CF3 = lshift(r0999, body.constant(int(31)));
                              body.emit(assign(r0CF2, add(r0CF3, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r0CF2, body.constant(0u), 0x01));

                              body.emit(assign(r0CE4, r0CF2, 0x03));

                              body.emit(assign(r0CE3, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0CF1->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0CF5 = less(r0CA0, body.constant(int(0)));
                              ir_if *f0CF4 = new(mem_ctx) ir_if(operand(r0CF5).val);
                              exec_list *const f0CF4_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0CF4->then_instructions;

                                 ir_variable *const r0CF6 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r0CF6, r0CA3, 0x01));

                                 ir_variable *const r0CF7 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r0CF7, neg(r0CA0), 0x01));

                                 ir_variable *const r0CF8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r0CF8);
                                 ir_variable *const r0CF9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r0CF9);
                                 ir_variable *const r0CFA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r0CFA);
                                 ir_variable *const r0CFB = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r0CFC = neg(r0CF7);
                                 body.emit(assign(r0CFB, bit_and(r0CFC, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0CFE = equal(r0CF7, body.constant(int(0)));
                                 ir_if *f0CFD = new(mem_ctx) ir_if(operand(r0CFE).val);
                                 exec_list *const f0CFD_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0CFD->then_instructions;

                                    body.emit(assign(r0CF8, r0CA3, 0x01));

                                    body.emit(assign(r0CF9, r0CA2, 0x01));

                                    body.emit(assign(r0CFA, r0CA1, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0CFD->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r0D00 = less(r0CF7, body.constant(int(32)));
                                    ir_if *f0CFF = new(mem_ctx) ir_if(operand(r0D00).val);
                                    exec_list *const f0CFF_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0CFF->then_instructions;

                                       body.emit(assign(r0CF8, lshift(r0CA2, r0CFB), 0x01));

                                       ir_expression *const r0D01 = lshift(r0CA1, r0CFB);
                                       ir_expression *const r0D02 = rshift(r0CA2, r0CF7);
                                       body.emit(assign(r0CF9, bit_or(r0D01, r0D02), 0x01));

                                       body.emit(assign(r0CFA, rshift(r0CA1, r0CF7), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0CFF->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r0D04 = equal(r0CF7, body.constant(int(32)));
                                       ir_if *f0D03 = new(mem_ctx) ir_if(operand(r0D04).val);
                                       exec_list *const f0D03_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0D03->then_instructions;

                                          body.emit(assign(r0CF8, r0CA2, 0x01));

                                          body.emit(assign(r0CF9, r0CA1, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0D03->else_instructions;

                                          body.emit(assign(r0CF6, bit_or(r0CA3, r0CA2), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r0D06 = less(r0CF7, body.constant(int(64)));
                                          ir_if *f0D05 = new(mem_ctx) ir_if(operand(r0D06).val);
                                          exec_list *const f0D05_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0D05->then_instructions;

                                             body.emit(assign(r0CF8, lshift(r0CA1, r0CFB), 0x01));

                                             ir_expression *const r0D07 = bit_and(r0CF7, body.constant(int(31)));
                                             body.emit(assign(r0CF9, rshift(r0CA1, r0D07), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0D05->else_instructions;

                                             ir_variable *const r0D08 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r0D0A = equal(r0CF7, body.constant(int(64)));
                                             ir_if *f0D09 = new(mem_ctx) ir_if(operand(r0D0A).val);
                                             exec_list *const f0D09_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f0D09->then_instructions;

                                                body.emit(assign(r0D08, r0CA1, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f0D09->else_instructions;

                                                ir_expression *const r0D0B = nequal(r0CA1, body.constant(0u));
                                                ir_expression *const r0D0C = expr(ir_unop_b2i, r0D0B);
                                                body.emit(assign(r0D08, expr(ir_unop_i2u, r0D0C), 0x01));


                                             body.instructions = f0D09_parent_instructions;
                                             body.emit(f0D09);

                                             /* END IF */

                                             body.emit(assign(r0CF8, r0D08, 0x01));

                                             body.emit(assign(r0CF9, body.constant(0u), 0x01));


                                          body.instructions = f0D05_parent_instructions;
                                          body.emit(f0D05);

                                          /* END IF */


                                       body.instructions = f0D03_parent_instructions;
                                       body.emit(f0D03);

                                       /* END IF */

                                       body.emit(assign(r0CFA, body.constant(0u), 0x01));


                                    body.instructions = f0CFF_parent_instructions;
                                    body.emit(f0CFF);

                                    /* END IF */

                                    ir_expression *const r0D0D = nequal(r0CF6, body.constant(0u));
                                    ir_expression *const r0D0E = expr(ir_unop_b2i, r0D0D);
                                    ir_expression *const r0D0F = expr(ir_unop_i2u, r0D0E);
                                    body.emit(assign(r0CF8, bit_or(r0CF8, r0D0F), 0x01));


                                 body.instructions = f0CFD_parent_instructions;
                                 body.emit(f0CFD);

                                 /* END IF */

                                 body.emit(assign(r0CE0, r0CFA, 0x01));

                                 body.emit(assign(r0CE1, r0CF9, 0x01));

                                 body.emit(assign(r0CE2, r0CF8, 0x01));

                                 body.emit(assign(r0CDF, body.constant(int(0)), 0x01));

                                 body.emit(assign(r0CE5, less(r0CF8, body.constant(0u)), 0x01));


                              body.instructions = f0CF4_parent_instructions;
                              body.emit(f0CF4);

                              /* END IF */


                           body.instructions = f0CF1_parent_instructions;
                           body.emit(f0CF1);

                           /* END IF */


                        body.instructions = f0CE7_parent_instructions;
                        body.emit(f0CE7);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f0D10 = new(mem_ctx) ir_if(operand(r0CE3).val);
                        exec_list *const f0D10_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0D10->then_instructions;

                           /* IF CONDITION */
                           ir_if *f0D11 = new(mem_ctx) ir_if(operand(r0CE5).val);
                           exec_list *const f0D11_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D11->then_instructions;

                              ir_variable *const r0D12 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r0D12, add(r0CE1, body.constant(1u)), 0x01));

                              ir_expression *const r0D13 = less(r0D12, r0CE1);
                              ir_expression *const r0D14 = expr(ir_unop_b2i, r0D13);
                              ir_expression *const r0D15 = expr(ir_unop_i2u, r0D14);
                              body.emit(assign(r0CE0, add(r0CE0, r0D15), 0x01));

                              ir_expression *const r0D16 = equal(r0CE2, body.constant(0u));
                              ir_expression *const r0D17 = expr(ir_unop_b2i, r0D16);
                              ir_expression *const r0D18 = expr(ir_unop_i2u, r0D17);
                              ir_expression *const r0D19 = add(r0CE2, r0D18);
                              ir_expression *const r0D1A = bit_and(r0D19, body.constant(1u));
                              ir_expression *const r0D1B = expr(ir_unop_bit_not, r0D1A);
                              body.emit(assign(r0CE1, bit_and(r0D12, r0D1B), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0D11->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0D1D = bit_or(r0CE0, r0CE1);
                              ir_expression *const r0D1E = equal(r0D1D, body.constant(0u));
                              ir_if *f0D1C = new(mem_ctx) ir_if(operand(r0D1E).val);
                              exec_list *const f0D1C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D1C->then_instructions;

                                 body.emit(assign(r0CDF, body.constant(int(0)), 0x01));


                              body.instructions = f0D1C_parent_instructions;
                              body.emit(f0D1C);

                              /* END IF */


                           body.instructions = f0D11_parent_instructions;
                           body.emit(f0D11);

                           /* END IF */

                           ir_variable *const r0D1F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r0D1F);
                           ir_expression *const r0D20 = lshift(r0999, body.constant(int(31)));
                           ir_expression *const r0D21 = expr(ir_unop_i2u, r0CDF);
                           ir_expression *const r0D22 = lshift(r0D21, body.constant(int(20)));
                           ir_expression *const r0D23 = add(r0D20, r0D22);
                           body.emit(assign(r0D1F, add(r0D23, r0CE0), 0x02));

                           body.emit(assign(r0D1F, r0CE1, 0x01));

                           body.emit(assign(r0CE4, r0D1F, 0x03));

                           body.emit(assign(r0CE3, body.constant(false), 0x01));


                        body.instructions = f0D10_parent_instructions;
                        body.emit(f0D10);

                        /* END IF */

                        body.emit(assign(r099A, r0CE4, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0C98->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0D25 = less(swizzle_x(r099F), swizzle_x(r099D));
                        ir_if *f0D24 = new(mem_ctx) ir_if(operand(r0D25).val);
                        exec_list *const f0D24_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0D24->then_instructions;

                           ir_variable *const r0D26 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r0D27 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r0D27, sub(swizzle_x(r099D), swizzle_x(r099F)), 0x01));

                           ir_expression *const r0D28 = sub(swizzle_y(r099D), swizzle_y(r099F));
                           ir_expression *const r0D29 = less(swizzle_x(r099D), swizzle_x(r099F));
                           ir_expression *const r0D2A = expr(ir_unop_b2i, r0D29);
                           ir_expression *const r0D2B = expr(ir_unop_i2u, r0D2A);
                           body.emit(assign(r0D26, sub(r0D28, r0D2B), 0x01));

                           body.emit(assign(r0999, bit_xor(r0999, body.constant(1u)), 0x01));

                           body.emit(assign(r09A0, add(r099C, body.constant(int(-1))), 0x01));

                           ir_variable *const r0D2C = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r0D2C, add(r09A0, body.constant(int(-10))), 0x01));

                           ir_variable *const r0D2D = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r0D2D, r0D26, 0x01));

                           ir_variable *const r0D2E = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r0D2E, r0D27, 0x01));

                           ir_variable *const r0D2F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r0D2F);
                           ir_variable *const r0D30 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r0D30);
                           /* IF CONDITION */
                           ir_expression *const r0D32 = equal(r0D26, body.constant(0u));
                           ir_if *f0D31 = new(mem_ctx) ir_if(operand(r0D32).val);
                           exec_list *const f0D31_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D31->then_instructions;

                              body.emit(assign(r0D2D, r0D27, 0x01));

                              body.emit(assign(r0D2E, body.constant(0u), 0x01));

                              body.emit(assign(r0D2C, add(r0D2C, body.constant(int(-32))), 0x01));


                           body.instructions = f0D31_parent_instructions;
                           body.emit(f0D31);

                           /* END IF */

                           ir_variable *const r0D33 = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r0D33, r0D2D, 0x01));

                           ir_variable *const r0D34 = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r0D35 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r0D35);
                           /* IF CONDITION */
                           ir_expression *const r0D37 = equal(r0D2D, body.constant(0u));
                           ir_if *f0D36 = new(mem_ctx) ir_if(operand(r0D37).val);
                           exec_list *const f0D36_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D36->then_instructions;

                              body.emit(assign(r0D34, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0D36->else_instructions;

                              body.emit(assign(r0D35, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0D39 = bit_and(r0D2D, body.constant(4294901760u));
                              ir_expression *const r0D3A = equal(r0D39, body.constant(0u));
                              ir_if *f0D38 = new(mem_ctx) ir_if(operand(r0D3A).val);
                              exec_list *const f0D38_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D38->then_instructions;

                                 body.emit(assign(r0D35, body.constant(int(16)), 0x01));

                                 body.emit(assign(r0D33, lshift(r0D2D, body.constant(int(16))), 0x01));


                              body.instructions = f0D38_parent_instructions;
                              body.emit(f0D38);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r0D3C = bit_and(r0D33, body.constant(4278190080u));
                              ir_expression *const r0D3D = equal(r0D3C, body.constant(0u));
                              ir_if *f0D3B = new(mem_ctx) ir_if(operand(r0D3D).val);
                              exec_list *const f0D3B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D3B->then_instructions;

                                 body.emit(assign(r0D35, add(r0D35, body.constant(int(8))), 0x01));

                                 body.emit(assign(r0D33, lshift(r0D33, body.constant(int(8))), 0x01));


                              body.instructions = f0D3B_parent_instructions;
                              body.emit(f0D3B);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r0D3F = bit_and(r0D33, body.constant(4026531840u));
                              ir_expression *const r0D40 = equal(r0D3F, body.constant(0u));
                              ir_if *f0D3E = new(mem_ctx) ir_if(operand(r0D40).val);
                              exec_list *const f0D3E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D3E->then_instructions;

                                 body.emit(assign(r0D35, add(r0D35, body.constant(int(4))), 0x01));

                                 body.emit(assign(r0D33, lshift(r0D33, body.constant(int(4))), 0x01));


                              body.instructions = f0D3E_parent_instructions;
                              body.emit(f0D3E);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r0D42 = bit_and(r0D33, body.constant(3221225472u));
                              ir_expression *const r0D43 = equal(r0D42, body.constant(0u));
                              ir_if *f0D41 = new(mem_ctx) ir_if(operand(r0D43).val);
                              exec_list *const f0D41_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D41->then_instructions;

                                 body.emit(assign(r0D35, add(r0D35, body.constant(int(2))), 0x01));

                                 body.emit(assign(r0D33, lshift(r0D33, body.constant(int(2))), 0x01));


                              body.instructions = f0D41_parent_instructions;
                              body.emit(f0D41);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r0D45 = bit_and(r0D33, body.constant(2147483648u));
                              ir_expression *const r0D46 = equal(r0D45, body.constant(0u));
                              ir_if *f0D44 = new(mem_ctx) ir_if(operand(r0D46).val);
                              exec_list *const f0D44_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D44->then_instructions;

                                 body.emit(assign(r0D35, add(r0D35, body.constant(int(1))), 0x01));


                              body.instructions = f0D44_parent_instructions;
                              body.emit(f0D44);

                              /* END IF */

                              body.emit(assign(r0D34, r0D35, 0x01));


                           body.instructions = f0D36_parent_instructions;
                           body.emit(f0D36);

                           /* END IF */

                           body.emit(assign(r0D30, add(r0D34, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0D48 = lequal(body.constant(int(0)), r0D30);
                           ir_if *f0D47 = new(mem_ctx) ir_if(operand(r0D48).val);
                           exec_list *const f0D47_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D47->then_instructions;

                              body.emit(assign(r0D2F, body.constant(0u), 0x01));

                              ir_variable *const r0D49 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r0D49, lshift(r0D2E, r0D30), 0x01));

                              ir_variable *const r0D4A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0D4C = equal(r0D30, body.constant(int(0)));
                              ir_if *f0D4B = new(mem_ctx) ir_if(operand(r0D4C).val);
                              exec_list *const f0D4B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D4B->then_instructions;

                                 body.emit(assign(r0D4A, r0D2D, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D4B->else_instructions;

                                 ir_expression *const r0D4D = lshift(r0D2D, r0D30);
                                 ir_expression *const r0D4E = neg(r0D30);
                                 ir_expression *const r0D4F = bit_and(r0D4E, body.constant(int(31)));
                                 ir_expression *const r0D50 = rshift(r0D2E, r0D4F);
                                 body.emit(assign(r0D4A, bit_or(r0D4D, r0D50), 0x01));


                              body.instructions = f0D4B_parent_instructions;
                              body.emit(f0D4B);

                              /* END IF */

                              body.emit(assign(r0D2D, r0D4A, 0x01));

                              body.emit(assign(r0D2E, r0D49, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0D47->else_instructions;

                              ir_variable *const r0D51 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r0D51, body.constant(0u), 0x01));

                              ir_variable *const r0D52 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r0D52, neg(r0D30), 0x01));

                              ir_variable *const r0D53 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r0D53);
                              ir_variable *const r0D54 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r0D54);
                              ir_variable *const r0D55 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r0D55);
                              ir_variable *const r0D56 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r0D57 = neg(r0D52);
                              body.emit(assign(r0D56, bit_and(r0D57, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0D59 = equal(r0D52, body.constant(int(0)));
                              ir_if *f0D58 = new(mem_ctx) ir_if(operand(r0D59).val);
                              exec_list *const f0D58_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D58->then_instructions;

                                 body.emit(assign(r0D53, r0D51, 0x01));

                                 body.emit(assign(r0D54, r0D2E, 0x01));

                                 body.emit(assign(r0D55, r0D2D, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D58->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0D5B = less(r0D52, body.constant(int(32)));
                                 ir_if *f0D5A = new(mem_ctx) ir_if(operand(r0D5B).val);
                                 exec_list *const f0D5A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0D5A->then_instructions;

                                    body.emit(assign(r0D53, lshift(r0D2E, r0D56), 0x01));

                                    ir_expression *const r0D5C = lshift(r0D2D, r0D56);
                                    ir_expression *const r0D5D = rshift(r0D2E, r0D52);
                                    body.emit(assign(r0D54, bit_or(r0D5C, r0D5D), 0x01));

                                    body.emit(assign(r0D55, rshift(r0D2D, r0D52), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0D5A->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r0D5F = equal(r0D52, body.constant(int(32)));
                                    ir_if *f0D5E = new(mem_ctx) ir_if(operand(r0D5F).val);
                                    exec_list *const f0D5E_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0D5E->then_instructions;

                                       body.emit(assign(r0D53, r0D2E, 0x01));

                                       body.emit(assign(r0D54, r0D2D, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0D5E->else_instructions;

                                       body.emit(assign(r0D51, bit_or(body.constant(0u), r0D2E), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r0D61 = less(r0D52, body.constant(int(64)));
                                       ir_if *f0D60 = new(mem_ctx) ir_if(operand(r0D61).val);
                                       exec_list *const f0D60_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0D60->then_instructions;

                                          body.emit(assign(r0D53, lshift(r0D2D, r0D56), 0x01));

                                          ir_expression *const r0D62 = bit_and(r0D52, body.constant(int(31)));
                                          body.emit(assign(r0D54, rshift(r0D2D, r0D62), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0D60->else_instructions;

                                          ir_variable *const r0D63 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r0D65 = equal(r0D52, body.constant(int(64)));
                                          ir_if *f0D64 = new(mem_ctx) ir_if(operand(r0D65).val);
                                          exec_list *const f0D64_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0D64->then_instructions;

                                             body.emit(assign(r0D63, r0D2D, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0D64->else_instructions;

                                             ir_expression *const r0D66 = nequal(r0D2D, body.constant(0u));
                                             ir_expression *const r0D67 = expr(ir_unop_b2i, r0D66);
                                             body.emit(assign(r0D63, expr(ir_unop_i2u, r0D67), 0x01));


                                          body.instructions = f0D64_parent_instructions;
                                          body.emit(f0D64);

                                          /* END IF */

                                          body.emit(assign(r0D53, r0D63, 0x01));

                                          body.emit(assign(r0D54, body.constant(0u), 0x01));


                                       body.instructions = f0D60_parent_instructions;
                                       body.emit(f0D60);

                                       /* END IF */


                                    body.instructions = f0D5E_parent_instructions;
                                    body.emit(f0D5E);

                                    /* END IF */

                                    body.emit(assign(r0D55, body.constant(0u), 0x01));


                                 body.instructions = f0D5A_parent_instructions;
                                 body.emit(f0D5A);

                                 /* END IF */

                                 ir_expression *const r0D68 = nequal(r0D51, body.constant(0u));
                                 ir_expression *const r0D69 = expr(ir_unop_b2i, r0D68);
                                 ir_expression *const r0D6A = expr(ir_unop_i2u, r0D69);
                                 body.emit(assign(r0D53, bit_or(r0D53, r0D6A), 0x01));


                              body.instructions = f0D58_parent_instructions;
                              body.emit(f0D58);

                              /* END IF */

                              body.emit(assign(r0D2D, r0D55, 0x01));

                              body.emit(assign(r0D2E, r0D54, 0x01));

                              body.emit(assign(r0D2F, r0D53, 0x01));


                           body.instructions = f0D47_parent_instructions;
                           body.emit(f0D47);

                           /* END IF */

                           body.emit(assign(r0D2C, sub(r0D2C, r0D30), 0x01));

                           ir_variable *const r0D6B = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r0D6B, r0D2C, 0x01));

                           ir_variable *const r0D6C = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r0D6C, r0D2D, 0x01));

                           ir_variable *const r0D6D = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r0D6D, r0D2E, 0x01));

                           ir_variable *const r0D6E = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r0D6E, r0D2F, 0x01));

                           ir_variable *const r0D6F = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r0D6F, body.constant(true), 0x01));

                           ir_variable *const r0D70 = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r0D71 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r0D71);
                           ir_expression *const r0D72 = expr(ir_unop_u2i, r0D2F);
                           body.emit(assign(r0D71, less(r0D72, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0D74 = lequal(body.constant(int(2045)), r0D2C);
                           ir_if *f0D73 = new(mem_ctx) ir_if(operand(r0D74).val);
                           exec_list *const f0D73_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D73->then_instructions;

                              ir_variable *const r0D75 = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0D77 = less(body.constant(int(2045)), r0D2C);
                              ir_if *f0D76 = new(mem_ctx) ir_if(operand(r0D77).val);
                              exec_list *const f0D76_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D76->then_instructions;

                                 body.emit(assign(r0D75, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D76->else_instructions;

                                 ir_variable *const r0D78 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0D7A = equal(r0D2C, body.constant(int(2045)));
                                 ir_if *f0D79 = new(mem_ctx) ir_if(operand(r0D7A).val);
                                 exec_list *const f0D79_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0D79->then_instructions;

                                    ir_expression *const r0D7B = equal(body.constant(2097151u), r0D2D);
                                    ir_expression *const r0D7C = equal(body.constant(4294967295u), r0D2E);
                                    body.emit(assign(r0D78, logic_and(r0D7B, r0D7C), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0D79->else_instructions;

                                    body.emit(assign(r0D78, body.constant(false), 0x01));


                                 body.instructions = f0D79_parent_instructions;
                                 body.emit(f0D79);

                                 /* END IF */

                                 body.emit(assign(r0D75, logic_and(r0D78, r0D71), 0x01));


                              body.instructions = f0D76_parent_instructions;
                              body.emit(f0D76);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f0D7D = new(mem_ctx) ir_if(operand(r0D75).val);
                              exec_list *const f0D7D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D7D->then_instructions;

                                 ir_variable *const r0D7E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r0D7E);
                                 ir_expression *const r0D7F = lshift(r0999, body.constant(int(31)));
                                 body.emit(assign(r0D7E, add(r0D7F, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r0D7E, body.constant(0u), 0x01));

                                 body.emit(assign(r0D70, r0D7E, 0x03));

                                 body.emit(assign(r0D6F, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D7D->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0D81 = less(r0D2C, body.constant(int(0)));
                                 ir_if *f0D80 = new(mem_ctx) ir_if(operand(r0D81).val);
                                 exec_list *const f0D80_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0D80->then_instructions;

                                    ir_variable *const r0D82 = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r0D82, r0D2F, 0x01));

                                    ir_variable *const r0D83 = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r0D83, neg(r0D2C), 0x01));

                                    ir_variable *const r0D84 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r0D84);
                                    ir_variable *const r0D85 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r0D85);
                                    ir_variable *const r0D86 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r0D86);
                                    ir_variable *const r0D87 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r0D88 = neg(r0D83);
                                    body.emit(assign(r0D87, bit_and(r0D88, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r0D8A = equal(r0D83, body.constant(int(0)));
                                    ir_if *f0D89 = new(mem_ctx) ir_if(operand(r0D8A).val);
                                    exec_list *const f0D89_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0D89->then_instructions;

                                       body.emit(assign(r0D84, r0D2F, 0x01));

                                       body.emit(assign(r0D85, r0D2E, 0x01));

                                       body.emit(assign(r0D86, r0D2D, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0D89->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r0D8C = less(r0D83, body.constant(int(32)));
                                       ir_if *f0D8B = new(mem_ctx) ir_if(operand(r0D8C).val);
                                       exec_list *const f0D8B_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0D8B->then_instructions;

                                          body.emit(assign(r0D84, lshift(r0D2E, r0D87), 0x01));

                                          ir_expression *const r0D8D = lshift(r0D2D, r0D87);
                                          ir_expression *const r0D8E = rshift(r0D2E, r0D83);
                                          body.emit(assign(r0D85, bit_or(r0D8D, r0D8E), 0x01));

                                          body.emit(assign(r0D86, rshift(r0D2D, r0D83), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0D8B->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r0D90 = equal(r0D83, body.constant(int(32)));
                                          ir_if *f0D8F = new(mem_ctx) ir_if(operand(r0D90).val);
                                          exec_list *const f0D8F_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0D8F->then_instructions;

                                             body.emit(assign(r0D84, r0D2E, 0x01));

                                             body.emit(assign(r0D85, r0D2D, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0D8F->else_instructions;

                                             body.emit(assign(r0D82, bit_or(r0D2F, r0D2E), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r0D92 = less(r0D83, body.constant(int(64)));
                                             ir_if *f0D91 = new(mem_ctx) ir_if(operand(r0D92).val);
                                             exec_list *const f0D91_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f0D91->then_instructions;

                                                body.emit(assign(r0D84, lshift(r0D2D, r0D87), 0x01));

                                                ir_expression *const r0D93 = bit_and(r0D83, body.constant(int(31)));
                                                body.emit(assign(r0D85, rshift(r0D2D, r0D93), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f0D91->else_instructions;

                                                ir_variable *const r0D94 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r0D96 = equal(r0D83, body.constant(int(64)));
                                                ir_if *f0D95 = new(mem_ctx) ir_if(operand(r0D96).val);
                                                exec_list *const f0D95_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f0D95->then_instructions;

                                                   body.emit(assign(r0D94, r0D2D, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f0D95->else_instructions;

                                                   ir_expression *const r0D97 = nequal(r0D2D, body.constant(0u));
                                                   ir_expression *const r0D98 = expr(ir_unop_b2i, r0D97);
                                                   body.emit(assign(r0D94, expr(ir_unop_i2u, r0D98), 0x01));


                                                body.instructions = f0D95_parent_instructions;
                                                body.emit(f0D95);

                                                /* END IF */

                                                body.emit(assign(r0D84, r0D94, 0x01));

                                                body.emit(assign(r0D85, body.constant(0u), 0x01));


                                             body.instructions = f0D91_parent_instructions;
                                             body.emit(f0D91);

                                             /* END IF */


                                          body.instructions = f0D8F_parent_instructions;
                                          body.emit(f0D8F);

                                          /* END IF */

                                          body.emit(assign(r0D86, body.constant(0u), 0x01));


                                       body.instructions = f0D8B_parent_instructions;
                                       body.emit(f0D8B);

                                       /* END IF */

                                       ir_expression *const r0D99 = nequal(r0D82, body.constant(0u));
                                       ir_expression *const r0D9A = expr(ir_unop_b2i, r0D99);
                                       ir_expression *const r0D9B = expr(ir_unop_i2u, r0D9A);
                                       body.emit(assign(r0D84, bit_or(r0D84, r0D9B), 0x01));


                                    body.instructions = f0D89_parent_instructions;
                                    body.emit(f0D89);

                                    /* END IF */

                                    body.emit(assign(r0D6C, r0D86, 0x01));

                                    body.emit(assign(r0D6D, r0D85, 0x01));

                                    body.emit(assign(r0D6E, r0D84, 0x01));

                                    body.emit(assign(r0D6B, body.constant(int(0)), 0x01));

                                    body.emit(assign(r0D71, less(r0D84, body.constant(0u)), 0x01));


                                 body.instructions = f0D80_parent_instructions;
                                 body.emit(f0D80);

                                 /* END IF */


                              body.instructions = f0D7D_parent_instructions;
                              body.emit(f0D7D);

                              /* END IF */


                           body.instructions = f0D73_parent_instructions;
                           body.emit(f0D73);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f0D9C = new(mem_ctx) ir_if(operand(r0D6F).val);
                           exec_list *const f0D9C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D9C->then_instructions;

                              /* IF CONDITION */
                              ir_if *f0D9D = new(mem_ctx) ir_if(operand(r0D71).val);
                              exec_list *const f0D9D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D9D->then_instructions;

                                 ir_variable *const r0D9E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r0D9E, add(r0D6D, body.constant(1u)), 0x01));

                                 ir_expression *const r0D9F = less(r0D9E, r0D6D);
                                 ir_expression *const r0DA0 = expr(ir_unop_b2i, r0D9F);
                                 ir_expression *const r0DA1 = expr(ir_unop_i2u, r0DA0);
                                 body.emit(assign(r0D6C, add(r0D6C, r0DA1), 0x01));

                                 ir_expression *const r0DA2 = equal(r0D6E, body.constant(0u));
                                 ir_expression *const r0DA3 = expr(ir_unop_b2i, r0DA2);
                                 ir_expression *const r0DA4 = expr(ir_unop_i2u, r0DA3);
                                 ir_expression *const r0DA5 = add(r0D6E, r0DA4);
                                 ir_expression *const r0DA6 = bit_and(r0DA5, body.constant(1u));
                                 ir_expression *const r0DA7 = expr(ir_unop_bit_not, r0DA6);
                                 body.emit(assign(r0D6D, bit_and(r0D9E, r0DA7), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D9D->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0DA9 = bit_or(r0D6C, r0D6D);
                                 ir_expression *const r0DAA = equal(r0DA9, body.constant(0u));
                                 ir_if *f0DA8 = new(mem_ctx) ir_if(operand(r0DAA).val);
                                 exec_list *const f0DA8_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0DA8->then_instructions;

                                    body.emit(assign(r0D6B, body.constant(int(0)), 0x01));


                                 body.instructions = f0DA8_parent_instructions;
                                 body.emit(f0DA8);

                                 /* END IF */


                              body.instructions = f0D9D_parent_instructions;
                              body.emit(f0D9D);

                              /* END IF */

                              ir_variable *const r0DAB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r0DAB);
                              ir_expression *const r0DAC = lshift(r0999, body.constant(int(31)));
                              ir_expression *const r0DAD = expr(ir_unop_i2u, r0D6B);
                              ir_expression *const r0DAE = lshift(r0DAD, body.constant(int(20)));
                              ir_expression *const r0DAF = add(r0DAC, r0DAE);
                              body.emit(assign(r0DAB, add(r0DAF, r0D6C), 0x02));

                              body.emit(assign(r0DAB, r0D6D, 0x01));

                              body.emit(assign(r0D70, r0DAB, 0x03));

                              body.emit(assign(r0D6F, body.constant(false), 0x01));


                           body.instructions = f0D9C_parent_instructions;
                           body.emit(f0D9C);

                           /* END IF */

                           body.emit(assign(r099A, r0D70, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0D24->else_instructions;

                           ir_variable *const r0DB0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r0DB0);
                           body.emit(assign(r0DB0, body.constant(0u), 0x02));

                           body.emit(assign(r0DB0, body.constant(0u), 0x01));

                           body.emit(assign(r099A, r0DB0, 0x03));


                        body.instructions = f0D24_parent_instructions;
                        body.emit(f0D24);

                        /* END IF */


                     body.instructions = f0C98_parent_instructions;
                     body.emit(f0C98);

                     /* END IF */


                  body.instructions = f0C0C_parent_instructions;
                  body.emit(f0C0C);

                  /* END IF */


               body.instructions = f0B80_parent_instructions;
               body.emit(f0B80);

               /* END IF */


            body.instructions = f0B59_parent_instructions;
            body.emit(f0B59);

            /* END IF */


         body.instructions = f0A83_parent_instructions;
         body.emit(f0A83);

         /* END IF */


      body.instructions = f09B1_parent_instructions;
      body.emit(f09B1);

      /* END IF */

      body.emit(assign(r07EB, r099A, 0x03));


   body.instructions = f07EE_parent_instructions;
   body.emit(f07EE);

   /* END IF */

   body.emit(ret(r07EB));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fsub64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0DB1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0DB1);
   ir_variable *const r0DB2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0DB2);
   ir_variable *const r0DB3 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r0DB4 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r0DB4, rshift(swizzle_y(r0DB1), body.constant(int(31))), 0x01));

   ir_variable *const r0DB5 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r0DB5, rshift(swizzle_y(r0DB2), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r0DB7 = equal(r0DB4, r0DB5);
   ir_if *f0DB6 = new(mem_ctx) ir_if(operand(r0DB7).val);
   exec_list *const f0DB6_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0DB6->then_instructions;

      ir_variable *const r0DB8 = body.make_temp(glsl_type::uint_type, "zSign");
      body.emit(assign(r0DB8, r0DB4, 0x01));

      ir_variable *const r0DB9 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r0DBA = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r0DBA);
      ir_variable *const r0DBB = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
      body.emit(r0DBB);
      ir_variable *const r0DBC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
      body.emit(r0DBC);
      ir_variable *const r0DBD = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
      body.emit(r0DBD);
      ir_variable *const r0DBE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
      body.emit(r0DBE);
      ir_variable *const r0DBF = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r0DBF);
      ir_variable *const r0DC0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r0DC0);
      body.emit(assign(r0DC0, bit_and(swizzle_y(r0DB1), body.constant(1048575u)), 0x02));

      body.emit(assign(r0DC0, swizzle_x(r0DB1), 0x01));

      ir_variable *const r0DC1 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r0DC2 = rshift(swizzle_y(r0DB1), body.constant(int(20)));
      ir_expression *const r0DC3 = bit_and(r0DC2, body.constant(2047u));
      body.emit(assign(r0DC1, expr(ir_unop_u2i, r0DC3), 0x01));

      body.emit(assign(r0DBD, r0DC1, 0x01));

      ir_variable *const r0DC4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r0DC4);
      body.emit(assign(r0DC4, bit_and(swizzle_y(r0DB2), body.constant(1048575u)), 0x02));

      body.emit(assign(r0DC4, swizzle_x(r0DB2), 0x01));

      ir_variable *const r0DC5 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r0DC6 = rshift(swizzle_y(r0DB2), body.constant(int(20)));
      ir_expression *const r0DC7 = bit_and(r0DC6, body.constant(2047u));
      body.emit(assign(r0DC5, expr(ir_unop_u2i, r0DC7), 0x01));

      body.emit(assign(r0DBB, r0DC5, 0x01));

      body.emit(assign(r0DBA, sub(r0DC1, r0DC5), 0x01));

      ir_variable *const r0DC8 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r0DC8, lshift(swizzle_x(r0DB1), body.constant(int(10))), 0x01));

      ir_variable *const r0DC9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r0DCA = lshift(swizzle_y(r0DC0), body.constant(int(10)));
      ir_expression *const r0DCB = rshift(swizzle_x(r0DB1), body.constant(int(22)));
      body.emit(assign(r0DC9, bit_or(r0DCA, r0DCB), 0x01));

      body.emit(assign(r0DBE, r0DC9, 0x02));

      body.emit(assign(r0DBE, r0DC8, 0x01));

      ir_variable *const r0DCC = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r0DCC, lshift(swizzle_x(r0DB2), body.constant(int(10))), 0x01));

      ir_variable *const r0DCD = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r0DCE = lshift(swizzle_y(r0DC4), body.constant(int(10)));
      ir_expression *const r0DCF = rshift(swizzle_x(r0DB2), body.constant(int(22)));
      body.emit(assign(r0DCD, bit_or(r0DCE, r0DCF), 0x01));

      body.emit(assign(r0DBC, r0DCD, 0x02));

      body.emit(assign(r0DBC, r0DCC, 0x01));

      /* IF CONDITION */
      ir_expression *const r0DD1 = less(body.constant(int(0)), r0DBA);
      ir_if *f0DD0 = new(mem_ctx) ir_if(operand(r0DD1).val);
      exec_list *const f0DD0_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0DD0->then_instructions;

         /* IF CONDITION */
         ir_expression *const r0DD3 = equal(r0DC1, body.constant(int(2047)));
         ir_if *f0DD2 = new(mem_ctx) ir_if(operand(r0DD3).val);
         exec_list *const f0DD2_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0DD2->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0DD5 = bit_or(r0DC9, r0DC8);
            ir_expression *const r0DD6 = nequal(r0DD5, body.constant(0u));
            ir_if *f0DD4 = new(mem_ctx) ir_if(operand(r0DD6).val);
            exec_list *const f0DD4_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0DD4->then_instructions;

               ir_variable *const r0DD7 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r0DD7, swizzle_x(r0DB1), 0x01));

               ir_variable *const r0DD8 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r0DD8, swizzle_x(r0DB2), 0x01));

               ir_variable *const r0DD9 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0DDA = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r0DDB = rshift(swizzle_y(r0DB1), body.constant(int(19)));
               ir_expression *const r0DDC = bit_and(r0DDB, body.constant(4095u));
               ir_expression *const r0DDD = equal(r0DDC, body.constant(4094u));
               ir_expression *const r0DDE = nequal(swizzle_x(r0DB1), body.constant(0u));
               ir_expression *const r0DDF = bit_and(swizzle_y(r0DB1), body.constant(524287u));
               ir_expression *const r0DE0 = nequal(r0DDF, body.constant(0u));
               ir_expression *const r0DE1 = logic_or(r0DDE, r0DE0);
               body.emit(assign(r0DDA, logic_and(r0DDD, r0DE1), 0x01));

               ir_variable *const r0DE2 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r0DE3 = lshift(swizzle_y(r0DB2), body.constant(int(1)));
               ir_expression *const r0DE4 = lequal(body.constant(4292870144u), r0DE3);
               ir_expression *const r0DE5 = nequal(swizzle_x(r0DB2), body.constant(0u));
               ir_expression *const r0DE6 = bit_and(swizzle_y(r0DB2), body.constant(1048575u));
               ir_expression *const r0DE7 = nequal(r0DE6, body.constant(0u));
               ir_expression *const r0DE8 = logic_or(r0DE5, r0DE7);
               body.emit(assign(r0DE2, logic_and(r0DE4, r0DE8), 0x01));

               body.emit(assign(r0DD7, bit_or(swizzle_y(r0DB1), body.constant(524288u)), 0x02));

               body.emit(assign(r0DD8, bit_or(swizzle_y(r0DB2), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r0DEA = lshift(swizzle_y(r0DB1), body.constant(int(1)));
               ir_expression *const r0DEB = lequal(body.constant(4292870144u), r0DEA);
               ir_expression *const r0DEC = nequal(swizzle_x(r0DB1), body.constant(0u));
               ir_expression *const r0DED = bit_and(swizzle_y(r0DB1), body.constant(1048575u));
               ir_expression *const r0DEE = nequal(r0DED, body.constant(0u));
               ir_expression *const r0DEF = logic_or(r0DEC, r0DEE);
               ir_expression *const r0DF0 = logic_and(r0DEB, r0DEF);
               ir_if *f0DE9 = new(mem_ctx) ir_if(operand(r0DF0).val);
               exec_list *const f0DE9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0DE9->then_instructions;

                  ir_variable *const r0DF1 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0DF3 = logic_and(r0DDA, r0DE2);
                  ir_if *f0DF2 = new(mem_ctx) ir_if(operand(r0DF3).val);
                  exec_list *const f0DF2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0DF2->then_instructions;

                     body.emit(assign(r0DF1, r0DD8, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0DF2->else_instructions;

                     body.emit(assign(r0DF1, r0DD7, 0x03));


                  body.instructions = f0DF2_parent_instructions;
                  body.emit(f0DF2);

                  /* END IF */

                  body.emit(assign(r0DD9, r0DF1, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0DE9->else_instructions;

                  body.emit(assign(r0DD9, r0DD8, 0x03));


               body.instructions = f0DE9_parent_instructions;
               body.emit(f0DE9);

               /* END IF */

               body.emit(assign(r0DB9, r0DD9, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0DD4->else_instructions;

               body.emit(assign(r0DB9, r0DB1, 0x03));


            body.instructions = f0DD4_parent_instructions;
            body.emit(f0DD4);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0DD2->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0DF5 = equal(r0DC5, body.constant(int(0)));
            ir_if *f0DF4 = new(mem_ctx) ir_if(operand(r0DF5).val);
            exec_list *const f0DF4_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0DF4->then_instructions;

               body.emit(assign(r0DBA, add(r0DBA, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0DF4->else_instructions;

               body.emit(assign(r0DBC, bit_or(r0DCD, body.constant(1073741824u)), 0x02));


            body.instructions = f0DF4_parent_instructions;
            body.emit(f0DF4);

            /* END IF */

            ir_variable *const r0DF6 = body.make_temp(glsl_type::uint_type, "a0");
            body.emit(assign(r0DF6, swizzle_y(r0DBC), 0x01));

            ir_variable *const r0DF7 = body.make_temp(glsl_type::uint_type, "a1");
            body.emit(assign(r0DF7, swizzle_x(r0DBC), 0x01));

            ir_variable *const r0DF8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r0DF8);
            ir_variable *const r0DF9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r0DF9);
            ir_variable *const r0DFA = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r0DFB = neg(r0DBA);
            body.emit(assign(r0DFA, bit_and(r0DFB, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0DFD = equal(r0DBA, body.constant(int(0)));
            ir_if *f0DFC = new(mem_ctx) ir_if(operand(r0DFD).val);
            exec_list *const f0DFC_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0DFC->then_instructions;

               body.emit(assign(r0DF8, r0DF7, 0x01));

               body.emit(assign(r0DF9, r0DF6, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0DFC->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0DFF = less(r0DBA, body.constant(int(32)));
               ir_if *f0DFE = new(mem_ctx) ir_if(operand(r0DFF).val);
               exec_list *const f0DFE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0DFE->then_instructions;

                  ir_expression *const r0E00 = lshift(swizzle_y(r0DBC), r0DFA);
                  ir_expression *const r0E01 = rshift(r0DCC, r0DBA);
                  ir_expression *const r0E02 = bit_or(r0E00, r0E01);
                  ir_expression *const r0E03 = lshift(r0DCC, r0DFA);
                  ir_expression *const r0E04 = nequal(r0E03, body.constant(0u));
                  ir_expression *const r0E05 = expr(ir_unop_b2i, r0E04);
                  ir_expression *const r0E06 = expr(ir_unop_i2u, r0E05);
                  body.emit(assign(r0DF8, bit_or(r0E02, r0E06), 0x01));

                  body.emit(assign(r0DF9, rshift(swizzle_y(r0DBC), r0DBA), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0DFE->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0E08 = equal(r0DBA, body.constant(int(32)));
                  ir_if *f0E07 = new(mem_ctx) ir_if(operand(r0E08).val);
                  exec_list *const f0E07_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0E07->then_instructions;

                     ir_expression *const r0E09 = nequal(r0DCC, body.constant(0u));
                     ir_expression *const r0E0A = expr(ir_unop_b2i, r0E09);
                     ir_expression *const r0E0B = expr(ir_unop_i2u, r0E0A);
                     body.emit(assign(r0DF8, bit_or(swizzle_y(r0DBC), r0E0B), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0E07->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0E0D = less(r0DBA, body.constant(int(64)));
                     ir_if *f0E0C = new(mem_ctx) ir_if(operand(r0E0D).val);
                     exec_list *const f0E0C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0E0C->then_instructions;

                        ir_expression *const r0E0E = bit_and(r0DBA, body.constant(int(31)));
                        ir_expression *const r0E0F = rshift(swizzle_y(r0DBC), r0E0E);
                        ir_expression *const r0E10 = lshift(swizzle_y(r0DBC), r0DFA);
                        ir_expression *const r0E11 = bit_or(r0E10, r0DCC);
                        ir_expression *const r0E12 = nequal(r0E11, body.constant(0u));
                        ir_expression *const r0E13 = expr(ir_unop_b2i, r0E12);
                        ir_expression *const r0E14 = expr(ir_unop_i2u, r0E13);
                        body.emit(assign(r0DF8, bit_or(r0E0F, r0E14), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0E0C->else_instructions;

                        ir_expression *const r0E15 = bit_or(swizzle_y(r0DBC), r0DCC);
                        ir_expression *const r0E16 = nequal(r0E15, body.constant(0u));
                        ir_expression *const r0E17 = expr(ir_unop_b2i, r0E16);
                        body.emit(assign(r0DF8, expr(ir_unop_i2u, r0E17), 0x01));


                     body.instructions = f0E0C_parent_instructions;
                     body.emit(f0E0C);

                     /* END IF */


                  body.instructions = f0E07_parent_instructions;
                  body.emit(f0E07);

                  /* END IF */

                  body.emit(assign(r0DF9, body.constant(0u), 0x01));


               body.instructions = f0DFE_parent_instructions;
               body.emit(f0DFE);

               /* END IF */


            body.instructions = f0DFC_parent_instructions;
            body.emit(f0DFC);

            /* END IF */

            body.emit(assign(r0DBC, r0DF9, 0x02));

            body.emit(assign(r0DBC, r0DF8, 0x01));

            body.emit(assign(r0DBE, bit_or(r0DC9, body.constant(1073741824u)), 0x02));

            ir_variable *const r0E18 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r0E19 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r0E19, sub(r0DC8, r0DF8), 0x01));

            ir_expression *const r0E1A = sub(swizzle_y(r0DBE), r0DF9);
            ir_expression *const r0E1B = less(r0DC8, r0DF8);
            ir_expression *const r0E1C = expr(ir_unop_b2i, r0E1B);
            ir_expression *const r0E1D = expr(ir_unop_i2u, r0E1C);
            body.emit(assign(r0E18, sub(r0E1A, r0E1D), 0x01));

            body.emit(assign(r0DBF, add(r0DC1, body.constant(int(-1))), 0x01));

            ir_variable *const r0E1E = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0E1E, add(r0DBF, body.constant(int(-10))), 0x01));

            ir_variable *const r0E1F = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0E1F, r0E18, 0x01));

            ir_variable *const r0E20 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0E20, r0E19, 0x01));

            ir_variable *const r0E21 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
            body.emit(r0E21);
            ir_variable *const r0E22 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0E22);
            /* IF CONDITION */
            ir_expression *const r0E24 = equal(r0E18, body.constant(0u));
            ir_if *f0E23 = new(mem_ctx) ir_if(operand(r0E24).val);
            exec_list *const f0E23_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0E23->then_instructions;

               body.emit(assign(r0E1F, r0E19, 0x01));

               body.emit(assign(r0E20, body.constant(0u), 0x01));

               body.emit(assign(r0E1E, add(r0E1E, body.constant(int(-32))), 0x01));


            body.instructions = f0E23_parent_instructions;
            body.emit(f0E23);

            /* END IF */

            ir_variable *const r0E25 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r0E25, r0E1F, 0x01));

            ir_variable *const r0E26 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r0E27 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0E27);
            /* IF CONDITION */
            ir_expression *const r0E29 = equal(r0E1F, body.constant(0u));
            ir_if *f0E28 = new(mem_ctx) ir_if(operand(r0E29).val);
            exec_list *const f0E28_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0E28->then_instructions;

               body.emit(assign(r0E26, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0E28->else_instructions;

               body.emit(assign(r0E27, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r0E2B = bit_and(r0E1F, body.constant(4294901760u));
               ir_expression *const r0E2C = equal(r0E2B, body.constant(0u));
               ir_if *f0E2A = new(mem_ctx) ir_if(operand(r0E2C).val);
               exec_list *const f0E2A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E2A->then_instructions;

                  body.emit(assign(r0E27, body.constant(int(16)), 0x01));

                  body.emit(assign(r0E25, lshift(r0E1F, body.constant(int(16))), 0x01));


               body.instructions = f0E2A_parent_instructions;
               body.emit(f0E2A);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0E2E = bit_and(r0E25, body.constant(4278190080u));
               ir_expression *const r0E2F = equal(r0E2E, body.constant(0u));
               ir_if *f0E2D = new(mem_ctx) ir_if(operand(r0E2F).val);
               exec_list *const f0E2D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E2D->then_instructions;

                  body.emit(assign(r0E27, add(r0E27, body.constant(int(8))), 0x01));

                  body.emit(assign(r0E25, lshift(r0E25, body.constant(int(8))), 0x01));


               body.instructions = f0E2D_parent_instructions;
               body.emit(f0E2D);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0E31 = bit_and(r0E25, body.constant(4026531840u));
               ir_expression *const r0E32 = equal(r0E31, body.constant(0u));
               ir_if *f0E30 = new(mem_ctx) ir_if(operand(r0E32).val);
               exec_list *const f0E30_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E30->then_instructions;

                  body.emit(assign(r0E27, add(r0E27, body.constant(int(4))), 0x01));

                  body.emit(assign(r0E25, lshift(r0E25, body.constant(int(4))), 0x01));


               body.instructions = f0E30_parent_instructions;
               body.emit(f0E30);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0E34 = bit_and(r0E25, body.constant(3221225472u));
               ir_expression *const r0E35 = equal(r0E34, body.constant(0u));
               ir_if *f0E33 = new(mem_ctx) ir_if(operand(r0E35).val);
               exec_list *const f0E33_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E33->then_instructions;

                  body.emit(assign(r0E27, add(r0E27, body.constant(int(2))), 0x01));

                  body.emit(assign(r0E25, lshift(r0E25, body.constant(int(2))), 0x01));


               body.instructions = f0E33_parent_instructions;
               body.emit(f0E33);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0E37 = bit_and(r0E25, body.constant(2147483648u));
               ir_expression *const r0E38 = equal(r0E37, body.constant(0u));
               ir_if *f0E36 = new(mem_ctx) ir_if(operand(r0E38).val);
               exec_list *const f0E36_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E36->then_instructions;

                  body.emit(assign(r0E27, add(r0E27, body.constant(int(1))), 0x01));


               body.instructions = f0E36_parent_instructions;
               body.emit(f0E36);

               /* END IF */

               body.emit(assign(r0E26, r0E27, 0x01));


            body.instructions = f0E28_parent_instructions;
            body.emit(f0E28);

            /* END IF */

            body.emit(assign(r0E22, add(r0E26, body.constant(int(-11))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0E3A = lequal(body.constant(int(0)), r0E22);
            ir_if *f0E39 = new(mem_ctx) ir_if(operand(r0E3A).val);
            exec_list *const f0E39_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0E39->then_instructions;

               body.emit(assign(r0E21, body.constant(0u), 0x01));

               ir_variable *const r0E3B = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r0E3B, lshift(r0E20, r0E22), 0x01));

               ir_variable *const r0E3C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r0E3E = equal(r0E22, body.constant(int(0)));
               ir_if *f0E3D = new(mem_ctx) ir_if(operand(r0E3E).val);
               exec_list *const f0E3D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E3D->then_instructions;

                  body.emit(assign(r0E3C, r0E1F, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0E3D->else_instructions;

                  ir_expression *const r0E3F = lshift(r0E1F, r0E22);
                  ir_expression *const r0E40 = neg(r0E22);
                  ir_expression *const r0E41 = bit_and(r0E40, body.constant(int(31)));
                  ir_expression *const r0E42 = rshift(r0E20, r0E41);
                  body.emit(assign(r0E3C, bit_or(r0E3F, r0E42), 0x01));


               body.instructions = f0E3D_parent_instructions;
               body.emit(f0E3D);

               /* END IF */

               body.emit(assign(r0E1F, r0E3C, 0x01));

               body.emit(assign(r0E20, r0E3B, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0E39->else_instructions;

               ir_variable *const r0E43 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r0E43, body.constant(0u), 0x01));

               ir_variable *const r0E44 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0E44, neg(r0E22), 0x01));

               ir_variable *const r0E45 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r0E45);
               ir_variable *const r0E46 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0E46);
               ir_variable *const r0E47 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0E47);
               ir_variable *const r0E48 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0E49 = neg(r0E44);
               body.emit(assign(r0E48, bit_and(r0E49, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0E4B = equal(r0E44, body.constant(int(0)));
               ir_if *f0E4A = new(mem_ctx) ir_if(operand(r0E4B).val);
               exec_list *const f0E4A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E4A->then_instructions;

                  body.emit(assign(r0E45, r0E43, 0x01));

                  body.emit(assign(r0E46, r0E20, 0x01));

                  body.emit(assign(r0E47, r0E1F, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0E4A->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0E4D = less(r0E44, body.constant(int(32)));
                  ir_if *f0E4C = new(mem_ctx) ir_if(operand(r0E4D).val);
                  exec_list *const f0E4C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0E4C->then_instructions;

                     body.emit(assign(r0E45, lshift(r0E20, r0E48), 0x01));

                     ir_expression *const r0E4E = lshift(r0E1F, r0E48);
                     ir_expression *const r0E4F = rshift(r0E20, r0E44);
                     body.emit(assign(r0E46, bit_or(r0E4E, r0E4F), 0x01));

                     body.emit(assign(r0E47, rshift(r0E1F, r0E44), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0E4C->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0E51 = equal(r0E44, body.constant(int(32)));
                     ir_if *f0E50 = new(mem_ctx) ir_if(operand(r0E51).val);
                     exec_list *const f0E50_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0E50->then_instructions;

                        body.emit(assign(r0E45, r0E20, 0x01));

                        body.emit(assign(r0E46, r0E1F, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0E50->else_instructions;

                        body.emit(assign(r0E43, bit_or(body.constant(0u), r0E20), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0E53 = less(r0E44, body.constant(int(64)));
                        ir_if *f0E52 = new(mem_ctx) ir_if(operand(r0E53).val);
                        exec_list *const f0E52_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0E52->then_instructions;

                           body.emit(assign(r0E45, lshift(r0E1F, r0E48), 0x01));

                           ir_expression *const r0E54 = bit_and(r0E44, body.constant(int(31)));
                           body.emit(assign(r0E46, rshift(r0E1F, r0E54), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0E52->else_instructions;

                           ir_variable *const r0E55 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0E57 = equal(r0E44, body.constant(int(64)));
                           ir_if *f0E56 = new(mem_ctx) ir_if(operand(r0E57).val);
                           exec_list *const f0E56_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0E56->then_instructions;

                              body.emit(assign(r0E55, r0E1F, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0E56->else_instructions;

                              ir_expression *const r0E58 = nequal(r0E1F, body.constant(0u));
                              ir_expression *const r0E59 = expr(ir_unop_b2i, r0E58);
                              body.emit(assign(r0E55, expr(ir_unop_i2u, r0E59), 0x01));


                           body.instructions = f0E56_parent_instructions;
                           body.emit(f0E56);

                           /* END IF */

                           body.emit(assign(r0E45, r0E55, 0x01));

                           body.emit(assign(r0E46, body.constant(0u), 0x01));


                        body.instructions = f0E52_parent_instructions;
                        body.emit(f0E52);

                        /* END IF */


                     body.instructions = f0E50_parent_instructions;
                     body.emit(f0E50);

                     /* END IF */

                     body.emit(assign(r0E47, body.constant(0u), 0x01));


                  body.instructions = f0E4C_parent_instructions;
                  body.emit(f0E4C);

                  /* END IF */

                  ir_expression *const r0E5A = nequal(r0E43, body.constant(0u));
                  ir_expression *const r0E5B = expr(ir_unop_b2i, r0E5A);
                  ir_expression *const r0E5C = expr(ir_unop_i2u, r0E5B);
                  body.emit(assign(r0E45, bit_or(r0E45, r0E5C), 0x01));


               body.instructions = f0E4A_parent_instructions;
               body.emit(f0E4A);

               /* END IF */

               body.emit(assign(r0E1F, r0E47, 0x01));

               body.emit(assign(r0E20, r0E46, 0x01));

               body.emit(assign(r0E21, r0E45, 0x01));


            body.instructions = f0E39_parent_instructions;
            body.emit(f0E39);

            /* END IF */

            body.emit(assign(r0E1E, sub(r0E1E, r0E22), 0x01));

            ir_variable *const r0E5D = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0E5D, r0E1E, 0x01));

            ir_variable *const r0E5E = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0E5E, r0E1F, 0x01));

            ir_variable *const r0E5F = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0E5F, r0E20, 0x01));

            ir_variable *const r0E60 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r0E60, r0E21, 0x01));

            ir_variable *const r0E61 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r0E61, body.constant(true), 0x01));

            ir_variable *const r0E62 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0E63 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r0E63);
            ir_expression *const r0E64 = expr(ir_unop_u2i, r0E21);
            body.emit(assign(r0E63, less(r0E64, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0E66 = lequal(body.constant(int(2045)), r0E1E);
            ir_if *f0E65 = new(mem_ctx) ir_if(operand(r0E66).val);
            exec_list *const f0E65_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0E65->then_instructions;

               ir_variable *const r0E67 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0E69 = less(body.constant(int(2045)), r0E1E);
               ir_if *f0E68 = new(mem_ctx) ir_if(operand(r0E69).val);
               exec_list *const f0E68_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E68->then_instructions;

                  body.emit(assign(r0E67, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0E68->else_instructions;

                  ir_variable *const r0E6A = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0E6C = equal(r0E1E, body.constant(int(2045)));
                  ir_if *f0E6B = new(mem_ctx) ir_if(operand(r0E6C).val);
                  exec_list *const f0E6B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0E6B->then_instructions;

                     ir_expression *const r0E6D = equal(body.constant(2097151u), r0E1F);
                     ir_expression *const r0E6E = equal(body.constant(4294967295u), r0E20);
                     body.emit(assign(r0E6A, logic_and(r0E6D, r0E6E), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0E6B->else_instructions;

                     body.emit(assign(r0E6A, body.constant(false), 0x01));


                  body.instructions = f0E6B_parent_instructions;
                  body.emit(f0E6B);

                  /* END IF */

                  body.emit(assign(r0E67, logic_and(r0E6A, r0E63), 0x01));


               body.instructions = f0E68_parent_instructions;
               body.emit(f0E68);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0E6F = new(mem_ctx) ir_if(operand(r0E67).val);
               exec_list *const f0E6F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E6F->then_instructions;

                  ir_variable *const r0E70 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0E70);
                  ir_expression *const r0E71 = lshift(r0DB4, body.constant(int(31)));
                  body.emit(assign(r0E70, add(r0E71, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0E70, body.constant(0u), 0x01));

                  body.emit(assign(r0E62, r0E70, 0x03));

                  body.emit(assign(r0E61, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0E6F->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0E73 = less(r0E1E, body.constant(int(0)));
                  ir_if *f0E72 = new(mem_ctx) ir_if(operand(r0E73).val);
                  exec_list *const f0E72_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0E72->then_instructions;

                     ir_variable *const r0E74 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0E74, r0E21, 0x01));

                     ir_variable *const r0E75 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0E75, neg(r0E1E), 0x01));

                     ir_variable *const r0E76 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0E76);
                     ir_variable *const r0E77 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0E77);
                     ir_variable *const r0E78 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0E78);
                     ir_variable *const r0E79 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0E7A = neg(r0E75);
                     body.emit(assign(r0E79, bit_and(r0E7A, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0E7C = equal(r0E75, body.constant(int(0)));
                     ir_if *f0E7B = new(mem_ctx) ir_if(operand(r0E7C).val);
                     exec_list *const f0E7B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0E7B->then_instructions;

                        body.emit(assign(r0E76, r0E21, 0x01));

                        body.emit(assign(r0E77, r0E20, 0x01));

                        body.emit(assign(r0E78, r0E1F, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0E7B->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0E7E = less(r0E75, body.constant(int(32)));
                        ir_if *f0E7D = new(mem_ctx) ir_if(operand(r0E7E).val);
                        exec_list *const f0E7D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0E7D->then_instructions;

                           body.emit(assign(r0E76, lshift(r0E20, r0E79), 0x01));

                           ir_expression *const r0E7F = lshift(r0E1F, r0E79);
                           ir_expression *const r0E80 = rshift(r0E20, r0E75);
                           body.emit(assign(r0E77, bit_or(r0E7F, r0E80), 0x01));

                           body.emit(assign(r0E78, rshift(r0E1F, r0E75), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0E7D->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0E82 = equal(r0E75, body.constant(int(32)));
                           ir_if *f0E81 = new(mem_ctx) ir_if(operand(r0E82).val);
                           exec_list *const f0E81_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0E81->then_instructions;

                              body.emit(assign(r0E76, r0E20, 0x01));

                              body.emit(assign(r0E77, r0E1F, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0E81->else_instructions;

                              body.emit(assign(r0E74, bit_or(r0E21, r0E20), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0E84 = less(r0E75, body.constant(int(64)));
                              ir_if *f0E83 = new(mem_ctx) ir_if(operand(r0E84).val);
                              exec_list *const f0E83_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0E83->then_instructions;

                                 body.emit(assign(r0E76, lshift(r0E1F, r0E79), 0x01));

                                 ir_expression *const r0E85 = bit_and(r0E75, body.constant(int(31)));
                                 body.emit(assign(r0E77, rshift(r0E1F, r0E85), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0E83->else_instructions;

                                 ir_variable *const r0E86 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0E88 = equal(r0E75, body.constant(int(64)));
                                 ir_if *f0E87 = new(mem_ctx) ir_if(operand(r0E88).val);
                                 exec_list *const f0E87_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0E87->then_instructions;

                                    body.emit(assign(r0E86, r0E1F, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0E87->else_instructions;

                                    ir_expression *const r0E89 = nequal(r0E1F, body.constant(0u));
                                    ir_expression *const r0E8A = expr(ir_unop_b2i, r0E89);
                                    body.emit(assign(r0E86, expr(ir_unop_i2u, r0E8A), 0x01));


                                 body.instructions = f0E87_parent_instructions;
                                 body.emit(f0E87);

                                 /* END IF */

                                 body.emit(assign(r0E76, r0E86, 0x01));

                                 body.emit(assign(r0E77, body.constant(0u), 0x01));


                              body.instructions = f0E83_parent_instructions;
                              body.emit(f0E83);

                              /* END IF */


                           body.instructions = f0E81_parent_instructions;
                           body.emit(f0E81);

                           /* END IF */

                           body.emit(assign(r0E78, body.constant(0u), 0x01));


                        body.instructions = f0E7D_parent_instructions;
                        body.emit(f0E7D);

                        /* END IF */

                        ir_expression *const r0E8B = nequal(r0E74, body.constant(0u));
                        ir_expression *const r0E8C = expr(ir_unop_b2i, r0E8B);
                        ir_expression *const r0E8D = expr(ir_unop_i2u, r0E8C);
                        body.emit(assign(r0E76, bit_or(r0E76, r0E8D), 0x01));


                     body.instructions = f0E7B_parent_instructions;
                     body.emit(f0E7B);

                     /* END IF */

                     body.emit(assign(r0E5E, r0E78, 0x01));

                     body.emit(assign(r0E5F, r0E77, 0x01));

                     body.emit(assign(r0E60, r0E76, 0x01));

                     body.emit(assign(r0E5D, body.constant(int(0)), 0x01));

                     body.emit(assign(r0E63, less(r0E76, body.constant(0u)), 0x01));


                  body.instructions = f0E72_parent_instructions;
                  body.emit(f0E72);

                  /* END IF */


               body.instructions = f0E6F_parent_instructions;
               body.emit(f0E6F);

               /* END IF */


            body.instructions = f0E65_parent_instructions;
            body.emit(f0E65);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0E8E = new(mem_ctx) ir_if(operand(r0E61).val);
            exec_list *const f0E8E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0E8E->then_instructions;

               /* IF CONDITION */
               ir_if *f0E8F = new(mem_ctx) ir_if(operand(r0E63).val);
               exec_list *const f0E8F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0E8F->then_instructions;

                  ir_variable *const r0E90 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r0E90, add(r0E5F, body.constant(1u)), 0x01));

                  ir_expression *const r0E91 = less(r0E90, r0E5F);
                  ir_expression *const r0E92 = expr(ir_unop_b2i, r0E91);
                  ir_expression *const r0E93 = expr(ir_unop_i2u, r0E92);
                  body.emit(assign(r0E5E, add(r0E5E, r0E93), 0x01));

                  ir_expression *const r0E94 = equal(r0E60, body.constant(0u));
                  ir_expression *const r0E95 = expr(ir_unop_b2i, r0E94);
                  ir_expression *const r0E96 = expr(ir_unop_i2u, r0E95);
                  ir_expression *const r0E97 = add(r0E60, r0E96);
                  ir_expression *const r0E98 = bit_and(r0E97, body.constant(1u));
                  ir_expression *const r0E99 = expr(ir_unop_bit_not, r0E98);
                  body.emit(assign(r0E5F, bit_and(r0E90, r0E99), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0E8F->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0E9B = bit_or(r0E5E, r0E5F);
                  ir_expression *const r0E9C = equal(r0E9B, body.constant(0u));
                  ir_if *f0E9A = new(mem_ctx) ir_if(operand(r0E9C).val);
                  exec_list *const f0E9A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0E9A->then_instructions;

                     body.emit(assign(r0E5D, body.constant(int(0)), 0x01));


                  body.instructions = f0E9A_parent_instructions;
                  body.emit(f0E9A);

                  /* END IF */


               body.instructions = f0E8F_parent_instructions;
               body.emit(f0E8F);

               /* END IF */

               ir_variable *const r0E9D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0E9D);
               ir_expression *const r0E9E = lshift(r0DB4, body.constant(int(31)));
               ir_expression *const r0E9F = expr(ir_unop_i2u, r0E5D);
               ir_expression *const r0EA0 = lshift(r0E9F, body.constant(int(20)));
               ir_expression *const r0EA1 = add(r0E9E, r0EA0);
               body.emit(assign(r0E9D, add(r0EA1, r0E5E), 0x02));

               body.emit(assign(r0E9D, r0E5F, 0x01));

               body.emit(assign(r0E62, r0E9D, 0x03));

               body.emit(assign(r0E61, body.constant(false), 0x01));


            body.instructions = f0E8E_parent_instructions;
            body.emit(f0E8E);

            /* END IF */

            body.emit(assign(r0DB9, r0E62, 0x03));


         body.instructions = f0DD2_parent_instructions;
         body.emit(f0DD2);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0DD0->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0EA3 = less(r0DBA, body.constant(int(0)));
         ir_if *f0EA2 = new(mem_ctx) ir_if(operand(r0EA3).val);
         exec_list *const f0EA2_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0EA2->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0EA5 = equal(r0DC5, body.constant(int(2047)));
            ir_if *f0EA4 = new(mem_ctx) ir_if(operand(r0EA5).val);
            exec_list *const f0EA4_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0EA4->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0EA7 = bit_or(swizzle_y(r0DBC), swizzle_x(r0DBC));
               ir_expression *const r0EA8 = nequal(r0EA7, body.constant(0u));
               ir_if *f0EA6 = new(mem_ctx) ir_if(operand(r0EA8).val);
               exec_list *const f0EA6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0EA6->then_instructions;

                  ir_variable *const r0EA9 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r0EA9, swizzle_x(r0DB1), 0x01));

                  ir_variable *const r0EAA = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r0EAA, swizzle_x(r0DB2), 0x01));

                  ir_variable *const r0EAB = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0EAC = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0EAD = rshift(swizzle_y(r0DB1), body.constant(int(19)));
                  ir_expression *const r0EAE = bit_and(r0EAD, body.constant(4095u));
                  ir_expression *const r0EAF = equal(r0EAE, body.constant(4094u));
                  ir_expression *const r0EB0 = nequal(swizzle_x(r0DB1), body.constant(0u));
                  ir_expression *const r0EB1 = bit_and(swizzle_y(r0DB1), body.constant(524287u));
                  ir_expression *const r0EB2 = nequal(r0EB1, body.constant(0u));
                  ir_expression *const r0EB3 = logic_or(r0EB0, r0EB2);
                  body.emit(assign(r0EAC, logic_and(r0EAF, r0EB3), 0x01));

                  ir_variable *const r0EB4 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0EB5 = lshift(swizzle_y(r0DB2), body.constant(int(1)));
                  ir_expression *const r0EB6 = lequal(body.constant(4292870144u), r0EB5);
                  ir_expression *const r0EB7 = nequal(swizzle_x(r0DB2), body.constant(0u));
                  ir_expression *const r0EB8 = bit_and(swizzle_y(r0DB2), body.constant(1048575u));
                  ir_expression *const r0EB9 = nequal(r0EB8, body.constant(0u));
                  ir_expression *const r0EBA = logic_or(r0EB7, r0EB9);
                  body.emit(assign(r0EB4, logic_and(r0EB6, r0EBA), 0x01));

                  body.emit(assign(r0EA9, bit_or(swizzle_y(r0DB1), body.constant(524288u)), 0x02));

                  body.emit(assign(r0EAA, bit_or(swizzle_y(r0DB2), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r0EBC = lshift(swizzle_y(r0DB1), body.constant(int(1)));
                  ir_expression *const r0EBD = lequal(body.constant(4292870144u), r0EBC);
                  ir_expression *const r0EBE = nequal(swizzle_x(r0DB1), body.constant(0u));
                  ir_expression *const r0EBF = bit_and(swizzle_y(r0DB1), body.constant(1048575u));
                  ir_expression *const r0EC0 = nequal(r0EBF, body.constant(0u));
                  ir_expression *const r0EC1 = logic_or(r0EBE, r0EC0);
                  ir_expression *const r0EC2 = logic_and(r0EBD, r0EC1);
                  ir_if *f0EBB = new(mem_ctx) ir_if(operand(r0EC2).val);
                  exec_list *const f0EBB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0EBB->then_instructions;

                     ir_variable *const r0EC3 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0EC5 = logic_and(r0EAC, r0EB4);
                     ir_if *f0EC4 = new(mem_ctx) ir_if(operand(r0EC5).val);
                     exec_list *const f0EC4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0EC4->then_instructions;

                        body.emit(assign(r0EC3, r0EAA, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0EC4->else_instructions;

                        body.emit(assign(r0EC3, r0EA9, 0x03));


                     body.instructions = f0EC4_parent_instructions;
                     body.emit(f0EC4);

                     /* END IF */

                     body.emit(assign(r0EAB, r0EC3, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0EBB->else_instructions;

                     body.emit(assign(r0EAB, r0EAA, 0x03));


                  body.instructions = f0EBB_parent_instructions;
                  body.emit(f0EBB);

                  /* END IF */

                  body.emit(assign(r0DB9, r0EAB, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0EA6->else_instructions;

                  ir_variable *const r0EC6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0EC6);
                  ir_expression *const r0EC7 = bit_xor(r0DB4, body.constant(1u));
                  ir_expression *const r0EC8 = lshift(r0EC7, body.constant(int(31)));
                  body.emit(assign(r0EC6, add(r0EC8, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0EC6, body.constant(0u), 0x01));

                  body.emit(assign(r0DB9, r0EC6, 0x03));


               body.instructions = f0EA6_parent_instructions;
               body.emit(f0EA6);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0EA4->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0ECA = equal(r0DC1, body.constant(int(0)));
               ir_if *f0EC9 = new(mem_ctx) ir_if(operand(r0ECA).val);
               exec_list *const f0EC9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0EC9->then_instructions;

                  body.emit(assign(r0DBA, add(r0DBA, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0EC9->else_instructions;

                  body.emit(assign(r0DBE, bit_or(swizzle_y(r0DBE), body.constant(1073741824u)), 0x02));


               body.instructions = f0EC9_parent_instructions;
               body.emit(f0EC9);

               /* END IF */

               ir_variable *const r0ECB = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r0ECB, swizzle_y(r0DBE), 0x01));

               ir_variable *const r0ECC = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r0ECC, swizzle_x(r0DBE), 0x01));

               ir_variable *const r0ECD = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0ECD, neg(r0DBA), 0x01));

               ir_variable *const r0ECE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0ECE);
               ir_variable *const r0ECF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0ECF);
               ir_variable *const r0ED0 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0ED1 = neg(r0ECD);
               body.emit(assign(r0ED0, bit_and(r0ED1, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0ED3 = equal(r0ECD, body.constant(int(0)));
               ir_if *f0ED2 = new(mem_ctx) ir_if(operand(r0ED3).val);
               exec_list *const f0ED2_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0ED2->then_instructions;

                  body.emit(assign(r0ECE, r0ECC, 0x01));

                  body.emit(assign(r0ECF, r0ECB, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0ED2->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0ED5 = less(r0ECD, body.constant(int(32)));
                  ir_if *f0ED4 = new(mem_ctx) ir_if(operand(r0ED5).val);
                  exec_list *const f0ED4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0ED4->then_instructions;

                     ir_expression *const r0ED6 = lshift(swizzle_y(r0DBE), r0ED0);
                     ir_expression *const r0ED7 = rshift(r0DC8, r0ECD);
                     ir_expression *const r0ED8 = bit_or(r0ED6, r0ED7);
                     ir_expression *const r0ED9 = lshift(r0DC8, r0ED0);
                     ir_expression *const r0EDA = nequal(r0ED9, body.constant(0u));
                     ir_expression *const r0EDB = expr(ir_unop_b2i, r0EDA);
                     ir_expression *const r0EDC = expr(ir_unop_i2u, r0EDB);
                     body.emit(assign(r0ECE, bit_or(r0ED8, r0EDC), 0x01));

                     body.emit(assign(r0ECF, rshift(swizzle_y(r0DBE), r0ECD), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0ED4->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0EDE = equal(r0ECD, body.constant(int(32)));
                     ir_if *f0EDD = new(mem_ctx) ir_if(operand(r0EDE).val);
                     exec_list *const f0EDD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0EDD->then_instructions;

                        ir_expression *const r0EDF = nequal(r0DC8, body.constant(0u));
                        ir_expression *const r0EE0 = expr(ir_unop_b2i, r0EDF);
                        ir_expression *const r0EE1 = expr(ir_unop_i2u, r0EE0);
                        body.emit(assign(r0ECE, bit_or(swizzle_y(r0DBE), r0EE1), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0EDD->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0EE3 = less(r0ECD, body.constant(int(64)));
                        ir_if *f0EE2 = new(mem_ctx) ir_if(operand(r0EE3).val);
                        exec_list *const f0EE2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0EE2->then_instructions;

                           ir_expression *const r0EE4 = bit_and(r0ECD, body.constant(int(31)));
                           ir_expression *const r0EE5 = rshift(swizzle_y(r0DBE), r0EE4);
                           ir_expression *const r0EE6 = lshift(swizzle_y(r0DBE), r0ED0);
                           ir_expression *const r0EE7 = bit_or(r0EE6, r0DC8);
                           ir_expression *const r0EE8 = nequal(r0EE7, body.constant(0u));
                           ir_expression *const r0EE9 = expr(ir_unop_b2i, r0EE8);
                           ir_expression *const r0EEA = expr(ir_unop_i2u, r0EE9);
                           body.emit(assign(r0ECE, bit_or(r0EE5, r0EEA), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0EE2->else_instructions;

                           ir_expression *const r0EEB = bit_or(swizzle_y(r0DBE), r0DC8);
                           ir_expression *const r0EEC = nequal(r0EEB, body.constant(0u));
                           ir_expression *const r0EED = expr(ir_unop_b2i, r0EEC);
                           body.emit(assign(r0ECE, expr(ir_unop_i2u, r0EED), 0x01));


                        body.instructions = f0EE2_parent_instructions;
                        body.emit(f0EE2);

                        /* END IF */


                     body.instructions = f0EDD_parent_instructions;
                     body.emit(f0EDD);

                     /* END IF */

                     body.emit(assign(r0ECF, body.constant(0u), 0x01));


                  body.instructions = f0ED4_parent_instructions;
                  body.emit(f0ED4);

                  /* END IF */


               body.instructions = f0ED2_parent_instructions;
               body.emit(f0ED2);

               /* END IF */

               body.emit(assign(r0DBE, r0ECF, 0x02));

               body.emit(assign(r0DBE, r0ECE, 0x01));

               body.emit(assign(r0DBC, bit_or(swizzle_y(r0DBC), body.constant(1073741824u)), 0x02));

               ir_variable *const r0EEE = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r0EEF = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r0EEF, sub(swizzle_x(r0DBC), r0ECE), 0x01));

               ir_expression *const r0EF0 = sub(swizzle_y(r0DBC), r0ECF);
               ir_expression *const r0EF1 = less(swizzle_x(r0DBC), r0ECE);
               ir_expression *const r0EF2 = expr(ir_unop_b2i, r0EF1);
               ir_expression *const r0EF3 = expr(ir_unop_i2u, r0EF2);
               body.emit(assign(r0EEE, sub(r0EF0, r0EF3), 0x01));

               body.emit(assign(r0DB8, bit_xor(r0DB4, body.constant(1u)), 0x01));

               body.emit(assign(r0DBF, add(r0DC5, body.constant(int(-1))), 0x01));

               ir_variable *const r0EF4 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r0EF4, add(r0DBF, body.constant(int(-10))), 0x01));

               ir_variable *const r0EF5 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0EF5, r0EEE, 0x01));

               ir_variable *const r0EF6 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0EF6, r0EEF, 0x01));

               ir_variable *const r0EF7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r0EF7);
               ir_variable *const r0EF8 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r0EF8);
               /* IF CONDITION */
               ir_expression *const r0EFA = equal(r0EEE, body.constant(0u));
               ir_if *f0EF9 = new(mem_ctx) ir_if(operand(r0EFA).val);
               exec_list *const f0EF9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0EF9->then_instructions;

                  body.emit(assign(r0EF5, r0EEF, 0x01));

                  body.emit(assign(r0EF6, body.constant(0u), 0x01));

                  body.emit(assign(r0EF4, add(r0EF4, body.constant(int(-32))), 0x01));


               body.instructions = f0EF9_parent_instructions;
               body.emit(f0EF9);

               /* END IF */

               ir_variable *const r0EFB = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r0EFB, r0EF5, 0x01));

               ir_variable *const r0EFC = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r0EFD = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r0EFD);
               /* IF CONDITION */
               ir_expression *const r0EFF = equal(r0EF5, body.constant(0u));
               ir_if *f0EFE = new(mem_ctx) ir_if(operand(r0EFF).val);
               exec_list *const f0EFE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0EFE->then_instructions;

                  body.emit(assign(r0EFC, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0EFE->else_instructions;

                  body.emit(assign(r0EFD, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0F01 = bit_and(r0EF5, body.constant(4294901760u));
                  ir_expression *const r0F02 = equal(r0F01, body.constant(0u));
                  ir_if *f0F00 = new(mem_ctx) ir_if(operand(r0F02).val);
                  exec_list *const f0F00_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F00->then_instructions;

                     body.emit(assign(r0EFD, body.constant(int(16)), 0x01));

                     body.emit(assign(r0EFB, lshift(r0EF5, body.constant(int(16))), 0x01));


                  body.instructions = f0F00_parent_instructions;
                  body.emit(f0F00);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0F04 = bit_and(r0EFB, body.constant(4278190080u));
                  ir_expression *const r0F05 = equal(r0F04, body.constant(0u));
                  ir_if *f0F03 = new(mem_ctx) ir_if(operand(r0F05).val);
                  exec_list *const f0F03_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F03->then_instructions;

                     body.emit(assign(r0EFD, add(r0EFD, body.constant(int(8))), 0x01));

                     body.emit(assign(r0EFB, lshift(r0EFB, body.constant(int(8))), 0x01));


                  body.instructions = f0F03_parent_instructions;
                  body.emit(f0F03);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0F07 = bit_and(r0EFB, body.constant(4026531840u));
                  ir_expression *const r0F08 = equal(r0F07, body.constant(0u));
                  ir_if *f0F06 = new(mem_ctx) ir_if(operand(r0F08).val);
                  exec_list *const f0F06_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F06->then_instructions;

                     body.emit(assign(r0EFD, add(r0EFD, body.constant(int(4))), 0x01));

                     body.emit(assign(r0EFB, lshift(r0EFB, body.constant(int(4))), 0x01));


                  body.instructions = f0F06_parent_instructions;
                  body.emit(f0F06);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0F0A = bit_and(r0EFB, body.constant(3221225472u));
                  ir_expression *const r0F0B = equal(r0F0A, body.constant(0u));
                  ir_if *f0F09 = new(mem_ctx) ir_if(operand(r0F0B).val);
                  exec_list *const f0F09_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F09->then_instructions;

                     body.emit(assign(r0EFD, add(r0EFD, body.constant(int(2))), 0x01));

                     body.emit(assign(r0EFB, lshift(r0EFB, body.constant(int(2))), 0x01));


                  body.instructions = f0F09_parent_instructions;
                  body.emit(f0F09);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0F0D = bit_and(r0EFB, body.constant(2147483648u));
                  ir_expression *const r0F0E = equal(r0F0D, body.constant(0u));
                  ir_if *f0F0C = new(mem_ctx) ir_if(operand(r0F0E).val);
                  exec_list *const f0F0C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F0C->then_instructions;

                     body.emit(assign(r0EFD, add(r0EFD, body.constant(int(1))), 0x01));


                  body.instructions = f0F0C_parent_instructions;
                  body.emit(f0F0C);

                  /* END IF */

                  body.emit(assign(r0EFC, r0EFD, 0x01));


               body.instructions = f0EFE_parent_instructions;
               body.emit(f0EFE);

               /* END IF */

               body.emit(assign(r0EF8, add(r0EFC, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0F10 = lequal(body.constant(int(0)), r0EF8);
               ir_if *f0F0F = new(mem_ctx) ir_if(operand(r0F10).val);
               exec_list *const f0F0F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F0F->then_instructions;

                  body.emit(assign(r0EF7, body.constant(0u), 0x01));

                  ir_variable *const r0F11 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0F11, lshift(r0EF6, r0EF8), 0x01));

                  ir_variable *const r0F12 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0F14 = equal(r0EF8, body.constant(int(0)));
                  ir_if *f0F13 = new(mem_ctx) ir_if(operand(r0F14).val);
                  exec_list *const f0F13_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F13->then_instructions;

                     body.emit(assign(r0F12, r0EF5, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F13->else_instructions;

                     ir_expression *const r0F15 = lshift(r0EF5, r0EF8);
                     ir_expression *const r0F16 = neg(r0EF8);
                     ir_expression *const r0F17 = bit_and(r0F16, body.constant(int(31)));
                     ir_expression *const r0F18 = rshift(r0EF6, r0F17);
                     body.emit(assign(r0F12, bit_or(r0F15, r0F18), 0x01));


                  body.instructions = f0F13_parent_instructions;
                  body.emit(f0F13);

                  /* END IF */

                  body.emit(assign(r0EF5, r0F12, 0x01));

                  body.emit(assign(r0EF6, r0F11, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0F0F->else_instructions;

                  ir_variable *const r0F19 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r0F19, body.constant(0u), 0x01));

                  ir_variable *const r0F1A = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r0F1A, neg(r0EF8), 0x01));

                  ir_variable *const r0F1B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r0F1B);
                  ir_variable *const r0F1C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r0F1C);
                  ir_variable *const r0F1D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r0F1D);
                  ir_variable *const r0F1E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r0F1F = neg(r0F1A);
                  body.emit(assign(r0F1E, bit_and(r0F1F, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0F21 = equal(r0F1A, body.constant(int(0)));
                  ir_if *f0F20 = new(mem_ctx) ir_if(operand(r0F21).val);
                  exec_list *const f0F20_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F20->then_instructions;

                     body.emit(assign(r0F1B, r0F19, 0x01));

                     body.emit(assign(r0F1C, r0EF6, 0x01));

                     body.emit(assign(r0F1D, r0EF5, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F20->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0F23 = less(r0F1A, body.constant(int(32)));
                     ir_if *f0F22 = new(mem_ctx) ir_if(operand(r0F23).val);
                     exec_list *const f0F22_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F22->then_instructions;

                        body.emit(assign(r0F1B, lshift(r0EF6, r0F1E), 0x01));

                        ir_expression *const r0F24 = lshift(r0EF5, r0F1E);
                        ir_expression *const r0F25 = rshift(r0EF6, r0F1A);
                        body.emit(assign(r0F1C, bit_or(r0F24, r0F25), 0x01));

                        body.emit(assign(r0F1D, rshift(r0EF5, r0F1A), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0F22->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0F27 = equal(r0F1A, body.constant(int(32)));
                        ir_if *f0F26 = new(mem_ctx) ir_if(operand(r0F27).val);
                        exec_list *const f0F26_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F26->then_instructions;

                           body.emit(assign(r0F1B, r0EF6, 0x01));

                           body.emit(assign(r0F1C, r0EF5, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0F26->else_instructions;

                           body.emit(assign(r0F19, bit_or(body.constant(0u), r0EF6), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0F29 = less(r0F1A, body.constant(int(64)));
                           ir_if *f0F28 = new(mem_ctx) ir_if(operand(r0F29).val);
                           exec_list *const f0F28_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0F28->then_instructions;

                              body.emit(assign(r0F1B, lshift(r0EF5, r0F1E), 0x01));

                              ir_expression *const r0F2A = bit_and(r0F1A, body.constant(int(31)));
                              body.emit(assign(r0F1C, rshift(r0EF5, r0F2A), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0F28->else_instructions;

                              ir_variable *const r0F2B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0F2D = equal(r0F1A, body.constant(int(64)));
                              ir_if *f0F2C = new(mem_ctx) ir_if(operand(r0F2D).val);
                              exec_list *const f0F2C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0F2C->then_instructions;

                                 body.emit(assign(r0F2B, r0EF5, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0F2C->else_instructions;

                                 ir_expression *const r0F2E = nequal(r0EF5, body.constant(0u));
                                 ir_expression *const r0F2F = expr(ir_unop_b2i, r0F2E);
                                 body.emit(assign(r0F2B, expr(ir_unop_i2u, r0F2F), 0x01));


                              body.instructions = f0F2C_parent_instructions;
                              body.emit(f0F2C);

                              /* END IF */

                              body.emit(assign(r0F1B, r0F2B, 0x01));

                              body.emit(assign(r0F1C, body.constant(0u), 0x01));


                           body.instructions = f0F28_parent_instructions;
                           body.emit(f0F28);

                           /* END IF */


                        body.instructions = f0F26_parent_instructions;
                        body.emit(f0F26);

                        /* END IF */

                        body.emit(assign(r0F1D, body.constant(0u), 0x01));


                     body.instructions = f0F22_parent_instructions;
                     body.emit(f0F22);

                     /* END IF */

                     ir_expression *const r0F30 = nequal(r0F19, body.constant(0u));
                     ir_expression *const r0F31 = expr(ir_unop_b2i, r0F30);
                     ir_expression *const r0F32 = expr(ir_unop_i2u, r0F31);
                     body.emit(assign(r0F1B, bit_or(r0F1B, r0F32), 0x01));


                  body.instructions = f0F20_parent_instructions;
                  body.emit(f0F20);

                  /* END IF */

                  body.emit(assign(r0EF5, r0F1D, 0x01));

                  body.emit(assign(r0EF6, r0F1C, 0x01));

                  body.emit(assign(r0EF7, r0F1B, 0x01));


               body.instructions = f0F0F_parent_instructions;
               body.emit(f0F0F);

               /* END IF */

               body.emit(assign(r0EF4, sub(r0EF4, r0EF8), 0x01));

               ir_variable *const r0F33 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r0F33, r0EF4, 0x01));

               ir_variable *const r0F34 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0F34, r0EF5, 0x01));

               ir_variable *const r0F35 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0F35, r0EF6, 0x01));

               ir_variable *const r0F36 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r0F36, r0EF7, 0x01));

               ir_variable *const r0F37 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r0F37, body.constant(true), 0x01));

               ir_variable *const r0F38 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0F39 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r0F39);
               ir_expression *const r0F3A = expr(ir_unop_u2i, r0EF7);
               body.emit(assign(r0F39, less(r0F3A, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0F3C = lequal(body.constant(int(2045)), r0EF4);
               ir_if *f0F3B = new(mem_ctx) ir_if(operand(r0F3C).val);
               exec_list *const f0F3B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F3B->then_instructions;

                  ir_variable *const r0F3D = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0F3F = less(body.constant(int(2045)), r0EF4);
                  ir_if *f0F3E = new(mem_ctx) ir_if(operand(r0F3F).val);
                  exec_list *const f0F3E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F3E->then_instructions;

                     body.emit(assign(r0F3D, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F3E->else_instructions;

                     ir_variable *const r0F40 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0F42 = equal(r0EF4, body.constant(int(2045)));
                     ir_if *f0F41 = new(mem_ctx) ir_if(operand(r0F42).val);
                     exec_list *const f0F41_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F41->then_instructions;

                        ir_expression *const r0F43 = equal(body.constant(2097151u), r0EF5);
                        ir_expression *const r0F44 = equal(body.constant(4294967295u), r0EF6);
                        body.emit(assign(r0F40, logic_and(r0F43, r0F44), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0F41->else_instructions;

                        body.emit(assign(r0F40, body.constant(false), 0x01));


                     body.instructions = f0F41_parent_instructions;
                     body.emit(f0F41);

                     /* END IF */

                     body.emit(assign(r0F3D, logic_and(r0F40, r0F39), 0x01));


                  body.instructions = f0F3E_parent_instructions;
                  body.emit(f0F3E);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0F45 = new(mem_ctx) ir_if(operand(r0F3D).val);
                  exec_list *const f0F45_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F45->then_instructions;

                     ir_variable *const r0F46 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0F46);
                     ir_expression *const r0F47 = lshift(r0DB8, body.constant(int(31)));
                     body.emit(assign(r0F46, add(r0F47, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r0F46, body.constant(0u), 0x01));

                     body.emit(assign(r0F38, r0F46, 0x03));

                     body.emit(assign(r0F37, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F45->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0F49 = less(r0EF4, body.constant(int(0)));
                     ir_if *f0F48 = new(mem_ctx) ir_if(operand(r0F49).val);
                     exec_list *const f0F48_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F48->then_instructions;

                        ir_variable *const r0F4A = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0F4A, r0EF7, 0x01));

                        ir_variable *const r0F4B = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0F4B, neg(r0EF4), 0x01));

                        ir_variable *const r0F4C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0F4C);
                        ir_variable *const r0F4D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0F4D);
                        ir_variable *const r0F4E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0F4E);
                        ir_variable *const r0F4F = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r0F50 = neg(r0F4B);
                        body.emit(assign(r0F4F, bit_and(r0F50, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0F52 = equal(r0F4B, body.constant(int(0)));
                        ir_if *f0F51 = new(mem_ctx) ir_if(operand(r0F52).val);
                        exec_list *const f0F51_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F51->then_instructions;

                           body.emit(assign(r0F4C, r0EF7, 0x01));

                           body.emit(assign(r0F4D, r0EF6, 0x01));

                           body.emit(assign(r0F4E, r0EF5, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0F51->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0F54 = less(r0F4B, body.constant(int(32)));
                           ir_if *f0F53 = new(mem_ctx) ir_if(operand(r0F54).val);
                           exec_list *const f0F53_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0F53->then_instructions;

                              body.emit(assign(r0F4C, lshift(r0EF6, r0F4F), 0x01));

                              ir_expression *const r0F55 = lshift(r0EF5, r0F4F);
                              ir_expression *const r0F56 = rshift(r0EF6, r0F4B);
                              body.emit(assign(r0F4D, bit_or(r0F55, r0F56), 0x01));

                              body.emit(assign(r0F4E, rshift(r0EF5, r0F4B), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0F53->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0F58 = equal(r0F4B, body.constant(int(32)));
                              ir_if *f0F57 = new(mem_ctx) ir_if(operand(r0F58).val);
                              exec_list *const f0F57_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0F57->then_instructions;

                                 body.emit(assign(r0F4C, r0EF6, 0x01));

                                 body.emit(assign(r0F4D, r0EF5, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0F57->else_instructions;

                                 body.emit(assign(r0F4A, bit_or(r0EF7, r0EF6), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0F5A = less(r0F4B, body.constant(int(64)));
                                 ir_if *f0F59 = new(mem_ctx) ir_if(operand(r0F5A).val);
                                 exec_list *const f0F59_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0F59->then_instructions;

                                    body.emit(assign(r0F4C, lshift(r0EF5, r0F4F), 0x01));

                                    ir_expression *const r0F5B = bit_and(r0F4B, body.constant(int(31)));
                                    body.emit(assign(r0F4D, rshift(r0EF5, r0F5B), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0F59->else_instructions;

                                    ir_variable *const r0F5C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r0F5E = equal(r0F4B, body.constant(int(64)));
                                    ir_if *f0F5D = new(mem_ctx) ir_if(operand(r0F5E).val);
                                    exec_list *const f0F5D_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0F5D->then_instructions;

                                       body.emit(assign(r0F5C, r0EF5, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0F5D->else_instructions;

                                       ir_expression *const r0F5F = nequal(r0EF5, body.constant(0u));
                                       ir_expression *const r0F60 = expr(ir_unop_b2i, r0F5F);
                                       body.emit(assign(r0F5C, expr(ir_unop_i2u, r0F60), 0x01));


                                    body.instructions = f0F5D_parent_instructions;
                                    body.emit(f0F5D);

                                    /* END IF */

                                    body.emit(assign(r0F4C, r0F5C, 0x01));

                                    body.emit(assign(r0F4D, body.constant(0u), 0x01));


                                 body.instructions = f0F59_parent_instructions;
                                 body.emit(f0F59);

                                 /* END IF */


                              body.instructions = f0F57_parent_instructions;
                              body.emit(f0F57);

                              /* END IF */

                              body.emit(assign(r0F4E, body.constant(0u), 0x01));


                           body.instructions = f0F53_parent_instructions;
                           body.emit(f0F53);

                           /* END IF */

                           ir_expression *const r0F61 = nequal(r0F4A, body.constant(0u));
                           ir_expression *const r0F62 = expr(ir_unop_b2i, r0F61);
                           ir_expression *const r0F63 = expr(ir_unop_i2u, r0F62);
                           body.emit(assign(r0F4C, bit_or(r0F4C, r0F63), 0x01));


                        body.instructions = f0F51_parent_instructions;
                        body.emit(f0F51);

                        /* END IF */

                        body.emit(assign(r0F34, r0F4E, 0x01));

                        body.emit(assign(r0F35, r0F4D, 0x01));

                        body.emit(assign(r0F36, r0F4C, 0x01));

                        body.emit(assign(r0F33, body.constant(int(0)), 0x01));

                        body.emit(assign(r0F39, less(r0F4C, body.constant(0u)), 0x01));


                     body.instructions = f0F48_parent_instructions;
                     body.emit(f0F48);

                     /* END IF */


                  body.instructions = f0F45_parent_instructions;
                  body.emit(f0F45);

                  /* END IF */


               body.instructions = f0F3B_parent_instructions;
               body.emit(f0F3B);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0F64 = new(mem_ctx) ir_if(operand(r0F37).val);
               exec_list *const f0F64_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F64->then_instructions;

                  /* IF CONDITION */
                  ir_if *f0F65 = new(mem_ctx) ir_if(operand(r0F39).val);
                  exec_list *const f0F65_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F65->then_instructions;

                     ir_variable *const r0F66 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r0F66, add(r0F35, body.constant(1u)), 0x01));

                     ir_expression *const r0F67 = less(r0F66, r0F35);
                     ir_expression *const r0F68 = expr(ir_unop_b2i, r0F67);
                     ir_expression *const r0F69 = expr(ir_unop_i2u, r0F68);
                     body.emit(assign(r0F34, add(r0F34, r0F69), 0x01));

                     ir_expression *const r0F6A = equal(r0F36, body.constant(0u));
                     ir_expression *const r0F6B = expr(ir_unop_b2i, r0F6A);
                     ir_expression *const r0F6C = expr(ir_unop_i2u, r0F6B);
                     ir_expression *const r0F6D = add(r0F36, r0F6C);
                     ir_expression *const r0F6E = bit_and(r0F6D, body.constant(1u));
                     ir_expression *const r0F6F = expr(ir_unop_bit_not, r0F6E);
                     body.emit(assign(r0F35, bit_and(r0F66, r0F6F), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F65->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0F71 = bit_or(r0F34, r0F35);
                     ir_expression *const r0F72 = equal(r0F71, body.constant(0u));
                     ir_if *f0F70 = new(mem_ctx) ir_if(operand(r0F72).val);
                     exec_list *const f0F70_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F70->then_instructions;

                        body.emit(assign(r0F33, body.constant(int(0)), 0x01));


                     body.instructions = f0F70_parent_instructions;
                     body.emit(f0F70);

                     /* END IF */


                  body.instructions = f0F65_parent_instructions;
                  body.emit(f0F65);

                  /* END IF */

                  ir_variable *const r0F73 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0F73);
                  ir_expression *const r0F74 = lshift(r0DB8, body.constant(int(31)));
                  ir_expression *const r0F75 = expr(ir_unop_i2u, r0F33);
                  ir_expression *const r0F76 = lshift(r0F75, body.constant(int(20)));
                  ir_expression *const r0F77 = add(r0F74, r0F76);
                  body.emit(assign(r0F73, add(r0F77, r0F34), 0x02));

                  body.emit(assign(r0F73, r0F35, 0x01));

                  body.emit(assign(r0F38, r0F73, 0x03));

                  body.emit(assign(r0F37, body.constant(false), 0x01));


               body.instructions = f0F64_parent_instructions;
               body.emit(f0F64);

               /* END IF */

               body.emit(assign(r0DB9, r0F38, 0x03));


            body.instructions = f0EA4_parent_instructions;
            body.emit(f0EA4);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0EA2->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0F79 = equal(r0DC1, body.constant(int(2047)));
            ir_if *f0F78 = new(mem_ctx) ir_if(operand(r0F79).val);
            exec_list *const f0F78_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0F78->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0F7B = bit_or(swizzle_y(r0DBE), swizzle_x(r0DBE));
               ir_expression *const r0F7C = bit_or(swizzle_y(r0DBC), swizzle_x(r0DBC));
               ir_expression *const r0F7D = bit_or(r0F7B, r0F7C);
               ir_expression *const r0F7E = nequal(r0F7D, body.constant(0u));
               ir_if *f0F7A = new(mem_ctx) ir_if(operand(r0F7E).val);
               exec_list *const f0F7A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F7A->then_instructions;

                  ir_variable *const r0F7F = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r0F7F, swizzle_x(r0DB1), 0x01));

                  ir_variable *const r0F80 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r0F80, swizzle_x(r0DB2), 0x01));

                  ir_variable *const r0F81 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0F82 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0F83 = rshift(swizzle_y(r0DB1), body.constant(int(19)));
                  ir_expression *const r0F84 = bit_and(r0F83, body.constant(4095u));
                  ir_expression *const r0F85 = equal(r0F84, body.constant(4094u));
                  ir_expression *const r0F86 = nequal(swizzle_x(r0DB1), body.constant(0u));
                  ir_expression *const r0F87 = bit_and(swizzle_y(r0DB1), body.constant(524287u));
                  ir_expression *const r0F88 = nequal(r0F87, body.constant(0u));
                  ir_expression *const r0F89 = logic_or(r0F86, r0F88);
                  body.emit(assign(r0F82, logic_and(r0F85, r0F89), 0x01));

                  ir_variable *const r0F8A = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0F8B = lshift(swizzle_y(r0DB2), body.constant(int(1)));
                  ir_expression *const r0F8C = lequal(body.constant(4292870144u), r0F8B);
                  ir_expression *const r0F8D = nequal(swizzle_x(r0DB2), body.constant(0u));
                  ir_expression *const r0F8E = bit_and(swizzle_y(r0DB2), body.constant(1048575u));
                  ir_expression *const r0F8F = nequal(r0F8E, body.constant(0u));
                  ir_expression *const r0F90 = logic_or(r0F8D, r0F8F);
                  body.emit(assign(r0F8A, logic_and(r0F8C, r0F90), 0x01));

                  body.emit(assign(r0F7F, bit_or(swizzle_y(r0DB1), body.constant(524288u)), 0x02));

                  body.emit(assign(r0F80, bit_or(swizzle_y(r0DB2), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r0F92 = lshift(swizzle_y(r0DB1), body.constant(int(1)));
                  ir_expression *const r0F93 = lequal(body.constant(4292870144u), r0F92);
                  ir_expression *const r0F94 = nequal(swizzle_x(r0DB1), body.constant(0u));
                  ir_expression *const r0F95 = bit_and(swizzle_y(r0DB1), body.constant(1048575u));
                  ir_expression *const r0F96 = nequal(r0F95, body.constant(0u));
                  ir_expression *const r0F97 = logic_or(r0F94, r0F96);
                  ir_expression *const r0F98 = logic_and(r0F93, r0F97);
                  ir_if *f0F91 = new(mem_ctx) ir_if(operand(r0F98).val);
                  exec_list *const f0F91_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F91->then_instructions;

                     ir_variable *const r0F99 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0F9B = logic_and(r0F82, r0F8A);
                     ir_if *f0F9A = new(mem_ctx) ir_if(operand(r0F9B).val);
                     exec_list *const f0F9A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F9A->then_instructions;

                        body.emit(assign(r0F99, r0F80, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0F9A->else_instructions;

                        body.emit(assign(r0F99, r0F7F, 0x03));


                     body.instructions = f0F9A_parent_instructions;
                     body.emit(f0F9A);

                     /* END IF */

                     body.emit(assign(r0F81, r0F99, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F91->else_instructions;

                     body.emit(assign(r0F81, r0F80, 0x03));


                  body.instructions = f0F91_parent_instructions;
                  body.emit(f0F91);

                  /* END IF */

                  body.emit(assign(r0DB9, r0F81, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0F7A->else_instructions;

                  ir_constant_data r0F9C_data;
                  memset(&r0F9C_data, 0, sizeof(ir_constant_data));
                  r0F9C_data.u[0] = 4294967295;
                  r0F9C_data.u[1] = 4294967295;
                  ir_constant *const r0F9C = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r0F9C_data);
                  body.emit(assign(r0DB9, r0F9C, 0x03));


               body.instructions = f0F7A_parent_instructions;
               body.emit(f0F7A);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0F78->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0F9E = equal(r0DC1, body.constant(int(0)));
               ir_if *f0F9D = new(mem_ctx) ir_if(operand(r0F9E).val);
               exec_list *const f0F9D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F9D->then_instructions;

                  body.emit(assign(r0DBD, body.constant(int(1)), 0x01));

                  body.emit(assign(r0DBB, body.constant(int(1)), 0x01));


               body.instructions = f0F9D_parent_instructions;
               body.emit(f0F9D);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0FA0 = less(swizzle_y(r0DBC), swizzle_y(r0DBE));
               ir_if *f0F9F = new(mem_ctx) ir_if(operand(r0FA0).val);
               exec_list *const f0F9F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F9F->then_instructions;

                  ir_variable *const r0FA1 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r0FA2 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0FA2, sub(swizzle_x(r0DBE), swizzle_x(r0DBC)), 0x01));

                  ir_expression *const r0FA3 = sub(swizzle_y(r0DBE), swizzle_y(r0DBC));
                  ir_expression *const r0FA4 = less(swizzle_x(r0DBE), swizzle_x(r0DBC));
                  ir_expression *const r0FA5 = expr(ir_unop_b2i, r0FA4);
                  ir_expression *const r0FA6 = expr(ir_unop_i2u, r0FA5);
                  body.emit(assign(r0FA1, sub(r0FA3, r0FA6), 0x01));

                  body.emit(assign(r0DBF, add(r0DBD, body.constant(int(-1))), 0x01));

                  ir_variable *const r0FA7 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r0FA7, add(r0DBF, body.constant(int(-10))), 0x01));

                  ir_variable *const r0FA8 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r0FA8, r0FA1, 0x01));

                  ir_variable *const r0FA9 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r0FA9, r0FA2, 0x01));

                  ir_variable *const r0FAA = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r0FAA);
                  ir_variable *const r0FAB = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0FAB);
                  /* IF CONDITION */
                  ir_expression *const r0FAD = equal(r0FA1, body.constant(0u));
                  ir_if *f0FAC = new(mem_ctx) ir_if(operand(r0FAD).val);
                  exec_list *const f0FAC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0FAC->then_instructions;

                     body.emit(assign(r0FA8, r0FA2, 0x01));

                     body.emit(assign(r0FA9, body.constant(0u), 0x01));

                     body.emit(assign(r0FA7, add(r0FA7, body.constant(int(-32))), 0x01));


                  body.instructions = f0FAC_parent_instructions;
                  body.emit(f0FAC);

                  /* END IF */

                  ir_variable *const r0FAE = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r0FAE, r0FA8, 0x01));

                  ir_variable *const r0FAF = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r0FB0 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0FB0);
                  /* IF CONDITION */
                  ir_expression *const r0FB2 = equal(r0FA8, body.constant(0u));
                  ir_if *f0FB1 = new(mem_ctx) ir_if(operand(r0FB2).val);
                  exec_list *const f0FB1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0FB1->then_instructions;

                     body.emit(assign(r0FAF, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0FB1->else_instructions;

                     body.emit(assign(r0FB0, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0FB4 = bit_and(r0FA8, body.constant(4294901760u));
                     ir_expression *const r0FB5 = equal(r0FB4, body.constant(0u));
                     ir_if *f0FB3 = new(mem_ctx) ir_if(operand(r0FB5).val);
                     exec_list *const f0FB3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FB3->then_instructions;

                        body.emit(assign(r0FB0, body.constant(int(16)), 0x01));

                        body.emit(assign(r0FAE, lshift(r0FA8, body.constant(int(16))), 0x01));


                     body.instructions = f0FB3_parent_instructions;
                     body.emit(f0FB3);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0FB7 = bit_and(r0FAE, body.constant(4278190080u));
                     ir_expression *const r0FB8 = equal(r0FB7, body.constant(0u));
                     ir_if *f0FB6 = new(mem_ctx) ir_if(operand(r0FB8).val);
                     exec_list *const f0FB6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FB6->then_instructions;

                        body.emit(assign(r0FB0, add(r0FB0, body.constant(int(8))), 0x01));

                        body.emit(assign(r0FAE, lshift(r0FAE, body.constant(int(8))), 0x01));


                     body.instructions = f0FB6_parent_instructions;
                     body.emit(f0FB6);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0FBA = bit_and(r0FAE, body.constant(4026531840u));
                     ir_expression *const r0FBB = equal(r0FBA, body.constant(0u));
                     ir_if *f0FB9 = new(mem_ctx) ir_if(operand(r0FBB).val);
                     exec_list *const f0FB9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FB9->then_instructions;

                        body.emit(assign(r0FB0, add(r0FB0, body.constant(int(4))), 0x01));

                        body.emit(assign(r0FAE, lshift(r0FAE, body.constant(int(4))), 0x01));


                     body.instructions = f0FB9_parent_instructions;
                     body.emit(f0FB9);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0FBD = bit_and(r0FAE, body.constant(3221225472u));
                     ir_expression *const r0FBE = equal(r0FBD, body.constant(0u));
                     ir_if *f0FBC = new(mem_ctx) ir_if(operand(r0FBE).val);
                     exec_list *const f0FBC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FBC->then_instructions;

                        body.emit(assign(r0FB0, add(r0FB0, body.constant(int(2))), 0x01));

                        body.emit(assign(r0FAE, lshift(r0FAE, body.constant(int(2))), 0x01));


                     body.instructions = f0FBC_parent_instructions;
                     body.emit(f0FBC);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0FC0 = bit_and(r0FAE, body.constant(2147483648u));
                     ir_expression *const r0FC1 = equal(r0FC0, body.constant(0u));
                     ir_if *f0FBF = new(mem_ctx) ir_if(operand(r0FC1).val);
                     exec_list *const f0FBF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FBF->then_instructions;

                        body.emit(assign(r0FB0, add(r0FB0, body.constant(int(1))), 0x01));


                     body.instructions = f0FBF_parent_instructions;
                     body.emit(f0FBF);

                     /* END IF */

                     body.emit(assign(r0FAF, r0FB0, 0x01));


                  body.instructions = f0FB1_parent_instructions;
                  body.emit(f0FB1);

                  /* END IF */

                  body.emit(assign(r0FAB, add(r0FAF, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0FC3 = lequal(body.constant(int(0)), r0FAB);
                  ir_if *f0FC2 = new(mem_ctx) ir_if(operand(r0FC3).val);
                  exec_list *const f0FC2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0FC2->then_instructions;

                     body.emit(assign(r0FAA, body.constant(0u), 0x01));

                     ir_variable *const r0FC4 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r0FC4, lshift(r0FA9, r0FAB), 0x01));

                     ir_variable *const r0FC5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0FC7 = equal(r0FAB, body.constant(int(0)));
                     ir_if *f0FC6 = new(mem_ctx) ir_if(operand(r0FC7).val);
                     exec_list *const f0FC6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FC6->then_instructions;

                        body.emit(assign(r0FC5, r0FA8, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0FC6->else_instructions;

                        ir_expression *const r0FC8 = lshift(r0FA8, r0FAB);
                        ir_expression *const r0FC9 = neg(r0FAB);
                        ir_expression *const r0FCA = bit_and(r0FC9, body.constant(int(31)));
                        ir_expression *const r0FCB = rshift(r0FA9, r0FCA);
                        body.emit(assign(r0FC5, bit_or(r0FC8, r0FCB), 0x01));


                     body.instructions = f0FC6_parent_instructions;
                     body.emit(f0FC6);

                     /* END IF */

                     body.emit(assign(r0FA8, r0FC5, 0x01));

                     body.emit(assign(r0FA9, r0FC4, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0FC2->else_instructions;

                     ir_variable *const r0FCC = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0FCC, body.constant(0u), 0x01));

                     ir_variable *const r0FCD = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0FCD, neg(r0FAB), 0x01));

                     ir_variable *const r0FCE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0FCE);
                     ir_variable *const r0FCF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0FCF);
                     ir_variable *const r0FD0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0FD0);
                     ir_variable *const r0FD1 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0FD2 = neg(r0FCD);
                     body.emit(assign(r0FD1, bit_and(r0FD2, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0FD4 = equal(r0FCD, body.constant(int(0)));
                     ir_if *f0FD3 = new(mem_ctx) ir_if(operand(r0FD4).val);
                     exec_list *const f0FD3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FD3->then_instructions;

                        body.emit(assign(r0FCE, r0FCC, 0x01));

                        body.emit(assign(r0FCF, r0FA9, 0x01));

                        body.emit(assign(r0FD0, r0FA8, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0FD3->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0FD6 = less(r0FCD, body.constant(int(32)));
                        ir_if *f0FD5 = new(mem_ctx) ir_if(operand(r0FD6).val);
                        exec_list *const f0FD5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0FD5->then_instructions;

                           body.emit(assign(r0FCE, lshift(r0FA9, r0FD1), 0x01));

                           ir_expression *const r0FD7 = lshift(r0FA8, r0FD1);
                           ir_expression *const r0FD8 = rshift(r0FA9, r0FCD);
                           body.emit(assign(r0FCF, bit_or(r0FD7, r0FD8), 0x01));

                           body.emit(assign(r0FD0, rshift(r0FA8, r0FCD), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0FD5->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0FDA = equal(r0FCD, body.constant(int(32)));
                           ir_if *f0FD9 = new(mem_ctx) ir_if(operand(r0FDA).val);
                           exec_list *const f0FD9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0FD9->then_instructions;

                              body.emit(assign(r0FCE, r0FA9, 0x01));

                              body.emit(assign(r0FCF, r0FA8, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0FD9->else_instructions;

                              body.emit(assign(r0FCC, bit_or(body.constant(0u), r0FA9), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0FDC = less(r0FCD, body.constant(int(64)));
                              ir_if *f0FDB = new(mem_ctx) ir_if(operand(r0FDC).val);
                              exec_list *const f0FDB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0FDB->then_instructions;

                                 body.emit(assign(r0FCE, lshift(r0FA8, r0FD1), 0x01));

                                 ir_expression *const r0FDD = bit_and(r0FCD, body.constant(int(31)));
                                 body.emit(assign(r0FCF, rshift(r0FA8, r0FDD), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0FDB->else_instructions;

                                 ir_variable *const r0FDE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0FE0 = equal(r0FCD, body.constant(int(64)));
                                 ir_if *f0FDF = new(mem_ctx) ir_if(operand(r0FE0).val);
                                 exec_list *const f0FDF_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0FDF->then_instructions;

                                    body.emit(assign(r0FDE, r0FA8, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0FDF->else_instructions;

                                    ir_expression *const r0FE1 = nequal(r0FA8, body.constant(0u));
                                    ir_expression *const r0FE2 = expr(ir_unop_b2i, r0FE1);
                                    body.emit(assign(r0FDE, expr(ir_unop_i2u, r0FE2), 0x01));


                                 body.instructions = f0FDF_parent_instructions;
                                 body.emit(f0FDF);

                                 /* END IF */

                                 body.emit(assign(r0FCE, r0FDE, 0x01));

                                 body.emit(assign(r0FCF, body.constant(0u), 0x01));


                              body.instructions = f0FDB_parent_instructions;
                              body.emit(f0FDB);

                              /* END IF */


                           body.instructions = f0FD9_parent_instructions;
                           body.emit(f0FD9);

                           /* END IF */

                           body.emit(assign(r0FD0, body.constant(0u), 0x01));


                        body.instructions = f0FD5_parent_instructions;
                        body.emit(f0FD5);

                        /* END IF */

                        ir_expression *const r0FE3 = nequal(r0FCC, body.constant(0u));
                        ir_expression *const r0FE4 = expr(ir_unop_b2i, r0FE3);
                        ir_expression *const r0FE5 = expr(ir_unop_i2u, r0FE4);
                        body.emit(assign(r0FCE, bit_or(r0FCE, r0FE5), 0x01));


                     body.instructions = f0FD3_parent_instructions;
                     body.emit(f0FD3);

                     /* END IF */

                     body.emit(assign(r0FA8, r0FD0, 0x01));

                     body.emit(assign(r0FA9, r0FCF, 0x01));

                     body.emit(assign(r0FAA, r0FCE, 0x01));


                  body.instructions = f0FC2_parent_instructions;
                  body.emit(f0FC2);

                  /* END IF */

                  body.emit(assign(r0FA7, sub(r0FA7, r0FAB), 0x01));

                  ir_variable *const r0FE6 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r0FE6, r0FA7, 0x01));

                  ir_variable *const r0FE7 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r0FE7, r0FA8, 0x01));

                  ir_variable *const r0FE8 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r0FE8, r0FA9, 0x01));

                  ir_variable *const r0FE9 = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r0FE9, r0FAA, 0x01));

                  ir_variable *const r0FEA = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r0FEA, body.constant(true), 0x01));

                  ir_variable *const r0FEB = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0FEC = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r0FEC);
                  ir_expression *const r0FED = expr(ir_unop_u2i, r0FAA);
                  body.emit(assign(r0FEC, less(r0FED, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0FEF = lequal(body.constant(int(2045)), r0FA7);
                  ir_if *f0FEE = new(mem_ctx) ir_if(operand(r0FEF).val);
                  exec_list *const f0FEE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0FEE->then_instructions;

                     ir_variable *const r0FF0 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0FF2 = less(body.constant(int(2045)), r0FA7);
                     ir_if *f0FF1 = new(mem_ctx) ir_if(operand(r0FF2).val);
                     exec_list *const f0FF1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FF1->then_instructions;

                        body.emit(assign(r0FF0, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0FF1->else_instructions;

                        ir_variable *const r0FF3 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0FF5 = equal(r0FA7, body.constant(int(2045)));
                        ir_if *f0FF4 = new(mem_ctx) ir_if(operand(r0FF5).val);
                        exec_list *const f0FF4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0FF4->then_instructions;

                           ir_expression *const r0FF6 = equal(body.constant(2097151u), r0FA8);
                           ir_expression *const r0FF7 = equal(body.constant(4294967295u), r0FA9);
                           body.emit(assign(r0FF3, logic_and(r0FF6, r0FF7), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0FF4->else_instructions;

                           body.emit(assign(r0FF3, body.constant(false), 0x01));


                        body.instructions = f0FF4_parent_instructions;
                        body.emit(f0FF4);

                        /* END IF */

                        body.emit(assign(r0FF0, logic_and(r0FF3, r0FEC), 0x01));


                     body.instructions = f0FF1_parent_instructions;
                     body.emit(f0FF1);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f0FF8 = new(mem_ctx) ir_if(operand(r0FF0).val);
                     exec_list *const f0FF8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FF8->then_instructions;

                        ir_variable *const r0FF9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r0FF9);
                        ir_expression *const r0FFA = lshift(r0DB8, body.constant(int(31)));
                        body.emit(assign(r0FF9, add(r0FFA, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r0FF9, body.constant(0u), 0x01));

                        body.emit(assign(r0FEB, r0FF9, 0x03));

                        body.emit(assign(r0FEA, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0FF8->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0FFC = less(r0FA7, body.constant(int(0)));
                        ir_if *f0FFB = new(mem_ctx) ir_if(operand(r0FFC).val);
                        exec_list *const f0FFB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0FFB->then_instructions;

                           ir_variable *const r0FFD = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r0FFD, r0FAA, 0x01));

                           ir_variable *const r0FFE = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r0FFE, neg(r0FA7), 0x01));

                           ir_variable *const r0FFF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r0FFF);
                           ir_variable *const r1000 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r1000);
                           ir_variable *const r1001 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r1001);
                           ir_variable *const r1002 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r1003 = neg(r0FFE);
                           body.emit(assign(r1002, bit_and(r1003, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1005 = equal(r0FFE, body.constant(int(0)));
                           ir_if *f1004 = new(mem_ctx) ir_if(operand(r1005).val);
                           exec_list *const f1004_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1004->then_instructions;

                              body.emit(assign(r0FFF, r0FAA, 0x01));

                              body.emit(assign(r1000, r0FA9, 0x01));

                              body.emit(assign(r1001, r0FA8, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1004->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1007 = less(r0FFE, body.constant(int(32)));
                              ir_if *f1006 = new(mem_ctx) ir_if(operand(r1007).val);
                              exec_list *const f1006_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1006->then_instructions;

                                 body.emit(assign(r0FFF, lshift(r0FA9, r1002), 0x01));

                                 ir_expression *const r1008 = lshift(r0FA8, r1002);
                                 ir_expression *const r1009 = rshift(r0FA9, r0FFE);
                                 body.emit(assign(r1000, bit_or(r1008, r1009), 0x01));

                                 body.emit(assign(r1001, rshift(r0FA8, r0FFE), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1006->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r100B = equal(r0FFE, body.constant(int(32)));
                                 ir_if *f100A = new(mem_ctx) ir_if(operand(r100B).val);
                                 exec_list *const f100A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f100A->then_instructions;

                                    body.emit(assign(r0FFF, r0FA9, 0x01));

                                    body.emit(assign(r1000, r0FA8, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f100A->else_instructions;

                                    body.emit(assign(r0FFD, bit_or(r0FAA, r0FA9), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r100D = less(r0FFE, body.constant(int(64)));
                                    ir_if *f100C = new(mem_ctx) ir_if(operand(r100D).val);
                                    exec_list *const f100C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f100C->then_instructions;

                                       body.emit(assign(r0FFF, lshift(r0FA8, r1002), 0x01));

                                       ir_expression *const r100E = bit_and(r0FFE, body.constant(int(31)));
                                       body.emit(assign(r1000, rshift(r0FA8, r100E), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f100C->else_instructions;

                                       ir_variable *const r100F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r1011 = equal(r0FFE, body.constant(int(64)));
                                       ir_if *f1010 = new(mem_ctx) ir_if(operand(r1011).val);
                                       exec_list *const f1010_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1010->then_instructions;

                                          body.emit(assign(r100F, r0FA8, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1010->else_instructions;

                                          ir_expression *const r1012 = nequal(r0FA8, body.constant(0u));
                                          ir_expression *const r1013 = expr(ir_unop_b2i, r1012);
                                          body.emit(assign(r100F, expr(ir_unop_i2u, r1013), 0x01));


                                       body.instructions = f1010_parent_instructions;
                                       body.emit(f1010);

                                       /* END IF */

                                       body.emit(assign(r0FFF, r100F, 0x01));

                                       body.emit(assign(r1000, body.constant(0u), 0x01));


                                    body.instructions = f100C_parent_instructions;
                                    body.emit(f100C);

                                    /* END IF */


                                 body.instructions = f100A_parent_instructions;
                                 body.emit(f100A);

                                 /* END IF */

                                 body.emit(assign(r1001, body.constant(0u), 0x01));


                              body.instructions = f1006_parent_instructions;
                              body.emit(f1006);

                              /* END IF */

                              ir_expression *const r1014 = nequal(r0FFD, body.constant(0u));
                              ir_expression *const r1015 = expr(ir_unop_b2i, r1014);
                              ir_expression *const r1016 = expr(ir_unop_i2u, r1015);
                              body.emit(assign(r0FFF, bit_or(r0FFF, r1016), 0x01));


                           body.instructions = f1004_parent_instructions;
                           body.emit(f1004);

                           /* END IF */

                           body.emit(assign(r0FE7, r1001, 0x01));

                           body.emit(assign(r0FE8, r1000, 0x01));

                           body.emit(assign(r0FE9, r0FFF, 0x01));

                           body.emit(assign(r0FE6, body.constant(int(0)), 0x01));

                           body.emit(assign(r0FEC, less(r0FFF, body.constant(0u)), 0x01));


                        body.instructions = f0FFB_parent_instructions;
                        body.emit(f0FFB);

                        /* END IF */


                     body.instructions = f0FF8_parent_instructions;
                     body.emit(f0FF8);

                     /* END IF */


                  body.instructions = f0FEE_parent_instructions;
                  body.emit(f0FEE);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f1017 = new(mem_ctx) ir_if(operand(r0FEA).val);
                  exec_list *const f1017_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1017->then_instructions;

                     /* IF CONDITION */
                     ir_if *f1018 = new(mem_ctx) ir_if(operand(r0FEC).val);
                     exec_list *const f1018_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1018->then_instructions;

                        ir_variable *const r1019 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r1019, add(r0FE8, body.constant(1u)), 0x01));

                        ir_expression *const r101A = less(r1019, r0FE8);
                        ir_expression *const r101B = expr(ir_unop_b2i, r101A);
                        ir_expression *const r101C = expr(ir_unop_i2u, r101B);
                        body.emit(assign(r0FE7, add(r0FE7, r101C), 0x01));

                        ir_expression *const r101D = equal(r0FE9, body.constant(0u));
                        ir_expression *const r101E = expr(ir_unop_b2i, r101D);
                        ir_expression *const r101F = expr(ir_unop_i2u, r101E);
                        ir_expression *const r1020 = add(r0FE9, r101F);
                        ir_expression *const r1021 = bit_and(r1020, body.constant(1u));
                        ir_expression *const r1022 = expr(ir_unop_bit_not, r1021);
                        body.emit(assign(r0FE8, bit_and(r1019, r1022), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1018->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1024 = bit_or(r0FE7, r0FE8);
                        ir_expression *const r1025 = equal(r1024, body.constant(0u));
                        ir_if *f1023 = new(mem_ctx) ir_if(operand(r1025).val);
                        exec_list *const f1023_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1023->then_instructions;

                           body.emit(assign(r0FE6, body.constant(int(0)), 0x01));


                        body.instructions = f1023_parent_instructions;
                        body.emit(f1023);

                        /* END IF */


                     body.instructions = f1018_parent_instructions;
                     body.emit(f1018);

                     /* END IF */

                     ir_variable *const r1026 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r1026);
                     ir_expression *const r1027 = lshift(r0DB8, body.constant(int(31)));
                     ir_expression *const r1028 = expr(ir_unop_i2u, r0FE6);
                     ir_expression *const r1029 = lshift(r1028, body.constant(int(20)));
                     ir_expression *const r102A = add(r1027, r1029);
                     body.emit(assign(r1026, add(r102A, r0FE7), 0x02));

                     body.emit(assign(r1026, r0FE8, 0x01));

                     body.emit(assign(r0FEB, r1026, 0x03));

                     body.emit(assign(r0FEA, body.constant(false), 0x01));


                  body.instructions = f1017_parent_instructions;
                  body.emit(f1017);

                  /* END IF */

                  body.emit(assign(r0DB9, r0FEB, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0F9F->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r102C = less(swizzle_y(r0DBE), swizzle_y(r0DBC));
                  ir_if *f102B = new(mem_ctx) ir_if(operand(r102C).val);
                  exec_list *const f102B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f102B->then_instructions;

                     ir_variable *const r102D = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r102E = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r102E, sub(swizzle_x(r0DBC), swizzle_x(r0DBE)), 0x01));

                     ir_expression *const r102F = sub(swizzle_y(r0DBC), swizzle_y(r0DBE));
                     ir_expression *const r1030 = less(swizzle_x(r0DBC), swizzle_x(r0DBE));
                     ir_expression *const r1031 = expr(ir_unop_b2i, r1030);
                     ir_expression *const r1032 = expr(ir_unop_i2u, r1031);
                     body.emit(assign(r102D, sub(r102F, r1032), 0x01));

                     body.emit(assign(r0DB8, bit_xor(r0DB8, body.constant(1u)), 0x01));

                     body.emit(assign(r0DBF, add(r0DBB, body.constant(int(-1))), 0x01));

                     ir_variable *const r1033 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r1033, add(r0DBF, body.constant(int(-10))), 0x01));

                     ir_variable *const r1034 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r1034, r102D, 0x01));

                     ir_variable *const r1035 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r1035, r102E, 0x01));

                     ir_variable *const r1036 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r1036);
                     ir_variable *const r1037 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r1037);
                     /* IF CONDITION */
                     ir_expression *const r1039 = equal(r102D, body.constant(0u));
                     ir_if *f1038 = new(mem_ctx) ir_if(operand(r1039).val);
                     exec_list *const f1038_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1038->then_instructions;

                        body.emit(assign(r1034, r102E, 0x01));

                        body.emit(assign(r1035, body.constant(0u), 0x01));

                        body.emit(assign(r1033, add(r1033, body.constant(int(-32))), 0x01));


                     body.instructions = f1038_parent_instructions;
                     body.emit(f1038);

                     /* END IF */

                     ir_variable *const r103A = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r103A, r1034, 0x01));

                     ir_variable *const r103B = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r103C = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r103C);
                     /* IF CONDITION */
                     ir_expression *const r103E = equal(r1034, body.constant(0u));
                     ir_if *f103D = new(mem_ctx) ir_if(operand(r103E).val);
                     exec_list *const f103D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f103D->then_instructions;

                        body.emit(assign(r103B, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f103D->else_instructions;

                        body.emit(assign(r103C, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1040 = bit_and(r1034, body.constant(4294901760u));
                        ir_expression *const r1041 = equal(r1040, body.constant(0u));
                        ir_if *f103F = new(mem_ctx) ir_if(operand(r1041).val);
                        exec_list *const f103F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f103F->then_instructions;

                           body.emit(assign(r103C, body.constant(int(16)), 0x01));

                           body.emit(assign(r103A, lshift(r1034, body.constant(int(16))), 0x01));


                        body.instructions = f103F_parent_instructions;
                        body.emit(f103F);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1043 = bit_and(r103A, body.constant(4278190080u));
                        ir_expression *const r1044 = equal(r1043, body.constant(0u));
                        ir_if *f1042 = new(mem_ctx) ir_if(operand(r1044).val);
                        exec_list *const f1042_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1042->then_instructions;

                           body.emit(assign(r103C, add(r103C, body.constant(int(8))), 0x01));

                           body.emit(assign(r103A, lshift(r103A, body.constant(int(8))), 0x01));


                        body.instructions = f1042_parent_instructions;
                        body.emit(f1042);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1046 = bit_and(r103A, body.constant(4026531840u));
                        ir_expression *const r1047 = equal(r1046, body.constant(0u));
                        ir_if *f1045 = new(mem_ctx) ir_if(operand(r1047).val);
                        exec_list *const f1045_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1045->then_instructions;

                           body.emit(assign(r103C, add(r103C, body.constant(int(4))), 0x01));

                           body.emit(assign(r103A, lshift(r103A, body.constant(int(4))), 0x01));


                        body.instructions = f1045_parent_instructions;
                        body.emit(f1045);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1049 = bit_and(r103A, body.constant(3221225472u));
                        ir_expression *const r104A = equal(r1049, body.constant(0u));
                        ir_if *f1048 = new(mem_ctx) ir_if(operand(r104A).val);
                        exec_list *const f1048_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1048->then_instructions;

                           body.emit(assign(r103C, add(r103C, body.constant(int(2))), 0x01));

                           body.emit(assign(r103A, lshift(r103A, body.constant(int(2))), 0x01));


                        body.instructions = f1048_parent_instructions;
                        body.emit(f1048);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r104C = bit_and(r103A, body.constant(2147483648u));
                        ir_expression *const r104D = equal(r104C, body.constant(0u));
                        ir_if *f104B = new(mem_ctx) ir_if(operand(r104D).val);
                        exec_list *const f104B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f104B->then_instructions;

                           body.emit(assign(r103C, add(r103C, body.constant(int(1))), 0x01));


                        body.instructions = f104B_parent_instructions;
                        body.emit(f104B);

                        /* END IF */

                        body.emit(assign(r103B, r103C, 0x01));


                     body.instructions = f103D_parent_instructions;
                     body.emit(f103D);

                     /* END IF */

                     body.emit(assign(r1037, add(r103B, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r104F = lequal(body.constant(int(0)), r1037);
                     ir_if *f104E = new(mem_ctx) ir_if(operand(r104F).val);
                     exec_list *const f104E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f104E->then_instructions;

                        body.emit(assign(r1036, body.constant(0u), 0x01));

                        ir_variable *const r1050 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r1050, lshift(r1035, r1037), 0x01));

                        ir_variable *const r1051 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r1053 = equal(r1037, body.constant(int(0)));
                        ir_if *f1052 = new(mem_ctx) ir_if(operand(r1053).val);
                        exec_list *const f1052_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1052->then_instructions;

                           body.emit(assign(r1051, r1034, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1052->else_instructions;

                           ir_expression *const r1054 = lshift(r1034, r1037);
                           ir_expression *const r1055 = neg(r1037);
                           ir_expression *const r1056 = bit_and(r1055, body.constant(int(31)));
                           ir_expression *const r1057 = rshift(r1035, r1056);
                           body.emit(assign(r1051, bit_or(r1054, r1057), 0x01));


                        body.instructions = f1052_parent_instructions;
                        body.emit(f1052);

                        /* END IF */

                        body.emit(assign(r1034, r1051, 0x01));

                        body.emit(assign(r1035, r1050, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f104E->else_instructions;

                        ir_variable *const r1058 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r1058, body.constant(0u), 0x01));

                        ir_variable *const r1059 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r1059, neg(r1037), 0x01));

                        ir_variable *const r105A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r105A);
                        ir_variable *const r105B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r105B);
                        ir_variable *const r105C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r105C);
                        ir_variable *const r105D = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r105E = neg(r1059);
                        body.emit(assign(r105D, bit_and(r105E, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1060 = equal(r1059, body.constant(int(0)));
                        ir_if *f105F = new(mem_ctx) ir_if(operand(r1060).val);
                        exec_list *const f105F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f105F->then_instructions;

                           body.emit(assign(r105A, r1058, 0x01));

                           body.emit(assign(r105B, r1035, 0x01));

                           body.emit(assign(r105C, r1034, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f105F->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1062 = less(r1059, body.constant(int(32)));
                           ir_if *f1061 = new(mem_ctx) ir_if(operand(r1062).val);
                           exec_list *const f1061_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1061->then_instructions;

                              body.emit(assign(r105A, lshift(r1035, r105D), 0x01));

                              ir_expression *const r1063 = lshift(r1034, r105D);
                              ir_expression *const r1064 = rshift(r1035, r1059);
                              body.emit(assign(r105B, bit_or(r1063, r1064), 0x01));

                              body.emit(assign(r105C, rshift(r1034, r1059), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1061->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1066 = equal(r1059, body.constant(int(32)));
                              ir_if *f1065 = new(mem_ctx) ir_if(operand(r1066).val);
                              exec_list *const f1065_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1065->then_instructions;

                                 body.emit(assign(r105A, r1035, 0x01));

                                 body.emit(assign(r105B, r1034, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1065->else_instructions;

                                 body.emit(assign(r1058, bit_or(body.constant(0u), r1035), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1068 = less(r1059, body.constant(int(64)));
                                 ir_if *f1067 = new(mem_ctx) ir_if(operand(r1068).val);
                                 exec_list *const f1067_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1067->then_instructions;

                                    body.emit(assign(r105A, lshift(r1034, r105D), 0x01));

                                    ir_expression *const r1069 = bit_and(r1059, body.constant(int(31)));
                                    body.emit(assign(r105B, rshift(r1034, r1069), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1067->else_instructions;

                                    ir_variable *const r106A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r106C = equal(r1059, body.constant(int(64)));
                                    ir_if *f106B = new(mem_ctx) ir_if(operand(r106C).val);
                                    exec_list *const f106B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f106B->then_instructions;

                                       body.emit(assign(r106A, r1034, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f106B->else_instructions;

                                       ir_expression *const r106D = nequal(r1034, body.constant(0u));
                                       ir_expression *const r106E = expr(ir_unop_b2i, r106D);
                                       body.emit(assign(r106A, expr(ir_unop_i2u, r106E), 0x01));


                                    body.instructions = f106B_parent_instructions;
                                    body.emit(f106B);

                                    /* END IF */

                                    body.emit(assign(r105A, r106A, 0x01));

                                    body.emit(assign(r105B, body.constant(0u), 0x01));


                                 body.instructions = f1067_parent_instructions;
                                 body.emit(f1067);

                                 /* END IF */


                              body.instructions = f1065_parent_instructions;
                              body.emit(f1065);

                              /* END IF */

                              body.emit(assign(r105C, body.constant(0u), 0x01));


                           body.instructions = f1061_parent_instructions;
                           body.emit(f1061);

                           /* END IF */

                           ir_expression *const r106F = nequal(r1058, body.constant(0u));
                           ir_expression *const r1070 = expr(ir_unop_b2i, r106F);
                           ir_expression *const r1071 = expr(ir_unop_i2u, r1070);
                           body.emit(assign(r105A, bit_or(r105A, r1071), 0x01));


                        body.instructions = f105F_parent_instructions;
                        body.emit(f105F);

                        /* END IF */

                        body.emit(assign(r1034, r105C, 0x01));

                        body.emit(assign(r1035, r105B, 0x01));

                        body.emit(assign(r1036, r105A, 0x01));


                     body.instructions = f104E_parent_instructions;
                     body.emit(f104E);

                     /* END IF */

                     body.emit(assign(r1033, sub(r1033, r1037), 0x01));

                     ir_variable *const r1072 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r1072, r1033, 0x01));

                     ir_variable *const r1073 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r1073, r1034, 0x01));

                     ir_variable *const r1074 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r1074, r1035, 0x01));

                     ir_variable *const r1075 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r1075, r1036, 0x01));

                     ir_variable *const r1076 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r1076, body.constant(true), 0x01));

                     ir_variable *const r1077 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r1078 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r1078);
                     ir_expression *const r1079 = expr(ir_unop_u2i, r1036);
                     body.emit(assign(r1078, less(r1079, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r107B = lequal(body.constant(int(2045)), r1033);
                     ir_if *f107A = new(mem_ctx) ir_if(operand(r107B).val);
                     exec_list *const f107A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f107A->then_instructions;

                        ir_variable *const r107C = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r107E = less(body.constant(int(2045)), r1033);
                        ir_if *f107D = new(mem_ctx) ir_if(operand(r107E).val);
                        exec_list *const f107D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f107D->then_instructions;

                           body.emit(assign(r107C, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f107D->else_instructions;

                           ir_variable *const r107F = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r1081 = equal(r1033, body.constant(int(2045)));
                           ir_if *f1080 = new(mem_ctx) ir_if(operand(r1081).val);
                           exec_list *const f1080_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1080->then_instructions;

                              ir_expression *const r1082 = equal(body.constant(2097151u), r1034);
                              ir_expression *const r1083 = equal(body.constant(4294967295u), r1035);
                              body.emit(assign(r107F, logic_and(r1082, r1083), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1080->else_instructions;

                              body.emit(assign(r107F, body.constant(false), 0x01));


                           body.instructions = f1080_parent_instructions;
                           body.emit(f1080);

                           /* END IF */

                           body.emit(assign(r107C, logic_and(r107F, r1078), 0x01));


                        body.instructions = f107D_parent_instructions;
                        body.emit(f107D);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f1084 = new(mem_ctx) ir_if(operand(r107C).val);
                        exec_list *const f1084_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1084->then_instructions;

                           ir_variable *const r1085 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r1085);
                           ir_expression *const r1086 = lshift(r0DB8, body.constant(int(31)));
                           body.emit(assign(r1085, add(r1086, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r1085, body.constant(0u), 0x01));

                           body.emit(assign(r1077, r1085, 0x03));

                           body.emit(assign(r1076, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1084->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1088 = less(r1033, body.constant(int(0)));
                           ir_if *f1087 = new(mem_ctx) ir_if(operand(r1088).val);
                           exec_list *const f1087_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1087->then_instructions;

                              ir_variable *const r1089 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r1089, r1036, 0x01));

                              ir_variable *const r108A = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r108A, neg(r1033), 0x01));

                              ir_variable *const r108B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r108B);
                              ir_variable *const r108C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r108C);
                              ir_variable *const r108D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r108D);
                              ir_variable *const r108E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r108F = neg(r108A);
                              body.emit(assign(r108E, bit_and(r108F, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1091 = equal(r108A, body.constant(int(0)));
                              ir_if *f1090 = new(mem_ctx) ir_if(operand(r1091).val);
                              exec_list *const f1090_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1090->then_instructions;

                                 body.emit(assign(r108B, r1036, 0x01));

                                 body.emit(assign(r108C, r1035, 0x01));

                                 body.emit(assign(r108D, r1034, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1090->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r1093 = less(r108A, body.constant(int(32)));
                                 ir_if *f1092 = new(mem_ctx) ir_if(operand(r1093).val);
                                 exec_list *const f1092_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1092->then_instructions;

                                    body.emit(assign(r108B, lshift(r1035, r108E), 0x01));

                                    ir_expression *const r1094 = lshift(r1034, r108E);
                                    ir_expression *const r1095 = rshift(r1035, r108A);
                                    body.emit(assign(r108C, bit_or(r1094, r1095), 0x01));

                                    body.emit(assign(r108D, rshift(r1034, r108A), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1092->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r1097 = equal(r108A, body.constant(int(32)));
                                    ir_if *f1096 = new(mem_ctx) ir_if(operand(r1097).val);
                                    exec_list *const f1096_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1096->then_instructions;

                                       body.emit(assign(r108B, r1035, 0x01));

                                       body.emit(assign(r108C, r1034, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1096->else_instructions;

                                       body.emit(assign(r1089, bit_or(r1036, r1035), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r1099 = less(r108A, body.constant(int(64)));
                                       ir_if *f1098 = new(mem_ctx) ir_if(operand(r1099).val);
                                       exec_list *const f1098_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1098->then_instructions;

                                          body.emit(assign(r108B, lshift(r1034, r108E), 0x01));

                                          ir_expression *const r109A = bit_and(r108A, body.constant(int(31)));
                                          body.emit(assign(r108C, rshift(r1034, r109A), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1098->else_instructions;

                                          ir_variable *const r109B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r109D = equal(r108A, body.constant(int(64)));
                                          ir_if *f109C = new(mem_ctx) ir_if(operand(r109D).val);
                                          exec_list *const f109C_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f109C->then_instructions;

                                             body.emit(assign(r109B, r1034, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f109C->else_instructions;

                                             ir_expression *const r109E = nequal(r1034, body.constant(0u));
                                             ir_expression *const r109F = expr(ir_unop_b2i, r109E);
                                             body.emit(assign(r109B, expr(ir_unop_i2u, r109F), 0x01));


                                          body.instructions = f109C_parent_instructions;
                                          body.emit(f109C);

                                          /* END IF */

                                          body.emit(assign(r108B, r109B, 0x01));

                                          body.emit(assign(r108C, body.constant(0u), 0x01));


                                       body.instructions = f1098_parent_instructions;
                                       body.emit(f1098);

                                       /* END IF */


                                    body.instructions = f1096_parent_instructions;
                                    body.emit(f1096);

                                    /* END IF */

                                    body.emit(assign(r108D, body.constant(0u), 0x01));


                                 body.instructions = f1092_parent_instructions;
                                 body.emit(f1092);

                                 /* END IF */

                                 ir_expression *const r10A0 = nequal(r1089, body.constant(0u));
                                 ir_expression *const r10A1 = expr(ir_unop_b2i, r10A0);
                                 ir_expression *const r10A2 = expr(ir_unop_i2u, r10A1);
                                 body.emit(assign(r108B, bit_or(r108B, r10A2), 0x01));


                              body.instructions = f1090_parent_instructions;
                              body.emit(f1090);

                              /* END IF */

                              body.emit(assign(r1073, r108D, 0x01));

                              body.emit(assign(r1074, r108C, 0x01));

                              body.emit(assign(r1075, r108B, 0x01));

                              body.emit(assign(r1072, body.constant(int(0)), 0x01));

                              body.emit(assign(r1078, less(r108B, body.constant(0u)), 0x01));


                           body.instructions = f1087_parent_instructions;
                           body.emit(f1087);

                           /* END IF */


                        body.instructions = f1084_parent_instructions;
                        body.emit(f1084);

                        /* END IF */


                     body.instructions = f107A_parent_instructions;
                     body.emit(f107A);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f10A3 = new(mem_ctx) ir_if(operand(r1076).val);
                     exec_list *const f10A3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f10A3->then_instructions;

                        /* IF CONDITION */
                        ir_if *f10A4 = new(mem_ctx) ir_if(operand(r1078).val);
                        exec_list *const f10A4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f10A4->then_instructions;

                           ir_variable *const r10A5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r10A5, add(r1074, body.constant(1u)), 0x01));

                           ir_expression *const r10A6 = less(r10A5, r1074);
                           ir_expression *const r10A7 = expr(ir_unop_b2i, r10A6);
                           ir_expression *const r10A8 = expr(ir_unop_i2u, r10A7);
                           body.emit(assign(r1073, add(r1073, r10A8), 0x01));

                           ir_expression *const r10A9 = equal(r1075, body.constant(0u));
                           ir_expression *const r10AA = expr(ir_unop_b2i, r10A9);
                           ir_expression *const r10AB = expr(ir_unop_i2u, r10AA);
                           ir_expression *const r10AC = add(r1075, r10AB);
                           ir_expression *const r10AD = bit_and(r10AC, body.constant(1u));
                           ir_expression *const r10AE = expr(ir_unop_bit_not, r10AD);
                           body.emit(assign(r1074, bit_and(r10A5, r10AE), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f10A4->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r10B0 = bit_or(r1073, r1074);
                           ir_expression *const r10B1 = equal(r10B0, body.constant(0u));
                           ir_if *f10AF = new(mem_ctx) ir_if(operand(r10B1).val);
                           exec_list *const f10AF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10AF->then_instructions;

                              body.emit(assign(r1072, body.constant(int(0)), 0x01));


                           body.instructions = f10AF_parent_instructions;
                           body.emit(f10AF);

                           /* END IF */


                        body.instructions = f10A4_parent_instructions;
                        body.emit(f10A4);

                        /* END IF */

                        ir_variable *const r10B2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r10B2);
                        ir_expression *const r10B3 = lshift(r0DB8, body.constant(int(31)));
                        ir_expression *const r10B4 = expr(ir_unop_i2u, r1072);
                        ir_expression *const r10B5 = lshift(r10B4, body.constant(int(20)));
                        ir_expression *const r10B6 = add(r10B3, r10B5);
                        body.emit(assign(r10B2, add(r10B6, r1073), 0x02));

                        body.emit(assign(r10B2, r1074, 0x01));

                        body.emit(assign(r1077, r10B2, 0x03));

                        body.emit(assign(r1076, body.constant(false), 0x01));


                     body.instructions = f10A3_parent_instructions;
                     body.emit(f10A3);

                     /* END IF */

                     body.emit(assign(r0DB9, r1077, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f102B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r10B8 = less(swizzle_x(r0DBC), swizzle_x(r0DBE));
                     ir_if *f10B7 = new(mem_ctx) ir_if(operand(r10B8).val);
                     exec_list *const f10B7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f10B7->then_instructions;

                        ir_variable *const r10B9 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r10BA = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r10BA, sub(swizzle_x(r0DBE), swizzle_x(r0DBC)), 0x01));

                        ir_expression *const r10BB = sub(swizzle_y(r0DBE), swizzle_y(r0DBC));
                        ir_expression *const r10BC = less(swizzle_x(r0DBE), swizzle_x(r0DBC));
                        ir_expression *const r10BD = expr(ir_unop_b2i, r10BC);
                        ir_expression *const r10BE = expr(ir_unop_i2u, r10BD);
                        body.emit(assign(r10B9, sub(r10BB, r10BE), 0x01));

                        body.emit(assign(r0DBF, add(r0DBD, body.constant(int(-1))), 0x01));

                        ir_variable *const r10BF = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r10BF, add(r0DBF, body.constant(int(-10))), 0x01));

                        ir_variable *const r10C0 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r10C0, r10B9, 0x01));

                        ir_variable *const r10C1 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r10C1, r10BA, 0x01));

                        ir_variable *const r10C2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r10C2);
                        ir_variable *const r10C3 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r10C3);
                        /* IF CONDITION */
                        ir_expression *const r10C5 = equal(r10B9, body.constant(0u));
                        ir_if *f10C4 = new(mem_ctx) ir_if(operand(r10C5).val);
                        exec_list *const f10C4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f10C4->then_instructions;

                           body.emit(assign(r10C0, r10BA, 0x01));

                           body.emit(assign(r10C1, body.constant(0u), 0x01));

                           body.emit(assign(r10BF, add(r10BF, body.constant(int(-32))), 0x01));


                        body.instructions = f10C4_parent_instructions;
                        body.emit(f10C4);

                        /* END IF */

                        ir_variable *const r10C6 = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r10C6, r10C0, 0x01));

                        ir_variable *const r10C7 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r10C8 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r10C8);
                        /* IF CONDITION */
                        ir_expression *const r10CA = equal(r10C0, body.constant(0u));
                        ir_if *f10C9 = new(mem_ctx) ir_if(operand(r10CA).val);
                        exec_list *const f10C9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f10C9->then_instructions;

                           body.emit(assign(r10C7, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f10C9->else_instructions;

                           body.emit(assign(r10C8, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r10CC = bit_and(r10C0, body.constant(4294901760u));
                           ir_expression *const r10CD = equal(r10CC, body.constant(0u));
                           ir_if *f10CB = new(mem_ctx) ir_if(operand(r10CD).val);
                           exec_list *const f10CB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10CB->then_instructions;

                              body.emit(assign(r10C8, body.constant(int(16)), 0x01));

                              body.emit(assign(r10C6, lshift(r10C0, body.constant(int(16))), 0x01));


                           body.instructions = f10CB_parent_instructions;
                           body.emit(f10CB);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r10CF = bit_and(r10C6, body.constant(4278190080u));
                           ir_expression *const r10D0 = equal(r10CF, body.constant(0u));
                           ir_if *f10CE = new(mem_ctx) ir_if(operand(r10D0).val);
                           exec_list *const f10CE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10CE->then_instructions;

                              body.emit(assign(r10C8, add(r10C8, body.constant(int(8))), 0x01));

                              body.emit(assign(r10C6, lshift(r10C6, body.constant(int(8))), 0x01));


                           body.instructions = f10CE_parent_instructions;
                           body.emit(f10CE);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r10D2 = bit_and(r10C6, body.constant(4026531840u));
                           ir_expression *const r10D3 = equal(r10D2, body.constant(0u));
                           ir_if *f10D1 = new(mem_ctx) ir_if(operand(r10D3).val);
                           exec_list *const f10D1_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10D1->then_instructions;

                              body.emit(assign(r10C8, add(r10C8, body.constant(int(4))), 0x01));

                              body.emit(assign(r10C6, lshift(r10C6, body.constant(int(4))), 0x01));


                           body.instructions = f10D1_parent_instructions;
                           body.emit(f10D1);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r10D5 = bit_and(r10C6, body.constant(3221225472u));
                           ir_expression *const r10D6 = equal(r10D5, body.constant(0u));
                           ir_if *f10D4 = new(mem_ctx) ir_if(operand(r10D6).val);
                           exec_list *const f10D4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10D4->then_instructions;

                              body.emit(assign(r10C8, add(r10C8, body.constant(int(2))), 0x01));

                              body.emit(assign(r10C6, lshift(r10C6, body.constant(int(2))), 0x01));


                           body.instructions = f10D4_parent_instructions;
                           body.emit(f10D4);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r10D8 = bit_and(r10C6, body.constant(2147483648u));
                           ir_expression *const r10D9 = equal(r10D8, body.constant(0u));
                           ir_if *f10D7 = new(mem_ctx) ir_if(operand(r10D9).val);
                           exec_list *const f10D7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10D7->then_instructions;

                              body.emit(assign(r10C8, add(r10C8, body.constant(int(1))), 0x01));


                           body.instructions = f10D7_parent_instructions;
                           body.emit(f10D7);

                           /* END IF */

                           body.emit(assign(r10C7, r10C8, 0x01));


                        body.instructions = f10C9_parent_instructions;
                        body.emit(f10C9);

                        /* END IF */

                        body.emit(assign(r10C3, add(r10C7, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r10DB = lequal(body.constant(int(0)), r10C3);
                        ir_if *f10DA = new(mem_ctx) ir_if(operand(r10DB).val);
                        exec_list *const f10DA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f10DA->then_instructions;

                           body.emit(assign(r10C2, body.constant(0u), 0x01));

                           ir_variable *const r10DC = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r10DC, lshift(r10C1, r10C3), 0x01));

                           ir_variable *const r10DD = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r10DF = equal(r10C3, body.constant(int(0)));
                           ir_if *f10DE = new(mem_ctx) ir_if(operand(r10DF).val);
                           exec_list *const f10DE_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10DE->then_instructions;

                              body.emit(assign(r10DD, r10C0, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f10DE->else_instructions;

                              ir_expression *const r10E0 = lshift(r10C0, r10C3);
                              ir_expression *const r10E1 = neg(r10C3);
                              ir_expression *const r10E2 = bit_and(r10E1, body.constant(int(31)));
                              ir_expression *const r10E3 = rshift(r10C1, r10E2);
                              body.emit(assign(r10DD, bit_or(r10E0, r10E3), 0x01));


                           body.instructions = f10DE_parent_instructions;
                           body.emit(f10DE);

                           /* END IF */

                           body.emit(assign(r10C0, r10DD, 0x01));

                           body.emit(assign(r10C1, r10DC, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f10DA->else_instructions;

                           ir_variable *const r10E4 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r10E4, body.constant(0u), 0x01));

                           ir_variable *const r10E5 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r10E5, neg(r10C3), 0x01));

                           ir_variable *const r10E6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r10E6);
                           ir_variable *const r10E7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r10E7);
                           ir_variable *const r10E8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r10E8);
                           ir_variable *const r10E9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r10EA = neg(r10E5);
                           body.emit(assign(r10E9, bit_and(r10EA, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r10EC = equal(r10E5, body.constant(int(0)));
                           ir_if *f10EB = new(mem_ctx) ir_if(operand(r10EC).val);
                           exec_list *const f10EB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f10EB->then_instructions;

                              body.emit(assign(r10E6, r10E4, 0x01));

                              body.emit(assign(r10E7, r10C1, 0x01));

                              body.emit(assign(r10E8, r10C0, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f10EB->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r10EE = less(r10E5, body.constant(int(32)));
                              ir_if *f10ED = new(mem_ctx) ir_if(operand(r10EE).val);
                              exec_list *const f10ED_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f10ED->then_instructions;

                                 body.emit(assign(r10E6, lshift(r10C1, r10E9), 0x01));

                                 ir_expression *const r10EF = lshift(r10C0, r10E9);
                                 ir_expression *const r10F0 = rshift(r10C1, r10E5);
                                 body.emit(assign(r10E7, bit_or(r10EF, r10F0), 0x01));

                                 body.emit(assign(r10E8, rshift(r10C0, r10E5), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f10ED->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r10F2 = equal(r10E5, body.constant(int(32)));
                                 ir_if *f10F1 = new(mem_ctx) ir_if(operand(r10F2).val);
                                 exec_list *const f10F1_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f10F1->then_instructions;

                                    body.emit(assign(r10E6, r10C1, 0x01));

                                    body.emit(assign(r10E7, r10C0, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f10F1->else_instructions;

                                    body.emit(assign(r10E4, bit_or(body.constant(0u), r10C1), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r10F4 = less(r10E5, body.constant(int(64)));
                                    ir_if *f10F3 = new(mem_ctx) ir_if(operand(r10F4).val);
                                    exec_list *const f10F3_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f10F3->then_instructions;

                                       body.emit(assign(r10E6, lshift(r10C0, r10E9), 0x01));

                                       ir_expression *const r10F5 = bit_and(r10E5, body.constant(int(31)));
                                       body.emit(assign(r10E7, rshift(r10C0, r10F5), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f10F3->else_instructions;

                                       ir_variable *const r10F6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r10F8 = equal(r10E5, body.constant(int(64)));
                                       ir_if *f10F7 = new(mem_ctx) ir_if(operand(r10F8).val);
                                       exec_list *const f10F7_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f10F7->then_instructions;

                                          body.emit(assign(r10F6, r10C0, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f10F7->else_instructions;

                                          ir_expression *const r10F9 = nequal(r10C0, body.constant(0u));
                                          ir_expression *const r10FA = expr(ir_unop_b2i, r10F9);
                                          body.emit(assign(r10F6, expr(ir_unop_i2u, r10FA), 0x01));


                                       body.instructions = f10F7_parent_instructions;
                                       body.emit(f10F7);

                                       /* END IF */

                                       body.emit(assign(r10E6, r10F6, 0x01));

                                       body.emit(assign(r10E7, body.constant(0u), 0x01));


                                    body.instructions = f10F3_parent_instructions;
                                    body.emit(f10F3);

                                    /* END IF */


                                 body.instructions = f10F1_parent_instructions;
                                 body.emit(f10F1);

                                 /* END IF */

                                 body.emit(assign(r10E8, body.constant(0u), 0x01));


                              body.instructions = f10ED_parent_instructions;
                              body.emit(f10ED);

                              /* END IF */

                              ir_expression *const r10FB = nequal(r10E4, body.constant(0u));
                              ir_expression *const r10FC = expr(ir_unop_b2i, r10FB);
                              ir_expression *const r10FD = expr(ir_unop_i2u, r10FC);
                              body.emit(assign(r10E6, bit_or(r10E6, r10FD), 0x01));


                           body.instructions = f10EB_parent_instructions;
                           body.emit(f10EB);

                           /* END IF */

                           body.emit(assign(r10C0, r10E8, 0x01));

                           body.emit(assign(r10C1, r10E7, 0x01));

                           body.emit(assign(r10C2, r10E6, 0x01));


                        body.instructions = f10DA_parent_instructions;
                        body.emit(f10DA);

                        /* END IF */

                        body.emit(assign(r10BF, sub(r10BF, r10C3), 0x01));

                        ir_variable *const r10FE = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r10FE, r10BF, 0x01));

                        ir_variable *const r10FF = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r10FF, r10C0, 0x01));

                        ir_variable *const r1100 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r1100, r10C1, 0x01));

                        ir_variable *const r1101 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r1101, r10C2, 0x01));

                        ir_variable *const r1102 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r1102, body.constant(true), 0x01));

                        ir_variable *const r1103 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r1104 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r1104);
                        ir_expression *const r1105 = expr(ir_unop_u2i, r10C2);
                        body.emit(assign(r1104, less(r1105, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1107 = lequal(body.constant(int(2045)), r10BF);
                        ir_if *f1106 = new(mem_ctx) ir_if(operand(r1107).val);
                        exec_list *const f1106_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1106->then_instructions;

                           ir_variable *const r1108 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r110A = less(body.constant(int(2045)), r10BF);
                           ir_if *f1109 = new(mem_ctx) ir_if(operand(r110A).val);
                           exec_list *const f1109_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1109->then_instructions;

                              body.emit(assign(r1108, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1109->else_instructions;

                              ir_variable *const r110B = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r110D = equal(r10BF, body.constant(int(2045)));
                              ir_if *f110C = new(mem_ctx) ir_if(operand(r110D).val);
                              exec_list *const f110C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f110C->then_instructions;

                                 ir_expression *const r110E = equal(body.constant(2097151u), r10C0);
                                 ir_expression *const r110F = equal(body.constant(4294967295u), r10C1);
                                 body.emit(assign(r110B, logic_and(r110E, r110F), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f110C->else_instructions;

                                 body.emit(assign(r110B, body.constant(false), 0x01));


                              body.instructions = f110C_parent_instructions;
                              body.emit(f110C);

                              /* END IF */

                              body.emit(assign(r1108, logic_and(r110B, r1104), 0x01));


                           body.instructions = f1109_parent_instructions;
                           body.emit(f1109);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f1110 = new(mem_ctx) ir_if(operand(r1108).val);
                           exec_list *const f1110_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1110->then_instructions;

                              ir_variable *const r1111 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r1111);
                              ir_expression *const r1112 = lshift(r0DB8, body.constant(int(31)));
                              body.emit(assign(r1111, add(r1112, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r1111, body.constant(0u), 0x01));

                              body.emit(assign(r1103, r1111, 0x03));

                              body.emit(assign(r1102, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1110->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1114 = less(r10BF, body.constant(int(0)));
                              ir_if *f1113 = new(mem_ctx) ir_if(operand(r1114).val);
                              exec_list *const f1113_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1113->then_instructions;

                                 ir_variable *const r1115 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r1115, r10C2, 0x01));

                                 ir_variable *const r1116 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r1116, neg(r10BF), 0x01));

                                 ir_variable *const r1117 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r1117);
                                 ir_variable *const r1118 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r1118);
                                 ir_variable *const r1119 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r1119);
                                 ir_variable *const r111A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r111B = neg(r1116);
                                 body.emit(assign(r111A, bit_and(r111B, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r111D = equal(r1116, body.constant(int(0)));
                                 ir_if *f111C = new(mem_ctx) ir_if(operand(r111D).val);
                                 exec_list *const f111C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f111C->then_instructions;

                                    body.emit(assign(r1117, r10C2, 0x01));

                                    body.emit(assign(r1118, r10C1, 0x01));

                                    body.emit(assign(r1119, r10C0, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f111C->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r111F = less(r1116, body.constant(int(32)));
                                    ir_if *f111E = new(mem_ctx) ir_if(operand(r111F).val);
                                    exec_list *const f111E_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f111E->then_instructions;

                                       body.emit(assign(r1117, lshift(r10C1, r111A), 0x01));

                                       ir_expression *const r1120 = lshift(r10C0, r111A);
                                       ir_expression *const r1121 = rshift(r10C1, r1116);
                                       body.emit(assign(r1118, bit_or(r1120, r1121), 0x01));

                                       body.emit(assign(r1119, rshift(r10C0, r1116), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f111E->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r1123 = equal(r1116, body.constant(int(32)));
                                       ir_if *f1122 = new(mem_ctx) ir_if(operand(r1123).val);
                                       exec_list *const f1122_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f1122->then_instructions;

                                          body.emit(assign(r1117, r10C1, 0x01));

                                          body.emit(assign(r1118, r10C0, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f1122->else_instructions;

                                          body.emit(assign(r1115, bit_or(r10C2, r10C1), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r1125 = less(r1116, body.constant(int(64)));
                                          ir_if *f1124 = new(mem_ctx) ir_if(operand(r1125).val);
                                          exec_list *const f1124_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1124->then_instructions;

                                             body.emit(assign(r1117, lshift(r10C0, r111A), 0x01));

                                             ir_expression *const r1126 = bit_and(r1116, body.constant(int(31)));
                                             body.emit(assign(r1118, rshift(r10C0, r1126), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1124->else_instructions;

                                             ir_variable *const r1127 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r1129 = equal(r1116, body.constant(int(64)));
                                             ir_if *f1128 = new(mem_ctx) ir_if(operand(r1129).val);
                                             exec_list *const f1128_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f1128->then_instructions;

                                                body.emit(assign(r1127, r10C0, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f1128->else_instructions;

                                                ir_expression *const r112A = nequal(r10C0, body.constant(0u));
                                                ir_expression *const r112B = expr(ir_unop_b2i, r112A);
                                                body.emit(assign(r1127, expr(ir_unop_i2u, r112B), 0x01));


                                             body.instructions = f1128_parent_instructions;
                                             body.emit(f1128);

                                             /* END IF */

                                             body.emit(assign(r1117, r1127, 0x01));

                                             body.emit(assign(r1118, body.constant(0u), 0x01));


                                          body.instructions = f1124_parent_instructions;
                                          body.emit(f1124);

                                          /* END IF */


                                       body.instructions = f1122_parent_instructions;
                                       body.emit(f1122);

                                       /* END IF */

                                       body.emit(assign(r1119, body.constant(0u), 0x01));


                                    body.instructions = f111E_parent_instructions;
                                    body.emit(f111E);

                                    /* END IF */

                                    ir_expression *const r112C = nequal(r1115, body.constant(0u));
                                    ir_expression *const r112D = expr(ir_unop_b2i, r112C);
                                    ir_expression *const r112E = expr(ir_unop_i2u, r112D);
                                    body.emit(assign(r1117, bit_or(r1117, r112E), 0x01));


                                 body.instructions = f111C_parent_instructions;
                                 body.emit(f111C);

                                 /* END IF */

                                 body.emit(assign(r10FF, r1119, 0x01));

                                 body.emit(assign(r1100, r1118, 0x01));

                                 body.emit(assign(r1101, r1117, 0x01));

                                 body.emit(assign(r10FE, body.constant(int(0)), 0x01));

                                 body.emit(assign(r1104, less(r1117, body.constant(0u)), 0x01));


                              body.instructions = f1113_parent_instructions;
                              body.emit(f1113);

                              /* END IF */


                           body.instructions = f1110_parent_instructions;
                           body.emit(f1110);

                           /* END IF */


                        body.instructions = f1106_parent_instructions;
                        body.emit(f1106);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f112F = new(mem_ctx) ir_if(operand(r1102).val);
                        exec_list *const f112F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f112F->then_instructions;

                           /* IF CONDITION */
                           ir_if *f1130 = new(mem_ctx) ir_if(operand(r1104).val);
                           exec_list *const f1130_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1130->then_instructions;

                              ir_variable *const r1131 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r1131, add(r1100, body.constant(1u)), 0x01));

                              ir_expression *const r1132 = less(r1131, r1100);
                              ir_expression *const r1133 = expr(ir_unop_b2i, r1132);
                              ir_expression *const r1134 = expr(ir_unop_i2u, r1133);
                              body.emit(assign(r10FF, add(r10FF, r1134), 0x01));

                              ir_expression *const r1135 = equal(r1101, body.constant(0u));
                              ir_expression *const r1136 = expr(ir_unop_b2i, r1135);
                              ir_expression *const r1137 = expr(ir_unop_i2u, r1136);
                              ir_expression *const r1138 = add(r1101, r1137);
                              ir_expression *const r1139 = bit_and(r1138, body.constant(1u));
                              ir_expression *const r113A = expr(ir_unop_bit_not, r1139);
                              body.emit(assign(r1100, bit_and(r1131, r113A), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1130->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r113C = bit_or(r10FF, r1100);
                              ir_expression *const r113D = equal(r113C, body.constant(0u));
                              ir_if *f113B = new(mem_ctx) ir_if(operand(r113D).val);
                              exec_list *const f113B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f113B->then_instructions;

                                 body.emit(assign(r10FE, body.constant(int(0)), 0x01));


                              body.instructions = f113B_parent_instructions;
                              body.emit(f113B);

                              /* END IF */


                           body.instructions = f1130_parent_instructions;
                           body.emit(f1130);

                           /* END IF */

                           ir_variable *const r113E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r113E);
                           ir_expression *const r113F = lshift(r0DB8, body.constant(int(31)));
                           ir_expression *const r1140 = expr(ir_unop_i2u, r10FE);
                           ir_expression *const r1141 = lshift(r1140, body.constant(int(20)));
                           ir_expression *const r1142 = add(r113F, r1141);
                           body.emit(assign(r113E, add(r1142, r10FF), 0x02));

                           body.emit(assign(r113E, r1100, 0x01));

                           body.emit(assign(r1103, r113E, 0x03));

                           body.emit(assign(r1102, body.constant(false), 0x01));


                        body.instructions = f112F_parent_instructions;
                        body.emit(f112F);

                        /* END IF */

                        body.emit(assign(r0DB9, r1103, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f10B7->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1144 = less(swizzle_x(r0DBE), swizzle_x(r0DBC));
                        ir_if *f1143 = new(mem_ctx) ir_if(operand(r1144).val);
                        exec_list *const f1143_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1143->then_instructions;

                           ir_variable *const r1145 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r1146 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r1146, sub(swizzle_x(r0DBC), swizzle_x(r0DBE)), 0x01));

                           ir_expression *const r1147 = sub(swizzle_y(r0DBC), swizzle_y(r0DBE));
                           ir_expression *const r1148 = less(swizzle_x(r0DBC), swizzle_x(r0DBE));
                           ir_expression *const r1149 = expr(ir_unop_b2i, r1148);
                           ir_expression *const r114A = expr(ir_unop_i2u, r1149);
                           body.emit(assign(r1145, sub(r1147, r114A), 0x01));

                           body.emit(assign(r0DB8, bit_xor(r0DB8, body.constant(1u)), 0x01));

                           body.emit(assign(r0DBF, add(r0DBB, body.constant(int(-1))), 0x01));

                           ir_variable *const r114B = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r114B, add(r0DBF, body.constant(int(-10))), 0x01));

                           ir_variable *const r114C = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r114C, r1145, 0x01));

                           ir_variable *const r114D = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r114D, r1146, 0x01));

                           ir_variable *const r114E = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r114E);
                           ir_variable *const r114F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r114F);
                           /* IF CONDITION */
                           ir_expression *const r1151 = equal(r1145, body.constant(0u));
                           ir_if *f1150 = new(mem_ctx) ir_if(operand(r1151).val);
                           exec_list *const f1150_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1150->then_instructions;

                              body.emit(assign(r114C, r1146, 0x01));

                              body.emit(assign(r114D, body.constant(0u), 0x01));

                              body.emit(assign(r114B, add(r114B, body.constant(int(-32))), 0x01));


                           body.instructions = f1150_parent_instructions;
                           body.emit(f1150);

                           /* END IF */

                           ir_variable *const r1152 = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r1152, r114C, 0x01));

                           ir_variable *const r1153 = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r1154 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r1154);
                           /* IF CONDITION */
                           ir_expression *const r1156 = equal(r114C, body.constant(0u));
                           ir_if *f1155 = new(mem_ctx) ir_if(operand(r1156).val);
                           exec_list *const f1155_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1155->then_instructions;

                              body.emit(assign(r1153, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1155->else_instructions;

                              body.emit(assign(r1154, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1158 = bit_and(r114C, body.constant(4294901760u));
                              ir_expression *const r1159 = equal(r1158, body.constant(0u));
                              ir_if *f1157 = new(mem_ctx) ir_if(operand(r1159).val);
                              exec_list *const f1157_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1157->then_instructions;

                                 body.emit(assign(r1154, body.constant(int(16)), 0x01));

                                 body.emit(assign(r1152, lshift(r114C, body.constant(int(16))), 0x01));


                              body.instructions = f1157_parent_instructions;
                              body.emit(f1157);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r115B = bit_and(r1152, body.constant(4278190080u));
                              ir_expression *const r115C = equal(r115B, body.constant(0u));
                              ir_if *f115A = new(mem_ctx) ir_if(operand(r115C).val);
                              exec_list *const f115A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f115A->then_instructions;

                                 body.emit(assign(r1154, add(r1154, body.constant(int(8))), 0x01));

                                 body.emit(assign(r1152, lshift(r1152, body.constant(int(8))), 0x01));


                              body.instructions = f115A_parent_instructions;
                              body.emit(f115A);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r115E = bit_and(r1152, body.constant(4026531840u));
                              ir_expression *const r115F = equal(r115E, body.constant(0u));
                              ir_if *f115D = new(mem_ctx) ir_if(operand(r115F).val);
                              exec_list *const f115D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f115D->then_instructions;

                                 body.emit(assign(r1154, add(r1154, body.constant(int(4))), 0x01));

                                 body.emit(assign(r1152, lshift(r1152, body.constant(int(4))), 0x01));


                              body.instructions = f115D_parent_instructions;
                              body.emit(f115D);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r1161 = bit_and(r1152, body.constant(3221225472u));
                              ir_expression *const r1162 = equal(r1161, body.constant(0u));
                              ir_if *f1160 = new(mem_ctx) ir_if(operand(r1162).val);
                              exec_list *const f1160_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1160->then_instructions;

                                 body.emit(assign(r1154, add(r1154, body.constant(int(2))), 0x01));

                                 body.emit(assign(r1152, lshift(r1152, body.constant(int(2))), 0x01));


                              body.instructions = f1160_parent_instructions;
                              body.emit(f1160);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r1164 = bit_and(r1152, body.constant(2147483648u));
                              ir_expression *const r1165 = equal(r1164, body.constant(0u));
                              ir_if *f1163 = new(mem_ctx) ir_if(operand(r1165).val);
                              exec_list *const f1163_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1163->then_instructions;

                                 body.emit(assign(r1154, add(r1154, body.constant(int(1))), 0x01));


                              body.instructions = f1163_parent_instructions;
                              body.emit(f1163);

                              /* END IF */

                              body.emit(assign(r1153, r1154, 0x01));


                           body.instructions = f1155_parent_instructions;
                           body.emit(f1155);

                           /* END IF */

                           body.emit(assign(r114F, add(r1153, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1167 = lequal(body.constant(int(0)), r114F);
                           ir_if *f1166 = new(mem_ctx) ir_if(operand(r1167).val);
                           exec_list *const f1166_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1166->then_instructions;

                              body.emit(assign(r114E, body.constant(0u), 0x01));

                              ir_variable *const r1168 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r1168, lshift(r114D, r114F), 0x01));

                              ir_variable *const r1169 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r116B = equal(r114F, body.constant(int(0)));
                              ir_if *f116A = new(mem_ctx) ir_if(operand(r116B).val);
                              exec_list *const f116A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f116A->then_instructions;

                                 body.emit(assign(r1169, r114C, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f116A->else_instructions;

                                 ir_expression *const r116C = lshift(r114C, r114F);
                                 ir_expression *const r116D = neg(r114F);
                                 ir_expression *const r116E = bit_and(r116D, body.constant(int(31)));
                                 ir_expression *const r116F = rshift(r114D, r116E);
                                 body.emit(assign(r1169, bit_or(r116C, r116F), 0x01));


                              body.instructions = f116A_parent_instructions;
                              body.emit(f116A);

                              /* END IF */

                              body.emit(assign(r114C, r1169, 0x01));

                              body.emit(assign(r114D, r1168, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1166->else_instructions;

                              ir_variable *const r1170 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r1170, body.constant(0u), 0x01));

                              ir_variable *const r1171 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r1171, neg(r114F), 0x01));

                              ir_variable *const r1172 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r1172);
                              ir_variable *const r1173 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r1173);
                              ir_variable *const r1174 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r1174);
                              ir_variable *const r1175 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r1176 = neg(r1171);
                              body.emit(assign(r1175, bit_and(r1176, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1178 = equal(r1171, body.constant(int(0)));
                              ir_if *f1177 = new(mem_ctx) ir_if(operand(r1178).val);
                              exec_list *const f1177_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1177->then_instructions;

                                 body.emit(assign(r1172, r1170, 0x01));

                                 body.emit(assign(r1173, r114D, 0x01));

                                 body.emit(assign(r1174, r114C, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1177->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r117A = less(r1171, body.constant(int(32)));
                                 ir_if *f1179 = new(mem_ctx) ir_if(operand(r117A).val);
                                 exec_list *const f1179_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1179->then_instructions;

                                    body.emit(assign(r1172, lshift(r114D, r1175), 0x01));

                                    ir_expression *const r117B = lshift(r114C, r1175);
                                    ir_expression *const r117C = rshift(r114D, r1171);
                                    body.emit(assign(r1173, bit_or(r117B, r117C), 0x01));

                                    body.emit(assign(r1174, rshift(r114C, r1171), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1179->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r117E = equal(r1171, body.constant(int(32)));
                                    ir_if *f117D = new(mem_ctx) ir_if(operand(r117E).val);
                                    exec_list *const f117D_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f117D->then_instructions;

                                       body.emit(assign(r1172, r114D, 0x01));

                                       body.emit(assign(r1173, r114C, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f117D->else_instructions;

                                       body.emit(assign(r1170, bit_or(body.constant(0u), r114D), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r1180 = less(r1171, body.constant(int(64)));
                                       ir_if *f117F = new(mem_ctx) ir_if(operand(r1180).val);
                                       exec_list *const f117F_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f117F->then_instructions;

                                          body.emit(assign(r1172, lshift(r114C, r1175), 0x01));

                                          ir_expression *const r1181 = bit_and(r1171, body.constant(int(31)));
                                          body.emit(assign(r1173, rshift(r114C, r1181), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f117F->else_instructions;

                                          ir_variable *const r1182 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r1184 = equal(r1171, body.constant(int(64)));
                                          ir_if *f1183 = new(mem_ctx) ir_if(operand(r1184).val);
                                          exec_list *const f1183_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f1183->then_instructions;

                                             body.emit(assign(r1182, r114C, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f1183->else_instructions;

                                             ir_expression *const r1185 = nequal(r114C, body.constant(0u));
                                             ir_expression *const r1186 = expr(ir_unop_b2i, r1185);
                                             body.emit(assign(r1182, expr(ir_unop_i2u, r1186), 0x01));


                                          body.instructions = f1183_parent_instructions;
                                          body.emit(f1183);

                                          /* END IF */

                                          body.emit(assign(r1172, r1182, 0x01));

                                          body.emit(assign(r1173, body.constant(0u), 0x01));


                                       body.instructions = f117F_parent_instructions;
                                       body.emit(f117F);

                                       /* END IF */


                                    body.instructions = f117D_parent_instructions;
                                    body.emit(f117D);

                                    /* END IF */

                                    body.emit(assign(r1174, body.constant(0u), 0x01));


                                 body.instructions = f1179_parent_instructions;
                                 body.emit(f1179);

                                 /* END IF */

                                 ir_expression *const r1187 = nequal(r1170, body.constant(0u));
                                 ir_expression *const r1188 = expr(ir_unop_b2i, r1187);
                                 ir_expression *const r1189 = expr(ir_unop_i2u, r1188);
                                 body.emit(assign(r1172, bit_or(r1172, r1189), 0x01));


                              body.instructions = f1177_parent_instructions;
                              body.emit(f1177);

                              /* END IF */

                              body.emit(assign(r114C, r1174, 0x01));

                              body.emit(assign(r114D, r1173, 0x01));

                              body.emit(assign(r114E, r1172, 0x01));


                           body.instructions = f1166_parent_instructions;
                           body.emit(f1166);

                           /* END IF */

                           body.emit(assign(r114B, sub(r114B, r114F), 0x01));

                           ir_variable *const r118A = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r118A, r114B, 0x01));

                           ir_variable *const r118B = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r118B, r114C, 0x01));

                           ir_variable *const r118C = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r118C, r114D, 0x01));

                           ir_variable *const r118D = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r118D, r114E, 0x01));

                           ir_variable *const r118E = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r118E, body.constant(true), 0x01));

                           ir_variable *const r118F = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r1190 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r1190);
                           ir_expression *const r1191 = expr(ir_unop_u2i, r114E);
                           body.emit(assign(r1190, less(r1191, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1193 = lequal(body.constant(int(2045)), r114B);
                           ir_if *f1192 = new(mem_ctx) ir_if(operand(r1193).val);
                           exec_list *const f1192_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1192->then_instructions;

                              ir_variable *const r1194 = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1196 = less(body.constant(int(2045)), r114B);
                              ir_if *f1195 = new(mem_ctx) ir_if(operand(r1196).val);
                              exec_list *const f1195_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1195->then_instructions;

                                 body.emit(assign(r1194, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1195->else_instructions;

                                 ir_variable *const r1197 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r1199 = equal(r114B, body.constant(int(2045)));
                                 ir_if *f1198 = new(mem_ctx) ir_if(operand(r1199).val);
                                 exec_list *const f1198_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1198->then_instructions;

                                    ir_expression *const r119A = equal(body.constant(2097151u), r114C);
                                    ir_expression *const r119B = equal(body.constant(4294967295u), r114D);
                                    body.emit(assign(r1197, logic_and(r119A, r119B), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1198->else_instructions;

                                    body.emit(assign(r1197, body.constant(false), 0x01));


                                 body.instructions = f1198_parent_instructions;
                                 body.emit(f1198);

                                 /* END IF */

                                 body.emit(assign(r1194, logic_and(r1197, r1190), 0x01));


                              body.instructions = f1195_parent_instructions;
                              body.emit(f1195);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f119C = new(mem_ctx) ir_if(operand(r1194).val);
                              exec_list *const f119C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f119C->then_instructions;

                                 ir_variable *const r119D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r119D);
                                 ir_expression *const r119E = lshift(r0DB8, body.constant(int(31)));
                                 body.emit(assign(r119D, add(r119E, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r119D, body.constant(0u), 0x01));

                                 body.emit(assign(r118F, r119D, 0x03));

                                 body.emit(assign(r118E, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f119C->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r11A0 = less(r114B, body.constant(int(0)));
                                 ir_if *f119F = new(mem_ctx) ir_if(operand(r11A0).val);
                                 exec_list *const f119F_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f119F->then_instructions;

                                    ir_variable *const r11A1 = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r11A1, r114E, 0x01));

                                    ir_variable *const r11A2 = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r11A2, neg(r114B), 0x01));

                                    ir_variable *const r11A3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r11A3);
                                    ir_variable *const r11A4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r11A4);
                                    ir_variable *const r11A5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r11A5);
                                    ir_variable *const r11A6 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r11A7 = neg(r11A2);
                                    body.emit(assign(r11A6, bit_and(r11A7, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r11A9 = equal(r11A2, body.constant(int(0)));
                                    ir_if *f11A8 = new(mem_ctx) ir_if(operand(r11A9).val);
                                    exec_list *const f11A8_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f11A8->then_instructions;

                                       body.emit(assign(r11A3, r114E, 0x01));

                                       body.emit(assign(r11A4, r114D, 0x01));

                                       body.emit(assign(r11A5, r114C, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f11A8->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r11AB = less(r11A2, body.constant(int(32)));
                                       ir_if *f11AA = new(mem_ctx) ir_if(operand(r11AB).val);
                                       exec_list *const f11AA_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f11AA->then_instructions;

                                          body.emit(assign(r11A3, lshift(r114D, r11A6), 0x01));

                                          ir_expression *const r11AC = lshift(r114C, r11A6);
                                          ir_expression *const r11AD = rshift(r114D, r11A2);
                                          body.emit(assign(r11A4, bit_or(r11AC, r11AD), 0x01));

                                          body.emit(assign(r11A5, rshift(r114C, r11A2), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f11AA->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r11AF = equal(r11A2, body.constant(int(32)));
                                          ir_if *f11AE = new(mem_ctx) ir_if(operand(r11AF).val);
                                          exec_list *const f11AE_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f11AE->then_instructions;

                                             body.emit(assign(r11A3, r114D, 0x01));

                                             body.emit(assign(r11A4, r114C, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f11AE->else_instructions;

                                             body.emit(assign(r11A1, bit_or(r114E, r114D), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r11B1 = less(r11A2, body.constant(int(64)));
                                             ir_if *f11B0 = new(mem_ctx) ir_if(operand(r11B1).val);
                                             exec_list *const f11B0_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f11B0->then_instructions;

                                                body.emit(assign(r11A3, lshift(r114C, r11A6), 0x01));

                                                ir_expression *const r11B2 = bit_and(r11A2, body.constant(int(31)));
                                                body.emit(assign(r11A4, rshift(r114C, r11B2), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f11B0->else_instructions;

                                                ir_variable *const r11B3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r11B5 = equal(r11A2, body.constant(int(64)));
                                                ir_if *f11B4 = new(mem_ctx) ir_if(operand(r11B5).val);
                                                exec_list *const f11B4_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f11B4->then_instructions;

                                                   body.emit(assign(r11B3, r114C, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f11B4->else_instructions;

                                                   ir_expression *const r11B6 = nequal(r114C, body.constant(0u));
                                                   ir_expression *const r11B7 = expr(ir_unop_b2i, r11B6);
                                                   body.emit(assign(r11B3, expr(ir_unop_i2u, r11B7), 0x01));


                                                body.instructions = f11B4_parent_instructions;
                                                body.emit(f11B4);

                                                /* END IF */

                                                body.emit(assign(r11A3, r11B3, 0x01));

                                                body.emit(assign(r11A4, body.constant(0u), 0x01));


                                             body.instructions = f11B0_parent_instructions;
                                             body.emit(f11B0);

                                             /* END IF */


                                          body.instructions = f11AE_parent_instructions;
                                          body.emit(f11AE);

                                          /* END IF */

                                          body.emit(assign(r11A5, body.constant(0u), 0x01));


                                       body.instructions = f11AA_parent_instructions;
                                       body.emit(f11AA);

                                       /* END IF */

                                       ir_expression *const r11B8 = nequal(r11A1, body.constant(0u));
                                       ir_expression *const r11B9 = expr(ir_unop_b2i, r11B8);
                                       ir_expression *const r11BA = expr(ir_unop_i2u, r11B9);
                                       body.emit(assign(r11A3, bit_or(r11A3, r11BA), 0x01));


                                    body.instructions = f11A8_parent_instructions;
                                    body.emit(f11A8);

                                    /* END IF */

                                    body.emit(assign(r118B, r11A5, 0x01));

                                    body.emit(assign(r118C, r11A4, 0x01));

                                    body.emit(assign(r118D, r11A3, 0x01));

                                    body.emit(assign(r118A, body.constant(int(0)), 0x01));

                                    body.emit(assign(r1190, less(r11A3, body.constant(0u)), 0x01));


                                 body.instructions = f119F_parent_instructions;
                                 body.emit(f119F);

                                 /* END IF */


                              body.instructions = f119C_parent_instructions;
                              body.emit(f119C);

                              /* END IF */


                           body.instructions = f1192_parent_instructions;
                           body.emit(f1192);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f11BB = new(mem_ctx) ir_if(operand(r118E).val);
                           exec_list *const f11BB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f11BB->then_instructions;

                              /* IF CONDITION */
                              ir_if *f11BC = new(mem_ctx) ir_if(operand(r1190).val);
                              exec_list *const f11BC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f11BC->then_instructions;

                                 ir_variable *const r11BD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r11BD, add(r118C, body.constant(1u)), 0x01));

                                 ir_expression *const r11BE = less(r11BD, r118C);
                                 ir_expression *const r11BF = expr(ir_unop_b2i, r11BE);
                                 ir_expression *const r11C0 = expr(ir_unop_i2u, r11BF);
                                 body.emit(assign(r118B, add(r118B, r11C0), 0x01));

                                 ir_expression *const r11C1 = equal(r118D, body.constant(0u));
                                 ir_expression *const r11C2 = expr(ir_unop_b2i, r11C1);
                                 ir_expression *const r11C3 = expr(ir_unop_i2u, r11C2);
                                 ir_expression *const r11C4 = add(r118D, r11C3);
                                 ir_expression *const r11C5 = bit_and(r11C4, body.constant(1u));
                                 ir_expression *const r11C6 = expr(ir_unop_bit_not, r11C5);
                                 body.emit(assign(r118C, bit_and(r11BD, r11C6), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f11BC->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r11C8 = bit_or(r118B, r118C);
                                 ir_expression *const r11C9 = equal(r11C8, body.constant(0u));
                                 ir_if *f11C7 = new(mem_ctx) ir_if(operand(r11C9).val);
                                 exec_list *const f11C7_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f11C7->then_instructions;

                                    body.emit(assign(r118A, body.constant(int(0)), 0x01));


                                 body.instructions = f11C7_parent_instructions;
                                 body.emit(f11C7);

                                 /* END IF */


                              body.instructions = f11BC_parent_instructions;
                              body.emit(f11BC);

                              /* END IF */

                              ir_variable *const r11CA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r11CA);
                              ir_expression *const r11CB = lshift(r0DB8, body.constant(int(31)));
                              ir_expression *const r11CC = expr(ir_unop_i2u, r118A);
                              ir_expression *const r11CD = lshift(r11CC, body.constant(int(20)));
                              ir_expression *const r11CE = add(r11CB, r11CD);
                              body.emit(assign(r11CA, add(r11CE, r118B), 0x02));

                              body.emit(assign(r11CA, r118C, 0x01));

                              body.emit(assign(r118F, r11CA, 0x03));

                              body.emit(assign(r118E, body.constant(false), 0x01));


                           body.instructions = f11BB_parent_instructions;
                           body.emit(f11BB);

                           /* END IF */

                           body.emit(assign(r0DB9, r118F, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1143->else_instructions;

                           ir_variable *const r11CF = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r11CF);
                           body.emit(assign(r11CF, body.constant(0u), 0x02));

                           body.emit(assign(r11CF, body.constant(0u), 0x01));

                           body.emit(assign(r0DB9, r11CF, 0x03));


                        body.instructions = f1143_parent_instructions;
                        body.emit(f1143);

                        /* END IF */


                     body.instructions = f10B7_parent_instructions;
                     body.emit(f10B7);

                     /* END IF */


                  body.instructions = f102B_parent_instructions;
                  body.emit(f102B);

                  /* END IF */


               body.instructions = f0F9F_parent_instructions;
               body.emit(f0F9F);

               /* END IF */


            body.instructions = f0F78_parent_instructions;
            body.emit(f0F78);

            /* END IF */


         body.instructions = f0EA2_parent_instructions;
         body.emit(f0EA2);

         /* END IF */


      body.instructions = f0DD0_parent_instructions;
      body.emit(f0DD0);

      /* END IF */

      body.emit(assign(r0DB3, r0DB9, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0DB6->else_instructions;

      ir_variable *const r11D0 = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r11D0, body.constant(true), 0x01));

      ir_variable *const r11D1 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r11D2 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r11D2);
      ir_variable *const r11D3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
      body.emit(r11D3);
      ir_variable *const r11D4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
      body.emit(r11D4);
      ir_variable *const r11D5 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r11D5);
      ir_variable *const r11D6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
      body.emit(r11D6);
      ir_variable *const r11D7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
      body.emit(r11D7);
      body.emit(assign(r11D7, body.constant(0u), 0x01));

      body.emit(assign(r11D6, body.constant(0u), 0x01));

      ir_variable *const r11D8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r11D8);
      body.emit(assign(r11D8, bit_and(swizzle_y(r0DB1), body.constant(1048575u)), 0x02));

      body.emit(assign(r11D8, swizzle_x(r0DB1), 0x01));

      body.emit(assign(r11D4, r11D8, 0x03));

      ir_variable *const r11D9 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r11DA = rshift(swizzle_y(r0DB1), body.constant(int(20)));
      ir_expression *const r11DB = bit_and(r11DA, body.constant(2047u));
      body.emit(assign(r11D9, expr(ir_unop_u2i, r11DB), 0x01));

      ir_variable *const r11DC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r11DC);
      body.emit(assign(r11DC, bit_and(swizzle_y(r0DB2), body.constant(1048575u)), 0x02));

      body.emit(assign(r11DC, swizzle_x(r0DB2), 0x01));

      body.emit(assign(r11D3, r11DC, 0x03));

      ir_variable *const r11DD = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r11DE = rshift(swizzle_y(r0DB2), body.constant(int(20)));
      ir_expression *const r11DF = bit_and(r11DE, body.constant(2047u));
      body.emit(assign(r11DD, expr(ir_unop_u2i, r11DF), 0x01));

      ir_variable *const r11E0 = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r11E0, sub(r11D9, r11DD), 0x01));

      body.emit(assign(r11D2, r11E0, 0x01));

      /* IF CONDITION */
      ir_expression *const r11E2 = less(body.constant(int(0)), r11E0);
      ir_if *f11E1 = new(mem_ctx) ir_if(operand(r11E2).val);
      exec_list *const f11E1_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f11E1->then_instructions;

         /* IF CONDITION */
         ir_expression *const r11E4 = equal(r11D9, body.constant(int(2047)));
         ir_if *f11E3 = new(mem_ctx) ir_if(operand(r11E4).val);
         exec_list *const f11E3_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f11E3->then_instructions;

            /* IF CONDITION */
            ir_expression *const r11E6 = bit_or(swizzle_y(r11D8), swizzle_x(r0DB1));
            ir_expression *const r11E7 = nequal(r11E6, body.constant(0u));
            ir_if *f11E5 = new(mem_ctx) ir_if(operand(r11E7).val);
            exec_list *const f11E5_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f11E5->then_instructions;

               ir_variable *const r11E8 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r11E8, swizzle_x(r0DB1), 0x01));

               ir_variable *const r11E9 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r11E9, swizzle_x(r0DB2), 0x01));

               ir_variable *const r11EA = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r11EB = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r11EC = rshift(swizzle_y(r0DB1), body.constant(int(19)));
               ir_expression *const r11ED = bit_and(r11EC, body.constant(4095u));
               ir_expression *const r11EE = equal(r11ED, body.constant(4094u));
               ir_expression *const r11EF = nequal(swizzle_x(r0DB1), body.constant(0u));
               ir_expression *const r11F0 = bit_and(swizzle_y(r0DB1), body.constant(524287u));
               ir_expression *const r11F1 = nequal(r11F0, body.constant(0u));
               ir_expression *const r11F2 = logic_or(r11EF, r11F1);
               body.emit(assign(r11EB, logic_and(r11EE, r11F2), 0x01));

               ir_variable *const r11F3 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r11F4 = lshift(swizzle_y(r0DB2), body.constant(int(1)));
               ir_expression *const r11F5 = lequal(body.constant(4292870144u), r11F4);
               ir_expression *const r11F6 = nequal(swizzle_x(r0DB2), body.constant(0u));
               ir_expression *const r11F7 = bit_and(swizzle_y(r0DB2), body.constant(1048575u));
               ir_expression *const r11F8 = nequal(r11F7, body.constant(0u));
               ir_expression *const r11F9 = logic_or(r11F6, r11F8);
               body.emit(assign(r11F3, logic_and(r11F5, r11F9), 0x01));

               body.emit(assign(r11E8, bit_or(swizzle_y(r0DB1), body.constant(524288u)), 0x02));

               body.emit(assign(r11E9, bit_or(swizzle_y(r0DB2), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r11FB = lshift(swizzle_y(r0DB1), body.constant(int(1)));
               ir_expression *const r11FC = lequal(body.constant(4292870144u), r11FB);
               ir_expression *const r11FD = nequal(swizzle_x(r0DB1), body.constant(0u));
               ir_expression *const r11FE = bit_and(swizzle_y(r0DB1), body.constant(1048575u));
               ir_expression *const r11FF = nequal(r11FE, body.constant(0u));
               ir_expression *const r1200 = logic_or(r11FD, r11FF);
               ir_expression *const r1201 = logic_and(r11FC, r1200);
               ir_if *f11FA = new(mem_ctx) ir_if(operand(r1201).val);
               exec_list *const f11FA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f11FA->then_instructions;

                  ir_variable *const r1202 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1204 = logic_and(r11EB, r11F3);
                  ir_if *f1203 = new(mem_ctx) ir_if(operand(r1204).val);
                  exec_list *const f1203_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1203->then_instructions;

                     body.emit(assign(r1202, r11E9, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1203->else_instructions;

                     body.emit(assign(r1202, r11E8, 0x03));


                  body.instructions = f1203_parent_instructions;
                  body.emit(f1203);

                  /* END IF */

                  body.emit(assign(r11EA, r1202, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f11FA->else_instructions;

                  body.emit(assign(r11EA, r11E9, 0x03));


               body.instructions = f11FA_parent_instructions;
               body.emit(f11FA);

               /* END IF */

               body.emit(assign(r11D1, r11EA, 0x03));

               body.emit(assign(r11D0, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f11E5->else_instructions;

               body.emit(assign(r11D1, r0DB1, 0x03));

               body.emit(assign(r11D0, body.constant(false), 0x01));


            body.instructions = f11E5_parent_instructions;
            body.emit(f11E5);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f11E3->else_instructions;

            /* IF CONDITION */
            ir_expression *const r1206 = equal(r11DD, body.constant(int(0)));
            ir_if *f1205 = new(mem_ctx) ir_if(operand(r1206).val);
            exec_list *const f1205_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1205->then_instructions;

               body.emit(assign(r11D2, add(r11E0, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1205->else_instructions;

               body.emit(assign(r11D3, bit_or(swizzle_y(r11DC), body.constant(1048576u)), 0x02));


            body.instructions = f1205_parent_instructions;
            body.emit(f1205);

            /* END IF */

            ir_variable *const r1207 = body.make_temp(glsl_type::uint_type, "a0");
            body.emit(assign(r1207, swizzle_y(r11D3), 0x01));

            ir_variable *const r1208 = body.make_temp(glsl_type::uint_type, "a1");
            body.emit(assign(r1208, swizzle_x(r11D3), 0x01));

            ir_variable *const r1209 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r1209, body.constant(0u), 0x01));

            ir_variable *const r120A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r120A);
            ir_variable *const r120B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r120B);
            ir_variable *const r120C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r120C);
            ir_variable *const r120D = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r120E = neg(r11D2);
            body.emit(assign(r120D, bit_and(r120E, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r1210 = equal(r11D2, body.constant(int(0)));
            ir_if *f120F = new(mem_ctx) ir_if(operand(r1210).val);
            exec_list *const f120F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f120F->then_instructions;

               body.emit(assign(r120A, r1209, 0x01));

               body.emit(assign(r120B, r1208, 0x01));

               body.emit(assign(r120C, r1207, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f120F->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1212 = less(r11D2, body.constant(int(32)));
               ir_if *f1211 = new(mem_ctx) ir_if(operand(r1212).val);
               exec_list *const f1211_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1211->then_instructions;

                  body.emit(assign(r120A, lshift(swizzle_x(r11DC), r120D), 0x01));

                  ir_expression *const r1213 = lshift(swizzle_y(r11D3), r120D);
                  ir_expression *const r1214 = rshift(swizzle_x(r11DC), r11D2);
                  body.emit(assign(r120B, bit_or(r1213, r1214), 0x01));

                  body.emit(assign(r120C, rshift(swizzle_y(r11D3), r11D2), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1211->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1216 = equal(r11D2, body.constant(int(32)));
                  ir_if *f1215 = new(mem_ctx) ir_if(operand(r1216).val);
                  exec_list *const f1215_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1215->then_instructions;

                     body.emit(assign(r120A, r1208, 0x01));

                     body.emit(assign(r120B, r1207, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1215->else_instructions;

                     body.emit(assign(r1209, bit_or(body.constant(0u), swizzle_x(r11DC)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1218 = less(r11D2, body.constant(int(64)));
                     ir_if *f1217 = new(mem_ctx) ir_if(operand(r1218).val);
                     exec_list *const f1217_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1217->then_instructions;

                        body.emit(assign(r120A, lshift(swizzle_y(r11D3), r120D), 0x01));

                        ir_expression *const r1219 = bit_and(r11D2, body.constant(int(31)));
                        body.emit(assign(r120B, rshift(swizzle_y(r11D3), r1219), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1217->else_instructions;

                        ir_variable *const r121A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r121C = equal(r11D2, body.constant(int(64)));
                        ir_if *f121B = new(mem_ctx) ir_if(operand(r121C).val);
                        exec_list *const f121B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f121B->then_instructions;

                           body.emit(assign(r121A, r1207, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f121B->else_instructions;

                           ir_expression *const r121D = nequal(swizzle_y(r11D3), body.constant(0u));
                           ir_expression *const r121E = expr(ir_unop_b2i, r121D);
                           body.emit(assign(r121A, expr(ir_unop_i2u, r121E), 0x01));


                        body.instructions = f121B_parent_instructions;
                        body.emit(f121B);

                        /* END IF */

                        body.emit(assign(r120A, r121A, 0x01));

                        body.emit(assign(r120B, body.constant(0u), 0x01));


                     body.instructions = f1217_parent_instructions;
                     body.emit(f1217);

                     /* END IF */


                  body.instructions = f1215_parent_instructions;
                  body.emit(f1215);

                  /* END IF */

                  body.emit(assign(r120C, body.constant(0u), 0x01));


               body.instructions = f1211_parent_instructions;
               body.emit(f1211);

               /* END IF */

               ir_expression *const r121F = nequal(r1209, body.constant(0u));
               ir_expression *const r1220 = expr(ir_unop_b2i, r121F);
               ir_expression *const r1221 = expr(ir_unop_i2u, r1220);
               body.emit(assign(r120A, bit_or(r120A, r1221), 0x01));


            body.instructions = f120F_parent_instructions;
            body.emit(f120F);

            /* END IF */

            body.emit(assign(r11D3, r120C, 0x02));

            body.emit(assign(r11D3, r120B, 0x01));

            body.emit(assign(r11D6, r120A, 0x01));

            body.emit(assign(r11D5, r11D9, 0x01));


         body.instructions = f11E3_parent_instructions;
         body.emit(f11E3);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f11E1->else_instructions;

         /* IF CONDITION */
         ir_expression *const r1223 = less(r11D2, body.constant(int(0)));
         ir_if *f1222 = new(mem_ctx) ir_if(operand(r1223).val);
         exec_list *const f1222_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1222->then_instructions;

            /* IF CONDITION */
            ir_expression *const r1225 = equal(r11DD, body.constant(int(2047)));
            ir_if *f1224 = new(mem_ctx) ir_if(operand(r1225).val);
            exec_list *const f1224_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1224->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1227 = bit_or(swizzle_y(r11D3), swizzle_x(r11D3));
               ir_expression *const r1228 = nequal(r1227, body.constant(0u));
               ir_if *f1226 = new(mem_ctx) ir_if(operand(r1228).val);
               exec_list *const f1226_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1226->then_instructions;

                  ir_variable *const r1229 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r1229, swizzle_x(r0DB1), 0x01));

                  ir_variable *const r122A = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r122A, swizzle_x(r0DB2), 0x01));

                  ir_variable *const r122B = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r122C = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r122D = rshift(swizzle_y(r0DB1), body.constant(int(19)));
                  ir_expression *const r122E = bit_and(r122D, body.constant(4095u));
                  ir_expression *const r122F = equal(r122E, body.constant(4094u));
                  ir_expression *const r1230 = nequal(swizzle_x(r0DB1), body.constant(0u));
                  ir_expression *const r1231 = bit_and(swizzle_y(r0DB1), body.constant(524287u));
                  ir_expression *const r1232 = nequal(r1231, body.constant(0u));
                  ir_expression *const r1233 = logic_or(r1230, r1232);
                  body.emit(assign(r122C, logic_and(r122F, r1233), 0x01));

                  ir_variable *const r1234 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r1235 = lshift(swizzle_y(r0DB2), body.constant(int(1)));
                  ir_expression *const r1236 = lequal(body.constant(4292870144u), r1235);
                  ir_expression *const r1237 = nequal(swizzle_x(r0DB2), body.constant(0u));
                  ir_expression *const r1238 = bit_and(swizzle_y(r0DB2), body.constant(1048575u));
                  ir_expression *const r1239 = nequal(r1238, body.constant(0u));
                  ir_expression *const r123A = logic_or(r1237, r1239);
                  body.emit(assign(r1234, logic_and(r1236, r123A), 0x01));

                  body.emit(assign(r1229, bit_or(swizzle_y(r0DB1), body.constant(524288u)), 0x02));

                  body.emit(assign(r122A, bit_or(swizzle_y(r0DB2), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r123C = lshift(swizzle_y(r0DB1), body.constant(int(1)));
                  ir_expression *const r123D = lequal(body.constant(4292870144u), r123C);
                  ir_expression *const r123E = nequal(swizzle_x(r0DB1), body.constant(0u));
                  ir_expression *const r123F = bit_and(swizzle_y(r0DB1), body.constant(1048575u));
                  ir_expression *const r1240 = nequal(r123F, body.constant(0u));
                  ir_expression *const r1241 = logic_or(r123E, r1240);
                  ir_expression *const r1242 = logic_and(r123D, r1241);
                  ir_if *f123B = new(mem_ctx) ir_if(operand(r1242).val);
                  exec_list *const f123B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f123B->then_instructions;

                     ir_variable *const r1243 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1245 = logic_and(r122C, r1234);
                     ir_if *f1244 = new(mem_ctx) ir_if(operand(r1245).val);
                     exec_list *const f1244_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1244->then_instructions;

                        body.emit(assign(r1243, r122A, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1244->else_instructions;

                        body.emit(assign(r1243, r1229, 0x03));


                     body.instructions = f1244_parent_instructions;
                     body.emit(f1244);

                     /* END IF */

                     body.emit(assign(r122B, r1243, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f123B->else_instructions;

                     body.emit(assign(r122B, r122A, 0x03));


                  body.instructions = f123B_parent_instructions;
                  body.emit(f123B);

                  /* END IF */

                  body.emit(assign(r11D1, r122B, 0x03));

                  body.emit(assign(r11D0, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1226->else_instructions;

                  ir_variable *const r1246 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1246);
                  ir_expression *const r1247 = lshift(r0DB4, body.constant(int(31)));
                  body.emit(assign(r1246, add(r1247, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r1246, body.constant(0u), 0x01));

                  body.emit(assign(r11D1, r1246, 0x03));

                  body.emit(assign(r11D0, body.constant(false), 0x01));


               body.instructions = f1226_parent_instructions;
               body.emit(f1226);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1224->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1249 = equal(r11D9, body.constant(int(0)));
               ir_if *f1248 = new(mem_ctx) ir_if(operand(r1249).val);
               exec_list *const f1248_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1248->then_instructions;

                  body.emit(assign(r11D2, add(r11D2, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1248->else_instructions;

                  body.emit(assign(r11D4, bit_or(swizzle_y(r11D8), body.constant(1048576u)), 0x02));


               body.instructions = f1248_parent_instructions;
               body.emit(f1248);

               /* END IF */

               ir_variable *const r124A = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r124A, swizzle_y(r11D4), 0x01));

               ir_variable *const r124B = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r124B, swizzle_x(r11D4), 0x01));

               ir_variable *const r124C = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r124C, body.constant(0u), 0x01));

               ir_variable *const r124D = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r124D, neg(r11D2), 0x01));

               ir_variable *const r124E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r124E);
               ir_variable *const r124F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r124F);
               ir_variable *const r1250 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1250);
               ir_variable *const r1251 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r1252 = neg(r124D);
               body.emit(assign(r1251, bit_and(r1252, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1254 = equal(r124D, body.constant(int(0)));
               ir_if *f1253 = new(mem_ctx) ir_if(operand(r1254).val);
               exec_list *const f1253_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1253->then_instructions;

                  body.emit(assign(r124E, r124C, 0x01));

                  body.emit(assign(r124F, r124B, 0x01));

                  body.emit(assign(r1250, r124A, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1253->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1256 = less(r124D, body.constant(int(32)));
                  ir_if *f1255 = new(mem_ctx) ir_if(operand(r1256).val);
                  exec_list *const f1255_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1255->then_instructions;

                     body.emit(assign(r124E, lshift(swizzle_x(r11D8), r1251), 0x01));

                     ir_expression *const r1257 = lshift(swizzle_y(r11D4), r1251);
                     ir_expression *const r1258 = rshift(swizzle_x(r11D8), r124D);
                     body.emit(assign(r124F, bit_or(r1257, r1258), 0x01));

                     body.emit(assign(r1250, rshift(swizzle_y(r11D4), r124D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1255->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r125A = equal(r124D, body.constant(int(32)));
                     ir_if *f1259 = new(mem_ctx) ir_if(operand(r125A).val);
                     exec_list *const f1259_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1259->then_instructions;

                        body.emit(assign(r124E, r124B, 0x01));

                        body.emit(assign(r124F, r124A, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1259->else_instructions;

                        body.emit(assign(r124C, bit_or(body.constant(0u), swizzle_x(r11D8)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r125C = less(r124D, body.constant(int(64)));
                        ir_if *f125B = new(mem_ctx) ir_if(operand(r125C).val);
                        exec_list *const f125B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f125B->then_instructions;

                           body.emit(assign(r124E, lshift(swizzle_y(r11D4), r1251), 0x01));

                           ir_expression *const r125D = bit_and(r124D, body.constant(int(31)));
                           body.emit(assign(r124F, rshift(swizzle_y(r11D4), r125D), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f125B->else_instructions;

                           ir_variable *const r125E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r1260 = equal(r124D, body.constant(int(64)));
                           ir_if *f125F = new(mem_ctx) ir_if(operand(r1260).val);
                           exec_list *const f125F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f125F->then_instructions;

                              body.emit(assign(r125E, r124A, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f125F->else_instructions;

                              ir_expression *const r1261 = nequal(swizzle_y(r11D4), body.constant(0u));
                              ir_expression *const r1262 = expr(ir_unop_b2i, r1261);
                              body.emit(assign(r125E, expr(ir_unop_i2u, r1262), 0x01));


                           body.instructions = f125F_parent_instructions;
                           body.emit(f125F);

                           /* END IF */

                           body.emit(assign(r124E, r125E, 0x01));

                           body.emit(assign(r124F, body.constant(0u), 0x01));


                        body.instructions = f125B_parent_instructions;
                        body.emit(f125B);

                        /* END IF */


                     body.instructions = f1259_parent_instructions;
                     body.emit(f1259);

                     /* END IF */

                     body.emit(assign(r1250, body.constant(0u), 0x01));


                  body.instructions = f1255_parent_instructions;
                  body.emit(f1255);

                  /* END IF */

                  ir_expression *const r1263 = nequal(r124C, body.constant(0u));
                  ir_expression *const r1264 = expr(ir_unop_b2i, r1263);
                  ir_expression *const r1265 = expr(ir_unop_i2u, r1264);
                  body.emit(assign(r124E, bit_or(r124E, r1265), 0x01));


               body.instructions = f1253_parent_instructions;
               body.emit(f1253);

               /* END IF */

               body.emit(assign(r11D4, r1250, 0x02));

               body.emit(assign(r11D4, r124F, 0x01));

               body.emit(assign(r11D6, r124E, 0x01));

               body.emit(assign(r11D5, r11DD, 0x01));


            body.instructions = f1224_parent_instructions;
            body.emit(f1224);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1222->else_instructions;

            /* IF CONDITION */
            ir_expression *const r1267 = equal(r11D9, body.constant(int(2047)));
            ir_if *f1266 = new(mem_ctx) ir_if(operand(r1267).val);
            exec_list *const f1266_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1266->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1269 = bit_or(swizzle_y(r11D4), swizzle_x(r11D4));
               ir_expression *const r126A = bit_or(swizzle_y(r11D3), swizzle_x(r11D3));
               ir_expression *const r126B = bit_or(r1269, r126A);
               ir_expression *const r126C = nequal(r126B, body.constant(0u));
               ir_if *f1268 = new(mem_ctx) ir_if(operand(r126C).val);
               exec_list *const f1268_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1268->then_instructions;

                  ir_variable *const r126D = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r126D, swizzle_x(r0DB1), 0x01));

                  ir_variable *const r126E = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r126E, swizzle_x(r0DB2), 0x01));

                  ir_variable *const r126F = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r1270 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r1271 = rshift(swizzle_y(r0DB1), body.constant(int(19)));
                  ir_expression *const r1272 = bit_and(r1271, body.constant(4095u));
                  ir_expression *const r1273 = equal(r1272, body.constant(4094u));
                  ir_expression *const r1274 = nequal(swizzle_x(r0DB1), body.constant(0u));
                  ir_expression *const r1275 = bit_and(swizzle_y(r0DB1), body.constant(524287u));
                  ir_expression *const r1276 = nequal(r1275, body.constant(0u));
                  ir_expression *const r1277 = logic_or(r1274, r1276);
                  body.emit(assign(r1270, logic_and(r1273, r1277), 0x01));

                  ir_variable *const r1278 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r1279 = lshift(swizzle_y(r0DB2), body.constant(int(1)));
                  ir_expression *const r127A = lequal(body.constant(4292870144u), r1279);
                  ir_expression *const r127B = nequal(swizzle_x(r0DB2), body.constant(0u));
                  ir_expression *const r127C = bit_and(swizzle_y(r0DB2), body.constant(1048575u));
                  ir_expression *const r127D = nequal(r127C, body.constant(0u));
                  ir_expression *const r127E = logic_or(r127B, r127D);
                  body.emit(assign(r1278, logic_and(r127A, r127E), 0x01));

                  body.emit(assign(r126D, bit_or(swizzle_y(r0DB1), body.constant(524288u)), 0x02));

                  body.emit(assign(r126E, bit_or(swizzle_y(r0DB2), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r1280 = lshift(swizzle_y(r0DB1), body.constant(int(1)));
                  ir_expression *const r1281 = lequal(body.constant(4292870144u), r1280);
                  ir_expression *const r1282 = nequal(swizzle_x(r0DB1), body.constant(0u));
                  ir_expression *const r1283 = bit_and(swizzle_y(r0DB1), body.constant(1048575u));
                  ir_expression *const r1284 = nequal(r1283, body.constant(0u));
                  ir_expression *const r1285 = logic_or(r1282, r1284);
                  ir_expression *const r1286 = logic_and(r1281, r1285);
                  ir_if *f127F = new(mem_ctx) ir_if(operand(r1286).val);
                  exec_list *const f127F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f127F->then_instructions;

                     ir_variable *const r1287 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1289 = logic_and(r1270, r1278);
                     ir_if *f1288 = new(mem_ctx) ir_if(operand(r1289).val);
                     exec_list *const f1288_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1288->then_instructions;

                        body.emit(assign(r1287, r126E, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1288->else_instructions;

                        body.emit(assign(r1287, r126D, 0x03));


                     body.instructions = f1288_parent_instructions;
                     body.emit(f1288);

                     /* END IF */

                     body.emit(assign(r126F, r1287, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f127F->else_instructions;

                     body.emit(assign(r126F, r126E, 0x03));


                  body.instructions = f127F_parent_instructions;
                  body.emit(f127F);

                  /* END IF */

                  body.emit(assign(r11D1, r126F, 0x03));

                  body.emit(assign(r11D0, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1268->else_instructions;

                  body.emit(assign(r11D1, r0DB1, 0x03));

                  body.emit(assign(r11D0, body.constant(false), 0x01));


               body.instructions = f1268_parent_instructions;
               body.emit(f1268);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1266->else_instructions;

               ir_variable *const r128A = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r128B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r128B, add(swizzle_x(r11D4), swizzle_x(r11D3)), 0x01));

               ir_expression *const r128C = add(swizzle_y(r11D4), swizzle_y(r11D3));
               ir_expression *const r128D = less(r128B, swizzle_x(r11D4));
               ir_expression *const r128E = expr(ir_unop_b2i, r128D);
               ir_expression *const r128F = expr(ir_unop_i2u, r128E);
               body.emit(assign(r128A, add(r128C, r128F), 0x01));

               body.emit(assign(r11D7, r128A, 0x01));

               /* IF CONDITION */
               ir_expression *const r1291 = equal(r11D9, body.constant(int(0)));
               ir_if *f1290 = new(mem_ctx) ir_if(operand(r1291).val);
               exec_list *const f1290_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1290->then_instructions;

                  ir_variable *const r1292 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1292);
                  ir_expression *const r1293 = lshift(r0DB4, body.constant(int(31)));
                  body.emit(assign(r1292, add(r1293, r128A), 0x02));

                  body.emit(assign(r1292, r128B, 0x01));

                  body.emit(assign(r11D1, r1292, 0x03));

                  body.emit(assign(r11D0, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1290->else_instructions;

                  body.emit(assign(r11D7, bit_or(r128A, body.constant(2097152u)), 0x01));

                  body.emit(assign(r11D5, r11D9, 0x01));

                  ir_variable *const r1294 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r1294);
                  ir_variable *const r1295 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1295);
                  ir_variable *const r1296 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1296);
                  body.emit(assign(r1294, lshift(r128B, body.constant(int(31))), 0x01));

                  ir_expression *const r1297 = lshift(r11D7, body.constant(int(31)));
                  ir_expression *const r1298 = rshift(r128B, body.constant(int(1)));
                  body.emit(assign(r1295, bit_or(r1297, r1298), 0x01));

                  body.emit(assign(r1296, rshift(r11D7, body.constant(int(1))), 0x01));

                  body.emit(assign(r1294, bit_or(r1294, body.constant(0u)), 0x01));

                  body.emit(assign(r11D7, r1296, 0x01));

                  body.emit(assign(r11D6, r1294, 0x01));

                  ir_variable *const r1299 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r1299, r11D9, 0x01));

                  ir_variable *const r129A = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r129A, r1296, 0x01));

                  ir_variable *const r129B = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r129B, r1295, 0x01));

                  ir_variable *const r129C = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r129C, r1294, 0x01));

                  ir_variable *const r129D = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r129D, body.constant(true), 0x01));

                  ir_variable *const r129E = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r129F = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r129F);
                  ir_expression *const r12A0 = expr(ir_unop_u2i, r1294);
                  body.emit(assign(r129F, less(r12A0, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r12A2 = lequal(body.constant(int(2045)), r11D9);
                  ir_if *f12A1 = new(mem_ctx) ir_if(operand(r12A2).val);
                  exec_list *const f12A1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f12A1->then_instructions;

                     ir_variable *const r12A3 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r12A5 = less(body.constant(int(2045)), r11D9);
                     ir_if *f12A4 = new(mem_ctx) ir_if(operand(r12A5).val);
                     exec_list *const f12A4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f12A4->then_instructions;

                        body.emit(assign(r12A3, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f12A4->else_instructions;

                        ir_variable *const r12A6 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r12A8 = equal(r11D9, body.constant(int(2045)));
                        ir_if *f12A7 = new(mem_ctx) ir_if(operand(r12A8).val);
                        exec_list *const f12A7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f12A7->then_instructions;

                           ir_expression *const r12A9 = equal(body.constant(2097151u), r1296);
                           ir_expression *const r12AA = equal(body.constant(4294967295u), r1295);
                           body.emit(assign(r12A6, logic_and(r12A9, r12AA), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f12A7->else_instructions;

                           body.emit(assign(r12A6, body.constant(false), 0x01));


                        body.instructions = f12A7_parent_instructions;
                        body.emit(f12A7);

                        /* END IF */

                        body.emit(assign(r12A3, logic_and(r12A6, r129F), 0x01));


                     body.instructions = f12A4_parent_instructions;
                     body.emit(f12A4);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f12AB = new(mem_ctx) ir_if(operand(r12A3).val);
                     exec_list *const f12AB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f12AB->then_instructions;

                        ir_variable *const r12AC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r12AC);
                        ir_expression *const r12AD = lshift(r0DB4, body.constant(int(31)));
                        body.emit(assign(r12AC, add(r12AD, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r12AC, body.constant(0u), 0x01));

                        body.emit(assign(r129E, r12AC, 0x03));

                        body.emit(assign(r129D, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f12AB->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r12AF = less(r11D9, body.constant(int(0)));
                        ir_if *f12AE = new(mem_ctx) ir_if(operand(r12AF).val);
                        exec_list *const f12AE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f12AE->then_instructions;

                           ir_variable *const r12B0 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r12B0, r1294, 0x01));

                           ir_variable *const r12B1 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r12B1, neg(r11D9), 0x01));

                           ir_variable *const r12B2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r12B2);
                           ir_variable *const r12B3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r12B3);
                           ir_variable *const r12B4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r12B4);
                           ir_variable *const r12B5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r12B6 = neg(r12B1);
                           body.emit(assign(r12B5, bit_and(r12B6, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r12B8 = equal(r12B1, body.constant(int(0)));
                           ir_if *f12B7 = new(mem_ctx) ir_if(operand(r12B8).val);
                           exec_list *const f12B7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f12B7->then_instructions;

                              body.emit(assign(r12B2, r1294, 0x01));

                              body.emit(assign(r12B3, r1295, 0x01));

                              body.emit(assign(r12B4, r1296, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f12B7->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r12BA = less(r12B1, body.constant(int(32)));
                              ir_if *f12B9 = new(mem_ctx) ir_if(operand(r12BA).val);
                              exec_list *const f12B9_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f12B9->then_instructions;

                                 body.emit(assign(r12B2, lshift(r1295, r12B5), 0x01));

                                 ir_expression *const r12BB = lshift(r1296, r12B5);
                                 ir_expression *const r12BC = rshift(r1295, r12B1);
                                 body.emit(assign(r12B3, bit_or(r12BB, r12BC), 0x01));

                                 body.emit(assign(r12B4, rshift(r1296, r12B1), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f12B9->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r12BE = equal(r12B1, body.constant(int(32)));
                                 ir_if *f12BD = new(mem_ctx) ir_if(operand(r12BE).val);
                                 exec_list *const f12BD_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f12BD->then_instructions;

                                    body.emit(assign(r12B2, r1295, 0x01));

                                    body.emit(assign(r12B3, r1296, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f12BD->else_instructions;

                                    body.emit(assign(r12B0, bit_or(r1294, r1295), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r12C0 = less(r12B1, body.constant(int(64)));
                                    ir_if *f12BF = new(mem_ctx) ir_if(operand(r12C0).val);
                                    exec_list *const f12BF_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f12BF->then_instructions;

                                       body.emit(assign(r12B2, lshift(r1296, r12B5), 0x01));

                                       ir_expression *const r12C1 = bit_and(r12B1, body.constant(int(31)));
                                       body.emit(assign(r12B3, rshift(r1296, r12C1), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f12BF->else_instructions;

                                       ir_variable *const r12C2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r12C4 = equal(r12B1, body.constant(int(64)));
                                       ir_if *f12C3 = new(mem_ctx) ir_if(operand(r12C4).val);
                                       exec_list *const f12C3_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f12C3->then_instructions;

                                          body.emit(assign(r12C2, r1296, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f12C3->else_instructions;

                                          ir_expression *const r12C5 = nequal(r1296, body.constant(0u));
                                          ir_expression *const r12C6 = expr(ir_unop_b2i, r12C5);
                                          body.emit(assign(r12C2, expr(ir_unop_i2u, r12C6), 0x01));


                                       body.instructions = f12C3_parent_instructions;
                                       body.emit(f12C3);

                                       /* END IF */

                                       body.emit(assign(r12B2, r12C2, 0x01));

                                       body.emit(assign(r12B3, body.constant(0u), 0x01));


                                    body.instructions = f12BF_parent_instructions;
                                    body.emit(f12BF);

                                    /* END IF */


                                 body.instructions = f12BD_parent_instructions;
                                 body.emit(f12BD);

                                 /* END IF */

                                 body.emit(assign(r12B4, body.constant(0u), 0x01));


                              body.instructions = f12B9_parent_instructions;
                              body.emit(f12B9);

                              /* END IF */

                              ir_expression *const r12C7 = nequal(r12B0, body.constant(0u));
                              ir_expression *const r12C8 = expr(ir_unop_b2i, r12C7);
                              ir_expression *const r12C9 = expr(ir_unop_i2u, r12C8);
                              body.emit(assign(r12B2, bit_or(r12B2, r12C9), 0x01));


                           body.instructions = f12B7_parent_instructions;
                           body.emit(f12B7);

                           /* END IF */

                           body.emit(assign(r129A, r12B4, 0x01));

                           body.emit(assign(r129B, r12B3, 0x01));

                           body.emit(assign(r129C, r12B2, 0x01));

                           body.emit(assign(r1299, body.constant(int(0)), 0x01));

                           body.emit(assign(r129F, less(r12B2, body.constant(0u)), 0x01));


                        body.instructions = f12AE_parent_instructions;
                        body.emit(f12AE);

                        /* END IF */


                     body.instructions = f12AB_parent_instructions;
                     body.emit(f12AB);

                     /* END IF */


                  body.instructions = f12A1_parent_instructions;
                  body.emit(f12A1);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f12CA = new(mem_ctx) ir_if(operand(r129D).val);
                  exec_list *const f12CA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f12CA->then_instructions;

                     /* IF CONDITION */
                     ir_if *f12CB = new(mem_ctx) ir_if(operand(r129F).val);
                     exec_list *const f12CB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f12CB->then_instructions;

                        ir_variable *const r12CC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r12CC, add(r129B, body.constant(1u)), 0x01));

                        ir_expression *const r12CD = less(r12CC, r129B);
                        ir_expression *const r12CE = expr(ir_unop_b2i, r12CD);
                        ir_expression *const r12CF = expr(ir_unop_i2u, r12CE);
                        body.emit(assign(r129A, add(r129A, r12CF), 0x01));

                        ir_expression *const r12D0 = equal(r129C, body.constant(0u));
                        ir_expression *const r12D1 = expr(ir_unop_b2i, r12D0);
                        ir_expression *const r12D2 = expr(ir_unop_i2u, r12D1);
                        ir_expression *const r12D3 = add(r129C, r12D2);
                        ir_expression *const r12D4 = bit_and(r12D3, body.constant(1u));
                        ir_expression *const r12D5 = expr(ir_unop_bit_not, r12D4);
                        body.emit(assign(r129B, bit_and(r12CC, r12D5), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f12CB->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r12D7 = bit_or(r129A, r129B);
                        ir_expression *const r12D8 = equal(r12D7, body.constant(0u));
                        ir_if *f12D6 = new(mem_ctx) ir_if(operand(r12D8).val);
                        exec_list *const f12D6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f12D6->then_instructions;

                           body.emit(assign(r1299, body.constant(int(0)), 0x01));


                        body.instructions = f12D6_parent_instructions;
                        body.emit(f12D6);

                        /* END IF */


                     body.instructions = f12CB_parent_instructions;
                     body.emit(f12CB);

                     /* END IF */

                     ir_variable *const r12D9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r12D9);
                     ir_expression *const r12DA = lshift(r0DB4, body.constant(int(31)));
                     ir_expression *const r12DB = expr(ir_unop_i2u, r1299);
                     ir_expression *const r12DC = lshift(r12DB, body.constant(int(20)));
                     ir_expression *const r12DD = add(r12DA, r12DC);
                     body.emit(assign(r12D9, add(r12DD, r129A), 0x02));

                     body.emit(assign(r12D9, r129B, 0x01));

                     body.emit(assign(r129E, r12D9, 0x03));

                     body.emit(assign(r129D, body.constant(false), 0x01));


                  body.instructions = f12CA_parent_instructions;
                  body.emit(f12CA);

                  /* END IF */

                  body.emit(assign(r11D1, r129E, 0x03));

                  body.emit(assign(r11D0, body.constant(false), 0x01));


               body.instructions = f1290_parent_instructions;
               body.emit(f1290);

               /* END IF */


            body.instructions = f1266_parent_instructions;
            body.emit(f1266);

            /* END IF */


         body.instructions = f1222_parent_instructions;
         body.emit(f1222);

         /* END IF */


      body.instructions = f11E1_parent_instructions;
      body.emit(f11E1);

      /* END IF */

      /* IF CONDITION */
      ir_if *f12DE = new(mem_ctx) ir_if(operand(r11D0).val);
      exec_list *const f12DE_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f12DE->then_instructions;

         body.emit(assign(r11D4, bit_or(swizzle_y(r11D4), body.constant(1048576u)), 0x02));

         ir_variable *const r12DF = body.make_temp(glsl_type::uint_type, "z0Ptr");
         ir_variable *const r12E0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r12E0, add(swizzle_x(r11D4), swizzle_x(r11D3)), 0x01));

         ir_expression *const r12E1 = add(swizzle_y(r11D4), swizzle_y(r11D3));
         ir_expression *const r12E2 = less(r12E0, swizzle_x(r11D4));
         ir_expression *const r12E3 = expr(ir_unop_b2i, r12E2);
         ir_expression *const r12E4 = expr(ir_unop_i2u, r12E3);
         body.emit(assign(r12DF, add(r12E1, r12E4), 0x01));

         body.emit(assign(r11D7, r12DF, 0x01));

         body.emit(assign(r11D5, add(r11D5, body.constant(int(-1))), 0x01));

         /* IF CONDITION */
         ir_expression *const r12E6 = less(r12DF, body.constant(2097152u));
         ir_if *f12E5 = new(mem_ctx) ir_if(operand(r12E6).val);
         exec_list *const f12E5_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f12E5->then_instructions;

            ir_variable *const r12E7 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r12E7, r11D5, 0x01));

            ir_variable *const r12E8 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r12E8, r12DF, 0x01));

            ir_variable *const r12E9 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r12E9, r12E0, 0x01));

            ir_variable *const r12EA = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r12EA, r11D6, 0x01));

            ir_variable *const r12EB = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r12EB, body.constant(true), 0x01));

            ir_variable *const r12EC = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r12ED = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r12ED);
            ir_expression *const r12EE = expr(ir_unop_u2i, r11D6);
            body.emit(assign(r12ED, less(r12EE, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r12F0 = lequal(body.constant(int(2045)), r11D5);
            ir_if *f12EF = new(mem_ctx) ir_if(operand(r12F0).val);
            exec_list *const f12EF_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f12EF->then_instructions;

               ir_variable *const r12F1 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r12F3 = less(body.constant(int(2045)), r11D5);
               ir_if *f12F2 = new(mem_ctx) ir_if(operand(r12F3).val);
               exec_list *const f12F2_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f12F2->then_instructions;

                  body.emit(assign(r12F1, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f12F2->else_instructions;

                  ir_variable *const r12F4 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r12F6 = equal(r11D5, body.constant(int(2045)));
                  ir_if *f12F5 = new(mem_ctx) ir_if(operand(r12F6).val);
                  exec_list *const f12F5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f12F5->then_instructions;

                     ir_expression *const r12F7 = equal(body.constant(2097151u), r12DF);
                     ir_expression *const r12F8 = equal(body.constant(4294967295u), r12E0);
                     body.emit(assign(r12F4, logic_and(r12F7, r12F8), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f12F5->else_instructions;

                     body.emit(assign(r12F4, body.constant(false), 0x01));


                  body.instructions = f12F5_parent_instructions;
                  body.emit(f12F5);

                  /* END IF */

                  body.emit(assign(r12F1, logic_and(r12F4, r12ED), 0x01));


               body.instructions = f12F2_parent_instructions;
               body.emit(f12F2);

               /* END IF */

               /* IF CONDITION */
               ir_if *f12F9 = new(mem_ctx) ir_if(operand(r12F1).val);
               exec_list *const f12F9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f12F9->then_instructions;

                  ir_variable *const r12FA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r12FA);
                  ir_expression *const r12FB = lshift(r0DB4, body.constant(int(31)));
                  body.emit(assign(r12FA, add(r12FB, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r12FA, body.constant(0u), 0x01));

                  body.emit(assign(r12EC, r12FA, 0x03));

                  body.emit(assign(r12EB, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f12F9->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r12FD = less(r11D5, body.constant(int(0)));
                  ir_if *f12FC = new(mem_ctx) ir_if(operand(r12FD).val);
                  exec_list *const f12FC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f12FC->then_instructions;

                     ir_variable *const r12FE = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r12FE, r11D6, 0x01));

                     ir_variable *const r12FF = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r12FF, neg(r11D5), 0x01));

                     ir_variable *const r1300 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r1300);
                     ir_variable *const r1301 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r1301);
                     ir_variable *const r1302 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r1302);
                     ir_variable *const r1303 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r1304 = neg(r12FF);
                     body.emit(assign(r1303, bit_and(r1304, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1306 = equal(r12FF, body.constant(int(0)));
                     ir_if *f1305 = new(mem_ctx) ir_if(operand(r1306).val);
                     exec_list *const f1305_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1305->then_instructions;

                        body.emit(assign(r1300, r11D6, 0x01));

                        body.emit(assign(r1301, r12E0, 0x01));

                        body.emit(assign(r1302, r12DF, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1305->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1308 = less(r12FF, body.constant(int(32)));
                        ir_if *f1307 = new(mem_ctx) ir_if(operand(r1308).val);
                        exec_list *const f1307_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1307->then_instructions;

                           body.emit(assign(r1300, lshift(r12E0, r1303), 0x01));

                           ir_expression *const r1309 = lshift(r12DF, r1303);
                           ir_expression *const r130A = rshift(r12E0, r12FF);
                           body.emit(assign(r1301, bit_or(r1309, r130A), 0x01));

                           body.emit(assign(r1302, rshift(r12DF, r12FF), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1307->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r130C = equal(r12FF, body.constant(int(32)));
                           ir_if *f130B = new(mem_ctx) ir_if(operand(r130C).val);
                           exec_list *const f130B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f130B->then_instructions;

                              body.emit(assign(r1300, r12E0, 0x01));

                              body.emit(assign(r1301, r12DF, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f130B->else_instructions;

                              body.emit(assign(r12FE, bit_or(r11D6, r12E0), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r130E = less(r12FF, body.constant(int(64)));
                              ir_if *f130D = new(mem_ctx) ir_if(operand(r130E).val);
                              exec_list *const f130D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f130D->then_instructions;

                                 body.emit(assign(r1300, lshift(r12DF, r1303), 0x01));

                                 ir_expression *const r130F = bit_and(r12FF, body.constant(int(31)));
                                 body.emit(assign(r1301, rshift(r12DF, r130F), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f130D->else_instructions;

                                 ir_variable *const r1310 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r1312 = equal(r12FF, body.constant(int(64)));
                                 ir_if *f1311 = new(mem_ctx) ir_if(operand(r1312).val);
                                 exec_list *const f1311_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1311->then_instructions;

                                    body.emit(assign(r1310, r12DF, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1311->else_instructions;

                                    ir_expression *const r1313 = nequal(r12DF, body.constant(0u));
                                    ir_expression *const r1314 = expr(ir_unop_b2i, r1313);
                                    body.emit(assign(r1310, expr(ir_unop_i2u, r1314), 0x01));


                                 body.instructions = f1311_parent_instructions;
                                 body.emit(f1311);

                                 /* END IF */

                                 body.emit(assign(r1300, r1310, 0x01));

                                 body.emit(assign(r1301, body.constant(0u), 0x01));


                              body.instructions = f130D_parent_instructions;
                              body.emit(f130D);

                              /* END IF */


                           body.instructions = f130B_parent_instructions;
                           body.emit(f130B);

                           /* END IF */

                           body.emit(assign(r1302, body.constant(0u), 0x01));


                        body.instructions = f1307_parent_instructions;
                        body.emit(f1307);

                        /* END IF */

                        ir_expression *const r1315 = nequal(r12FE, body.constant(0u));
                        ir_expression *const r1316 = expr(ir_unop_b2i, r1315);
                        ir_expression *const r1317 = expr(ir_unop_i2u, r1316);
                        body.emit(assign(r1300, bit_or(r1300, r1317), 0x01));


                     body.instructions = f1305_parent_instructions;
                     body.emit(f1305);

                     /* END IF */

                     body.emit(assign(r12E8, r1302, 0x01));

                     body.emit(assign(r12E9, r1301, 0x01));

                     body.emit(assign(r12EA, r1300, 0x01));

                     body.emit(assign(r12E7, body.constant(int(0)), 0x01));

                     body.emit(assign(r12ED, less(r1300, body.constant(0u)), 0x01));


                  body.instructions = f12FC_parent_instructions;
                  body.emit(f12FC);

                  /* END IF */


               body.instructions = f12F9_parent_instructions;
               body.emit(f12F9);

               /* END IF */


            body.instructions = f12EF_parent_instructions;
            body.emit(f12EF);

            /* END IF */

            /* IF CONDITION */
            ir_if *f1318 = new(mem_ctx) ir_if(operand(r12EB).val);
            exec_list *const f1318_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1318->then_instructions;

               /* IF CONDITION */
               ir_if *f1319 = new(mem_ctx) ir_if(operand(r12ED).val);
               exec_list *const f1319_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1319->then_instructions;

                  ir_variable *const r131A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r131A, add(r12E9, body.constant(1u)), 0x01));

                  ir_expression *const r131B = less(r131A, r12E9);
                  ir_expression *const r131C = expr(ir_unop_b2i, r131B);
                  ir_expression *const r131D = expr(ir_unop_i2u, r131C);
                  body.emit(assign(r12E8, add(r12E8, r131D), 0x01));

                  ir_expression *const r131E = equal(r12EA, body.constant(0u));
                  ir_expression *const r131F = expr(ir_unop_b2i, r131E);
                  ir_expression *const r1320 = expr(ir_unop_i2u, r131F);
                  ir_expression *const r1321 = add(r12EA, r1320);
                  ir_expression *const r1322 = bit_and(r1321, body.constant(1u));
                  ir_expression *const r1323 = expr(ir_unop_bit_not, r1322);
                  body.emit(assign(r12E9, bit_and(r131A, r1323), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1319->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1325 = bit_or(r12E8, r12E9);
                  ir_expression *const r1326 = equal(r1325, body.constant(0u));
                  ir_if *f1324 = new(mem_ctx) ir_if(operand(r1326).val);
                  exec_list *const f1324_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1324->then_instructions;

                     body.emit(assign(r12E7, body.constant(int(0)), 0x01));


                  body.instructions = f1324_parent_instructions;
                  body.emit(f1324);

                  /* END IF */


               body.instructions = f1319_parent_instructions;
               body.emit(f1319);

               /* END IF */

               ir_variable *const r1327 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r1327);
               ir_expression *const r1328 = lshift(r0DB4, body.constant(int(31)));
               ir_expression *const r1329 = expr(ir_unop_i2u, r12E7);
               ir_expression *const r132A = lshift(r1329, body.constant(int(20)));
               ir_expression *const r132B = add(r1328, r132A);
               body.emit(assign(r1327, add(r132B, r12E8), 0x02));

               body.emit(assign(r1327, r12E9, 0x01));

               body.emit(assign(r12EC, r1327, 0x03));

               body.emit(assign(r12EB, body.constant(false), 0x01));


            body.instructions = f1318_parent_instructions;
            body.emit(f1318);

            /* END IF */

            body.emit(assign(r11D1, r12EC, 0x03));

            body.emit(assign(r11D0, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f12E5->else_instructions;

            body.emit(assign(r11D5, add(r11D5, body.constant(int(1))), 0x01));

            ir_variable *const r132C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r132C);
            ir_variable *const r132D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r132D);
            ir_variable *const r132E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r132E);
            body.emit(assign(r132C, lshift(r12E0, body.constant(int(31))), 0x01));

            ir_expression *const r132F = lshift(r12DF, body.constant(int(31)));
            ir_expression *const r1330 = rshift(r12E0, body.constant(int(1)));
            body.emit(assign(r132D, bit_or(r132F, r1330), 0x01));

            body.emit(assign(r132E, rshift(r12DF, body.constant(int(1))), 0x01));

            ir_expression *const r1331 = nequal(r11D6, body.constant(0u));
            ir_expression *const r1332 = expr(ir_unop_b2i, r1331);
            ir_expression *const r1333 = expr(ir_unop_i2u, r1332);
            body.emit(assign(r132C, bit_or(r132C, r1333), 0x01));

            body.emit(assign(r11D7, r132E, 0x01));

            body.emit(assign(r11D6, r132C, 0x01));

            ir_variable *const r1334 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r1334, r11D5, 0x01));

            ir_variable *const r1335 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r1335, r132E, 0x01));

            ir_variable *const r1336 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r1336, r132D, 0x01));

            ir_variable *const r1337 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r1337, r132C, 0x01));

            ir_variable *const r1338 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r1338, body.constant(true), 0x01));

            ir_variable *const r1339 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r133A = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r133A);
            ir_expression *const r133B = expr(ir_unop_u2i, r132C);
            body.emit(assign(r133A, less(r133B, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r133D = lequal(body.constant(int(2045)), r11D5);
            ir_if *f133C = new(mem_ctx) ir_if(operand(r133D).val);
            exec_list *const f133C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f133C->then_instructions;

               ir_variable *const r133E = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r1340 = less(body.constant(int(2045)), r11D5);
               ir_if *f133F = new(mem_ctx) ir_if(operand(r1340).val);
               exec_list *const f133F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f133F->then_instructions;

                  body.emit(assign(r133E, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f133F->else_instructions;

                  ir_variable *const r1341 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1343 = equal(r11D5, body.constant(int(2045)));
                  ir_if *f1342 = new(mem_ctx) ir_if(operand(r1343).val);
                  exec_list *const f1342_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1342->then_instructions;

                     ir_expression *const r1344 = equal(body.constant(2097151u), r132E);
                     ir_expression *const r1345 = equal(body.constant(4294967295u), r132D);
                     body.emit(assign(r1341, logic_and(r1344, r1345), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1342->else_instructions;

                     body.emit(assign(r1341, body.constant(false), 0x01));


                  body.instructions = f1342_parent_instructions;
                  body.emit(f1342);

                  /* END IF */

                  body.emit(assign(r133E, logic_and(r1341, r133A), 0x01));


               body.instructions = f133F_parent_instructions;
               body.emit(f133F);

               /* END IF */

               /* IF CONDITION */
               ir_if *f1346 = new(mem_ctx) ir_if(operand(r133E).val);
               exec_list *const f1346_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1346->then_instructions;

                  ir_variable *const r1347 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1347);
                  ir_expression *const r1348 = lshift(r0DB4, body.constant(int(31)));
                  body.emit(assign(r1347, add(r1348, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r1347, body.constant(0u), 0x01));

                  body.emit(assign(r1339, r1347, 0x03));

                  body.emit(assign(r1338, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1346->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r134A = less(r11D5, body.constant(int(0)));
                  ir_if *f1349 = new(mem_ctx) ir_if(operand(r134A).val);
                  exec_list *const f1349_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1349->then_instructions;

                     ir_variable *const r134B = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r134B, r132C, 0x01));

                     ir_variable *const r134C = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r134C, neg(r11D5), 0x01));

                     ir_variable *const r134D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r134D);
                     ir_variable *const r134E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r134E);
                     ir_variable *const r134F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r134F);
                     ir_variable *const r1350 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r1351 = neg(r134C);
                     body.emit(assign(r1350, bit_and(r1351, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1353 = equal(r134C, body.constant(int(0)));
                     ir_if *f1352 = new(mem_ctx) ir_if(operand(r1353).val);
                     exec_list *const f1352_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1352->then_instructions;

                        body.emit(assign(r134D, r132C, 0x01));

                        body.emit(assign(r134E, r132D, 0x01));

                        body.emit(assign(r134F, r132E, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1352->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1355 = less(r134C, body.constant(int(32)));
                        ir_if *f1354 = new(mem_ctx) ir_if(operand(r1355).val);
                        exec_list *const f1354_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1354->then_instructions;

                           body.emit(assign(r134D, lshift(r132D, r1350), 0x01));

                           ir_expression *const r1356 = lshift(r132E, r1350);
                           ir_expression *const r1357 = rshift(r132D, r134C);
                           body.emit(assign(r134E, bit_or(r1356, r1357), 0x01));

                           body.emit(assign(r134F, rshift(r132E, r134C), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1354->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1359 = equal(r134C, body.constant(int(32)));
                           ir_if *f1358 = new(mem_ctx) ir_if(operand(r1359).val);
                           exec_list *const f1358_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1358->then_instructions;

                              body.emit(assign(r134D, r132D, 0x01));

                              body.emit(assign(r134E, r132E, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1358->else_instructions;

                              body.emit(assign(r134B, bit_or(r132C, r132D), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r135B = less(r134C, body.constant(int(64)));
                              ir_if *f135A = new(mem_ctx) ir_if(operand(r135B).val);
                              exec_list *const f135A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f135A->then_instructions;

                                 body.emit(assign(r134D, lshift(r132E, r1350), 0x01));

                                 ir_expression *const r135C = bit_and(r134C, body.constant(int(31)));
                                 body.emit(assign(r134E, rshift(r132E, r135C), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f135A->else_instructions;

                                 ir_variable *const r135D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r135F = equal(r134C, body.constant(int(64)));
                                 ir_if *f135E = new(mem_ctx) ir_if(operand(r135F).val);
                                 exec_list *const f135E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f135E->then_instructions;

                                    body.emit(assign(r135D, r132E, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f135E->else_instructions;

                                    ir_expression *const r1360 = nequal(r132E, body.constant(0u));
                                    ir_expression *const r1361 = expr(ir_unop_b2i, r1360);
                                    body.emit(assign(r135D, expr(ir_unop_i2u, r1361), 0x01));


                                 body.instructions = f135E_parent_instructions;
                                 body.emit(f135E);

                                 /* END IF */

                                 body.emit(assign(r134D, r135D, 0x01));

                                 body.emit(assign(r134E, body.constant(0u), 0x01));


                              body.instructions = f135A_parent_instructions;
                              body.emit(f135A);

                              /* END IF */


                           body.instructions = f1358_parent_instructions;
                           body.emit(f1358);

                           /* END IF */

                           body.emit(assign(r134F, body.constant(0u), 0x01));


                        body.instructions = f1354_parent_instructions;
                        body.emit(f1354);

                        /* END IF */

                        ir_expression *const r1362 = nequal(r134B, body.constant(0u));
                        ir_expression *const r1363 = expr(ir_unop_b2i, r1362);
                        ir_expression *const r1364 = expr(ir_unop_i2u, r1363);
                        body.emit(assign(r134D, bit_or(r134D, r1364), 0x01));


                     body.instructions = f1352_parent_instructions;
                     body.emit(f1352);

                     /* END IF */

                     body.emit(assign(r1335, r134F, 0x01));

                     body.emit(assign(r1336, r134E, 0x01));

                     body.emit(assign(r1337, r134D, 0x01));

                     body.emit(assign(r1334, body.constant(int(0)), 0x01));

                     body.emit(assign(r133A, less(r134D, body.constant(0u)), 0x01));


                  body.instructions = f1349_parent_instructions;
                  body.emit(f1349);

                  /* END IF */


               body.instructions = f1346_parent_instructions;
               body.emit(f1346);

               /* END IF */


            body.instructions = f133C_parent_instructions;
            body.emit(f133C);

            /* END IF */

            /* IF CONDITION */
            ir_if *f1365 = new(mem_ctx) ir_if(operand(r1338).val);
            exec_list *const f1365_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1365->then_instructions;

               /* IF CONDITION */
               ir_if *f1366 = new(mem_ctx) ir_if(operand(r133A).val);
               exec_list *const f1366_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1366->then_instructions;

                  ir_variable *const r1367 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1367, add(r1336, body.constant(1u)), 0x01));

                  ir_expression *const r1368 = less(r1367, r1336);
                  ir_expression *const r1369 = expr(ir_unop_b2i, r1368);
                  ir_expression *const r136A = expr(ir_unop_i2u, r1369);
                  body.emit(assign(r1335, add(r1335, r136A), 0x01));

                  ir_expression *const r136B = equal(r1337, body.constant(0u));
                  ir_expression *const r136C = expr(ir_unop_b2i, r136B);
                  ir_expression *const r136D = expr(ir_unop_i2u, r136C);
                  ir_expression *const r136E = add(r1337, r136D);
                  ir_expression *const r136F = bit_and(r136E, body.constant(1u));
                  ir_expression *const r1370 = expr(ir_unop_bit_not, r136F);
                  body.emit(assign(r1336, bit_and(r1367, r1370), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1366->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1372 = bit_or(r1335, r1336);
                  ir_expression *const r1373 = equal(r1372, body.constant(0u));
                  ir_if *f1371 = new(mem_ctx) ir_if(operand(r1373).val);
                  exec_list *const f1371_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1371->then_instructions;

                     body.emit(assign(r1334, body.constant(int(0)), 0x01));


                  body.instructions = f1371_parent_instructions;
                  body.emit(f1371);

                  /* END IF */


               body.instructions = f1366_parent_instructions;
               body.emit(f1366);

               /* END IF */

               ir_variable *const r1374 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r1374);
               ir_expression *const r1375 = lshift(r0DB4, body.constant(int(31)));
               ir_expression *const r1376 = expr(ir_unop_i2u, r1334);
               ir_expression *const r1377 = lshift(r1376, body.constant(int(20)));
               ir_expression *const r1378 = add(r1375, r1377);
               body.emit(assign(r1374, add(r1378, r1335), 0x02));

               body.emit(assign(r1374, r1336, 0x01));

               body.emit(assign(r1339, r1374, 0x03));

               body.emit(assign(r1338, body.constant(false), 0x01));


            body.instructions = f1365_parent_instructions;
            body.emit(f1365);

            /* END IF */

            body.emit(assign(r11D1, r1339, 0x03));

            body.emit(assign(r11D0, body.constant(false), 0x01));


         body.instructions = f12E5_parent_instructions;
         body.emit(f12E5);

         /* END IF */


      body.instructions = f12DE_parent_instructions;
      body.emit(f12DE);

      /* END IF */

      body.emit(assign(r0DB3, r11D1, 0x03));


   body.instructions = f0DB6_parent_instructions;
   body.emit(f0DB6);

   /* END IF */

   body.emit(ret(r0DB3));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
mul32To64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1379 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1379);
   ir_variable *const r137A = new(mem_ctx) ir_variable(glsl_type::uint_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r137A);
   ir_variable *const r137B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r137B);
   ir_variable *const r137C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r137C);
   ir_variable *const r137D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r137D);
   ir_variable *const r137E = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r137E);
   ir_variable *const r137F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r137F);
   ir_variable *const r1380 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1380, bit_and(r1379, body.constant(65535u)), 0x01));

   ir_variable *const r1381 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1381, rshift(r1379, body.constant(int(16))), 0x01));

   ir_variable *const r1382 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1382, bit_and(r137A, body.constant(65535u)), 0x01));

   ir_variable *const r1383 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1383, rshift(r137A, body.constant(int(16))), 0x01));

   ir_variable *const r1384 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1384, mul(r1381, r1382), 0x01));

   ir_expression *const r1385 = mul(r1380, r1383);
   body.emit(assign(r137E, add(r1385, r1384), 0x01));

   ir_expression *const r1386 = mul(r1381, r1383);
   ir_expression *const r1387 = less(r137E, r1384);
   ir_expression *const r1388 = expr(ir_unop_b2i, r1387);
   ir_expression *const r1389 = expr(ir_unop_i2u, r1388);
   ir_expression *const r138A = lshift(r1389, body.constant(int(16)));
   ir_expression *const r138B = rshift(r137E, body.constant(int(16)));
   ir_expression *const r138C = add(r138A, r138B);
   body.emit(assign(r137D, add(r1386, r138C), 0x01));

   body.emit(assign(r137E, lshift(r137E, body.constant(int(16))), 0x01));

   ir_expression *const r138D = mul(r1380, r1382);
   body.emit(assign(r137F, add(r138D, r137E), 0x01));

   ir_expression *const r138E = less(r137F, r137E);
   ir_expression *const r138F = expr(ir_unop_b2i, r138E);
   ir_expression *const r1390 = expr(ir_unop_i2u, r138F);
   body.emit(assign(r137D, add(r137D, r1390), 0x01));

   body.emit(assign(r137C, r137F, 0x01));

   body.emit(assign(r137B, r137D, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
mul64To128(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1391 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r1391);
   ir_variable *const r1392 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r1392);
   ir_variable *const r1393 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r1393);
   ir_variable *const r1394 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r1394);
   ir_variable *const r1395 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1395);
   ir_variable *const r1396 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1396);
   ir_variable *const r1397 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1397);
   ir_variable *const r1398 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z3Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1398);
   ir_variable *const r1399 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r1399);
   ir_variable *const r139A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r139A);
   ir_variable *const r139B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r139B);
   ir_variable *const r139C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r139C, bit_and(r1392, body.constant(65535u)), 0x01));

   ir_variable *const r139D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r139D, rshift(r1392, body.constant(int(16))), 0x01));

   ir_variable *const r139E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r139E, bit_and(r1394, body.constant(65535u)), 0x01));

   ir_variable *const r139F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r139F, rshift(r1394, body.constant(int(16))), 0x01));

   ir_variable *const r13A0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13A0, mul(r139D, r139E), 0x01));

   ir_expression *const r13A1 = mul(r139C, r139F);
   body.emit(assign(r139A, add(r13A1, r13A0), 0x01));

   ir_expression *const r13A2 = mul(r139D, r139F);
   ir_expression *const r13A3 = less(r139A, r13A0);
   ir_expression *const r13A4 = expr(ir_unop_b2i, r13A3);
   ir_expression *const r13A5 = expr(ir_unop_i2u, r13A4);
   ir_expression *const r13A6 = lshift(r13A5, body.constant(int(16)));
   ir_expression *const r13A7 = rshift(r139A, body.constant(int(16)));
   ir_expression *const r13A8 = add(r13A6, r13A7);
   body.emit(assign(r1399, add(r13A2, r13A8), 0x01));

   body.emit(assign(r139A, lshift(r139A, body.constant(int(16))), 0x01));

   ir_expression *const r13A9 = mul(r139C, r139E);
   body.emit(assign(r139B, add(r13A9, r139A), 0x01));

   ir_expression *const r13AA = less(r139B, r139A);
   ir_expression *const r13AB = expr(ir_unop_b2i, r13AA);
   ir_expression *const r13AC = expr(ir_unop_i2u, r13AB);
   body.emit(assign(r1399, add(r1399, r13AC), 0x01));

   ir_variable *const r13AD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r13AD);
   ir_variable *const r13AE = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r13AE);
   ir_variable *const r13AF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r13AF);
   ir_variable *const r13B0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13B0, bit_and(r1392, body.constant(65535u)), 0x01));

   ir_variable *const r13B1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13B1, rshift(r1392, body.constant(int(16))), 0x01));

   ir_variable *const r13B2 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13B2, bit_and(r1393, body.constant(65535u)), 0x01));

   ir_variable *const r13B3 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13B3, rshift(r1393, body.constant(int(16))), 0x01));

   ir_variable *const r13B4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13B4, mul(r13B1, r13B2), 0x01));

   ir_expression *const r13B5 = mul(r13B0, r13B3);
   body.emit(assign(r13AE, add(r13B5, r13B4), 0x01));

   ir_expression *const r13B6 = mul(r13B1, r13B3);
   ir_expression *const r13B7 = less(r13AE, r13B4);
   ir_expression *const r13B8 = expr(ir_unop_b2i, r13B7);
   ir_expression *const r13B9 = expr(ir_unop_i2u, r13B8);
   ir_expression *const r13BA = lshift(r13B9, body.constant(int(16)));
   ir_expression *const r13BB = rshift(r13AE, body.constant(int(16)));
   ir_expression *const r13BC = add(r13BA, r13BB);
   body.emit(assign(r13AD, add(r13B6, r13BC), 0x01));

   body.emit(assign(r13AE, lshift(r13AE, body.constant(int(16))), 0x01));

   ir_expression *const r13BD = mul(r13B0, r13B2);
   body.emit(assign(r13AF, add(r13BD, r13AE), 0x01));

   ir_expression *const r13BE = less(r13AF, r13AE);
   ir_expression *const r13BF = expr(ir_unop_b2i, r13BE);
   ir_expression *const r13C0 = expr(ir_unop_i2u, r13BF);
   body.emit(assign(r13AD, add(r13AD, r13C0), 0x01));

   ir_variable *const r13C1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13C1, add(r13AF, r1399), 0x01));

   ir_variable *const r13C2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r13C2);
   ir_variable *const r13C3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r13C3);
   ir_variable *const r13C4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r13C4);
   ir_variable *const r13C5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13C5, bit_and(r1391, body.constant(65535u)), 0x01));

   ir_variable *const r13C6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13C6, rshift(r1391, body.constant(int(16))), 0x01));

   ir_variable *const r13C7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13C7, bit_and(r1393, body.constant(65535u)), 0x01));

   ir_variable *const r13C8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13C8, rshift(r1393, body.constant(int(16))), 0x01));

   ir_variable *const r13C9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13C9, mul(r13C6, r13C7), 0x01));

   ir_expression *const r13CA = mul(r13C5, r13C8);
   body.emit(assign(r13C3, add(r13CA, r13C9), 0x01));

   ir_expression *const r13CB = mul(r13C6, r13C8);
   ir_expression *const r13CC = less(r13C3, r13C9);
   ir_expression *const r13CD = expr(ir_unop_b2i, r13CC);
   ir_expression *const r13CE = expr(ir_unop_i2u, r13CD);
   ir_expression *const r13CF = lshift(r13CE, body.constant(int(16)));
   ir_expression *const r13D0 = rshift(r13C3, body.constant(int(16)));
   ir_expression *const r13D1 = add(r13CF, r13D0);
   body.emit(assign(r13C2, add(r13CB, r13D1), 0x01));

   body.emit(assign(r13C3, lshift(r13C3, body.constant(int(16))), 0x01));

   ir_expression *const r13D2 = mul(r13C5, r13C7);
   body.emit(assign(r13C4, add(r13D2, r13C3), 0x01));

   ir_expression *const r13D3 = less(r13C4, r13C3);
   ir_expression *const r13D4 = expr(ir_unop_b2i, r13D3);
   ir_expression *const r13D5 = expr(ir_unop_i2u, r13D4);
   body.emit(assign(r13C2, add(r13C2, r13D5), 0x01));

   ir_variable *const r13D6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   ir_expression *const r13D7 = less(r13C1, r13AF);
   ir_expression *const r13D8 = expr(ir_unop_b2i, r13D7);
   ir_expression *const r13D9 = expr(ir_unop_i2u, r13D8);
   ir_expression *const r13DA = add(r13AD, r13D9);
   body.emit(assign(r13D6, add(r13C4, r13DA), 0x01));

   ir_variable *const r13DB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r13DB);
   ir_variable *const r13DC = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r13DC);
   ir_variable *const r13DD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r13DD);
   ir_variable *const r13DE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13DE, bit_and(r1391, body.constant(65535u)), 0x01));

   ir_variable *const r13DF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13DF, rshift(r1391, body.constant(int(16))), 0x01));

   ir_variable *const r13E0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13E0, bit_and(r1394, body.constant(65535u)), 0x01));

   ir_variable *const r13E1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13E1, rshift(r1394, body.constant(int(16))), 0x01));

   ir_variable *const r13E2 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13E2, mul(r13DF, r13E0), 0x01));

   ir_expression *const r13E3 = mul(r13DE, r13E1);
   body.emit(assign(r13DC, add(r13E3, r13E2), 0x01));

   ir_expression *const r13E4 = mul(r13DF, r13E1);
   ir_expression *const r13E5 = less(r13DC, r13E2);
   ir_expression *const r13E6 = expr(ir_unop_b2i, r13E5);
   ir_expression *const r13E7 = expr(ir_unop_i2u, r13E6);
   ir_expression *const r13E8 = lshift(r13E7, body.constant(int(16)));
   ir_expression *const r13E9 = rshift(r13DC, body.constant(int(16)));
   ir_expression *const r13EA = add(r13E8, r13E9);
   body.emit(assign(r13DB, add(r13E4, r13EA), 0x01));

   body.emit(assign(r13DC, lshift(r13DC, body.constant(int(16))), 0x01));

   ir_expression *const r13EB = mul(r13DE, r13E0);
   body.emit(assign(r13DD, add(r13EB, r13DC), 0x01));

   ir_expression *const r13EC = less(r13DD, r13DC);
   ir_expression *const r13ED = expr(ir_unop_b2i, r13EC);
   ir_expression *const r13EE = expr(ir_unop_i2u, r13ED);
   body.emit(assign(r13DB, add(r13DB, r13EE), 0x01));

   ir_variable *const r13EF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r13EF, add(r13DD, r13C1), 0x01));

   ir_variable *const r13F0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   ir_expression *const r13F1 = less(r13EF, r13DD);
   ir_expression *const r13F2 = expr(ir_unop_b2i, r13F1);
   ir_expression *const r13F3 = expr(ir_unop_i2u, r13F2);
   ir_expression *const r13F4 = add(r13DB, r13F3);
   body.emit(assign(r13F0, add(r13D6, r13F4), 0x01));

   body.emit(assign(r1398, r139B, 0x01));

   body.emit(assign(r1397, r13EF, 0x01));

   body.emit(assign(r1396, r13F0, 0x01));

   ir_expression *const r13F5 = less(r13D6, r13C4);
   ir_expression *const r13F6 = expr(ir_unop_b2i, r13F5);
   ir_expression *const r13F7 = expr(ir_unop_i2u, r13F6);
   ir_expression *const r13F8 = add(r13C2, r13F7);
   ir_expression *const r13F9 = less(r13F0, r13D6);
   ir_expression *const r13FA = expr(ir_unop_b2i, r13F9);
   ir_expression *const r13FB = expr(ir_unop_i2u, r13FA);
   body.emit(assign(r1395, add(r13F8, r13FB), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
normalizeFloat64Subnormal(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r13FC = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac0", ir_var_function_in);
   sig_parameters.push_tail(r13FC);
   ir_variable *const r13FD = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac1", ir_var_function_in);
   sig_parameters.push_tail(r13FD);
   ir_variable *const r13FE = new(mem_ctx) ir_variable(glsl_type::int_type, "zExpPtr", ir_var_function_inout);
   sig_parameters.push_tail(r13FE);
   ir_variable *const r13FF = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r13FF);
   ir_variable *const r1400 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1400);
   ir_variable *const r1401 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r1401);
   /* IF CONDITION */
   ir_expression *const r1403 = equal(r13FC, body.constant(0u));
   ir_if *f1402 = new(mem_ctx) ir_if(operand(r1403).val);
   exec_list *const f1402_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1402->then_instructions;

      ir_variable *const r1404 = body.make_temp(glsl_type::uint_type, "a");
      body.emit(assign(r1404, r13FD, 0x01));

      ir_variable *const r1405 = body.make_temp(glsl_type::int_type, "return_value");
      ir_variable *const r1406 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
      body.emit(r1406);
      /* IF CONDITION */
      ir_expression *const r1408 = equal(r13FD, body.constant(0u));
      ir_if *f1407 = new(mem_ctx) ir_if(operand(r1408).val);
      exec_list *const f1407_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1407->then_instructions;

         body.emit(assign(r1405, body.constant(int(32)), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1407->else_instructions;

         body.emit(assign(r1406, body.constant(int(0)), 0x01));

         /* IF CONDITION */
         ir_expression *const r140A = bit_and(r13FD, body.constant(4294901760u));
         ir_expression *const r140B = equal(r140A, body.constant(0u));
         ir_if *f1409 = new(mem_ctx) ir_if(operand(r140B).val);
         exec_list *const f1409_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1409->then_instructions;

            body.emit(assign(r1406, body.constant(int(16)), 0x01));

            body.emit(assign(r1404, lshift(r13FD, body.constant(int(16))), 0x01));


         body.instructions = f1409_parent_instructions;
         body.emit(f1409);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r140D = bit_and(r1404, body.constant(4278190080u));
         ir_expression *const r140E = equal(r140D, body.constant(0u));
         ir_if *f140C = new(mem_ctx) ir_if(operand(r140E).val);
         exec_list *const f140C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f140C->then_instructions;

            body.emit(assign(r1406, add(r1406, body.constant(int(8))), 0x01));

            body.emit(assign(r1404, lshift(r1404, body.constant(int(8))), 0x01));


         body.instructions = f140C_parent_instructions;
         body.emit(f140C);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1410 = bit_and(r1404, body.constant(4026531840u));
         ir_expression *const r1411 = equal(r1410, body.constant(0u));
         ir_if *f140F = new(mem_ctx) ir_if(operand(r1411).val);
         exec_list *const f140F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f140F->then_instructions;

            body.emit(assign(r1406, add(r1406, body.constant(int(4))), 0x01));

            body.emit(assign(r1404, lshift(r1404, body.constant(int(4))), 0x01));


         body.instructions = f140F_parent_instructions;
         body.emit(f140F);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1413 = bit_and(r1404, body.constant(3221225472u));
         ir_expression *const r1414 = equal(r1413, body.constant(0u));
         ir_if *f1412 = new(mem_ctx) ir_if(operand(r1414).val);
         exec_list *const f1412_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1412->then_instructions;

            body.emit(assign(r1406, add(r1406, body.constant(int(2))), 0x01));

            body.emit(assign(r1404, lshift(r1404, body.constant(int(2))), 0x01));


         body.instructions = f1412_parent_instructions;
         body.emit(f1412);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1416 = bit_and(r1404, body.constant(2147483648u));
         ir_expression *const r1417 = equal(r1416, body.constant(0u));
         ir_if *f1415 = new(mem_ctx) ir_if(operand(r1417).val);
         exec_list *const f1415_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1415->then_instructions;

            body.emit(assign(r1406, add(r1406, body.constant(int(1))), 0x01));


         body.instructions = f1415_parent_instructions;
         body.emit(f1415);

         /* END IF */

         body.emit(assign(r1405, r1406, 0x01));


      body.instructions = f1407_parent_instructions;
      body.emit(f1407);

      /* END IF */

      body.emit(assign(r1401, add(r1405, body.constant(int(-11))), 0x01));

      /* IF CONDITION */
      ir_expression *const r1419 = less(r1401, body.constant(int(0)));
      ir_if *f1418 = new(mem_ctx) ir_if(operand(r1419).val);
      exec_list *const f1418_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1418->then_instructions;

         ir_expression *const r141A = neg(r1401);
         body.emit(assign(r13FF, rshift(r13FD, r141A), 0x01));

         ir_expression *const r141B = bit_and(r1401, body.constant(int(31)));
         body.emit(assign(r1400, lshift(r13FD, r141B), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1418->else_instructions;

         body.emit(assign(r13FF, lshift(r13FD, r1401), 0x01));

         body.emit(assign(r1400, body.constant(0u), 0x01));


      body.instructions = f1418_parent_instructions;
      body.emit(f1418);

      /* END IF */

      body.emit(assign(r13FE, sub(body.constant(int(-31)), r1401), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1402->else_instructions;

      ir_variable *const r141C = body.make_temp(glsl_type::uint_type, "a");
      body.emit(assign(r141C, r13FC, 0x01));

      ir_variable *const r141D = body.make_temp(glsl_type::int_type, "return_value");
      ir_variable *const r141E = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
      body.emit(r141E);
      /* IF CONDITION */
      ir_expression *const r1420 = equal(r13FC, body.constant(0u));
      ir_if *f141F = new(mem_ctx) ir_if(operand(r1420).val);
      exec_list *const f141F_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f141F->then_instructions;

         body.emit(assign(r141D, body.constant(int(32)), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f141F->else_instructions;

         body.emit(assign(r141E, body.constant(int(0)), 0x01));

         /* IF CONDITION */
         ir_expression *const r1422 = bit_and(r13FC, body.constant(4294901760u));
         ir_expression *const r1423 = equal(r1422, body.constant(0u));
         ir_if *f1421 = new(mem_ctx) ir_if(operand(r1423).val);
         exec_list *const f1421_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1421->then_instructions;

            body.emit(assign(r141E, body.constant(int(16)), 0x01));

            body.emit(assign(r141C, lshift(r13FC, body.constant(int(16))), 0x01));


         body.instructions = f1421_parent_instructions;
         body.emit(f1421);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1425 = bit_and(r141C, body.constant(4278190080u));
         ir_expression *const r1426 = equal(r1425, body.constant(0u));
         ir_if *f1424 = new(mem_ctx) ir_if(operand(r1426).val);
         exec_list *const f1424_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1424->then_instructions;

            body.emit(assign(r141E, add(r141E, body.constant(int(8))), 0x01));

            body.emit(assign(r141C, lshift(r141C, body.constant(int(8))), 0x01));


         body.instructions = f1424_parent_instructions;
         body.emit(f1424);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1428 = bit_and(r141C, body.constant(4026531840u));
         ir_expression *const r1429 = equal(r1428, body.constant(0u));
         ir_if *f1427 = new(mem_ctx) ir_if(operand(r1429).val);
         exec_list *const f1427_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1427->then_instructions;

            body.emit(assign(r141E, add(r141E, body.constant(int(4))), 0x01));

            body.emit(assign(r141C, lshift(r141C, body.constant(int(4))), 0x01));


         body.instructions = f1427_parent_instructions;
         body.emit(f1427);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r142B = bit_and(r141C, body.constant(3221225472u));
         ir_expression *const r142C = equal(r142B, body.constant(0u));
         ir_if *f142A = new(mem_ctx) ir_if(operand(r142C).val);
         exec_list *const f142A_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f142A->then_instructions;

            body.emit(assign(r141E, add(r141E, body.constant(int(2))), 0x01));

            body.emit(assign(r141C, lshift(r141C, body.constant(int(2))), 0x01));


         body.instructions = f142A_parent_instructions;
         body.emit(f142A);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r142E = bit_and(r141C, body.constant(2147483648u));
         ir_expression *const r142F = equal(r142E, body.constant(0u));
         ir_if *f142D = new(mem_ctx) ir_if(operand(r142F).val);
         exec_list *const f142D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f142D->then_instructions;

            body.emit(assign(r141E, add(r141E, body.constant(int(1))), 0x01));


         body.instructions = f142D_parent_instructions;
         body.emit(f142D);

         /* END IF */

         body.emit(assign(r141D, r141E, 0x01));


      body.instructions = f141F_parent_instructions;
      body.emit(f141F);

      /* END IF */

      body.emit(assign(r1401, add(r141D, body.constant(int(-11))), 0x01));

      ir_variable *const r1430 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r1430, lshift(r13FD, r1401), 0x01));

      ir_variable *const r1431 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r1433 = equal(r1401, body.constant(int(0)));
      ir_if *f1432 = new(mem_ctx) ir_if(operand(r1433).val);
      exec_list *const f1432_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1432->then_instructions;

         body.emit(assign(r1431, r13FC, 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1432->else_instructions;

         ir_expression *const r1434 = lshift(r13FC, r1401);
         ir_expression *const r1435 = neg(r1401);
         ir_expression *const r1436 = bit_and(r1435, body.constant(int(31)));
         ir_expression *const r1437 = rshift(r13FD, r1436);
         body.emit(assign(r1431, bit_or(r1434, r1437), 0x01));


      body.instructions = f1432_parent_instructions;
      body.emit(f1432);

      /* END IF */

      body.emit(assign(r13FF, r1431, 0x01));

      body.emit(assign(r1400, r1430, 0x01));

      body.emit(assign(r13FE, sub(body.constant(int(1)), r1401), 0x01));


   body.instructions = f1402_parent_instructions;
   body.emit(f1402);

   /* END IF */

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fmul64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1438 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1438);
   ir_variable *const r1439 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r1439);
   ir_variable *const r143A = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r143A, body.constant(true), 0x01));

   ir_variable *const r143B = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r143C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_auto);
   body.emit(r143C);
   ir_variable *const r143D = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
   body.emit(r143D);
   ir_variable *const r143E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
   body.emit(r143E);
   ir_variable *const r143F = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r143F);
   ir_variable *const r1440 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
   body.emit(r1440);
   ir_variable *const r1441 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r1441);
   ir_variable *const r1442 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
   body.emit(r1442);
   ir_variable *const r1443 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r1443);
   ir_variable *const r1444 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r1444);
   body.emit(assign(r1444, body.constant(0u), 0x01));

   body.emit(assign(r1443, body.constant(0u), 0x01));

   body.emit(assign(r1442, body.constant(0u), 0x01));

   ir_variable *const r1445 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r1445);
   body.emit(assign(r1445, bit_and(swizzle_y(r1438), body.constant(1048575u)), 0x02));

   body.emit(assign(r1445, swizzle_x(r1438), 0x01));

   body.emit(assign(r1440, r1445, 0x03));

   ir_variable *const r1446 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r1447 = rshift(swizzle_y(r1438), body.constant(int(20)));
   ir_expression *const r1448 = bit_and(r1447, body.constant(2047u));
   body.emit(assign(r1446, expr(ir_unop_u2i, r1448), 0x01));

   body.emit(assign(r143F, r1446, 0x01));

   ir_variable *const r1449 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r1449);
   body.emit(assign(r1449, bit_and(swizzle_y(r1439), body.constant(1048575u)), 0x02));

   body.emit(assign(r1449, swizzle_x(r1439), 0x01));

   body.emit(assign(r143E, r1449, 0x03));

   ir_variable *const r144A = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r144B = rshift(swizzle_y(r1439), body.constant(int(20)));
   ir_expression *const r144C = bit_and(r144B, body.constant(2047u));
   body.emit(assign(r144A, expr(ir_unop_u2i, r144C), 0x01));

   body.emit(assign(r143D, r144A, 0x01));

   ir_expression *const r144D = rshift(swizzle_y(r1438), body.constant(int(31)));
   ir_expression *const r144E = rshift(swizzle_y(r1439), body.constant(int(31)));
   body.emit(assign(r143C, bit_xor(r144D, r144E), 0x01));

   /* IF CONDITION */
   ir_expression *const r1450 = equal(r1446, body.constant(int(2047)));
   ir_if *f144F = new(mem_ctx) ir_if(operand(r1450).val);
   exec_list *const f144F_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f144F->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1452 = bit_or(swizzle_y(r1445), swizzle_x(r1438));
      ir_expression *const r1453 = nequal(r1452, body.constant(0u));
      ir_expression *const r1454 = equal(r144A, body.constant(int(2047)));
      ir_expression *const r1455 = bit_or(swizzle_y(r1449), swizzle_x(r1439));
      ir_expression *const r1456 = nequal(r1455, body.constant(0u));
      ir_expression *const r1457 = logic_and(r1454, r1456);
      ir_expression *const r1458 = logic_or(r1453, r1457);
      ir_if *f1451 = new(mem_ctx) ir_if(operand(r1458).val);
      exec_list *const f1451_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1451->then_instructions;

         ir_variable *const r1459 = body.make_temp(glsl_type::uvec2_type, "a");
         body.emit(assign(r1459, swizzle_x(r1438), 0x01));

         ir_variable *const r145A = body.make_temp(glsl_type::uvec2_type, "b");
         body.emit(assign(r145A, swizzle_x(r1439), 0x01));

         ir_variable *const r145B = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r145C = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
         ir_expression *const r145D = rshift(swizzle_y(r1438), body.constant(int(19)));
         ir_expression *const r145E = bit_and(r145D, body.constant(4095u));
         ir_expression *const r145F = equal(r145E, body.constant(4094u));
         ir_expression *const r1460 = nequal(swizzle_x(r1438), body.constant(0u));
         ir_expression *const r1461 = bit_and(swizzle_y(r1438), body.constant(524287u));
         ir_expression *const r1462 = nequal(r1461, body.constant(0u));
         ir_expression *const r1463 = logic_or(r1460, r1462);
         body.emit(assign(r145C, logic_and(r145F, r1463), 0x01));

         ir_variable *const r1464 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
         ir_expression *const r1465 = lshift(swizzle_y(r1439), body.constant(int(1)));
         ir_expression *const r1466 = lequal(body.constant(4292870144u), r1465);
         ir_expression *const r1467 = nequal(swizzle_x(r1439), body.constant(0u));
         ir_expression *const r1468 = bit_and(swizzle_y(r1439), body.constant(1048575u));
         ir_expression *const r1469 = nequal(r1468, body.constant(0u));
         ir_expression *const r146A = logic_or(r1467, r1469);
         body.emit(assign(r1464, logic_and(r1466, r146A), 0x01));

         body.emit(assign(r1459, bit_or(swizzle_y(r1438), body.constant(524288u)), 0x02));

         body.emit(assign(r145A, bit_or(swizzle_y(r1439), body.constant(524288u)), 0x02));

         /* IF CONDITION */
         ir_expression *const r146C = lshift(swizzle_y(r1438), body.constant(int(1)));
         ir_expression *const r146D = lequal(body.constant(4292870144u), r146C);
         ir_expression *const r146E = nequal(swizzle_x(r1438), body.constant(0u));
         ir_expression *const r146F = bit_and(swizzle_y(r1438), body.constant(1048575u));
         ir_expression *const r1470 = nequal(r146F, body.constant(0u));
         ir_expression *const r1471 = logic_or(r146E, r1470);
         ir_expression *const r1472 = logic_and(r146D, r1471);
         ir_if *f146B = new(mem_ctx) ir_if(operand(r1472).val);
         exec_list *const f146B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f146B->then_instructions;

            ir_variable *const r1473 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r1475 = logic_and(r145C, r1464);
            ir_if *f1474 = new(mem_ctx) ir_if(operand(r1475).val);
            exec_list *const f1474_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1474->then_instructions;

               body.emit(assign(r1473, r145A, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1474->else_instructions;

               body.emit(assign(r1473, r1459, 0x03));


            body.instructions = f1474_parent_instructions;
            body.emit(f1474);

            /* END IF */

            body.emit(assign(r145B, r1473, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f146B->else_instructions;

            body.emit(assign(r145B, r145A, 0x03));


         body.instructions = f146B_parent_instructions;
         body.emit(f146B);

         /* END IF */

         body.emit(assign(r143B, r145B, 0x03));

         body.emit(assign(r143A, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1451->else_instructions;

         /* IF CONDITION */
         ir_expression *const r1477 = expr(ir_unop_i2u, r144A);
         ir_expression *const r1478 = bit_or(r1477, swizzle_y(r1449));
         ir_expression *const r1479 = bit_or(r1478, swizzle_x(r1439));
         ir_expression *const r147A = equal(r1479, body.constant(0u));
         ir_if *f1476 = new(mem_ctx) ir_if(operand(r147A).val);
         exec_list *const f1476_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1476->then_instructions;

            ir_constant_data r147B_data;
            memset(&r147B_data, 0, sizeof(ir_constant_data));
            r147B_data.u[0] = 4294967295;
            r147B_data.u[1] = 4294967295;
            ir_constant *const r147B = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r147B_data);
            body.emit(assign(r143B, r147B, 0x03));

            body.emit(assign(r143A, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1476->else_instructions;

            ir_variable *const r147C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r147C);
            ir_expression *const r147D = lshift(r143C, body.constant(int(31)));
            body.emit(assign(r147C, add(r147D, body.constant(2146435072u)), 0x02));

            body.emit(assign(r147C, body.constant(0u), 0x01));

            body.emit(assign(r143B, r147C, 0x03));

            body.emit(assign(r143A, body.constant(false), 0x01));


         body.instructions = f1476_parent_instructions;
         body.emit(f1476);

         /* END IF */


      body.instructions = f1451_parent_instructions;
      body.emit(f1451);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f144F->else_instructions;

      /* IF CONDITION */
      ir_expression *const r147F = equal(r144A, body.constant(int(2047)));
      ir_if *f147E = new(mem_ctx) ir_if(operand(r147F).val);
      exec_list *const f147E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f147E->then_instructions;

         /* IF CONDITION */
         ir_expression *const r1481 = bit_or(swizzle_y(r1449), swizzle_x(r1439));
         ir_expression *const r1482 = nequal(r1481, body.constant(0u));
         ir_if *f1480 = new(mem_ctx) ir_if(operand(r1482).val);
         exec_list *const f1480_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1480->then_instructions;

            ir_variable *const r1483 = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r1483, swizzle_x(r1438), 0x01));

            ir_variable *const r1484 = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r1484, swizzle_x(r1439), 0x01));

            ir_variable *const r1485 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r1486 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r1487 = rshift(swizzle_y(r1438), body.constant(int(19)));
            ir_expression *const r1488 = bit_and(r1487, body.constant(4095u));
            ir_expression *const r1489 = equal(r1488, body.constant(4094u));
            ir_expression *const r148A = nequal(swizzle_x(r1438), body.constant(0u));
            ir_expression *const r148B = bit_and(swizzle_y(r1438), body.constant(524287u));
            ir_expression *const r148C = nequal(r148B, body.constant(0u));
            ir_expression *const r148D = logic_or(r148A, r148C);
            body.emit(assign(r1486, logic_and(r1489, r148D), 0x01));

            ir_variable *const r148E = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r148F = lshift(swizzle_y(r1439), body.constant(int(1)));
            ir_expression *const r1490 = lequal(body.constant(4292870144u), r148F);
            ir_expression *const r1491 = nequal(swizzle_x(r1439), body.constant(0u));
            ir_expression *const r1492 = bit_and(swizzle_y(r1439), body.constant(1048575u));
            ir_expression *const r1493 = nequal(r1492, body.constant(0u));
            ir_expression *const r1494 = logic_or(r1491, r1493);
            body.emit(assign(r148E, logic_and(r1490, r1494), 0x01));

            body.emit(assign(r1483, bit_or(swizzle_y(r1438), body.constant(524288u)), 0x02));

            body.emit(assign(r1484, bit_or(swizzle_y(r1439), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r1496 = lshift(swizzle_y(r1438), body.constant(int(1)));
            ir_expression *const r1497 = lequal(body.constant(4292870144u), r1496);
            ir_expression *const r1498 = nequal(swizzle_x(r1438), body.constant(0u));
            ir_expression *const r1499 = bit_and(swizzle_y(r1438), body.constant(1048575u));
            ir_expression *const r149A = nequal(r1499, body.constant(0u));
            ir_expression *const r149B = logic_or(r1498, r149A);
            ir_expression *const r149C = logic_and(r1497, r149B);
            ir_if *f1495 = new(mem_ctx) ir_if(operand(r149C).val);
            exec_list *const f1495_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1495->then_instructions;

               ir_variable *const r149D = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r149F = logic_and(r1486, r148E);
               ir_if *f149E = new(mem_ctx) ir_if(operand(r149F).val);
               exec_list *const f149E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f149E->then_instructions;

                  body.emit(assign(r149D, r1484, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f149E->else_instructions;

                  body.emit(assign(r149D, r1483, 0x03));


               body.instructions = f149E_parent_instructions;
               body.emit(f149E);

               /* END IF */

               body.emit(assign(r1485, r149D, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1495->else_instructions;

               body.emit(assign(r1485, r1484, 0x03));


            body.instructions = f1495_parent_instructions;
            body.emit(f1495);

            /* END IF */

            body.emit(assign(r143B, r1485, 0x03));

            body.emit(assign(r143A, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1480->else_instructions;

            /* IF CONDITION */
            ir_expression *const r14A1 = expr(ir_unop_i2u, r1446);
            ir_expression *const r14A2 = bit_or(r14A1, swizzle_y(r1445));
            ir_expression *const r14A3 = bit_or(r14A2, swizzle_x(r1438));
            ir_expression *const r14A4 = equal(r14A3, body.constant(0u));
            ir_if *f14A0 = new(mem_ctx) ir_if(operand(r14A4).val);
            exec_list *const f14A0_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f14A0->then_instructions;

               ir_constant_data r14A5_data;
               memset(&r14A5_data, 0, sizeof(ir_constant_data));
               r14A5_data.u[0] = 4294967295;
               r14A5_data.u[1] = 4294967295;
               ir_constant *const r14A5 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r14A5_data);
               body.emit(assign(r143B, r14A5, 0x03));

               body.emit(assign(r143A, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f14A0->else_instructions;

               ir_variable *const r14A6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r14A6);
               ir_expression *const r14A7 = lshift(r143C, body.constant(int(31)));
               body.emit(assign(r14A6, add(r14A7, body.constant(2146435072u)), 0x02));

               body.emit(assign(r14A6, body.constant(0u), 0x01));

               body.emit(assign(r143B, r14A6, 0x03));

               body.emit(assign(r143A, body.constant(false), 0x01));


            body.instructions = f14A0_parent_instructions;
            body.emit(f14A0);

            /* END IF */


         body.instructions = f1480_parent_instructions;
         body.emit(f1480);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f147E->else_instructions;

         /* IF CONDITION */
         ir_expression *const r14A9 = equal(r1446, body.constant(int(0)));
         ir_if *f14A8 = new(mem_ctx) ir_if(operand(r14A9).val);
         exec_list *const f14A8_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f14A8->then_instructions;

            /* IF CONDITION */
            ir_expression *const r14AB = bit_or(swizzle_y(r1445), swizzle_x(r1438));
            ir_expression *const r14AC = equal(r14AB, body.constant(0u));
            ir_if *f14AA = new(mem_ctx) ir_if(operand(r14AC).val);
            exec_list *const f14AA_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f14AA->then_instructions;

               ir_variable *const r14AD = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r14AD);
               body.emit(assign(r14AD, lshift(r143C, body.constant(int(31))), 0x02));

               body.emit(assign(r14AD, body.constant(0u), 0x01));

               body.emit(assign(r143B, r14AD, 0x03));

               body.emit(assign(r143A, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f14AA->else_instructions;

               ir_variable *const r14AE = body.make_temp(glsl_type::uint_type, "aFrac0");
               body.emit(assign(r14AE, swizzle_y(r1445), 0x01));

               ir_variable *const r14AF = body.make_temp(glsl_type::uint_type, "aFrac1");
               body.emit(assign(r14AF, swizzle_x(r1445), 0x01));

               ir_variable *const r14B0 = body.make_temp(glsl_type::int_type, "zExpPtr");
               body.emit(assign(r14B0, r1446, 0x01));

               ir_variable *const r14B1 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
               body.emit(assign(r14B1, swizzle_y(r1445), 0x01));

               ir_variable *const r14B2 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
               body.emit(assign(r14B2, swizzle_x(r1445), 0x01));

               ir_variable *const r14B3 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r14B3);
               /* IF CONDITION */
               ir_expression *const r14B5 = equal(swizzle_y(r1445), body.constant(0u));
               ir_if *f14B4 = new(mem_ctx) ir_if(operand(r14B5).val);
               exec_list *const f14B4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f14B4->then_instructions;

                  ir_variable *const r14B6 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r14B6, r14AF, 0x01));

                  ir_variable *const r14B7 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r14B8 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r14B8);
                  /* IF CONDITION */
                  ir_expression *const r14BA = equal(swizzle_x(r1438), body.constant(0u));
                  ir_if *f14B9 = new(mem_ctx) ir_if(operand(r14BA).val);
                  exec_list *const f14B9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f14B9->then_instructions;

                     body.emit(assign(r14B7, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f14B9->else_instructions;

                     body.emit(assign(r14B8, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r14BC = bit_and(swizzle_x(r1438), body.constant(4294901760u));
                     ir_expression *const r14BD = equal(r14BC, body.constant(0u));
                     ir_if *f14BB = new(mem_ctx) ir_if(operand(r14BD).val);
                     exec_list *const f14BB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14BB->then_instructions;

                        body.emit(assign(r14B8, body.constant(int(16)), 0x01));

                        body.emit(assign(r14B6, lshift(swizzle_x(r1438), body.constant(int(16))), 0x01));


                     body.instructions = f14BB_parent_instructions;
                     body.emit(f14BB);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14BF = bit_and(r14B6, body.constant(4278190080u));
                     ir_expression *const r14C0 = equal(r14BF, body.constant(0u));
                     ir_if *f14BE = new(mem_ctx) ir_if(operand(r14C0).val);
                     exec_list *const f14BE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14BE->then_instructions;

                        body.emit(assign(r14B8, add(r14B8, body.constant(int(8))), 0x01));

                        body.emit(assign(r14B6, lshift(r14B6, body.constant(int(8))), 0x01));


                     body.instructions = f14BE_parent_instructions;
                     body.emit(f14BE);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14C2 = bit_and(r14B6, body.constant(4026531840u));
                     ir_expression *const r14C3 = equal(r14C2, body.constant(0u));
                     ir_if *f14C1 = new(mem_ctx) ir_if(operand(r14C3).val);
                     exec_list *const f14C1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14C1->then_instructions;

                        body.emit(assign(r14B8, add(r14B8, body.constant(int(4))), 0x01));

                        body.emit(assign(r14B6, lshift(r14B6, body.constant(int(4))), 0x01));


                     body.instructions = f14C1_parent_instructions;
                     body.emit(f14C1);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14C5 = bit_and(r14B6, body.constant(3221225472u));
                     ir_expression *const r14C6 = equal(r14C5, body.constant(0u));
                     ir_if *f14C4 = new(mem_ctx) ir_if(operand(r14C6).val);
                     exec_list *const f14C4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14C4->then_instructions;

                        body.emit(assign(r14B8, add(r14B8, body.constant(int(2))), 0x01));

                        body.emit(assign(r14B6, lshift(r14B6, body.constant(int(2))), 0x01));


                     body.instructions = f14C4_parent_instructions;
                     body.emit(f14C4);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14C8 = bit_and(r14B6, body.constant(2147483648u));
                     ir_expression *const r14C9 = equal(r14C8, body.constant(0u));
                     ir_if *f14C7 = new(mem_ctx) ir_if(operand(r14C9).val);
                     exec_list *const f14C7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14C7->then_instructions;

                        body.emit(assign(r14B8, add(r14B8, body.constant(int(1))), 0x01));


                     body.instructions = f14C7_parent_instructions;
                     body.emit(f14C7);

                     /* END IF */

                     body.emit(assign(r14B7, r14B8, 0x01));


                  body.instructions = f14B9_parent_instructions;
                  body.emit(f14B9);

                  /* END IF */

                  body.emit(assign(r14B3, add(r14B7, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r14CB = less(r14B3, body.constant(int(0)));
                  ir_if *f14CA = new(mem_ctx) ir_if(operand(r14CB).val);
                  exec_list *const f14CA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f14CA->then_instructions;

                     ir_expression *const r14CC = neg(r14B3);
                     body.emit(assign(r14B1, rshift(swizzle_x(r1438), r14CC), 0x01));

                     ir_expression *const r14CD = bit_and(r14B3, body.constant(int(31)));
                     body.emit(assign(r14B2, lshift(swizzle_x(r1438), r14CD), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f14CA->else_instructions;

                     body.emit(assign(r14B1, lshift(swizzle_x(r1438), r14B3), 0x01));

                     body.emit(assign(r14B2, body.constant(0u), 0x01));


                  body.instructions = f14CA_parent_instructions;
                  body.emit(f14CA);

                  /* END IF */

                  body.emit(assign(r14B0, sub(body.constant(int(-31)), r14B3), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f14B4->else_instructions;

                  ir_variable *const r14CE = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r14CE, r14AE, 0x01));

                  ir_variable *const r14CF = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r14D0 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r14D0);
                  /* IF CONDITION */
                  ir_expression *const r14D2 = equal(swizzle_y(r1445), body.constant(0u));
                  ir_if *f14D1 = new(mem_ctx) ir_if(operand(r14D2).val);
                  exec_list *const f14D1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f14D1->then_instructions;

                     body.emit(assign(r14CF, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f14D1->else_instructions;

                     body.emit(assign(r14D0, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r14D4 = bit_and(swizzle_y(r1445), body.constant(4294901760u));
                     ir_expression *const r14D5 = equal(r14D4, body.constant(0u));
                     ir_if *f14D3 = new(mem_ctx) ir_if(operand(r14D5).val);
                     exec_list *const f14D3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14D3->then_instructions;

                        body.emit(assign(r14D0, body.constant(int(16)), 0x01));

                        body.emit(assign(r14CE, lshift(swizzle_y(r1445), body.constant(int(16))), 0x01));


                     body.instructions = f14D3_parent_instructions;
                     body.emit(f14D3);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14D7 = bit_and(r14CE, body.constant(4278190080u));
                     ir_expression *const r14D8 = equal(r14D7, body.constant(0u));
                     ir_if *f14D6 = new(mem_ctx) ir_if(operand(r14D8).val);
                     exec_list *const f14D6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14D6->then_instructions;

                        body.emit(assign(r14D0, add(r14D0, body.constant(int(8))), 0x01));

                        body.emit(assign(r14CE, lshift(r14CE, body.constant(int(8))), 0x01));


                     body.instructions = f14D6_parent_instructions;
                     body.emit(f14D6);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14DA = bit_and(r14CE, body.constant(4026531840u));
                     ir_expression *const r14DB = equal(r14DA, body.constant(0u));
                     ir_if *f14D9 = new(mem_ctx) ir_if(operand(r14DB).val);
                     exec_list *const f14D9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14D9->then_instructions;

                        body.emit(assign(r14D0, add(r14D0, body.constant(int(4))), 0x01));

                        body.emit(assign(r14CE, lshift(r14CE, body.constant(int(4))), 0x01));


                     body.instructions = f14D9_parent_instructions;
                     body.emit(f14D9);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14DD = bit_and(r14CE, body.constant(3221225472u));
                     ir_expression *const r14DE = equal(r14DD, body.constant(0u));
                     ir_if *f14DC = new(mem_ctx) ir_if(operand(r14DE).val);
                     exec_list *const f14DC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14DC->then_instructions;

                        body.emit(assign(r14D0, add(r14D0, body.constant(int(2))), 0x01));

                        body.emit(assign(r14CE, lshift(r14CE, body.constant(int(2))), 0x01));


                     body.instructions = f14DC_parent_instructions;
                     body.emit(f14DC);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r14E0 = bit_and(r14CE, body.constant(2147483648u));
                     ir_expression *const r14E1 = equal(r14E0, body.constant(0u));
                     ir_if *f14DF = new(mem_ctx) ir_if(operand(r14E1).val);
                     exec_list *const f14DF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14DF->then_instructions;

                        body.emit(assign(r14D0, add(r14D0, body.constant(int(1))), 0x01));


                     body.instructions = f14DF_parent_instructions;
                     body.emit(f14DF);

                     /* END IF */

                     body.emit(assign(r14CF, r14D0, 0x01));


                  body.instructions = f14D1_parent_instructions;
                  body.emit(f14D1);

                  /* END IF */

                  body.emit(assign(r14B3, add(r14CF, body.constant(int(-11))), 0x01));

                  ir_variable *const r14E2 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r14E2, lshift(swizzle_x(r1438), r14B3), 0x01));

                  ir_variable *const r14E3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r14E5 = equal(r14B3, body.constant(int(0)));
                  ir_if *f14E4 = new(mem_ctx) ir_if(operand(r14E5).val);
                  exec_list *const f14E4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f14E4->then_instructions;

                     body.emit(assign(r14E3, r14AE, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f14E4->else_instructions;

                     ir_expression *const r14E6 = lshift(swizzle_y(r1445), r14B3);
                     ir_expression *const r14E7 = neg(r14B3);
                     ir_expression *const r14E8 = bit_and(r14E7, body.constant(int(31)));
                     ir_expression *const r14E9 = rshift(swizzle_x(r1438), r14E8);
                     body.emit(assign(r14E3, bit_or(r14E6, r14E9), 0x01));


                  body.instructions = f14E4_parent_instructions;
                  body.emit(f14E4);

                  /* END IF */

                  body.emit(assign(r14B1, r14E3, 0x01));

                  body.emit(assign(r14B2, r14E2, 0x01));

                  body.emit(assign(r14B0, sub(body.constant(int(1)), r14B3), 0x01));


               body.instructions = f14B4_parent_instructions;
               body.emit(f14B4);

               /* END IF */

               body.emit(assign(r143F, r14B0, 0x01));

               body.emit(assign(r1440, r14B1, 0x02));

               body.emit(assign(r1440, r14B2, 0x01));


            body.instructions = f14AA_parent_instructions;
            body.emit(f14AA);

            /* END IF */


         body.instructions = f14A8_parent_instructions;
         body.emit(f14A8);

         /* END IF */

         /* IF CONDITION */
         ir_if *f14EA = new(mem_ctx) ir_if(operand(r143A).val);
         exec_list *const f14EA_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f14EA->then_instructions;

            /* IF CONDITION */
            ir_expression *const r14EC = equal(r144A, body.constant(int(0)));
            ir_if *f14EB = new(mem_ctx) ir_if(operand(r14EC).val);
            exec_list *const f14EB_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f14EB->then_instructions;

               /* IF CONDITION */
               ir_expression *const r14EE = bit_or(swizzle_y(r1449), swizzle_x(r1439));
               ir_expression *const r14EF = equal(r14EE, body.constant(0u));
               ir_if *f14ED = new(mem_ctx) ir_if(operand(r14EF).val);
               exec_list *const f14ED_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f14ED->then_instructions;

                  ir_variable *const r14F0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r14F0);
                  body.emit(assign(r14F0, lshift(r143C, body.constant(int(31))), 0x02));

                  body.emit(assign(r14F0, body.constant(0u), 0x01));

                  body.emit(assign(r143B, r14F0, 0x03));

                  body.emit(assign(r143A, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f14ED->else_instructions;

                  ir_variable *const r14F1 = body.make_temp(glsl_type::uint_type, "aFrac0");
                  body.emit(assign(r14F1, swizzle_y(r1449), 0x01));

                  ir_variable *const r14F2 = body.make_temp(glsl_type::uint_type, "aFrac1");
                  body.emit(assign(r14F2, swizzle_x(r1449), 0x01));

                  ir_variable *const r14F3 = body.make_temp(glsl_type::int_type, "zExpPtr");
                  body.emit(assign(r14F3, r144A, 0x01));

                  ir_variable *const r14F4 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
                  body.emit(assign(r14F4, swizzle_y(r1449), 0x01));

                  ir_variable *const r14F5 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
                  body.emit(assign(r14F5, swizzle_x(r1449), 0x01));

                  ir_variable *const r14F6 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r14F6);
                  /* IF CONDITION */
                  ir_expression *const r14F8 = equal(swizzle_y(r1449), body.constant(0u));
                  ir_if *f14F7 = new(mem_ctx) ir_if(operand(r14F8).val);
                  exec_list *const f14F7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f14F7->then_instructions;

                     ir_variable *const r14F9 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r14F9, r14F2, 0x01));

                     ir_variable *const r14FA = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r14FB = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r14FB);
                     /* IF CONDITION */
                     ir_expression *const r14FD = equal(swizzle_x(r1439), body.constant(0u));
                     ir_if *f14FC = new(mem_ctx) ir_if(operand(r14FD).val);
                     exec_list *const f14FC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f14FC->then_instructions;

                        body.emit(assign(r14FA, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f14FC->else_instructions;

                        body.emit(assign(r14FB, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r14FF = bit_and(swizzle_x(r1439), body.constant(4294901760u));
                        ir_expression *const r1500 = equal(r14FF, body.constant(0u));
                        ir_if *f14FE = new(mem_ctx) ir_if(operand(r1500).val);
                        exec_list *const f14FE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f14FE->then_instructions;

                           body.emit(assign(r14FB, body.constant(int(16)), 0x01));

                           body.emit(assign(r14F9, lshift(swizzle_x(r1439), body.constant(int(16))), 0x01));


                        body.instructions = f14FE_parent_instructions;
                        body.emit(f14FE);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1502 = bit_and(r14F9, body.constant(4278190080u));
                        ir_expression *const r1503 = equal(r1502, body.constant(0u));
                        ir_if *f1501 = new(mem_ctx) ir_if(operand(r1503).val);
                        exec_list *const f1501_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1501->then_instructions;

                           body.emit(assign(r14FB, add(r14FB, body.constant(int(8))), 0x01));

                           body.emit(assign(r14F9, lshift(r14F9, body.constant(int(8))), 0x01));


                        body.instructions = f1501_parent_instructions;
                        body.emit(f1501);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1505 = bit_and(r14F9, body.constant(4026531840u));
                        ir_expression *const r1506 = equal(r1505, body.constant(0u));
                        ir_if *f1504 = new(mem_ctx) ir_if(operand(r1506).val);
                        exec_list *const f1504_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1504->then_instructions;

                           body.emit(assign(r14FB, add(r14FB, body.constant(int(4))), 0x01));

                           body.emit(assign(r14F9, lshift(r14F9, body.constant(int(4))), 0x01));


                        body.instructions = f1504_parent_instructions;
                        body.emit(f1504);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1508 = bit_and(r14F9, body.constant(3221225472u));
                        ir_expression *const r1509 = equal(r1508, body.constant(0u));
                        ir_if *f1507 = new(mem_ctx) ir_if(operand(r1509).val);
                        exec_list *const f1507_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1507->then_instructions;

                           body.emit(assign(r14FB, add(r14FB, body.constant(int(2))), 0x01));

                           body.emit(assign(r14F9, lshift(r14F9, body.constant(int(2))), 0x01));


                        body.instructions = f1507_parent_instructions;
                        body.emit(f1507);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r150B = bit_and(r14F9, body.constant(2147483648u));
                        ir_expression *const r150C = equal(r150B, body.constant(0u));
                        ir_if *f150A = new(mem_ctx) ir_if(operand(r150C).val);
                        exec_list *const f150A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f150A->then_instructions;

                           body.emit(assign(r14FB, add(r14FB, body.constant(int(1))), 0x01));


                        body.instructions = f150A_parent_instructions;
                        body.emit(f150A);

                        /* END IF */

                        body.emit(assign(r14FA, r14FB, 0x01));


                     body.instructions = f14FC_parent_instructions;
                     body.emit(f14FC);

                     /* END IF */

                     body.emit(assign(r14F6, add(r14FA, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r150E = less(r14F6, body.constant(int(0)));
                     ir_if *f150D = new(mem_ctx) ir_if(operand(r150E).val);
                     exec_list *const f150D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f150D->then_instructions;

                        ir_expression *const r150F = neg(r14F6);
                        body.emit(assign(r14F4, rshift(swizzle_x(r1439), r150F), 0x01));

                        ir_expression *const r1510 = bit_and(r14F6, body.constant(int(31)));
                        body.emit(assign(r14F5, lshift(swizzle_x(r1439), r1510), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f150D->else_instructions;

                        body.emit(assign(r14F4, lshift(swizzle_x(r1439), r14F6), 0x01));

                        body.emit(assign(r14F5, body.constant(0u), 0x01));


                     body.instructions = f150D_parent_instructions;
                     body.emit(f150D);

                     /* END IF */

                     body.emit(assign(r14F3, sub(body.constant(int(-31)), r14F6), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f14F7->else_instructions;

                     ir_variable *const r1511 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r1511, r14F1, 0x01));

                     ir_variable *const r1512 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r1513 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r1513);
                     /* IF CONDITION */
                     ir_expression *const r1515 = equal(swizzle_y(r1449), body.constant(0u));
                     ir_if *f1514 = new(mem_ctx) ir_if(operand(r1515).val);
                     exec_list *const f1514_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1514->then_instructions;

                        body.emit(assign(r1512, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1514->else_instructions;

                        body.emit(assign(r1513, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1517 = bit_and(swizzle_y(r1449), body.constant(4294901760u));
                        ir_expression *const r1518 = equal(r1517, body.constant(0u));
                        ir_if *f1516 = new(mem_ctx) ir_if(operand(r1518).val);
                        exec_list *const f1516_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1516->then_instructions;

                           body.emit(assign(r1513, body.constant(int(16)), 0x01));

                           body.emit(assign(r1511, lshift(swizzle_y(r1449), body.constant(int(16))), 0x01));


                        body.instructions = f1516_parent_instructions;
                        body.emit(f1516);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r151A = bit_and(r1511, body.constant(4278190080u));
                        ir_expression *const r151B = equal(r151A, body.constant(0u));
                        ir_if *f1519 = new(mem_ctx) ir_if(operand(r151B).val);
                        exec_list *const f1519_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1519->then_instructions;

                           body.emit(assign(r1513, add(r1513, body.constant(int(8))), 0x01));

                           body.emit(assign(r1511, lshift(r1511, body.constant(int(8))), 0x01));


                        body.instructions = f1519_parent_instructions;
                        body.emit(f1519);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r151D = bit_and(r1511, body.constant(4026531840u));
                        ir_expression *const r151E = equal(r151D, body.constant(0u));
                        ir_if *f151C = new(mem_ctx) ir_if(operand(r151E).val);
                        exec_list *const f151C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f151C->then_instructions;

                           body.emit(assign(r1513, add(r1513, body.constant(int(4))), 0x01));

                           body.emit(assign(r1511, lshift(r1511, body.constant(int(4))), 0x01));


                        body.instructions = f151C_parent_instructions;
                        body.emit(f151C);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1520 = bit_and(r1511, body.constant(3221225472u));
                        ir_expression *const r1521 = equal(r1520, body.constant(0u));
                        ir_if *f151F = new(mem_ctx) ir_if(operand(r1521).val);
                        exec_list *const f151F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f151F->then_instructions;

                           body.emit(assign(r1513, add(r1513, body.constant(int(2))), 0x01));

                           body.emit(assign(r1511, lshift(r1511, body.constant(int(2))), 0x01));


                        body.instructions = f151F_parent_instructions;
                        body.emit(f151F);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1523 = bit_and(r1511, body.constant(2147483648u));
                        ir_expression *const r1524 = equal(r1523, body.constant(0u));
                        ir_if *f1522 = new(mem_ctx) ir_if(operand(r1524).val);
                        exec_list *const f1522_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1522->then_instructions;

                           body.emit(assign(r1513, add(r1513, body.constant(int(1))), 0x01));


                        body.instructions = f1522_parent_instructions;
                        body.emit(f1522);

                        /* END IF */

                        body.emit(assign(r1512, r1513, 0x01));


                     body.instructions = f1514_parent_instructions;
                     body.emit(f1514);

                     /* END IF */

                     body.emit(assign(r14F6, add(r1512, body.constant(int(-11))), 0x01));

                     ir_variable *const r1525 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r1525, lshift(swizzle_x(r1439), r14F6), 0x01));

                     ir_variable *const r1526 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1528 = equal(r14F6, body.constant(int(0)));
                     ir_if *f1527 = new(mem_ctx) ir_if(operand(r1528).val);
                     exec_list *const f1527_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1527->then_instructions;

                        body.emit(assign(r1526, r14F1, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1527->else_instructions;

                        ir_expression *const r1529 = lshift(swizzle_y(r1449), r14F6);
                        ir_expression *const r152A = neg(r14F6);
                        ir_expression *const r152B = bit_and(r152A, body.constant(int(31)));
                        ir_expression *const r152C = rshift(swizzle_x(r1439), r152B);
                        body.emit(assign(r1526, bit_or(r1529, r152C), 0x01));


                     body.instructions = f1527_parent_instructions;
                     body.emit(f1527);

                     /* END IF */

                     body.emit(assign(r14F4, r1526, 0x01));

                     body.emit(assign(r14F5, r1525, 0x01));

                     body.emit(assign(r14F3, sub(body.constant(int(1)), r14F6), 0x01));


                  body.instructions = f14F7_parent_instructions;
                  body.emit(f14F7);

                  /* END IF */

                  body.emit(assign(r143D, r14F3, 0x01));

                  body.emit(assign(r143E, r14F4, 0x02));

                  body.emit(assign(r143E, r14F5, 0x01));


               body.instructions = f14ED_parent_instructions;
               body.emit(f14ED);

               /* END IF */


            body.instructions = f14EB_parent_instructions;
            body.emit(f14EB);

            /* END IF */

            /* IF CONDITION */
            ir_if *f152D = new(mem_ctx) ir_if(operand(r143A).val);
            exec_list *const f152D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f152D->then_instructions;

               ir_expression *const r152E = add(r143F, r143D);
               body.emit(assign(r1441, add(r152E, body.constant(int(-1024))), 0x01));

               body.emit(assign(r1440, bit_or(swizzle_y(r1440), body.constant(1048576u)), 0x02));

               ir_variable *const r152F = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r152F, lshift(swizzle_x(r143E), body.constant(int(12))), 0x01));

               ir_variable *const r1530 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r1531 = lshift(swizzle_y(r143E), body.constant(int(12)));
               ir_expression *const r1532 = rshift(swizzle_x(r143E), body.constant(int(20)));
               body.emit(assign(r1530, bit_or(r1531, r1532), 0x01));

               body.emit(assign(r143E, r1530, 0x02));

               body.emit(assign(r143E, r152F, 0x01));

               ir_variable *const r1533 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1533);
               ir_variable *const r1534 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r1534);
               ir_variable *const r1535 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1535);
               ir_variable *const r1536 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1536, bit_and(swizzle_x(r1440), body.constant(65535u)), 0x01));

               ir_variable *const r1537 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1537, rshift(swizzle_x(r1440), body.constant(int(16))), 0x01));

               ir_variable *const r1538 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1538, bit_and(r152F, body.constant(65535u)), 0x01));

               ir_variable *const r1539 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1539, rshift(r152F, body.constant(int(16))), 0x01));

               ir_variable *const r153A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r153A, mul(r1537, r1538), 0x01));

               ir_expression *const r153B = mul(r1536, r1539);
               body.emit(assign(r1534, add(r153B, r153A), 0x01));

               ir_expression *const r153C = mul(r1537, r1539);
               ir_expression *const r153D = less(r1534, r153A);
               ir_expression *const r153E = expr(ir_unop_b2i, r153D);
               ir_expression *const r153F = expr(ir_unop_i2u, r153E);
               ir_expression *const r1540 = lshift(r153F, body.constant(int(16)));
               ir_expression *const r1541 = rshift(r1534, body.constant(int(16)));
               ir_expression *const r1542 = add(r1540, r1541);
               body.emit(assign(r1533, add(r153C, r1542), 0x01));

               body.emit(assign(r1534, lshift(r1534, body.constant(int(16))), 0x01));

               ir_expression *const r1543 = mul(r1536, r1538);
               body.emit(assign(r1535, add(r1543, r1534), 0x01));

               ir_expression *const r1544 = less(r1535, r1534);
               ir_expression *const r1545 = expr(ir_unop_b2i, r1544);
               ir_expression *const r1546 = expr(ir_unop_i2u, r1545);
               body.emit(assign(r1533, add(r1533, r1546), 0x01));

               ir_variable *const r1547 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1547);
               ir_variable *const r1548 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r1548);
               ir_variable *const r1549 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1549);
               ir_variable *const r154A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r154A, bit_and(swizzle_x(r1440), body.constant(65535u)), 0x01));

               ir_variable *const r154B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r154B, rshift(swizzle_x(r1440), body.constant(int(16))), 0x01));

               ir_variable *const r154C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r154C, bit_and(r1530, body.constant(65535u)), 0x01));

               ir_variable *const r154D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r154D, rshift(r1530, body.constant(int(16))), 0x01));

               ir_variable *const r154E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r154E, mul(r154B, r154C), 0x01));

               ir_expression *const r154F = mul(r154A, r154D);
               body.emit(assign(r1548, add(r154F, r154E), 0x01));

               ir_expression *const r1550 = mul(r154B, r154D);
               ir_expression *const r1551 = less(r1548, r154E);
               ir_expression *const r1552 = expr(ir_unop_b2i, r1551);
               ir_expression *const r1553 = expr(ir_unop_i2u, r1552);
               ir_expression *const r1554 = lshift(r1553, body.constant(int(16)));
               ir_expression *const r1555 = rshift(r1548, body.constant(int(16)));
               ir_expression *const r1556 = add(r1554, r1555);
               body.emit(assign(r1547, add(r1550, r1556), 0x01));

               body.emit(assign(r1548, lshift(r1548, body.constant(int(16))), 0x01));

               ir_expression *const r1557 = mul(r154A, r154C);
               body.emit(assign(r1549, add(r1557, r1548), 0x01));

               ir_expression *const r1558 = less(r1549, r1548);
               ir_expression *const r1559 = expr(ir_unop_b2i, r1558);
               ir_expression *const r155A = expr(ir_unop_i2u, r1559);
               body.emit(assign(r1547, add(r1547, r155A), 0x01));

               ir_variable *const r155B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r155B, add(r1549, r1533), 0x01));

               ir_variable *const r155C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r155C);
               ir_variable *const r155D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r155D);
               ir_variable *const r155E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r155E);
               ir_variable *const r155F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r155F, bit_and(swizzle_y(r1440), body.constant(65535u)), 0x01));

               ir_variable *const r1560 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1560, rshift(swizzle_y(r1440), body.constant(int(16))), 0x01));

               ir_variable *const r1561 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1561, bit_and(r1530, body.constant(65535u)), 0x01));

               ir_variable *const r1562 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1562, rshift(r1530, body.constant(int(16))), 0x01));

               ir_variable *const r1563 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1563, mul(r1560, r1561), 0x01));

               ir_expression *const r1564 = mul(r155F, r1562);
               body.emit(assign(r155D, add(r1564, r1563), 0x01));

               ir_expression *const r1565 = mul(r1560, r1562);
               ir_expression *const r1566 = less(r155D, r1563);
               ir_expression *const r1567 = expr(ir_unop_b2i, r1566);
               ir_expression *const r1568 = expr(ir_unop_i2u, r1567);
               ir_expression *const r1569 = lshift(r1568, body.constant(int(16)));
               ir_expression *const r156A = rshift(r155D, body.constant(int(16)));
               ir_expression *const r156B = add(r1569, r156A);
               body.emit(assign(r155C, add(r1565, r156B), 0x01));

               body.emit(assign(r155D, lshift(r155D, body.constant(int(16))), 0x01));

               ir_expression *const r156C = mul(r155F, r1561);
               body.emit(assign(r155E, add(r156C, r155D), 0x01));

               ir_expression *const r156D = less(r155E, r155D);
               ir_expression *const r156E = expr(ir_unop_b2i, r156D);
               ir_expression *const r156F = expr(ir_unop_i2u, r156E);
               body.emit(assign(r155C, add(r155C, r156F), 0x01));

               ir_variable *const r1570 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r1571 = less(r155B, r1549);
               ir_expression *const r1572 = expr(ir_unop_b2i, r1571);
               ir_expression *const r1573 = expr(ir_unop_i2u, r1572);
               ir_expression *const r1574 = add(r1547, r1573);
               body.emit(assign(r1570, add(r155E, r1574), 0x01));

               ir_variable *const r1575 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1575);
               ir_variable *const r1576 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r1576);
               ir_variable *const r1577 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1577);
               ir_variable *const r1578 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1578, bit_and(swizzle_y(r1440), body.constant(65535u)), 0x01));

               ir_variable *const r1579 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1579, rshift(swizzle_y(r1440), body.constant(int(16))), 0x01));

               ir_variable *const r157A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r157A, bit_and(r152F, body.constant(65535u)), 0x01));

               ir_variable *const r157B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r157B, rshift(r152F, body.constant(int(16))), 0x01));

               ir_variable *const r157C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r157C, mul(r1579, r157A), 0x01));

               ir_expression *const r157D = mul(r1578, r157B);
               body.emit(assign(r1576, add(r157D, r157C), 0x01));

               ir_expression *const r157E = mul(r1579, r157B);
               ir_expression *const r157F = less(r1576, r157C);
               ir_expression *const r1580 = expr(ir_unop_b2i, r157F);
               ir_expression *const r1581 = expr(ir_unop_i2u, r1580);
               ir_expression *const r1582 = lshift(r1581, body.constant(int(16)));
               ir_expression *const r1583 = rshift(r1576, body.constant(int(16)));
               ir_expression *const r1584 = add(r1582, r1583);
               body.emit(assign(r1575, add(r157E, r1584), 0x01));

               body.emit(assign(r1576, lshift(r1576, body.constant(int(16))), 0x01));

               ir_expression *const r1585 = mul(r1578, r157A);
               body.emit(assign(r1577, add(r1585, r1576), 0x01));

               ir_expression *const r1586 = less(r1577, r1576);
               ir_expression *const r1587 = expr(ir_unop_b2i, r1586);
               ir_expression *const r1588 = expr(ir_unop_i2u, r1587);
               body.emit(assign(r1575, add(r1575, r1588), 0x01));

               ir_variable *const r1589 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1589, add(r1577, r155B), 0x01));

               ir_variable *const r158A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r158B = less(r1589, r1577);
               ir_expression *const r158C = expr(ir_unop_b2i, r158B);
               ir_expression *const r158D = expr(ir_unop_i2u, r158C);
               ir_expression *const r158E = add(r1575, r158D);
               body.emit(assign(r158A, add(r1570, r158E), 0x01));

               ir_variable *const r158F = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r1590 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1590, add(r158A, swizzle_x(r1440)), 0x01));

               ir_expression *const r1591 = less(r1570, r155E);
               ir_expression *const r1592 = expr(ir_unop_b2i, r1591);
               ir_expression *const r1593 = expr(ir_unop_i2u, r1592);
               ir_expression *const r1594 = add(r155C, r1593);
               ir_expression *const r1595 = less(r158A, r1570);
               ir_expression *const r1596 = expr(ir_unop_b2i, r1595);
               ir_expression *const r1597 = expr(ir_unop_i2u, r1596);
               ir_expression *const r1598 = add(r1594, r1597);
               ir_expression *const r1599 = add(r1598, swizzle_y(r1440));
               ir_expression *const r159A = less(r1590, r158A);
               ir_expression *const r159B = expr(ir_unop_b2i, r159A);
               ir_expression *const r159C = expr(ir_unop_i2u, r159B);
               body.emit(assign(r158F, add(r1599, r159C), 0x01));

               body.emit(assign(r1444, r158F, 0x01));

               body.emit(assign(r1443, r1590, 0x01));

               ir_expression *const r159D = nequal(r1535, body.constant(0u));
               ir_expression *const r159E = expr(ir_unop_b2i, r159D);
               ir_expression *const r159F = expr(ir_unop_i2u, r159E);
               body.emit(assign(r1442, bit_or(r1589, r159F), 0x01));

               /* IF CONDITION */
               ir_expression *const r15A1 = lequal(body.constant(2097152u), r158F);
               ir_if *f15A0 = new(mem_ctx) ir_if(operand(r15A1).val);
               exec_list *const f15A0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f15A0->then_instructions;

                  ir_variable *const r15A2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r15A2);
                  body.emit(assign(r15A2, lshift(r1590, body.constant(int(31))), 0x01));

                  ir_expression *const r15A3 = nequal(r1442, body.constant(0u));
                  ir_expression *const r15A4 = expr(ir_unop_b2i, r15A3);
                  ir_expression *const r15A5 = expr(ir_unop_i2u, r15A4);
                  body.emit(assign(r15A2, bit_or(r15A2, r15A5), 0x01));

                  body.emit(assign(r1444, rshift(r158F, body.constant(int(1))), 0x01));

                  ir_expression *const r15A6 = lshift(r158F, body.constant(int(31)));
                  ir_expression *const r15A7 = rshift(r1590, body.constant(int(1)));
                  body.emit(assign(r1443, bit_or(r15A6, r15A7), 0x01));

                  body.emit(assign(r1442, r15A2, 0x01));

                  body.emit(assign(r1441, add(r1441, body.constant(int(1))), 0x01));


               body.instructions = f15A0_parent_instructions;
               body.emit(f15A0);

               /* END IF */

               ir_variable *const r15A8 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r15A8, r1441, 0x01));

               ir_variable *const r15A9 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r15A9, r1444, 0x01));

               ir_variable *const r15AA = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r15AA, r1443, 0x01));

               ir_variable *const r15AB = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r15AB, r1442, 0x01));

               ir_variable *const r15AC = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r15AC, body.constant(true), 0x01));

               ir_variable *const r15AD = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r15AE = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r15AE);
               ir_expression *const r15AF = expr(ir_unop_u2i, r1442);
               body.emit(assign(r15AE, less(r15AF, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r15B1 = lequal(body.constant(int(2045)), r1441);
               ir_if *f15B0 = new(mem_ctx) ir_if(operand(r15B1).val);
               exec_list *const f15B0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f15B0->then_instructions;

                  ir_variable *const r15B2 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r15B4 = less(body.constant(int(2045)), r1441);
                  ir_if *f15B3 = new(mem_ctx) ir_if(operand(r15B4).val);
                  exec_list *const f15B3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f15B3->then_instructions;

                     body.emit(assign(r15B2, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f15B3->else_instructions;

                     ir_variable *const r15B5 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r15B7 = equal(r1441, body.constant(int(2045)));
                     ir_if *f15B6 = new(mem_ctx) ir_if(operand(r15B7).val);
                     exec_list *const f15B6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f15B6->then_instructions;

                        ir_expression *const r15B8 = equal(body.constant(2097151u), r1444);
                        ir_expression *const r15B9 = equal(body.constant(4294967295u), r1443);
                        body.emit(assign(r15B5, logic_and(r15B8, r15B9), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f15B6->else_instructions;

                        body.emit(assign(r15B5, body.constant(false), 0x01));


                     body.instructions = f15B6_parent_instructions;
                     body.emit(f15B6);

                     /* END IF */

                     body.emit(assign(r15B2, logic_and(r15B5, r15AE), 0x01));


                  body.instructions = f15B3_parent_instructions;
                  body.emit(f15B3);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f15BA = new(mem_ctx) ir_if(operand(r15B2).val);
                  exec_list *const f15BA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f15BA->then_instructions;

                     ir_variable *const r15BB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r15BB);
                     ir_expression *const r15BC = lshift(r143C, body.constant(int(31)));
                     body.emit(assign(r15BB, add(r15BC, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r15BB, body.constant(0u), 0x01));

                     body.emit(assign(r15AD, r15BB, 0x03));

                     body.emit(assign(r15AC, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f15BA->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r15BE = less(r1441, body.constant(int(0)));
                     ir_if *f15BD = new(mem_ctx) ir_if(operand(r15BE).val);
                     exec_list *const f15BD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f15BD->then_instructions;

                        ir_variable *const r15BF = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r15BF, r1442, 0x01));

                        ir_variable *const r15C0 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r15C0, neg(r1441), 0x01));

                        ir_variable *const r15C1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r15C1);
                        ir_variable *const r15C2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r15C2);
                        ir_variable *const r15C3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r15C3);
                        ir_variable *const r15C4 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r15C5 = neg(r15C0);
                        body.emit(assign(r15C4, bit_and(r15C5, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r15C7 = equal(r15C0, body.constant(int(0)));
                        ir_if *f15C6 = new(mem_ctx) ir_if(operand(r15C7).val);
                        exec_list *const f15C6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f15C6->then_instructions;

                           body.emit(assign(r15C1, r1442, 0x01));

                           body.emit(assign(r15C2, r1443, 0x01));

                           body.emit(assign(r15C3, r1444, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f15C6->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r15C9 = less(r15C0, body.constant(int(32)));
                           ir_if *f15C8 = new(mem_ctx) ir_if(operand(r15C9).val);
                           exec_list *const f15C8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f15C8->then_instructions;

                              body.emit(assign(r15C1, lshift(r1443, r15C4), 0x01));

                              ir_expression *const r15CA = lshift(r1444, r15C4);
                              ir_expression *const r15CB = rshift(r1443, r15C0);
                              body.emit(assign(r15C2, bit_or(r15CA, r15CB), 0x01));

                              body.emit(assign(r15C3, rshift(r1444, r15C0), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f15C8->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r15CD = equal(r15C0, body.constant(int(32)));
                              ir_if *f15CC = new(mem_ctx) ir_if(operand(r15CD).val);
                              exec_list *const f15CC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f15CC->then_instructions;

                                 body.emit(assign(r15C1, r1443, 0x01));

                                 body.emit(assign(r15C2, r1444, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f15CC->else_instructions;

                                 body.emit(assign(r15BF, bit_or(r1442, r1443), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r15CF = less(r15C0, body.constant(int(64)));
                                 ir_if *f15CE = new(mem_ctx) ir_if(operand(r15CF).val);
                                 exec_list *const f15CE_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f15CE->then_instructions;

                                    body.emit(assign(r15C1, lshift(r1444, r15C4), 0x01));

                                    ir_expression *const r15D0 = bit_and(r15C0, body.constant(int(31)));
                                    body.emit(assign(r15C2, rshift(r1444, r15D0), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f15CE->else_instructions;

                                    ir_variable *const r15D1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r15D3 = equal(r15C0, body.constant(int(64)));
                                    ir_if *f15D2 = new(mem_ctx) ir_if(operand(r15D3).val);
                                    exec_list *const f15D2_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f15D2->then_instructions;

                                       body.emit(assign(r15D1, r1444, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f15D2->else_instructions;

                                       ir_expression *const r15D4 = nequal(r1444, body.constant(0u));
                                       ir_expression *const r15D5 = expr(ir_unop_b2i, r15D4);
                                       body.emit(assign(r15D1, expr(ir_unop_i2u, r15D5), 0x01));


                                    body.instructions = f15D2_parent_instructions;
                                    body.emit(f15D2);

                                    /* END IF */

                                    body.emit(assign(r15C1, r15D1, 0x01));

                                    body.emit(assign(r15C2, body.constant(0u), 0x01));


                                 body.instructions = f15CE_parent_instructions;
                                 body.emit(f15CE);

                                 /* END IF */


                              body.instructions = f15CC_parent_instructions;
                              body.emit(f15CC);

                              /* END IF */

                              body.emit(assign(r15C3, body.constant(0u), 0x01));


                           body.instructions = f15C8_parent_instructions;
                           body.emit(f15C8);

                           /* END IF */

                           ir_expression *const r15D6 = nequal(r15BF, body.constant(0u));
                           ir_expression *const r15D7 = expr(ir_unop_b2i, r15D6);
                           ir_expression *const r15D8 = expr(ir_unop_i2u, r15D7);
                           body.emit(assign(r15C1, bit_or(r15C1, r15D8), 0x01));


                        body.instructions = f15C6_parent_instructions;
                        body.emit(f15C6);

                        /* END IF */

                        body.emit(assign(r15A9, r15C3, 0x01));

                        body.emit(assign(r15AA, r15C2, 0x01));

                        body.emit(assign(r15AB, r15C1, 0x01));

                        body.emit(assign(r15A8, body.constant(int(0)), 0x01));

                        body.emit(assign(r15AE, less(r15C1, body.constant(0u)), 0x01));


                     body.instructions = f15BD_parent_instructions;
                     body.emit(f15BD);

                     /* END IF */


                  body.instructions = f15BA_parent_instructions;
                  body.emit(f15BA);

                  /* END IF */


               body.instructions = f15B0_parent_instructions;
               body.emit(f15B0);

               /* END IF */

               /* IF CONDITION */
               ir_if *f15D9 = new(mem_ctx) ir_if(operand(r15AC).val);
               exec_list *const f15D9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f15D9->then_instructions;

                  /* IF CONDITION */
                  ir_if *f15DA = new(mem_ctx) ir_if(operand(r15AE).val);
                  exec_list *const f15DA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f15DA->then_instructions;

                     ir_variable *const r15DB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r15DB, add(r15AA, body.constant(1u)), 0x01));

                     ir_expression *const r15DC = less(r15DB, r15AA);
                     ir_expression *const r15DD = expr(ir_unop_b2i, r15DC);
                     ir_expression *const r15DE = expr(ir_unop_i2u, r15DD);
                     body.emit(assign(r15A9, add(r15A9, r15DE), 0x01));

                     ir_expression *const r15DF = equal(r15AB, body.constant(0u));
                     ir_expression *const r15E0 = expr(ir_unop_b2i, r15DF);
                     ir_expression *const r15E1 = expr(ir_unop_i2u, r15E0);
                     ir_expression *const r15E2 = add(r15AB, r15E1);
                     ir_expression *const r15E3 = bit_and(r15E2, body.constant(1u));
                     ir_expression *const r15E4 = expr(ir_unop_bit_not, r15E3);
                     body.emit(assign(r15AA, bit_and(r15DB, r15E4), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f15DA->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r15E6 = bit_or(r15A9, r15AA);
                     ir_expression *const r15E7 = equal(r15E6, body.constant(0u));
                     ir_if *f15E5 = new(mem_ctx) ir_if(operand(r15E7).val);
                     exec_list *const f15E5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f15E5->then_instructions;

                        body.emit(assign(r15A8, body.constant(int(0)), 0x01));


                     body.instructions = f15E5_parent_instructions;
                     body.emit(f15E5);

                     /* END IF */


                  body.instructions = f15DA_parent_instructions;
                  body.emit(f15DA);

                  /* END IF */

                  ir_variable *const r15E8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r15E8);
                  ir_expression *const r15E9 = lshift(r143C, body.constant(int(31)));
                  ir_expression *const r15EA = expr(ir_unop_i2u, r15A8);
                  ir_expression *const r15EB = lshift(r15EA, body.constant(int(20)));
                  ir_expression *const r15EC = add(r15E9, r15EB);
                  body.emit(assign(r15E8, add(r15EC, r15A9), 0x02));

                  body.emit(assign(r15E8, r15AA, 0x01));

                  body.emit(assign(r15AD, r15E8, 0x03));

                  body.emit(assign(r15AC, body.constant(false), 0x01));


               body.instructions = f15D9_parent_instructions;
               body.emit(f15D9);

               /* END IF */

               body.emit(assign(r143B, r15AD, 0x03));

               body.emit(assign(r143A, body.constant(false), 0x01));


            body.instructions = f152D_parent_instructions;
            body.emit(f152D);

            /* END IF */


         body.instructions = f14EA_parent_instructions;
         body.emit(f14EA);

         /* END IF */


      body.instructions = f147E_parent_instructions;
      body.emit(f147E);

      /* END IF */


   body.instructions = f144F_parent_instructions;
   body.emit(f144F);

   /* END IF */

   body.emit(ret(r143B));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
add96(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r15ED = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r15ED);
   ir_variable *const r15EE = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r15EE);
   ir_variable *const r15EF = new(mem_ctx) ir_variable(glsl_type::uint_type, "a2", ir_var_function_in);
   sig_parameters.push_tail(r15EF);
   ir_variable *const r15F0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r15F0);
   ir_variable *const r15F1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r15F1);
   ir_variable *const r15F2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b2", ir_var_function_in);
   sig_parameters.push_tail(r15F2);
   ir_variable *const r15F3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r15F3);
   ir_variable *const r15F4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r15F4);
   ir_variable *const r15F5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r15F5);
   ir_variable *const r15F6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r15F6);
   ir_variable *const r15F7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r15F7);
   ir_variable *const r15F8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r15F8, add(r15EF, r15F2), 0x01));

   ir_variable *const r15F9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   ir_expression *const r15FA = less(r15F8, r15EF);
   ir_expression *const r15FB = expr(ir_unop_b2i, r15FA);
   body.emit(assign(r15F9, expr(ir_unop_i2u, r15FB), 0x01));

   ir_variable *const r15FC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r15FC, add(r15EE, r15F1), 0x01));

   body.emit(assign(r15F7, add(r15FC, r15F9), 0x01));

   ir_expression *const r15FD = add(r15ED, r15F0);
   ir_expression *const r15FE = less(r15F7, r15F9);
   ir_expression *const r15FF = expr(ir_unop_b2i, r15FE);
   ir_expression *const r1600 = expr(ir_unop_i2u, r15FF);
   body.emit(assign(r15F6, add(r15FD, r1600), 0x01));

   ir_expression *const r1601 = less(r15FC, r15EE);
   ir_expression *const r1602 = expr(ir_unop_b2i, r1601);
   ir_expression *const r1603 = expr(ir_unop_i2u, r1602);
   body.emit(assign(r15F6, add(r15F6, r1603), 0x01));

   body.emit(assign(r15F5, r15F8, 0x01));

   body.emit(assign(r15F4, r15F7, 0x01));

   body.emit(assign(r15F3, r15F6, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
sub96(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1604 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r1604);
   ir_variable *const r1605 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r1605);
   ir_variable *const r1606 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a2", ir_var_function_in);
   sig_parameters.push_tail(r1606);
   ir_variable *const r1607 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r1607);
   ir_variable *const r1608 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r1608);
   ir_variable *const r1609 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b2", ir_var_function_in);
   sig_parameters.push_tail(r1609);
   ir_variable *const r160A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r160A);
   ir_variable *const r160B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r160B);
   ir_variable *const r160C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r160C);
   ir_variable *const r160D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r160D);
   ir_variable *const r160E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   ir_expression *const r160F = less(r1606, r1609);
   ir_expression *const r1610 = expr(ir_unop_b2i, r160F);
   body.emit(assign(r160E, expr(ir_unop_i2u, r1610), 0x01));

   ir_variable *const r1611 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1611, sub(r1605, r1608), 0x01));

   ir_expression *const r1612 = sub(r1604, r1607);
   ir_expression *const r1613 = less(r1611, r160E);
   ir_expression *const r1614 = expr(ir_unop_b2i, r1613);
   ir_expression *const r1615 = expr(ir_unop_i2u, r1614);
   body.emit(assign(r160D, sub(r1612, r1615), 0x01));

   ir_expression *const r1616 = less(r1605, r1608);
   ir_expression *const r1617 = expr(ir_unop_b2i, r1616);
   ir_expression *const r1618 = expr(ir_unop_i2u, r1617);
   body.emit(assign(r160D, sub(r160D, r1618), 0x01));

   body.emit(assign(r160C, sub(r1606, r1609), 0x01));

   body.emit(assign(r160B, sub(r1611, r160E), 0x01));

   body.emit(assign(r160A, r160D, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift64Right(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1619 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r1619);
   ir_variable *const r161A = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r161A);
   ir_variable *const r161B = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r161B);
   ir_variable *const r161C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r161C);
   ir_variable *const r161D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r161D);
   ir_variable *const r161E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r161E);
   ir_variable *const r161F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r161F);
   ir_variable *const r1620 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r1621 = neg(r161B);
   body.emit(assign(r1620, bit_and(r1621, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1623 = equal(r161B, body.constant(int(0)));
   ir_if *f1622 = new(mem_ctx) ir_if(operand(r1623).val);
   exec_list *const f1622_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1622->then_instructions;

      body.emit(assign(r161E, r161A, 0x01));

      body.emit(assign(r161F, r1619, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1622->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1625 = less(r161B, body.constant(int(32)));
      ir_if *f1624 = new(mem_ctx) ir_if(operand(r1625).val);
      exec_list *const f1624_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1624->then_instructions;

         ir_expression *const r1626 = lshift(r1619, r1620);
         ir_expression *const r1627 = rshift(r161A, r161B);
         body.emit(assign(r161E, bit_or(r1626, r1627), 0x01));

         body.emit(assign(r161F, rshift(r1619, r161B), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1624->else_instructions;

         ir_variable *const r1628 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r162A = less(r161B, body.constant(int(64)));
         ir_if *f1629 = new(mem_ctx) ir_if(operand(r162A).val);
         exec_list *const f1629_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1629->then_instructions;

            ir_expression *const r162B = bit_and(r161B, body.constant(int(31)));
            body.emit(assign(r1628, rshift(r1619, r162B), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1629->else_instructions;

            body.emit(assign(r1628, body.constant(0u), 0x01));


         body.instructions = f1629_parent_instructions;
         body.emit(f1629);

         /* END IF */

         body.emit(assign(r161E, r1628, 0x01));

         body.emit(assign(r161F, body.constant(0u), 0x01));


      body.instructions = f1624_parent_instructions;
      body.emit(f1624);

      /* END IF */


   body.instructions = f1622_parent_instructions;
   body.emit(f1622);

   /* END IF */

   body.emit(assign(r161D, r161E, 0x01));

   body.emit(assign(r161C, r161F, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
estimateDiv64To32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r162C = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r162C);
   ir_variable *const r162D = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r162D);
   ir_variable *const r162E = new(mem_ctx) ir_variable(glsl_type::uint_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r162E);
   ir_variable *const r162F = body.make_temp(glsl_type::uint_type, "return_value");
   ir_variable *const r1630 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
   body.emit(r1630);
   ir_variable *const r1631 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
   body.emit(r1631);
   ir_variable *const r1632 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
   body.emit(r1632);
   ir_variable *const r1633 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
   body.emit(r1633);
   body.emit(assign(r1632, body.constant(0u), 0x01));

   body.emit(assign(r1631, body.constant(0u), 0x01));

   /* IF CONDITION */
   ir_expression *const r1635 = lequal(r162E, r162C);
   ir_if *f1634 = new(mem_ctx) ir_if(operand(r1635).val);
   exec_list *const f1634_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1634->then_instructions;

      body.emit(assign(r162F, body.constant(4294967295u), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1634->else_instructions;

      body.emit(assign(r1633, rshift(r162E, body.constant(int(16))), 0x01));

      ir_variable *const r1636 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r1638 = lshift(r1633, body.constant(int(16)));
      ir_expression *const r1639 = lequal(r1638, r162C);
      ir_if *f1637 = new(mem_ctx) ir_if(operand(r1639).val);
      exec_list *const f1637_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1637->then_instructions;

         body.emit(assign(r1636, body.constant(4294901760u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1637->else_instructions;

         ir_expression *const r163A = expr(ir_binop_div, r162C, r1633);
         body.emit(assign(r1636, lshift(r163A, body.constant(int(16))), 0x01));


      body.instructions = f1637_parent_instructions;
      body.emit(f1637);

      /* END IF */

      body.emit(assign(r1630, r1636, 0x01));

      ir_variable *const r163B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r163B);
      ir_variable *const r163C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
      body.emit(r163C);
      ir_variable *const r163D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r163D);
      ir_variable *const r163E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r163E, bit_and(r162E, body.constant(65535u)), 0x01));

      ir_variable *const r163F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r163F, rshift(r162E, body.constant(int(16))), 0x01));

      ir_variable *const r1640 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r1640, bit_and(r1636, body.constant(65535u)), 0x01));

      ir_variable *const r1641 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r1641, rshift(r1636, body.constant(int(16))), 0x01));

      ir_variable *const r1642 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r1642, mul(r163F, r1640), 0x01));

      ir_expression *const r1643 = mul(r163E, r1641);
      body.emit(assign(r163C, add(r1643, r1642), 0x01));

      ir_expression *const r1644 = mul(r163F, r1641);
      ir_expression *const r1645 = less(r163C, r1642);
      ir_expression *const r1646 = expr(ir_unop_b2i, r1645);
      ir_expression *const r1647 = expr(ir_unop_i2u, r1646);
      ir_expression *const r1648 = lshift(r1647, body.constant(int(16)));
      ir_expression *const r1649 = rshift(r163C, body.constant(int(16)));
      ir_expression *const r164A = add(r1648, r1649);
      body.emit(assign(r163B, add(r1644, r164A), 0x01));

      body.emit(assign(r163C, lshift(r163C, body.constant(int(16))), 0x01));

      ir_expression *const r164B = mul(r163E, r1640);
      body.emit(assign(r163D, add(r164B, r163C), 0x01));

      ir_expression *const r164C = less(r163D, r163C);
      ir_expression *const r164D = expr(ir_unop_b2i, r164C);
      ir_expression *const r164E = expr(ir_unop_i2u, r164D);
      body.emit(assign(r163B, add(r163B, r164E), 0x01));

      ir_expression *const r164F = sub(r162C, r163B);
      ir_expression *const r1650 = less(r162D, r163D);
      ir_expression *const r1651 = expr(ir_unop_b2i, r1650);
      ir_expression *const r1652 = expr(ir_unop_i2u, r1651);
      body.emit(assign(r1632, sub(r164F, r1652), 0x01));

      body.emit(assign(r1631, sub(r162D, r163D), 0x01));

      /* LOOP BEGIN */
      ir_loop *f1653 = new(mem_ctx) ir_loop();
      exec_list *const f1653_parent_instructions = body.instructions;

         body.instructions = &f1653->body_instructions;

         /* IF CONDITION */
         ir_expression *const r1655 = expr(ir_unop_u2i, r1632);
         ir_expression *const r1656 = gequal(r1655, body.constant(int(0)));
         ir_if *f1654 = new(mem_ctx) ir_if(operand(r1656).val);
         exec_list *const f1654_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1654->then_instructions;

            body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


         body.instructions = f1654_parent_instructions;
         body.emit(f1654);

         /* END IF */

         body.emit(assign(r1630, add(r1630, body.constant(4294901760u)), 0x01));

         ir_variable *const r1657 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         ir_expression *const r1658 = lshift(r162E, body.constant(int(16)));
         body.emit(assign(r1657, add(r1631, r1658), 0x01));

         ir_expression *const r1659 = add(r1632, r1633);
         ir_expression *const r165A = less(r1657, r1631);
         ir_expression *const r165B = expr(ir_unop_b2i, r165A);
         ir_expression *const r165C = expr(ir_unop_i2u, r165B);
         body.emit(assign(r1632, add(r1659, r165C), 0x01));

         body.emit(assign(r1631, r1657, 0x01));

      /* LOOP END */

      body.instructions = f1653_parent_instructions;
      body.emit(f1653);

      ir_expression *const r165D = lshift(r1632, body.constant(int(16)));
      ir_expression *const r165E = rshift(r1631, body.constant(int(16)));
      body.emit(assign(r1632, bit_or(r165D, r165E), 0x01));

      ir_variable *const r165F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r1661 = lshift(r1633, body.constant(int(16)));
      ir_expression *const r1662 = lequal(r1661, r1632);
      ir_if *f1660 = new(mem_ctx) ir_if(operand(r1662).val);
      exec_list *const f1660_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1660->then_instructions;

         body.emit(assign(r165F, body.constant(65535u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1660->else_instructions;

         body.emit(assign(r165F, expr(ir_binop_div, r1632, r1633), 0x01));


      body.instructions = f1660_parent_instructions;
      body.emit(f1660);

      /* END IF */

      body.emit(assign(r1630, bit_or(r1630, r165F), 0x01));

      body.emit(assign(r162F, r1630, 0x01));


   body.instructions = f1634_parent_instructions;
   body.emit(f1634);

   /* END IF */

   body.emit(ret(r162F));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
mul64By32To96(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1663 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r1663);
   ir_variable *const r1664 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r1664);
   ir_variable *const r1665 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r1665);
   ir_variable *const r1666 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1666);
   ir_variable *const r1667 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1667);
   ir_variable *const r1668 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1668);
   ir_variable *const r1669 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r1669);
   ir_variable *const r166A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r166A);
   ir_variable *const r166B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r166B);
   ir_variable *const r166C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r166C, bit_and(r1664, body.constant(65535u)), 0x01));

   ir_variable *const r166D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r166D, rshift(r1664, body.constant(int(16))), 0x01));

   ir_variable *const r166E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r166E, bit_and(r1665, body.constant(65535u)), 0x01));

   ir_variable *const r166F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r166F, rshift(r1665, body.constant(int(16))), 0x01));

   ir_variable *const r1670 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1670, mul(r166D, r166E), 0x01));

   ir_expression *const r1671 = mul(r166C, r166F);
   body.emit(assign(r166A, add(r1671, r1670), 0x01));

   ir_expression *const r1672 = mul(r166D, r166F);
   ir_expression *const r1673 = less(r166A, r1670);
   ir_expression *const r1674 = expr(ir_unop_b2i, r1673);
   ir_expression *const r1675 = expr(ir_unop_i2u, r1674);
   ir_expression *const r1676 = lshift(r1675, body.constant(int(16)));
   ir_expression *const r1677 = rshift(r166A, body.constant(int(16)));
   ir_expression *const r1678 = add(r1676, r1677);
   body.emit(assign(r1669, add(r1672, r1678), 0x01));

   body.emit(assign(r166A, lshift(r166A, body.constant(int(16))), 0x01));

   ir_expression *const r1679 = mul(r166C, r166E);
   body.emit(assign(r166B, add(r1679, r166A), 0x01));

   ir_expression *const r167A = less(r166B, r166A);
   ir_expression *const r167B = expr(ir_unop_b2i, r167A);
   ir_expression *const r167C = expr(ir_unop_i2u, r167B);
   body.emit(assign(r1669, add(r1669, r167C), 0x01));

   ir_variable *const r167D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r167D);
   ir_variable *const r167E = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r167E);
   ir_variable *const r167F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r167F);
   ir_variable *const r1680 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1680, bit_and(r1663, body.constant(65535u)), 0x01));

   ir_variable *const r1681 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1681, rshift(r1663, body.constant(int(16))), 0x01));

   ir_variable *const r1682 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1682, bit_and(r1665, body.constant(65535u)), 0x01));

   ir_variable *const r1683 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1683, rshift(r1665, body.constant(int(16))), 0x01));

   ir_variable *const r1684 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1684, mul(r1681, r1682), 0x01));

   ir_expression *const r1685 = mul(r1680, r1683);
   body.emit(assign(r167E, add(r1685, r1684), 0x01));

   ir_expression *const r1686 = mul(r1681, r1683);
   ir_expression *const r1687 = less(r167E, r1684);
   ir_expression *const r1688 = expr(ir_unop_b2i, r1687);
   ir_expression *const r1689 = expr(ir_unop_i2u, r1688);
   ir_expression *const r168A = lshift(r1689, body.constant(int(16)));
   ir_expression *const r168B = rshift(r167E, body.constant(int(16)));
   ir_expression *const r168C = add(r168A, r168B);
   body.emit(assign(r167D, add(r1686, r168C), 0x01));

   body.emit(assign(r167E, lshift(r167E, body.constant(int(16))), 0x01));

   ir_expression *const r168D = mul(r1680, r1682);
   body.emit(assign(r167F, add(r168D, r167E), 0x01));

   ir_expression *const r168E = less(r167F, r167E);
   ir_expression *const r168F = expr(ir_unop_b2i, r168E);
   ir_expression *const r1690 = expr(ir_unop_i2u, r168F);
   body.emit(assign(r167D, add(r167D, r1690), 0x01));

   ir_variable *const r1691 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1691, add(r167F, r1669), 0x01));

   body.emit(assign(r1668, r166B, 0x01));

   body.emit(assign(r1667, r1691, 0x01));

   ir_expression *const r1692 = less(r1691, r167F);
   ir_expression *const r1693 = expr(ir_unop_b2i, r1692);
   ir_expression *const r1694 = expr(ir_unop_i2u, r1693);
   body.emit(assign(r1666, add(r167D, r1694), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fdiv64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1695 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1695);
   ir_variable *const r1696 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r1696);
   ir_variable *const r1697 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r1697, body.constant(true), 0x01));

   ir_variable *const r1698 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1699 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_auto);
   body.emit(r1699);
   ir_variable *const r169A = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
   body.emit(r169A);
   ir_variable *const r169B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
   body.emit(r169B);
   ir_variable *const r169C = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r169C);
   ir_variable *const r169D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
   body.emit(r169D);
   ir_variable *const r169E = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem3", ir_var_auto);
   body.emit(r169E);
   ir_variable *const r169F = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem2", ir_var_auto);
   body.emit(r169F);
   ir_variable *const r16A0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
   body.emit(r16A0);
   ir_variable *const r16A1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
   body.emit(r16A1);
   ir_variable *const r16A2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r16A2);
   ir_variable *const r16A3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r16A3);
   ir_variable *const r16A4 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r16A4);
   body.emit(assign(r16A3, body.constant(0u), 0x01));

   body.emit(assign(r16A2, body.constant(0u), 0x01));

   body.emit(assign(r16A1, body.constant(0u), 0x01));

   body.emit(assign(r16A0, body.constant(0u), 0x01));

   body.emit(assign(r169F, body.constant(0u), 0x01));

   body.emit(assign(r169E, body.constant(0u), 0x01));

   ir_variable *const r16A5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r16A5);
   body.emit(assign(r16A5, bit_and(swizzle_y(r1695), body.constant(1048575u)), 0x02));

   body.emit(assign(r16A5, swizzle_x(r1695), 0x01));

   body.emit(assign(r169D, r16A5, 0x03));

   ir_variable *const r16A6 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r16A7 = rshift(swizzle_y(r1695), body.constant(int(20)));
   ir_expression *const r16A8 = bit_and(r16A7, body.constant(2047u));
   body.emit(assign(r16A6, expr(ir_unop_u2i, r16A8), 0x01));

   body.emit(assign(r169C, r16A6, 0x01));

   ir_variable *const r16A9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r16A9);
   body.emit(assign(r16A9, bit_and(swizzle_y(r1696), body.constant(1048575u)), 0x02));

   body.emit(assign(r16A9, swizzle_x(r1696), 0x01));

   body.emit(assign(r169B, r16A9, 0x03));

   ir_variable *const r16AA = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r16AB = rshift(swizzle_y(r1696), body.constant(int(20)));
   ir_expression *const r16AC = bit_and(r16AB, body.constant(2047u));
   body.emit(assign(r16AA, expr(ir_unop_u2i, r16AC), 0x01));

   body.emit(assign(r169A, r16AA, 0x01));

   ir_expression *const r16AD = rshift(swizzle_y(r1695), body.constant(int(31)));
   ir_expression *const r16AE = rshift(swizzle_y(r1696), body.constant(int(31)));
   body.emit(assign(r1699, bit_xor(r16AD, r16AE), 0x01));

   /* IF CONDITION */
   ir_expression *const r16B0 = equal(r16A6, body.constant(int(2047)));
   ir_if *f16AF = new(mem_ctx) ir_if(operand(r16B0).val);
   exec_list *const f16AF_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f16AF->then_instructions;

      /* IF CONDITION */
      ir_expression *const r16B2 = bit_or(swizzle_y(r16A5), swizzle_x(r1695));
      ir_expression *const r16B3 = nequal(r16B2, body.constant(0u));
      ir_if *f16B1 = new(mem_ctx) ir_if(operand(r16B3).val);
      exec_list *const f16B1_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f16B1->then_instructions;

         ir_variable *const r16B4 = body.make_temp(glsl_type::uvec2_type, "a");
         body.emit(assign(r16B4, swizzle_x(r1695), 0x01));

         ir_variable *const r16B5 = body.make_temp(glsl_type::uvec2_type, "b");
         body.emit(assign(r16B5, swizzle_x(r1696), 0x01));

         ir_variable *const r16B6 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r16B7 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
         ir_expression *const r16B8 = rshift(swizzle_y(r1695), body.constant(int(19)));
         ir_expression *const r16B9 = bit_and(r16B8, body.constant(4095u));
         ir_expression *const r16BA = equal(r16B9, body.constant(4094u));
         ir_expression *const r16BB = nequal(swizzle_x(r1695), body.constant(0u));
         ir_expression *const r16BC = bit_and(swizzle_y(r1695), body.constant(524287u));
         ir_expression *const r16BD = nequal(r16BC, body.constant(0u));
         ir_expression *const r16BE = logic_or(r16BB, r16BD);
         body.emit(assign(r16B7, logic_and(r16BA, r16BE), 0x01));

         ir_variable *const r16BF = body.make_temp(glsl_type::bool_type, "is_nan_retval");
         ir_expression *const r16C0 = lshift(swizzle_y(r1696), body.constant(int(1)));
         ir_expression *const r16C1 = lequal(body.constant(4292870144u), r16C0);
         ir_expression *const r16C2 = nequal(swizzle_x(r1696), body.constant(0u));
         ir_expression *const r16C3 = bit_and(swizzle_y(r1696), body.constant(1048575u));
         ir_expression *const r16C4 = nequal(r16C3, body.constant(0u));
         ir_expression *const r16C5 = logic_or(r16C2, r16C4);
         body.emit(assign(r16BF, logic_and(r16C1, r16C5), 0x01));

         body.emit(assign(r16B4, bit_or(swizzle_y(r1695), body.constant(524288u)), 0x02));

         body.emit(assign(r16B5, bit_or(swizzle_y(r1696), body.constant(524288u)), 0x02));

         /* IF CONDITION */
         ir_expression *const r16C7 = lshift(swizzle_y(r1695), body.constant(int(1)));
         ir_expression *const r16C8 = lequal(body.constant(4292870144u), r16C7);
         ir_expression *const r16C9 = nequal(swizzle_x(r1695), body.constant(0u));
         ir_expression *const r16CA = bit_and(swizzle_y(r1695), body.constant(1048575u));
         ir_expression *const r16CB = nequal(r16CA, body.constant(0u));
         ir_expression *const r16CC = logic_or(r16C9, r16CB);
         ir_expression *const r16CD = logic_and(r16C8, r16CC);
         ir_if *f16C6 = new(mem_ctx) ir_if(operand(r16CD).val);
         exec_list *const f16C6_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f16C6->then_instructions;

            ir_variable *const r16CE = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r16D0 = logic_and(r16B7, r16BF);
            ir_if *f16CF = new(mem_ctx) ir_if(operand(r16D0).val);
            exec_list *const f16CF_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f16CF->then_instructions;

               body.emit(assign(r16CE, r16B5, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f16CF->else_instructions;

               body.emit(assign(r16CE, r16B4, 0x03));


            body.instructions = f16CF_parent_instructions;
            body.emit(f16CF);

            /* END IF */

            body.emit(assign(r16B6, r16CE, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f16C6->else_instructions;

            body.emit(assign(r16B6, r16B5, 0x03));


         body.instructions = f16C6_parent_instructions;
         body.emit(f16C6);

         /* END IF */

         body.emit(assign(r1698, r16B6, 0x03));

         body.emit(assign(r1697, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f16B1->else_instructions;

         /* IF CONDITION */
         ir_expression *const r16D2 = equal(r16AA, body.constant(int(2047)));
         ir_if *f16D1 = new(mem_ctx) ir_if(operand(r16D2).val);
         exec_list *const f16D1_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f16D1->then_instructions;

            /* IF CONDITION */
            ir_expression *const r16D4 = bit_or(swizzle_y(r16A9), swizzle_x(r1696));
            ir_expression *const r16D5 = nequal(r16D4, body.constant(0u));
            ir_if *f16D3 = new(mem_ctx) ir_if(operand(r16D5).val);
            exec_list *const f16D3_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f16D3->then_instructions;

               ir_variable *const r16D6 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r16D6, swizzle_x(r1695), 0x01));

               ir_variable *const r16D7 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r16D7, swizzle_x(r1696), 0x01));

               ir_variable *const r16D8 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r16D9 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r16DA = rshift(swizzle_y(r1695), body.constant(int(19)));
               ir_expression *const r16DB = bit_and(r16DA, body.constant(4095u));
               ir_expression *const r16DC = equal(r16DB, body.constant(4094u));
               ir_expression *const r16DD = nequal(swizzle_x(r1695), body.constant(0u));
               ir_expression *const r16DE = bit_and(swizzle_y(r1695), body.constant(524287u));
               ir_expression *const r16DF = nequal(r16DE, body.constant(0u));
               ir_expression *const r16E0 = logic_or(r16DD, r16DF);
               body.emit(assign(r16D9, logic_and(r16DC, r16E0), 0x01));

               ir_variable *const r16E1 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r16E2 = lshift(swizzle_y(r1696), body.constant(int(1)));
               ir_expression *const r16E3 = lequal(body.constant(4292870144u), r16E2);
               ir_expression *const r16E4 = nequal(swizzle_x(r1696), body.constant(0u));
               ir_expression *const r16E5 = bit_and(swizzle_y(r1696), body.constant(1048575u));
               ir_expression *const r16E6 = nequal(r16E5, body.constant(0u));
               ir_expression *const r16E7 = logic_or(r16E4, r16E6);
               body.emit(assign(r16E1, logic_and(r16E3, r16E7), 0x01));

               body.emit(assign(r16D6, bit_or(swizzle_y(r1695), body.constant(524288u)), 0x02));

               body.emit(assign(r16D7, bit_or(swizzle_y(r1696), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r16E9 = lshift(swizzle_y(r1695), body.constant(int(1)));
               ir_expression *const r16EA = lequal(body.constant(4292870144u), r16E9);
               ir_expression *const r16EB = nequal(swizzle_x(r1695), body.constant(0u));
               ir_expression *const r16EC = bit_and(swizzle_y(r1695), body.constant(1048575u));
               ir_expression *const r16ED = nequal(r16EC, body.constant(0u));
               ir_expression *const r16EE = logic_or(r16EB, r16ED);
               ir_expression *const r16EF = logic_and(r16EA, r16EE);
               ir_if *f16E8 = new(mem_ctx) ir_if(operand(r16EF).val);
               exec_list *const f16E8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f16E8->then_instructions;

                  ir_variable *const r16F0 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r16F2 = logic_and(r16D9, r16E1);
                  ir_if *f16F1 = new(mem_ctx) ir_if(operand(r16F2).val);
                  exec_list *const f16F1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f16F1->then_instructions;

                     body.emit(assign(r16F0, r16D7, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f16F1->else_instructions;

                     body.emit(assign(r16F0, r16D6, 0x03));


                  body.instructions = f16F1_parent_instructions;
                  body.emit(f16F1);

                  /* END IF */

                  body.emit(assign(r16D8, r16F0, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f16E8->else_instructions;

                  body.emit(assign(r16D8, r16D7, 0x03));


               body.instructions = f16E8_parent_instructions;
               body.emit(f16E8);

               /* END IF */

               body.emit(assign(r1698, r16D8, 0x03));

               body.emit(assign(r1697, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f16D3->else_instructions;

               ir_constant_data r16F3_data;
               memset(&r16F3_data, 0, sizeof(ir_constant_data));
               r16F3_data.u[0] = 4294967295;
               r16F3_data.u[1] = 4294967295;
               ir_constant *const r16F3 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r16F3_data);
               body.emit(assign(r1698, r16F3, 0x03));

               body.emit(assign(r1697, body.constant(false), 0x01));


            body.instructions = f16D3_parent_instructions;
            body.emit(f16D3);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f16D1->else_instructions;

            ir_variable *const r16F4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r16F4);
            ir_expression *const r16F5 = lshift(r1699, body.constant(int(31)));
            body.emit(assign(r16F4, add(r16F5, body.constant(2146435072u)), 0x02));

            body.emit(assign(r16F4, body.constant(0u), 0x01));

            body.emit(assign(r1698, r16F4, 0x03));

            body.emit(assign(r1697, body.constant(false), 0x01));


         body.instructions = f16D1_parent_instructions;
         body.emit(f16D1);

         /* END IF */


      body.instructions = f16B1_parent_instructions;
      body.emit(f16B1);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f16AF->else_instructions;

      /* IF CONDITION */
      ir_expression *const r16F7 = equal(r16AA, body.constant(int(2047)));
      ir_if *f16F6 = new(mem_ctx) ir_if(operand(r16F7).val);
      exec_list *const f16F6_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f16F6->then_instructions;

         /* IF CONDITION */
         ir_expression *const r16F9 = bit_or(swizzle_y(r16A9), swizzle_x(r1696));
         ir_expression *const r16FA = nequal(r16F9, body.constant(0u));
         ir_if *f16F8 = new(mem_ctx) ir_if(operand(r16FA).val);
         exec_list *const f16F8_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f16F8->then_instructions;

            ir_variable *const r16FB = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r16FB, swizzle_x(r1695), 0x01));

            ir_variable *const r16FC = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r16FC, swizzle_x(r1696), 0x01));

            ir_variable *const r16FD = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r16FE = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r16FF = rshift(swizzle_y(r1695), body.constant(int(19)));
            ir_expression *const r1700 = bit_and(r16FF, body.constant(4095u));
            ir_expression *const r1701 = equal(r1700, body.constant(4094u));
            ir_expression *const r1702 = nequal(swizzle_x(r1695), body.constant(0u));
            ir_expression *const r1703 = bit_and(swizzle_y(r1695), body.constant(524287u));
            ir_expression *const r1704 = nequal(r1703, body.constant(0u));
            ir_expression *const r1705 = logic_or(r1702, r1704);
            body.emit(assign(r16FE, logic_and(r1701, r1705), 0x01));

            ir_variable *const r1706 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r1707 = lshift(swizzle_y(r1696), body.constant(int(1)));
            ir_expression *const r1708 = lequal(body.constant(4292870144u), r1707);
            ir_expression *const r1709 = nequal(swizzle_x(r1696), body.constant(0u));
            ir_expression *const r170A = bit_and(swizzle_y(r1696), body.constant(1048575u));
            ir_expression *const r170B = nequal(r170A, body.constant(0u));
            ir_expression *const r170C = logic_or(r1709, r170B);
            body.emit(assign(r1706, logic_and(r1708, r170C), 0x01));

            body.emit(assign(r16FB, bit_or(swizzle_y(r1695), body.constant(524288u)), 0x02));

            body.emit(assign(r16FC, bit_or(swizzle_y(r1696), body.constant(524288u)), 0x02));

            /* IF CONDITION */
            ir_expression *const r170E = lshift(swizzle_y(r1695), body.constant(int(1)));
            ir_expression *const r170F = lequal(body.constant(4292870144u), r170E);
            ir_expression *const r1710 = nequal(swizzle_x(r1695), body.constant(0u));
            ir_expression *const r1711 = bit_and(swizzle_y(r1695), body.constant(1048575u));
            ir_expression *const r1712 = nequal(r1711, body.constant(0u));
            ir_expression *const r1713 = logic_or(r1710, r1712);
            ir_expression *const r1714 = logic_and(r170F, r1713);
            ir_if *f170D = new(mem_ctx) ir_if(operand(r1714).val);
            exec_list *const f170D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f170D->then_instructions;

               ir_variable *const r1715 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r1717 = logic_and(r16FE, r1706);
               ir_if *f1716 = new(mem_ctx) ir_if(operand(r1717).val);
               exec_list *const f1716_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1716->then_instructions;

                  body.emit(assign(r1715, r16FC, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1716->else_instructions;

                  body.emit(assign(r1715, r16FB, 0x03));


               body.instructions = f1716_parent_instructions;
               body.emit(f1716);

               /* END IF */

               body.emit(assign(r16FD, r1715, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f170D->else_instructions;

               body.emit(assign(r16FD, r16FC, 0x03));


            body.instructions = f170D_parent_instructions;
            body.emit(f170D);

            /* END IF */

            body.emit(assign(r1698, r16FD, 0x03));

            body.emit(assign(r1697, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f16F8->else_instructions;

            ir_variable *const r1718 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r1718);
            body.emit(assign(r1718, lshift(r1699, body.constant(int(31))), 0x02));

            body.emit(assign(r1718, body.constant(0u), 0x01));

            body.emit(assign(r1698, r1718, 0x03));

            body.emit(assign(r1697, body.constant(false), 0x01));


         body.instructions = f16F8_parent_instructions;
         body.emit(f16F8);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f16F6->else_instructions;

         /* IF CONDITION */
         ir_expression *const r171A = equal(r16AA, body.constant(int(0)));
         ir_if *f1719 = new(mem_ctx) ir_if(operand(r171A).val);
         exec_list *const f1719_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1719->then_instructions;

            /* IF CONDITION */
            ir_expression *const r171C = bit_or(swizzle_y(r16A9), swizzle_x(r1696));
            ir_expression *const r171D = equal(r171C, body.constant(0u));
            ir_if *f171B = new(mem_ctx) ir_if(operand(r171D).val);
            exec_list *const f171B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f171B->then_instructions;

               /* IF CONDITION */
               ir_expression *const r171F = expr(ir_unop_i2u, r16A6);
               ir_expression *const r1720 = bit_or(r171F, swizzle_y(r16A5));
               ir_expression *const r1721 = bit_or(r1720, swizzle_x(r1695));
               ir_expression *const r1722 = equal(r1721, body.constant(0u));
               ir_if *f171E = new(mem_ctx) ir_if(operand(r1722).val);
               exec_list *const f171E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f171E->then_instructions;

                  ir_constant_data r1723_data;
                  memset(&r1723_data, 0, sizeof(ir_constant_data));
                  r1723_data.u[0] = 4294967295;
                  r1723_data.u[1] = 4294967295;
                  ir_constant *const r1723 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r1723_data);
                  body.emit(assign(r1698, r1723, 0x03));

                  body.emit(assign(r1697, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f171E->else_instructions;

                  ir_variable *const r1724 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1724);
                  ir_expression *const r1725 = lshift(r1699, body.constant(int(31)));
                  body.emit(assign(r1724, add(r1725, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r1724, body.constant(0u), 0x01));

                  body.emit(assign(r1698, r1724, 0x03));

                  body.emit(assign(r1697, body.constant(false), 0x01));


               body.instructions = f171E_parent_instructions;
               body.emit(f171E);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f171B->else_instructions;

               ir_variable *const r1726 = body.make_temp(glsl_type::uint_type, "aFrac0");
               body.emit(assign(r1726, swizzle_y(r16A9), 0x01));

               ir_variable *const r1727 = body.make_temp(glsl_type::uint_type, "aFrac1");
               body.emit(assign(r1727, swizzle_x(r16A9), 0x01));

               ir_variable *const r1728 = body.make_temp(glsl_type::int_type, "zExpPtr");
               body.emit(assign(r1728, r16AA, 0x01));

               ir_variable *const r1729 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
               body.emit(assign(r1729, swizzle_y(r16A9), 0x01));

               ir_variable *const r172A = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
               body.emit(assign(r172A, swizzle_x(r16A9), 0x01));

               ir_variable *const r172B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r172B);
               /* IF CONDITION */
               ir_expression *const r172D = equal(swizzle_y(r16A9), body.constant(0u));
               ir_if *f172C = new(mem_ctx) ir_if(operand(r172D).val);
               exec_list *const f172C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f172C->then_instructions;

                  ir_variable *const r172E = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r172E, r1727, 0x01));

                  ir_variable *const r172F = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r1730 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r1730);
                  /* IF CONDITION */
                  ir_expression *const r1732 = equal(swizzle_x(r1696), body.constant(0u));
                  ir_if *f1731 = new(mem_ctx) ir_if(operand(r1732).val);
                  exec_list *const f1731_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1731->then_instructions;

                     body.emit(assign(r172F, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1731->else_instructions;

                     body.emit(assign(r1730, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1734 = bit_and(swizzle_x(r1696), body.constant(4294901760u));
                     ir_expression *const r1735 = equal(r1734, body.constant(0u));
                     ir_if *f1733 = new(mem_ctx) ir_if(operand(r1735).val);
                     exec_list *const f1733_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1733->then_instructions;

                        body.emit(assign(r1730, body.constant(int(16)), 0x01));

                        body.emit(assign(r172E, lshift(swizzle_x(r1696), body.constant(int(16))), 0x01));


                     body.instructions = f1733_parent_instructions;
                     body.emit(f1733);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1737 = bit_and(r172E, body.constant(4278190080u));
                     ir_expression *const r1738 = equal(r1737, body.constant(0u));
                     ir_if *f1736 = new(mem_ctx) ir_if(operand(r1738).val);
                     exec_list *const f1736_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1736->then_instructions;

                        body.emit(assign(r1730, add(r1730, body.constant(int(8))), 0x01));

                        body.emit(assign(r172E, lshift(r172E, body.constant(int(8))), 0x01));


                     body.instructions = f1736_parent_instructions;
                     body.emit(f1736);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r173A = bit_and(r172E, body.constant(4026531840u));
                     ir_expression *const r173B = equal(r173A, body.constant(0u));
                     ir_if *f1739 = new(mem_ctx) ir_if(operand(r173B).val);
                     exec_list *const f1739_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1739->then_instructions;

                        body.emit(assign(r1730, add(r1730, body.constant(int(4))), 0x01));

                        body.emit(assign(r172E, lshift(r172E, body.constant(int(4))), 0x01));


                     body.instructions = f1739_parent_instructions;
                     body.emit(f1739);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r173D = bit_and(r172E, body.constant(3221225472u));
                     ir_expression *const r173E = equal(r173D, body.constant(0u));
                     ir_if *f173C = new(mem_ctx) ir_if(operand(r173E).val);
                     exec_list *const f173C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f173C->then_instructions;

                        body.emit(assign(r1730, add(r1730, body.constant(int(2))), 0x01));

                        body.emit(assign(r172E, lshift(r172E, body.constant(int(2))), 0x01));


                     body.instructions = f173C_parent_instructions;
                     body.emit(f173C);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1740 = bit_and(r172E, body.constant(2147483648u));
                     ir_expression *const r1741 = equal(r1740, body.constant(0u));
                     ir_if *f173F = new(mem_ctx) ir_if(operand(r1741).val);
                     exec_list *const f173F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f173F->then_instructions;

                        body.emit(assign(r1730, add(r1730, body.constant(int(1))), 0x01));


                     body.instructions = f173F_parent_instructions;
                     body.emit(f173F);

                     /* END IF */

                     body.emit(assign(r172F, r1730, 0x01));


                  body.instructions = f1731_parent_instructions;
                  body.emit(f1731);

                  /* END IF */

                  body.emit(assign(r172B, add(r172F, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1743 = less(r172B, body.constant(int(0)));
                  ir_if *f1742 = new(mem_ctx) ir_if(operand(r1743).val);
                  exec_list *const f1742_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1742->then_instructions;

                     ir_expression *const r1744 = neg(r172B);
                     body.emit(assign(r1729, rshift(swizzle_x(r1696), r1744), 0x01));

                     ir_expression *const r1745 = bit_and(r172B, body.constant(int(31)));
                     body.emit(assign(r172A, lshift(swizzle_x(r1696), r1745), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1742->else_instructions;

                     body.emit(assign(r1729, lshift(swizzle_x(r1696), r172B), 0x01));

                     body.emit(assign(r172A, body.constant(0u), 0x01));


                  body.instructions = f1742_parent_instructions;
                  body.emit(f1742);

                  /* END IF */

                  body.emit(assign(r1728, sub(body.constant(int(-31)), r172B), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f172C->else_instructions;

                  ir_variable *const r1746 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r1746, r1726, 0x01));

                  ir_variable *const r1747 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r1748 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r1748);
                  /* IF CONDITION */
                  ir_expression *const r174A = equal(swizzle_y(r16A9), body.constant(0u));
                  ir_if *f1749 = new(mem_ctx) ir_if(operand(r174A).val);
                  exec_list *const f1749_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1749->then_instructions;

                     body.emit(assign(r1747, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1749->else_instructions;

                     body.emit(assign(r1748, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r174C = bit_and(swizzle_y(r16A9), body.constant(4294901760u));
                     ir_expression *const r174D = equal(r174C, body.constant(0u));
                     ir_if *f174B = new(mem_ctx) ir_if(operand(r174D).val);
                     exec_list *const f174B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f174B->then_instructions;

                        body.emit(assign(r1748, body.constant(int(16)), 0x01));

                        body.emit(assign(r1746, lshift(swizzle_y(r16A9), body.constant(int(16))), 0x01));


                     body.instructions = f174B_parent_instructions;
                     body.emit(f174B);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r174F = bit_and(r1746, body.constant(4278190080u));
                     ir_expression *const r1750 = equal(r174F, body.constant(0u));
                     ir_if *f174E = new(mem_ctx) ir_if(operand(r1750).val);
                     exec_list *const f174E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f174E->then_instructions;

                        body.emit(assign(r1748, add(r1748, body.constant(int(8))), 0x01));

                        body.emit(assign(r1746, lshift(r1746, body.constant(int(8))), 0x01));


                     body.instructions = f174E_parent_instructions;
                     body.emit(f174E);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1752 = bit_and(r1746, body.constant(4026531840u));
                     ir_expression *const r1753 = equal(r1752, body.constant(0u));
                     ir_if *f1751 = new(mem_ctx) ir_if(operand(r1753).val);
                     exec_list *const f1751_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1751->then_instructions;

                        body.emit(assign(r1748, add(r1748, body.constant(int(4))), 0x01));

                        body.emit(assign(r1746, lshift(r1746, body.constant(int(4))), 0x01));


                     body.instructions = f1751_parent_instructions;
                     body.emit(f1751);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1755 = bit_and(r1746, body.constant(3221225472u));
                     ir_expression *const r1756 = equal(r1755, body.constant(0u));
                     ir_if *f1754 = new(mem_ctx) ir_if(operand(r1756).val);
                     exec_list *const f1754_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1754->then_instructions;

                        body.emit(assign(r1748, add(r1748, body.constant(int(2))), 0x01));

                        body.emit(assign(r1746, lshift(r1746, body.constant(int(2))), 0x01));


                     body.instructions = f1754_parent_instructions;
                     body.emit(f1754);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1758 = bit_and(r1746, body.constant(2147483648u));
                     ir_expression *const r1759 = equal(r1758, body.constant(0u));
                     ir_if *f1757 = new(mem_ctx) ir_if(operand(r1759).val);
                     exec_list *const f1757_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1757->then_instructions;

                        body.emit(assign(r1748, add(r1748, body.constant(int(1))), 0x01));


                     body.instructions = f1757_parent_instructions;
                     body.emit(f1757);

                     /* END IF */

                     body.emit(assign(r1747, r1748, 0x01));


                  body.instructions = f1749_parent_instructions;
                  body.emit(f1749);

                  /* END IF */

                  body.emit(assign(r172B, add(r1747, body.constant(int(-11))), 0x01));

                  ir_variable *const r175A = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r175A, lshift(swizzle_x(r1696), r172B), 0x01));

                  ir_variable *const r175B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r175D = equal(r172B, body.constant(int(0)));
                  ir_if *f175C = new(mem_ctx) ir_if(operand(r175D).val);
                  exec_list *const f175C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f175C->then_instructions;

                     body.emit(assign(r175B, r1726, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f175C->else_instructions;

                     ir_expression *const r175E = lshift(swizzle_y(r16A9), r172B);
                     ir_expression *const r175F = neg(r172B);
                     ir_expression *const r1760 = bit_and(r175F, body.constant(int(31)));
                     ir_expression *const r1761 = rshift(swizzle_x(r1696), r1760);
                     body.emit(assign(r175B, bit_or(r175E, r1761), 0x01));


                  body.instructions = f175C_parent_instructions;
                  body.emit(f175C);

                  /* END IF */

                  body.emit(assign(r1729, r175B, 0x01));

                  body.emit(assign(r172A, r175A, 0x01));

                  body.emit(assign(r1728, sub(body.constant(int(1)), r172B), 0x01));


               body.instructions = f172C_parent_instructions;
               body.emit(f172C);

               /* END IF */

               body.emit(assign(r169A, r1728, 0x01));

               body.emit(assign(r169B, r1729, 0x02));

               body.emit(assign(r169B, r172A, 0x01));


            body.instructions = f171B_parent_instructions;
            body.emit(f171B);

            /* END IF */


         body.instructions = f1719_parent_instructions;
         body.emit(f1719);

         /* END IF */

         /* IF CONDITION */
         ir_if *f1762 = new(mem_ctx) ir_if(operand(r1697).val);
         exec_list *const f1762_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1762->then_instructions;

            /* IF CONDITION */
            ir_expression *const r1764 = equal(r16A6, body.constant(int(0)));
            ir_if *f1763 = new(mem_ctx) ir_if(operand(r1764).val);
            exec_list *const f1763_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1763->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1766 = bit_or(swizzle_y(r16A5), swizzle_x(r1695));
               ir_expression *const r1767 = equal(r1766, body.constant(0u));
               ir_if *f1765 = new(mem_ctx) ir_if(operand(r1767).val);
               exec_list *const f1765_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1765->then_instructions;

                  ir_variable *const r1768 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1768);
                  body.emit(assign(r1768, lshift(r1699, body.constant(int(31))), 0x02));

                  body.emit(assign(r1768, body.constant(0u), 0x01));

                  body.emit(assign(r1698, r1768, 0x03));

                  body.emit(assign(r1697, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1765->else_instructions;

                  ir_variable *const r1769 = body.make_temp(glsl_type::uint_type, "aFrac0");
                  body.emit(assign(r1769, swizzle_y(r16A5), 0x01));

                  ir_variable *const r176A = body.make_temp(glsl_type::uint_type, "aFrac1");
                  body.emit(assign(r176A, swizzle_x(r16A5), 0x01));

                  ir_variable *const r176B = body.make_temp(glsl_type::int_type, "zExpPtr");
                  body.emit(assign(r176B, r16A6, 0x01));

                  ir_variable *const r176C = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
                  body.emit(assign(r176C, swizzle_y(r16A5), 0x01));

                  ir_variable *const r176D = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
                  body.emit(assign(r176D, swizzle_x(r16A5), 0x01));

                  ir_variable *const r176E = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r176E);
                  /* IF CONDITION */
                  ir_expression *const r1770 = equal(swizzle_y(r16A5), body.constant(0u));
                  ir_if *f176F = new(mem_ctx) ir_if(operand(r1770).val);
                  exec_list *const f176F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f176F->then_instructions;

                     ir_variable *const r1771 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r1771, r176A, 0x01));

                     ir_variable *const r1772 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r1773 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r1773);
                     /* IF CONDITION */
                     ir_expression *const r1775 = equal(swizzle_x(r1695), body.constant(0u));
                     ir_if *f1774 = new(mem_ctx) ir_if(operand(r1775).val);
                     exec_list *const f1774_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1774->then_instructions;

                        body.emit(assign(r1772, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1774->else_instructions;

                        body.emit(assign(r1773, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1777 = bit_and(swizzle_x(r1695), body.constant(4294901760u));
                        ir_expression *const r1778 = equal(r1777, body.constant(0u));
                        ir_if *f1776 = new(mem_ctx) ir_if(operand(r1778).val);
                        exec_list *const f1776_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1776->then_instructions;

                           body.emit(assign(r1773, body.constant(int(16)), 0x01));

                           body.emit(assign(r1771, lshift(swizzle_x(r1695), body.constant(int(16))), 0x01));


                        body.instructions = f1776_parent_instructions;
                        body.emit(f1776);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r177A = bit_and(r1771, body.constant(4278190080u));
                        ir_expression *const r177B = equal(r177A, body.constant(0u));
                        ir_if *f1779 = new(mem_ctx) ir_if(operand(r177B).val);
                        exec_list *const f1779_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1779->then_instructions;

                           body.emit(assign(r1773, add(r1773, body.constant(int(8))), 0x01));

                           body.emit(assign(r1771, lshift(r1771, body.constant(int(8))), 0x01));


                        body.instructions = f1779_parent_instructions;
                        body.emit(f1779);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r177D = bit_and(r1771, body.constant(4026531840u));
                        ir_expression *const r177E = equal(r177D, body.constant(0u));
                        ir_if *f177C = new(mem_ctx) ir_if(operand(r177E).val);
                        exec_list *const f177C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f177C->then_instructions;

                           body.emit(assign(r1773, add(r1773, body.constant(int(4))), 0x01));

                           body.emit(assign(r1771, lshift(r1771, body.constant(int(4))), 0x01));


                        body.instructions = f177C_parent_instructions;
                        body.emit(f177C);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1780 = bit_and(r1771, body.constant(3221225472u));
                        ir_expression *const r1781 = equal(r1780, body.constant(0u));
                        ir_if *f177F = new(mem_ctx) ir_if(operand(r1781).val);
                        exec_list *const f177F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f177F->then_instructions;

                           body.emit(assign(r1773, add(r1773, body.constant(int(2))), 0x01));

                           body.emit(assign(r1771, lshift(r1771, body.constant(int(2))), 0x01));


                        body.instructions = f177F_parent_instructions;
                        body.emit(f177F);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1783 = bit_and(r1771, body.constant(2147483648u));
                        ir_expression *const r1784 = equal(r1783, body.constant(0u));
                        ir_if *f1782 = new(mem_ctx) ir_if(operand(r1784).val);
                        exec_list *const f1782_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1782->then_instructions;

                           body.emit(assign(r1773, add(r1773, body.constant(int(1))), 0x01));


                        body.instructions = f1782_parent_instructions;
                        body.emit(f1782);

                        /* END IF */

                        body.emit(assign(r1772, r1773, 0x01));


                     body.instructions = f1774_parent_instructions;
                     body.emit(f1774);

                     /* END IF */

                     body.emit(assign(r176E, add(r1772, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1786 = less(r176E, body.constant(int(0)));
                     ir_if *f1785 = new(mem_ctx) ir_if(operand(r1786).val);
                     exec_list *const f1785_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1785->then_instructions;

                        ir_expression *const r1787 = neg(r176E);
                        body.emit(assign(r176C, rshift(swizzle_x(r1695), r1787), 0x01));

                        ir_expression *const r1788 = bit_and(r176E, body.constant(int(31)));
                        body.emit(assign(r176D, lshift(swizzle_x(r1695), r1788), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1785->else_instructions;

                        body.emit(assign(r176C, lshift(swizzle_x(r1695), r176E), 0x01));

                        body.emit(assign(r176D, body.constant(0u), 0x01));


                     body.instructions = f1785_parent_instructions;
                     body.emit(f1785);

                     /* END IF */

                     body.emit(assign(r176B, sub(body.constant(int(-31)), r176E), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f176F->else_instructions;

                     ir_variable *const r1789 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r1789, r1769, 0x01));

                     ir_variable *const r178A = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r178B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r178B);
                     /* IF CONDITION */
                     ir_expression *const r178D = equal(swizzle_y(r16A5), body.constant(0u));
                     ir_if *f178C = new(mem_ctx) ir_if(operand(r178D).val);
                     exec_list *const f178C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f178C->then_instructions;

                        body.emit(assign(r178A, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f178C->else_instructions;

                        body.emit(assign(r178B, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r178F = bit_and(swizzle_y(r16A5), body.constant(4294901760u));
                        ir_expression *const r1790 = equal(r178F, body.constant(0u));
                        ir_if *f178E = new(mem_ctx) ir_if(operand(r1790).val);
                        exec_list *const f178E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f178E->then_instructions;

                           body.emit(assign(r178B, body.constant(int(16)), 0x01));

                           body.emit(assign(r1789, lshift(swizzle_y(r16A5), body.constant(int(16))), 0x01));


                        body.instructions = f178E_parent_instructions;
                        body.emit(f178E);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1792 = bit_and(r1789, body.constant(4278190080u));
                        ir_expression *const r1793 = equal(r1792, body.constant(0u));
                        ir_if *f1791 = new(mem_ctx) ir_if(operand(r1793).val);
                        exec_list *const f1791_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1791->then_instructions;

                           body.emit(assign(r178B, add(r178B, body.constant(int(8))), 0x01));

                           body.emit(assign(r1789, lshift(r1789, body.constant(int(8))), 0x01));


                        body.instructions = f1791_parent_instructions;
                        body.emit(f1791);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1795 = bit_and(r1789, body.constant(4026531840u));
                        ir_expression *const r1796 = equal(r1795, body.constant(0u));
                        ir_if *f1794 = new(mem_ctx) ir_if(operand(r1796).val);
                        exec_list *const f1794_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1794->then_instructions;

                           body.emit(assign(r178B, add(r178B, body.constant(int(4))), 0x01));

                           body.emit(assign(r1789, lshift(r1789, body.constant(int(4))), 0x01));


                        body.instructions = f1794_parent_instructions;
                        body.emit(f1794);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1798 = bit_and(r1789, body.constant(3221225472u));
                        ir_expression *const r1799 = equal(r1798, body.constant(0u));
                        ir_if *f1797 = new(mem_ctx) ir_if(operand(r1799).val);
                        exec_list *const f1797_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1797->then_instructions;

                           body.emit(assign(r178B, add(r178B, body.constant(int(2))), 0x01));

                           body.emit(assign(r1789, lshift(r1789, body.constant(int(2))), 0x01));


                        body.instructions = f1797_parent_instructions;
                        body.emit(f1797);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r179B = bit_and(r1789, body.constant(2147483648u));
                        ir_expression *const r179C = equal(r179B, body.constant(0u));
                        ir_if *f179A = new(mem_ctx) ir_if(operand(r179C).val);
                        exec_list *const f179A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f179A->then_instructions;

                           body.emit(assign(r178B, add(r178B, body.constant(int(1))), 0x01));


                        body.instructions = f179A_parent_instructions;
                        body.emit(f179A);

                        /* END IF */

                        body.emit(assign(r178A, r178B, 0x01));


                     body.instructions = f178C_parent_instructions;
                     body.emit(f178C);

                     /* END IF */

                     body.emit(assign(r176E, add(r178A, body.constant(int(-11))), 0x01));

                     ir_variable *const r179D = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r179D, lshift(swizzle_x(r1695), r176E), 0x01));

                     ir_variable *const r179E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r17A0 = equal(r176E, body.constant(int(0)));
                     ir_if *f179F = new(mem_ctx) ir_if(operand(r17A0).val);
                     exec_list *const f179F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f179F->then_instructions;

                        body.emit(assign(r179E, r1769, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f179F->else_instructions;

                        ir_expression *const r17A1 = lshift(swizzle_y(r16A5), r176E);
                        ir_expression *const r17A2 = neg(r176E);
                        ir_expression *const r17A3 = bit_and(r17A2, body.constant(int(31)));
                        ir_expression *const r17A4 = rshift(swizzle_x(r1695), r17A3);
                        body.emit(assign(r179E, bit_or(r17A1, r17A4), 0x01));


                     body.instructions = f179F_parent_instructions;
                     body.emit(f179F);

                     /* END IF */

                     body.emit(assign(r176C, r179E, 0x01));

                     body.emit(assign(r176D, r179D, 0x01));

                     body.emit(assign(r176B, sub(body.constant(int(1)), r176E), 0x01));


                  body.instructions = f176F_parent_instructions;
                  body.emit(f176F);

                  /* END IF */

                  body.emit(assign(r169C, r176B, 0x01));

                  body.emit(assign(r169D, r176C, 0x02));

                  body.emit(assign(r169D, r176D, 0x01));


               body.instructions = f1765_parent_instructions;
               body.emit(f1765);

               /* END IF */


            body.instructions = f1763_parent_instructions;
            body.emit(f1763);

            /* END IF */

            /* IF CONDITION */
            ir_if *f17A5 = new(mem_ctx) ir_if(operand(r1697).val);
            exec_list *const f17A5_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f17A5->then_instructions;

               ir_expression *const r17A6 = sub(r169C, r169A);
               body.emit(assign(r16A4, add(r17A6, body.constant(int(1021))), 0x01));

               ir_variable *const r17A7 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r17A7, lshift(swizzle_x(r169D), body.constant(int(11))), 0x01));

               ir_variable *const r17A8 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r17A9 = bit_or(swizzle_y(r169D), body.constant(1048576u));
               ir_expression *const r17AA = lshift(r17A9, body.constant(int(11)));
               ir_expression *const r17AB = rshift(swizzle_x(r169D), body.constant(int(21)));
               body.emit(assign(r17A8, bit_or(r17AA, r17AB), 0x01));

               body.emit(assign(r169D, r17A8, 0x02));

               body.emit(assign(r169D, r17A7, 0x01));

               ir_variable *const r17AC = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r17AC, lshift(swizzle_x(r169B), body.constant(int(11))), 0x01));

               ir_variable *const r17AD = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r17AE = bit_or(swizzle_y(r169B), body.constant(1048576u));
               ir_expression *const r17AF = lshift(r17AE, body.constant(int(11)));
               ir_expression *const r17B0 = rshift(swizzle_x(r169B), body.constant(int(21)));
               body.emit(assign(r17AD, bit_or(r17AF, r17B0), 0x01));

               body.emit(assign(r169B, r17AD, 0x02));

               body.emit(assign(r169B, r17AC, 0x01));

               /* IF CONDITION */
               ir_expression *const r17B2 = less(r17AD, r17A8);
               ir_expression *const r17B3 = equal(r17AD, r17A8);
               ir_expression *const r17B4 = lequal(r17AC, r17A7);
               ir_expression *const r17B5 = logic_and(r17B3, r17B4);
               ir_expression *const r17B6 = logic_or(r17B2, r17B5);
               ir_if *f17B1 = new(mem_ctx) ir_if(operand(r17B6).val);
               exec_list *const f17B1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f17B1->then_instructions;

                  body.emit(assign(r169D, rshift(r17A8, body.constant(int(1))), 0x02));

                  ir_expression *const r17B7 = lshift(r17A8, body.constant(int(31)));
                  ir_expression *const r17B8 = rshift(r17A7, body.constant(int(1)));
                  body.emit(assign(r169D, bit_or(r17B7, r17B8), 0x01));

                  body.emit(assign(r16A4, add(r16A4, body.constant(int(1))), 0x01));


               body.instructions = f17B1_parent_instructions;
               body.emit(f17B1);

               /* END IF */

               ir_variable *const r17B9 = body.make_temp(glsl_type::uint_type, "return_value");
               ir_variable *const r17BA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r17BA);
               ir_variable *const r17BB = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
               body.emit(r17BB);
               ir_variable *const r17BC = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
               body.emit(r17BC);
               ir_variable *const r17BD = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
               body.emit(r17BD);
               body.emit(assign(r17BC, body.constant(0u), 0x01));

               body.emit(assign(r17BB, body.constant(0u), 0x01));

               /* IF CONDITION */
               ir_expression *const r17BF = lequal(r17AD, swizzle_y(r169D));
               ir_if *f17BE = new(mem_ctx) ir_if(operand(r17BF).val);
               exec_list *const f17BE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f17BE->then_instructions;

                  body.emit(assign(r17B9, body.constant(4294967295u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f17BE->else_instructions;

                  body.emit(assign(r17BD, rshift(r17AD, body.constant(int(16))), 0x01));

                  ir_variable *const r17C0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r17C2 = lshift(r17BD, body.constant(int(16)));
                  ir_expression *const r17C3 = lequal(r17C2, swizzle_y(r169D));
                  ir_if *f17C1 = new(mem_ctx) ir_if(operand(r17C3).val);
                  exec_list *const f17C1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f17C1->then_instructions;

                     body.emit(assign(r17C0, body.constant(4294901760u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f17C1->else_instructions;

                     ir_expression *const r17C4 = expr(ir_binop_div, swizzle_y(r169D), r17BD);
                     body.emit(assign(r17C0, lshift(r17C4, body.constant(int(16))), 0x01));


                  body.instructions = f17C1_parent_instructions;
                  body.emit(f17C1);

                  /* END IF */

                  body.emit(assign(r17BA, r17C0, 0x01));

                  ir_variable *const r17C5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r17C5);
                  ir_variable *const r17C6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r17C6);
                  ir_variable *const r17C7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r17C7);
                  ir_variable *const r17C8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r17C8, bit_and(r17AD, body.constant(65535u)), 0x01));

                  ir_variable *const r17C9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r17C9, rshift(r17AD, body.constant(int(16))), 0x01));

                  ir_variable *const r17CA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r17CA, bit_and(r17C0, body.constant(65535u)), 0x01));

                  ir_variable *const r17CB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r17CB, rshift(r17C0, body.constant(int(16))), 0x01));

                  ir_variable *const r17CC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r17CC, mul(r17C9, r17CA), 0x01));

                  ir_expression *const r17CD = mul(r17C8, r17CB);
                  body.emit(assign(r17C6, add(r17CD, r17CC), 0x01));

                  ir_expression *const r17CE = mul(r17C9, r17CB);
                  ir_expression *const r17CF = less(r17C6, r17CC);
                  ir_expression *const r17D0 = expr(ir_unop_b2i, r17CF);
                  ir_expression *const r17D1 = expr(ir_unop_i2u, r17D0);
                  ir_expression *const r17D2 = lshift(r17D1, body.constant(int(16)));
                  ir_expression *const r17D3 = rshift(r17C6, body.constant(int(16)));
                  ir_expression *const r17D4 = add(r17D2, r17D3);
                  body.emit(assign(r17C5, add(r17CE, r17D4), 0x01));

                  body.emit(assign(r17C6, lshift(r17C6, body.constant(int(16))), 0x01));

                  ir_expression *const r17D5 = mul(r17C8, r17CA);
                  body.emit(assign(r17C7, add(r17D5, r17C6), 0x01));

                  ir_expression *const r17D6 = less(r17C7, r17C6);
                  ir_expression *const r17D7 = expr(ir_unop_b2i, r17D6);
                  ir_expression *const r17D8 = expr(ir_unop_i2u, r17D7);
                  body.emit(assign(r17C5, add(r17C5, r17D8), 0x01));

                  ir_expression *const r17D9 = sub(swizzle_y(r169D), r17C5);
                  ir_expression *const r17DA = less(swizzle_x(r169D), r17C7);
                  ir_expression *const r17DB = expr(ir_unop_b2i, r17DA);
                  ir_expression *const r17DC = expr(ir_unop_i2u, r17DB);
                  body.emit(assign(r17BC, sub(r17D9, r17DC), 0x01));

                  body.emit(assign(r17BB, sub(swizzle_x(r169D), r17C7), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f17DD = new(mem_ctx) ir_loop();
                  exec_list *const f17DD_parent_instructions = body.instructions;

                     body.instructions = &f17DD->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r17DF = expr(ir_unop_u2i, r17BC);
                     ir_expression *const r17E0 = gequal(r17DF, body.constant(int(0)));
                     ir_if *f17DE = new(mem_ctx) ir_if(operand(r17E0).val);
                     exec_list *const f17DE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f17DE->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f17DE_parent_instructions;
                     body.emit(f17DE);

                     /* END IF */

                     body.emit(assign(r17BA, add(r17BA, body.constant(4294901760u)), 0x01));

                     ir_variable *const r17E1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r17E2 = lshift(r17AD, body.constant(int(16)));
                     body.emit(assign(r17E1, add(r17BB, r17E2), 0x01));

                     ir_expression *const r17E3 = add(r17BC, r17BD);
                     ir_expression *const r17E4 = less(r17E1, r17BB);
                     ir_expression *const r17E5 = expr(ir_unop_b2i, r17E4);
                     ir_expression *const r17E6 = expr(ir_unop_i2u, r17E5);
                     body.emit(assign(r17BC, add(r17E3, r17E6), 0x01));

                     body.emit(assign(r17BB, r17E1, 0x01));

                  /* LOOP END */

                  body.instructions = f17DD_parent_instructions;
                  body.emit(f17DD);

                  ir_expression *const r17E7 = lshift(r17BC, body.constant(int(16)));
                  ir_expression *const r17E8 = rshift(r17BB, body.constant(int(16)));
                  body.emit(assign(r17BC, bit_or(r17E7, r17E8), 0x01));

                  ir_variable *const r17E9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r17EB = lshift(r17BD, body.constant(int(16)));
                  ir_expression *const r17EC = lequal(r17EB, r17BC);
                  ir_if *f17EA = new(mem_ctx) ir_if(operand(r17EC).val);
                  exec_list *const f17EA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f17EA->then_instructions;

                     body.emit(assign(r17E9, body.constant(65535u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f17EA->else_instructions;

                     body.emit(assign(r17E9, expr(ir_binop_div, r17BC, r17BD), 0x01));


                  body.instructions = f17EA_parent_instructions;
                  body.emit(f17EA);

                  /* END IF */

                  body.emit(assign(r17BA, bit_or(r17BA, r17E9), 0x01));

                  body.emit(assign(r17B9, r17BA, 0x01));


               body.instructions = f17BE_parent_instructions;
               body.emit(f17BE);

               /* END IF */

               body.emit(assign(r16A3, r17B9, 0x01));

               ir_variable *const r17ED = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r17ED);
               ir_variable *const r17EE = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r17EE);
               ir_variable *const r17EF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r17EF);
               ir_variable *const r17F0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r17F0, bit_and(r17AC, body.constant(65535u)), 0x01));

               ir_variable *const r17F1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r17F1, rshift(r17AC, body.constant(int(16))), 0x01));

               ir_variable *const r17F2 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r17F2, bit_and(r17B9, body.constant(65535u)), 0x01));

               ir_variable *const r17F3 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r17F3, rshift(r17B9, body.constant(int(16))), 0x01));

               ir_variable *const r17F4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r17F4, mul(r17F1, r17F2), 0x01));

               ir_expression *const r17F5 = mul(r17F0, r17F3);
               body.emit(assign(r17EE, add(r17F5, r17F4), 0x01));

               ir_expression *const r17F6 = mul(r17F1, r17F3);
               ir_expression *const r17F7 = less(r17EE, r17F4);
               ir_expression *const r17F8 = expr(ir_unop_b2i, r17F7);
               ir_expression *const r17F9 = expr(ir_unop_i2u, r17F8);
               ir_expression *const r17FA = lshift(r17F9, body.constant(int(16)));
               ir_expression *const r17FB = rshift(r17EE, body.constant(int(16)));
               ir_expression *const r17FC = add(r17FA, r17FB);
               body.emit(assign(r17ED, add(r17F6, r17FC), 0x01));

               body.emit(assign(r17EE, lshift(r17EE, body.constant(int(16))), 0x01));

               ir_expression *const r17FD = mul(r17F0, r17F2);
               body.emit(assign(r17EF, add(r17FD, r17EE), 0x01));

               ir_expression *const r17FE = less(r17EF, r17EE);
               ir_expression *const r17FF = expr(ir_unop_b2i, r17FE);
               ir_expression *const r1800 = expr(ir_unop_i2u, r17FF);
               body.emit(assign(r17ED, add(r17ED, r1800), 0x01));

               ir_variable *const r1801 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1801);
               ir_variable *const r1802 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r1802);
               ir_variable *const r1803 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1803);
               ir_variable *const r1804 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1804, bit_and(r17AD, body.constant(65535u)), 0x01));

               ir_variable *const r1805 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1805, rshift(r17AD, body.constant(int(16))), 0x01));

               ir_variable *const r1806 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1806, bit_and(r17B9, body.constant(65535u)), 0x01));

               ir_variable *const r1807 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1807, rshift(r17B9, body.constant(int(16))), 0x01));

               ir_variable *const r1808 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1808, mul(r1805, r1806), 0x01));

               ir_expression *const r1809 = mul(r1804, r1807);
               body.emit(assign(r1802, add(r1809, r1808), 0x01));

               ir_expression *const r180A = mul(r1805, r1807);
               ir_expression *const r180B = less(r1802, r1808);
               ir_expression *const r180C = expr(ir_unop_b2i, r180B);
               ir_expression *const r180D = expr(ir_unop_i2u, r180C);
               ir_expression *const r180E = lshift(r180D, body.constant(int(16)));
               ir_expression *const r180F = rshift(r1802, body.constant(int(16)));
               ir_expression *const r1810 = add(r180E, r180F);
               body.emit(assign(r1801, add(r180A, r1810), 0x01));

               body.emit(assign(r1802, lshift(r1802, body.constant(int(16))), 0x01));

               ir_expression *const r1811 = mul(r1804, r1806);
               body.emit(assign(r1803, add(r1811, r1802), 0x01));

               ir_expression *const r1812 = less(r1803, r1802);
               ir_expression *const r1813 = expr(ir_unop_b2i, r1812);
               ir_expression *const r1814 = expr(ir_unop_i2u, r1813);
               body.emit(assign(r1801, add(r1801, r1814), 0x01));

               ir_variable *const r1815 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1815, add(r1803, r17ED), 0x01));

               ir_variable *const r1816 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1816);
               ir_variable *const r1817 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r1818 = less(body.constant(0u), r17EF);
               ir_expression *const r1819 = expr(ir_unop_b2i, r1818);
               body.emit(assign(r1817, expr(ir_unop_i2u, r1819), 0x01));

               ir_variable *const r181A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r181A, sub(swizzle_x(r169D), r1815), 0x01));

               ir_expression *const r181B = less(r1815, r1803);
               ir_expression *const r181C = expr(ir_unop_b2i, r181B);
               ir_expression *const r181D = expr(ir_unop_i2u, r181C);
               ir_expression *const r181E = add(r1801, r181D);
               ir_expression *const r181F = sub(swizzle_y(r169D), r181E);
               ir_expression *const r1820 = less(r181A, r1817);
               ir_expression *const r1821 = expr(ir_unop_b2i, r1820);
               ir_expression *const r1822 = expr(ir_unop_i2u, r1821);
               body.emit(assign(r1816, sub(r181F, r1822), 0x01));

               ir_expression *const r1823 = less(swizzle_x(r169D), r1815);
               ir_expression *const r1824 = expr(ir_unop_b2i, r1823);
               ir_expression *const r1825 = expr(ir_unop_i2u, r1824);
               body.emit(assign(r1816, sub(r1816, r1825), 0x01));

               body.emit(assign(r16A1, r1816, 0x01));

               body.emit(assign(r16A0, sub(r181A, r1817), 0x01));

               body.emit(assign(r169F, neg(r17EF), 0x01));

               /* LOOP BEGIN */
               ir_loop *f1826 = new(mem_ctx) ir_loop();
               exec_list *const f1826_parent_instructions = body.instructions;

                  body.instructions = &f1826->body_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1828 = expr(ir_unop_u2i, r16A1);
                  ir_expression *const r1829 = gequal(r1828, body.constant(int(0)));
                  ir_if *f1827 = new(mem_ctx) ir_if(operand(r1829).val);
                  exec_list *const f1827_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1827->then_instructions;

                     body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                  body.instructions = f1827_parent_instructions;
                  body.emit(f1827);

                  /* END IF */

                  body.emit(assign(r16A3, add(r16A3, body.constant(4294967295u)), 0x01));

                  ir_variable *const r182A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r182A);
                  ir_variable *const r182B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r182B);
                  ir_variable *const r182C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r182C, add(r169F, r17AC), 0x01));

                  ir_variable *const r182D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  ir_expression *const r182E = less(r182C, r169F);
                  ir_expression *const r182F = expr(ir_unop_b2i, r182E);
                  body.emit(assign(r182D, expr(ir_unop_i2u, r182F), 0x01));

                  ir_variable *const r1830 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1830, add(r16A0, r17AD), 0x01));

                  body.emit(assign(r182B, add(r1830, r182D), 0x01));

                  ir_expression *const r1831 = less(r182B, r182D);
                  ir_expression *const r1832 = expr(ir_unop_b2i, r1831);
                  ir_expression *const r1833 = expr(ir_unop_i2u, r1832);
                  body.emit(assign(r182A, add(r16A1, r1833), 0x01));

                  ir_expression *const r1834 = less(r1830, r16A0);
                  ir_expression *const r1835 = expr(ir_unop_b2i, r1834);
                  ir_expression *const r1836 = expr(ir_unop_i2u, r1835);
                  body.emit(assign(r182A, add(r182A, r1836), 0x01));

                  body.emit(assign(r16A1, r182A, 0x01));

                  body.emit(assign(r16A0, r182B, 0x01));

                  body.emit(assign(r169F, r182C, 0x01));

               /* LOOP END */

               body.instructions = f1826_parent_instructions;
               body.emit(f1826);

               ir_variable *const r1837 = body.make_temp(glsl_type::uint_type, "return_value");
               ir_variable *const r1838 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r1838);
               ir_variable *const r1839 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
               body.emit(r1839);
               ir_variable *const r183A = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
               body.emit(r183A);
               ir_variable *const r183B = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
               body.emit(r183B);
               body.emit(assign(r183A, body.constant(0u), 0x01));

               body.emit(assign(r1839, body.constant(0u), 0x01));

               /* IF CONDITION */
               ir_expression *const r183D = lequal(r17AD, r16A0);
               ir_if *f183C = new(mem_ctx) ir_if(operand(r183D).val);
               exec_list *const f183C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f183C->then_instructions;

                  body.emit(assign(r1837, body.constant(4294967295u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f183C->else_instructions;

                  body.emit(assign(r183B, rshift(r17AD, body.constant(int(16))), 0x01));

                  ir_variable *const r183E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1840 = lshift(r183B, body.constant(int(16)));
                  ir_expression *const r1841 = lequal(r1840, r16A0);
                  ir_if *f183F = new(mem_ctx) ir_if(operand(r1841).val);
                  exec_list *const f183F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f183F->then_instructions;

                     body.emit(assign(r183E, body.constant(4294901760u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f183F->else_instructions;

                     ir_expression *const r1842 = expr(ir_binop_div, r16A0, r183B);
                     body.emit(assign(r183E, lshift(r1842, body.constant(int(16))), 0x01));


                  body.instructions = f183F_parent_instructions;
                  body.emit(f183F);

                  /* END IF */

                  body.emit(assign(r1838, r183E, 0x01));

                  ir_variable *const r1843 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1843);
                  ir_variable *const r1844 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r1844);
                  ir_variable *const r1845 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1845);
                  ir_variable *const r1846 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1846, bit_and(r17AD, body.constant(65535u)), 0x01));

                  ir_variable *const r1847 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1847, rshift(r17AD, body.constant(int(16))), 0x01));

                  ir_variable *const r1848 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1848, bit_and(r183E, body.constant(65535u)), 0x01));

                  ir_variable *const r1849 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1849, rshift(r183E, body.constant(int(16))), 0x01));

                  ir_variable *const r184A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r184A, mul(r1847, r1848), 0x01));

                  ir_expression *const r184B = mul(r1846, r1849);
                  body.emit(assign(r1844, add(r184B, r184A), 0x01));

                  ir_expression *const r184C = mul(r1847, r1849);
                  ir_expression *const r184D = less(r1844, r184A);
                  ir_expression *const r184E = expr(ir_unop_b2i, r184D);
                  ir_expression *const r184F = expr(ir_unop_i2u, r184E);
                  ir_expression *const r1850 = lshift(r184F, body.constant(int(16)));
                  ir_expression *const r1851 = rshift(r1844, body.constant(int(16)));
                  ir_expression *const r1852 = add(r1850, r1851);
                  body.emit(assign(r1843, add(r184C, r1852), 0x01));

                  body.emit(assign(r1844, lshift(r1844, body.constant(int(16))), 0x01));

                  ir_expression *const r1853 = mul(r1846, r1848);
                  body.emit(assign(r1845, add(r1853, r1844), 0x01));

                  ir_expression *const r1854 = less(r1845, r1844);
                  ir_expression *const r1855 = expr(ir_unop_b2i, r1854);
                  ir_expression *const r1856 = expr(ir_unop_i2u, r1855);
                  body.emit(assign(r1843, add(r1843, r1856), 0x01));

                  ir_expression *const r1857 = sub(r16A0, r1843);
                  ir_expression *const r1858 = less(r169F, r1845);
                  ir_expression *const r1859 = expr(ir_unop_b2i, r1858);
                  ir_expression *const r185A = expr(ir_unop_i2u, r1859);
                  body.emit(assign(r183A, sub(r1857, r185A), 0x01));

                  body.emit(assign(r1839, sub(r169F, r1845), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f185B = new(mem_ctx) ir_loop();
                  exec_list *const f185B_parent_instructions = body.instructions;

                     body.instructions = &f185B->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r185D = expr(ir_unop_u2i, r183A);
                     ir_expression *const r185E = gequal(r185D, body.constant(int(0)));
                     ir_if *f185C = new(mem_ctx) ir_if(operand(r185E).val);
                     exec_list *const f185C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f185C->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f185C_parent_instructions;
                     body.emit(f185C);

                     /* END IF */

                     body.emit(assign(r1838, add(r1838, body.constant(4294901760u)), 0x01));

                     ir_variable *const r185F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r1860 = lshift(r17AD, body.constant(int(16)));
                     body.emit(assign(r185F, add(r1839, r1860), 0x01));

                     ir_expression *const r1861 = add(r183A, r183B);
                     ir_expression *const r1862 = less(r185F, r1839);
                     ir_expression *const r1863 = expr(ir_unop_b2i, r1862);
                     ir_expression *const r1864 = expr(ir_unop_i2u, r1863);
                     body.emit(assign(r183A, add(r1861, r1864), 0x01));

                     body.emit(assign(r1839, r185F, 0x01));

                  /* LOOP END */

                  body.instructions = f185B_parent_instructions;
                  body.emit(f185B);

                  ir_expression *const r1865 = lshift(r183A, body.constant(int(16)));
                  ir_expression *const r1866 = rshift(r1839, body.constant(int(16)));
                  body.emit(assign(r183A, bit_or(r1865, r1866), 0x01));

                  ir_variable *const r1867 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1869 = lshift(r183B, body.constant(int(16)));
                  ir_expression *const r186A = lequal(r1869, r183A);
                  ir_if *f1868 = new(mem_ctx) ir_if(operand(r186A).val);
                  exec_list *const f1868_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1868->then_instructions;

                     body.emit(assign(r1867, body.constant(65535u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1868->else_instructions;

                     body.emit(assign(r1867, expr(ir_binop_div, r183A, r183B), 0x01));


                  body.instructions = f1868_parent_instructions;
                  body.emit(f1868);

                  /* END IF */

                  body.emit(assign(r1838, bit_or(r1838, r1867), 0x01));

                  body.emit(assign(r1837, r1838, 0x01));


               body.instructions = f183C_parent_instructions;
               body.emit(f183C);

               /* END IF */

               body.emit(assign(r16A2, r1837, 0x01));

               /* IF CONDITION */
               ir_expression *const r186C = bit_and(r1837, body.constant(1023u));
               ir_expression *const r186D = lequal(r186C, body.constant(4u));
               ir_if *f186B = new(mem_ctx) ir_if(operand(r186D).val);
               exec_list *const f186B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f186B->then_instructions;

                  ir_variable *const r186E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r186E);
                  ir_variable *const r186F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r186F);
                  ir_variable *const r1870 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1870);
                  ir_variable *const r1871 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1871, bit_and(r17AC, body.constant(65535u)), 0x01));

                  ir_variable *const r1872 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1872, rshift(r17AC, body.constant(int(16))), 0x01));

                  ir_variable *const r1873 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1873, bit_and(r1837, body.constant(65535u)), 0x01));

                  ir_variable *const r1874 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1874, rshift(r1837, body.constant(int(16))), 0x01));

                  ir_variable *const r1875 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1875, mul(r1872, r1873), 0x01));

                  ir_expression *const r1876 = mul(r1871, r1874);
                  body.emit(assign(r186F, add(r1876, r1875), 0x01));

                  ir_expression *const r1877 = mul(r1872, r1874);
                  ir_expression *const r1878 = less(r186F, r1875);
                  ir_expression *const r1879 = expr(ir_unop_b2i, r1878);
                  ir_expression *const r187A = expr(ir_unop_i2u, r1879);
                  ir_expression *const r187B = lshift(r187A, body.constant(int(16)));
                  ir_expression *const r187C = rshift(r186F, body.constant(int(16)));
                  ir_expression *const r187D = add(r187B, r187C);
                  body.emit(assign(r186E, add(r1877, r187D), 0x01));

                  body.emit(assign(r186F, lshift(r186F, body.constant(int(16))), 0x01));

                  ir_expression *const r187E = mul(r1871, r1873);
                  body.emit(assign(r1870, add(r187E, r186F), 0x01));

                  ir_expression *const r187F = less(r1870, r186F);
                  ir_expression *const r1880 = expr(ir_unop_b2i, r187F);
                  ir_expression *const r1881 = expr(ir_unop_i2u, r1880);
                  body.emit(assign(r186E, add(r186E, r1881), 0x01));

                  ir_variable *const r1882 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1882);
                  ir_variable *const r1883 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r1883);
                  ir_variable *const r1884 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1884);
                  ir_variable *const r1885 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1885, bit_and(r17AD, body.constant(65535u)), 0x01));

                  ir_variable *const r1886 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1886, rshift(r17AD, body.constant(int(16))), 0x01));

                  ir_variable *const r1887 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1887, bit_and(r1837, body.constant(65535u)), 0x01));

                  ir_variable *const r1888 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1888, rshift(r1837, body.constant(int(16))), 0x01));

                  ir_variable *const r1889 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1889, mul(r1886, r1887), 0x01));

                  ir_expression *const r188A = mul(r1885, r1888);
                  body.emit(assign(r1883, add(r188A, r1889), 0x01));

                  ir_expression *const r188B = mul(r1886, r1888);
                  ir_expression *const r188C = less(r1883, r1889);
                  ir_expression *const r188D = expr(ir_unop_b2i, r188C);
                  ir_expression *const r188E = expr(ir_unop_i2u, r188D);
                  ir_expression *const r188F = lshift(r188E, body.constant(int(16)));
                  ir_expression *const r1890 = rshift(r1883, body.constant(int(16)));
                  ir_expression *const r1891 = add(r188F, r1890);
                  body.emit(assign(r1882, add(r188B, r1891), 0x01));

                  body.emit(assign(r1883, lshift(r1883, body.constant(int(16))), 0x01));

                  ir_expression *const r1892 = mul(r1885, r1887);
                  body.emit(assign(r1884, add(r1892, r1883), 0x01));

                  ir_expression *const r1893 = less(r1884, r1883);
                  ir_expression *const r1894 = expr(ir_unop_b2i, r1893);
                  ir_expression *const r1895 = expr(ir_unop_i2u, r1894);
                  body.emit(assign(r1882, add(r1882, r1895), 0x01));

                  ir_variable *const r1896 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1896, add(r1884, r186E), 0x01));

                  ir_variable *const r1897 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1897);
                  ir_variable *const r1898 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  ir_expression *const r1899 = less(body.constant(0u), r1870);
                  ir_expression *const r189A = expr(ir_unop_b2i, r1899);
                  body.emit(assign(r1898, expr(ir_unop_i2u, r189A), 0x01));

                  ir_variable *const r189B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r189B, sub(r169F, r1896), 0x01));

                  ir_expression *const r189C = less(r1896, r1884);
                  ir_expression *const r189D = expr(ir_unop_b2i, r189C);
                  ir_expression *const r189E = expr(ir_unop_i2u, r189D);
                  ir_expression *const r189F = add(r1882, r189E);
                  ir_expression *const r18A0 = sub(r16A0, r189F);
                  ir_expression *const r18A1 = less(r189B, r1898);
                  ir_expression *const r18A2 = expr(ir_unop_b2i, r18A1);
                  ir_expression *const r18A3 = expr(ir_unop_i2u, r18A2);
                  body.emit(assign(r1897, sub(r18A0, r18A3), 0x01));

                  ir_expression *const r18A4 = less(r169F, r1896);
                  ir_expression *const r18A5 = expr(ir_unop_b2i, r18A4);
                  ir_expression *const r18A6 = expr(ir_unop_i2u, r18A5);
                  body.emit(assign(r1897, sub(r1897, r18A6), 0x01));

                  body.emit(assign(r16A0, r1897, 0x01));

                  body.emit(assign(r169F, sub(r189B, r1898), 0x01));

                  body.emit(assign(r169E, neg(r1870), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f18A7 = new(mem_ctx) ir_loop();
                  exec_list *const f18A7_parent_instructions = body.instructions;

                     body.instructions = &f18A7->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r18A9 = expr(ir_unop_u2i, r16A0);
                     ir_expression *const r18AA = gequal(r18A9, body.constant(int(0)));
                     ir_if *f18A8 = new(mem_ctx) ir_if(operand(r18AA).val);
                     exec_list *const f18A8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f18A8->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f18A8_parent_instructions;
                     body.emit(f18A8);

                     /* END IF */

                     body.emit(assign(r16A2, add(r16A2, body.constant(4294967295u)), 0x01));

                     ir_variable *const r18AB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r18AB);
                     ir_variable *const r18AC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r18AC);
                     ir_variable *const r18AD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r18AD, add(r169E, r17AC), 0x01));

                     ir_variable *const r18AE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r18AF = less(r18AD, r169E);
                     ir_expression *const r18B0 = expr(ir_unop_b2i, r18AF);
                     body.emit(assign(r18AE, expr(ir_unop_i2u, r18B0), 0x01));

                     ir_variable *const r18B1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r18B1, add(r169F, r17AD), 0x01));

                     body.emit(assign(r18AC, add(r18B1, r18AE), 0x01));

                     ir_expression *const r18B2 = less(r18AC, r18AE);
                     ir_expression *const r18B3 = expr(ir_unop_b2i, r18B2);
                     ir_expression *const r18B4 = expr(ir_unop_i2u, r18B3);
                     body.emit(assign(r18AB, add(r16A0, r18B4), 0x01));

                     ir_expression *const r18B5 = less(r18B1, r169F);
                     ir_expression *const r18B6 = expr(ir_unop_b2i, r18B5);
                     ir_expression *const r18B7 = expr(ir_unop_i2u, r18B6);
                     body.emit(assign(r18AB, add(r18AB, r18B7), 0x01));

                     body.emit(assign(r16A0, r18AB, 0x01));

                     body.emit(assign(r169F, r18AC, 0x01));

                     body.emit(assign(r169E, r18AD, 0x01));

                  /* LOOP END */

                  body.instructions = f18A7_parent_instructions;
                  body.emit(f18A7);

                  ir_expression *const r18B8 = bit_or(r16A0, r169F);
                  ir_expression *const r18B9 = bit_or(r18B8, r169E);
                  ir_expression *const r18BA = nequal(r18B9, body.constant(0u));
                  ir_expression *const r18BB = expr(ir_unop_b2i, r18BA);
                  ir_expression *const r18BC = expr(ir_unop_i2u, r18BB);
                  body.emit(assign(r16A2, bit_or(r16A2, r18BC), 0x01));


               body.instructions = f186B_parent_instructions;
               body.emit(f186B);

               /* END IF */

               ir_variable *const r18BD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r18BD);
               ir_variable *const r18BE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r18BE);
               ir_variable *const r18BF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r18BF);
               body.emit(assign(r18BD, lshift(r16A2, body.constant(int(21))), 0x01));

               ir_expression *const r18C0 = lshift(r16A3, body.constant(int(21)));
               ir_expression *const r18C1 = rshift(r16A2, body.constant(int(11)));
               body.emit(assign(r18BE, bit_or(r18C0, r18C1), 0x01));

               body.emit(assign(r18BF, rshift(r16A3, body.constant(int(11))), 0x01));

               body.emit(assign(r18BD, bit_or(r18BD, body.constant(0u)), 0x01));

               body.emit(assign(r16A3, r18BF, 0x01));

               body.emit(assign(r16A2, r18BE, 0x01));

               ir_variable *const r18C2 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r18C2, r16A4, 0x01));

               ir_variable *const r18C3 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r18C3, r18BF, 0x01));

               ir_variable *const r18C4 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r18C4, r18BE, 0x01));

               ir_variable *const r18C5 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r18C5, r18BD, 0x01));

               ir_variable *const r18C6 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r18C6, body.constant(true), 0x01));

               ir_variable *const r18C7 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r18C8 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r18C8);
               ir_expression *const r18C9 = expr(ir_unop_u2i, r18BD);
               body.emit(assign(r18C8, less(r18C9, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r18CB = lequal(body.constant(int(2045)), r16A4);
               ir_if *f18CA = new(mem_ctx) ir_if(operand(r18CB).val);
               exec_list *const f18CA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f18CA->then_instructions;

                  ir_variable *const r18CC = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r18CE = less(body.constant(int(2045)), r16A4);
                  ir_if *f18CD = new(mem_ctx) ir_if(operand(r18CE).val);
                  exec_list *const f18CD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f18CD->then_instructions;

                     body.emit(assign(r18CC, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f18CD->else_instructions;

                     ir_variable *const r18CF = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r18D1 = equal(r16A4, body.constant(int(2045)));
                     ir_if *f18D0 = new(mem_ctx) ir_if(operand(r18D1).val);
                     exec_list *const f18D0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f18D0->then_instructions;

                        ir_expression *const r18D2 = equal(body.constant(2097151u), r18BF);
                        ir_expression *const r18D3 = equal(body.constant(4294967295u), r18BE);
                        body.emit(assign(r18CF, logic_and(r18D2, r18D3), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f18D0->else_instructions;

                        body.emit(assign(r18CF, body.constant(false), 0x01));


                     body.instructions = f18D0_parent_instructions;
                     body.emit(f18D0);

                     /* END IF */

                     body.emit(assign(r18CC, logic_and(r18CF, r18C8), 0x01));


                  body.instructions = f18CD_parent_instructions;
                  body.emit(f18CD);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f18D4 = new(mem_ctx) ir_if(operand(r18CC).val);
                  exec_list *const f18D4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f18D4->then_instructions;

                     ir_variable *const r18D5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r18D5);
                     ir_expression *const r18D6 = lshift(r1699, body.constant(int(31)));
                     body.emit(assign(r18D5, add(r18D6, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r18D5, body.constant(0u), 0x01));

                     body.emit(assign(r18C7, r18D5, 0x03));

                     body.emit(assign(r18C6, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f18D4->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r18D8 = less(r16A4, body.constant(int(0)));
                     ir_if *f18D7 = new(mem_ctx) ir_if(operand(r18D8).val);
                     exec_list *const f18D7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f18D7->then_instructions;

                        ir_variable *const r18D9 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r18D9, r18BD, 0x01));

                        ir_variable *const r18DA = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r18DA, neg(r16A4), 0x01));

                        ir_variable *const r18DB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r18DB);
                        ir_variable *const r18DC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r18DC);
                        ir_variable *const r18DD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r18DD);
                        ir_variable *const r18DE = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r18DF = neg(r18DA);
                        body.emit(assign(r18DE, bit_and(r18DF, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r18E1 = equal(r18DA, body.constant(int(0)));
                        ir_if *f18E0 = new(mem_ctx) ir_if(operand(r18E1).val);
                        exec_list *const f18E0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f18E0->then_instructions;

                           body.emit(assign(r18DB, r18BD, 0x01));

                           body.emit(assign(r18DC, r18BE, 0x01));

                           body.emit(assign(r18DD, r18BF, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f18E0->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r18E3 = less(r18DA, body.constant(int(32)));
                           ir_if *f18E2 = new(mem_ctx) ir_if(operand(r18E3).val);
                           exec_list *const f18E2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f18E2->then_instructions;

                              body.emit(assign(r18DB, lshift(r18BE, r18DE), 0x01));

                              ir_expression *const r18E4 = lshift(r18BF, r18DE);
                              ir_expression *const r18E5 = rshift(r18BE, r18DA);
                              body.emit(assign(r18DC, bit_or(r18E4, r18E5), 0x01));

                              body.emit(assign(r18DD, rshift(r18BF, r18DA), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f18E2->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r18E7 = equal(r18DA, body.constant(int(32)));
                              ir_if *f18E6 = new(mem_ctx) ir_if(operand(r18E7).val);
                              exec_list *const f18E6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f18E6->then_instructions;

                                 body.emit(assign(r18DB, r18BE, 0x01));

                                 body.emit(assign(r18DC, r18BF, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f18E6->else_instructions;

                                 body.emit(assign(r18D9, bit_or(r18BD, r18BE), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r18E9 = less(r18DA, body.constant(int(64)));
                                 ir_if *f18E8 = new(mem_ctx) ir_if(operand(r18E9).val);
                                 exec_list *const f18E8_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f18E8->then_instructions;

                                    body.emit(assign(r18DB, lshift(r18BF, r18DE), 0x01));

                                    ir_expression *const r18EA = bit_and(r18DA, body.constant(int(31)));
                                    body.emit(assign(r18DC, rshift(r18BF, r18EA), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f18E8->else_instructions;

                                    ir_variable *const r18EB = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r18ED = equal(r18DA, body.constant(int(64)));
                                    ir_if *f18EC = new(mem_ctx) ir_if(operand(r18ED).val);
                                    exec_list *const f18EC_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f18EC->then_instructions;

                                       body.emit(assign(r18EB, r18BF, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f18EC->else_instructions;

                                       ir_expression *const r18EE = nequal(r18BF, body.constant(0u));
                                       ir_expression *const r18EF = expr(ir_unop_b2i, r18EE);
                                       body.emit(assign(r18EB, expr(ir_unop_i2u, r18EF), 0x01));


                                    body.instructions = f18EC_parent_instructions;
                                    body.emit(f18EC);

                                    /* END IF */

                                    body.emit(assign(r18DB, r18EB, 0x01));

                                    body.emit(assign(r18DC, body.constant(0u), 0x01));


                                 body.instructions = f18E8_parent_instructions;
                                 body.emit(f18E8);

                                 /* END IF */


                              body.instructions = f18E6_parent_instructions;
                              body.emit(f18E6);

                              /* END IF */

                              body.emit(assign(r18DD, body.constant(0u), 0x01));


                           body.instructions = f18E2_parent_instructions;
                           body.emit(f18E2);

                           /* END IF */

                           ir_expression *const r18F0 = nequal(r18D9, body.constant(0u));
                           ir_expression *const r18F1 = expr(ir_unop_b2i, r18F0);
                           ir_expression *const r18F2 = expr(ir_unop_i2u, r18F1);
                           body.emit(assign(r18DB, bit_or(r18DB, r18F2), 0x01));


                        body.instructions = f18E0_parent_instructions;
                        body.emit(f18E0);

                        /* END IF */

                        body.emit(assign(r18C3, r18DD, 0x01));

                        body.emit(assign(r18C4, r18DC, 0x01));

                        body.emit(assign(r18C5, r18DB, 0x01));

                        body.emit(assign(r18C2, body.constant(int(0)), 0x01));

                        body.emit(assign(r18C8, less(r18DB, body.constant(0u)), 0x01));


                     body.instructions = f18D7_parent_instructions;
                     body.emit(f18D7);

                     /* END IF */


                  body.instructions = f18D4_parent_instructions;
                  body.emit(f18D4);

                  /* END IF */


               body.instructions = f18CA_parent_instructions;
               body.emit(f18CA);

               /* END IF */

               /* IF CONDITION */
               ir_if *f18F3 = new(mem_ctx) ir_if(operand(r18C6).val);
               exec_list *const f18F3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f18F3->then_instructions;

                  /* IF CONDITION */
                  ir_if *f18F4 = new(mem_ctx) ir_if(operand(r18C8).val);
                  exec_list *const f18F4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f18F4->then_instructions;

                     ir_variable *const r18F5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r18F5, add(r18C4, body.constant(1u)), 0x01));

                     ir_expression *const r18F6 = less(r18F5, r18C4);
                     ir_expression *const r18F7 = expr(ir_unop_b2i, r18F6);
                     ir_expression *const r18F8 = expr(ir_unop_i2u, r18F7);
                     body.emit(assign(r18C3, add(r18C3, r18F8), 0x01));

                     ir_expression *const r18F9 = equal(r18C5, body.constant(0u));
                     ir_expression *const r18FA = expr(ir_unop_b2i, r18F9);
                     ir_expression *const r18FB = expr(ir_unop_i2u, r18FA);
                     ir_expression *const r18FC = add(r18C5, r18FB);
                     ir_expression *const r18FD = bit_and(r18FC, body.constant(1u));
                     ir_expression *const r18FE = expr(ir_unop_bit_not, r18FD);
                     body.emit(assign(r18C4, bit_and(r18F5, r18FE), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f18F4->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1900 = bit_or(r18C3, r18C4);
                     ir_expression *const r1901 = equal(r1900, body.constant(0u));
                     ir_if *f18FF = new(mem_ctx) ir_if(operand(r1901).val);
                     exec_list *const f18FF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f18FF->then_instructions;

                        body.emit(assign(r18C2, body.constant(int(0)), 0x01));


                     body.instructions = f18FF_parent_instructions;
                     body.emit(f18FF);

                     /* END IF */


                  body.instructions = f18F4_parent_instructions;
                  body.emit(f18F4);

                  /* END IF */

                  ir_variable *const r1902 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1902);
                  ir_expression *const r1903 = lshift(r1699, body.constant(int(31)));
                  ir_expression *const r1904 = expr(ir_unop_i2u, r18C2);
                  ir_expression *const r1905 = lshift(r1904, body.constant(int(20)));
                  ir_expression *const r1906 = add(r1903, r1905);
                  body.emit(assign(r1902, add(r1906, r18C3), 0x02));

                  body.emit(assign(r1902, r18C4, 0x01));

                  body.emit(assign(r18C7, r1902, 0x03));

                  body.emit(assign(r18C6, body.constant(false), 0x01));


               body.instructions = f18F3_parent_instructions;
               body.emit(f18F3);

               /* END IF */

               body.emit(assign(r1698, r18C7, 0x03));

               body.emit(assign(r1697, body.constant(false), 0x01));


            body.instructions = f17A5_parent_instructions;
            body.emit(f17A5);

            /* END IF */


         body.instructions = f1762_parent_instructions;
         body.emit(f1762);

         /* END IF */


      body.instructions = f16F6_parent_instructions;
      body.emit(f16F6);

      /* END IF */


   body.instructions = f16AF_parent_instructions;
   body.emit(f16AF);

   /* END IF */

   body.emit(ret(r1698));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
normalizeFloat32Subnormal(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1907 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac", ir_var_function_in);
   sig_parameters.push_tail(r1907);
   ir_variable *const r1908 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExpPtr", ir_var_function_inout);
   sig_parameters.push_tail(r1908);
   ir_variable *const r1909 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFracPtr", ir_var_function_inout);
   sig_parameters.push_tail(r1909);
   ir_variable *const r190A = body.make_temp(glsl_type::uint_type, "a");
   body.emit(assign(r190A, r1907, 0x01));

   ir_variable *const r190B = body.make_temp(glsl_type::int_type, "return_value");
   ir_variable *const r190C = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r190C);
   /* IF CONDITION */
   ir_expression *const r190E = equal(r1907, body.constant(0u));
   ir_if *f190D = new(mem_ctx) ir_if(operand(r190E).val);
   exec_list *const f190D_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f190D->then_instructions;

      body.emit(assign(r190B, body.constant(int(32)), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f190D->else_instructions;

      body.emit(assign(r190C, body.constant(int(0)), 0x01));

      /* IF CONDITION */
      ir_expression *const r1910 = bit_and(r1907, body.constant(4294901760u));
      ir_expression *const r1911 = equal(r1910, body.constant(0u));
      ir_if *f190F = new(mem_ctx) ir_if(operand(r1911).val);
      exec_list *const f190F_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f190F->then_instructions;

         body.emit(assign(r190C, body.constant(int(16)), 0x01));

         body.emit(assign(r190A, lshift(r1907, body.constant(int(16))), 0x01));


      body.instructions = f190F_parent_instructions;
      body.emit(f190F);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1913 = bit_and(r190A, body.constant(4278190080u));
      ir_expression *const r1914 = equal(r1913, body.constant(0u));
      ir_if *f1912 = new(mem_ctx) ir_if(operand(r1914).val);
      exec_list *const f1912_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1912->then_instructions;

         body.emit(assign(r190C, add(r190C, body.constant(int(8))), 0x01));

         body.emit(assign(r190A, lshift(r190A, body.constant(int(8))), 0x01));


      body.instructions = f1912_parent_instructions;
      body.emit(f1912);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1916 = bit_and(r190A, body.constant(4026531840u));
      ir_expression *const r1917 = equal(r1916, body.constant(0u));
      ir_if *f1915 = new(mem_ctx) ir_if(operand(r1917).val);
      exec_list *const f1915_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1915->then_instructions;

         body.emit(assign(r190C, add(r190C, body.constant(int(4))), 0x01));

         body.emit(assign(r190A, lshift(r190A, body.constant(int(4))), 0x01));


      body.instructions = f1915_parent_instructions;
      body.emit(f1915);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1919 = bit_and(r190A, body.constant(3221225472u));
      ir_expression *const r191A = equal(r1919, body.constant(0u));
      ir_if *f1918 = new(mem_ctx) ir_if(operand(r191A).val);
      exec_list *const f1918_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1918->then_instructions;

         body.emit(assign(r190C, add(r190C, body.constant(int(2))), 0x01));

         body.emit(assign(r190A, lshift(r190A, body.constant(int(2))), 0x01));


      body.instructions = f1918_parent_instructions;
      body.emit(f1918);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r191C = bit_and(r190A, body.constant(2147483648u));
      ir_expression *const r191D = equal(r191C, body.constant(0u));
      ir_if *f191B = new(mem_ctx) ir_if(operand(r191D).val);
      exec_list *const f191B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f191B->then_instructions;

         body.emit(assign(r190C, add(r190C, body.constant(int(1))), 0x01));


      body.instructions = f191B_parent_instructions;
      body.emit(f191B);

      /* END IF */

      body.emit(assign(r190B, r190C, 0x01));


   body.instructions = f190D_parent_instructions;
   body.emit(f190D);

   /* END IF */

   ir_variable *const r191E = body.make_temp(glsl_type::int_type, "assignment_tmp");
   body.emit(assign(r191E, add(r190B, body.constant(int(-8))), 0x01));

   body.emit(assign(r1909, lshift(r1907, r191E), 0x01));

   body.emit(assign(r1908, sub(body.constant(int(1)), r191E), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat32Frac(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r191F = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r191F);
   ir_expression *const r1920 = bit_and(r191F, body.constant(8388607u));
   body.emit(ret(r1920));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat32Exp(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::int_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1921 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1921);
   ir_expression *const r1922 = rshift(r1921, body.constant(int(23)));
   ir_expression *const r1923 = bit_and(r1922, body.constant(255u));
   ir_expression *const r1924 = expr(ir_unop_u2i, r1923);
   body.emit(ret(r1924));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat32Sign(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1925 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1925);
   ir_expression *const r1926 = rshift(r1925, body.constant(int(31)));
   body.emit(ret(r1926));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fp32_to_fp64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1927 = new(mem_ctx) ir_variable(glsl_type::float_type, "f", ir_var_function_in);
   sig_parameters.push_tail(r1927);
   ir_variable *const r1928 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r1928, body.constant(true), 0x01));

   ir_variable *const r1929 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r192A = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r192A);
   ir_variable *const r192B = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac", ir_var_auto);
   body.emit(r192B);
   ir_variable *const r192C = body.make_temp(glsl_type::uint_type, "floatBitsToUint_retval");
   body.emit(assign(r192C, expr(ir_unop_bitcast_f2u, r1927), 0x01));

   ir_variable *const r192D = body.make_temp(glsl_type::uint_type, "extractFloat32Frac_retval");
   body.emit(assign(r192D, bit_and(r192C, body.constant(8388607u)), 0x01));

   body.emit(assign(r192B, r192D, 0x01));

   ir_variable *const r192E = body.make_temp(glsl_type::int_type, "extractFloat32Exp_retval");
   ir_expression *const r192F = rshift(r192C, body.constant(int(23)));
   ir_expression *const r1930 = bit_and(r192F, body.constant(255u));
   body.emit(assign(r192E, expr(ir_unop_u2i, r1930), 0x01));

   body.emit(assign(r192A, r192E, 0x01));

   ir_variable *const r1931 = body.make_temp(glsl_type::uint_type, "extractFloat32Sign_retval");
   body.emit(assign(r1931, rshift(r192C, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1933 = equal(r192E, body.constant(int(255)));
   ir_if *f1932 = new(mem_ctx) ir_if(operand(r1933).val);
   exec_list *const f1932_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1932->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1935 = nequal(r192D, body.constant(0u));
      ir_if *f1934 = new(mem_ctx) ir_if(operand(r1935).val);
      exec_list *const f1934_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1934->then_instructions;

         ir_variable *const r1936 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "nan", ir_var_auto);
         body.emit(r1936);
         body.emit(assign(r1936, body.constant(0u), 0x01));

         body.emit(assign(r1936, lshift(r192C, body.constant(int(9))), 0x02));

         ir_variable *const r1937 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r1937);
         body.emit(assign(r1937, rshift(swizzle_y(r1936), body.constant(int(12))), 0x01));

         ir_expression *const r1938 = lshift(swizzle_y(r1936), body.constant(int(20)));
         body.emit(assign(r1936, bit_or(r1938, body.constant(0u)), 0x01));

         ir_expression *const r1939 = lshift(r1931, body.constant(int(31)));
         ir_expression *const r193A = bit_or(r1939, body.constant(2146959360u));
         body.emit(assign(r1936, bit_or(r1937, r193A), 0x02));

         body.emit(assign(r1929, r1936, 0x03));

         body.emit(assign(r1928, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1934->else_instructions;

         ir_variable *const r193B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r193B);
         ir_expression *const r193C = lshift(r1931, body.constant(int(31)));
         body.emit(assign(r193B, add(r193C, body.constant(2146435072u)), 0x02));

         body.emit(assign(r193B, body.constant(0u), 0x01));

         body.emit(assign(r1929, r193B, 0x03));

         body.emit(assign(r1928, body.constant(false), 0x01));


      body.instructions = f1934_parent_instructions;
      body.emit(f1934);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1932->else_instructions;

      /* IF CONDITION */
      ir_expression *const r193E = equal(r192E, body.constant(int(0)));
      ir_if *f193D = new(mem_ctx) ir_if(operand(r193E).val);
      exec_list *const f193D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f193D->then_instructions;

         /* IF CONDITION */
         ir_expression *const r1940 = equal(r192D, body.constant(0u));
         ir_if *f193F = new(mem_ctx) ir_if(operand(r1940).val);
         exec_list *const f193F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f193F->then_instructions;

            ir_variable *const r1941 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r1941);
            body.emit(assign(r1941, lshift(r1931, body.constant(int(31))), 0x02));

            body.emit(assign(r1941, body.constant(0u), 0x01));

            body.emit(assign(r1929, r1941, 0x03));

            body.emit(assign(r1928, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f193F->else_instructions;

            ir_variable *const r1942 = body.make_temp(glsl_type::int_type, "zExpPtr");
            body.emit(assign(r1942, r192E, 0x01));

            ir_variable *const r1943 = body.make_temp(glsl_type::uint_type, "zFracPtr");
            body.emit(assign(r1943, r192D, 0x01));

            ir_variable *const r1944 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r1944, r192D, 0x01));

            ir_variable *const r1945 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r1946 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r1946);
            /* IF CONDITION */
            ir_expression *const r1948 = equal(r192D, body.constant(0u));
            ir_if *f1947 = new(mem_ctx) ir_if(operand(r1948).val);
            exec_list *const f1947_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1947->then_instructions;

               body.emit(assign(r1945, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1947->else_instructions;

               body.emit(assign(r1946, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r194A = bit_and(r192D, body.constant(4294901760u));
               ir_expression *const r194B = equal(r194A, body.constant(0u));
               ir_if *f1949 = new(mem_ctx) ir_if(operand(r194B).val);
               exec_list *const f1949_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1949->then_instructions;

                  body.emit(assign(r1946, body.constant(int(16)), 0x01));

                  body.emit(assign(r1944, lshift(r192D, body.constant(int(16))), 0x01));


               body.instructions = f1949_parent_instructions;
               body.emit(f1949);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r194D = bit_and(r1944, body.constant(4278190080u));
               ir_expression *const r194E = equal(r194D, body.constant(0u));
               ir_if *f194C = new(mem_ctx) ir_if(operand(r194E).val);
               exec_list *const f194C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f194C->then_instructions;

                  body.emit(assign(r1946, add(r1946, body.constant(int(8))), 0x01));

                  body.emit(assign(r1944, lshift(r1944, body.constant(int(8))), 0x01));


               body.instructions = f194C_parent_instructions;
               body.emit(f194C);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1950 = bit_and(r1944, body.constant(4026531840u));
               ir_expression *const r1951 = equal(r1950, body.constant(0u));
               ir_if *f194F = new(mem_ctx) ir_if(operand(r1951).val);
               exec_list *const f194F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f194F->then_instructions;

                  body.emit(assign(r1946, add(r1946, body.constant(int(4))), 0x01));

                  body.emit(assign(r1944, lshift(r1944, body.constant(int(4))), 0x01));


               body.instructions = f194F_parent_instructions;
               body.emit(f194F);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1953 = bit_and(r1944, body.constant(3221225472u));
               ir_expression *const r1954 = equal(r1953, body.constant(0u));
               ir_if *f1952 = new(mem_ctx) ir_if(operand(r1954).val);
               exec_list *const f1952_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1952->then_instructions;

                  body.emit(assign(r1946, add(r1946, body.constant(int(2))), 0x01));

                  body.emit(assign(r1944, lshift(r1944, body.constant(int(2))), 0x01));


               body.instructions = f1952_parent_instructions;
               body.emit(f1952);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1956 = bit_and(r1944, body.constant(2147483648u));
               ir_expression *const r1957 = equal(r1956, body.constant(0u));
               ir_if *f1955 = new(mem_ctx) ir_if(operand(r1957).val);
               exec_list *const f1955_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1955->then_instructions;

                  body.emit(assign(r1946, add(r1946, body.constant(int(1))), 0x01));


               body.instructions = f1955_parent_instructions;
               body.emit(f1955);

               /* END IF */

               body.emit(assign(r1945, r1946, 0x01));


            body.instructions = f1947_parent_instructions;
            body.emit(f1947);

            /* END IF */

            ir_variable *const r1958 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            body.emit(assign(r1958, add(r1945, body.constant(int(-8))), 0x01));

            body.emit(assign(r1943, lshift(r192D, r1958), 0x01));

            body.emit(assign(r1942, sub(body.constant(int(1)), r1958), 0x01));

            body.emit(assign(r192B, r1943, 0x01));

            body.emit(assign(r192A, add(r1942, body.constant(int(-1))), 0x01));


         body.instructions = f193F_parent_instructions;
         body.emit(f193F);

         /* END IF */


      body.instructions = f193D_parent_instructions;
      body.emit(f193D);

      /* END IF */

      /* IF CONDITION */
      ir_if *f1959 = new(mem_ctx) ir_if(operand(r1928).val);
      exec_list *const f1959_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1959->then_instructions;

         ir_variable *const r195A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r195A);
         ir_expression *const r195B = lshift(r1931, body.constant(int(31)));
         ir_expression *const r195C = add(r192A, body.constant(int(896)));
         ir_expression *const r195D = expr(ir_unop_i2u, r195C);
         ir_expression *const r195E = lshift(r195D, body.constant(int(20)));
         ir_expression *const r195F = add(r195B, r195E);
         ir_expression *const r1960 = rshift(r192B, body.constant(int(3)));
         body.emit(assign(r195A, add(r195F, r1960), 0x02));

         ir_expression *const r1961 = lshift(r192B, body.constant(int(29)));
         body.emit(assign(r195A, bit_or(r1961, body.constant(0u)), 0x01));

         body.emit(assign(r1929, r195A, 0x03));

         body.emit(assign(r1928, body.constant(false), 0x01));


      body.instructions = f1959_parent_instructions;
      body.emit(f1959);

      /* END IF */


   body.instructions = f1932_parent_instructions;
   body.emit(f1932);

   /* END IF */

   body.emit(ret(r1929));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
packFloat32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1962 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r1962);
   ir_variable *const r1963 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r1963);
   ir_variable *const r1964 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac", ir_var_function_in);
   sig_parameters.push_tail(r1964);
   ir_expression *const r1965 = lshift(r1962, body.constant(int(31)));
   ir_expression *const r1966 = expr(ir_unop_i2u, r1963);
   ir_expression *const r1967 = lshift(r1966, body.constant(int(23)));
   ir_expression *const r1968 = add(r1965, r1967);
   ir_expression *const r1969 = add(r1968, r1964);
   body.emit(ret(r1969));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift32RightJamming(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r196A = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r196A);
   ir_variable *const r196B = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r196B);
   ir_variable *const r196C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zPtr", ir_var_function_inout);
   sig_parameters.push_tail(r196C);
   ir_variable *const r196D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
   body.emit(r196D);
   /* IF CONDITION */
   ir_expression *const r196F = equal(r196B, body.constant(int(0)));
   ir_if *f196E = new(mem_ctx) ir_if(operand(r196F).val);
   exec_list *const f196E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f196E->then_instructions;

      body.emit(assign(r196D, r196A, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f196E->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1971 = less(r196B, body.constant(int(32)));
      ir_if *f1970 = new(mem_ctx) ir_if(operand(r1971).val);
      exec_list *const f1970_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1970->then_instructions;

         ir_expression *const r1972 = rshift(r196A, r196B);
         ir_expression *const r1973 = neg(r196B);
         ir_expression *const r1974 = bit_and(r1973, body.constant(int(31)));
         ir_expression *const r1975 = lshift(r196A, r1974);
         ir_expression *const r1976 = nequal(r1975, body.constant(0u));
         ir_expression *const r1977 = expr(ir_unop_b2i, r1976);
         ir_expression *const r1978 = expr(ir_unop_i2u, r1977);
         body.emit(assign(r196D, bit_or(r1972, r1978), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1970->else_instructions;

         ir_expression *const r1979 = nequal(r196A, body.constant(0u));
         ir_expression *const r197A = expr(ir_unop_b2i, r1979);
         body.emit(assign(r196D, expr(ir_unop_i2u, r197A), 0x01));


      body.instructions = f1970_parent_instructions;
      body.emit(f1970);

      /* END IF */


   body.instructions = f196E_parent_instructions;
   body.emit(f196E);

   /* END IF */

   body.emit(assign(r196C, r196D, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
roundAndPackFloat32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r197B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r197B);
   ir_variable *const r197C = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r197C);
   ir_variable *const r197D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac", ir_var_function_in);
   sig_parameters.push_tail(r197D);
   ir_variable *const r197E = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r197E, body.constant(true), 0x01));

   ir_variable *const r197F = body.make_temp(glsl_type::uint_type, "return_value");
   ir_variable *const r1980 = new(mem_ctx) ir_variable(glsl_type::int_type, "roundBits", ir_var_auto);
   body.emit(r1980);
   ir_expression *const r1981 = expr(ir_unop_u2i, r197D);
   body.emit(assign(r1980, bit_and(r1981, body.constant(int(127))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1983 = expr(ir_unop_i2u, r197C);
   ir_expression *const r1984 = lequal(body.constant(253u), r1983);
   ir_if *f1982 = new(mem_ctx) ir_if(operand(r1984).val);
   exec_list *const f1982_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1982->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1986 = less(body.constant(int(253)), r197C);
      ir_expression *const r1987 = equal(r197C, body.constant(int(253)));
      ir_expression *const r1988 = add(r197D, body.constant(64u));
      ir_expression *const r1989 = expr(ir_unop_u2i, r1988);
      ir_expression *const r198A = less(r1989, body.constant(int(0)));
      ir_expression *const r198B = logic_and(r1987, r198A);
      ir_expression *const r198C = logic_or(r1986, r198B);
      ir_if *f1985 = new(mem_ctx) ir_if(operand(r198C).val);
      exec_list *const f1985_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1985->then_instructions;

         ir_expression *const r198D = lshift(r197B, body.constant(int(31)));
         body.emit(assign(r197F, add(r198D, body.constant(2139095040u)), 0x01));

         body.emit(assign(r197E, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1985->else_instructions;

         /* IF CONDITION */
         ir_expression *const r198F = less(r197C, body.constant(int(0)));
         ir_if *f198E = new(mem_ctx) ir_if(operand(r198F).val);
         exec_list *const f198E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f198E->then_instructions;

            ir_variable *const r1990 = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r1990, neg(r197C), 0x01));

            ir_variable *const r1991 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
            body.emit(r1991);
            /* IF CONDITION */
            ir_expression *const r1993 = equal(r1990, body.constant(int(0)));
            ir_if *f1992 = new(mem_ctx) ir_if(operand(r1993).val);
            exec_list *const f1992_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1992->then_instructions;

               body.emit(assign(r1991, r197D, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1992->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1995 = less(r1990, body.constant(int(32)));
               ir_if *f1994 = new(mem_ctx) ir_if(operand(r1995).val);
               exec_list *const f1994_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1994->then_instructions;

                  ir_expression *const r1996 = rshift(r197D, r1990);
                  ir_expression *const r1997 = neg(r1990);
                  ir_expression *const r1998 = bit_and(r1997, body.constant(int(31)));
                  ir_expression *const r1999 = lshift(r197D, r1998);
                  ir_expression *const r199A = nequal(r1999, body.constant(0u));
                  ir_expression *const r199B = expr(ir_unop_b2i, r199A);
                  ir_expression *const r199C = expr(ir_unop_i2u, r199B);
                  body.emit(assign(r1991, bit_or(r1996, r199C), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1994->else_instructions;

                  ir_expression *const r199D = nequal(r197D, body.constant(0u));
                  ir_expression *const r199E = expr(ir_unop_b2i, r199D);
                  body.emit(assign(r1991, expr(ir_unop_i2u, r199E), 0x01));


               body.instructions = f1994_parent_instructions;
               body.emit(f1994);

               /* END IF */


            body.instructions = f1992_parent_instructions;
            body.emit(f1992);

            /* END IF */

            body.emit(assign(r197D, r1991, 0x01));

            body.emit(assign(r197C, body.constant(int(0)), 0x01));

            ir_expression *const r199F = expr(ir_unop_u2i, r1991);
            body.emit(assign(r1980, bit_and(r199F, body.constant(int(127))), 0x01));


         body.instructions = f198E_parent_instructions;
         body.emit(f198E);

         /* END IF */


      body.instructions = f1985_parent_instructions;
      body.emit(f1985);

      /* END IF */


   body.instructions = f1982_parent_instructions;
   body.emit(f1982);

   /* END IF */

   /* IF CONDITION */
   ir_if *f19A0 = new(mem_ctx) ir_if(operand(r197E).val);
   exec_list *const f19A0_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f19A0->then_instructions;

      ir_expression *const r19A1 = add(r197D, body.constant(64u));
      body.emit(assign(r197D, rshift(r19A1, body.constant(int(7))), 0x01));

      ir_expression *const r19A2 = bit_xor(r1980, body.constant(int(64)));
      ir_expression *const r19A3 = equal(r19A2, body.constant(int(0)));
      ir_expression *const r19A4 = expr(ir_unop_b2i, r19A3);
      ir_expression *const r19A5 = expr(ir_unop_i2u, r19A4);
      ir_expression *const r19A6 = bit_and(r19A5, body.constant(1u));
      ir_expression *const r19A7 = expr(ir_unop_bit_not, r19A6);
      body.emit(assign(r197D, bit_and(r197D, r19A7), 0x01));

      /* IF CONDITION */
      ir_expression *const r19A9 = equal(r197D, body.constant(0u));
      ir_if *f19A8 = new(mem_ctx) ir_if(operand(r19A9).val);
      exec_list *const f19A8_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f19A8->then_instructions;

         body.emit(assign(r197C, body.constant(int(0)), 0x01));


      body.instructions = f19A8_parent_instructions;
      body.emit(f19A8);

      /* END IF */

      ir_expression *const r19AA = lshift(r197B, body.constant(int(31)));
      ir_expression *const r19AB = expr(ir_unop_i2u, r197C);
      ir_expression *const r19AC = lshift(r19AB, body.constant(int(23)));
      ir_expression *const r19AD = add(r19AA, r19AC);
      body.emit(assign(r197F, add(r19AD, r197D), 0x01));

      body.emit(assign(r197E, body.constant(false), 0x01));


   body.instructions = f19A0_parent_instructions;
   body.emit(f19A0);

   /* END IF */

   body.emit(ret(r197F));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fp64_to_fp32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::float_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r19AE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r19AE);
   ir_variable *const r19AF = body.make_temp(glsl_type::float_type, "return_value");
   ir_variable *const r19B0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac", ir_var_auto);
   body.emit(r19B0);
   body.emit(assign(r19B0, body.constant(0u), 0x01));

   ir_variable *const r19B1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r19B1);
   body.emit(assign(r19B1, bit_and(swizzle_y(r19AE), body.constant(1048575u)), 0x02));

   body.emit(assign(r19B1, swizzle_x(r19AE), 0x01));

   ir_variable *const r19B2 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r19B3 = rshift(swizzle_y(r19AE), body.constant(int(20)));
   ir_expression *const r19B4 = bit_and(r19B3, body.constant(2047u));
   body.emit(assign(r19B2, expr(ir_unop_u2i, r19B4), 0x01));

   ir_variable *const r19B5 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r19B5, rshift(swizzle_y(r19AE), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r19B7 = equal(r19B2, body.constant(int(2047)));
   ir_if *f19B6 = new(mem_ctx) ir_if(operand(r19B7).val);
   exec_list *const f19B6_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f19B6->then_instructions;

      /* IF CONDITION */
      ir_expression *const r19B9 = bit_or(swizzle_y(r19B1), swizzle_x(r19AE));
      ir_expression *const r19BA = nequal(r19B9, body.constant(0u));
      ir_if *f19B8 = new(mem_ctx) ir_if(operand(r19BA).val);
      exec_list *const f19B8_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f19B8->then_instructions;

         ir_variable *const r19BB = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r19BB, lshift(swizzle_x(r19AE), body.constant(int(12))), 0x01));

         ir_variable *const r19BC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         ir_expression *const r19BD = lshift(swizzle_y(r19AE), body.constant(int(12)));
         ir_expression *const r19BE = rshift(swizzle_x(r19AE), body.constant(int(20)));
         body.emit(assign(r19BC, bit_or(r19BD, r19BE), 0x01));

         body.emit(assign(r19AE, r19BC, 0x02));

         body.emit(assign(r19AE, r19BB, 0x01));

         ir_expression *const r19BF = lshift(r19B5, body.constant(int(31)));
         ir_expression *const r19C0 = bit_or(r19BF, body.constant(2143289344u));
         ir_expression *const r19C1 = rshift(r19BC, body.constant(int(9)));
         ir_expression *const r19C2 = bit_or(r19C0, r19C1);
         body.emit(assign(r19AF, expr(ir_unop_bitcast_u2f, r19C2), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f19B8->else_instructions;

         ir_expression *const r19C3 = lshift(r19B5, body.constant(int(31)));
         ir_expression *const r19C4 = add(r19C3, body.constant(2139095040u));
         body.emit(assign(r19AF, expr(ir_unop_bitcast_u2f, r19C4), 0x01));


      body.instructions = f19B8_parent_instructions;
      body.emit(f19B8);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f19B6->else_instructions;

      ir_variable *const r19C5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r19C5);
      ir_variable *const r19C6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r19C6);
      ir_expression *const r19C7 = lshift(swizzle_y(r19B1), body.constant(int(10)));
      ir_expression *const r19C8 = rshift(swizzle_x(r19B1), body.constant(int(22)));
      ir_expression *const r19C9 = bit_or(r19C7, r19C8);
      ir_expression *const r19CA = lshift(swizzle_x(r19B1), body.constant(int(10)));
      ir_expression *const r19CB = nequal(r19CA, body.constant(0u));
      ir_expression *const r19CC = expr(ir_unop_b2i, r19CB);
      ir_expression *const r19CD = expr(ir_unop_i2u, r19CC);
      body.emit(assign(r19C5, bit_or(r19C9, r19CD), 0x01));

      body.emit(assign(r19C6, rshift(swizzle_y(r19B1), body.constant(int(22))), 0x01));

      body.emit(assign(r19B0, r19C5, 0x01));

      /* IF CONDITION */
      ir_expression *const r19CF = nequal(r19B2, body.constant(int(0)));
      ir_if *f19CE = new(mem_ctx) ir_if(operand(r19CF).val);
      exec_list *const f19CE_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f19CE->then_instructions;

         body.emit(assign(r19B0, bit_or(r19C5, body.constant(1073741824u)), 0x01));


      body.instructions = f19CE_parent_instructions;
      body.emit(f19CE);

      /* END IF */

      ir_variable *const r19D0 = body.make_temp(glsl_type::int_type, "zExp");
      body.emit(assign(r19D0, add(r19B2, body.constant(int(-897))), 0x01));

      ir_variable *const r19D1 = body.make_temp(glsl_type::uint_type, "zFrac");
      body.emit(assign(r19D1, r19B0, 0x01));

      ir_variable *const r19D2 = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r19D2, body.constant(true), 0x01));

      ir_variable *const r19D3 = body.make_temp(glsl_type::uint_type, "return_value");
      ir_variable *const r19D4 = new(mem_ctx) ir_variable(glsl_type::int_type, "roundBits", ir_var_auto);
      body.emit(r19D4);
      ir_expression *const r19D5 = expr(ir_unop_u2i, r19B0);
      body.emit(assign(r19D4, bit_and(r19D5, body.constant(int(127))), 0x01));

      /* IF CONDITION */
      ir_expression *const r19D7 = expr(ir_unop_i2u, r19D0);
      ir_expression *const r19D8 = lequal(body.constant(253u), r19D7);
      ir_if *f19D6 = new(mem_ctx) ir_if(operand(r19D8).val);
      exec_list *const f19D6_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f19D6->then_instructions;

         /* IF CONDITION */
         ir_expression *const r19DA = less(body.constant(int(253)), r19D0);
         ir_expression *const r19DB = equal(r19D0, body.constant(int(253)));
         ir_expression *const r19DC = add(r19B0, body.constant(64u));
         ir_expression *const r19DD = expr(ir_unop_u2i, r19DC);
         ir_expression *const r19DE = less(r19DD, body.constant(int(0)));
         ir_expression *const r19DF = logic_and(r19DB, r19DE);
         ir_expression *const r19E0 = logic_or(r19DA, r19DF);
         ir_if *f19D9 = new(mem_ctx) ir_if(operand(r19E0).val);
         exec_list *const f19D9_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f19D9->then_instructions;

            ir_expression *const r19E1 = lshift(r19B5, body.constant(int(31)));
            body.emit(assign(r19D3, add(r19E1, body.constant(2139095040u)), 0x01));

            body.emit(assign(r19D2, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f19D9->else_instructions;

            /* IF CONDITION */
            ir_expression *const r19E3 = less(r19D0, body.constant(int(0)));
            ir_if *f19E2 = new(mem_ctx) ir_if(operand(r19E3).val);
            exec_list *const f19E2_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f19E2->then_instructions;

               ir_variable *const r19E4 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r19E4, neg(r19D0), 0x01));

               ir_variable *const r19E5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r19E5);
               /* IF CONDITION */
               ir_expression *const r19E7 = equal(r19E4, body.constant(int(0)));
               ir_if *f19E6 = new(mem_ctx) ir_if(operand(r19E7).val);
               exec_list *const f19E6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f19E6->then_instructions;

                  body.emit(assign(r19E5, r19B0, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f19E6->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r19E9 = less(r19E4, body.constant(int(32)));
                  ir_if *f19E8 = new(mem_ctx) ir_if(operand(r19E9).val);
                  exec_list *const f19E8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f19E8->then_instructions;

                     ir_expression *const r19EA = rshift(r19B0, r19E4);
                     ir_expression *const r19EB = neg(r19E4);
                     ir_expression *const r19EC = bit_and(r19EB, body.constant(int(31)));
                     ir_expression *const r19ED = lshift(r19B0, r19EC);
                     ir_expression *const r19EE = nequal(r19ED, body.constant(0u));
                     ir_expression *const r19EF = expr(ir_unop_b2i, r19EE);
                     ir_expression *const r19F0 = expr(ir_unop_i2u, r19EF);
                     body.emit(assign(r19E5, bit_or(r19EA, r19F0), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f19E8->else_instructions;

                     ir_expression *const r19F1 = nequal(r19B0, body.constant(0u));
                     ir_expression *const r19F2 = expr(ir_unop_b2i, r19F1);
                     body.emit(assign(r19E5, expr(ir_unop_i2u, r19F2), 0x01));


                  body.instructions = f19E8_parent_instructions;
                  body.emit(f19E8);

                  /* END IF */


               body.instructions = f19E6_parent_instructions;
               body.emit(f19E6);

               /* END IF */

               body.emit(assign(r19D1, r19E5, 0x01));

               body.emit(assign(r19D0, body.constant(int(0)), 0x01));

               ir_expression *const r19F3 = expr(ir_unop_u2i, r19E5);
               body.emit(assign(r19D4, bit_and(r19F3, body.constant(int(127))), 0x01));


            body.instructions = f19E2_parent_instructions;
            body.emit(f19E2);

            /* END IF */


         body.instructions = f19D9_parent_instructions;
         body.emit(f19D9);

         /* END IF */


      body.instructions = f19D6_parent_instructions;
      body.emit(f19D6);

      /* END IF */

      /* IF CONDITION */
      ir_if *f19F4 = new(mem_ctx) ir_if(operand(r19D2).val);
      exec_list *const f19F4_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f19F4->then_instructions;

         ir_expression *const r19F5 = add(r19D1, body.constant(64u));
         body.emit(assign(r19D1, rshift(r19F5, body.constant(int(7))), 0x01));

         ir_expression *const r19F6 = bit_xor(r19D4, body.constant(int(64)));
         ir_expression *const r19F7 = equal(r19F6, body.constant(int(0)));
         ir_expression *const r19F8 = expr(ir_unop_b2i, r19F7);
         ir_expression *const r19F9 = expr(ir_unop_i2u, r19F8);
         ir_expression *const r19FA = bit_and(r19F9, body.constant(1u));
         ir_expression *const r19FB = expr(ir_unop_bit_not, r19FA);
         body.emit(assign(r19D1, bit_and(r19D1, r19FB), 0x01));

         /* IF CONDITION */
         ir_expression *const r19FD = equal(r19D1, body.constant(0u));
         ir_if *f19FC = new(mem_ctx) ir_if(operand(r19FD).val);
         exec_list *const f19FC_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f19FC->then_instructions;

            body.emit(assign(r19D0, body.constant(int(0)), 0x01));


         body.instructions = f19FC_parent_instructions;
         body.emit(f19FC);

         /* END IF */

         ir_expression *const r19FE = lshift(r19B5, body.constant(int(31)));
         ir_expression *const r19FF = expr(ir_unop_i2u, r19D0);
         ir_expression *const r1A00 = lshift(r19FF, body.constant(int(23)));
         ir_expression *const r1A01 = add(r19FE, r1A00);
         body.emit(assign(r19D3, add(r1A01, r19D1), 0x01));

         body.emit(assign(r19D2, body.constant(false), 0x01));


      body.instructions = f19F4_parent_instructions;
      body.emit(f19F4);

      /* END IF */

      body.emit(assign(r19AF, expr(ir_unop_bitcast_u2f, r19D3), 0x01));


   body.instructions = f19B6_parent_instructions;
   body.emit(f19B6);

   /* END IF */

   body.emit(ret(r19AF));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fp64_to_int(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::int_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1A02 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1A02);
   ir_variable *const r1A03 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r1A03, body.constant(true), 0x01));

   ir_variable *const r1A04 = body.make_temp(glsl_type::int_type, "return_value");
   ir_variable *const r1A05 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFracExtra", ir_var_auto);
   body.emit(r1A05);
   ir_variable *const r1A06 = new(mem_ctx) ir_variable(glsl_type::uint_type, "absZ", ir_var_auto);
   body.emit(r1A06);
   ir_variable *const r1A07 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aSign", ir_var_auto);
   body.emit(r1A07);
   ir_variable *const r1A08 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
   body.emit(r1A08);
   ir_variable *const r1A09 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r1A09);
   body.emit(assign(r1A09, bit_and(swizzle_y(r1A02), body.constant(1048575u)), 0x02));

   body.emit(assign(r1A09, swizzle_x(r1A02), 0x01));

   body.emit(assign(r1A08, r1A09, 0x03));

   ir_variable *const r1A0A = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r1A0B = rshift(swizzle_y(r1A02), body.constant(int(20)));
   ir_expression *const r1A0C = bit_and(r1A0B, body.constant(2047u));
   body.emit(assign(r1A0A, expr(ir_unop_u2i, r1A0C), 0x01));

   body.emit(assign(r1A07, rshift(swizzle_y(r1A02), body.constant(int(31))), 0x01));

   body.emit(assign(r1A06, body.constant(0u), 0x01));

   body.emit(assign(r1A05, body.constant(0u), 0x01));

   ir_variable *const r1A0D = body.make_temp(glsl_type::int_type, "assignment_tmp");
   body.emit(assign(r1A0D, add(r1A0A, body.constant(int(-1043))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1A0F = lequal(body.constant(int(0)), r1A0D);
   ir_if *f1A0E = new(mem_ctx) ir_if(operand(r1A0F).val);
   exec_list *const f1A0E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A0E->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1A11 = less(body.constant(int(1054)), r1A0A);
      ir_if *f1A10 = new(mem_ctx) ir_if(operand(r1A11).val);
      exec_list *const f1A10_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A10->then_instructions;

         /* IF CONDITION */
         ir_expression *const r1A13 = equal(r1A0A, body.constant(int(2047)));
         ir_expression *const r1A14 = bit_or(swizzle_y(r1A09), swizzle_x(r1A02));
         ir_expression *const r1A15 = nequal(r1A14, body.constant(0u));
         ir_expression *const r1A16 = logic_and(r1A13, r1A15);
         ir_if *f1A12 = new(mem_ctx) ir_if(operand(r1A16).val);
         exec_list *const f1A12_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A12->then_instructions;

            body.emit(assign(r1A07, body.constant(0u), 0x01));


         body.instructions = f1A12_parent_instructions;
         body.emit(f1A12);

         /* END IF */

         ir_variable *const r1A17 = body.make_temp(glsl_type::int_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1A19 = nequal(r1A07, body.constant(0u));
         ir_if *f1A18 = new(mem_ctx) ir_if(operand(r1A19).val);
         exec_list *const f1A18_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A18->then_instructions;

            body.emit(assign(r1A17, body.constant(int(-2147483648)), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1A18->else_instructions;

            body.emit(assign(r1A17, body.constant(int(2147483647)), 0x01));


         body.instructions = f1A18_parent_instructions;
         body.emit(f1A18);

         /* END IF */

         body.emit(assign(r1A04, r1A17, 0x01));

         body.emit(assign(r1A03, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A10->else_instructions;

         ir_variable *const r1A1A = body.make_temp(glsl_type::uint_type, "a0");
         body.emit(assign(r1A1A, bit_or(swizzle_y(r1A09), body.constant(1048576u)), 0x01));

         ir_variable *const r1A1B = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r1A1B, lshift(swizzle_x(r1A02), r1A0D), 0x01));

         ir_variable *const r1A1C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1A1E = equal(r1A0D, body.constant(int(0)));
         ir_if *f1A1D = new(mem_ctx) ir_if(operand(r1A1E).val);
         exec_list *const f1A1D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A1D->then_instructions;

            body.emit(assign(r1A1C, r1A1A, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1A1D->else_instructions;

            ir_expression *const r1A1F = lshift(r1A1A, r1A0D);
            ir_expression *const r1A20 = neg(r1A0D);
            ir_expression *const r1A21 = bit_and(r1A20, body.constant(int(31)));
            ir_expression *const r1A22 = rshift(swizzle_x(r1A02), r1A21);
            body.emit(assign(r1A1C, bit_or(r1A1F, r1A22), 0x01));


         body.instructions = f1A1D_parent_instructions;
         body.emit(f1A1D);

         /* END IF */

         body.emit(assign(r1A06, r1A1C, 0x01));

         body.emit(assign(r1A05, r1A1B, 0x01));

         /* IF CONDITION */
         ir_expression *const r1A24 = less(body.constant(2147483648u), r1A1C);
         ir_if *f1A23 = new(mem_ctx) ir_if(operand(r1A24).val);
         exec_list *const f1A23_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A23->then_instructions;

            ir_variable *const r1A25 = body.make_temp(glsl_type::int_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r1A27 = nequal(r1A07, body.constant(0u));
            ir_if *f1A26 = new(mem_ctx) ir_if(operand(r1A27).val);
            exec_list *const f1A26_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1A26->then_instructions;

               body.emit(assign(r1A25, body.constant(int(-2147483648)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1A26->else_instructions;

               body.emit(assign(r1A25, body.constant(int(2147483647)), 0x01));


            body.instructions = f1A26_parent_instructions;
            body.emit(f1A26);

            /* END IF */

            body.emit(assign(r1A04, r1A25, 0x01));

            body.emit(assign(r1A03, body.constant(false), 0x01));


         body.instructions = f1A23_parent_instructions;
         body.emit(f1A23);

         /* END IF */


      body.instructions = f1A10_parent_instructions;
      body.emit(f1A10);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1A0E->else_instructions;

      ir_expression *const r1A28 = nequal(swizzle_x(r1A02), body.constant(0u));
      ir_expression *const r1A29 = expr(ir_unop_b2i, r1A28);
      body.emit(assign(r1A08, expr(ir_unop_i2u, r1A29), 0x01));

      /* IF CONDITION */
      ir_expression *const r1A2B = less(r1A0A, body.constant(int(1022)));
      ir_if *f1A2A = new(mem_ctx) ir_if(operand(r1A2B).val);
      exec_list *const f1A2A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A2A->then_instructions;

         ir_expression *const r1A2C = expr(ir_unop_i2u, r1A0A);
         ir_expression *const r1A2D = bit_or(r1A2C, swizzle_y(r1A09));
         body.emit(assign(r1A05, bit_or(r1A2D, swizzle_x(r1A08)), 0x01));

         body.emit(assign(r1A06, body.constant(0u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A2A->else_instructions;

         body.emit(assign(r1A08, bit_or(swizzle_y(r1A09), body.constant(1048576u)), 0x02));

         ir_expression *const r1A2E = bit_and(r1A0D, body.constant(int(31)));
         ir_expression *const r1A2F = lshift(swizzle_y(r1A08), r1A2E);
         body.emit(assign(r1A05, bit_or(r1A2F, swizzle_x(r1A08)), 0x01));

         ir_expression *const r1A30 = neg(r1A0D);
         body.emit(assign(r1A06, rshift(swizzle_y(r1A08), r1A30), 0x01));


      body.instructions = f1A2A_parent_instructions;
      body.emit(f1A2A);

      /* END IF */


   body.instructions = f1A0E_parent_instructions;
   body.emit(f1A0E);

   /* END IF */

   /* IF CONDITION */
   ir_if *f1A31 = new(mem_ctx) ir_if(operand(r1A03).val);
   exec_list *const f1A31_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A31->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1A33 = expr(ir_unop_u2i, r1A05);
      ir_expression *const r1A34 = less(r1A33, body.constant(int(0)));
      ir_expression *const r1A35 = lshift(r1A05, body.constant(int(1)));
      ir_expression *const r1A36 = equal(r1A35, body.constant(0u));
      ir_expression *const r1A37 = logic_and(r1A34, r1A36);
      ir_if *f1A32 = new(mem_ctx) ir_if(operand(r1A37).val);
      exec_list *const f1A32_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A32->then_instructions;

         body.emit(assign(r1A06, bit_and(r1A06, body.constant(4294967294u)), 0x01));


      body.instructions = f1A32_parent_instructions;
      body.emit(f1A32);

      /* END IF */

      ir_variable *const r1A38 = body.make_temp(glsl_type::int_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r1A3A = nequal(r1A07, body.constant(0u));
      ir_if *f1A39 = new(mem_ctx) ir_if(operand(r1A3A).val);
      exec_list *const f1A39_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A39->then_instructions;

         ir_expression *const r1A3B = expr(ir_unop_u2i, r1A06);
         body.emit(assign(r1A38, neg(r1A3B), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A39->else_instructions;

         body.emit(assign(r1A38, expr(ir_unop_u2i, r1A06), 0x01));


      body.instructions = f1A39_parent_instructions;
      body.emit(f1A39);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1A3D = less(r1A38, body.constant(int(0)));
      ir_expression *const r1A3E = expr(ir_unop_b2i, r1A3D);
      ir_expression *const r1A3F = expr(ir_unop_i2u, r1A3E);
      ir_expression *const r1A40 = bit_xor(r1A07, r1A3F);
      ir_expression *const r1A41 = expr(ir_unop_u2i, r1A40);
      ir_expression *const r1A42 = expr(ir_unop_i2b, r1A41);
      ir_expression *const r1A43 = expr(ir_unop_i2b, r1A38);
      ir_expression *const r1A44 = logic_and(r1A42, r1A43);
      ir_if *f1A3C = new(mem_ctx) ir_if(operand(r1A44).val);
      exec_list *const f1A3C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A3C->then_instructions;

         ir_variable *const r1A45 = body.make_temp(glsl_type::int_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1A47 = expr(ir_unop_u2i, r1A07);
         ir_expression *const r1A48 = expr(ir_unop_i2b, r1A47);
         ir_if *f1A46 = new(mem_ctx) ir_if(operand(r1A48).val);
         exec_list *const f1A46_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A46->then_instructions;

            body.emit(assign(r1A45, body.constant(int(-2147483648)), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1A46->else_instructions;

            body.emit(assign(r1A45, body.constant(int(2147483647)), 0x01));


         body.instructions = f1A46_parent_instructions;
         body.emit(f1A46);

         /* END IF */

         body.emit(assign(r1A04, r1A45, 0x01));

         body.emit(assign(r1A03, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A3C->else_instructions;

         body.emit(assign(r1A04, r1A38, 0x01));

         body.emit(assign(r1A03, body.constant(false), 0x01));


      body.instructions = f1A3C_parent_instructions;
      body.emit(f1A3C);

      /* END IF */


   body.instructions = f1A31_parent_instructions;
   body.emit(f1A31);

   /* END IF */

   body.emit(ret(r1A04));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
int_to_fp64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1A49 = new(mem_ctx) ir_variable(glsl_type::int_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1A49);
   ir_variable *const r1A4A = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1A4B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_auto);
   body.emit(r1A4B);
   ir_variable *const r1A4C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r1A4C);
   ir_variable *const r1A4D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r1A4D);
   body.emit(assign(r1A4D, body.constant(0u), 0x01));

   body.emit(assign(r1A4C, body.constant(0u), 0x01));

   /* IF CONDITION */
   ir_expression *const r1A4F = equal(r1A49, body.constant(int(0)));
   ir_if *f1A4E = new(mem_ctx) ir_if(operand(r1A4F).val);
   exec_list *const f1A4E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A4E->then_instructions;

      ir_variable *const r1A50 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r1A50);
      body.emit(assign(r1A50, body.constant(0u), 0x02));

      body.emit(assign(r1A50, body.constant(0u), 0x01));

      body.emit(assign(r1A4A, r1A50, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1A4E->else_instructions;

      ir_expression *const r1A51 = less(r1A49, body.constant(int(0)));
      ir_expression *const r1A52 = expr(ir_unop_b2i, r1A51);
      body.emit(assign(r1A4B, expr(ir_unop_i2u, r1A52), 0x01));

      ir_variable *const r1A53 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r1A55 = less(r1A49, body.constant(int(0)));
      ir_if *f1A54 = new(mem_ctx) ir_if(operand(r1A55).val);
      exec_list *const f1A54_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A54->then_instructions;

         ir_expression *const r1A56 = neg(r1A49);
         body.emit(assign(r1A53, expr(ir_unop_i2u, r1A56), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A54->else_instructions;

         body.emit(assign(r1A53, expr(ir_unop_i2u, r1A49), 0x01));


      body.instructions = f1A54_parent_instructions;
      body.emit(f1A54);

      /* END IF */

      ir_variable *const r1A57 = body.make_temp(glsl_type::uint_type, "a");
      body.emit(assign(r1A57, r1A53, 0x01));

      ir_variable *const r1A58 = body.make_temp(glsl_type::int_type, "return_value");
      ir_variable *const r1A59 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
      body.emit(r1A59);
      /* IF CONDITION */
      ir_expression *const r1A5B = equal(r1A53, body.constant(0u));
      ir_if *f1A5A = new(mem_ctx) ir_if(operand(r1A5B).val);
      exec_list *const f1A5A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A5A->then_instructions;

         body.emit(assign(r1A58, body.constant(int(32)), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A5A->else_instructions;

         body.emit(assign(r1A59, body.constant(int(0)), 0x01));

         /* IF CONDITION */
         ir_expression *const r1A5D = bit_and(r1A53, body.constant(4294901760u));
         ir_expression *const r1A5E = equal(r1A5D, body.constant(0u));
         ir_if *f1A5C = new(mem_ctx) ir_if(operand(r1A5E).val);
         exec_list *const f1A5C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A5C->then_instructions;

            body.emit(assign(r1A59, body.constant(int(16)), 0x01));

            body.emit(assign(r1A57, lshift(r1A53, body.constant(int(16))), 0x01));


         body.instructions = f1A5C_parent_instructions;
         body.emit(f1A5C);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1A60 = bit_and(r1A57, body.constant(4278190080u));
         ir_expression *const r1A61 = equal(r1A60, body.constant(0u));
         ir_if *f1A5F = new(mem_ctx) ir_if(operand(r1A61).val);
         exec_list *const f1A5F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A5F->then_instructions;

            body.emit(assign(r1A59, add(r1A59, body.constant(int(8))), 0x01));

            body.emit(assign(r1A57, lshift(r1A57, body.constant(int(8))), 0x01));


         body.instructions = f1A5F_parent_instructions;
         body.emit(f1A5F);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1A63 = bit_and(r1A57, body.constant(4026531840u));
         ir_expression *const r1A64 = equal(r1A63, body.constant(0u));
         ir_if *f1A62 = new(mem_ctx) ir_if(operand(r1A64).val);
         exec_list *const f1A62_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A62->then_instructions;

            body.emit(assign(r1A59, add(r1A59, body.constant(int(4))), 0x01));

            body.emit(assign(r1A57, lshift(r1A57, body.constant(int(4))), 0x01));


         body.instructions = f1A62_parent_instructions;
         body.emit(f1A62);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1A66 = bit_and(r1A57, body.constant(3221225472u));
         ir_expression *const r1A67 = equal(r1A66, body.constant(0u));
         ir_if *f1A65 = new(mem_ctx) ir_if(operand(r1A67).val);
         exec_list *const f1A65_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A65->then_instructions;

            body.emit(assign(r1A59, add(r1A59, body.constant(int(2))), 0x01));

            body.emit(assign(r1A57, lshift(r1A57, body.constant(int(2))), 0x01));


         body.instructions = f1A65_parent_instructions;
         body.emit(f1A65);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1A69 = bit_and(r1A57, body.constant(2147483648u));
         ir_expression *const r1A6A = equal(r1A69, body.constant(0u));
         ir_if *f1A68 = new(mem_ctx) ir_if(operand(r1A6A).val);
         exec_list *const f1A68_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A68->then_instructions;

            body.emit(assign(r1A59, add(r1A59, body.constant(int(1))), 0x01));


         body.instructions = f1A68_parent_instructions;
         body.emit(f1A68);

         /* END IF */

         body.emit(assign(r1A58, r1A59, 0x01));


      body.instructions = f1A5A_parent_instructions;
      body.emit(f1A5A);

      /* END IF */

      ir_variable *const r1A6B = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r1A6B, add(r1A58, body.constant(int(-11))), 0x01));

      /* IF CONDITION */
      ir_expression *const r1A6D = lequal(body.constant(int(0)), r1A6B);
      ir_if *f1A6C = new(mem_ctx) ir_if(operand(r1A6D).val);
      exec_list *const f1A6C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A6C->then_instructions;

         body.emit(assign(r1A4D, lshift(r1A53, r1A6B), 0x01));

         body.emit(assign(r1A4C, body.constant(0u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A6C->else_instructions;

         ir_variable *const r1A6E = body.make_temp(glsl_type::uint_type, "a1");
         body.emit(assign(r1A6E, body.constant(0u), 0x01));

         ir_variable *const r1A6F = body.make_temp(glsl_type::int_type, "count");
         body.emit(assign(r1A6F, neg(r1A6B), 0x01));

         ir_variable *const r1A70 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r1A70);
         ir_variable *const r1A71 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r1A71);
         ir_variable *const r1A72 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         ir_expression *const r1A73 = neg(r1A6F);
         body.emit(assign(r1A72, bit_and(r1A73, body.constant(int(31))), 0x01));

         /* IF CONDITION */
         ir_expression *const r1A75 = equal(r1A6F, body.constant(int(0)));
         ir_if *f1A74 = new(mem_ctx) ir_if(operand(r1A75).val);
         exec_list *const f1A74_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1A74->then_instructions;

            body.emit(assign(r1A70, body.constant(0u), 0x01));

            body.emit(assign(r1A71, r1A53, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1A74->else_instructions;

            /* IF CONDITION */
            ir_expression *const r1A77 = less(r1A6F, body.constant(int(32)));
            ir_if *f1A76 = new(mem_ctx) ir_if(operand(r1A77).val);
            exec_list *const f1A76_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1A76->then_instructions;

               ir_expression *const r1A78 = lshift(r1A53, r1A72);
               body.emit(assign(r1A70, bit_or(r1A78, body.constant(0u)), 0x01));

               body.emit(assign(r1A71, rshift(r1A53, r1A6F), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1A76->else_instructions;

               ir_variable *const r1A79 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r1A7B = less(r1A6F, body.constant(int(64)));
               ir_if *f1A7A = new(mem_ctx) ir_if(operand(r1A7B).val);
               exec_list *const f1A7A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1A7A->then_instructions;

                  ir_expression *const r1A7C = bit_and(r1A6F, body.constant(int(31)));
                  body.emit(assign(r1A79, rshift(r1A53, r1A7C), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1A7A->else_instructions;

                  body.emit(assign(r1A79, body.constant(0u), 0x01));


               body.instructions = f1A7A_parent_instructions;
               body.emit(f1A7A);

               /* END IF */

               body.emit(assign(r1A70, r1A79, 0x01));

               body.emit(assign(r1A71, body.constant(0u), 0x01));


            body.instructions = f1A76_parent_instructions;
            body.emit(f1A76);

            /* END IF */


         body.instructions = f1A74_parent_instructions;
         body.emit(f1A74);

         /* END IF */

         body.emit(assign(r1A4D, r1A71, 0x01));

         body.emit(assign(r1A4C, r1A70, 0x01));


      body.instructions = f1A6C_parent_instructions;
      body.emit(f1A6C);

      /* END IF */

      ir_variable *const r1A7D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r1A7D);
      ir_expression *const r1A7E = lshift(r1A4B, body.constant(int(31)));
      ir_expression *const r1A7F = sub(body.constant(int(1042)), r1A6B);
      ir_expression *const r1A80 = expr(ir_unop_i2u, r1A7F);
      ir_expression *const r1A81 = lshift(r1A80, body.constant(int(20)));
      ir_expression *const r1A82 = add(r1A7E, r1A81);
      body.emit(assign(r1A7D, add(r1A82, r1A4D), 0x02));

      body.emit(assign(r1A7D, r1A4C, 0x01));

      body.emit(assign(r1A4A, r1A7D, 0x03));


   body.instructions = f1A4E_parent_instructions;
   body.emit(f1A4E);

   /* END IF */

   body.emit(ret(r1A4A));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fgt64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1A83 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1A83);
   ir_variable *const r1A84 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r1A84);
   ir_variable *const r1A85 = body.make_temp(glsl_type::bool_type, "return_value");
   ir_variable *const r1A86 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
   body.emit(r1A86);
   ir_variable *const r1A87 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
   body.emit(r1A87);
   ir_variable *const r1A88 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r1A88);
   body.emit(assign(r1A88, bit_and(swizzle_y(r1A84), body.constant(1048575u)), 0x02));

   body.emit(assign(r1A88, swizzle_x(r1A84), 0x01));

   ir_variable *const r1A89 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r1A89);
   body.emit(assign(r1A89, bit_and(swizzle_y(r1A83), body.constant(1048575u)), 0x02));

   body.emit(assign(r1A89, swizzle_x(r1A83), 0x01));

   ir_expression *const r1A8A = rshift(swizzle_y(r1A84), body.constant(int(20)));
   ir_expression *const r1A8B = bit_and(r1A8A, body.constant(2047u));
   ir_expression *const r1A8C = expr(ir_unop_u2i, r1A8B);
   ir_expression *const r1A8D = equal(r1A8C, body.constant(int(2047)));
   ir_expression *const r1A8E = bit_or(swizzle_y(r1A88), swizzle_x(r1A84));
   ir_expression *const r1A8F = nequal(r1A8E, body.constant(0u));
   body.emit(assign(r1A87, logic_and(r1A8D, r1A8F), 0x01));

   ir_expression *const r1A90 = rshift(swizzle_y(r1A83), body.constant(int(20)));
   ir_expression *const r1A91 = bit_and(r1A90, body.constant(2047u));
   ir_expression *const r1A92 = expr(ir_unop_u2i, r1A91);
   ir_expression *const r1A93 = equal(r1A92, body.constant(int(2047)));
   ir_expression *const r1A94 = bit_or(swizzle_y(r1A89), swizzle_x(r1A83));
   ir_expression *const r1A95 = nequal(r1A94, body.constant(0u));
   body.emit(assign(r1A86, logic_and(r1A93, r1A95), 0x01));

   /* IF CONDITION */
   ir_expression *const r1A97 = logic_or(r1A87, r1A86);
   ir_if *f1A96 = new(mem_ctx) ir_if(operand(r1A97).val);
   exec_list *const f1A96_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1A96->then_instructions;

      body.emit(assign(r1A85, body.constant(false), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1A96->else_instructions;

      ir_variable *const r1A98 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r1A98, rshift(swizzle_y(r1A84), body.constant(int(31))), 0x01));

      ir_variable *const r1A99 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r1A99, rshift(swizzle_y(r1A83), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r1A9B = nequal(r1A98, r1A99);
      ir_if *f1A9A = new(mem_ctx) ir_if(operand(r1A9B).val);
      exec_list *const f1A9A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1A9A->then_instructions;

         ir_expression *const r1A9C = nequal(r1A98, body.constant(0u));
         ir_expression *const r1A9D = bit_or(swizzle_y(r1A84), swizzle_y(r1A83));
         ir_expression *const r1A9E = lshift(r1A9D, body.constant(int(1)));
         ir_expression *const r1A9F = bit_or(r1A9E, swizzle_x(r1A84));
         ir_expression *const r1AA0 = bit_or(r1A9F, swizzle_x(r1A83));
         ir_expression *const r1AA1 = nequal(r1AA0, body.constant(0u));
         body.emit(assign(r1A85, logic_and(r1A9C, r1AA1), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1A9A->else_instructions;

         ir_variable *const r1AA2 = body.make_temp(glsl_type::bool_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1AA4 = nequal(r1A98, body.constant(0u));
         ir_if *f1AA3 = new(mem_ctx) ir_if(operand(r1AA4).val);
         exec_list *const f1AA3_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1AA3->then_instructions;

            ir_expression *const r1AA5 = less(swizzle_y(r1A83), swizzle_y(r1A84));
            ir_expression *const r1AA6 = equal(swizzle_y(r1A83), swizzle_y(r1A84));
            ir_expression *const r1AA7 = less(swizzle_x(r1A83), swizzle_x(r1A84));
            ir_expression *const r1AA8 = logic_and(r1AA6, r1AA7);
            body.emit(assign(r1AA2, logic_or(r1AA5, r1AA8), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1AA3->else_instructions;

            ir_expression *const r1AA9 = less(swizzle_y(r1A84), swizzle_y(r1A83));
            ir_expression *const r1AAA = equal(swizzle_y(r1A84), swizzle_y(r1A83));
            ir_expression *const r1AAB = less(swizzle_x(r1A84), swizzle_x(r1A83));
            ir_expression *const r1AAC = logic_and(r1AAA, r1AAB);
            body.emit(assign(r1AA2, logic_or(r1AA9, r1AAC), 0x01));


         body.instructions = f1AA3_parent_instructions;
         body.emit(f1AA3);

         /* END IF */

         body.emit(assign(r1A85, r1AA2, 0x01));


      body.instructions = f1A9A_parent_instructions;
      body.emit(f1A9A);

      /* END IF */


   body.instructions = f1A96_parent_instructions;
   body.emit(f1A96);

   /* END IF */

   body.emit(ret(r1A85));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
sqrtOddAdjustments(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1AAD = new(mem_ctx) ir_variable(glsl_type::int_type, "index", ir_var_function_in);
   sig_parameters.push_tail(r1AAD);
   ir_variable *const r1AAE = new(mem_ctx) ir_variable(glsl_type::uint_type, "res", ir_var_auto);
   body.emit(r1AAE);
   body.emit(assign(r1AAE, body.constant(0u), 0x01));

   /* IF CONDITION */
   ir_expression *const r1AB0 = equal(r1AAD, body.constant(int(0)));
   ir_if *f1AAF = new(mem_ctx) ir_if(operand(r1AB0).val);
   exec_list *const f1AAF_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AAF->then_instructions;

      body.emit(assign(r1AAE, body.constant(4u), 0x01));


   body.instructions = f1AAF_parent_instructions;
   body.emit(f1AAF);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AB2 = equal(r1AAD, body.constant(int(1)));
   ir_if *f1AB1 = new(mem_ctx) ir_if(operand(r1AB2).val);
   exec_list *const f1AB1_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AB1->then_instructions;

      body.emit(assign(r1AAE, body.constant(34u), 0x01));


   body.instructions = f1AB1_parent_instructions;
   body.emit(f1AB1);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AB4 = equal(r1AAD, body.constant(int(2)));
   ir_if *f1AB3 = new(mem_ctx) ir_if(operand(r1AB4).val);
   exec_list *const f1AB3_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AB3->then_instructions;

      body.emit(assign(r1AAE, body.constant(93u), 0x01));


   body.instructions = f1AB3_parent_instructions;
   body.emit(f1AB3);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AB6 = equal(r1AAD, body.constant(int(3)));
   ir_if *f1AB5 = new(mem_ctx) ir_if(operand(r1AB6).val);
   exec_list *const f1AB5_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AB5->then_instructions;

      body.emit(assign(r1AAE, body.constant(177u), 0x01));


   body.instructions = f1AB5_parent_instructions;
   body.emit(f1AB5);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AB8 = equal(r1AAD, body.constant(int(4)));
   ir_if *f1AB7 = new(mem_ctx) ir_if(operand(r1AB8).val);
   exec_list *const f1AB7_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AB7->then_instructions;

      body.emit(assign(r1AAE, body.constant(285u), 0x01));


   body.instructions = f1AB7_parent_instructions;
   body.emit(f1AB7);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1ABA = equal(r1AAD, body.constant(int(5)));
   ir_if *f1AB9 = new(mem_ctx) ir_if(operand(r1ABA).val);
   exec_list *const f1AB9_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AB9->then_instructions;

      body.emit(assign(r1AAE, body.constant(415u), 0x01));


   body.instructions = f1AB9_parent_instructions;
   body.emit(f1AB9);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1ABC = equal(r1AAD, body.constant(int(6)));
   ir_if *f1ABB = new(mem_ctx) ir_if(operand(r1ABC).val);
   exec_list *const f1ABB_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1ABB->then_instructions;

      body.emit(assign(r1AAE, body.constant(566u), 0x01));


   body.instructions = f1ABB_parent_instructions;
   body.emit(f1ABB);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1ABE = equal(r1AAD, body.constant(int(7)));
   ir_if *f1ABD = new(mem_ctx) ir_if(operand(r1ABE).val);
   exec_list *const f1ABD_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1ABD->then_instructions;

      body.emit(assign(r1AAE, body.constant(736u), 0x01));


   body.instructions = f1ABD_parent_instructions;
   body.emit(f1ABD);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AC0 = equal(r1AAD, body.constant(int(8)));
   ir_if *f1ABF = new(mem_ctx) ir_if(operand(r1AC0).val);
   exec_list *const f1ABF_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1ABF->then_instructions;

      body.emit(assign(r1AAE, body.constant(924u), 0x01));


   body.instructions = f1ABF_parent_instructions;
   body.emit(f1ABF);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AC2 = equal(r1AAD, body.constant(int(9)));
   ir_if *f1AC1 = new(mem_ctx) ir_if(operand(r1AC2).val);
   exec_list *const f1AC1_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AC1->then_instructions;

      body.emit(assign(r1AAE, body.constant(1128u), 0x01));


   body.instructions = f1AC1_parent_instructions;
   body.emit(f1AC1);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AC4 = equal(r1AAD, body.constant(int(10)));
   ir_if *f1AC3 = new(mem_ctx) ir_if(operand(r1AC4).val);
   exec_list *const f1AC3_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AC3->then_instructions;

      body.emit(assign(r1AAE, body.constant(1349u), 0x01));


   body.instructions = f1AC3_parent_instructions;
   body.emit(f1AC3);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AC6 = equal(r1AAD, body.constant(int(11)));
   ir_if *f1AC5 = new(mem_ctx) ir_if(operand(r1AC6).val);
   exec_list *const f1AC5_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AC5->then_instructions;

      body.emit(assign(r1AAE, body.constant(1585u), 0x01));


   body.instructions = f1AC5_parent_instructions;
   body.emit(f1AC5);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AC8 = equal(r1AAD, body.constant(int(12)));
   ir_if *f1AC7 = new(mem_ctx) ir_if(operand(r1AC8).val);
   exec_list *const f1AC7_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AC7->then_instructions;

      body.emit(assign(r1AAE, body.constant(1835u), 0x01));


   body.instructions = f1AC7_parent_instructions;
   body.emit(f1AC7);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1ACA = equal(r1AAD, body.constant(int(13)));
   ir_if *f1AC9 = new(mem_ctx) ir_if(operand(r1ACA).val);
   exec_list *const f1AC9_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AC9->then_instructions;

      body.emit(assign(r1AAE, body.constant(2098u), 0x01));


   body.instructions = f1AC9_parent_instructions;
   body.emit(f1AC9);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1ACC = equal(r1AAD, body.constant(int(14)));
   ir_if *f1ACB = new(mem_ctx) ir_if(operand(r1ACC).val);
   exec_list *const f1ACB_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1ACB->then_instructions;

      body.emit(assign(r1AAE, body.constant(2374u), 0x01));


   body.instructions = f1ACB_parent_instructions;
   body.emit(f1ACB);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1ACE = equal(r1AAD, body.constant(int(15)));
   ir_if *f1ACD = new(mem_ctx) ir_if(operand(r1ACE).val);
   exec_list *const f1ACD_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1ACD->then_instructions;

      body.emit(assign(r1AAE, body.constant(2663u), 0x01));


   body.instructions = f1ACD_parent_instructions;
   body.emit(f1ACD);

   /* END IF */

   body.emit(ret(r1AAE));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
sqrtEvenAdjustments(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1ACF = new(mem_ctx) ir_variable(glsl_type::int_type, "index", ir_var_function_in);
   sig_parameters.push_tail(r1ACF);
   ir_variable *const r1AD0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "res", ir_var_auto);
   body.emit(r1AD0);
   body.emit(assign(r1AD0, body.constant(0u), 0x01));

   /* IF CONDITION */
   ir_expression *const r1AD2 = equal(r1ACF, body.constant(int(0)));
   ir_if *f1AD1 = new(mem_ctx) ir_if(operand(r1AD2).val);
   exec_list *const f1AD1_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AD1->then_instructions;

      body.emit(assign(r1AD0, body.constant(2605u), 0x01));


   body.instructions = f1AD1_parent_instructions;
   body.emit(f1AD1);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AD4 = equal(r1ACF, body.constant(int(1)));
   ir_if *f1AD3 = new(mem_ctx) ir_if(operand(r1AD4).val);
   exec_list *const f1AD3_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AD3->then_instructions;

      body.emit(assign(r1AD0, body.constant(2223u), 0x01));


   body.instructions = f1AD3_parent_instructions;
   body.emit(f1AD3);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AD6 = equal(r1ACF, body.constant(int(2)));
   ir_if *f1AD5 = new(mem_ctx) ir_if(operand(r1AD6).val);
   exec_list *const f1AD5_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AD5->then_instructions;

      body.emit(assign(r1AD0, body.constant(1882u), 0x01));


   body.instructions = f1AD5_parent_instructions;
   body.emit(f1AD5);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AD8 = equal(r1ACF, body.constant(int(3)));
   ir_if *f1AD7 = new(mem_ctx) ir_if(operand(r1AD8).val);
   exec_list *const f1AD7_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AD7->then_instructions;

      body.emit(assign(r1AD0, body.constant(1577u), 0x01));


   body.instructions = f1AD7_parent_instructions;
   body.emit(f1AD7);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1ADA = equal(r1ACF, body.constant(int(4)));
   ir_if *f1AD9 = new(mem_ctx) ir_if(operand(r1ADA).val);
   exec_list *const f1AD9_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AD9->then_instructions;

      body.emit(assign(r1AD0, body.constant(1306u), 0x01));


   body.instructions = f1AD9_parent_instructions;
   body.emit(f1AD9);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1ADC = equal(r1ACF, body.constant(int(5)));
   ir_if *f1ADB = new(mem_ctx) ir_if(operand(r1ADC).val);
   exec_list *const f1ADB_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1ADB->then_instructions;

      body.emit(assign(r1AD0, body.constant(1065u), 0x01));


   body.instructions = f1ADB_parent_instructions;
   body.emit(f1ADB);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1ADE = equal(r1ACF, body.constant(int(6)));
   ir_if *f1ADD = new(mem_ctx) ir_if(operand(r1ADE).val);
   exec_list *const f1ADD_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1ADD->then_instructions;

      body.emit(assign(r1AD0, body.constant(854u), 0x01));


   body.instructions = f1ADD_parent_instructions;
   body.emit(f1ADD);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AE0 = equal(r1ACF, body.constant(int(7)));
   ir_if *f1ADF = new(mem_ctx) ir_if(operand(r1AE0).val);
   exec_list *const f1ADF_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1ADF->then_instructions;

      body.emit(assign(r1AD0, body.constant(670u), 0x01));


   body.instructions = f1ADF_parent_instructions;
   body.emit(f1ADF);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AE2 = equal(r1ACF, body.constant(int(8)));
   ir_if *f1AE1 = new(mem_ctx) ir_if(operand(r1AE2).val);
   exec_list *const f1AE1_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AE1->then_instructions;

      body.emit(assign(r1AD0, body.constant(512u), 0x01));


   body.instructions = f1AE1_parent_instructions;
   body.emit(f1AE1);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AE4 = equal(r1ACF, body.constant(int(9)));
   ir_if *f1AE3 = new(mem_ctx) ir_if(operand(r1AE4).val);
   exec_list *const f1AE3_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AE3->then_instructions;

      body.emit(assign(r1AD0, body.constant(377u), 0x01));


   body.instructions = f1AE3_parent_instructions;
   body.emit(f1AE3);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AE6 = equal(r1ACF, body.constant(int(10)));
   ir_if *f1AE5 = new(mem_ctx) ir_if(operand(r1AE6).val);
   exec_list *const f1AE5_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AE5->then_instructions;

      body.emit(assign(r1AD0, body.constant(265u), 0x01));


   body.instructions = f1AE5_parent_instructions;
   body.emit(f1AE5);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AE8 = equal(r1ACF, body.constant(int(11)));
   ir_if *f1AE7 = new(mem_ctx) ir_if(operand(r1AE8).val);
   exec_list *const f1AE7_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AE7->then_instructions;

      body.emit(assign(r1AD0, body.constant(175u), 0x01));


   body.instructions = f1AE7_parent_instructions;
   body.emit(f1AE7);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AEA = equal(r1ACF, body.constant(int(12)));
   ir_if *f1AE9 = new(mem_ctx) ir_if(operand(r1AEA).val);
   exec_list *const f1AE9_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AE9->then_instructions;

      body.emit(assign(r1AD0, body.constant(104u), 0x01));


   body.instructions = f1AE9_parent_instructions;
   body.emit(f1AE9);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AEC = equal(r1ACF, body.constant(int(13)));
   ir_if *f1AEB = new(mem_ctx) ir_if(operand(r1AEC).val);
   exec_list *const f1AEB_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AEB->then_instructions;

      body.emit(assign(r1AD0, body.constant(52u), 0x01));


   body.instructions = f1AEB_parent_instructions;
   body.emit(f1AEB);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AEE = equal(r1ACF, body.constant(int(14)));
   ir_if *f1AED = new(mem_ctx) ir_if(operand(r1AEE).val);
   exec_list *const f1AED_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AED->then_instructions;

      body.emit(assign(r1AD0, body.constant(18u), 0x01));


   body.instructions = f1AED_parent_instructions;
   body.emit(f1AED);

   /* END IF */

   /* IF CONDITION */
   ir_expression *const r1AF0 = equal(r1ACF, body.constant(int(15)));
   ir_if *f1AEF = new(mem_ctx) ir_if(operand(r1AF0).val);
   exec_list *const f1AEF_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AEF->then_instructions;

      body.emit(assign(r1AD0, body.constant(2u), 0x01));


   body.instructions = f1AEF_parent_instructions;
   body.emit(f1AEF);

   /* END IF */

   body.emit(ret(r1AD0));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
estimateSqrt32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1AF1 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_function_in);
   sig_parameters.push_tail(r1AF1);
   ir_variable *const r1AF2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1AF2);
   ir_variable *const r1AF3 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r1AF3, body.constant(true), 0x01));

   ir_variable *const r1AF4 = body.make_temp(glsl_type::uint_type, "return_value");
   ir_variable *const r1AF5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
   body.emit(r1AF5);
   ir_variable *const r1AF6 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r1AF7 = rshift(r1AF2, body.constant(int(27)));
   ir_expression *const r1AF8 = bit_and(r1AF7, body.constant(15u));
   body.emit(assign(r1AF6, expr(ir_unop_u2i, r1AF8), 0x01));

   /* IF CONDITION */
   ir_expression *const r1AFA = bit_and(r1AF1, body.constant(int(1)));
   ir_expression *const r1AFB = nequal(r1AFA, body.constant(int(0)));
   ir_if *f1AF9 = new(mem_ctx) ir_if(operand(r1AFB).val);
   exec_list *const f1AF9_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1AF9->then_instructions;

      ir_variable *const r1AFC = new(mem_ctx) ir_variable(glsl_type::uint_type, "res", ir_var_auto);
      body.emit(r1AFC);
      body.emit(assign(r1AFC, body.constant(0u), 0x01));

      /* IF CONDITION */
      ir_expression *const r1AFE = equal(r1AF6, body.constant(int(0)));
      ir_if *f1AFD = new(mem_ctx) ir_if(operand(r1AFE).val);
      exec_list *const f1AFD_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AFD->then_instructions;

         body.emit(assign(r1AFC, body.constant(4u), 0x01));


      body.instructions = f1AFD_parent_instructions;
      body.emit(f1AFD);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B00 = equal(r1AF6, body.constant(int(1)));
      ir_if *f1AFF = new(mem_ctx) ir_if(operand(r1B00).val);
      exec_list *const f1AFF_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1AFF->then_instructions;

         body.emit(assign(r1AFC, body.constant(34u), 0x01));


      body.instructions = f1AFF_parent_instructions;
      body.emit(f1AFF);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B02 = equal(r1AF6, body.constant(int(2)));
      ir_if *f1B01 = new(mem_ctx) ir_if(operand(r1B02).val);
      exec_list *const f1B01_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B01->then_instructions;

         body.emit(assign(r1AFC, body.constant(93u), 0x01));


      body.instructions = f1B01_parent_instructions;
      body.emit(f1B01);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B04 = equal(r1AF6, body.constant(int(3)));
      ir_if *f1B03 = new(mem_ctx) ir_if(operand(r1B04).val);
      exec_list *const f1B03_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B03->then_instructions;

         body.emit(assign(r1AFC, body.constant(177u), 0x01));


      body.instructions = f1B03_parent_instructions;
      body.emit(f1B03);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B06 = equal(r1AF6, body.constant(int(4)));
      ir_if *f1B05 = new(mem_ctx) ir_if(operand(r1B06).val);
      exec_list *const f1B05_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B05->then_instructions;

         body.emit(assign(r1AFC, body.constant(285u), 0x01));


      body.instructions = f1B05_parent_instructions;
      body.emit(f1B05);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B08 = equal(r1AF6, body.constant(int(5)));
      ir_if *f1B07 = new(mem_ctx) ir_if(operand(r1B08).val);
      exec_list *const f1B07_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B07->then_instructions;

         body.emit(assign(r1AFC, body.constant(415u), 0x01));


      body.instructions = f1B07_parent_instructions;
      body.emit(f1B07);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B0A = equal(r1AF6, body.constant(int(6)));
      ir_if *f1B09 = new(mem_ctx) ir_if(operand(r1B0A).val);
      exec_list *const f1B09_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B09->then_instructions;

         body.emit(assign(r1AFC, body.constant(566u), 0x01));


      body.instructions = f1B09_parent_instructions;
      body.emit(f1B09);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B0C = equal(r1AF6, body.constant(int(7)));
      ir_if *f1B0B = new(mem_ctx) ir_if(operand(r1B0C).val);
      exec_list *const f1B0B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B0B->then_instructions;

         body.emit(assign(r1AFC, body.constant(736u), 0x01));


      body.instructions = f1B0B_parent_instructions;
      body.emit(f1B0B);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B0E = equal(r1AF6, body.constant(int(8)));
      ir_if *f1B0D = new(mem_ctx) ir_if(operand(r1B0E).val);
      exec_list *const f1B0D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B0D->then_instructions;

         body.emit(assign(r1AFC, body.constant(924u), 0x01));


      body.instructions = f1B0D_parent_instructions;
      body.emit(f1B0D);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B10 = equal(r1AF6, body.constant(int(9)));
      ir_if *f1B0F = new(mem_ctx) ir_if(operand(r1B10).val);
      exec_list *const f1B0F_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B0F->then_instructions;

         body.emit(assign(r1AFC, body.constant(1128u), 0x01));


      body.instructions = f1B0F_parent_instructions;
      body.emit(f1B0F);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B12 = equal(r1AF6, body.constant(int(10)));
      ir_if *f1B11 = new(mem_ctx) ir_if(operand(r1B12).val);
      exec_list *const f1B11_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B11->then_instructions;

         body.emit(assign(r1AFC, body.constant(1349u), 0x01));


      body.instructions = f1B11_parent_instructions;
      body.emit(f1B11);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B14 = equal(r1AF6, body.constant(int(11)));
      ir_if *f1B13 = new(mem_ctx) ir_if(operand(r1B14).val);
      exec_list *const f1B13_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B13->then_instructions;

         body.emit(assign(r1AFC, body.constant(1585u), 0x01));


      body.instructions = f1B13_parent_instructions;
      body.emit(f1B13);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B16 = equal(r1AF6, body.constant(int(12)));
      ir_if *f1B15 = new(mem_ctx) ir_if(operand(r1B16).val);
      exec_list *const f1B15_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B15->then_instructions;

         body.emit(assign(r1AFC, body.constant(1835u), 0x01));


      body.instructions = f1B15_parent_instructions;
      body.emit(f1B15);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B18 = equal(r1AF6, body.constant(int(13)));
      ir_if *f1B17 = new(mem_ctx) ir_if(operand(r1B18).val);
      exec_list *const f1B17_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B17->then_instructions;

         body.emit(assign(r1AFC, body.constant(2098u), 0x01));


      body.instructions = f1B17_parent_instructions;
      body.emit(f1B17);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B1A = equal(r1AF6, body.constant(int(14)));
      ir_if *f1B19 = new(mem_ctx) ir_if(operand(r1B1A).val);
      exec_list *const f1B19_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B19->then_instructions;

         body.emit(assign(r1AFC, body.constant(2374u), 0x01));


      body.instructions = f1B19_parent_instructions;
      body.emit(f1B19);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B1C = equal(r1AF6, body.constant(int(15)));
      ir_if *f1B1B = new(mem_ctx) ir_if(operand(r1B1C).val);
      exec_list *const f1B1B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B1B->then_instructions;

         body.emit(assign(r1AFC, body.constant(2663u), 0x01));


      body.instructions = f1B1B_parent_instructions;
      body.emit(f1B1B);

      /* END IF */

      ir_expression *const r1B1D = rshift(r1AF2, body.constant(int(17)));
      ir_expression *const r1B1E = add(body.constant(16384u), r1B1D);
      body.emit(assign(r1AF5, sub(r1B1E, r1AFC), 0x01));

      ir_expression *const r1B1F = expr(ir_binop_div, r1AF2, r1AF5);
      ir_expression *const r1B20 = lshift(r1B1F, body.constant(int(14)));
      ir_expression *const r1B21 = lshift(r1AF5, body.constant(int(15)));
      body.emit(assign(r1AF5, add(r1B20, r1B21), 0x01));

      body.emit(assign(r1AF2, rshift(r1AF2, body.constant(int(1))), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1AF9->else_instructions;

      ir_variable *const r1B22 = new(mem_ctx) ir_variable(glsl_type::uint_type, "res", ir_var_auto);
      body.emit(r1B22);
      body.emit(assign(r1B22, body.constant(0u), 0x01));

      /* IF CONDITION */
      ir_expression *const r1B24 = equal(r1AF6, body.constant(int(0)));
      ir_if *f1B23 = new(mem_ctx) ir_if(operand(r1B24).val);
      exec_list *const f1B23_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B23->then_instructions;

         body.emit(assign(r1B22, body.constant(2605u), 0x01));


      body.instructions = f1B23_parent_instructions;
      body.emit(f1B23);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B26 = equal(r1AF6, body.constant(int(1)));
      ir_if *f1B25 = new(mem_ctx) ir_if(operand(r1B26).val);
      exec_list *const f1B25_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B25->then_instructions;

         body.emit(assign(r1B22, body.constant(2223u), 0x01));


      body.instructions = f1B25_parent_instructions;
      body.emit(f1B25);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B28 = equal(r1AF6, body.constant(int(2)));
      ir_if *f1B27 = new(mem_ctx) ir_if(operand(r1B28).val);
      exec_list *const f1B27_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B27->then_instructions;

         body.emit(assign(r1B22, body.constant(1882u), 0x01));


      body.instructions = f1B27_parent_instructions;
      body.emit(f1B27);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B2A = equal(r1AF6, body.constant(int(3)));
      ir_if *f1B29 = new(mem_ctx) ir_if(operand(r1B2A).val);
      exec_list *const f1B29_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B29->then_instructions;

         body.emit(assign(r1B22, body.constant(1577u), 0x01));


      body.instructions = f1B29_parent_instructions;
      body.emit(f1B29);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B2C = equal(r1AF6, body.constant(int(4)));
      ir_if *f1B2B = new(mem_ctx) ir_if(operand(r1B2C).val);
      exec_list *const f1B2B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B2B->then_instructions;

         body.emit(assign(r1B22, body.constant(1306u), 0x01));


      body.instructions = f1B2B_parent_instructions;
      body.emit(f1B2B);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B2E = equal(r1AF6, body.constant(int(5)));
      ir_if *f1B2D = new(mem_ctx) ir_if(operand(r1B2E).val);
      exec_list *const f1B2D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B2D->then_instructions;

         body.emit(assign(r1B22, body.constant(1065u), 0x01));


      body.instructions = f1B2D_parent_instructions;
      body.emit(f1B2D);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B30 = equal(r1AF6, body.constant(int(6)));
      ir_if *f1B2F = new(mem_ctx) ir_if(operand(r1B30).val);
      exec_list *const f1B2F_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B2F->then_instructions;

         body.emit(assign(r1B22, body.constant(854u), 0x01));


      body.instructions = f1B2F_parent_instructions;
      body.emit(f1B2F);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B32 = equal(r1AF6, body.constant(int(7)));
      ir_if *f1B31 = new(mem_ctx) ir_if(operand(r1B32).val);
      exec_list *const f1B31_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B31->then_instructions;

         body.emit(assign(r1B22, body.constant(670u), 0x01));


      body.instructions = f1B31_parent_instructions;
      body.emit(f1B31);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B34 = equal(r1AF6, body.constant(int(8)));
      ir_if *f1B33 = new(mem_ctx) ir_if(operand(r1B34).val);
      exec_list *const f1B33_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B33->then_instructions;

         body.emit(assign(r1B22, body.constant(512u), 0x01));


      body.instructions = f1B33_parent_instructions;
      body.emit(f1B33);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B36 = equal(r1AF6, body.constant(int(9)));
      ir_if *f1B35 = new(mem_ctx) ir_if(operand(r1B36).val);
      exec_list *const f1B35_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B35->then_instructions;

         body.emit(assign(r1B22, body.constant(377u), 0x01));


      body.instructions = f1B35_parent_instructions;
      body.emit(f1B35);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B38 = equal(r1AF6, body.constant(int(10)));
      ir_if *f1B37 = new(mem_ctx) ir_if(operand(r1B38).val);
      exec_list *const f1B37_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B37->then_instructions;

         body.emit(assign(r1B22, body.constant(265u), 0x01));


      body.instructions = f1B37_parent_instructions;
      body.emit(f1B37);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B3A = equal(r1AF6, body.constant(int(11)));
      ir_if *f1B39 = new(mem_ctx) ir_if(operand(r1B3A).val);
      exec_list *const f1B39_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B39->then_instructions;

         body.emit(assign(r1B22, body.constant(175u), 0x01));


      body.instructions = f1B39_parent_instructions;
      body.emit(f1B39);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B3C = equal(r1AF6, body.constant(int(12)));
      ir_if *f1B3B = new(mem_ctx) ir_if(operand(r1B3C).val);
      exec_list *const f1B3B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B3B->then_instructions;

         body.emit(assign(r1B22, body.constant(104u), 0x01));


      body.instructions = f1B3B_parent_instructions;
      body.emit(f1B3B);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B3E = equal(r1AF6, body.constant(int(13)));
      ir_if *f1B3D = new(mem_ctx) ir_if(operand(r1B3E).val);
      exec_list *const f1B3D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B3D->then_instructions;

         body.emit(assign(r1B22, body.constant(52u), 0x01));


      body.instructions = f1B3D_parent_instructions;
      body.emit(f1B3D);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B40 = equal(r1AF6, body.constant(int(14)));
      ir_if *f1B3F = new(mem_ctx) ir_if(operand(r1B40).val);
      exec_list *const f1B3F_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B3F->then_instructions;

         body.emit(assign(r1B22, body.constant(18u), 0x01));


      body.instructions = f1B3F_parent_instructions;
      body.emit(f1B3F);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1B42 = equal(r1AF6, body.constant(int(15)));
      ir_if *f1B41 = new(mem_ctx) ir_if(operand(r1B42).val);
      exec_list *const f1B41_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B41->then_instructions;

         body.emit(assign(r1B22, body.constant(2u), 0x01));


      body.instructions = f1B41_parent_instructions;
      body.emit(f1B41);

      /* END IF */

      ir_expression *const r1B43 = rshift(r1AF2, body.constant(int(17)));
      ir_expression *const r1B44 = add(body.constant(32768u), r1B43);
      body.emit(assign(r1AF5, sub(r1B44, r1B22), 0x01));

      ir_expression *const r1B45 = expr(ir_binop_div, r1AF2, r1AF5);
      body.emit(assign(r1AF5, add(r1B45, r1AF5), 0x01));

      ir_variable *const r1B46 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r1B48 = lequal(body.constant(131072u), r1AF5);
      ir_if *f1B47 = new(mem_ctx) ir_if(operand(r1B48).val);
      exec_list *const f1B47_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B47->then_instructions;

         body.emit(assign(r1B46, body.constant(4294934528u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1B47->else_instructions;

         body.emit(assign(r1B46, lshift(r1AF5, body.constant(int(15))), 0x01));


      body.instructions = f1B47_parent_instructions;
      body.emit(f1B47);

      /* END IF */

      body.emit(assign(r1AF5, r1B46, 0x01));

      /* IF CONDITION */
      ir_expression *const r1B4A = lequal(r1B46, r1AF2);
      ir_if *f1B49 = new(mem_ctx) ir_if(operand(r1B4A).val);
      exec_list *const f1B49_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B49->then_instructions;

         ir_expression *const r1B4B = expr(ir_unop_u2i, r1AF2);
         ir_expression *const r1B4C = rshift(r1B4B, body.constant(int(1)));
         body.emit(assign(r1AF4, expr(ir_unop_i2u, r1B4C), 0x01));

         body.emit(assign(r1AF3, body.constant(false), 0x01));


      body.instructions = f1B49_parent_instructions;
      body.emit(f1B49);

      /* END IF */


   body.instructions = f1AF9_parent_instructions;
   body.emit(f1AF9);

   /* END IF */

   /* IF CONDITION */
   ir_if *f1B4D = new(mem_ctx) ir_if(operand(r1AF3).val);
   exec_list *const f1B4D_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1B4D->then_instructions;

      ir_variable *const r1B4E = body.make_temp(glsl_type::uint_type, "return_value");
      ir_variable *const r1B4F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
      body.emit(r1B4F);
      ir_variable *const r1B50 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
      body.emit(r1B50);
      ir_variable *const r1B51 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
      body.emit(r1B51);
      ir_variable *const r1B52 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
      body.emit(r1B52);
      body.emit(assign(r1B51, body.constant(0u), 0x01));

      body.emit(assign(r1B50, body.constant(0u), 0x01));

      /* IF CONDITION */
      ir_expression *const r1B54 = lequal(r1AF5, r1AF2);
      ir_if *f1B53 = new(mem_ctx) ir_if(operand(r1B54).val);
      exec_list *const f1B53_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B53->then_instructions;

         body.emit(assign(r1B4E, body.constant(4294967295u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1B53->else_instructions;

         body.emit(assign(r1B52, rshift(r1AF5, body.constant(int(16))), 0x01));

         ir_variable *const r1B55 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1B57 = lshift(r1B52, body.constant(int(16)));
         ir_expression *const r1B58 = lequal(r1B57, r1AF2);
         ir_if *f1B56 = new(mem_ctx) ir_if(operand(r1B58).val);
         exec_list *const f1B56_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1B56->then_instructions;

            body.emit(assign(r1B55, body.constant(4294901760u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1B56->else_instructions;

            ir_expression *const r1B59 = expr(ir_binop_div, r1AF2, r1B52);
            body.emit(assign(r1B55, lshift(r1B59, body.constant(int(16))), 0x01));


         body.instructions = f1B56_parent_instructions;
         body.emit(f1B56);

         /* END IF */

         body.emit(assign(r1B4F, r1B55, 0x01));

         ir_variable *const r1B5A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r1B5A);
         ir_variable *const r1B5B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
         body.emit(r1B5B);
         ir_variable *const r1B5C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r1B5C);
         ir_variable *const r1B5D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r1B5D, bit_and(r1AF5, body.constant(65535u)), 0x01));

         ir_variable *const r1B5E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r1B5E, rshift(r1AF5, body.constant(int(16))), 0x01));

         ir_variable *const r1B5F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r1B5F, bit_and(r1B55, body.constant(65535u)), 0x01));

         ir_variable *const r1B60 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r1B60, rshift(r1B55, body.constant(int(16))), 0x01));

         ir_variable *const r1B61 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r1B61, mul(r1B5E, r1B5F), 0x01));

         ir_expression *const r1B62 = mul(r1B5D, r1B60);
         body.emit(assign(r1B5B, add(r1B62, r1B61), 0x01));

         ir_expression *const r1B63 = mul(r1B5E, r1B60);
         ir_expression *const r1B64 = less(r1B5B, r1B61);
         ir_expression *const r1B65 = expr(ir_unop_b2i, r1B64);
         ir_expression *const r1B66 = expr(ir_unop_i2u, r1B65);
         ir_expression *const r1B67 = lshift(r1B66, body.constant(int(16)));
         ir_expression *const r1B68 = rshift(r1B5B, body.constant(int(16)));
         ir_expression *const r1B69 = add(r1B67, r1B68);
         body.emit(assign(r1B5A, add(r1B63, r1B69), 0x01));

         body.emit(assign(r1B5B, lshift(r1B5B, body.constant(int(16))), 0x01));

         ir_expression *const r1B6A = mul(r1B5D, r1B5F);
         body.emit(assign(r1B5C, add(r1B6A, r1B5B), 0x01));

         ir_expression *const r1B6B = less(r1B5C, r1B5B);
         ir_expression *const r1B6C = expr(ir_unop_b2i, r1B6B);
         ir_expression *const r1B6D = expr(ir_unop_i2u, r1B6C);
         body.emit(assign(r1B5A, add(r1B5A, r1B6D), 0x01));

         ir_expression *const r1B6E = sub(r1AF2, r1B5A);
         ir_expression *const r1B6F = less(body.constant(0u), r1B5C);
         ir_expression *const r1B70 = expr(ir_unop_b2i, r1B6F);
         ir_expression *const r1B71 = expr(ir_unop_i2u, r1B70);
         body.emit(assign(r1B51, sub(r1B6E, r1B71), 0x01));

         body.emit(assign(r1B50, neg(r1B5C), 0x01));

         /* LOOP BEGIN */
         ir_loop *f1B72 = new(mem_ctx) ir_loop();
         exec_list *const f1B72_parent_instructions = body.instructions;

            body.instructions = &f1B72->body_instructions;

            /* IF CONDITION */
            ir_expression *const r1B74 = expr(ir_unop_u2i, r1B51);
            ir_expression *const r1B75 = gequal(r1B74, body.constant(int(0)));
            ir_if *f1B73 = new(mem_ctx) ir_if(operand(r1B75).val);
            exec_list *const f1B73_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1B73->then_instructions;

               body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


            body.instructions = f1B73_parent_instructions;
            body.emit(f1B73);

            /* END IF */

            body.emit(assign(r1B4F, add(r1B4F, body.constant(4294901760u)), 0x01));

            ir_variable *const r1B76 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            ir_expression *const r1B77 = lshift(r1AF5, body.constant(int(16)));
            body.emit(assign(r1B76, add(r1B50, r1B77), 0x01));

            ir_expression *const r1B78 = add(r1B51, r1B52);
            ir_expression *const r1B79 = less(r1B76, r1B50);
            ir_expression *const r1B7A = expr(ir_unop_b2i, r1B79);
            ir_expression *const r1B7B = expr(ir_unop_i2u, r1B7A);
            body.emit(assign(r1B51, add(r1B78, r1B7B), 0x01));

            body.emit(assign(r1B50, r1B76, 0x01));

         /* LOOP END */

         body.instructions = f1B72_parent_instructions;
         body.emit(f1B72);

         ir_expression *const r1B7C = lshift(r1B51, body.constant(int(16)));
         ir_expression *const r1B7D = rshift(r1B50, body.constant(int(16)));
         body.emit(assign(r1B51, bit_or(r1B7C, r1B7D), 0x01));

         ir_variable *const r1B7E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1B80 = lshift(r1B52, body.constant(int(16)));
         ir_expression *const r1B81 = lequal(r1B80, r1B51);
         ir_if *f1B7F = new(mem_ctx) ir_if(operand(r1B81).val);
         exec_list *const f1B7F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1B7F->then_instructions;

            body.emit(assign(r1B7E, body.constant(65535u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1B7F->else_instructions;

            body.emit(assign(r1B7E, expr(ir_binop_div, r1B51, r1B52), 0x01));


         body.instructions = f1B7F_parent_instructions;
         body.emit(f1B7F);

         /* END IF */

         body.emit(assign(r1B4F, bit_or(r1B4F, r1B7E), 0x01));

         body.emit(assign(r1B4E, r1B4F, 0x01));


      body.instructions = f1B53_parent_instructions;
      body.emit(f1B53);

      /* END IF */

      ir_expression *const r1B82 = rshift(r1B4E, body.constant(int(1)));
      ir_expression *const r1B83 = rshift(r1AF5, body.constant(int(1)));
      body.emit(assign(r1AF4, add(r1B82, r1B83), 0x01));

      body.emit(assign(r1AF3, body.constant(false), 0x01));


   body.instructions = f1B4D_parent_instructions;
   body.emit(f1B4D);

   /* END IF */

   body.emit(ret(r1AF4));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fsqrt64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1B84 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1B84);
   ir_variable *const r1B85 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r1B85, body.constant(true), 0x01));

   ir_variable *const r1B86 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1B87 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r1B87);
   ir_variable *const r1B88 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r1B88);
   ir_variable *const r1B89 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
   body.emit(r1B89);
   ir_variable *const r1B8A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "default_nan", ir_var_auto);
   body.emit(r1B8A);
   ir_variable *const r1B8B = new(mem_ctx) ir_variable(glsl_type::uint_type, "term3", ir_var_auto);
   body.emit(r1B8B);
   ir_variable *const r1B8C = new(mem_ctx) ir_variable(glsl_type::uint_type, "term2", ir_var_auto);
   body.emit(r1B8C);
   ir_variable *const r1B8D = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem3", ir_var_auto);
   body.emit(r1B8D);
   ir_variable *const r1B8E = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem2", ir_var_auto);
   body.emit(r1B8E);
   ir_variable *const r1B8F = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
   body.emit(r1B8F);
   ir_variable *const r1B90 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
   body.emit(r1B90);
   ir_variable *const r1B91 = new(mem_ctx) ir_variable(glsl_type::uint_type, "doubleZFrac0", ir_var_auto);
   body.emit(r1B91);
   ir_variable *const r1B92 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r1B92);
   ir_variable *const r1B93 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r1B93);
   body.emit(assign(r1B93, body.constant(0u), 0x01));

   body.emit(assign(r1B92, body.constant(0u), 0x01));

   body.emit(assign(r1B91, body.constant(0u), 0x01));

   body.emit(assign(r1B90, body.constant(0u), 0x01));

   body.emit(assign(r1B8F, body.constant(0u), 0x01));

   body.emit(assign(r1B8E, body.constant(0u), 0x01));

   body.emit(assign(r1B8D, body.constant(0u), 0x01));

   body.emit(assign(r1B8C, body.constant(0u), 0x01));

   body.emit(assign(r1B8B, body.constant(0u), 0x01));

   body.emit(assign(r1B8A, body.constant(4294967295u), 0x02));

   body.emit(assign(r1B8A, body.constant(4294967295u), 0x01));

   ir_variable *const r1B94 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r1B94);
   body.emit(assign(r1B94, bit_and(swizzle_y(r1B84), body.constant(1048575u)), 0x02));

   body.emit(assign(r1B94, swizzle_x(r1B84), 0x01));

   body.emit(assign(r1B89, r1B94, 0x03));

   ir_variable *const r1B95 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r1B96 = rshift(swizzle_y(r1B84), body.constant(int(20)));
   ir_expression *const r1B97 = bit_and(r1B96, body.constant(2047u));
   body.emit(assign(r1B95, expr(ir_unop_u2i, r1B97), 0x01));

   body.emit(assign(r1B88, r1B95, 0x01));

   ir_variable *const r1B98 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r1B98, rshift(swizzle_y(r1B84), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1B9A = equal(r1B95, body.constant(int(2047)));
   ir_if *f1B99 = new(mem_ctx) ir_if(operand(r1B9A).val);
   exec_list *const f1B99_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1B99->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1B9C = bit_or(swizzle_y(r1B94), swizzle_x(r1B84));
      ir_expression *const r1B9D = nequal(r1B9C, body.constant(0u));
      ir_if *f1B9B = new(mem_ctx) ir_if(operand(r1B9D).val);
      exec_list *const f1B9B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1B9B->then_instructions;

         ir_variable *const r1B9E = body.make_temp(glsl_type::uvec2_type, "a");
         body.emit(assign(r1B9E, swizzle_x(r1B84), 0x01));

         ir_variable *const r1B9F = body.make_temp(glsl_type::uvec2_type, "b");
         body.emit(assign(r1B9F, swizzle_x(r1B84), 0x01));

         ir_variable *const r1BA0 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r1BA1 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
         ir_expression *const r1BA2 = rshift(swizzle_y(r1B84), body.constant(int(19)));
         ir_expression *const r1BA3 = bit_and(r1BA2, body.constant(4095u));
         ir_expression *const r1BA4 = equal(r1BA3, body.constant(4094u));
         ir_expression *const r1BA5 = nequal(swizzle_x(r1B84), body.constant(0u));
         ir_expression *const r1BA6 = bit_and(swizzle_y(r1B84), body.constant(524287u));
         ir_expression *const r1BA7 = nequal(r1BA6, body.constant(0u));
         ir_expression *const r1BA8 = logic_or(r1BA5, r1BA7);
         body.emit(assign(r1BA1, logic_and(r1BA4, r1BA8), 0x01));

         ir_variable *const r1BA9 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
         ir_expression *const r1BAA = lshift(swizzle_y(r1B84), body.constant(int(1)));
         ir_expression *const r1BAB = lequal(body.constant(4292870144u), r1BAA);
         ir_expression *const r1BAC = nequal(swizzle_x(r1B84), body.constant(0u));
         ir_expression *const r1BAD = bit_and(swizzle_y(r1B84), body.constant(1048575u));
         ir_expression *const r1BAE = nequal(r1BAD, body.constant(0u));
         ir_expression *const r1BAF = logic_or(r1BAC, r1BAE);
         body.emit(assign(r1BA9, logic_and(r1BAB, r1BAF), 0x01));

         body.emit(assign(r1B9E, bit_or(swizzle_y(r1B84), body.constant(524288u)), 0x02));

         body.emit(assign(r1B9F, bit_or(swizzle_y(r1B84), body.constant(524288u)), 0x02));

         /* IF CONDITION */
         ir_expression *const r1BB1 = lshift(swizzle_y(r1B84), body.constant(int(1)));
         ir_expression *const r1BB2 = lequal(body.constant(4292870144u), r1BB1);
         ir_expression *const r1BB3 = nequal(swizzle_x(r1B84), body.constant(0u));
         ir_expression *const r1BB4 = bit_and(swizzle_y(r1B84), body.constant(1048575u));
         ir_expression *const r1BB5 = nequal(r1BB4, body.constant(0u));
         ir_expression *const r1BB6 = logic_or(r1BB3, r1BB5);
         ir_expression *const r1BB7 = logic_and(r1BB2, r1BB6);
         ir_if *f1BB0 = new(mem_ctx) ir_if(operand(r1BB7).val);
         exec_list *const f1BB0_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1BB0->then_instructions;

            ir_variable *const r1BB8 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r1BBA = logic_and(r1BA1, r1BA9);
            ir_if *f1BB9 = new(mem_ctx) ir_if(operand(r1BBA).val);
            exec_list *const f1BB9_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1BB9->then_instructions;

               body.emit(assign(r1BB8, r1B9F, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1BB9->else_instructions;

               body.emit(assign(r1BB8, r1B9E, 0x03));


            body.instructions = f1BB9_parent_instructions;
            body.emit(f1BB9);

            /* END IF */

            body.emit(assign(r1BA0, r1BB8, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1BB0->else_instructions;

            body.emit(assign(r1BA0, r1B9F, 0x03));


         body.instructions = f1BB0_parent_instructions;
         body.emit(f1BB0);

         /* END IF */

         body.emit(assign(r1B86, r1BA0, 0x03));

         body.emit(assign(r1B85, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1B9B->else_instructions;

         /* IF CONDITION */
         ir_expression *const r1BBC = equal(r1B98, body.constant(0u));
         ir_if *f1BBB = new(mem_ctx) ir_if(operand(r1BBC).val);
         exec_list *const f1BBB_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1BBB->then_instructions;

            body.emit(assign(r1B86, r1B84, 0x03));

            body.emit(assign(r1B85, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1BBB->else_instructions;

            body.emit(assign(r1B86, r1B8A, 0x03));

            body.emit(assign(r1B85, body.constant(false), 0x01));


         body.instructions = f1BBB_parent_instructions;
         body.emit(f1BBB);

         /* END IF */


      body.instructions = f1B9B_parent_instructions;
      body.emit(f1B9B);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1B99->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1BBE = nequal(r1B98, body.constant(0u));
      ir_if *f1BBD = new(mem_ctx) ir_if(operand(r1BBE).val);
      exec_list *const f1BBD_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1BBD->then_instructions;

         /* IF CONDITION */
         ir_expression *const r1BC0 = expr(ir_unop_i2u, r1B95);
         ir_expression *const r1BC1 = bit_or(r1BC0, swizzle_y(r1B94));
         ir_expression *const r1BC2 = bit_or(r1BC1, swizzle_x(r1B84));
         ir_expression *const r1BC3 = equal(r1BC2, body.constant(0u));
         ir_if *f1BBF = new(mem_ctx) ir_if(operand(r1BC3).val);
         exec_list *const f1BBF_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1BBF->then_instructions;

            body.emit(assign(r1B86, r1B84, 0x03));

            body.emit(assign(r1B85, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1BBF->else_instructions;

            body.emit(assign(r1B86, r1B8A, 0x03));

            body.emit(assign(r1B85, body.constant(false), 0x01));


         body.instructions = f1BBF_parent_instructions;
         body.emit(f1BBF);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1BBD->else_instructions;

         /* IF CONDITION */
         ir_expression *const r1BC5 = equal(r1B95, body.constant(int(0)));
         ir_if *f1BC4 = new(mem_ctx) ir_if(operand(r1BC5).val);
         exec_list *const f1BC4_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1BC4->then_instructions;

            /* IF CONDITION */
            ir_expression *const r1BC7 = bit_or(swizzle_y(r1B94), swizzle_x(r1B84));
            ir_expression *const r1BC8 = equal(r1BC7, body.constant(0u));
            ir_if *f1BC6 = new(mem_ctx) ir_if(operand(r1BC8).val);
            exec_list *const f1BC6_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1BC6->then_instructions;

               ir_variable *const r1BC9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r1BC9);
               body.emit(assign(r1BC9, body.constant(0u), 0x02));

               body.emit(assign(r1BC9, body.constant(0u), 0x01));

               body.emit(assign(r1B86, r1BC9, 0x03));

               body.emit(assign(r1B85, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1BC6->else_instructions;

               ir_variable *const r1BCA = body.make_temp(glsl_type::uint_type, "aFrac0");
               body.emit(assign(r1BCA, swizzle_y(r1B94), 0x01));

               ir_variable *const r1BCB = body.make_temp(glsl_type::uint_type, "aFrac1");
               body.emit(assign(r1BCB, swizzle_x(r1B94), 0x01));

               ir_variable *const r1BCC = body.make_temp(glsl_type::int_type, "zExpPtr");
               body.emit(assign(r1BCC, r1B95, 0x01));

               ir_variable *const r1BCD = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
               body.emit(assign(r1BCD, swizzle_y(r1B94), 0x01));

               ir_variable *const r1BCE = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
               body.emit(assign(r1BCE, swizzle_x(r1B94), 0x01));

               ir_variable *const r1BCF = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1BCF);
               /* IF CONDITION */
               ir_expression *const r1BD1 = equal(swizzle_y(r1B94), body.constant(0u));
               ir_if *f1BD0 = new(mem_ctx) ir_if(operand(r1BD1).val);
               exec_list *const f1BD0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1BD0->then_instructions;

                  ir_variable *const r1BD2 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r1BD2, r1BCB, 0x01));

                  ir_variable *const r1BD3 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r1BD4 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r1BD4);
                  /* IF CONDITION */
                  ir_expression *const r1BD6 = equal(swizzle_x(r1B84), body.constant(0u));
                  ir_if *f1BD5 = new(mem_ctx) ir_if(operand(r1BD6).val);
                  exec_list *const f1BD5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1BD5->then_instructions;

                     body.emit(assign(r1BD3, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1BD5->else_instructions;

                     body.emit(assign(r1BD4, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1BD8 = bit_and(swizzle_x(r1B84), body.constant(4294901760u));
                     ir_expression *const r1BD9 = equal(r1BD8, body.constant(0u));
                     ir_if *f1BD7 = new(mem_ctx) ir_if(operand(r1BD9).val);
                     exec_list *const f1BD7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1BD7->then_instructions;

                        body.emit(assign(r1BD4, body.constant(int(16)), 0x01));

                        body.emit(assign(r1BD2, lshift(swizzle_x(r1B84), body.constant(int(16))), 0x01));


                     body.instructions = f1BD7_parent_instructions;
                     body.emit(f1BD7);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1BDB = bit_and(r1BD2, body.constant(4278190080u));
                     ir_expression *const r1BDC = equal(r1BDB, body.constant(0u));
                     ir_if *f1BDA = new(mem_ctx) ir_if(operand(r1BDC).val);
                     exec_list *const f1BDA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1BDA->then_instructions;

                        body.emit(assign(r1BD4, add(r1BD4, body.constant(int(8))), 0x01));

                        body.emit(assign(r1BD2, lshift(r1BD2, body.constant(int(8))), 0x01));


                     body.instructions = f1BDA_parent_instructions;
                     body.emit(f1BDA);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1BDE = bit_and(r1BD2, body.constant(4026531840u));
                     ir_expression *const r1BDF = equal(r1BDE, body.constant(0u));
                     ir_if *f1BDD = new(mem_ctx) ir_if(operand(r1BDF).val);
                     exec_list *const f1BDD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1BDD->then_instructions;

                        body.emit(assign(r1BD4, add(r1BD4, body.constant(int(4))), 0x01));

                        body.emit(assign(r1BD2, lshift(r1BD2, body.constant(int(4))), 0x01));


                     body.instructions = f1BDD_parent_instructions;
                     body.emit(f1BDD);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1BE1 = bit_and(r1BD2, body.constant(3221225472u));
                     ir_expression *const r1BE2 = equal(r1BE1, body.constant(0u));
                     ir_if *f1BE0 = new(mem_ctx) ir_if(operand(r1BE2).val);
                     exec_list *const f1BE0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1BE0->then_instructions;

                        body.emit(assign(r1BD4, add(r1BD4, body.constant(int(2))), 0x01));

                        body.emit(assign(r1BD2, lshift(r1BD2, body.constant(int(2))), 0x01));


                     body.instructions = f1BE0_parent_instructions;
                     body.emit(f1BE0);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1BE4 = bit_and(r1BD2, body.constant(2147483648u));
                     ir_expression *const r1BE5 = equal(r1BE4, body.constant(0u));
                     ir_if *f1BE3 = new(mem_ctx) ir_if(operand(r1BE5).val);
                     exec_list *const f1BE3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1BE3->then_instructions;

                        body.emit(assign(r1BD4, add(r1BD4, body.constant(int(1))), 0x01));


                     body.instructions = f1BE3_parent_instructions;
                     body.emit(f1BE3);

                     /* END IF */

                     body.emit(assign(r1BD3, r1BD4, 0x01));


                  body.instructions = f1BD5_parent_instructions;
                  body.emit(f1BD5);

                  /* END IF */

                  body.emit(assign(r1BCF, add(r1BD3, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1BE7 = less(r1BCF, body.constant(int(0)));
                  ir_if *f1BE6 = new(mem_ctx) ir_if(operand(r1BE7).val);
                  exec_list *const f1BE6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1BE6->then_instructions;

                     ir_expression *const r1BE8 = neg(r1BCF);
                     body.emit(assign(r1BCD, rshift(swizzle_x(r1B84), r1BE8), 0x01));

                     ir_expression *const r1BE9 = bit_and(r1BCF, body.constant(int(31)));
                     body.emit(assign(r1BCE, lshift(swizzle_x(r1B84), r1BE9), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1BE6->else_instructions;

                     body.emit(assign(r1BCD, lshift(swizzle_x(r1B84), r1BCF), 0x01));

                     body.emit(assign(r1BCE, body.constant(0u), 0x01));


                  body.instructions = f1BE6_parent_instructions;
                  body.emit(f1BE6);

                  /* END IF */

                  body.emit(assign(r1BCC, sub(body.constant(int(-31)), r1BCF), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1BD0->else_instructions;

                  ir_variable *const r1BEA = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r1BEA, r1BCA, 0x01));

                  ir_variable *const r1BEB = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r1BEC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r1BEC);
                  /* IF CONDITION */
                  ir_expression *const r1BEE = equal(swizzle_y(r1B94), body.constant(0u));
                  ir_if *f1BED = new(mem_ctx) ir_if(operand(r1BEE).val);
                  exec_list *const f1BED_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1BED->then_instructions;

                     body.emit(assign(r1BEB, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1BED->else_instructions;

                     body.emit(assign(r1BEC, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1BF0 = bit_and(swizzle_y(r1B94), body.constant(4294901760u));
                     ir_expression *const r1BF1 = equal(r1BF0, body.constant(0u));
                     ir_if *f1BEF = new(mem_ctx) ir_if(operand(r1BF1).val);
                     exec_list *const f1BEF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1BEF->then_instructions;

                        body.emit(assign(r1BEC, body.constant(int(16)), 0x01));

                        body.emit(assign(r1BEA, lshift(swizzle_y(r1B94), body.constant(int(16))), 0x01));


                     body.instructions = f1BEF_parent_instructions;
                     body.emit(f1BEF);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1BF3 = bit_and(r1BEA, body.constant(4278190080u));
                     ir_expression *const r1BF4 = equal(r1BF3, body.constant(0u));
                     ir_if *f1BF2 = new(mem_ctx) ir_if(operand(r1BF4).val);
                     exec_list *const f1BF2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1BF2->then_instructions;

                        body.emit(assign(r1BEC, add(r1BEC, body.constant(int(8))), 0x01));

                        body.emit(assign(r1BEA, lshift(r1BEA, body.constant(int(8))), 0x01));


                     body.instructions = f1BF2_parent_instructions;
                     body.emit(f1BF2);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1BF6 = bit_and(r1BEA, body.constant(4026531840u));
                     ir_expression *const r1BF7 = equal(r1BF6, body.constant(0u));
                     ir_if *f1BF5 = new(mem_ctx) ir_if(operand(r1BF7).val);
                     exec_list *const f1BF5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1BF5->then_instructions;

                        body.emit(assign(r1BEC, add(r1BEC, body.constant(int(4))), 0x01));

                        body.emit(assign(r1BEA, lshift(r1BEA, body.constant(int(4))), 0x01));


                     body.instructions = f1BF5_parent_instructions;
                     body.emit(f1BF5);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1BF9 = bit_and(r1BEA, body.constant(3221225472u));
                     ir_expression *const r1BFA = equal(r1BF9, body.constant(0u));
                     ir_if *f1BF8 = new(mem_ctx) ir_if(operand(r1BFA).val);
                     exec_list *const f1BF8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1BF8->then_instructions;

                        body.emit(assign(r1BEC, add(r1BEC, body.constant(int(2))), 0x01));

                        body.emit(assign(r1BEA, lshift(r1BEA, body.constant(int(2))), 0x01));


                     body.instructions = f1BF8_parent_instructions;
                     body.emit(f1BF8);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1BFC = bit_and(r1BEA, body.constant(2147483648u));
                     ir_expression *const r1BFD = equal(r1BFC, body.constant(0u));
                     ir_if *f1BFB = new(mem_ctx) ir_if(operand(r1BFD).val);
                     exec_list *const f1BFB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1BFB->then_instructions;

                        body.emit(assign(r1BEC, add(r1BEC, body.constant(int(1))), 0x01));


                     body.instructions = f1BFB_parent_instructions;
                     body.emit(f1BFB);

                     /* END IF */

                     body.emit(assign(r1BEB, r1BEC, 0x01));


                  body.instructions = f1BED_parent_instructions;
                  body.emit(f1BED);

                  /* END IF */

                  body.emit(assign(r1BCF, add(r1BEB, body.constant(int(-11))), 0x01));

                  ir_variable *const r1BFE = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r1BFE, lshift(swizzle_x(r1B84), r1BCF), 0x01));

                  ir_variable *const r1BFF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1C01 = equal(r1BCF, body.constant(int(0)));
                  ir_if *f1C00 = new(mem_ctx) ir_if(operand(r1C01).val);
                  exec_list *const f1C00_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1C00->then_instructions;

                     body.emit(assign(r1BFF, r1BCA, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1C00->else_instructions;

                     ir_expression *const r1C02 = lshift(swizzle_y(r1B94), r1BCF);
                     ir_expression *const r1C03 = neg(r1BCF);
                     ir_expression *const r1C04 = bit_and(r1C03, body.constant(int(31)));
                     ir_expression *const r1C05 = rshift(swizzle_x(r1B84), r1C04);
                     body.emit(assign(r1BFF, bit_or(r1C02, r1C05), 0x01));


                  body.instructions = f1C00_parent_instructions;
                  body.emit(f1C00);

                  /* END IF */

                  body.emit(assign(r1BCD, r1BFF, 0x01));

                  body.emit(assign(r1BCE, r1BFE, 0x01));

                  body.emit(assign(r1BCC, sub(body.constant(int(1)), r1BCF), 0x01));


               body.instructions = f1BD0_parent_instructions;
               body.emit(f1BD0);

               /* END IF */

               body.emit(assign(r1B88, r1BCC, 0x01));

               body.emit(assign(r1B89, r1BCD, 0x02));

               body.emit(assign(r1B89, r1BCE, 0x01));


            body.instructions = f1BC6_parent_instructions;
            body.emit(f1BC6);

            /* END IF */


         body.instructions = f1BC4_parent_instructions;
         body.emit(f1BC4);

         /* END IF */

         /* IF CONDITION */
         ir_if *f1C06 = new(mem_ctx) ir_if(operand(r1B85).val);
         exec_list *const f1C06_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1C06->then_instructions;

            ir_expression *const r1C07 = add(r1B88, body.constant(int(-1023)));
            ir_expression *const r1C08 = rshift(r1C07, body.constant(int(1)));
            body.emit(assign(r1B87, add(r1C08, body.constant(int(1022))), 0x01));

            body.emit(assign(r1B89, bit_or(swizzle_y(r1B89), body.constant(1048576u)), 0x02));

            ir_variable *const r1C09 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r1C09, lshift(swizzle_x(r1B89), body.constant(int(11))), 0x01));

            ir_variable *const r1C0A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
            ir_expression *const r1C0B = lshift(swizzle_y(r1B89), body.constant(int(11)));
            ir_expression *const r1C0C = rshift(swizzle_x(r1B89), body.constant(int(21)));
            body.emit(assign(r1C0A, bit_or(r1C0B, r1C0C), 0x01));

            ir_variable *const r1C0D = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r1C0D, r1C0A, 0x01));

            ir_variable *const r1C0E = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r1C0E, body.constant(true), 0x01));

            ir_variable *const r1C0F = body.make_temp(glsl_type::uint_type, "return_value");
            ir_variable *const r1C10 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
            body.emit(r1C10);
            ir_variable *const r1C11 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r1C12 = rshift(r1C0A, body.constant(int(27)));
            ir_expression *const r1C13 = bit_and(r1C12, body.constant(15u));
            body.emit(assign(r1C11, expr(ir_unop_u2i, r1C13), 0x01));

            /* IF CONDITION */
            ir_expression *const r1C15 = bit_and(r1B88, body.constant(int(1)));
            ir_expression *const r1C16 = nequal(r1C15, body.constant(int(0)));
            ir_if *f1C14 = new(mem_ctx) ir_if(operand(r1C16).val);
            exec_list *const f1C14_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1C14->then_instructions;

               ir_variable *const r1C17 = new(mem_ctx) ir_variable(glsl_type::uint_type, "res", ir_var_auto);
               body.emit(r1C17);
               body.emit(assign(r1C17, body.constant(0u), 0x01));

               /* IF CONDITION */
               ir_expression *const r1C19 = equal(r1C11, body.constant(int(0)));
               ir_if *f1C18 = new(mem_ctx) ir_if(operand(r1C19).val);
               exec_list *const f1C18_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C18->then_instructions;

                  body.emit(assign(r1C17, body.constant(4u), 0x01));


               body.instructions = f1C18_parent_instructions;
               body.emit(f1C18);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C1B = equal(r1C11, body.constant(int(1)));
               ir_if *f1C1A = new(mem_ctx) ir_if(operand(r1C1B).val);
               exec_list *const f1C1A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C1A->then_instructions;

                  body.emit(assign(r1C17, body.constant(34u), 0x01));


               body.instructions = f1C1A_parent_instructions;
               body.emit(f1C1A);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C1D = equal(r1C11, body.constant(int(2)));
               ir_if *f1C1C = new(mem_ctx) ir_if(operand(r1C1D).val);
               exec_list *const f1C1C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C1C->then_instructions;

                  body.emit(assign(r1C17, body.constant(93u), 0x01));


               body.instructions = f1C1C_parent_instructions;
               body.emit(f1C1C);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C1F = equal(r1C11, body.constant(int(3)));
               ir_if *f1C1E = new(mem_ctx) ir_if(operand(r1C1F).val);
               exec_list *const f1C1E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C1E->then_instructions;

                  body.emit(assign(r1C17, body.constant(177u), 0x01));


               body.instructions = f1C1E_parent_instructions;
               body.emit(f1C1E);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C21 = equal(r1C11, body.constant(int(4)));
               ir_if *f1C20 = new(mem_ctx) ir_if(operand(r1C21).val);
               exec_list *const f1C20_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C20->then_instructions;

                  body.emit(assign(r1C17, body.constant(285u), 0x01));


               body.instructions = f1C20_parent_instructions;
               body.emit(f1C20);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C23 = equal(r1C11, body.constant(int(5)));
               ir_if *f1C22 = new(mem_ctx) ir_if(operand(r1C23).val);
               exec_list *const f1C22_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C22->then_instructions;

                  body.emit(assign(r1C17, body.constant(415u), 0x01));


               body.instructions = f1C22_parent_instructions;
               body.emit(f1C22);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C25 = equal(r1C11, body.constant(int(6)));
               ir_if *f1C24 = new(mem_ctx) ir_if(operand(r1C25).val);
               exec_list *const f1C24_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C24->then_instructions;

                  body.emit(assign(r1C17, body.constant(566u), 0x01));


               body.instructions = f1C24_parent_instructions;
               body.emit(f1C24);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C27 = equal(r1C11, body.constant(int(7)));
               ir_if *f1C26 = new(mem_ctx) ir_if(operand(r1C27).val);
               exec_list *const f1C26_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C26->then_instructions;

                  body.emit(assign(r1C17, body.constant(736u), 0x01));


               body.instructions = f1C26_parent_instructions;
               body.emit(f1C26);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C29 = equal(r1C11, body.constant(int(8)));
               ir_if *f1C28 = new(mem_ctx) ir_if(operand(r1C29).val);
               exec_list *const f1C28_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C28->then_instructions;

                  body.emit(assign(r1C17, body.constant(924u), 0x01));


               body.instructions = f1C28_parent_instructions;
               body.emit(f1C28);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C2B = equal(r1C11, body.constant(int(9)));
               ir_if *f1C2A = new(mem_ctx) ir_if(operand(r1C2B).val);
               exec_list *const f1C2A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C2A->then_instructions;

                  body.emit(assign(r1C17, body.constant(1128u), 0x01));


               body.instructions = f1C2A_parent_instructions;
               body.emit(f1C2A);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C2D = equal(r1C11, body.constant(int(10)));
               ir_if *f1C2C = new(mem_ctx) ir_if(operand(r1C2D).val);
               exec_list *const f1C2C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C2C->then_instructions;

                  body.emit(assign(r1C17, body.constant(1349u), 0x01));


               body.instructions = f1C2C_parent_instructions;
               body.emit(f1C2C);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C2F = equal(r1C11, body.constant(int(11)));
               ir_if *f1C2E = new(mem_ctx) ir_if(operand(r1C2F).val);
               exec_list *const f1C2E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C2E->then_instructions;

                  body.emit(assign(r1C17, body.constant(1585u), 0x01));


               body.instructions = f1C2E_parent_instructions;
               body.emit(f1C2E);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C31 = equal(r1C11, body.constant(int(12)));
               ir_if *f1C30 = new(mem_ctx) ir_if(operand(r1C31).val);
               exec_list *const f1C30_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C30->then_instructions;

                  body.emit(assign(r1C17, body.constant(1835u), 0x01));


               body.instructions = f1C30_parent_instructions;
               body.emit(f1C30);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C33 = equal(r1C11, body.constant(int(13)));
               ir_if *f1C32 = new(mem_ctx) ir_if(operand(r1C33).val);
               exec_list *const f1C32_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C32->then_instructions;

                  body.emit(assign(r1C17, body.constant(2098u), 0x01));


               body.instructions = f1C32_parent_instructions;
               body.emit(f1C32);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C35 = equal(r1C11, body.constant(int(14)));
               ir_if *f1C34 = new(mem_ctx) ir_if(operand(r1C35).val);
               exec_list *const f1C34_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C34->then_instructions;

                  body.emit(assign(r1C17, body.constant(2374u), 0x01));


               body.instructions = f1C34_parent_instructions;
               body.emit(f1C34);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C37 = equal(r1C11, body.constant(int(15)));
               ir_if *f1C36 = new(mem_ctx) ir_if(operand(r1C37).val);
               exec_list *const f1C36_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C36->then_instructions;

                  body.emit(assign(r1C17, body.constant(2663u), 0x01));


               body.instructions = f1C36_parent_instructions;
               body.emit(f1C36);

               /* END IF */

               ir_expression *const r1C38 = rshift(r1C0A, body.constant(int(17)));
               ir_expression *const r1C39 = add(body.constant(16384u), r1C38);
               body.emit(assign(r1C10, sub(r1C39, r1C17), 0x01));

               ir_expression *const r1C3A = expr(ir_binop_div, r1C0A, r1C10);
               ir_expression *const r1C3B = lshift(r1C3A, body.constant(int(14)));
               ir_expression *const r1C3C = lshift(r1C10, body.constant(int(15)));
               body.emit(assign(r1C10, add(r1C3B, r1C3C), 0x01));

               body.emit(assign(r1C0D, rshift(r1C0A, body.constant(int(1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1C14->else_instructions;

               ir_variable *const r1C3D = new(mem_ctx) ir_variable(glsl_type::uint_type, "res", ir_var_auto);
               body.emit(r1C3D);
               body.emit(assign(r1C3D, body.constant(0u), 0x01));

               /* IF CONDITION */
               ir_expression *const r1C3F = equal(r1C11, body.constant(int(0)));
               ir_if *f1C3E = new(mem_ctx) ir_if(operand(r1C3F).val);
               exec_list *const f1C3E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C3E->then_instructions;

                  body.emit(assign(r1C3D, body.constant(2605u), 0x01));


               body.instructions = f1C3E_parent_instructions;
               body.emit(f1C3E);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C41 = equal(r1C11, body.constant(int(1)));
               ir_if *f1C40 = new(mem_ctx) ir_if(operand(r1C41).val);
               exec_list *const f1C40_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C40->then_instructions;

                  body.emit(assign(r1C3D, body.constant(2223u), 0x01));


               body.instructions = f1C40_parent_instructions;
               body.emit(f1C40);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C43 = equal(r1C11, body.constant(int(2)));
               ir_if *f1C42 = new(mem_ctx) ir_if(operand(r1C43).val);
               exec_list *const f1C42_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C42->then_instructions;

                  body.emit(assign(r1C3D, body.constant(1882u), 0x01));


               body.instructions = f1C42_parent_instructions;
               body.emit(f1C42);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C45 = equal(r1C11, body.constant(int(3)));
               ir_if *f1C44 = new(mem_ctx) ir_if(operand(r1C45).val);
               exec_list *const f1C44_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C44->then_instructions;

                  body.emit(assign(r1C3D, body.constant(1577u), 0x01));


               body.instructions = f1C44_parent_instructions;
               body.emit(f1C44);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C47 = equal(r1C11, body.constant(int(4)));
               ir_if *f1C46 = new(mem_ctx) ir_if(operand(r1C47).val);
               exec_list *const f1C46_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C46->then_instructions;

                  body.emit(assign(r1C3D, body.constant(1306u), 0x01));


               body.instructions = f1C46_parent_instructions;
               body.emit(f1C46);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C49 = equal(r1C11, body.constant(int(5)));
               ir_if *f1C48 = new(mem_ctx) ir_if(operand(r1C49).val);
               exec_list *const f1C48_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C48->then_instructions;

                  body.emit(assign(r1C3D, body.constant(1065u), 0x01));


               body.instructions = f1C48_parent_instructions;
               body.emit(f1C48);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C4B = equal(r1C11, body.constant(int(6)));
               ir_if *f1C4A = new(mem_ctx) ir_if(operand(r1C4B).val);
               exec_list *const f1C4A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C4A->then_instructions;

                  body.emit(assign(r1C3D, body.constant(854u), 0x01));


               body.instructions = f1C4A_parent_instructions;
               body.emit(f1C4A);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C4D = equal(r1C11, body.constant(int(7)));
               ir_if *f1C4C = new(mem_ctx) ir_if(operand(r1C4D).val);
               exec_list *const f1C4C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C4C->then_instructions;

                  body.emit(assign(r1C3D, body.constant(670u), 0x01));


               body.instructions = f1C4C_parent_instructions;
               body.emit(f1C4C);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C4F = equal(r1C11, body.constant(int(8)));
               ir_if *f1C4E = new(mem_ctx) ir_if(operand(r1C4F).val);
               exec_list *const f1C4E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C4E->then_instructions;

                  body.emit(assign(r1C3D, body.constant(512u), 0x01));


               body.instructions = f1C4E_parent_instructions;
               body.emit(f1C4E);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C51 = equal(r1C11, body.constant(int(9)));
               ir_if *f1C50 = new(mem_ctx) ir_if(operand(r1C51).val);
               exec_list *const f1C50_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C50->then_instructions;

                  body.emit(assign(r1C3D, body.constant(377u), 0x01));


               body.instructions = f1C50_parent_instructions;
               body.emit(f1C50);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C53 = equal(r1C11, body.constant(int(10)));
               ir_if *f1C52 = new(mem_ctx) ir_if(operand(r1C53).val);
               exec_list *const f1C52_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C52->then_instructions;

                  body.emit(assign(r1C3D, body.constant(265u), 0x01));


               body.instructions = f1C52_parent_instructions;
               body.emit(f1C52);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C55 = equal(r1C11, body.constant(int(11)));
               ir_if *f1C54 = new(mem_ctx) ir_if(operand(r1C55).val);
               exec_list *const f1C54_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C54->then_instructions;

                  body.emit(assign(r1C3D, body.constant(175u), 0x01));


               body.instructions = f1C54_parent_instructions;
               body.emit(f1C54);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C57 = equal(r1C11, body.constant(int(12)));
               ir_if *f1C56 = new(mem_ctx) ir_if(operand(r1C57).val);
               exec_list *const f1C56_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C56->then_instructions;

                  body.emit(assign(r1C3D, body.constant(104u), 0x01));


               body.instructions = f1C56_parent_instructions;
               body.emit(f1C56);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C59 = equal(r1C11, body.constant(int(13)));
               ir_if *f1C58 = new(mem_ctx) ir_if(operand(r1C59).val);
               exec_list *const f1C58_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C58->then_instructions;

                  body.emit(assign(r1C3D, body.constant(52u), 0x01));


               body.instructions = f1C58_parent_instructions;
               body.emit(f1C58);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C5B = equal(r1C11, body.constant(int(14)));
               ir_if *f1C5A = new(mem_ctx) ir_if(operand(r1C5B).val);
               exec_list *const f1C5A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C5A->then_instructions;

                  body.emit(assign(r1C3D, body.constant(18u), 0x01));


               body.instructions = f1C5A_parent_instructions;
               body.emit(f1C5A);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1C5D = equal(r1C11, body.constant(int(15)));
               ir_if *f1C5C = new(mem_ctx) ir_if(operand(r1C5D).val);
               exec_list *const f1C5C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C5C->then_instructions;

                  body.emit(assign(r1C3D, body.constant(2u), 0x01));


               body.instructions = f1C5C_parent_instructions;
               body.emit(f1C5C);

               /* END IF */

               ir_expression *const r1C5E = rshift(r1C0D, body.constant(int(17)));
               ir_expression *const r1C5F = add(body.constant(32768u), r1C5E);
               body.emit(assign(r1C10, sub(r1C5F, r1C3D), 0x01));

               ir_expression *const r1C60 = expr(ir_binop_div, r1C0D, r1C10);
               body.emit(assign(r1C10, add(r1C60, r1C10), 0x01));

               ir_variable *const r1C61 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r1C63 = lequal(body.constant(131072u), r1C10);
               ir_if *f1C62 = new(mem_ctx) ir_if(operand(r1C63).val);
               exec_list *const f1C62_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C62->then_instructions;

                  body.emit(assign(r1C61, body.constant(4294934528u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1C62->else_instructions;

                  body.emit(assign(r1C61, lshift(r1C10, body.constant(int(15))), 0x01));


               body.instructions = f1C62_parent_instructions;
               body.emit(f1C62);

               /* END IF */

               body.emit(assign(r1C10, r1C61, 0x01));

               /* IF CONDITION */
               ir_expression *const r1C65 = lequal(r1C61, r1C0D);
               ir_if *f1C64 = new(mem_ctx) ir_if(operand(r1C65).val);
               exec_list *const f1C64_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C64->then_instructions;

                  ir_expression *const r1C66 = expr(ir_unop_u2i, r1C0D);
                  ir_expression *const r1C67 = rshift(r1C66, body.constant(int(1)));
                  body.emit(assign(r1C0F, expr(ir_unop_i2u, r1C67), 0x01));

                  body.emit(assign(r1C0E, body.constant(false), 0x01));


               body.instructions = f1C64_parent_instructions;
               body.emit(f1C64);

               /* END IF */


            body.instructions = f1C14_parent_instructions;
            body.emit(f1C14);

            /* END IF */

            /* IF CONDITION */
            ir_if *f1C68 = new(mem_ctx) ir_if(operand(r1C0E).val);
            exec_list *const f1C68_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1C68->then_instructions;

               ir_variable *const r1C69 = body.make_temp(glsl_type::uint_type, "return_value");
               ir_variable *const r1C6A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r1C6A);
               ir_variable *const r1C6B = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
               body.emit(r1C6B);
               ir_variable *const r1C6C = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
               body.emit(r1C6C);
               ir_variable *const r1C6D = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
               body.emit(r1C6D);
               body.emit(assign(r1C6C, body.constant(0u), 0x01));

               body.emit(assign(r1C6B, body.constant(0u), 0x01));

               /* IF CONDITION */
               ir_expression *const r1C6F = lequal(r1C10, r1C0D);
               ir_if *f1C6E = new(mem_ctx) ir_if(operand(r1C6F).val);
               exec_list *const f1C6E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1C6E->then_instructions;

                  body.emit(assign(r1C69, body.constant(4294967295u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1C6E->else_instructions;

                  body.emit(assign(r1C6D, rshift(r1C10, body.constant(int(16))), 0x01));

                  ir_variable *const r1C70 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1C72 = lshift(r1C6D, body.constant(int(16)));
                  ir_expression *const r1C73 = lequal(r1C72, r1C0D);
                  ir_if *f1C71 = new(mem_ctx) ir_if(operand(r1C73).val);
                  exec_list *const f1C71_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1C71->then_instructions;

                     body.emit(assign(r1C70, body.constant(4294901760u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1C71->else_instructions;

                     ir_expression *const r1C74 = expr(ir_binop_div, r1C0D, r1C6D);
                     body.emit(assign(r1C70, lshift(r1C74, body.constant(int(16))), 0x01));


                  body.instructions = f1C71_parent_instructions;
                  body.emit(f1C71);

                  /* END IF */

                  body.emit(assign(r1C6A, r1C70, 0x01));

                  ir_variable *const r1C75 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1C75);
                  ir_variable *const r1C76 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r1C76);
                  ir_variable *const r1C77 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1C77);
                  ir_variable *const r1C78 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1C78, bit_and(r1C10, body.constant(65535u)), 0x01));

                  ir_variable *const r1C79 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1C79, rshift(r1C10, body.constant(int(16))), 0x01));

                  ir_variable *const r1C7A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1C7A, bit_and(r1C70, body.constant(65535u)), 0x01));

                  ir_variable *const r1C7B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1C7B, rshift(r1C70, body.constant(int(16))), 0x01));

                  ir_variable *const r1C7C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1C7C, mul(r1C79, r1C7A), 0x01));

                  ir_expression *const r1C7D = mul(r1C78, r1C7B);
                  body.emit(assign(r1C76, add(r1C7D, r1C7C), 0x01));

                  ir_expression *const r1C7E = mul(r1C79, r1C7B);
                  ir_expression *const r1C7F = less(r1C76, r1C7C);
                  ir_expression *const r1C80 = expr(ir_unop_b2i, r1C7F);
                  ir_expression *const r1C81 = expr(ir_unop_i2u, r1C80);
                  ir_expression *const r1C82 = lshift(r1C81, body.constant(int(16)));
                  ir_expression *const r1C83 = rshift(r1C76, body.constant(int(16)));
                  ir_expression *const r1C84 = add(r1C82, r1C83);
                  body.emit(assign(r1C75, add(r1C7E, r1C84), 0x01));

                  body.emit(assign(r1C76, lshift(r1C76, body.constant(int(16))), 0x01));

                  ir_expression *const r1C85 = mul(r1C78, r1C7A);
                  body.emit(assign(r1C77, add(r1C85, r1C76), 0x01));

                  ir_expression *const r1C86 = less(r1C77, r1C76);
                  ir_expression *const r1C87 = expr(ir_unop_b2i, r1C86);
                  ir_expression *const r1C88 = expr(ir_unop_i2u, r1C87);
                  body.emit(assign(r1C75, add(r1C75, r1C88), 0x01));

                  ir_expression *const r1C89 = sub(r1C0D, r1C75);
                  ir_expression *const r1C8A = less(body.constant(0u), r1C77);
                  ir_expression *const r1C8B = expr(ir_unop_b2i, r1C8A);
                  ir_expression *const r1C8C = expr(ir_unop_i2u, r1C8B);
                  body.emit(assign(r1C6C, sub(r1C89, r1C8C), 0x01));

                  body.emit(assign(r1C6B, neg(r1C77), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f1C8D = new(mem_ctx) ir_loop();
                  exec_list *const f1C8D_parent_instructions = body.instructions;

                     body.instructions = &f1C8D->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1C8F = expr(ir_unop_u2i, r1C6C);
                     ir_expression *const r1C90 = gequal(r1C8F, body.constant(int(0)));
                     ir_if *f1C8E = new(mem_ctx) ir_if(operand(r1C90).val);
                     exec_list *const f1C8E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1C8E->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f1C8E_parent_instructions;
                     body.emit(f1C8E);

                     /* END IF */

                     body.emit(assign(r1C6A, add(r1C6A, body.constant(4294901760u)), 0x01));

                     ir_variable *const r1C91 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r1C92 = lshift(r1C10, body.constant(int(16)));
                     body.emit(assign(r1C91, add(r1C6B, r1C92), 0x01));

                     ir_expression *const r1C93 = add(r1C6C, r1C6D);
                     ir_expression *const r1C94 = less(r1C91, r1C6B);
                     ir_expression *const r1C95 = expr(ir_unop_b2i, r1C94);
                     ir_expression *const r1C96 = expr(ir_unop_i2u, r1C95);
                     body.emit(assign(r1C6C, add(r1C93, r1C96), 0x01));

                     body.emit(assign(r1C6B, r1C91, 0x01));

                  /* LOOP END */

                  body.instructions = f1C8D_parent_instructions;
                  body.emit(f1C8D);

                  ir_expression *const r1C97 = lshift(r1C6C, body.constant(int(16)));
                  ir_expression *const r1C98 = rshift(r1C6B, body.constant(int(16)));
                  body.emit(assign(r1C6C, bit_or(r1C97, r1C98), 0x01));

                  ir_variable *const r1C99 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1C9B = lshift(r1C6D, body.constant(int(16)));
                  ir_expression *const r1C9C = lequal(r1C9B, r1C6C);
                  ir_if *f1C9A = new(mem_ctx) ir_if(operand(r1C9C).val);
                  exec_list *const f1C9A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1C9A->then_instructions;

                     body.emit(assign(r1C99, body.constant(65535u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1C9A->else_instructions;

                     body.emit(assign(r1C99, expr(ir_binop_div, r1C6C, r1C6D), 0x01));


                  body.instructions = f1C9A_parent_instructions;
                  body.emit(f1C9A);

                  /* END IF */

                  body.emit(assign(r1C6A, bit_or(r1C6A, r1C99), 0x01));

                  body.emit(assign(r1C69, r1C6A, 0x01));


               body.instructions = f1C6E_parent_instructions;
               body.emit(f1C6E);

               /* END IF */

               ir_expression *const r1C9D = rshift(r1C69, body.constant(int(1)));
               ir_expression *const r1C9E = rshift(r1C10, body.constant(int(1)));
               body.emit(assign(r1C0F, add(r1C9D, r1C9E), 0x01));

               body.emit(assign(r1C0E, body.constant(false), 0x01));


            body.instructions = f1C68_parent_instructions;
            body.emit(f1C68);

            /* END IF */

            ir_expression *const r1C9F = rshift(r1C0F, body.constant(int(1)));
            body.emit(assign(r1B93, add(r1C9F, body.constant(1u)), 0x01));

            /* IF CONDITION */
            ir_expression *const r1CA1 = equal(r1B93, body.constant(0u));
            ir_if *f1CA0 = new(mem_ctx) ir_if(operand(r1CA1).val);
            exec_list *const f1CA0_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1CA0->then_instructions;

               body.emit(assign(r1B93, body.constant(2147483647u), 0x01));


            body.instructions = f1CA0_parent_instructions;
            body.emit(f1CA0);

            /* END IF */

            body.emit(assign(r1B91, add(r1B93, r1B93), 0x01));

            ir_variable *const r1CA2 = body.make_temp(glsl_type::uint_type, "a0");
            body.emit(assign(r1CA2, swizzle_y(r1B89), 0x01));

            ir_variable *const r1CA3 = body.make_temp(glsl_type::int_type, "count");
            ir_expression *const r1CA4 = bit_and(r1B88, body.constant(int(1)));
            body.emit(assign(r1CA3, sub(body.constant(int(9)), r1CA4), 0x01));

            ir_variable *const r1CA5 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r1CA5, lshift(swizzle_x(r1B89), r1CA3), 0x01));

            ir_variable *const r1CA6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r1CA8 = equal(r1CA3, body.constant(int(0)));
            ir_if *f1CA7 = new(mem_ctx) ir_if(operand(r1CA8).val);
            exec_list *const f1CA7_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1CA7->then_instructions;

               body.emit(assign(r1CA6, r1CA2, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1CA7->else_instructions;

               ir_expression *const r1CA9 = lshift(swizzle_y(r1B89), r1CA3);
               ir_expression *const r1CAA = neg(r1CA3);
               ir_expression *const r1CAB = bit_and(r1CAA, body.constant(int(31)));
               ir_expression *const r1CAC = rshift(swizzle_x(r1B89), r1CAB);
               body.emit(assign(r1CA6, bit_or(r1CA9, r1CAC), 0x01));


            body.instructions = f1CA7_parent_instructions;
            body.emit(f1CA7);

            /* END IF */

            body.emit(assign(r1B89, r1CA6, 0x02));

            body.emit(assign(r1B89, r1CA5, 0x01));

            ir_variable *const r1CAD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r1CAD);
            ir_variable *const r1CAE = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
            body.emit(r1CAE);
            ir_variable *const r1CAF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r1CAF);
            ir_variable *const r1CB0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r1CB0, bit_and(r1B93, body.constant(65535u)), 0x01));

            ir_variable *const r1CB1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r1CB1, rshift(r1B93, body.constant(int(16))), 0x01));

            ir_variable *const r1CB2 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r1CB2, bit_and(r1B93, body.constant(65535u)), 0x01));

            ir_variable *const r1CB3 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r1CB3, rshift(r1B93, body.constant(int(16))), 0x01));

            ir_variable *const r1CB4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r1CB4, mul(r1CB1, r1CB2), 0x01));

            ir_expression *const r1CB5 = mul(r1CB0, r1CB3);
            body.emit(assign(r1CAE, add(r1CB5, r1CB4), 0x01));

            ir_expression *const r1CB6 = mul(r1CB1, r1CB3);
            ir_expression *const r1CB7 = less(r1CAE, r1CB4);
            ir_expression *const r1CB8 = expr(ir_unop_b2i, r1CB7);
            ir_expression *const r1CB9 = expr(ir_unop_i2u, r1CB8);
            ir_expression *const r1CBA = lshift(r1CB9, body.constant(int(16)));
            ir_expression *const r1CBB = rshift(r1CAE, body.constant(int(16)));
            ir_expression *const r1CBC = add(r1CBA, r1CBB);
            body.emit(assign(r1CAD, add(r1CB6, r1CBC), 0x01));

            body.emit(assign(r1CAE, lshift(r1CAE, body.constant(int(16))), 0x01));

            ir_expression *const r1CBD = mul(r1CB0, r1CB2);
            body.emit(assign(r1CAF, add(r1CBD, r1CAE), 0x01));

            ir_expression *const r1CBE = less(r1CAF, r1CAE);
            ir_expression *const r1CBF = expr(ir_unop_b2i, r1CBE);
            ir_expression *const r1CC0 = expr(ir_unop_i2u, r1CBF);
            body.emit(assign(r1CAD, add(r1CAD, r1CC0), 0x01));

            ir_expression *const r1CC1 = sub(r1CA6, r1CAD);
            ir_expression *const r1CC2 = less(r1CA5, r1CAF);
            ir_expression *const r1CC3 = expr(ir_unop_b2i, r1CC2);
            ir_expression *const r1CC4 = expr(ir_unop_i2u, r1CC3);
            body.emit(assign(r1B90, sub(r1CC1, r1CC4), 0x01));

            body.emit(assign(r1B8F, sub(r1CA5, r1CAF), 0x01));

            /* LOOP BEGIN */
            ir_loop *f1CC5 = new(mem_ctx) ir_loop();
            exec_list *const f1CC5_parent_instructions = body.instructions;

               body.instructions = &f1CC5->body_instructions;

               /* IF CONDITION */
               ir_expression *const r1CC7 = expr(ir_unop_u2i, r1B90);
               ir_expression *const r1CC8 = gequal(r1CC7, body.constant(int(0)));
               ir_if *f1CC6 = new(mem_ctx) ir_if(operand(r1CC8).val);
               exec_list *const f1CC6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1CC6->then_instructions;

                  body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


               body.instructions = f1CC6_parent_instructions;
               body.emit(f1CC6);

               /* END IF */

               body.emit(assign(r1B93, add(r1B93, body.constant(4294967295u)), 0x01));

               body.emit(assign(r1B91, add(r1B91, body.constant(4294967294u)), 0x01));

               ir_variable *const r1CC9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r1CCA = bit_or(r1B91, body.constant(1u));
               body.emit(assign(r1CC9, add(r1B8F, r1CCA), 0x01));

               ir_expression *const r1CCB = less(r1CC9, r1B8F);
               ir_expression *const r1CCC = expr(ir_unop_b2i, r1CCB);
               ir_expression *const r1CCD = expr(ir_unop_i2u, r1CCC);
               body.emit(assign(r1B90, add(r1B90, r1CCD), 0x01));

               body.emit(assign(r1B8F, r1CC9, 0x01));

            /* LOOP END */

            body.instructions = f1CC5_parent_instructions;
            body.emit(f1CC5);

            ir_variable *const r1CCE = body.make_temp(glsl_type::uint_type, "return_value");
            ir_variable *const r1CCF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
            body.emit(r1CCF);
            ir_variable *const r1CD0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
            body.emit(r1CD0);
            ir_variable *const r1CD1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
            body.emit(r1CD1);
            ir_variable *const r1CD2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
            body.emit(r1CD2);
            body.emit(assign(r1CD1, body.constant(0u), 0x01));

            body.emit(assign(r1CD0, body.constant(0u), 0x01));

            /* IF CONDITION */
            ir_expression *const r1CD4 = lequal(r1B91, r1B8F);
            ir_if *f1CD3 = new(mem_ctx) ir_if(operand(r1CD4).val);
            exec_list *const f1CD3_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1CD3->then_instructions;

               body.emit(assign(r1CCE, body.constant(4294967295u), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1CD3->else_instructions;

               body.emit(assign(r1CD2, rshift(r1B91, body.constant(int(16))), 0x01));

               ir_variable *const r1CD5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r1CD7 = lshift(r1CD2, body.constant(int(16)));
               ir_expression *const r1CD8 = lequal(r1CD7, r1B8F);
               ir_if *f1CD6 = new(mem_ctx) ir_if(operand(r1CD8).val);
               exec_list *const f1CD6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1CD6->then_instructions;

                  body.emit(assign(r1CD5, body.constant(4294901760u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1CD6->else_instructions;

                  ir_expression *const r1CD9 = expr(ir_binop_div, r1B8F, r1CD2);
                  body.emit(assign(r1CD5, lshift(r1CD9, body.constant(int(16))), 0x01));


               body.instructions = f1CD6_parent_instructions;
               body.emit(f1CD6);

               /* END IF */

               body.emit(assign(r1CCF, r1CD5, 0x01));

               ir_variable *const r1CDA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1CDA);
               ir_variable *const r1CDB = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r1CDB);
               ir_variable *const r1CDC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1CDC);
               ir_variable *const r1CDD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1CDD, bit_and(r1B91, body.constant(65535u)), 0x01));

               ir_variable *const r1CDE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1CDE, rshift(r1B91, body.constant(int(16))), 0x01));

               ir_variable *const r1CDF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1CDF, bit_and(r1CD5, body.constant(65535u)), 0x01));

               ir_variable *const r1CE0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1CE0, rshift(r1CD5, body.constant(int(16))), 0x01));

               ir_variable *const r1CE1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1CE1, mul(r1CDE, r1CDF), 0x01));

               ir_expression *const r1CE2 = mul(r1CDD, r1CE0);
               body.emit(assign(r1CDB, add(r1CE2, r1CE1), 0x01));

               ir_expression *const r1CE3 = mul(r1CDE, r1CE0);
               ir_expression *const r1CE4 = less(r1CDB, r1CE1);
               ir_expression *const r1CE5 = expr(ir_unop_b2i, r1CE4);
               ir_expression *const r1CE6 = expr(ir_unop_i2u, r1CE5);
               ir_expression *const r1CE7 = lshift(r1CE6, body.constant(int(16)));
               ir_expression *const r1CE8 = rshift(r1CDB, body.constant(int(16)));
               ir_expression *const r1CE9 = add(r1CE7, r1CE8);
               body.emit(assign(r1CDA, add(r1CE3, r1CE9), 0x01));

               body.emit(assign(r1CDB, lshift(r1CDB, body.constant(int(16))), 0x01));

               ir_expression *const r1CEA = mul(r1CDD, r1CDF);
               body.emit(assign(r1CDC, add(r1CEA, r1CDB), 0x01));

               ir_expression *const r1CEB = less(r1CDC, r1CDB);
               ir_expression *const r1CEC = expr(ir_unop_b2i, r1CEB);
               ir_expression *const r1CED = expr(ir_unop_i2u, r1CEC);
               body.emit(assign(r1CDA, add(r1CDA, r1CED), 0x01));

               ir_expression *const r1CEE = sub(r1B8F, r1CDA);
               ir_expression *const r1CEF = less(body.constant(0u), r1CDC);
               ir_expression *const r1CF0 = expr(ir_unop_b2i, r1CEF);
               ir_expression *const r1CF1 = expr(ir_unop_i2u, r1CF0);
               body.emit(assign(r1CD1, sub(r1CEE, r1CF1), 0x01));

               body.emit(assign(r1CD0, neg(r1CDC), 0x01));

               /* LOOP BEGIN */
               ir_loop *f1CF2 = new(mem_ctx) ir_loop();
               exec_list *const f1CF2_parent_instructions = body.instructions;

                  body.instructions = &f1CF2->body_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1CF4 = expr(ir_unop_u2i, r1CD1);
                  ir_expression *const r1CF5 = gequal(r1CF4, body.constant(int(0)));
                  ir_if *f1CF3 = new(mem_ctx) ir_if(operand(r1CF5).val);
                  exec_list *const f1CF3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1CF3->then_instructions;

                     body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                  body.instructions = f1CF3_parent_instructions;
                  body.emit(f1CF3);

                  /* END IF */

                  body.emit(assign(r1CCF, add(r1CCF, body.constant(4294901760u)), 0x01));

                  ir_variable *const r1CF6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  ir_expression *const r1CF7 = lshift(r1B91, body.constant(int(16)));
                  body.emit(assign(r1CF6, add(r1CD0, r1CF7), 0x01));

                  ir_expression *const r1CF8 = add(r1CD1, r1CD2);
                  ir_expression *const r1CF9 = less(r1CF6, r1CD0);
                  ir_expression *const r1CFA = expr(ir_unop_b2i, r1CF9);
                  ir_expression *const r1CFB = expr(ir_unop_i2u, r1CFA);
                  body.emit(assign(r1CD1, add(r1CF8, r1CFB), 0x01));

                  body.emit(assign(r1CD0, r1CF6, 0x01));

               /* LOOP END */

               body.instructions = f1CF2_parent_instructions;
               body.emit(f1CF2);

               ir_expression *const r1CFC = lshift(r1CD1, body.constant(int(16)));
               ir_expression *const r1CFD = rshift(r1CD0, body.constant(int(16)));
               body.emit(assign(r1CD1, bit_or(r1CFC, r1CFD), 0x01));

               ir_variable *const r1CFE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r1D00 = lshift(r1CD2, body.constant(int(16)));
               ir_expression *const r1D01 = lequal(r1D00, r1CD1);
               ir_if *f1CFF = new(mem_ctx) ir_if(operand(r1D01).val);
               exec_list *const f1CFF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1CFF->then_instructions;

                  body.emit(assign(r1CFE, body.constant(65535u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1CFF->else_instructions;

                  body.emit(assign(r1CFE, expr(ir_binop_div, r1CD1, r1CD2), 0x01));


               body.instructions = f1CFF_parent_instructions;
               body.emit(f1CFF);

               /* END IF */

               body.emit(assign(r1CCF, bit_or(r1CCF, r1CFE), 0x01));

               body.emit(assign(r1CCE, r1CCF, 0x01));


            body.instructions = f1CD3_parent_instructions;
            body.emit(f1CD3);

            /* END IF */

            body.emit(assign(r1B92, r1CCE, 0x01));

            /* IF CONDITION */
            ir_expression *const r1D03 = bit_and(r1CCE, body.constant(511u));
            ir_expression *const r1D04 = lequal(r1D03, body.constant(5u));
            ir_if *f1D02 = new(mem_ctx) ir_if(operand(r1D04).val);
            exec_list *const f1D02_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1D02->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1D06 = equal(r1CCE, body.constant(0u));
               ir_if *f1D05 = new(mem_ctx) ir_if(operand(r1D06).val);
               exec_list *const f1D05_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1D05->then_instructions;

                  body.emit(assign(r1B92, body.constant(1u), 0x01));


               body.instructions = f1D05_parent_instructions;
               body.emit(f1D05);

               /* END IF */

               ir_variable *const r1D07 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1D07);
               ir_variable *const r1D08 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r1D08);
               ir_variable *const r1D09 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1D09);
               ir_variable *const r1D0A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1D0A, bit_and(r1B91, body.constant(65535u)), 0x01));

               ir_variable *const r1D0B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1D0B, rshift(r1B91, body.constant(int(16))), 0x01));

               ir_variable *const r1D0C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1D0C, bit_and(r1B92, body.constant(65535u)), 0x01));

               ir_variable *const r1D0D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1D0D, rshift(r1B92, body.constant(int(16))), 0x01));

               ir_variable *const r1D0E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1D0E, mul(r1D0B, r1D0C), 0x01));

               ir_expression *const r1D0F = mul(r1D0A, r1D0D);
               body.emit(assign(r1D08, add(r1D0F, r1D0E), 0x01));

               ir_expression *const r1D10 = mul(r1D0B, r1D0D);
               ir_expression *const r1D11 = less(r1D08, r1D0E);
               ir_expression *const r1D12 = expr(ir_unop_b2i, r1D11);
               ir_expression *const r1D13 = expr(ir_unop_i2u, r1D12);
               ir_expression *const r1D14 = lshift(r1D13, body.constant(int(16)));
               ir_expression *const r1D15 = rshift(r1D08, body.constant(int(16)));
               ir_expression *const r1D16 = add(r1D14, r1D15);
               body.emit(assign(r1D07, add(r1D10, r1D16), 0x01));

               body.emit(assign(r1D08, lshift(r1D08, body.constant(int(16))), 0x01));

               ir_expression *const r1D17 = mul(r1D0A, r1D0C);
               body.emit(assign(r1D09, add(r1D17, r1D08), 0x01));

               ir_expression *const r1D18 = less(r1D09, r1D08);
               ir_expression *const r1D19 = expr(ir_unop_b2i, r1D18);
               ir_expression *const r1D1A = expr(ir_unop_i2u, r1D19);
               body.emit(assign(r1D07, add(r1D07, r1D1A), 0x01));

               ir_variable *const r1D1B = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r1D1B, neg(r1D09), 0x01));

               ir_variable *const r1D1C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1D1C);
               ir_variable *const r1D1D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r1D1D);
               ir_variable *const r1D1E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1D1E);
               ir_variable *const r1D1F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1D1F, bit_and(r1B92, body.constant(65535u)), 0x01));

               ir_variable *const r1D20 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1D20, rshift(r1B92, body.constant(int(16))), 0x01));

               ir_variable *const r1D21 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1D21, bit_and(r1B92, body.constant(65535u)), 0x01));

               ir_variable *const r1D22 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1D22, rshift(r1B92, body.constant(int(16))), 0x01));

               ir_variable *const r1D23 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1D23, mul(r1D20, r1D21), 0x01));

               ir_expression *const r1D24 = mul(r1D1F, r1D22);
               body.emit(assign(r1D1D, add(r1D24, r1D23), 0x01));

               ir_expression *const r1D25 = mul(r1D20, r1D22);
               ir_expression *const r1D26 = less(r1D1D, r1D23);
               ir_expression *const r1D27 = expr(ir_unop_b2i, r1D26);
               ir_expression *const r1D28 = expr(ir_unop_i2u, r1D27);
               ir_expression *const r1D29 = lshift(r1D28, body.constant(int(16)));
               ir_expression *const r1D2A = rshift(r1D1D, body.constant(int(16)));
               ir_expression *const r1D2B = add(r1D29, r1D2A);
               body.emit(assign(r1D1C, add(r1D25, r1D2B), 0x01));

               body.emit(assign(r1D1D, lshift(r1D1D, body.constant(int(16))), 0x01));

               ir_expression *const r1D2C = mul(r1D1F, r1D21);
               body.emit(assign(r1D1E, add(r1D2C, r1D1D), 0x01));

               ir_expression *const r1D2D = less(r1D1E, r1D1D);
               ir_expression *const r1D2E = expr(ir_unop_b2i, r1D2D);
               ir_expression *const r1D2F = expr(ir_unop_i2u, r1D2E);
               body.emit(assign(r1D1C, add(r1D1C, r1D2F), 0x01));

               body.emit(assign(r1B8C, r1D1C, 0x01));

               body.emit(assign(r1B8B, r1D1E, 0x01));

               ir_variable *const r1D30 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1D30);
               ir_variable *const r1D31 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r1D32 = less(body.constant(0u), r1D1E);
               ir_expression *const r1D33 = expr(ir_unop_b2i, r1D32);
               body.emit(assign(r1D31, expr(ir_unop_i2u, r1D33), 0x01));

               ir_variable *const r1D34 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1D34, sub(r1D1B, r1D1C), 0x01));

               ir_expression *const r1D35 = sub(r1B8F, r1D07);
               ir_expression *const r1D36 = less(body.constant(0u), r1D09);
               ir_expression *const r1D37 = expr(ir_unop_b2i, r1D36);
               ir_expression *const r1D38 = expr(ir_unop_i2u, r1D37);
               ir_expression *const r1D39 = sub(r1D35, r1D38);
               ir_expression *const r1D3A = less(r1D34, r1D31);
               ir_expression *const r1D3B = expr(ir_unop_b2i, r1D3A);
               ir_expression *const r1D3C = expr(ir_unop_i2u, r1D3B);
               body.emit(assign(r1D30, sub(r1D39, r1D3C), 0x01));

               ir_expression *const r1D3D = less(r1D1B, r1D1C);
               ir_expression *const r1D3E = expr(ir_unop_b2i, r1D3D);
               ir_expression *const r1D3F = expr(ir_unop_i2u, r1D3E);
               body.emit(assign(r1D30, sub(r1D30, r1D3F), 0x01));

               body.emit(assign(r1B8F, r1D30, 0x01));

               body.emit(assign(r1B8E, sub(r1D34, r1D31), 0x01));

               body.emit(assign(r1B8D, neg(r1D1E), 0x01));

               /* LOOP BEGIN */
               ir_loop *f1D40 = new(mem_ctx) ir_loop();
               exec_list *const f1D40_parent_instructions = body.instructions;

                  body.instructions = &f1D40->body_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1D42 = expr(ir_unop_u2i, r1B8F);
                  ir_expression *const r1D43 = gequal(r1D42, body.constant(int(0)));
                  ir_if *f1D41 = new(mem_ctx) ir_if(operand(r1D43).val);
                  exec_list *const f1D41_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D41->then_instructions;

                     body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                  body.instructions = f1D41_parent_instructions;
                  body.emit(f1D41);

                  /* END IF */

                  body.emit(assign(r1B92, add(r1B92, body.constant(4294967295u)), 0x01));

                  ir_expression *const r1D44 = lshift(r1B92, body.constant(int(1)));
                  body.emit(assign(r1B8B, bit_or(r1D44, body.constant(1u)), 0x01));

                  ir_expression *const r1D45 = rshift(r1B92, body.constant(int(31)));
                  ir_expression *const r1D46 = bit_or(body.constant(0u), r1D45);
                  body.emit(assign(r1B8C, bit_or(r1D46, r1B91), 0x01));

                  ir_variable *const r1D47 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1D47);
                  ir_variable *const r1D48 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1D48);
                  ir_variable *const r1D49 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1D49, add(r1B8D, r1B8B), 0x01));

                  ir_variable *const r1D4A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  ir_expression *const r1D4B = less(r1D49, r1B8D);
                  ir_expression *const r1D4C = expr(ir_unop_b2i, r1D4B);
                  body.emit(assign(r1D4A, expr(ir_unop_i2u, r1D4C), 0x01));

                  ir_variable *const r1D4D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1D4D, add(r1B8E, r1B8C), 0x01));

                  body.emit(assign(r1D48, add(r1D4D, r1D4A), 0x01));

                  ir_expression *const r1D4E = less(r1D48, r1D4A);
                  ir_expression *const r1D4F = expr(ir_unop_b2i, r1D4E);
                  ir_expression *const r1D50 = expr(ir_unop_i2u, r1D4F);
                  body.emit(assign(r1D47, add(r1B8F, r1D50), 0x01));

                  ir_expression *const r1D51 = less(r1D4D, r1B8E);
                  ir_expression *const r1D52 = expr(ir_unop_b2i, r1D51);
                  ir_expression *const r1D53 = expr(ir_unop_i2u, r1D52);
                  body.emit(assign(r1D47, add(r1D47, r1D53), 0x01));

                  body.emit(assign(r1B8F, r1D47, 0x01));

                  body.emit(assign(r1B8E, r1D48, 0x01));

                  body.emit(assign(r1B8D, r1D49, 0x01));

               /* LOOP END */

               body.instructions = f1D40_parent_instructions;
               body.emit(f1D40);

               ir_expression *const r1D54 = bit_or(r1B8F, r1B8E);
               ir_expression *const r1D55 = bit_or(r1D54, r1B8D);
               ir_expression *const r1D56 = nequal(r1D55, body.constant(0u));
               ir_expression *const r1D57 = expr(ir_unop_b2i, r1D56);
               ir_expression *const r1D58 = expr(ir_unop_i2u, r1D57);
               body.emit(assign(r1B92, bit_or(r1B92, r1D58), 0x01));


            body.instructions = f1D02_parent_instructions;
            body.emit(f1D02);

            /* END IF */

            ir_variable *const r1D59 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r1D59);
            ir_variable *const r1D5A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r1D5A);
            ir_variable *const r1D5B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r1D5B);
            body.emit(assign(r1D59, lshift(r1B92, body.constant(int(22))), 0x01));

            ir_expression *const r1D5C = lshift(r1B93, body.constant(int(22)));
            ir_expression *const r1D5D = rshift(r1B92, body.constant(int(10)));
            body.emit(assign(r1D5A, bit_or(r1D5C, r1D5D), 0x01));

            body.emit(assign(r1D5B, rshift(r1B93, body.constant(int(10))), 0x01));

            body.emit(assign(r1D59, bit_or(r1D59, body.constant(0u)), 0x01));

            body.emit(assign(r1B93, r1D5B, 0x01));

            body.emit(assign(r1B92, r1D5A, 0x01));

            ir_variable *const r1D5E = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r1D5E, r1B87, 0x01));

            ir_variable *const r1D5F = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r1D5F, r1D5B, 0x01));

            ir_variable *const r1D60 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r1D60, r1D5A, 0x01));

            ir_variable *const r1D61 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r1D61, r1D59, 0x01));

            ir_variable *const r1D62 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r1D62, body.constant(true), 0x01));

            ir_variable *const r1D63 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r1D64 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r1D64);
            ir_expression *const r1D65 = expr(ir_unop_u2i, r1D59);
            body.emit(assign(r1D64, less(r1D65, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r1D67 = lequal(body.constant(int(2045)), r1B87);
            ir_if *f1D66 = new(mem_ctx) ir_if(operand(r1D67).val);
            exec_list *const f1D66_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1D66->then_instructions;

               ir_variable *const r1D68 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r1D6A = less(body.constant(int(2045)), r1B87);
               ir_if *f1D69 = new(mem_ctx) ir_if(operand(r1D6A).val);
               exec_list *const f1D69_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1D69->then_instructions;

                  body.emit(assign(r1D68, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1D69->else_instructions;

                  ir_variable *const r1D6B = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1D6D = equal(r1B87, body.constant(int(2045)));
                  ir_if *f1D6C = new(mem_ctx) ir_if(operand(r1D6D).val);
                  exec_list *const f1D6C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D6C->then_instructions;

                     ir_expression *const r1D6E = equal(body.constant(2097151u), r1D5B);
                     ir_expression *const r1D6F = equal(body.constant(4294967295u), r1D5A);
                     body.emit(assign(r1D6B, logic_and(r1D6E, r1D6F), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1D6C->else_instructions;

                     body.emit(assign(r1D6B, body.constant(false), 0x01));


                  body.instructions = f1D6C_parent_instructions;
                  body.emit(f1D6C);

                  /* END IF */

                  body.emit(assign(r1D68, logic_and(r1D6B, r1D64), 0x01));


               body.instructions = f1D69_parent_instructions;
               body.emit(f1D69);

               /* END IF */

               /* IF CONDITION */
               ir_if *f1D70 = new(mem_ctx) ir_if(operand(r1D68).val);
               exec_list *const f1D70_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1D70->then_instructions;

                  ir_variable *const r1D71 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1D71);
                  body.emit(assign(r1D71, body.constant(2146435072u), 0x02));

                  body.emit(assign(r1D71, body.constant(0u), 0x01));

                  body.emit(assign(r1D63, r1D71, 0x03));

                  body.emit(assign(r1D62, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1D70->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1D73 = less(r1B87, body.constant(int(0)));
                  ir_if *f1D72 = new(mem_ctx) ir_if(operand(r1D73).val);
                  exec_list *const f1D72_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D72->then_instructions;

                     ir_variable *const r1D74 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r1D74, r1D59, 0x01));

                     ir_variable *const r1D75 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r1D75, neg(r1B87), 0x01));

                     ir_variable *const r1D76 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r1D76);
                     ir_variable *const r1D77 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r1D77);
                     ir_variable *const r1D78 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r1D78);
                     ir_variable *const r1D79 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r1D7A = neg(r1D75);
                     body.emit(assign(r1D79, bit_and(r1D7A, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1D7C = equal(r1D75, body.constant(int(0)));
                     ir_if *f1D7B = new(mem_ctx) ir_if(operand(r1D7C).val);
                     exec_list *const f1D7B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1D7B->then_instructions;

                        body.emit(assign(r1D76, r1D59, 0x01));

                        body.emit(assign(r1D77, r1D5A, 0x01));

                        body.emit(assign(r1D78, r1D5B, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1D7B->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1D7E = less(r1D75, body.constant(int(32)));
                        ir_if *f1D7D = new(mem_ctx) ir_if(operand(r1D7E).val);
                        exec_list *const f1D7D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1D7D->then_instructions;

                           body.emit(assign(r1D76, lshift(r1D5A, r1D79), 0x01));

                           ir_expression *const r1D7F = lshift(r1D5B, r1D79);
                           ir_expression *const r1D80 = rshift(r1D5A, r1D75);
                           body.emit(assign(r1D77, bit_or(r1D7F, r1D80), 0x01));

                           body.emit(assign(r1D78, rshift(r1D5B, r1D75), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1D7D->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1D82 = equal(r1D75, body.constant(int(32)));
                           ir_if *f1D81 = new(mem_ctx) ir_if(operand(r1D82).val);
                           exec_list *const f1D81_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1D81->then_instructions;

                              body.emit(assign(r1D76, r1D5A, 0x01));

                              body.emit(assign(r1D77, r1D5B, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1D81->else_instructions;

                              body.emit(assign(r1D74, bit_or(r1D59, r1D5A), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r1D84 = less(r1D75, body.constant(int(64)));
                              ir_if *f1D83 = new(mem_ctx) ir_if(operand(r1D84).val);
                              exec_list *const f1D83_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1D83->then_instructions;

                                 body.emit(assign(r1D76, lshift(r1D5B, r1D79), 0x01));

                                 ir_expression *const r1D85 = bit_and(r1D75, body.constant(int(31)));
                                 body.emit(assign(r1D77, rshift(r1D5B, r1D85), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1D83->else_instructions;

                                 ir_variable *const r1D86 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r1D88 = equal(r1D75, body.constant(int(64)));
                                 ir_if *f1D87 = new(mem_ctx) ir_if(operand(r1D88).val);
                                 exec_list *const f1D87_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1D87->then_instructions;

                                    body.emit(assign(r1D86, r1D5B, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1D87->else_instructions;

                                    ir_expression *const r1D89 = nequal(r1D5B, body.constant(0u));
                                    ir_expression *const r1D8A = expr(ir_unop_b2i, r1D89);
                                    body.emit(assign(r1D86, expr(ir_unop_i2u, r1D8A), 0x01));


                                 body.instructions = f1D87_parent_instructions;
                                 body.emit(f1D87);

                                 /* END IF */

                                 body.emit(assign(r1D76, r1D86, 0x01));

                                 body.emit(assign(r1D77, body.constant(0u), 0x01));


                              body.instructions = f1D83_parent_instructions;
                              body.emit(f1D83);

                              /* END IF */


                           body.instructions = f1D81_parent_instructions;
                           body.emit(f1D81);

                           /* END IF */

                           body.emit(assign(r1D78, body.constant(0u), 0x01));


                        body.instructions = f1D7D_parent_instructions;
                        body.emit(f1D7D);

                        /* END IF */

                        ir_expression *const r1D8B = nequal(r1D74, body.constant(0u));
                        ir_expression *const r1D8C = expr(ir_unop_b2i, r1D8B);
                        ir_expression *const r1D8D = expr(ir_unop_i2u, r1D8C);
                        body.emit(assign(r1D76, bit_or(r1D76, r1D8D), 0x01));


                     body.instructions = f1D7B_parent_instructions;
                     body.emit(f1D7B);

                     /* END IF */

                     body.emit(assign(r1D5F, r1D78, 0x01));

                     body.emit(assign(r1D60, r1D77, 0x01));

                     body.emit(assign(r1D61, r1D76, 0x01));

                     body.emit(assign(r1D5E, body.constant(int(0)), 0x01));

                     body.emit(assign(r1D64, less(r1D76, body.constant(0u)), 0x01));


                  body.instructions = f1D72_parent_instructions;
                  body.emit(f1D72);

                  /* END IF */


               body.instructions = f1D70_parent_instructions;
               body.emit(f1D70);

               /* END IF */


            body.instructions = f1D66_parent_instructions;
            body.emit(f1D66);

            /* END IF */

            /* IF CONDITION */
            ir_if *f1D8E = new(mem_ctx) ir_if(operand(r1D62).val);
            exec_list *const f1D8E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1D8E->then_instructions;

               /* IF CONDITION */
               ir_if *f1D8F = new(mem_ctx) ir_if(operand(r1D64).val);
               exec_list *const f1D8F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1D8F->then_instructions;

                  ir_variable *const r1D90 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1D90, add(r1D60, body.constant(1u)), 0x01));

                  ir_expression *const r1D91 = less(r1D90, r1D60);
                  ir_expression *const r1D92 = expr(ir_unop_b2i, r1D91);
                  ir_expression *const r1D93 = expr(ir_unop_i2u, r1D92);
                  body.emit(assign(r1D5F, add(r1D5F, r1D93), 0x01));

                  ir_expression *const r1D94 = equal(r1D61, body.constant(0u));
                  ir_expression *const r1D95 = expr(ir_unop_b2i, r1D94);
                  ir_expression *const r1D96 = expr(ir_unop_i2u, r1D95);
                  ir_expression *const r1D97 = add(r1D61, r1D96);
                  ir_expression *const r1D98 = bit_and(r1D97, body.constant(1u));
                  ir_expression *const r1D99 = expr(ir_unop_bit_not, r1D98);
                  body.emit(assign(r1D60, bit_and(r1D90, r1D99), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1D8F->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1D9B = bit_or(r1D5F, r1D60);
                  ir_expression *const r1D9C = equal(r1D9B, body.constant(0u));
                  ir_if *f1D9A = new(mem_ctx) ir_if(operand(r1D9C).val);
                  exec_list *const f1D9A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1D9A->then_instructions;

                     body.emit(assign(r1D5E, body.constant(int(0)), 0x01));


                  body.instructions = f1D9A_parent_instructions;
                  body.emit(f1D9A);

                  /* END IF */


               body.instructions = f1D8F_parent_instructions;
               body.emit(f1D8F);

               /* END IF */

               ir_variable *const r1D9D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r1D9D);
               ir_expression *const r1D9E = expr(ir_unop_i2u, r1D5E);
               ir_expression *const r1D9F = lshift(r1D9E, body.constant(int(20)));
               body.emit(assign(r1D9D, add(r1D9F, r1D5F), 0x02));

               body.emit(assign(r1D9D, r1D60, 0x01));

               body.emit(assign(r1D63, r1D9D, 0x03));

               body.emit(assign(r1D62, body.constant(false), 0x01));


            body.instructions = f1D8E_parent_instructions;
            body.emit(f1D8E);

            /* END IF */

            body.emit(assign(r1B86, r1D63, 0x03));

            body.emit(assign(r1B85, body.constant(false), 0x01));


         body.instructions = f1C06_parent_instructions;
         body.emit(f1C06);

         /* END IF */


      body.instructions = f1BBD_parent_instructions;
      body.emit(f1BBD);

      /* END IF */


   body.instructions = f1B99_parent_instructions;
   body.emit(f1B99);

   /* END IF */

   body.emit(ret(r1B86));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift64Left(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1DA0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r1DA0);
   ir_variable *const r1DA1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r1DA1);
   ir_variable *const r1DA2 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r1DA2);
   ir_variable *const r1DA3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1DA3);
   ir_variable *const r1DA4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1DA4);
   ir_variable *const r1DA5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r1DA5);
   ir_variable *const r1DA6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r1DA6);
   ir_variable *const r1DA7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r1DA8 = neg(r1DA2);
   body.emit(assign(r1DA7, bit_and(r1DA8, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1DAA = equal(r1DA2, body.constant(int(0)));
   ir_if *f1DA9 = new(mem_ctx) ir_if(operand(r1DAA).val);
   exec_list *const f1DA9_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1DA9->then_instructions;

      body.emit(assign(r1DA6, r1DA0, 0x01));

      body.emit(assign(r1DA5, r1DA1, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1DA9->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1DAC = less(r1DA2, body.constant(int(32)));
      ir_if *f1DAB = new(mem_ctx) ir_if(operand(r1DAC).val);
      exec_list *const f1DAB_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1DAB->then_instructions;

         ir_expression *const r1DAD = lshift(r1DA0, r1DA2);
         ir_expression *const r1DAE = rshift(r1DA1, r1DA7);
         body.emit(assign(r1DA6, bit_or(r1DAD, r1DAE), 0x01));

         body.emit(assign(r1DA5, lshift(r1DA1, r1DA2), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1DAB->else_instructions;

         ir_variable *const r1DAF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1DB1 = less(r1DA2, body.constant(int(64)));
         ir_if *f1DB0 = new(mem_ctx) ir_if(operand(r1DB1).val);
         exec_list *const f1DB0_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1DB0->then_instructions;

            ir_expression *const r1DB2 = add(r1DA2, body.constant(int(-32)));
            body.emit(assign(r1DAF, lshift(r1DA1, r1DB2), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1DB0->else_instructions;

            body.emit(assign(r1DAF, body.constant(0u), 0x01));


         body.instructions = f1DB0_parent_instructions;
         body.emit(f1DB0);

         /* END IF */

         body.emit(assign(r1DA6, r1DAF, 0x01));

         body.emit(assign(r1DA5, body.constant(0u), 0x01));


      body.instructions = f1DAB_parent_instructions;
      body.emit(f1DAB);

      /* END IF */


   body.instructions = f1DA9_parent_instructions;
   body.emit(f1DA9);

   /* END IF */

   body.emit(assign(r1DA3, r1DA6, 0x01));

   body.emit(assign(r1DA4, r1DA5, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
uint_to_fp64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1DB3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1DB3);
   ir_variable *const r1DB4 = body.make_temp(glsl_type::uvec2_type, "return_value");
   /* IF CONDITION */
   ir_expression *const r1DB6 = equal(r1DB3, body.constant(0u));
   ir_if *f1DB5 = new(mem_ctx) ir_if(operand(r1DB6).val);
   exec_list *const f1DB5_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1DB5->then_instructions;

      body.emit(assign(r1DB4, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1DB5->else_instructions;

      ir_variable *const r1DB7 = body.make_temp(glsl_type::uint_type, "a");
      body.emit(assign(r1DB7, r1DB3, 0x01));

      ir_variable *const r1DB8 = body.make_temp(glsl_type::int_type, "return_value");
      ir_variable *const r1DB9 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
      body.emit(r1DB9);
      /* IF CONDITION */
      ir_expression *const r1DBB = equal(r1DB3, body.constant(0u));
      ir_if *f1DBA = new(mem_ctx) ir_if(operand(r1DBB).val);
      exec_list *const f1DBA_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1DBA->then_instructions;

         body.emit(assign(r1DB8, body.constant(int(32)), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1DBA->else_instructions;

         body.emit(assign(r1DB9, body.constant(int(0)), 0x01));

         /* IF CONDITION */
         ir_expression *const r1DBD = bit_and(r1DB3, body.constant(4294901760u));
         ir_expression *const r1DBE = equal(r1DBD, body.constant(0u));
         ir_if *f1DBC = new(mem_ctx) ir_if(operand(r1DBE).val);
         exec_list *const f1DBC_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1DBC->then_instructions;

            body.emit(assign(r1DB9, body.constant(int(16)), 0x01));

            body.emit(assign(r1DB7, lshift(r1DB3, body.constant(int(16))), 0x01));


         body.instructions = f1DBC_parent_instructions;
         body.emit(f1DBC);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1DC0 = bit_and(r1DB7, body.constant(4278190080u));
         ir_expression *const r1DC1 = equal(r1DC0, body.constant(0u));
         ir_if *f1DBF = new(mem_ctx) ir_if(operand(r1DC1).val);
         exec_list *const f1DBF_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1DBF->then_instructions;

            body.emit(assign(r1DB9, add(r1DB9, body.constant(int(8))), 0x01));

            body.emit(assign(r1DB7, lshift(r1DB7, body.constant(int(8))), 0x01));


         body.instructions = f1DBF_parent_instructions;
         body.emit(f1DBF);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1DC3 = bit_and(r1DB7, body.constant(4026531840u));
         ir_expression *const r1DC4 = equal(r1DC3, body.constant(0u));
         ir_if *f1DC2 = new(mem_ctx) ir_if(operand(r1DC4).val);
         exec_list *const f1DC2_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1DC2->then_instructions;

            body.emit(assign(r1DB9, add(r1DB9, body.constant(int(4))), 0x01));

            body.emit(assign(r1DB7, lshift(r1DB7, body.constant(int(4))), 0x01));


         body.instructions = f1DC2_parent_instructions;
         body.emit(f1DC2);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1DC6 = bit_and(r1DB7, body.constant(3221225472u));
         ir_expression *const r1DC7 = equal(r1DC6, body.constant(0u));
         ir_if *f1DC5 = new(mem_ctx) ir_if(operand(r1DC7).val);
         exec_list *const f1DC5_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1DC5->then_instructions;

            body.emit(assign(r1DB9, add(r1DB9, body.constant(int(2))), 0x01));

            body.emit(assign(r1DB7, lshift(r1DB7, body.constant(int(2))), 0x01));


         body.instructions = f1DC5_parent_instructions;
         body.emit(f1DC5);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1DC9 = bit_and(r1DB7, body.constant(2147483648u));
         ir_expression *const r1DCA = equal(r1DC9, body.constant(0u));
         ir_if *f1DC8 = new(mem_ctx) ir_if(operand(r1DCA).val);
         exec_list *const f1DC8_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1DC8->then_instructions;

            body.emit(assign(r1DB9, add(r1DB9, body.constant(int(1))), 0x01));


         body.instructions = f1DC8_parent_instructions;
         body.emit(f1DC8);

         /* END IF */

         body.emit(assign(r1DB8, r1DB9, 0x01));


      body.instructions = f1DBA_parent_instructions;
      body.emit(f1DBA);

      /* END IF */

      ir_variable *const r1DCB = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r1DCB, add(r1DB8, body.constant(int(21))), 0x01));

      ir_variable *const r1DCC = body.make_temp(glsl_type::uint_type, "a0");
      body.emit(assign(r1DCC, body.constant(0u), 0x01));

      ir_variable *const r1DCD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r1DCD);
      ir_variable *const r1DCE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r1DCE);
      ir_variable *const r1DCF = body.make_temp(glsl_type::int_type, "assignment_tmp");
      ir_expression *const r1DD0 = neg(r1DCB);
      body.emit(assign(r1DCF, bit_and(r1DD0, body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r1DD2 = equal(r1DCB, body.constant(int(0)));
      ir_if *f1DD1 = new(mem_ctx) ir_if(operand(r1DD2).val);
      exec_list *const f1DD1_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1DD1->then_instructions;

         body.emit(assign(r1DCE, body.constant(0u), 0x01));

         body.emit(assign(r1DCD, r1DB3, 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1DD1->else_instructions;

         /* IF CONDITION */
         ir_expression *const r1DD4 = less(r1DCB, body.constant(int(32)));
         ir_if *f1DD3 = new(mem_ctx) ir_if(operand(r1DD4).val);
         exec_list *const f1DD3_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1DD3->then_instructions;

            ir_expression *const r1DD5 = rshift(r1DB3, r1DCF);
            body.emit(assign(r1DCE, bit_or(body.constant(0u), r1DD5), 0x01));

            body.emit(assign(r1DCD, lshift(r1DB3, r1DCB), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1DD3->else_instructions;

            ir_variable *const r1DD6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r1DD8 = less(r1DCB, body.constant(int(64)));
            ir_if *f1DD7 = new(mem_ctx) ir_if(operand(r1DD8).val);
            exec_list *const f1DD7_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1DD7->then_instructions;

               ir_expression *const r1DD9 = add(r1DCB, body.constant(int(-32)));
               body.emit(assign(r1DD6, lshift(r1DB3, r1DD9), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1DD7->else_instructions;

               body.emit(assign(r1DD6, body.constant(0u), 0x01));


            body.instructions = f1DD7_parent_instructions;
            body.emit(f1DD7);

            /* END IF */

            body.emit(assign(r1DCE, r1DD6, 0x01));

            body.emit(assign(r1DCD, body.constant(0u), 0x01));


         body.instructions = f1DD3_parent_instructions;
         body.emit(f1DD3);

         /* END IF */


      body.instructions = f1DD1_parent_instructions;
      body.emit(f1DD1);

      /* END IF */

      ir_variable *const r1DDA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r1DDA);
      ir_expression *const r1DDB = sub(body.constant(int(1074)), r1DCB);
      ir_expression *const r1DDC = expr(ir_unop_i2u, r1DDB);
      ir_expression *const r1DDD = lshift(r1DDC, body.constant(int(20)));
      body.emit(assign(r1DDA, add(r1DDD, r1DCE), 0x02));

      body.emit(assign(r1DDA, r1DCD, 0x01));

      body.emit(assign(r1DB4, r1DDA, 0x03));


   body.instructions = f1DB5_parent_instructions;
   body.emit(f1DB5);

   /* END IF */

   body.emit(ret(r1DB4));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fp64_to_uint(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1DDE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1DDE);
   ir_variable *const r1DDF = body.make_temp(glsl_type::uint_type, "return_value");
   ir_variable *const r1DE0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
   body.emit(r1DE0);
   ir_variable *const r1DE1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
   body.emit(r1DE1);
   body.emit(assign(r1DE1, bit_and(swizzle_y(r1DDE), body.constant(1048575u)), 0x02));

   body.emit(assign(r1DE1, swizzle_x(r1DDE), 0x01));

   body.emit(assign(r1DE0, r1DE1, 0x03));

   ir_variable *const r1DE2 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r1DE3 = rshift(swizzle_y(r1DDE), body.constant(int(20)));
   ir_expression *const r1DE4 = bit_and(r1DE3, body.constant(2047u));
   body.emit(assign(r1DE2, expr(ir_unop_u2i, r1DE4), 0x01));

   ir_variable *const r1DE5 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r1DE5, rshift(swizzle_y(r1DDE), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1DE7 = nequal(r1DE5, body.constant(0u));
   ir_if *f1DE6 = new(mem_ctx) ir_if(operand(r1DE7).val);
   exec_list *const f1DE6_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1DE6->then_instructions;

      body.emit(assign(r1DDF, body.constant(0u), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1DE6->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1DE9 = equal(r1DE2, body.constant(int(2047)));
      ir_expression *const r1DEA = bit_or(swizzle_y(r1DE1), swizzle_x(r1DDE));
      ir_expression *const r1DEB = nequal(r1DEA, body.constant(0u));
      ir_expression *const r1DEC = logic_and(r1DE9, r1DEB);
      ir_if *f1DE8 = new(mem_ctx) ir_if(operand(r1DEC).val);
      exec_list *const f1DE8_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1DE8->then_instructions;

         body.emit(assign(r1DDF, body.constant(4294967295u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1DE8->else_instructions;

         /* IF CONDITION */
         ir_expression *const r1DEE = nequal(r1DE2, body.constant(int(0)));
         ir_if *f1DED = new(mem_ctx) ir_if(operand(r1DEE).val);
         exec_list *const f1DED_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1DED->then_instructions;

            body.emit(assign(r1DE0, bit_or(swizzle_y(r1DE1), body.constant(1048576u)), 0x02));


         body.instructions = f1DED_parent_instructions;
         body.emit(f1DED);

         /* END IF */

         ir_variable *const r1DEF = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r1DEF, sub(body.constant(int(1063)), r1DE2), 0x01));

         /* IF CONDITION */
         ir_expression *const r1DF1 = less(body.constant(int(0)), r1DEF);
         ir_if *f1DF0 = new(mem_ctx) ir_if(operand(r1DF1).val);
         exec_list *const f1DF0_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1DF0->then_instructions;

            ir_variable *const r1DF2 = body.make_temp(glsl_type::uint_type, "a0");
            body.emit(assign(r1DF2, swizzle_y(r1DE0), 0x01));

            ir_variable *const r1DF3 = body.make_temp(glsl_type::uint_type, "a1");
            body.emit(assign(r1DF3, swizzle_x(r1DE0), 0x01));

            ir_variable *const r1DF4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r1DF4);
            ir_variable *const r1DF5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r1DF5);
            ir_variable *const r1DF6 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r1DF7 = neg(r1DEF);
            body.emit(assign(r1DF6, bit_and(r1DF7, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r1DF9 = equal(r1DEF, body.constant(int(0)));
            ir_if *f1DF8 = new(mem_ctx) ir_if(operand(r1DF9).val);
            exec_list *const f1DF8_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1DF8->then_instructions;

               body.emit(assign(r1DF4, r1DF3, 0x01));

               body.emit(assign(r1DF5, r1DF2, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1DF8->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1DFB = less(r1DEF, body.constant(int(32)));
               ir_if *f1DFA = new(mem_ctx) ir_if(operand(r1DFB).val);
               exec_list *const f1DFA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1DFA->then_instructions;

                  ir_expression *const r1DFC = lshift(swizzle_y(r1DE0), r1DF6);
                  ir_expression *const r1DFD = rshift(swizzle_x(r1DE1), r1DEF);
                  ir_expression *const r1DFE = bit_or(r1DFC, r1DFD);
                  ir_expression *const r1DFF = lshift(swizzle_x(r1DE1), r1DF6);
                  ir_expression *const r1E00 = nequal(r1DFF, body.constant(0u));
                  ir_expression *const r1E01 = expr(ir_unop_b2i, r1E00);
                  ir_expression *const r1E02 = expr(ir_unop_i2u, r1E01);
                  body.emit(assign(r1DF4, bit_or(r1DFE, r1E02), 0x01));

                  body.emit(assign(r1DF5, rshift(swizzle_y(r1DE0), r1DEF), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1DFA->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1E04 = equal(r1DEF, body.constant(int(32)));
                  ir_if *f1E03 = new(mem_ctx) ir_if(operand(r1E04).val);
                  exec_list *const f1E03_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1E03->then_instructions;

                     ir_expression *const r1E05 = nequal(swizzle_x(r1DE1), body.constant(0u));
                     ir_expression *const r1E06 = expr(ir_unop_b2i, r1E05);
                     ir_expression *const r1E07 = expr(ir_unop_i2u, r1E06);
                     body.emit(assign(r1DF4, bit_or(swizzle_y(r1DE0), r1E07), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1E03->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1E09 = less(r1DEF, body.constant(int(64)));
                     ir_if *f1E08 = new(mem_ctx) ir_if(operand(r1E09).val);
                     exec_list *const f1E08_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1E08->then_instructions;

                        ir_expression *const r1E0A = bit_and(r1DEF, body.constant(int(31)));
                        ir_expression *const r1E0B = rshift(swizzle_y(r1DE0), r1E0A);
                        ir_expression *const r1E0C = lshift(swizzle_y(r1DE0), r1DF6);
                        ir_expression *const r1E0D = bit_or(r1E0C, swizzle_x(r1DE1));
                        ir_expression *const r1E0E = nequal(r1E0D, body.constant(0u));
                        ir_expression *const r1E0F = expr(ir_unop_b2i, r1E0E);
                        ir_expression *const r1E10 = expr(ir_unop_i2u, r1E0F);
                        body.emit(assign(r1DF4, bit_or(r1E0B, r1E10), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1E08->else_instructions;

                        ir_expression *const r1E11 = bit_or(swizzle_y(r1DE0), swizzle_x(r1DE1));
                        ir_expression *const r1E12 = nequal(r1E11, body.constant(0u));
                        ir_expression *const r1E13 = expr(ir_unop_b2i, r1E12);
                        body.emit(assign(r1DF4, expr(ir_unop_i2u, r1E13), 0x01));


                     body.instructions = f1E08_parent_instructions;
                     body.emit(f1E08);

                     /* END IF */


                  body.instructions = f1E03_parent_instructions;
                  body.emit(f1E03);

                  /* END IF */

                  body.emit(assign(r1DF5, body.constant(0u), 0x01));


               body.instructions = f1DFA_parent_instructions;
               body.emit(f1DFA);

               /* END IF */


            body.instructions = f1DF8_parent_instructions;
            body.emit(f1DF8);

            /* END IF */

            body.emit(assign(r1DE0, r1DF5, 0x02));

            body.emit(assign(r1DE0, r1DF4, 0x01));


         body.instructions = f1DF0_parent_instructions;
         body.emit(f1DF0);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r1E15 = bit_and(swizzle_y(r1DE0), body.constant(4294963200u));
         ir_expression *const r1E16 = nequal(r1E15, body.constant(0u));
         ir_if *f1E14 = new(mem_ctx) ir_if(operand(r1E16).val);
         exec_list *const f1E14_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1E14->then_instructions;

            ir_variable *const r1E17 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r1E19 = nequal(r1DE5, body.constant(0u));
            ir_if *f1E18 = new(mem_ctx) ir_if(operand(r1E19).val);
            exec_list *const f1E18_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1E18->then_instructions;

               body.emit(assign(r1E17, body.constant(0u), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1E18->else_instructions;

               body.emit(assign(r1E17, body.constant(4294967295u), 0x01));


            body.instructions = f1E18_parent_instructions;
            body.emit(f1E18);

            /* END IF */

            body.emit(assign(r1DDF, r1E17, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1E14->else_instructions;

            ir_variable *const r1E1A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r1E1A);
            ir_variable *const r1E1B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r1E1B);
            ir_expression *const r1E1C = lshift(swizzle_y(r1DE0), body.constant(int(20)));
            ir_expression *const r1E1D = rshift(swizzle_x(r1DE0), body.constant(int(12)));
            body.emit(assign(r1E1A, bit_or(r1E1C, r1E1D), 0x01));

            body.emit(assign(r1E1B, rshift(swizzle_y(r1DE0), body.constant(int(12))), 0x01));

            /* IF CONDITION */
            ir_expression *const r1E1F = nequal(r1DE5, body.constant(0u));
            ir_expression *const r1E20 = nequal(r1E1A, body.constant(0u));
            ir_expression *const r1E21 = logic_and(r1E1F, r1E20);
            ir_if *f1E1E = new(mem_ctx) ir_if(operand(r1E21).val);
            exec_list *const f1E1E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1E1E->then_instructions;

               ir_variable *const r1E22 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r1E24 = nequal(r1DE5, body.constant(0u));
               ir_if *f1E23 = new(mem_ctx) ir_if(operand(r1E24).val);
               exec_list *const f1E23_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1E23->then_instructions;

                  body.emit(assign(r1E22, body.constant(0u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1E23->else_instructions;

                  body.emit(assign(r1E22, body.constant(4294967295u), 0x01));


               body.instructions = f1E23_parent_instructions;
               body.emit(f1E23);

               /* END IF */

               body.emit(assign(r1DDF, r1E22, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1E1E->else_instructions;

               body.emit(assign(r1DDF, r1E1A, 0x01));


            body.instructions = f1E1E_parent_instructions;
            body.emit(f1E1E);

            /* END IF */


         body.instructions = f1E14_parent_instructions;
         body.emit(f1E14);

         /* END IF */


      body.instructions = f1DE8_parent_instructions;
      body.emit(f1DE8);

      /* END IF */


   body.instructions = f1DE6_parent_instructions;
   body.emit(f1DE6);

   /* END IF */

   body.emit(ret(r1DDF));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
ftrunc64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1E25 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1E25);
   ir_variable *const r1E26 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1E27 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r1E28 = rshift(swizzle_y(r1E25), body.constant(int(20)));
   ir_expression *const r1E29 = bit_and(r1E28, body.constant(2047u));
   ir_expression *const r1E2A = expr(ir_unop_u2i, r1E29);
   body.emit(assign(r1E27, add(r1E2A, body.constant(int(-1023))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1E2C = less(r1E27, body.constant(int(0)));
   ir_if *f1E2B = new(mem_ctx) ir_if(operand(r1E2C).val);
   exec_list *const f1E2B_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1E2B->then_instructions;

      body.emit(assign(r1E26, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1E2B->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1E2E = greater(r1E27, body.constant(int(52)));
      ir_if *f1E2D = new(mem_ctx) ir_if(operand(r1E2E).val);
      exec_list *const f1E2D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1E2D->then_instructions;

         body.emit(assign(r1E26, r1E25, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1E2D->else_instructions;

         ir_variable *const r1E2F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r1E2F);
         ir_variable *const r1E30 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r1E30, sub(body.constant(int(52)), r1E27), 0x01));

         ir_variable *const r1E31 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1E33 = gequal(r1E30, body.constant(int(32)));
         ir_if *f1E32 = new(mem_ctx) ir_if(operand(r1E33).val);
         exec_list *const f1E32_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1E32->then_instructions;

            body.emit(assign(r1E31, body.constant(0u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1E32->else_instructions;

            body.emit(assign(r1E31, lshift(body.constant(4294967295u), r1E30), 0x01));


         body.instructions = f1E32_parent_instructions;
         body.emit(f1E32);

         /* END IF */

         ir_variable *const r1E34 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1E36 = less(r1E30, body.constant(int(33)));
         ir_if *f1E35 = new(mem_ctx) ir_if(operand(r1E36).val);
         exec_list *const f1E35_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1E35->then_instructions;

            body.emit(assign(r1E34, body.constant(4294967295u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1E35->else_instructions;

            ir_expression *const r1E37 = add(r1E30, body.constant(int(-32)));
            body.emit(assign(r1E34, lshift(body.constant(4294967295u), r1E37), 0x01));


         body.instructions = f1E35_parent_instructions;
         body.emit(f1E35);

         /* END IF */

         body.emit(assign(r1E2F, bit_and(r1E31, swizzle_x(r1E25)), 0x01));

         body.emit(assign(r1E2F, bit_and(r1E34, swizzle_y(r1E25)), 0x02));

         body.emit(assign(r1E26, r1E2F, 0x03));


      body.instructions = f1E2D_parent_instructions;
      body.emit(f1E2D);

      /* END IF */


   body.instructions = f1E2B_parent_instructions;
   body.emit(f1E2B);

   /* END IF */

   body.emit(ret(r1E26));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
ffloor64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1E38 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1E38);
   ir_variable *const r1E39 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r1E3A = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r1E3B = rshift(swizzle_y(r1E38), body.constant(int(20)));
   ir_expression *const r1E3C = bit_and(r1E3B, body.constant(2047u));
   ir_expression *const r1E3D = expr(ir_unop_u2i, r1E3C);
   body.emit(assign(r1E3A, add(r1E3D, body.constant(int(-1023))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1E3F = less(r1E3A, body.constant(int(0)));
   ir_if *f1E3E = new(mem_ctx) ir_if(operand(r1E3F).val);
   exec_list *const f1E3E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1E3E->then_instructions;

      body.emit(assign(r1E39, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1E3E->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1E41 = greater(r1E3A, body.constant(int(52)));
      ir_if *f1E40 = new(mem_ctx) ir_if(operand(r1E41).val);
      exec_list *const f1E40_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1E40->then_instructions;

         body.emit(assign(r1E39, r1E38, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1E40->else_instructions;

         ir_variable *const r1E42 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r1E42);
         ir_variable *const r1E43 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r1E43, sub(body.constant(int(52)), r1E3A), 0x01));

         ir_variable *const r1E44 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1E46 = gequal(r1E43, body.constant(int(32)));
         ir_if *f1E45 = new(mem_ctx) ir_if(operand(r1E46).val);
         exec_list *const f1E45_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1E45->then_instructions;

            body.emit(assign(r1E44, body.constant(0u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1E45->else_instructions;

            body.emit(assign(r1E44, lshift(body.constant(4294967295u), r1E43), 0x01));


         body.instructions = f1E45_parent_instructions;
         body.emit(f1E45);

         /* END IF */

         ir_variable *const r1E47 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1E49 = less(r1E43, body.constant(int(33)));
         ir_if *f1E48 = new(mem_ctx) ir_if(operand(r1E49).val);
         exec_list *const f1E48_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1E48->then_instructions;

            body.emit(assign(r1E47, body.constant(4294967295u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1E48->else_instructions;

            ir_expression *const r1E4A = add(r1E43, body.constant(int(-32)));
            body.emit(assign(r1E47, lshift(body.constant(4294967295u), r1E4A), 0x01));


         body.instructions = f1E48_parent_instructions;
         body.emit(f1E48);

         /* END IF */

         body.emit(assign(r1E42, bit_and(r1E44, swizzle_x(r1E38)), 0x01));

         body.emit(assign(r1E42, bit_and(r1E47, swizzle_y(r1E38)), 0x02));

         body.emit(assign(r1E39, r1E42, 0x03));


      body.instructions = f1E40_parent_instructions;
      body.emit(f1E40);

      /* END IF */


   body.instructions = f1E3E_parent_instructions;
   body.emit(f1E3E);

   /* END IF */

   ir_variable *const r1E4B = body.make_temp(glsl_type::bool_type, "assignment_tmp");
   ir_expression *const r1E4C = rshift(swizzle_y(r1E38), body.constant(int(31)));
   ir_expression *const r1E4D = expr(ir_unop_u2i, r1E4C);
   body.emit(assign(r1E4B, expr(ir_unop_i2b, r1E4D), 0x01));

   ir_variable *const r1E4E = body.make_temp(glsl_type::bool_type, "or_tmp");
   /* IF CONDITION */
   ir_expression *const r1E50 = expr(ir_unop_logic_not, r1E4B);
   ir_if *f1E4F = new(mem_ctx) ir_if(operand(r1E50).val);
   exec_list *const f1E4F_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1E4F->then_instructions;

      body.emit(assign(r1E4E, body.constant(true), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1E4F->else_instructions;

      ir_variable *const r1E51 = body.make_temp(glsl_type::bool_type, "return_value");
      ir_variable *const r1E52 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
      body.emit(r1E52);
      ir_variable *const r1E53 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
      body.emit(r1E53);
      ir_variable *const r1E54 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r1E54);
      body.emit(assign(r1E54, bit_and(swizzle_y(r1E38), body.constant(1048575u)), 0x02));

      body.emit(assign(r1E54, swizzle_x(r1E38), 0x01));

      ir_variable *const r1E55 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r1E55);
      body.emit(assign(r1E55, bit_and(swizzle_y(r1E39), body.constant(1048575u)), 0x02));

      body.emit(assign(r1E55, swizzle_x(r1E39), 0x01));

      ir_expression *const r1E56 = rshift(swizzle_y(r1E38), body.constant(int(20)));
      ir_expression *const r1E57 = bit_and(r1E56, body.constant(2047u));
      ir_expression *const r1E58 = expr(ir_unop_u2i, r1E57);
      ir_expression *const r1E59 = equal(r1E58, body.constant(int(2047)));
      ir_expression *const r1E5A = bit_or(swizzle_y(r1E54), swizzle_x(r1E38));
      ir_expression *const r1E5B = nequal(r1E5A, body.constant(0u));
      body.emit(assign(r1E53, logic_and(r1E59, r1E5B), 0x01));

      ir_expression *const r1E5C = rshift(swizzle_y(r1E39), body.constant(int(20)));
      ir_expression *const r1E5D = bit_and(r1E5C, body.constant(2047u));
      ir_expression *const r1E5E = expr(ir_unop_u2i, r1E5D);
      ir_expression *const r1E5F = equal(r1E5E, body.constant(int(2047)));
      ir_expression *const r1E60 = bit_or(swizzle_y(r1E55), swizzle_x(r1E39));
      ir_expression *const r1E61 = nequal(r1E60, body.constant(0u));
      body.emit(assign(r1E52, logic_and(r1E5F, r1E61), 0x01));

      /* IF CONDITION */
      ir_expression *const r1E63 = logic_or(r1E53, r1E52);
      ir_if *f1E62 = new(mem_ctx) ir_if(operand(r1E63).val);
      exec_list *const f1E62_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1E62->then_instructions;

         body.emit(assign(r1E51, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1E62->else_instructions;

         ir_expression *const r1E64 = equal(swizzle_x(r1E38), swizzle_x(r1E39));
         ir_expression *const r1E65 = equal(swizzle_y(r1E38), swizzle_y(r1E39));
         ir_expression *const r1E66 = equal(swizzle_x(r1E38), body.constant(0u));
         ir_expression *const r1E67 = bit_or(swizzle_y(r1E38), swizzle_y(r1E39));
         ir_expression *const r1E68 = lshift(r1E67, body.constant(int(1)));
         ir_expression *const r1E69 = equal(r1E68, body.constant(0u));
         ir_expression *const r1E6A = logic_and(r1E66, r1E69);
         ir_expression *const r1E6B = logic_or(r1E65, r1E6A);
         body.emit(assign(r1E51, logic_and(r1E64, r1E6B), 0x01));


      body.instructions = f1E62_parent_instructions;
      body.emit(f1E62);

      /* END IF */

      body.emit(assign(r1E4E, r1E51, 0x01));


   body.instructions = f1E4F_parent_instructions;
   body.emit(f1E4F);

   /* END IF */

   ir_variable *const r1E6C = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
   /* IF CONDITION */
   ir_if *f1E6D = new(mem_ctx) ir_if(operand(r1E4E).val);
   exec_list *const f1E6D_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1E6D->then_instructions;

      body.emit(assign(r1E6C, r1E39, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1E6D->else_instructions;

      ir_variable *const r1E6E = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r1E6F = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r1E6F, rshift(swizzle_y(r1E39), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r1E71 = equal(r1E6F, body.constant(0u));
      ir_if *f1E70 = new(mem_ctx) ir_if(operand(r1E71).val);
      exec_list *const f1E70_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1E70->then_instructions;

         ir_variable *const r1E72 = body.make_temp(glsl_type::uint_type, "zSign");
         body.emit(assign(r1E72, r1E6F, 0x01));

         ir_variable *const r1E73 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r1E74 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r1E74);
         ir_variable *const r1E75 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
         body.emit(r1E75);
         ir_variable *const r1E76 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
         body.emit(r1E76);
         ir_variable *const r1E77 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
         body.emit(r1E77);
         ir_variable *const r1E78 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
         body.emit(r1E78);
         ir_variable *const r1E79 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r1E79);
         ir_variable *const r1E7A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
         body.emit(r1E7A);
         body.emit(assign(r1E7A, bit_and(swizzle_y(r1E39), body.constant(1048575u)), 0x02));

         body.emit(assign(r1E7A, swizzle_x(r1E39), 0x01));

         ir_variable *const r1E7B = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r1E7C = rshift(swizzle_y(r1E39), body.constant(int(20)));
         ir_expression *const r1E7D = bit_and(r1E7C, body.constant(2047u));
         body.emit(assign(r1E7B, expr(ir_unop_u2i, r1E7D), 0x01));

         body.emit(assign(r1E77, r1E7B, 0x01));

         ir_variable *const r1E7E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
         body.emit(r1E7E);
         body.emit(assign(r1E7E, body.constant(0u), 0x02));

         body.emit(assign(r1E7E, body.constant(0u), 0x01));

         body.emit(assign(r1E75, body.constant(int(1023)), 0x01));

         body.emit(assign(r1E74, add(r1E7B, body.constant(int(-1023))), 0x01));

         ir_variable *const r1E7F = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r1E7F, lshift(swizzle_x(r1E39), body.constant(int(10))), 0x01));

         ir_variable *const r1E80 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         ir_expression *const r1E81 = lshift(swizzle_y(r1E7A), body.constant(int(10)));
         ir_expression *const r1E82 = rshift(swizzle_x(r1E39), body.constant(int(22)));
         body.emit(assign(r1E80, bit_or(r1E81, r1E82), 0x01));

         body.emit(assign(r1E78, r1E80, 0x02));

         body.emit(assign(r1E78, r1E7F, 0x01));

         ir_variable *const r1E83 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         body.emit(assign(r1E83, body.constant(0u), 0x01));

         body.emit(assign(r1E76, r1E83, 0x02));

         body.emit(assign(r1E76, body.constant(0u), 0x01));

         /* IF CONDITION */
         ir_expression *const r1E85 = less(body.constant(int(0)), r1E74);
         ir_if *f1E84 = new(mem_ctx) ir_if(operand(r1E85).val);
         exec_list *const f1E84_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1E84->then_instructions;

            /* IF CONDITION */
            ir_expression *const r1E87 = equal(r1E7B, body.constant(int(2047)));
            ir_if *f1E86 = new(mem_ctx) ir_if(operand(r1E87).val);
            exec_list *const f1E86_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1E86->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1E89 = bit_or(r1E80, r1E7F);
               ir_expression *const r1E8A = nequal(r1E89, body.constant(0u));
               ir_if *f1E88 = new(mem_ctx) ir_if(operand(r1E8A).val);
               exec_list *const f1E88_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1E88->then_instructions;

                  ir_variable *const r1E8B = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r1E8B, swizzle_x(r1E39), 0x01));

                  ir_variable *const r1E8C = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r1E8C, body.constant(0u), 0x01));

                  ir_variable *const r1E8D = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r1E8B, bit_or(swizzle_y(r1E39), body.constant(524288u)), 0x02));

                  body.emit(assign(r1E8C, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r1E8F = lshift(swizzle_y(r1E39), body.constant(int(1)));
                  ir_expression *const r1E90 = lequal(body.constant(4292870144u), r1E8F);
                  ir_expression *const r1E91 = nequal(swizzle_x(r1E39), body.constant(0u));
                  ir_expression *const r1E92 = bit_and(swizzle_y(r1E39), body.constant(1048575u));
                  ir_expression *const r1E93 = nequal(r1E92, body.constant(0u));
                  ir_expression *const r1E94 = logic_or(r1E91, r1E93);
                  ir_expression *const r1E95 = logic_and(r1E90, r1E94);
                  ir_if *f1E8E = new(mem_ctx) ir_if(operand(r1E95).val);
                  exec_list *const f1E8E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1E8E->then_instructions;

                     body.emit(assign(r1E8D, r1E8B, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1E8E->else_instructions;

                     body.emit(assign(r1E8D, r1E8C, 0x03));


                  body.instructions = f1E8E_parent_instructions;
                  body.emit(f1E8E);

                  /* END IF */

                  body.emit(assign(r1E73, r1E8D, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1E88->else_instructions;

                  body.emit(assign(r1E73, r1E39, 0x03));


               body.instructions = f1E88_parent_instructions;
               body.emit(f1E88);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1E86->else_instructions;

               body.emit(assign(r1E76, body.constant(1073741824u), 0x02));

               ir_variable *const r1E96 = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r1E96, body.constant(1073741824u), 0x01));

               ir_variable *const r1E97 = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r1E97, body.constant(0u), 0x01));

               ir_variable *const r1E98 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1E98);
               ir_variable *const r1E99 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1E99);
               ir_variable *const r1E9A = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r1E9B = neg(r1E74);
               body.emit(assign(r1E9A, bit_and(r1E9B, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1E9D = equal(r1E74, body.constant(int(0)));
               ir_if *f1E9C = new(mem_ctx) ir_if(operand(r1E9D).val);
               exec_list *const f1E9C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1E9C->then_instructions;

                  body.emit(assign(r1E98, r1E97, 0x01));

                  body.emit(assign(r1E99, r1E96, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1E9C->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1E9F = less(r1E74, body.constant(int(32)));
                  ir_if *f1E9E = new(mem_ctx) ir_if(operand(r1E9F).val);
                  exec_list *const f1E9E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1E9E->then_instructions;

                     ir_expression *const r1EA0 = lshift(body.constant(1073741824u), r1E9A);
                     ir_expression *const r1EA1 = bit_or(r1EA0, body.constant(0u));
                     body.emit(assign(r1E98, bit_or(r1EA1, body.constant(0u)), 0x01));

                     body.emit(assign(r1E99, rshift(body.constant(1073741824u), r1E74), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1E9E->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1EA3 = equal(r1E74, body.constant(int(32)));
                     ir_if *f1EA2 = new(mem_ctx) ir_if(operand(r1EA3).val);
                     exec_list *const f1EA2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1EA2->then_instructions;

                        body.emit(assign(r1E98, body.constant(1073741824u), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1EA2->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1EA5 = less(r1E74, body.constant(int(64)));
                        ir_if *f1EA4 = new(mem_ctx) ir_if(operand(r1EA5).val);
                        exec_list *const f1EA4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1EA4->then_instructions;

                           ir_expression *const r1EA6 = bit_and(r1E74, body.constant(int(31)));
                           ir_expression *const r1EA7 = rshift(body.constant(1073741824u), r1EA6);
                           ir_expression *const r1EA8 = lshift(body.constant(1073741824u), r1E9A);
                           ir_expression *const r1EA9 = bit_or(r1EA8, body.constant(0u));
                           ir_expression *const r1EAA = nequal(r1EA9, body.constant(0u));
                           ir_expression *const r1EAB = expr(ir_unop_b2i, r1EAA);
                           ir_expression *const r1EAC = expr(ir_unop_i2u, r1EAB);
                           body.emit(assign(r1E98, bit_or(r1EA7, r1EAC), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1EA4->else_instructions;

                           body.emit(assign(r1E98, body.constant(1u), 0x01));


                        body.instructions = f1EA4_parent_instructions;
                        body.emit(f1EA4);

                        /* END IF */


                     body.instructions = f1EA2_parent_instructions;
                     body.emit(f1EA2);

                     /* END IF */

                     body.emit(assign(r1E99, body.constant(0u), 0x01));


                  body.instructions = f1E9E_parent_instructions;
                  body.emit(f1E9E);

                  /* END IF */


               body.instructions = f1E9C_parent_instructions;
               body.emit(f1E9C);

               /* END IF */

               body.emit(assign(r1E76, r1E99, 0x02));

               body.emit(assign(r1E76, r1E98, 0x01));

               body.emit(assign(r1E78, bit_or(r1E80, body.constant(1073741824u)), 0x02));

               ir_variable *const r1EAD = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r1EAE = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r1EAE, sub(r1E7F, r1E98), 0x01));

               ir_expression *const r1EAF = sub(swizzle_y(r1E78), r1E99);
               ir_expression *const r1EB0 = less(r1E7F, r1E98);
               ir_expression *const r1EB1 = expr(ir_unop_b2i, r1EB0);
               ir_expression *const r1EB2 = expr(ir_unop_i2u, r1EB1);
               body.emit(assign(r1EAD, sub(r1EAF, r1EB2), 0x01));

               body.emit(assign(r1E79, add(r1E7B, body.constant(int(-1))), 0x01));

               ir_variable *const r1EB3 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r1EB3, add(r1E79, body.constant(int(-10))), 0x01));

               ir_variable *const r1EB4 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r1EB4, r1EAD, 0x01));

               ir_variable *const r1EB5 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r1EB5, r1EAE, 0x01));

               ir_variable *const r1EB6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r1EB6);
               ir_variable *const r1EB7 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1EB7);
               /* IF CONDITION */
               ir_expression *const r1EB9 = equal(r1EAD, body.constant(0u));
               ir_if *f1EB8 = new(mem_ctx) ir_if(operand(r1EB9).val);
               exec_list *const f1EB8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1EB8->then_instructions;

                  body.emit(assign(r1EB4, r1EAE, 0x01));

                  body.emit(assign(r1EB5, body.constant(0u), 0x01));

                  body.emit(assign(r1EB3, add(r1EB3, body.constant(int(-32))), 0x01));


               body.instructions = f1EB8_parent_instructions;
               body.emit(f1EB8);

               /* END IF */

               ir_variable *const r1EBA = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r1EBA, r1EB4, 0x01));

               ir_variable *const r1EBB = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r1EBC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1EBC);
               /* IF CONDITION */
               ir_expression *const r1EBE = equal(r1EB4, body.constant(0u));
               ir_if *f1EBD = new(mem_ctx) ir_if(operand(r1EBE).val);
               exec_list *const f1EBD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1EBD->then_instructions;

                  body.emit(assign(r1EBB, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1EBD->else_instructions;

                  body.emit(assign(r1EBC, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1EC0 = bit_and(r1EB4, body.constant(4294901760u));
                  ir_expression *const r1EC1 = equal(r1EC0, body.constant(0u));
                  ir_if *f1EBF = new(mem_ctx) ir_if(operand(r1EC1).val);
                  exec_list *const f1EBF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1EBF->then_instructions;

                     body.emit(assign(r1EBC, body.constant(int(16)), 0x01));

                     body.emit(assign(r1EBA, lshift(r1EB4, body.constant(int(16))), 0x01));


                  body.instructions = f1EBF_parent_instructions;
                  body.emit(f1EBF);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1EC3 = bit_and(r1EBA, body.constant(4278190080u));
                  ir_expression *const r1EC4 = equal(r1EC3, body.constant(0u));
                  ir_if *f1EC2 = new(mem_ctx) ir_if(operand(r1EC4).val);
                  exec_list *const f1EC2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1EC2->then_instructions;

                     body.emit(assign(r1EBC, add(r1EBC, body.constant(int(8))), 0x01));

                     body.emit(assign(r1EBA, lshift(r1EBA, body.constant(int(8))), 0x01));


                  body.instructions = f1EC2_parent_instructions;
                  body.emit(f1EC2);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1EC6 = bit_and(r1EBA, body.constant(4026531840u));
                  ir_expression *const r1EC7 = equal(r1EC6, body.constant(0u));
                  ir_if *f1EC5 = new(mem_ctx) ir_if(operand(r1EC7).val);
                  exec_list *const f1EC5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1EC5->then_instructions;

                     body.emit(assign(r1EBC, add(r1EBC, body.constant(int(4))), 0x01));

                     body.emit(assign(r1EBA, lshift(r1EBA, body.constant(int(4))), 0x01));


                  body.instructions = f1EC5_parent_instructions;
                  body.emit(f1EC5);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1EC9 = bit_and(r1EBA, body.constant(3221225472u));
                  ir_expression *const r1ECA = equal(r1EC9, body.constant(0u));
                  ir_if *f1EC8 = new(mem_ctx) ir_if(operand(r1ECA).val);
                  exec_list *const f1EC8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1EC8->then_instructions;

                     body.emit(assign(r1EBC, add(r1EBC, body.constant(int(2))), 0x01));

                     body.emit(assign(r1EBA, lshift(r1EBA, body.constant(int(2))), 0x01));


                  body.instructions = f1EC8_parent_instructions;
                  body.emit(f1EC8);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1ECC = bit_and(r1EBA, body.constant(2147483648u));
                  ir_expression *const r1ECD = equal(r1ECC, body.constant(0u));
                  ir_if *f1ECB = new(mem_ctx) ir_if(operand(r1ECD).val);
                  exec_list *const f1ECB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1ECB->then_instructions;

                     body.emit(assign(r1EBC, add(r1EBC, body.constant(int(1))), 0x01));


                  body.instructions = f1ECB_parent_instructions;
                  body.emit(f1ECB);

                  /* END IF */

                  body.emit(assign(r1EBB, r1EBC, 0x01));


               body.instructions = f1EBD_parent_instructions;
               body.emit(f1EBD);

               /* END IF */

               body.emit(assign(r1EB7, add(r1EBB, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1ECF = lequal(body.constant(int(0)), r1EB7);
               ir_if *f1ECE = new(mem_ctx) ir_if(operand(r1ECF).val);
               exec_list *const f1ECE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1ECE->then_instructions;

                  body.emit(assign(r1EB6, body.constant(0u), 0x01));

                  ir_variable *const r1ED0 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r1ED0, lshift(r1EB5, r1EB7), 0x01));

                  ir_variable *const r1ED1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1ED3 = equal(r1EB7, body.constant(int(0)));
                  ir_if *f1ED2 = new(mem_ctx) ir_if(operand(r1ED3).val);
                  exec_list *const f1ED2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1ED2->then_instructions;

                     body.emit(assign(r1ED1, r1EB4, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1ED2->else_instructions;

                     ir_expression *const r1ED4 = lshift(r1EB4, r1EB7);
                     ir_expression *const r1ED5 = neg(r1EB7);
                     ir_expression *const r1ED6 = bit_and(r1ED5, body.constant(int(31)));
                     ir_expression *const r1ED7 = rshift(r1EB5, r1ED6);
                     body.emit(assign(r1ED1, bit_or(r1ED4, r1ED7), 0x01));


                  body.instructions = f1ED2_parent_instructions;
                  body.emit(f1ED2);

                  /* END IF */

                  body.emit(assign(r1EB4, r1ED1, 0x01));

                  body.emit(assign(r1EB5, r1ED0, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1ECE->else_instructions;

                  ir_variable *const r1ED8 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r1ED8, body.constant(0u), 0x01));

                  ir_variable *const r1ED9 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r1ED9, neg(r1EB7), 0x01));

                  ir_variable *const r1EDA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r1EDA);
                  ir_variable *const r1EDB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1EDB);
                  ir_variable *const r1EDC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1EDC);
                  ir_variable *const r1EDD = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r1EDE = neg(r1ED9);
                  body.emit(assign(r1EDD, bit_and(r1EDE, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1EE0 = equal(r1ED9, body.constant(int(0)));
                  ir_if *f1EDF = new(mem_ctx) ir_if(operand(r1EE0).val);
                  exec_list *const f1EDF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1EDF->then_instructions;

                     body.emit(assign(r1EDA, r1ED8, 0x01));

                     body.emit(assign(r1EDB, r1EB5, 0x01));

                     body.emit(assign(r1EDC, r1EB4, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1EDF->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1EE2 = less(r1ED9, body.constant(int(32)));
                     ir_if *f1EE1 = new(mem_ctx) ir_if(operand(r1EE2).val);
                     exec_list *const f1EE1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1EE1->then_instructions;

                        body.emit(assign(r1EDA, lshift(r1EB5, r1EDD), 0x01));

                        ir_expression *const r1EE3 = lshift(r1EB4, r1EDD);
                        ir_expression *const r1EE4 = rshift(r1EB5, r1ED9);
                        body.emit(assign(r1EDB, bit_or(r1EE3, r1EE4), 0x01));

                        body.emit(assign(r1EDC, rshift(r1EB4, r1ED9), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1EE1->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1EE6 = equal(r1ED9, body.constant(int(32)));
                        ir_if *f1EE5 = new(mem_ctx) ir_if(operand(r1EE6).val);
                        exec_list *const f1EE5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1EE5->then_instructions;

                           body.emit(assign(r1EDA, r1EB5, 0x01));

                           body.emit(assign(r1EDB, r1EB4, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1EE5->else_instructions;

                           body.emit(assign(r1ED8, bit_or(body.constant(0u), r1EB5), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1EE8 = less(r1ED9, body.constant(int(64)));
                           ir_if *f1EE7 = new(mem_ctx) ir_if(operand(r1EE8).val);
                           exec_list *const f1EE7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1EE7->then_instructions;

                              body.emit(assign(r1EDA, lshift(r1EB4, r1EDD), 0x01));

                              ir_expression *const r1EE9 = bit_and(r1ED9, body.constant(int(31)));
                              body.emit(assign(r1EDB, rshift(r1EB4, r1EE9), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1EE7->else_instructions;

                              ir_variable *const r1EEA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1EEC = equal(r1ED9, body.constant(int(64)));
                              ir_if *f1EEB = new(mem_ctx) ir_if(operand(r1EEC).val);
                              exec_list *const f1EEB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1EEB->then_instructions;

                                 body.emit(assign(r1EEA, r1EB4, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1EEB->else_instructions;

                                 ir_expression *const r1EED = nequal(r1EB4, body.constant(0u));
                                 ir_expression *const r1EEE = expr(ir_unop_b2i, r1EED);
                                 body.emit(assign(r1EEA, expr(ir_unop_i2u, r1EEE), 0x01));


                              body.instructions = f1EEB_parent_instructions;
                              body.emit(f1EEB);

                              /* END IF */

                              body.emit(assign(r1EDA, r1EEA, 0x01));

                              body.emit(assign(r1EDB, body.constant(0u), 0x01));


                           body.instructions = f1EE7_parent_instructions;
                           body.emit(f1EE7);

                           /* END IF */


                        body.instructions = f1EE5_parent_instructions;
                        body.emit(f1EE5);

                        /* END IF */

                        body.emit(assign(r1EDC, body.constant(0u), 0x01));


                     body.instructions = f1EE1_parent_instructions;
                     body.emit(f1EE1);

                     /* END IF */

                     ir_expression *const r1EEF = nequal(r1ED8, body.constant(0u));
                     ir_expression *const r1EF0 = expr(ir_unop_b2i, r1EEF);
                     ir_expression *const r1EF1 = expr(ir_unop_i2u, r1EF0);
                     body.emit(assign(r1EDA, bit_or(r1EDA, r1EF1), 0x01));


                  body.instructions = f1EDF_parent_instructions;
                  body.emit(f1EDF);

                  /* END IF */

                  body.emit(assign(r1EB4, r1EDC, 0x01));

                  body.emit(assign(r1EB5, r1EDB, 0x01));

                  body.emit(assign(r1EB6, r1EDA, 0x01));


               body.instructions = f1ECE_parent_instructions;
               body.emit(f1ECE);

               /* END IF */

               body.emit(assign(r1EB3, sub(r1EB3, r1EB7), 0x01));

               ir_variable *const r1EF2 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r1EF2, r1EB3, 0x01));

               ir_variable *const r1EF3 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r1EF3, r1EB4, 0x01));

               ir_variable *const r1EF4 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r1EF4, r1EB5, 0x01));

               ir_variable *const r1EF5 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r1EF5, r1EB6, 0x01));

               ir_variable *const r1EF6 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r1EF6, body.constant(true), 0x01));

               ir_variable *const r1EF7 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r1EF8 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r1EF8);
               ir_expression *const r1EF9 = expr(ir_unop_u2i, r1EB6);
               body.emit(assign(r1EF8, less(r1EF9, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1EFB = lequal(body.constant(int(2045)), r1EB3);
               ir_if *f1EFA = new(mem_ctx) ir_if(operand(r1EFB).val);
               exec_list *const f1EFA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1EFA->then_instructions;

                  ir_variable *const r1EFC = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1EFE = less(body.constant(int(2045)), r1EB3);
                  ir_if *f1EFD = new(mem_ctx) ir_if(operand(r1EFE).val);
                  exec_list *const f1EFD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1EFD->then_instructions;

                     body.emit(assign(r1EFC, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1EFD->else_instructions;

                     ir_variable *const r1EFF = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1F01 = equal(r1EB3, body.constant(int(2045)));
                     ir_if *f1F00 = new(mem_ctx) ir_if(operand(r1F01).val);
                     exec_list *const f1F00_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1F00->then_instructions;

                        ir_expression *const r1F02 = equal(body.constant(2097151u), r1EB4);
                        ir_expression *const r1F03 = equal(body.constant(4294967295u), r1EB5);
                        body.emit(assign(r1EFF, logic_and(r1F02, r1F03), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1F00->else_instructions;

                        body.emit(assign(r1EFF, body.constant(false), 0x01));


                     body.instructions = f1F00_parent_instructions;
                     body.emit(f1F00);

                     /* END IF */

                     body.emit(assign(r1EFC, logic_and(r1EFF, r1EF8), 0x01));


                  body.instructions = f1EFD_parent_instructions;
                  body.emit(f1EFD);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f1F04 = new(mem_ctx) ir_if(operand(r1EFC).val);
                  exec_list *const f1F04_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1F04->then_instructions;

                     ir_variable *const r1F05 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r1F05);
                     ir_expression *const r1F06 = lshift(r1E6F, body.constant(int(31)));
                     body.emit(assign(r1F05, add(r1F06, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r1F05, body.constant(0u), 0x01));

                     body.emit(assign(r1EF7, r1F05, 0x03));

                     body.emit(assign(r1EF6, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1F04->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1F08 = less(r1EB3, body.constant(int(0)));
                     ir_if *f1F07 = new(mem_ctx) ir_if(operand(r1F08).val);
                     exec_list *const f1F07_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1F07->then_instructions;

                        ir_variable *const r1F09 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r1F09, r1EB6, 0x01));

                        ir_variable *const r1F0A = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r1F0A, neg(r1EB3), 0x01));

                        ir_variable *const r1F0B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r1F0B);
                        ir_variable *const r1F0C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r1F0C);
                        ir_variable *const r1F0D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r1F0D);
                        ir_variable *const r1F0E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r1F0F = neg(r1F0A);
                        body.emit(assign(r1F0E, bit_and(r1F0F, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1F11 = equal(r1F0A, body.constant(int(0)));
                        ir_if *f1F10 = new(mem_ctx) ir_if(operand(r1F11).val);
                        exec_list *const f1F10_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1F10->then_instructions;

                           body.emit(assign(r1F0B, r1EB6, 0x01));

                           body.emit(assign(r1F0C, r1EB5, 0x01));

                           body.emit(assign(r1F0D, r1EB4, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1F10->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1F13 = less(r1F0A, body.constant(int(32)));
                           ir_if *f1F12 = new(mem_ctx) ir_if(operand(r1F13).val);
                           exec_list *const f1F12_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1F12->then_instructions;

                              body.emit(assign(r1F0B, lshift(r1EB5, r1F0E), 0x01));

                              ir_expression *const r1F14 = lshift(r1EB4, r1F0E);
                              ir_expression *const r1F15 = rshift(r1EB5, r1F0A);
                              body.emit(assign(r1F0C, bit_or(r1F14, r1F15), 0x01));

                              body.emit(assign(r1F0D, rshift(r1EB4, r1F0A), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1F12->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1F17 = equal(r1F0A, body.constant(int(32)));
                              ir_if *f1F16 = new(mem_ctx) ir_if(operand(r1F17).val);
                              exec_list *const f1F16_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F16->then_instructions;

                                 body.emit(assign(r1F0B, r1EB5, 0x01));

                                 body.emit(assign(r1F0C, r1EB4, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1F16->else_instructions;

                                 body.emit(assign(r1F09, bit_or(r1EB6, r1EB5), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1F19 = less(r1F0A, body.constant(int(64)));
                                 ir_if *f1F18 = new(mem_ctx) ir_if(operand(r1F19).val);
                                 exec_list *const f1F18_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1F18->then_instructions;

                                    body.emit(assign(r1F0B, lshift(r1EB4, r1F0E), 0x01));

                                    ir_expression *const r1F1A = bit_and(r1F0A, body.constant(int(31)));
                                    body.emit(assign(r1F0C, rshift(r1EB4, r1F1A), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1F18->else_instructions;

                                    ir_variable *const r1F1B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r1F1D = equal(r1F0A, body.constant(int(64)));
                                    ir_if *f1F1C = new(mem_ctx) ir_if(operand(r1F1D).val);
                                    exec_list *const f1F1C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1F1C->then_instructions;

                                       body.emit(assign(r1F1B, r1EB4, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1F1C->else_instructions;

                                       ir_expression *const r1F1E = nequal(r1EB4, body.constant(0u));
                                       ir_expression *const r1F1F = expr(ir_unop_b2i, r1F1E);
                                       body.emit(assign(r1F1B, expr(ir_unop_i2u, r1F1F), 0x01));


                                    body.instructions = f1F1C_parent_instructions;
                                    body.emit(f1F1C);

                                    /* END IF */

                                    body.emit(assign(r1F0B, r1F1B, 0x01));

                                    body.emit(assign(r1F0C, body.constant(0u), 0x01));


                                 body.instructions = f1F18_parent_instructions;
                                 body.emit(f1F18);

                                 /* END IF */


                              body.instructions = f1F16_parent_instructions;
                              body.emit(f1F16);

                              /* END IF */

                              body.emit(assign(r1F0D, body.constant(0u), 0x01));


                           body.instructions = f1F12_parent_instructions;
                           body.emit(f1F12);

                           /* END IF */

                           ir_expression *const r1F20 = nequal(r1F09, body.constant(0u));
                           ir_expression *const r1F21 = expr(ir_unop_b2i, r1F20);
                           ir_expression *const r1F22 = expr(ir_unop_i2u, r1F21);
                           body.emit(assign(r1F0B, bit_or(r1F0B, r1F22), 0x01));


                        body.instructions = f1F10_parent_instructions;
                        body.emit(f1F10);

                        /* END IF */

                        body.emit(assign(r1EF3, r1F0D, 0x01));

                        body.emit(assign(r1EF4, r1F0C, 0x01));

                        body.emit(assign(r1EF5, r1F0B, 0x01));

                        body.emit(assign(r1EF2, body.constant(int(0)), 0x01));

                        body.emit(assign(r1EF8, less(r1F0B, body.constant(0u)), 0x01));


                     body.instructions = f1F07_parent_instructions;
                     body.emit(f1F07);

                     /* END IF */


                  body.instructions = f1F04_parent_instructions;
                  body.emit(f1F04);

                  /* END IF */


               body.instructions = f1EFA_parent_instructions;
               body.emit(f1EFA);

               /* END IF */

               /* IF CONDITION */
               ir_if *f1F23 = new(mem_ctx) ir_if(operand(r1EF6).val);
               exec_list *const f1F23_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1F23->then_instructions;

                  /* IF CONDITION */
                  ir_if *f1F24 = new(mem_ctx) ir_if(operand(r1EF8).val);
                  exec_list *const f1F24_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1F24->then_instructions;

                     ir_variable *const r1F25 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r1F25, add(r1EF4, body.constant(1u)), 0x01));

                     ir_expression *const r1F26 = less(r1F25, r1EF4);
                     ir_expression *const r1F27 = expr(ir_unop_b2i, r1F26);
                     ir_expression *const r1F28 = expr(ir_unop_i2u, r1F27);
                     body.emit(assign(r1EF3, add(r1EF3, r1F28), 0x01));

                     ir_expression *const r1F29 = equal(r1EF5, body.constant(0u));
                     ir_expression *const r1F2A = expr(ir_unop_b2i, r1F29);
                     ir_expression *const r1F2B = expr(ir_unop_i2u, r1F2A);
                     ir_expression *const r1F2C = add(r1EF5, r1F2B);
                     ir_expression *const r1F2D = bit_and(r1F2C, body.constant(1u));
                     ir_expression *const r1F2E = expr(ir_unop_bit_not, r1F2D);
                     body.emit(assign(r1EF4, bit_and(r1F25, r1F2E), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1F24->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1F30 = bit_or(r1EF3, r1EF4);
                     ir_expression *const r1F31 = equal(r1F30, body.constant(0u));
                     ir_if *f1F2F = new(mem_ctx) ir_if(operand(r1F31).val);
                     exec_list *const f1F2F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1F2F->then_instructions;

                        body.emit(assign(r1EF2, body.constant(int(0)), 0x01));


                     body.instructions = f1F2F_parent_instructions;
                     body.emit(f1F2F);

                     /* END IF */


                  body.instructions = f1F24_parent_instructions;
                  body.emit(f1F24);

                  /* END IF */

                  ir_variable *const r1F32 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1F32);
                  ir_expression *const r1F33 = lshift(r1E6F, body.constant(int(31)));
                  ir_expression *const r1F34 = expr(ir_unop_i2u, r1EF2);
                  ir_expression *const r1F35 = lshift(r1F34, body.constant(int(20)));
                  ir_expression *const r1F36 = add(r1F33, r1F35);
                  body.emit(assign(r1F32, add(r1F36, r1EF3), 0x02));

                  body.emit(assign(r1F32, r1EF4, 0x01));

                  body.emit(assign(r1EF7, r1F32, 0x03));

                  body.emit(assign(r1EF6, body.constant(false), 0x01));


               body.instructions = f1F23_parent_instructions;
               body.emit(f1F23);

               /* END IF */

               body.emit(assign(r1E73, r1EF7, 0x03));


            body.instructions = f1E86_parent_instructions;
            body.emit(f1E86);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1E84->else_instructions;

            /* IF CONDITION */
            ir_expression *const r1F38 = less(r1E74, body.constant(int(0)));
            ir_if *f1F37 = new(mem_ctx) ir_if(operand(r1F38).val);
            exec_list *const f1F37_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1F37->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1F3A = equal(r1E7B, body.constant(int(0)));
               ir_if *f1F39 = new(mem_ctx) ir_if(operand(r1F3A).val);
               exec_list *const f1F39_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1F39->then_instructions;

                  body.emit(assign(r1E74, add(r1E74, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1F39->else_instructions;

                  body.emit(assign(r1E78, bit_or(swizzle_y(r1E78), body.constant(1073741824u)), 0x02));


               body.instructions = f1F39_parent_instructions;
               body.emit(f1F39);

               /* END IF */

               ir_variable *const r1F3B = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r1F3B, swizzle_y(r1E78), 0x01));

               ir_variable *const r1F3C = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r1F3C, swizzle_x(r1E78), 0x01));

               ir_variable *const r1F3D = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r1F3D, neg(r1E74), 0x01));

               ir_variable *const r1F3E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1F3E);
               ir_variable *const r1F3F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1F3F);
               ir_variable *const r1F40 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r1F41 = neg(r1F3D);
               body.emit(assign(r1F40, bit_and(r1F41, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1F43 = equal(r1F3D, body.constant(int(0)));
               ir_if *f1F42 = new(mem_ctx) ir_if(operand(r1F43).val);
               exec_list *const f1F42_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1F42->then_instructions;

                  body.emit(assign(r1F3E, r1F3C, 0x01));

                  body.emit(assign(r1F3F, r1F3B, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1F42->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1F45 = less(r1F3D, body.constant(int(32)));
                  ir_if *f1F44 = new(mem_ctx) ir_if(operand(r1F45).val);
                  exec_list *const f1F44_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1F44->then_instructions;

                     ir_expression *const r1F46 = lshift(swizzle_y(r1E78), r1F40);
                     ir_expression *const r1F47 = rshift(r1E7F, r1F3D);
                     ir_expression *const r1F48 = bit_or(r1F46, r1F47);
                     ir_expression *const r1F49 = lshift(r1E7F, r1F40);
                     ir_expression *const r1F4A = nequal(r1F49, body.constant(0u));
                     ir_expression *const r1F4B = expr(ir_unop_b2i, r1F4A);
                     ir_expression *const r1F4C = expr(ir_unop_i2u, r1F4B);
                     body.emit(assign(r1F3E, bit_or(r1F48, r1F4C), 0x01));

                     body.emit(assign(r1F3F, rshift(swizzle_y(r1E78), r1F3D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1F44->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1F4E = equal(r1F3D, body.constant(int(32)));
                     ir_if *f1F4D = new(mem_ctx) ir_if(operand(r1F4E).val);
                     exec_list *const f1F4D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1F4D->then_instructions;

                        ir_expression *const r1F4F = nequal(r1E7F, body.constant(0u));
                        ir_expression *const r1F50 = expr(ir_unop_b2i, r1F4F);
                        ir_expression *const r1F51 = expr(ir_unop_i2u, r1F50);
                        body.emit(assign(r1F3E, bit_or(swizzle_y(r1E78), r1F51), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1F4D->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1F53 = less(r1F3D, body.constant(int(64)));
                        ir_if *f1F52 = new(mem_ctx) ir_if(operand(r1F53).val);
                        exec_list *const f1F52_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1F52->then_instructions;

                           ir_expression *const r1F54 = bit_and(r1F3D, body.constant(int(31)));
                           ir_expression *const r1F55 = rshift(swizzle_y(r1E78), r1F54);
                           ir_expression *const r1F56 = lshift(swizzle_y(r1E78), r1F40);
                           ir_expression *const r1F57 = bit_or(r1F56, r1E7F);
                           ir_expression *const r1F58 = nequal(r1F57, body.constant(0u));
                           ir_expression *const r1F59 = expr(ir_unop_b2i, r1F58);
                           ir_expression *const r1F5A = expr(ir_unop_i2u, r1F59);
                           body.emit(assign(r1F3E, bit_or(r1F55, r1F5A), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1F52->else_instructions;

                           ir_expression *const r1F5B = bit_or(swizzle_y(r1E78), r1E7F);
                           ir_expression *const r1F5C = nequal(r1F5B, body.constant(0u));
                           ir_expression *const r1F5D = expr(ir_unop_b2i, r1F5C);
                           body.emit(assign(r1F3E, expr(ir_unop_i2u, r1F5D), 0x01));


                        body.instructions = f1F52_parent_instructions;
                        body.emit(f1F52);

                        /* END IF */


                     body.instructions = f1F4D_parent_instructions;
                     body.emit(f1F4D);

                     /* END IF */

                     body.emit(assign(r1F3F, body.constant(0u), 0x01));


                  body.instructions = f1F44_parent_instructions;
                  body.emit(f1F44);

                  /* END IF */


               body.instructions = f1F42_parent_instructions;
               body.emit(f1F42);

               /* END IF */

               body.emit(assign(r1E78, r1F3F, 0x02));

               body.emit(assign(r1E78, r1F3E, 0x01));

               body.emit(assign(r1E76, bit_or(swizzle_y(r1E76), body.constant(1073741824u)), 0x02));

               ir_variable *const r1F5E = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r1F5F = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r1F5F, sub(swizzle_x(r1E76), r1F3E), 0x01));

               ir_expression *const r1F60 = sub(swizzle_y(r1E76), r1F3F);
               ir_expression *const r1F61 = less(swizzle_x(r1E76), r1F3E);
               ir_expression *const r1F62 = expr(ir_unop_b2i, r1F61);
               ir_expression *const r1F63 = expr(ir_unop_i2u, r1F62);
               body.emit(assign(r1F5E, sub(r1F60, r1F63), 0x01));

               body.emit(assign(r1E72, bit_xor(r1E6F, body.constant(1u)), 0x01));

               body.emit(assign(r1E79, body.constant(int(1022)), 0x01));

               ir_variable *const r1F64 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r1F64, body.constant(int(1012)), 0x01));

               ir_variable *const r1F65 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r1F65, r1F5E, 0x01));

               ir_variable *const r1F66 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r1F66, r1F5F, 0x01));

               ir_variable *const r1F67 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r1F67);
               ir_variable *const r1F68 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1F68);
               /* IF CONDITION */
               ir_expression *const r1F6A = equal(r1F5E, body.constant(0u));
               ir_if *f1F69 = new(mem_ctx) ir_if(operand(r1F6A).val);
               exec_list *const f1F69_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1F69->then_instructions;

                  body.emit(assign(r1F65, r1F5F, 0x01));

                  body.emit(assign(r1F66, body.constant(0u), 0x01));

                  body.emit(assign(r1F64, body.constant(int(980)), 0x01));


               body.instructions = f1F69_parent_instructions;
               body.emit(f1F69);

               /* END IF */

               ir_variable *const r1F6B = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r1F6B, r1F65, 0x01));

               ir_variable *const r1F6C = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r1F6D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1F6D);
               /* IF CONDITION */
               ir_expression *const r1F6F = equal(r1F65, body.constant(0u));
               ir_if *f1F6E = new(mem_ctx) ir_if(operand(r1F6F).val);
               exec_list *const f1F6E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1F6E->then_instructions;

                  body.emit(assign(r1F6C, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1F6E->else_instructions;

                  body.emit(assign(r1F6D, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1F71 = bit_and(r1F65, body.constant(4294901760u));
                  ir_expression *const r1F72 = equal(r1F71, body.constant(0u));
                  ir_if *f1F70 = new(mem_ctx) ir_if(operand(r1F72).val);
                  exec_list *const f1F70_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1F70->then_instructions;

                     body.emit(assign(r1F6D, body.constant(int(16)), 0x01));

                     body.emit(assign(r1F6B, lshift(r1F65, body.constant(int(16))), 0x01));


                  body.instructions = f1F70_parent_instructions;
                  body.emit(f1F70);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1F74 = bit_and(r1F6B, body.constant(4278190080u));
                  ir_expression *const r1F75 = equal(r1F74, body.constant(0u));
                  ir_if *f1F73 = new(mem_ctx) ir_if(operand(r1F75).val);
                  exec_list *const f1F73_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1F73->then_instructions;

                     body.emit(assign(r1F6D, add(r1F6D, body.constant(int(8))), 0x01));

                     body.emit(assign(r1F6B, lshift(r1F6B, body.constant(int(8))), 0x01));


                  body.instructions = f1F73_parent_instructions;
                  body.emit(f1F73);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1F77 = bit_and(r1F6B, body.constant(4026531840u));
                  ir_expression *const r1F78 = equal(r1F77, body.constant(0u));
                  ir_if *f1F76 = new(mem_ctx) ir_if(operand(r1F78).val);
                  exec_list *const f1F76_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1F76->then_instructions;

                     body.emit(assign(r1F6D, add(r1F6D, body.constant(int(4))), 0x01));

                     body.emit(assign(r1F6B, lshift(r1F6B, body.constant(int(4))), 0x01));


                  body.instructions = f1F76_parent_instructions;
                  body.emit(f1F76);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1F7A = bit_and(r1F6B, body.constant(3221225472u));
                  ir_expression *const r1F7B = equal(r1F7A, body.constant(0u));
                  ir_if *f1F79 = new(mem_ctx) ir_if(operand(r1F7B).val);
                  exec_list *const f1F79_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1F79->then_instructions;

                     body.emit(assign(r1F6D, add(r1F6D, body.constant(int(2))), 0x01));

                     body.emit(assign(r1F6B, lshift(r1F6B, body.constant(int(2))), 0x01));


                  body.instructions = f1F79_parent_instructions;
                  body.emit(f1F79);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1F7D = bit_and(r1F6B, body.constant(2147483648u));
                  ir_expression *const r1F7E = equal(r1F7D, body.constant(0u));
                  ir_if *f1F7C = new(mem_ctx) ir_if(operand(r1F7E).val);
                  exec_list *const f1F7C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1F7C->then_instructions;

                     body.emit(assign(r1F6D, add(r1F6D, body.constant(int(1))), 0x01));


                  body.instructions = f1F7C_parent_instructions;
                  body.emit(f1F7C);

                  /* END IF */

                  body.emit(assign(r1F6C, r1F6D, 0x01));


               body.instructions = f1F6E_parent_instructions;
               body.emit(f1F6E);

               /* END IF */

               body.emit(assign(r1F68, add(r1F6C, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1F80 = lequal(body.constant(int(0)), r1F68);
               ir_if *f1F7F = new(mem_ctx) ir_if(operand(r1F80).val);
               exec_list *const f1F7F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1F7F->then_instructions;

                  body.emit(assign(r1F67, body.constant(0u), 0x01));

                  ir_variable *const r1F81 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r1F81, lshift(r1F66, r1F68), 0x01));

                  ir_variable *const r1F82 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1F84 = equal(r1F68, body.constant(int(0)));
                  ir_if *f1F83 = new(mem_ctx) ir_if(operand(r1F84).val);
                  exec_list *const f1F83_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1F83->then_instructions;

                     body.emit(assign(r1F82, r1F65, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1F83->else_instructions;

                     ir_expression *const r1F85 = lshift(r1F65, r1F68);
                     ir_expression *const r1F86 = neg(r1F68);
                     ir_expression *const r1F87 = bit_and(r1F86, body.constant(int(31)));
                     ir_expression *const r1F88 = rshift(r1F66, r1F87);
                     body.emit(assign(r1F82, bit_or(r1F85, r1F88), 0x01));


                  body.instructions = f1F83_parent_instructions;
                  body.emit(f1F83);

                  /* END IF */

                  body.emit(assign(r1F65, r1F82, 0x01));

                  body.emit(assign(r1F66, r1F81, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1F7F->else_instructions;

                  ir_variable *const r1F89 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r1F89, body.constant(0u), 0x01));

                  ir_variable *const r1F8A = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r1F8A, neg(r1F68), 0x01));

                  ir_variable *const r1F8B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r1F8B);
                  ir_variable *const r1F8C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1F8C);
                  ir_variable *const r1F8D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1F8D);
                  ir_variable *const r1F8E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r1F8F = neg(r1F8A);
                  body.emit(assign(r1F8E, bit_and(r1F8F, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1F91 = equal(r1F8A, body.constant(int(0)));
                  ir_if *f1F90 = new(mem_ctx) ir_if(operand(r1F91).val);
                  exec_list *const f1F90_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1F90->then_instructions;

                     body.emit(assign(r1F8B, r1F89, 0x01));

                     body.emit(assign(r1F8C, r1F66, 0x01));

                     body.emit(assign(r1F8D, r1F65, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1F90->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1F93 = less(r1F8A, body.constant(int(32)));
                     ir_if *f1F92 = new(mem_ctx) ir_if(operand(r1F93).val);
                     exec_list *const f1F92_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1F92->then_instructions;

                        body.emit(assign(r1F8B, lshift(r1F66, r1F8E), 0x01));

                        ir_expression *const r1F94 = lshift(r1F65, r1F8E);
                        ir_expression *const r1F95 = rshift(r1F66, r1F8A);
                        body.emit(assign(r1F8C, bit_or(r1F94, r1F95), 0x01));

                        body.emit(assign(r1F8D, rshift(r1F65, r1F8A), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1F92->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r1F97 = equal(r1F8A, body.constant(int(32)));
                        ir_if *f1F96 = new(mem_ctx) ir_if(operand(r1F97).val);
                        exec_list *const f1F96_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1F96->then_instructions;

                           body.emit(assign(r1F8B, r1F66, 0x01));

                           body.emit(assign(r1F8C, r1F65, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1F96->else_instructions;

                           body.emit(assign(r1F89, bit_or(body.constant(0u), r1F66), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r1F99 = less(r1F8A, body.constant(int(64)));
                           ir_if *f1F98 = new(mem_ctx) ir_if(operand(r1F99).val);
                           exec_list *const f1F98_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1F98->then_instructions;

                              body.emit(assign(r1F8B, lshift(r1F65, r1F8E), 0x01));

                              ir_expression *const r1F9A = bit_and(r1F8A, body.constant(int(31)));
                              body.emit(assign(r1F8C, rshift(r1F65, r1F9A), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1F98->else_instructions;

                              ir_variable *const r1F9B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r1F9D = equal(r1F8A, body.constant(int(64)));
                              ir_if *f1F9C = new(mem_ctx) ir_if(operand(r1F9D).val);
                              exec_list *const f1F9C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1F9C->then_instructions;

                                 body.emit(assign(r1F9B, r1F65, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1F9C->else_instructions;

                                 ir_expression *const r1F9E = nequal(r1F65, body.constant(0u));
                                 ir_expression *const r1F9F = expr(ir_unop_b2i, r1F9E);
                                 body.emit(assign(r1F9B, expr(ir_unop_i2u, r1F9F), 0x01));


                              body.instructions = f1F9C_parent_instructions;
                              body.emit(f1F9C);

                              /* END IF */

                              body.emit(assign(r1F8B, r1F9B, 0x01));

                              body.emit(assign(r1F8C, body.constant(0u), 0x01));


                           body.instructions = f1F98_parent_instructions;
                           body.emit(f1F98);

                           /* END IF */


                        body.instructions = f1F96_parent_instructions;
                        body.emit(f1F96);

                        /* END IF */

                        body.emit(assign(r1F8D, body.constant(0u), 0x01));


                     body.instructions = f1F92_parent_instructions;
                     body.emit(f1F92);

                     /* END IF */

                     ir_expression *const r1FA0 = nequal(r1F89, body.constant(0u));
                     ir_expression *const r1FA1 = expr(ir_unop_b2i, r1FA0);
                     ir_expression *const r1FA2 = expr(ir_unop_i2u, r1FA1);
                     body.emit(assign(r1F8B, bit_or(r1F8B, r1FA2), 0x01));


                  body.instructions = f1F90_parent_instructions;
                  body.emit(f1F90);

                  /* END IF */

                  body.emit(assign(r1F65, r1F8D, 0x01));

                  body.emit(assign(r1F66, r1F8C, 0x01));

                  body.emit(assign(r1F67, r1F8B, 0x01));


               body.instructions = f1F7F_parent_instructions;
               body.emit(f1F7F);

               /* END IF */

               body.emit(assign(r1F64, sub(r1F64, r1F68), 0x01));

               ir_variable *const r1FA3 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r1FA3, r1F64, 0x01));

               ir_variable *const r1FA4 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r1FA4, r1F65, 0x01));

               ir_variable *const r1FA5 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r1FA5, r1F66, 0x01));

               ir_variable *const r1FA6 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r1FA6, r1F67, 0x01));

               ir_variable *const r1FA7 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r1FA7, body.constant(true), 0x01));

               ir_variable *const r1FA8 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r1FA9 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r1FA9);
               ir_expression *const r1FAA = expr(ir_unop_u2i, r1F67);
               body.emit(assign(r1FA9, less(r1FAA, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r1FAC = lequal(body.constant(int(2045)), r1F64);
               ir_if *f1FAB = new(mem_ctx) ir_if(operand(r1FAC).val);
               exec_list *const f1FAB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1FAB->then_instructions;

                  ir_variable *const r1FAD = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1FAF = less(body.constant(int(2045)), r1F64);
                  ir_if *f1FAE = new(mem_ctx) ir_if(operand(r1FAF).val);
                  exec_list *const f1FAE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1FAE->then_instructions;

                     body.emit(assign(r1FAD, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1FAE->else_instructions;

                     ir_variable *const r1FB0 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r1FB2 = equal(r1F64, body.constant(int(2045)));
                     ir_if *f1FB1 = new(mem_ctx) ir_if(operand(r1FB2).val);
                     exec_list *const f1FB1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1FB1->then_instructions;

                        ir_expression *const r1FB3 = equal(body.constant(2097151u), r1F65);
                        ir_expression *const r1FB4 = equal(body.constant(4294967295u), r1F66);
                        body.emit(assign(r1FB0, logic_and(r1FB3, r1FB4), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1FB1->else_instructions;

                        body.emit(assign(r1FB0, body.constant(false), 0x01));


                     body.instructions = f1FB1_parent_instructions;
                     body.emit(f1FB1);

                     /* END IF */

                     body.emit(assign(r1FAD, logic_and(r1FB0, r1FA9), 0x01));


                  body.instructions = f1FAE_parent_instructions;
                  body.emit(f1FAE);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f1FB5 = new(mem_ctx) ir_if(operand(r1FAD).val);
                  exec_list *const f1FB5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1FB5->then_instructions;

                     ir_variable *const r1FB6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r1FB6);
                     ir_expression *const r1FB7 = lshift(r1E72, body.constant(int(31)));
                     body.emit(assign(r1FB6, add(r1FB7, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r1FB6, body.constant(0u), 0x01));

                     body.emit(assign(r1FA8, r1FB6, 0x03));

                     body.emit(assign(r1FA7, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1FB5->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1FB9 = less(r1F64, body.constant(int(0)));
                     ir_if *f1FB8 = new(mem_ctx) ir_if(operand(r1FB9).val);
                     exec_list *const f1FB8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1FB8->then_instructions;

                        ir_variable *const r1FBA = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r1FBA, r1F67, 0x01));

                        ir_variable *const r1FBB = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r1FBB, neg(r1F64), 0x01));

                        ir_variable *const r1FBC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r1FBC);
                        ir_variable *const r1FBD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r1FBD);
                        ir_variable *const r1FBE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r1FBE);
                        ir_variable *const r1FBF = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r1FC0 = neg(r1FBB);
                        body.emit(assign(r1FBF, bit_and(r1FC0, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r1FC2 = equal(r1FBB, body.constant(int(0)));
                        ir_if *f1FC1 = new(mem_ctx) ir_if(operand(r1FC2).val);
                        exec_list *const f1FC1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1FC1->then_instructions;

                           body.emit(assign(r1FBC, r1F67, 0x01));

                           body.emit(assign(r1FBD, r1F66, 0x01));

                           body.emit(assign(r1FBE, r1F65, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f1FC1->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r1FC4 = less(r1FBB, body.constant(int(32)));
                           ir_if *f1FC3 = new(mem_ctx) ir_if(operand(r1FC4).val);
                           exec_list *const f1FC3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f1FC3->then_instructions;

                              body.emit(assign(r1FBC, lshift(r1F66, r1FBF), 0x01));

                              ir_expression *const r1FC5 = lshift(r1F65, r1FBF);
                              ir_expression *const r1FC6 = rshift(r1F66, r1FBB);
                              body.emit(assign(r1FBD, bit_or(r1FC5, r1FC6), 0x01));

                              body.emit(assign(r1FBE, rshift(r1F65, r1FBB), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f1FC3->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r1FC8 = equal(r1FBB, body.constant(int(32)));
                              ir_if *f1FC7 = new(mem_ctx) ir_if(operand(r1FC8).val);
                              exec_list *const f1FC7_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f1FC7->then_instructions;

                                 body.emit(assign(r1FBC, r1F66, 0x01));

                                 body.emit(assign(r1FBD, r1F65, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f1FC7->else_instructions;

                                 body.emit(assign(r1FBA, bit_or(r1F67, r1F66), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r1FCA = less(r1FBB, body.constant(int(64)));
                                 ir_if *f1FC9 = new(mem_ctx) ir_if(operand(r1FCA).val);
                                 exec_list *const f1FC9_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f1FC9->then_instructions;

                                    body.emit(assign(r1FBC, lshift(r1F65, r1FBF), 0x01));

                                    ir_expression *const r1FCB = bit_and(r1FBB, body.constant(int(31)));
                                    body.emit(assign(r1FBD, rshift(r1F65, r1FCB), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f1FC9->else_instructions;

                                    ir_variable *const r1FCC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r1FCE = equal(r1FBB, body.constant(int(64)));
                                    ir_if *f1FCD = new(mem_ctx) ir_if(operand(r1FCE).val);
                                    exec_list *const f1FCD_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f1FCD->then_instructions;

                                       body.emit(assign(r1FCC, r1F65, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f1FCD->else_instructions;

                                       ir_expression *const r1FCF = nequal(r1F65, body.constant(0u));
                                       ir_expression *const r1FD0 = expr(ir_unop_b2i, r1FCF);
                                       body.emit(assign(r1FCC, expr(ir_unop_i2u, r1FD0), 0x01));


                                    body.instructions = f1FCD_parent_instructions;
                                    body.emit(f1FCD);

                                    /* END IF */

                                    body.emit(assign(r1FBC, r1FCC, 0x01));

                                    body.emit(assign(r1FBD, body.constant(0u), 0x01));


                                 body.instructions = f1FC9_parent_instructions;
                                 body.emit(f1FC9);

                                 /* END IF */


                              body.instructions = f1FC7_parent_instructions;
                              body.emit(f1FC7);

                              /* END IF */

                              body.emit(assign(r1FBE, body.constant(0u), 0x01));


                           body.instructions = f1FC3_parent_instructions;
                           body.emit(f1FC3);

                           /* END IF */

                           ir_expression *const r1FD1 = nequal(r1FBA, body.constant(0u));
                           ir_expression *const r1FD2 = expr(ir_unop_b2i, r1FD1);
                           ir_expression *const r1FD3 = expr(ir_unop_i2u, r1FD2);
                           body.emit(assign(r1FBC, bit_or(r1FBC, r1FD3), 0x01));


                        body.instructions = f1FC1_parent_instructions;
                        body.emit(f1FC1);

                        /* END IF */

                        body.emit(assign(r1FA4, r1FBE, 0x01));

                        body.emit(assign(r1FA5, r1FBD, 0x01));

                        body.emit(assign(r1FA6, r1FBC, 0x01));

                        body.emit(assign(r1FA3, body.constant(int(0)), 0x01));

                        body.emit(assign(r1FA9, less(r1FBC, body.constant(0u)), 0x01));


                     body.instructions = f1FB8_parent_instructions;
                     body.emit(f1FB8);

                     /* END IF */


                  body.instructions = f1FB5_parent_instructions;
                  body.emit(f1FB5);

                  /* END IF */


               body.instructions = f1FAB_parent_instructions;
               body.emit(f1FAB);

               /* END IF */

               /* IF CONDITION */
               ir_if *f1FD4 = new(mem_ctx) ir_if(operand(r1FA7).val);
               exec_list *const f1FD4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1FD4->then_instructions;

                  /* IF CONDITION */
                  ir_if *f1FD5 = new(mem_ctx) ir_if(operand(r1FA9).val);
                  exec_list *const f1FD5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1FD5->then_instructions;

                     ir_variable *const r1FD6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r1FD6, add(r1FA5, body.constant(1u)), 0x01));

                     ir_expression *const r1FD7 = less(r1FD6, r1FA5);
                     ir_expression *const r1FD8 = expr(ir_unop_b2i, r1FD7);
                     ir_expression *const r1FD9 = expr(ir_unop_i2u, r1FD8);
                     body.emit(assign(r1FA4, add(r1FA4, r1FD9), 0x01));

                     ir_expression *const r1FDA = equal(r1FA6, body.constant(0u));
                     ir_expression *const r1FDB = expr(ir_unop_b2i, r1FDA);
                     ir_expression *const r1FDC = expr(ir_unop_i2u, r1FDB);
                     ir_expression *const r1FDD = add(r1FA6, r1FDC);
                     ir_expression *const r1FDE = bit_and(r1FDD, body.constant(1u));
                     ir_expression *const r1FDF = expr(ir_unop_bit_not, r1FDE);
                     body.emit(assign(r1FA5, bit_and(r1FD6, r1FDF), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1FD5->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1FE1 = bit_or(r1FA4, r1FA5);
                     ir_expression *const r1FE2 = equal(r1FE1, body.constant(0u));
                     ir_if *f1FE0 = new(mem_ctx) ir_if(operand(r1FE2).val);
                     exec_list *const f1FE0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1FE0->then_instructions;

                        body.emit(assign(r1FA3, body.constant(int(0)), 0x01));


                     body.instructions = f1FE0_parent_instructions;
                     body.emit(f1FE0);

                     /* END IF */


                  body.instructions = f1FD5_parent_instructions;
                  body.emit(f1FD5);

                  /* END IF */

                  ir_variable *const r1FE3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1FE3);
                  ir_expression *const r1FE4 = lshift(r1E72, body.constant(int(31)));
                  ir_expression *const r1FE5 = expr(ir_unop_i2u, r1FA3);
                  ir_expression *const r1FE6 = lshift(r1FE5, body.constant(int(20)));
                  ir_expression *const r1FE7 = add(r1FE4, r1FE6);
                  body.emit(assign(r1FE3, add(r1FE7, r1FA4), 0x02));

                  body.emit(assign(r1FE3, r1FA5, 0x01));

                  body.emit(assign(r1FA8, r1FE3, 0x03));

                  body.emit(assign(r1FA7, body.constant(false), 0x01));


               body.instructions = f1FD4_parent_instructions;
               body.emit(f1FD4);

               /* END IF */

               body.emit(assign(r1E73, r1FA8, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1F37->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1FE9 = equal(r1E7B, body.constant(int(2047)));
               ir_if *f1FE8 = new(mem_ctx) ir_if(operand(r1FE9).val);
               exec_list *const f1FE8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1FE8->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1FEB = bit_or(swizzle_y(r1E78), swizzle_x(r1E78));
                  ir_expression *const r1FEC = bit_or(swizzle_y(r1E76), swizzle_x(r1E76));
                  ir_expression *const r1FED = bit_or(r1FEB, r1FEC);
                  ir_expression *const r1FEE = nequal(r1FED, body.constant(0u));
                  ir_if *f1FEA = new(mem_ctx) ir_if(operand(r1FEE).val);
                  exec_list *const f1FEA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1FEA->then_instructions;

                     ir_variable *const r1FEF = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r1FEF, swizzle_x(r1E39), 0x01));

                     ir_variable *const r1FF0 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r1FF0, body.constant(0u), 0x01));

                     ir_variable *const r1FF1 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r1FEF, bit_or(swizzle_y(r1E39), body.constant(524288u)), 0x02));

                     body.emit(assign(r1FF0, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r1FF3 = lshift(swizzle_y(r1E39), body.constant(int(1)));
                     ir_expression *const r1FF4 = lequal(body.constant(4292870144u), r1FF3);
                     ir_expression *const r1FF5 = nequal(swizzle_x(r1E39), body.constant(0u));
                     ir_expression *const r1FF6 = bit_and(swizzle_y(r1E39), body.constant(1048575u));
                     ir_expression *const r1FF7 = nequal(r1FF6, body.constant(0u));
                     ir_expression *const r1FF8 = logic_or(r1FF5, r1FF7);
                     ir_expression *const r1FF9 = logic_and(r1FF4, r1FF8);
                     ir_if *f1FF2 = new(mem_ctx) ir_if(operand(r1FF9).val);
                     exec_list *const f1FF2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1FF2->then_instructions;

                        body.emit(assign(r1FF1, r1FEF, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f1FF2->else_instructions;

                        body.emit(assign(r1FF1, r1FF0, 0x03));


                     body.instructions = f1FF2_parent_instructions;
                     body.emit(f1FF2);

                     /* END IF */

                     body.emit(assign(r1E73, r1FF1, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1FEA->else_instructions;

                     ir_constant_data r1FFA_data;
                     memset(&r1FFA_data, 0, sizeof(ir_constant_data));
                     r1FFA_data.u[0] = 4294967295;
                     r1FFA_data.u[1] = 4294967295;
                     ir_constant *const r1FFA = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r1FFA_data);
                     body.emit(assign(r1E73, r1FFA, 0x03));


                  body.instructions = f1FEA_parent_instructions;
                  body.emit(f1FEA);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1FE8->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1FFC = equal(r1E7B, body.constant(int(0)));
                  ir_if *f1FFB = new(mem_ctx) ir_if(operand(r1FFC).val);
                  exec_list *const f1FFB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1FFB->then_instructions;

                     body.emit(assign(r1E77, body.constant(int(1)), 0x01));

                     body.emit(assign(r1E75, body.constant(int(1)), 0x01));


                  body.instructions = f1FFB_parent_instructions;
                  body.emit(f1FFB);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r1FFE = less(swizzle_y(r1E76), swizzle_y(r1E78));
                  ir_if *f1FFD = new(mem_ctx) ir_if(operand(r1FFE).val);
                  exec_list *const f1FFD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1FFD->then_instructions;

                     ir_variable *const r1FFF = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r2000 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r2000, sub(swizzle_x(r1E78), swizzle_x(r1E76)), 0x01));

                     ir_expression *const r2001 = sub(swizzle_y(r1E78), swizzle_y(r1E76));
                     ir_expression *const r2002 = less(swizzle_x(r1E78), swizzle_x(r1E76));
                     ir_expression *const r2003 = expr(ir_unop_b2i, r2002);
                     ir_expression *const r2004 = expr(ir_unop_i2u, r2003);
                     body.emit(assign(r1FFF, sub(r2001, r2004), 0x01));

                     body.emit(assign(r1E79, add(r1E77, body.constant(int(-1))), 0x01));

                     ir_variable *const r2005 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r2005, add(r1E79, body.constant(int(-10))), 0x01));

                     ir_variable *const r2006 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r2006, r1FFF, 0x01));

                     ir_variable *const r2007 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r2007, r2000, 0x01));

                     ir_variable *const r2008 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r2008);
                     ir_variable *const r2009 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r2009);
                     /* IF CONDITION */
                     ir_expression *const r200B = equal(r1FFF, body.constant(0u));
                     ir_if *f200A = new(mem_ctx) ir_if(operand(r200B).val);
                     exec_list *const f200A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f200A->then_instructions;

                        body.emit(assign(r2006, r2000, 0x01));

                        body.emit(assign(r2007, body.constant(0u), 0x01));

                        body.emit(assign(r2005, add(r2005, body.constant(int(-32))), 0x01));


                     body.instructions = f200A_parent_instructions;
                     body.emit(f200A);

                     /* END IF */

                     ir_variable *const r200C = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r200C, r2006, 0x01));

                     ir_variable *const r200D = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r200E = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r200E);
                     /* IF CONDITION */
                     ir_expression *const r2010 = equal(r2006, body.constant(0u));
                     ir_if *f200F = new(mem_ctx) ir_if(operand(r2010).val);
                     exec_list *const f200F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f200F->then_instructions;

                        body.emit(assign(r200D, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f200F->else_instructions;

                        body.emit(assign(r200E, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2012 = bit_and(r2006, body.constant(4294901760u));
                        ir_expression *const r2013 = equal(r2012, body.constant(0u));
                        ir_if *f2011 = new(mem_ctx) ir_if(operand(r2013).val);
                        exec_list *const f2011_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2011->then_instructions;

                           body.emit(assign(r200E, body.constant(int(16)), 0x01));

                           body.emit(assign(r200C, lshift(r2006, body.constant(int(16))), 0x01));


                        body.instructions = f2011_parent_instructions;
                        body.emit(f2011);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2015 = bit_and(r200C, body.constant(4278190080u));
                        ir_expression *const r2016 = equal(r2015, body.constant(0u));
                        ir_if *f2014 = new(mem_ctx) ir_if(operand(r2016).val);
                        exec_list *const f2014_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2014->then_instructions;

                           body.emit(assign(r200E, add(r200E, body.constant(int(8))), 0x01));

                           body.emit(assign(r200C, lshift(r200C, body.constant(int(8))), 0x01));


                        body.instructions = f2014_parent_instructions;
                        body.emit(f2014);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2018 = bit_and(r200C, body.constant(4026531840u));
                        ir_expression *const r2019 = equal(r2018, body.constant(0u));
                        ir_if *f2017 = new(mem_ctx) ir_if(operand(r2019).val);
                        exec_list *const f2017_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2017->then_instructions;

                           body.emit(assign(r200E, add(r200E, body.constant(int(4))), 0x01));

                           body.emit(assign(r200C, lshift(r200C, body.constant(int(4))), 0x01));


                        body.instructions = f2017_parent_instructions;
                        body.emit(f2017);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r201B = bit_and(r200C, body.constant(3221225472u));
                        ir_expression *const r201C = equal(r201B, body.constant(0u));
                        ir_if *f201A = new(mem_ctx) ir_if(operand(r201C).val);
                        exec_list *const f201A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f201A->then_instructions;

                           body.emit(assign(r200E, add(r200E, body.constant(int(2))), 0x01));

                           body.emit(assign(r200C, lshift(r200C, body.constant(int(2))), 0x01));


                        body.instructions = f201A_parent_instructions;
                        body.emit(f201A);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r201E = bit_and(r200C, body.constant(2147483648u));
                        ir_expression *const r201F = equal(r201E, body.constant(0u));
                        ir_if *f201D = new(mem_ctx) ir_if(operand(r201F).val);
                        exec_list *const f201D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f201D->then_instructions;

                           body.emit(assign(r200E, add(r200E, body.constant(int(1))), 0x01));


                        body.instructions = f201D_parent_instructions;
                        body.emit(f201D);

                        /* END IF */

                        body.emit(assign(r200D, r200E, 0x01));


                     body.instructions = f200F_parent_instructions;
                     body.emit(f200F);

                     /* END IF */

                     body.emit(assign(r2009, add(r200D, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2021 = lequal(body.constant(int(0)), r2009);
                     ir_if *f2020 = new(mem_ctx) ir_if(operand(r2021).val);
                     exec_list *const f2020_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2020->then_instructions;

                        body.emit(assign(r2008, body.constant(0u), 0x01));

                        ir_variable *const r2022 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r2022, lshift(r2007, r2009), 0x01));

                        ir_variable *const r2023 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2025 = equal(r2009, body.constant(int(0)));
                        ir_if *f2024 = new(mem_ctx) ir_if(operand(r2025).val);
                        exec_list *const f2024_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2024->then_instructions;

                           body.emit(assign(r2023, r2006, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2024->else_instructions;

                           ir_expression *const r2026 = lshift(r2006, r2009);
                           ir_expression *const r2027 = neg(r2009);
                           ir_expression *const r2028 = bit_and(r2027, body.constant(int(31)));
                           ir_expression *const r2029 = rshift(r2007, r2028);
                           body.emit(assign(r2023, bit_or(r2026, r2029), 0x01));


                        body.instructions = f2024_parent_instructions;
                        body.emit(f2024);

                        /* END IF */

                        body.emit(assign(r2006, r2023, 0x01));

                        body.emit(assign(r2007, r2022, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2020->else_instructions;

                        ir_variable *const r202A = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r202A, body.constant(0u), 0x01));

                        ir_variable *const r202B = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r202B, neg(r2009), 0x01));

                        ir_variable *const r202C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r202C);
                        ir_variable *const r202D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r202D);
                        ir_variable *const r202E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r202E);
                        ir_variable *const r202F = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2030 = neg(r202B);
                        body.emit(assign(r202F, bit_and(r2030, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2032 = equal(r202B, body.constant(int(0)));
                        ir_if *f2031 = new(mem_ctx) ir_if(operand(r2032).val);
                        exec_list *const f2031_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2031->then_instructions;

                           body.emit(assign(r202C, r202A, 0x01));

                           body.emit(assign(r202D, r2007, 0x01));

                           body.emit(assign(r202E, r2006, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2031->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2034 = less(r202B, body.constant(int(32)));
                           ir_if *f2033 = new(mem_ctx) ir_if(operand(r2034).val);
                           exec_list *const f2033_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2033->then_instructions;

                              body.emit(assign(r202C, lshift(r2007, r202F), 0x01));

                              ir_expression *const r2035 = lshift(r2006, r202F);
                              ir_expression *const r2036 = rshift(r2007, r202B);
                              body.emit(assign(r202D, bit_or(r2035, r2036), 0x01));

                              body.emit(assign(r202E, rshift(r2006, r202B), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2033->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2038 = equal(r202B, body.constant(int(32)));
                              ir_if *f2037 = new(mem_ctx) ir_if(operand(r2038).val);
                              exec_list *const f2037_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2037->then_instructions;

                                 body.emit(assign(r202C, r2007, 0x01));

                                 body.emit(assign(r202D, r2006, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2037->else_instructions;

                                 body.emit(assign(r202A, bit_or(body.constant(0u), r2007), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r203A = less(r202B, body.constant(int(64)));
                                 ir_if *f2039 = new(mem_ctx) ir_if(operand(r203A).val);
                                 exec_list *const f2039_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2039->then_instructions;

                                    body.emit(assign(r202C, lshift(r2006, r202F), 0x01));

                                    ir_expression *const r203B = bit_and(r202B, body.constant(int(31)));
                                    body.emit(assign(r202D, rshift(r2006, r203B), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2039->else_instructions;

                                    ir_variable *const r203C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r203E = equal(r202B, body.constant(int(64)));
                                    ir_if *f203D = new(mem_ctx) ir_if(operand(r203E).val);
                                    exec_list *const f203D_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f203D->then_instructions;

                                       body.emit(assign(r203C, r2006, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f203D->else_instructions;

                                       ir_expression *const r203F = nequal(r2006, body.constant(0u));
                                       ir_expression *const r2040 = expr(ir_unop_b2i, r203F);
                                       body.emit(assign(r203C, expr(ir_unop_i2u, r2040), 0x01));


                                    body.instructions = f203D_parent_instructions;
                                    body.emit(f203D);

                                    /* END IF */

                                    body.emit(assign(r202C, r203C, 0x01));

                                    body.emit(assign(r202D, body.constant(0u), 0x01));


                                 body.instructions = f2039_parent_instructions;
                                 body.emit(f2039);

                                 /* END IF */


                              body.instructions = f2037_parent_instructions;
                              body.emit(f2037);

                              /* END IF */

                              body.emit(assign(r202E, body.constant(0u), 0x01));


                           body.instructions = f2033_parent_instructions;
                           body.emit(f2033);

                           /* END IF */

                           ir_expression *const r2041 = nequal(r202A, body.constant(0u));
                           ir_expression *const r2042 = expr(ir_unop_b2i, r2041);
                           ir_expression *const r2043 = expr(ir_unop_i2u, r2042);
                           body.emit(assign(r202C, bit_or(r202C, r2043), 0x01));


                        body.instructions = f2031_parent_instructions;
                        body.emit(f2031);

                        /* END IF */

                        body.emit(assign(r2006, r202E, 0x01));

                        body.emit(assign(r2007, r202D, 0x01));

                        body.emit(assign(r2008, r202C, 0x01));


                     body.instructions = f2020_parent_instructions;
                     body.emit(f2020);

                     /* END IF */

                     body.emit(assign(r2005, sub(r2005, r2009), 0x01));

                     ir_variable *const r2044 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r2044, r2005, 0x01));

                     ir_variable *const r2045 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r2045, r2006, 0x01));

                     ir_variable *const r2046 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r2046, r2007, 0x01));

                     ir_variable *const r2047 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r2047, r2008, 0x01));

                     ir_variable *const r2048 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r2048, body.constant(true), 0x01));

                     ir_variable *const r2049 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r204A = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r204A);
                     ir_expression *const r204B = expr(ir_unop_u2i, r2008);
                     body.emit(assign(r204A, less(r204B, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r204D = lequal(body.constant(int(2045)), r2005);
                     ir_if *f204C = new(mem_ctx) ir_if(operand(r204D).val);
                     exec_list *const f204C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f204C->then_instructions;

                        ir_variable *const r204E = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2050 = less(body.constant(int(2045)), r2005);
                        ir_if *f204F = new(mem_ctx) ir_if(operand(r2050).val);
                        exec_list *const f204F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f204F->then_instructions;

                           body.emit(assign(r204E, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f204F->else_instructions;

                           ir_variable *const r2051 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2053 = equal(r2005, body.constant(int(2045)));
                           ir_if *f2052 = new(mem_ctx) ir_if(operand(r2053).val);
                           exec_list *const f2052_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2052->then_instructions;

                              ir_expression *const r2054 = equal(body.constant(2097151u), r2006);
                              ir_expression *const r2055 = equal(body.constant(4294967295u), r2007);
                              body.emit(assign(r2051, logic_and(r2054, r2055), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2052->else_instructions;

                              body.emit(assign(r2051, body.constant(false), 0x01));


                           body.instructions = f2052_parent_instructions;
                           body.emit(f2052);

                           /* END IF */

                           body.emit(assign(r204E, logic_and(r2051, r204A), 0x01));


                        body.instructions = f204F_parent_instructions;
                        body.emit(f204F);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f2056 = new(mem_ctx) ir_if(operand(r204E).val);
                        exec_list *const f2056_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2056->then_instructions;

                           ir_variable *const r2057 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r2057);
                           ir_expression *const r2058 = lshift(r1E72, body.constant(int(31)));
                           body.emit(assign(r2057, add(r2058, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r2057, body.constant(0u), 0x01));

                           body.emit(assign(r2049, r2057, 0x03));

                           body.emit(assign(r2048, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2056->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r205A = less(r2005, body.constant(int(0)));
                           ir_if *f2059 = new(mem_ctx) ir_if(operand(r205A).val);
                           exec_list *const f2059_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2059->then_instructions;

                              ir_variable *const r205B = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r205B, r2008, 0x01));

                              ir_variable *const r205C = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r205C, neg(r2005), 0x01));

                              ir_variable *const r205D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r205D);
                              ir_variable *const r205E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r205E);
                              ir_variable *const r205F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r205F);
                              ir_variable *const r2060 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r2061 = neg(r205C);
                              body.emit(assign(r2060, bit_and(r2061, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2063 = equal(r205C, body.constant(int(0)));
                              ir_if *f2062 = new(mem_ctx) ir_if(operand(r2063).val);
                              exec_list *const f2062_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2062->then_instructions;

                                 body.emit(assign(r205D, r2008, 0x01));

                                 body.emit(assign(r205E, r2007, 0x01));

                                 body.emit(assign(r205F, r2006, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2062->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2065 = less(r205C, body.constant(int(32)));
                                 ir_if *f2064 = new(mem_ctx) ir_if(operand(r2065).val);
                                 exec_list *const f2064_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2064->then_instructions;

                                    body.emit(assign(r205D, lshift(r2007, r2060), 0x01));

                                    ir_expression *const r2066 = lshift(r2006, r2060);
                                    ir_expression *const r2067 = rshift(r2007, r205C);
                                    body.emit(assign(r205E, bit_or(r2066, r2067), 0x01));

                                    body.emit(assign(r205F, rshift(r2006, r205C), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2064->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2069 = equal(r205C, body.constant(int(32)));
                                    ir_if *f2068 = new(mem_ctx) ir_if(operand(r2069).val);
                                    exec_list *const f2068_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2068->then_instructions;

                                       body.emit(assign(r205D, r2007, 0x01));

                                       body.emit(assign(r205E, r2006, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2068->else_instructions;

                                       body.emit(assign(r205B, bit_or(r2008, r2007), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r206B = less(r205C, body.constant(int(64)));
                                       ir_if *f206A = new(mem_ctx) ir_if(operand(r206B).val);
                                       exec_list *const f206A_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f206A->then_instructions;

                                          body.emit(assign(r205D, lshift(r2006, r2060), 0x01));

                                          ir_expression *const r206C = bit_and(r205C, body.constant(int(31)));
                                          body.emit(assign(r205E, rshift(r2006, r206C), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f206A->else_instructions;

                                          ir_variable *const r206D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r206F = equal(r205C, body.constant(int(64)));
                                          ir_if *f206E = new(mem_ctx) ir_if(operand(r206F).val);
                                          exec_list *const f206E_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f206E->then_instructions;

                                             body.emit(assign(r206D, r2006, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f206E->else_instructions;

                                             ir_expression *const r2070 = nequal(r2006, body.constant(0u));
                                             ir_expression *const r2071 = expr(ir_unop_b2i, r2070);
                                             body.emit(assign(r206D, expr(ir_unop_i2u, r2071), 0x01));


                                          body.instructions = f206E_parent_instructions;
                                          body.emit(f206E);

                                          /* END IF */

                                          body.emit(assign(r205D, r206D, 0x01));

                                          body.emit(assign(r205E, body.constant(0u), 0x01));


                                       body.instructions = f206A_parent_instructions;
                                       body.emit(f206A);

                                       /* END IF */


                                    body.instructions = f2068_parent_instructions;
                                    body.emit(f2068);

                                    /* END IF */

                                    body.emit(assign(r205F, body.constant(0u), 0x01));


                                 body.instructions = f2064_parent_instructions;
                                 body.emit(f2064);

                                 /* END IF */

                                 ir_expression *const r2072 = nequal(r205B, body.constant(0u));
                                 ir_expression *const r2073 = expr(ir_unop_b2i, r2072);
                                 ir_expression *const r2074 = expr(ir_unop_i2u, r2073);
                                 body.emit(assign(r205D, bit_or(r205D, r2074), 0x01));


                              body.instructions = f2062_parent_instructions;
                              body.emit(f2062);

                              /* END IF */

                              body.emit(assign(r2045, r205F, 0x01));

                              body.emit(assign(r2046, r205E, 0x01));

                              body.emit(assign(r2047, r205D, 0x01));

                              body.emit(assign(r2044, body.constant(int(0)), 0x01));

                              body.emit(assign(r204A, less(r205D, body.constant(0u)), 0x01));


                           body.instructions = f2059_parent_instructions;
                           body.emit(f2059);

                           /* END IF */


                        body.instructions = f2056_parent_instructions;
                        body.emit(f2056);

                        /* END IF */


                     body.instructions = f204C_parent_instructions;
                     body.emit(f204C);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f2075 = new(mem_ctx) ir_if(operand(r2048).val);
                     exec_list *const f2075_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2075->then_instructions;

                        /* IF CONDITION */
                        ir_if *f2076 = new(mem_ctx) ir_if(operand(r204A).val);
                        exec_list *const f2076_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2076->then_instructions;

                           ir_variable *const r2077 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r2077, add(r2046, body.constant(1u)), 0x01));

                           ir_expression *const r2078 = less(r2077, r2046);
                           ir_expression *const r2079 = expr(ir_unop_b2i, r2078);
                           ir_expression *const r207A = expr(ir_unop_i2u, r2079);
                           body.emit(assign(r2045, add(r2045, r207A), 0x01));

                           ir_expression *const r207B = equal(r2047, body.constant(0u));
                           ir_expression *const r207C = expr(ir_unop_b2i, r207B);
                           ir_expression *const r207D = expr(ir_unop_i2u, r207C);
                           ir_expression *const r207E = add(r2047, r207D);
                           ir_expression *const r207F = bit_and(r207E, body.constant(1u));
                           ir_expression *const r2080 = expr(ir_unop_bit_not, r207F);
                           body.emit(assign(r2046, bit_and(r2077, r2080), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2076->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2082 = bit_or(r2045, r2046);
                           ir_expression *const r2083 = equal(r2082, body.constant(0u));
                           ir_if *f2081 = new(mem_ctx) ir_if(operand(r2083).val);
                           exec_list *const f2081_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2081->then_instructions;

                              body.emit(assign(r2044, body.constant(int(0)), 0x01));


                           body.instructions = f2081_parent_instructions;
                           body.emit(f2081);

                           /* END IF */


                        body.instructions = f2076_parent_instructions;
                        body.emit(f2076);

                        /* END IF */

                        ir_variable *const r2084 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r2084);
                        ir_expression *const r2085 = lshift(r1E72, body.constant(int(31)));
                        ir_expression *const r2086 = expr(ir_unop_i2u, r2044);
                        ir_expression *const r2087 = lshift(r2086, body.constant(int(20)));
                        ir_expression *const r2088 = add(r2085, r2087);
                        body.emit(assign(r2084, add(r2088, r2045), 0x02));

                        body.emit(assign(r2084, r2046, 0x01));

                        body.emit(assign(r2049, r2084, 0x03));

                        body.emit(assign(r2048, body.constant(false), 0x01));


                     body.instructions = f2075_parent_instructions;
                     body.emit(f2075);

                     /* END IF */

                     body.emit(assign(r1E73, r2049, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1FFD->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r208A = less(swizzle_y(r1E78), swizzle_y(r1E76));
                     ir_if *f2089 = new(mem_ctx) ir_if(operand(r208A).val);
                     exec_list *const f2089_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2089->then_instructions;

                        ir_variable *const r208B = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r208C = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r208C, sub(swizzle_x(r1E76), swizzle_x(r1E78)), 0x01));

                        ir_expression *const r208D = sub(swizzle_y(r1E76), swizzle_y(r1E78));
                        ir_expression *const r208E = less(swizzle_x(r1E76), swizzle_x(r1E78));
                        ir_expression *const r208F = expr(ir_unop_b2i, r208E);
                        ir_expression *const r2090 = expr(ir_unop_i2u, r208F);
                        body.emit(assign(r208B, sub(r208D, r2090), 0x01));

                        body.emit(assign(r1E72, bit_xor(r1E72, body.constant(1u)), 0x01));

                        body.emit(assign(r1E79, add(r1E75, body.constant(int(-1))), 0x01));

                        ir_variable *const r2091 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r2091, add(r1E79, body.constant(int(-10))), 0x01));

                        ir_variable *const r2092 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r2092, r208B, 0x01));

                        ir_variable *const r2093 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r2093, r208C, 0x01));

                        ir_variable *const r2094 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r2094);
                        ir_variable *const r2095 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r2095);
                        /* IF CONDITION */
                        ir_expression *const r2097 = equal(r208B, body.constant(0u));
                        ir_if *f2096 = new(mem_ctx) ir_if(operand(r2097).val);
                        exec_list *const f2096_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2096->then_instructions;

                           body.emit(assign(r2092, r208C, 0x01));

                           body.emit(assign(r2093, body.constant(0u), 0x01));

                           body.emit(assign(r2091, add(r2091, body.constant(int(-32))), 0x01));


                        body.instructions = f2096_parent_instructions;
                        body.emit(f2096);

                        /* END IF */

                        ir_variable *const r2098 = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r2098, r2092, 0x01));

                        ir_variable *const r2099 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r209A = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r209A);
                        /* IF CONDITION */
                        ir_expression *const r209C = equal(r2092, body.constant(0u));
                        ir_if *f209B = new(mem_ctx) ir_if(operand(r209C).val);
                        exec_list *const f209B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f209B->then_instructions;

                           body.emit(assign(r2099, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f209B->else_instructions;

                           body.emit(assign(r209A, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r209E = bit_and(r2092, body.constant(4294901760u));
                           ir_expression *const r209F = equal(r209E, body.constant(0u));
                           ir_if *f209D = new(mem_ctx) ir_if(operand(r209F).val);
                           exec_list *const f209D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f209D->then_instructions;

                              body.emit(assign(r209A, body.constant(int(16)), 0x01));

                              body.emit(assign(r2098, lshift(r2092, body.constant(int(16))), 0x01));


                           body.instructions = f209D_parent_instructions;
                           body.emit(f209D);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r20A1 = bit_and(r2098, body.constant(4278190080u));
                           ir_expression *const r20A2 = equal(r20A1, body.constant(0u));
                           ir_if *f20A0 = new(mem_ctx) ir_if(operand(r20A2).val);
                           exec_list *const f20A0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f20A0->then_instructions;

                              body.emit(assign(r209A, add(r209A, body.constant(int(8))), 0x01));

                              body.emit(assign(r2098, lshift(r2098, body.constant(int(8))), 0x01));


                           body.instructions = f20A0_parent_instructions;
                           body.emit(f20A0);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r20A4 = bit_and(r2098, body.constant(4026531840u));
                           ir_expression *const r20A5 = equal(r20A4, body.constant(0u));
                           ir_if *f20A3 = new(mem_ctx) ir_if(operand(r20A5).val);
                           exec_list *const f20A3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f20A3->then_instructions;

                              body.emit(assign(r209A, add(r209A, body.constant(int(4))), 0x01));

                              body.emit(assign(r2098, lshift(r2098, body.constant(int(4))), 0x01));


                           body.instructions = f20A3_parent_instructions;
                           body.emit(f20A3);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r20A7 = bit_and(r2098, body.constant(3221225472u));
                           ir_expression *const r20A8 = equal(r20A7, body.constant(0u));
                           ir_if *f20A6 = new(mem_ctx) ir_if(operand(r20A8).val);
                           exec_list *const f20A6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f20A6->then_instructions;

                              body.emit(assign(r209A, add(r209A, body.constant(int(2))), 0x01));

                              body.emit(assign(r2098, lshift(r2098, body.constant(int(2))), 0x01));


                           body.instructions = f20A6_parent_instructions;
                           body.emit(f20A6);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r20AA = bit_and(r2098, body.constant(2147483648u));
                           ir_expression *const r20AB = equal(r20AA, body.constant(0u));
                           ir_if *f20A9 = new(mem_ctx) ir_if(operand(r20AB).val);
                           exec_list *const f20A9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f20A9->then_instructions;

                              body.emit(assign(r209A, add(r209A, body.constant(int(1))), 0x01));


                           body.instructions = f20A9_parent_instructions;
                           body.emit(f20A9);

                           /* END IF */

                           body.emit(assign(r2099, r209A, 0x01));


                        body.instructions = f209B_parent_instructions;
                        body.emit(f209B);

                        /* END IF */

                        body.emit(assign(r2095, add(r2099, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r20AD = lequal(body.constant(int(0)), r2095);
                        ir_if *f20AC = new(mem_ctx) ir_if(operand(r20AD).val);
                        exec_list *const f20AC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f20AC->then_instructions;

                           body.emit(assign(r2094, body.constant(0u), 0x01));

                           ir_variable *const r20AE = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r20AE, lshift(r2093, r2095), 0x01));

                           ir_variable *const r20AF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r20B1 = equal(r2095, body.constant(int(0)));
                           ir_if *f20B0 = new(mem_ctx) ir_if(operand(r20B1).val);
                           exec_list *const f20B0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f20B0->then_instructions;

                              body.emit(assign(r20AF, r2092, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f20B0->else_instructions;

                              ir_expression *const r20B2 = lshift(r2092, r2095);
                              ir_expression *const r20B3 = neg(r2095);
                              ir_expression *const r20B4 = bit_and(r20B3, body.constant(int(31)));
                              ir_expression *const r20B5 = rshift(r2093, r20B4);
                              body.emit(assign(r20AF, bit_or(r20B2, r20B5), 0x01));


                           body.instructions = f20B0_parent_instructions;
                           body.emit(f20B0);

                           /* END IF */

                           body.emit(assign(r2092, r20AF, 0x01));

                           body.emit(assign(r2093, r20AE, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f20AC->else_instructions;

                           ir_variable *const r20B6 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r20B6, body.constant(0u), 0x01));

                           ir_variable *const r20B7 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r20B7, neg(r2095), 0x01));

                           ir_variable *const r20B8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r20B8);
                           ir_variable *const r20B9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r20B9);
                           ir_variable *const r20BA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r20BA);
                           ir_variable *const r20BB = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r20BC = neg(r20B7);
                           body.emit(assign(r20BB, bit_and(r20BC, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r20BE = equal(r20B7, body.constant(int(0)));
                           ir_if *f20BD = new(mem_ctx) ir_if(operand(r20BE).val);
                           exec_list *const f20BD_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f20BD->then_instructions;

                              body.emit(assign(r20B8, r20B6, 0x01));

                              body.emit(assign(r20B9, r2093, 0x01));

                              body.emit(assign(r20BA, r2092, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f20BD->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r20C0 = less(r20B7, body.constant(int(32)));
                              ir_if *f20BF = new(mem_ctx) ir_if(operand(r20C0).val);
                              exec_list *const f20BF_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f20BF->then_instructions;

                                 body.emit(assign(r20B8, lshift(r2093, r20BB), 0x01));

                                 ir_expression *const r20C1 = lshift(r2092, r20BB);
                                 ir_expression *const r20C2 = rshift(r2093, r20B7);
                                 body.emit(assign(r20B9, bit_or(r20C1, r20C2), 0x01));

                                 body.emit(assign(r20BA, rshift(r2092, r20B7), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f20BF->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r20C4 = equal(r20B7, body.constant(int(32)));
                                 ir_if *f20C3 = new(mem_ctx) ir_if(operand(r20C4).val);
                                 exec_list *const f20C3_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f20C3->then_instructions;

                                    body.emit(assign(r20B8, r2093, 0x01));

                                    body.emit(assign(r20B9, r2092, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f20C3->else_instructions;

                                    body.emit(assign(r20B6, bit_or(body.constant(0u), r2093), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r20C6 = less(r20B7, body.constant(int(64)));
                                    ir_if *f20C5 = new(mem_ctx) ir_if(operand(r20C6).val);
                                    exec_list *const f20C5_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f20C5->then_instructions;

                                       body.emit(assign(r20B8, lshift(r2092, r20BB), 0x01));

                                       ir_expression *const r20C7 = bit_and(r20B7, body.constant(int(31)));
                                       body.emit(assign(r20B9, rshift(r2092, r20C7), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f20C5->else_instructions;

                                       ir_variable *const r20C8 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r20CA = equal(r20B7, body.constant(int(64)));
                                       ir_if *f20C9 = new(mem_ctx) ir_if(operand(r20CA).val);
                                       exec_list *const f20C9_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f20C9->then_instructions;

                                          body.emit(assign(r20C8, r2092, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f20C9->else_instructions;

                                          ir_expression *const r20CB = nequal(r2092, body.constant(0u));
                                          ir_expression *const r20CC = expr(ir_unop_b2i, r20CB);
                                          body.emit(assign(r20C8, expr(ir_unop_i2u, r20CC), 0x01));


                                       body.instructions = f20C9_parent_instructions;
                                       body.emit(f20C9);

                                       /* END IF */

                                       body.emit(assign(r20B8, r20C8, 0x01));

                                       body.emit(assign(r20B9, body.constant(0u), 0x01));


                                    body.instructions = f20C5_parent_instructions;
                                    body.emit(f20C5);

                                    /* END IF */


                                 body.instructions = f20C3_parent_instructions;
                                 body.emit(f20C3);

                                 /* END IF */

                                 body.emit(assign(r20BA, body.constant(0u), 0x01));


                              body.instructions = f20BF_parent_instructions;
                              body.emit(f20BF);

                              /* END IF */

                              ir_expression *const r20CD = nequal(r20B6, body.constant(0u));
                              ir_expression *const r20CE = expr(ir_unop_b2i, r20CD);
                              ir_expression *const r20CF = expr(ir_unop_i2u, r20CE);
                              body.emit(assign(r20B8, bit_or(r20B8, r20CF), 0x01));


                           body.instructions = f20BD_parent_instructions;
                           body.emit(f20BD);

                           /* END IF */

                           body.emit(assign(r2092, r20BA, 0x01));

                           body.emit(assign(r2093, r20B9, 0x01));

                           body.emit(assign(r2094, r20B8, 0x01));


                        body.instructions = f20AC_parent_instructions;
                        body.emit(f20AC);

                        /* END IF */

                        body.emit(assign(r2091, sub(r2091, r2095), 0x01));

                        ir_variable *const r20D0 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r20D0, r2091, 0x01));

                        ir_variable *const r20D1 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r20D1, r2092, 0x01));

                        ir_variable *const r20D2 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r20D2, r2093, 0x01));

                        ir_variable *const r20D3 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r20D3, r2094, 0x01));

                        ir_variable *const r20D4 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r20D4, body.constant(true), 0x01));

                        ir_variable *const r20D5 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r20D6 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r20D6);
                        ir_expression *const r20D7 = expr(ir_unop_u2i, r2094);
                        body.emit(assign(r20D6, less(r20D7, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r20D9 = lequal(body.constant(int(2045)), r2091);
                        ir_if *f20D8 = new(mem_ctx) ir_if(operand(r20D9).val);
                        exec_list *const f20D8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f20D8->then_instructions;

                           ir_variable *const r20DA = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r20DC = less(body.constant(int(2045)), r2091);
                           ir_if *f20DB = new(mem_ctx) ir_if(operand(r20DC).val);
                           exec_list *const f20DB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f20DB->then_instructions;

                              body.emit(assign(r20DA, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f20DB->else_instructions;

                              ir_variable *const r20DD = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r20DF = equal(r2091, body.constant(int(2045)));
                              ir_if *f20DE = new(mem_ctx) ir_if(operand(r20DF).val);
                              exec_list *const f20DE_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f20DE->then_instructions;

                                 ir_expression *const r20E0 = equal(body.constant(2097151u), r2092);
                                 ir_expression *const r20E1 = equal(body.constant(4294967295u), r2093);
                                 body.emit(assign(r20DD, logic_and(r20E0, r20E1), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f20DE->else_instructions;

                                 body.emit(assign(r20DD, body.constant(false), 0x01));


                              body.instructions = f20DE_parent_instructions;
                              body.emit(f20DE);

                              /* END IF */

                              body.emit(assign(r20DA, logic_and(r20DD, r20D6), 0x01));


                           body.instructions = f20DB_parent_instructions;
                           body.emit(f20DB);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f20E2 = new(mem_ctx) ir_if(operand(r20DA).val);
                           exec_list *const f20E2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f20E2->then_instructions;

                              ir_variable *const r20E3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r20E3);
                              ir_expression *const r20E4 = lshift(r1E72, body.constant(int(31)));
                              body.emit(assign(r20E3, add(r20E4, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r20E3, body.constant(0u), 0x01));

                              body.emit(assign(r20D5, r20E3, 0x03));

                              body.emit(assign(r20D4, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f20E2->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r20E6 = less(r2091, body.constant(int(0)));
                              ir_if *f20E5 = new(mem_ctx) ir_if(operand(r20E6).val);
                              exec_list *const f20E5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f20E5->then_instructions;

                                 ir_variable *const r20E7 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r20E7, r2094, 0x01));

                                 ir_variable *const r20E8 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r20E8, neg(r2091), 0x01));

                                 ir_variable *const r20E9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r20E9);
                                 ir_variable *const r20EA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r20EA);
                                 ir_variable *const r20EB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r20EB);
                                 ir_variable *const r20EC = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r20ED = neg(r20E8);
                                 body.emit(assign(r20EC, bit_and(r20ED, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r20EF = equal(r20E8, body.constant(int(0)));
                                 ir_if *f20EE = new(mem_ctx) ir_if(operand(r20EF).val);
                                 exec_list *const f20EE_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f20EE->then_instructions;

                                    body.emit(assign(r20E9, r2094, 0x01));

                                    body.emit(assign(r20EA, r2093, 0x01));

                                    body.emit(assign(r20EB, r2092, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f20EE->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r20F1 = less(r20E8, body.constant(int(32)));
                                    ir_if *f20F0 = new(mem_ctx) ir_if(operand(r20F1).val);
                                    exec_list *const f20F0_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f20F0->then_instructions;

                                       body.emit(assign(r20E9, lshift(r2093, r20EC), 0x01));

                                       ir_expression *const r20F2 = lshift(r2092, r20EC);
                                       ir_expression *const r20F3 = rshift(r2093, r20E8);
                                       body.emit(assign(r20EA, bit_or(r20F2, r20F3), 0x01));

                                       body.emit(assign(r20EB, rshift(r2092, r20E8), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f20F0->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r20F5 = equal(r20E8, body.constant(int(32)));
                                       ir_if *f20F4 = new(mem_ctx) ir_if(operand(r20F5).val);
                                       exec_list *const f20F4_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f20F4->then_instructions;

                                          body.emit(assign(r20E9, r2093, 0x01));

                                          body.emit(assign(r20EA, r2092, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f20F4->else_instructions;

                                          body.emit(assign(r20E7, bit_or(r2094, r2093), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r20F7 = less(r20E8, body.constant(int(64)));
                                          ir_if *f20F6 = new(mem_ctx) ir_if(operand(r20F7).val);
                                          exec_list *const f20F6_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f20F6->then_instructions;

                                             body.emit(assign(r20E9, lshift(r2092, r20EC), 0x01));

                                             ir_expression *const r20F8 = bit_and(r20E8, body.constant(int(31)));
                                             body.emit(assign(r20EA, rshift(r2092, r20F8), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f20F6->else_instructions;

                                             ir_variable *const r20F9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r20FB = equal(r20E8, body.constant(int(64)));
                                             ir_if *f20FA = new(mem_ctx) ir_if(operand(r20FB).val);
                                             exec_list *const f20FA_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f20FA->then_instructions;

                                                body.emit(assign(r20F9, r2092, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f20FA->else_instructions;

                                                ir_expression *const r20FC = nequal(r2092, body.constant(0u));
                                                ir_expression *const r20FD = expr(ir_unop_b2i, r20FC);
                                                body.emit(assign(r20F9, expr(ir_unop_i2u, r20FD), 0x01));


                                             body.instructions = f20FA_parent_instructions;
                                             body.emit(f20FA);

                                             /* END IF */

                                             body.emit(assign(r20E9, r20F9, 0x01));

                                             body.emit(assign(r20EA, body.constant(0u), 0x01));


                                          body.instructions = f20F6_parent_instructions;
                                          body.emit(f20F6);

                                          /* END IF */


                                       body.instructions = f20F4_parent_instructions;
                                       body.emit(f20F4);

                                       /* END IF */

                                       body.emit(assign(r20EB, body.constant(0u), 0x01));


                                    body.instructions = f20F0_parent_instructions;
                                    body.emit(f20F0);

                                    /* END IF */

                                    ir_expression *const r20FE = nequal(r20E7, body.constant(0u));
                                    ir_expression *const r20FF = expr(ir_unop_b2i, r20FE);
                                    ir_expression *const r2100 = expr(ir_unop_i2u, r20FF);
                                    body.emit(assign(r20E9, bit_or(r20E9, r2100), 0x01));


                                 body.instructions = f20EE_parent_instructions;
                                 body.emit(f20EE);

                                 /* END IF */

                                 body.emit(assign(r20D1, r20EB, 0x01));

                                 body.emit(assign(r20D2, r20EA, 0x01));

                                 body.emit(assign(r20D3, r20E9, 0x01));

                                 body.emit(assign(r20D0, body.constant(int(0)), 0x01));

                                 body.emit(assign(r20D6, less(r20E9, body.constant(0u)), 0x01));


                              body.instructions = f20E5_parent_instructions;
                              body.emit(f20E5);

                              /* END IF */


                           body.instructions = f20E2_parent_instructions;
                           body.emit(f20E2);

                           /* END IF */


                        body.instructions = f20D8_parent_instructions;
                        body.emit(f20D8);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f2101 = new(mem_ctx) ir_if(operand(r20D4).val);
                        exec_list *const f2101_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2101->then_instructions;

                           /* IF CONDITION */
                           ir_if *f2102 = new(mem_ctx) ir_if(operand(r20D6).val);
                           exec_list *const f2102_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2102->then_instructions;

                              ir_variable *const r2103 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r2103, add(r20D2, body.constant(1u)), 0x01));

                              ir_expression *const r2104 = less(r2103, r20D2);
                              ir_expression *const r2105 = expr(ir_unop_b2i, r2104);
                              ir_expression *const r2106 = expr(ir_unop_i2u, r2105);
                              body.emit(assign(r20D1, add(r20D1, r2106), 0x01));

                              ir_expression *const r2107 = equal(r20D3, body.constant(0u));
                              ir_expression *const r2108 = expr(ir_unop_b2i, r2107);
                              ir_expression *const r2109 = expr(ir_unop_i2u, r2108);
                              ir_expression *const r210A = add(r20D3, r2109);
                              ir_expression *const r210B = bit_and(r210A, body.constant(1u));
                              ir_expression *const r210C = expr(ir_unop_bit_not, r210B);
                              body.emit(assign(r20D2, bit_and(r2103, r210C), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2102->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r210E = bit_or(r20D1, r20D2);
                              ir_expression *const r210F = equal(r210E, body.constant(0u));
                              ir_if *f210D = new(mem_ctx) ir_if(operand(r210F).val);
                              exec_list *const f210D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f210D->then_instructions;

                                 body.emit(assign(r20D0, body.constant(int(0)), 0x01));


                              body.instructions = f210D_parent_instructions;
                              body.emit(f210D);

                              /* END IF */


                           body.instructions = f2102_parent_instructions;
                           body.emit(f2102);

                           /* END IF */

                           ir_variable *const r2110 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r2110);
                           ir_expression *const r2111 = lshift(r1E72, body.constant(int(31)));
                           ir_expression *const r2112 = expr(ir_unop_i2u, r20D0);
                           ir_expression *const r2113 = lshift(r2112, body.constant(int(20)));
                           ir_expression *const r2114 = add(r2111, r2113);
                           body.emit(assign(r2110, add(r2114, r20D1), 0x02));

                           body.emit(assign(r2110, r20D2, 0x01));

                           body.emit(assign(r20D5, r2110, 0x03));

                           body.emit(assign(r20D4, body.constant(false), 0x01));


                        body.instructions = f2101_parent_instructions;
                        body.emit(f2101);

                        /* END IF */

                        body.emit(assign(r1E73, r20D5, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2089->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2116 = less(swizzle_x(r1E76), swizzle_x(r1E78));
                        ir_if *f2115 = new(mem_ctx) ir_if(operand(r2116).val);
                        exec_list *const f2115_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2115->then_instructions;

                           ir_variable *const r2117 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r2118 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r2118, sub(swizzle_x(r1E78), swizzle_x(r1E76)), 0x01));

                           ir_expression *const r2119 = sub(swizzle_y(r1E78), swizzle_y(r1E76));
                           ir_expression *const r211A = less(swizzle_x(r1E78), swizzle_x(r1E76));
                           ir_expression *const r211B = expr(ir_unop_b2i, r211A);
                           ir_expression *const r211C = expr(ir_unop_i2u, r211B);
                           body.emit(assign(r2117, sub(r2119, r211C), 0x01));

                           body.emit(assign(r1E79, add(r1E77, body.constant(int(-1))), 0x01));

                           ir_variable *const r211D = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r211D, add(r1E79, body.constant(int(-10))), 0x01));

                           ir_variable *const r211E = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r211E, r2117, 0x01));

                           ir_variable *const r211F = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r211F, r2118, 0x01));

                           ir_variable *const r2120 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r2120);
                           ir_variable *const r2121 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r2121);
                           /* IF CONDITION */
                           ir_expression *const r2123 = equal(r2117, body.constant(0u));
                           ir_if *f2122 = new(mem_ctx) ir_if(operand(r2123).val);
                           exec_list *const f2122_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2122->then_instructions;

                              body.emit(assign(r211E, r2118, 0x01));

                              body.emit(assign(r211F, body.constant(0u), 0x01));

                              body.emit(assign(r211D, add(r211D, body.constant(int(-32))), 0x01));


                           body.instructions = f2122_parent_instructions;
                           body.emit(f2122);

                           /* END IF */

                           ir_variable *const r2124 = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r2124, r211E, 0x01));

                           ir_variable *const r2125 = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r2126 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r2126);
                           /* IF CONDITION */
                           ir_expression *const r2128 = equal(r211E, body.constant(0u));
                           ir_if *f2127 = new(mem_ctx) ir_if(operand(r2128).val);
                           exec_list *const f2127_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2127->then_instructions;

                              body.emit(assign(r2125, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2127->else_instructions;

                              body.emit(assign(r2126, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r212A = bit_and(r211E, body.constant(4294901760u));
                              ir_expression *const r212B = equal(r212A, body.constant(0u));
                              ir_if *f2129 = new(mem_ctx) ir_if(operand(r212B).val);
                              exec_list *const f2129_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2129->then_instructions;

                                 body.emit(assign(r2126, body.constant(int(16)), 0x01));

                                 body.emit(assign(r2124, lshift(r211E, body.constant(int(16))), 0x01));


                              body.instructions = f2129_parent_instructions;
                              body.emit(f2129);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r212D = bit_and(r2124, body.constant(4278190080u));
                              ir_expression *const r212E = equal(r212D, body.constant(0u));
                              ir_if *f212C = new(mem_ctx) ir_if(operand(r212E).val);
                              exec_list *const f212C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f212C->then_instructions;

                                 body.emit(assign(r2126, add(r2126, body.constant(int(8))), 0x01));

                                 body.emit(assign(r2124, lshift(r2124, body.constant(int(8))), 0x01));


                              body.instructions = f212C_parent_instructions;
                              body.emit(f212C);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2130 = bit_and(r2124, body.constant(4026531840u));
                              ir_expression *const r2131 = equal(r2130, body.constant(0u));
                              ir_if *f212F = new(mem_ctx) ir_if(operand(r2131).val);
                              exec_list *const f212F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f212F->then_instructions;

                                 body.emit(assign(r2126, add(r2126, body.constant(int(4))), 0x01));

                                 body.emit(assign(r2124, lshift(r2124, body.constant(int(4))), 0x01));


                              body.instructions = f212F_parent_instructions;
                              body.emit(f212F);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2133 = bit_and(r2124, body.constant(3221225472u));
                              ir_expression *const r2134 = equal(r2133, body.constant(0u));
                              ir_if *f2132 = new(mem_ctx) ir_if(operand(r2134).val);
                              exec_list *const f2132_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2132->then_instructions;

                                 body.emit(assign(r2126, add(r2126, body.constant(int(2))), 0x01));

                                 body.emit(assign(r2124, lshift(r2124, body.constant(int(2))), 0x01));


                              body.instructions = f2132_parent_instructions;
                              body.emit(f2132);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2136 = bit_and(r2124, body.constant(2147483648u));
                              ir_expression *const r2137 = equal(r2136, body.constant(0u));
                              ir_if *f2135 = new(mem_ctx) ir_if(operand(r2137).val);
                              exec_list *const f2135_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2135->then_instructions;

                                 body.emit(assign(r2126, add(r2126, body.constant(int(1))), 0x01));


                              body.instructions = f2135_parent_instructions;
                              body.emit(f2135);

                              /* END IF */

                              body.emit(assign(r2125, r2126, 0x01));


                           body.instructions = f2127_parent_instructions;
                           body.emit(f2127);

                           /* END IF */

                           body.emit(assign(r2121, add(r2125, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2139 = lequal(body.constant(int(0)), r2121);
                           ir_if *f2138 = new(mem_ctx) ir_if(operand(r2139).val);
                           exec_list *const f2138_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2138->then_instructions;

                              body.emit(assign(r2120, body.constant(0u), 0x01));

                              ir_variable *const r213A = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r213A, lshift(r211F, r2121), 0x01));

                              ir_variable *const r213B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r213D = equal(r2121, body.constant(int(0)));
                              ir_if *f213C = new(mem_ctx) ir_if(operand(r213D).val);
                              exec_list *const f213C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f213C->then_instructions;

                                 body.emit(assign(r213B, r211E, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f213C->else_instructions;

                                 ir_expression *const r213E = lshift(r211E, r2121);
                                 ir_expression *const r213F = neg(r2121);
                                 ir_expression *const r2140 = bit_and(r213F, body.constant(int(31)));
                                 ir_expression *const r2141 = rshift(r211F, r2140);
                                 body.emit(assign(r213B, bit_or(r213E, r2141), 0x01));


                              body.instructions = f213C_parent_instructions;
                              body.emit(f213C);

                              /* END IF */

                              body.emit(assign(r211E, r213B, 0x01));

                              body.emit(assign(r211F, r213A, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2138->else_instructions;

                              ir_variable *const r2142 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r2142, body.constant(0u), 0x01));

                              ir_variable *const r2143 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r2143, neg(r2121), 0x01));

                              ir_variable *const r2144 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r2144);
                              ir_variable *const r2145 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r2145);
                              ir_variable *const r2146 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r2146);
                              ir_variable *const r2147 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r2148 = neg(r2143);
                              body.emit(assign(r2147, bit_and(r2148, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r214A = equal(r2143, body.constant(int(0)));
                              ir_if *f2149 = new(mem_ctx) ir_if(operand(r214A).val);
                              exec_list *const f2149_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2149->then_instructions;

                                 body.emit(assign(r2144, r2142, 0x01));

                                 body.emit(assign(r2145, r211F, 0x01));

                                 body.emit(assign(r2146, r211E, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2149->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r214C = less(r2143, body.constant(int(32)));
                                 ir_if *f214B = new(mem_ctx) ir_if(operand(r214C).val);
                                 exec_list *const f214B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f214B->then_instructions;

                                    body.emit(assign(r2144, lshift(r211F, r2147), 0x01));

                                    ir_expression *const r214D = lshift(r211E, r2147);
                                    ir_expression *const r214E = rshift(r211F, r2143);
                                    body.emit(assign(r2145, bit_or(r214D, r214E), 0x01));

                                    body.emit(assign(r2146, rshift(r211E, r2143), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f214B->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2150 = equal(r2143, body.constant(int(32)));
                                    ir_if *f214F = new(mem_ctx) ir_if(operand(r2150).val);
                                    exec_list *const f214F_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f214F->then_instructions;

                                       body.emit(assign(r2144, r211F, 0x01));

                                       body.emit(assign(r2145, r211E, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f214F->else_instructions;

                                       body.emit(assign(r2142, bit_or(body.constant(0u), r211F), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2152 = less(r2143, body.constant(int(64)));
                                       ir_if *f2151 = new(mem_ctx) ir_if(operand(r2152).val);
                                       exec_list *const f2151_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2151->then_instructions;

                                          body.emit(assign(r2144, lshift(r211E, r2147), 0x01));

                                          ir_expression *const r2153 = bit_and(r2143, body.constant(int(31)));
                                          body.emit(assign(r2145, rshift(r211E, r2153), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2151->else_instructions;

                                          ir_variable *const r2154 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r2156 = equal(r2143, body.constant(int(64)));
                                          ir_if *f2155 = new(mem_ctx) ir_if(operand(r2156).val);
                                          exec_list *const f2155_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2155->then_instructions;

                                             body.emit(assign(r2154, r211E, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2155->else_instructions;

                                             ir_expression *const r2157 = nequal(r211E, body.constant(0u));
                                             ir_expression *const r2158 = expr(ir_unop_b2i, r2157);
                                             body.emit(assign(r2154, expr(ir_unop_i2u, r2158), 0x01));


                                          body.instructions = f2155_parent_instructions;
                                          body.emit(f2155);

                                          /* END IF */

                                          body.emit(assign(r2144, r2154, 0x01));

                                          body.emit(assign(r2145, body.constant(0u), 0x01));


                                       body.instructions = f2151_parent_instructions;
                                       body.emit(f2151);

                                       /* END IF */


                                    body.instructions = f214F_parent_instructions;
                                    body.emit(f214F);

                                    /* END IF */

                                    body.emit(assign(r2146, body.constant(0u), 0x01));


                                 body.instructions = f214B_parent_instructions;
                                 body.emit(f214B);

                                 /* END IF */

                                 ir_expression *const r2159 = nequal(r2142, body.constant(0u));
                                 ir_expression *const r215A = expr(ir_unop_b2i, r2159);
                                 ir_expression *const r215B = expr(ir_unop_i2u, r215A);
                                 body.emit(assign(r2144, bit_or(r2144, r215B), 0x01));


                              body.instructions = f2149_parent_instructions;
                              body.emit(f2149);

                              /* END IF */

                              body.emit(assign(r211E, r2146, 0x01));

                              body.emit(assign(r211F, r2145, 0x01));

                              body.emit(assign(r2120, r2144, 0x01));


                           body.instructions = f2138_parent_instructions;
                           body.emit(f2138);

                           /* END IF */

                           body.emit(assign(r211D, sub(r211D, r2121), 0x01));

                           ir_variable *const r215C = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r215C, r211D, 0x01));

                           ir_variable *const r215D = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r215D, r211E, 0x01));

                           ir_variable *const r215E = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r215E, r211F, 0x01));

                           ir_variable *const r215F = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r215F, r2120, 0x01));

                           ir_variable *const r2160 = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r2160, body.constant(true), 0x01));

                           ir_variable *const r2161 = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r2162 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r2162);
                           ir_expression *const r2163 = expr(ir_unop_u2i, r2120);
                           body.emit(assign(r2162, less(r2163, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2165 = lequal(body.constant(int(2045)), r211D);
                           ir_if *f2164 = new(mem_ctx) ir_if(operand(r2165).val);
                           exec_list *const f2164_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2164->then_instructions;

                              ir_variable *const r2166 = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2168 = less(body.constant(int(2045)), r211D);
                              ir_if *f2167 = new(mem_ctx) ir_if(operand(r2168).val);
                              exec_list *const f2167_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2167->then_instructions;

                                 body.emit(assign(r2166, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2167->else_instructions;

                                 ir_variable *const r2169 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r216B = equal(r211D, body.constant(int(2045)));
                                 ir_if *f216A = new(mem_ctx) ir_if(operand(r216B).val);
                                 exec_list *const f216A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f216A->then_instructions;

                                    ir_expression *const r216C = equal(body.constant(2097151u), r211E);
                                    ir_expression *const r216D = equal(body.constant(4294967295u), r211F);
                                    body.emit(assign(r2169, logic_and(r216C, r216D), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f216A->else_instructions;

                                    body.emit(assign(r2169, body.constant(false), 0x01));


                                 body.instructions = f216A_parent_instructions;
                                 body.emit(f216A);

                                 /* END IF */

                                 body.emit(assign(r2166, logic_and(r2169, r2162), 0x01));


                              body.instructions = f2167_parent_instructions;
                              body.emit(f2167);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f216E = new(mem_ctx) ir_if(operand(r2166).val);
                              exec_list *const f216E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f216E->then_instructions;

                                 ir_variable *const r216F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r216F);
                                 ir_expression *const r2170 = lshift(r1E72, body.constant(int(31)));
                                 body.emit(assign(r216F, add(r2170, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r216F, body.constant(0u), 0x01));

                                 body.emit(assign(r2161, r216F, 0x03));

                                 body.emit(assign(r2160, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f216E->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2172 = less(r211D, body.constant(int(0)));
                                 ir_if *f2171 = new(mem_ctx) ir_if(operand(r2172).val);
                                 exec_list *const f2171_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2171->then_instructions;

                                    ir_variable *const r2173 = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r2173, r2120, 0x01));

                                    ir_variable *const r2174 = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r2174, neg(r211D), 0x01));

                                    ir_variable *const r2175 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r2175);
                                    ir_variable *const r2176 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r2176);
                                    ir_variable *const r2177 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r2177);
                                    ir_variable *const r2178 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r2179 = neg(r2174);
                                    body.emit(assign(r2178, bit_and(r2179, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r217B = equal(r2174, body.constant(int(0)));
                                    ir_if *f217A = new(mem_ctx) ir_if(operand(r217B).val);
                                    exec_list *const f217A_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f217A->then_instructions;

                                       body.emit(assign(r2175, r2120, 0x01));

                                       body.emit(assign(r2176, r211F, 0x01));

                                       body.emit(assign(r2177, r211E, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f217A->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r217D = less(r2174, body.constant(int(32)));
                                       ir_if *f217C = new(mem_ctx) ir_if(operand(r217D).val);
                                       exec_list *const f217C_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f217C->then_instructions;

                                          body.emit(assign(r2175, lshift(r211F, r2178), 0x01));

                                          ir_expression *const r217E = lshift(r211E, r2178);
                                          ir_expression *const r217F = rshift(r211F, r2174);
                                          body.emit(assign(r2176, bit_or(r217E, r217F), 0x01));

                                          body.emit(assign(r2177, rshift(r211E, r2174), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f217C->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r2181 = equal(r2174, body.constant(int(32)));
                                          ir_if *f2180 = new(mem_ctx) ir_if(operand(r2181).val);
                                          exec_list *const f2180_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2180->then_instructions;

                                             body.emit(assign(r2175, r211F, 0x01));

                                             body.emit(assign(r2176, r211E, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2180->else_instructions;

                                             body.emit(assign(r2173, bit_or(r2120, r211F), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r2183 = less(r2174, body.constant(int(64)));
                                             ir_if *f2182 = new(mem_ctx) ir_if(operand(r2183).val);
                                             exec_list *const f2182_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2182->then_instructions;

                                                body.emit(assign(r2175, lshift(r211E, r2178), 0x01));

                                                ir_expression *const r2184 = bit_and(r2174, body.constant(int(31)));
                                                body.emit(assign(r2176, rshift(r211E, r2184), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2182->else_instructions;

                                                ir_variable *const r2185 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r2187 = equal(r2174, body.constant(int(64)));
                                                ir_if *f2186 = new(mem_ctx) ir_if(operand(r2187).val);
                                                exec_list *const f2186_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f2186->then_instructions;

                                                   body.emit(assign(r2185, r211E, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f2186->else_instructions;

                                                   ir_expression *const r2188 = nequal(r211E, body.constant(0u));
                                                   ir_expression *const r2189 = expr(ir_unop_b2i, r2188);
                                                   body.emit(assign(r2185, expr(ir_unop_i2u, r2189), 0x01));


                                                body.instructions = f2186_parent_instructions;
                                                body.emit(f2186);

                                                /* END IF */

                                                body.emit(assign(r2175, r2185, 0x01));

                                                body.emit(assign(r2176, body.constant(0u), 0x01));


                                             body.instructions = f2182_parent_instructions;
                                             body.emit(f2182);

                                             /* END IF */


                                          body.instructions = f2180_parent_instructions;
                                          body.emit(f2180);

                                          /* END IF */

                                          body.emit(assign(r2177, body.constant(0u), 0x01));


                                       body.instructions = f217C_parent_instructions;
                                       body.emit(f217C);

                                       /* END IF */

                                       ir_expression *const r218A = nequal(r2173, body.constant(0u));
                                       ir_expression *const r218B = expr(ir_unop_b2i, r218A);
                                       ir_expression *const r218C = expr(ir_unop_i2u, r218B);
                                       body.emit(assign(r2175, bit_or(r2175, r218C), 0x01));


                                    body.instructions = f217A_parent_instructions;
                                    body.emit(f217A);

                                    /* END IF */

                                    body.emit(assign(r215D, r2177, 0x01));

                                    body.emit(assign(r215E, r2176, 0x01));

                                    body.emit(assign(r215F, r2175, 0x01));

                                    body.emit(assign(r215C, body.constant(int(0)), 0x01));

                                    body.emit(assign(r2162, less(r2175, body.constant(0u)), 0x01));


                                 body.instructions = f2171_parent_instructions;
                                 body.emit(f2171);

                                 /* END IF */


                              body.instructions = f216E_parent_instructions;
                              body.emit(f216E);

                              /* END IF */


                           body.instructions = f2164_parent_instructions;
                           body.emit(f2164);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f218D = new(mem_ctx) ir_if(operand(r2160).val);
                           exec_list *const f218D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f218D->then_instructions;

                              /* IF CONDITION */
                              ir_if *f218E = new(mem_ctx) ir_if(operand(r2162).val);
                              exec_list *const f218E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f218E->then_instructions;

                                 ir_variable *const r218F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r218F, add(r215E, body.constant(1u)), 0x01));

                                 ir_expression *const r2190 = less(r218F, r215E);
                                 ir_expression *const r2191 = expr(ir_unop_b2i, r2190);
                                 ir_expression *const r2192 = expr(ir_unop_i2u, r2191);
                                 body.emit(assign(r215D, add(r215D, r2192), 0x01));

                                 ir_expression *const r2193 = equal(r215F, body.constant(0u));
                                 ir_expression *const r2194 = expr(ir_unop_b2i, r2193);
                                 ir_expression *const r2195 = expr(ir_unop_i2u, r2194);
                                 ir_expression *const r2196 = add(r215F, r2195);
                                 ir_expression *const r2197 = bit_and(r2196, body.constant(1u));
                                 ir_expression *const r2198 = expr(ir_unop_bit_not, r2197);
                                 body.emit(assign(r215E, bit_and(r218F, r2198), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f218E->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r219A = bit_or(r215D, r215E);
                                 ir_expression *const r219B = equal(r219A, body.constant(0u));
                                 ir_if *f2199 = new(mem_ctx) ir_if(operand(r219B).val);
                                 exec_list *const f2199_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2199->then_instructions;

                                    body.emit(assign(r215C, body.constant(int(0)), 0x01));


                                 body.instructions = f2199_parent_instructions;
                                 body.emit(f2199);

                                 /* END IF */


                              body.instructions = f218E_parent_instructions;
                              body.emit(f218E);

                              /* END IF */

                              ir_variable *const r219C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r219C);
                              ir_expression *const r219D = lshift(r1E72, body.constant(int(31)));
                              ir_expression *const r219E = expr(ir_unop_i2u, r215C);
                              ir_expression *const r219F = lshift(r219E, body.constant(int(20)));
                              ir_expression *const r21A0 = add(r219D, r219F);
                              body.emit(assign(r219C, add(r21A0, r215D), 0x02));

                              body.emit(assign(r219C, r215E, 0x01));

                              body.emit(assign(r2161, r219C, 0x03));

                              body.emit(assign(r2160, body.constant(false), 0x01));


                           body.instructions = f218D_parent_instructions;
                           body.emit(f218D);

                           /* END IF */

                           body.emit(assign(r1E73, r2161, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2115->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r21A2 = less(swizzle_x(r1E78), swizzle_x(r1E76));
                           ir_if *f21A1 = new(mem_ctx) ir_if(operand(r21A2).val);
                           exec_list *const f21A1_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f21A1->then_instructions;

                              ir_variable *const r21A3 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                              ir_variable *const r21A4 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r21A4, sub(swizzle_x(r1E76), swizzle_x(r1E78)), 0x01));

                              ir_expression *const r21A5 = sub(swizzle_y(r1E76), swizzle_y(r1E78));
                              ir_expression *const r21A6 = less(swizzle_x(r1E76), swizzle_x(r1E78));
                              ir_expression *const r21A7 = expr(ir_unop_b2i, r21A6);
                              ir_expression *const r21A8 = expr(ir_unop_i2u, r21A7);
                              body.emit(assign(r21A3, sub(r21A5, r21A8), 0x01));

                              body.emit(assign(r1E72, bit_xor(r1E72, body.constant(1u)), 0x01));

                              body.emit(assign(r1E79, add(r1E75, body.constant(int(-1))), 0x01));

                              ir_variable *const r21A9 = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r21A9, add(r1E79, body.constant(int(-10))), 0x01));

                              ir_variable *const r21AA = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r21AA, r21A3, 0x01));

                              ir_variable *const r21AB = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r21AB, r21A4, 0x01));

                              ir_variable *const r21AC = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                              body.emit(r21AC);
                              ir_variable *const r21AD = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r21AD);
                              /* IF CONDITION */
                              ir_expression *const r21AF = equal(r21A3, body.constant(0u));
                              ir_if *f21AE = new(mem_ctx) ir_if(operand(r21AF).val);
                              exec_list *const f21AE_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f21AE->then_instructions;

                                 body.emit(assign(r21AA, r21A4, 0x01));

                                 body.emit(assign(r21AB, body.constant(0u), 0x01));

                                 body.emit(assign(r21A9, add(r21A9, body.constant(int(-32))), 0x01));


                              body.instructions = f21AE_parent_instructions;
                              body.emit(f21AE);

                              /* END IF */

                              ir_variable *const r21B0 = body.make_temp(glsl_type::uint_type, "a");
                              body.emit(assign(r21B0, r21AA, 0x01));

                              ir_variable *const r21B1 = body.make_temp(glsl_type::int_type, "return_value");
                              ir_variable *const r21B2 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r21B2);
                              /* IF CONDITION */
                              ir_expression *const r21B4 = equal(r21AA, body.constant(0u));
                              ir_if *f21B3 = new(mem_ctx) ir_if(operand(r21B4).val);
                              exec_list *const f21B3_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f21B3->then_instructions;

                                 body.emit(assign(r21B1, body.constant(int(32)), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f21B3->else_instructions;

                                 body.emit(assign(r21B2, body.constant(int(0)), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r21B6 = bit_and(r21AA, body.constant(4294901760u));
                                 ir_expression *const r21B7 = equal(r21B6, body.constant(0u));
                                 ir_if *f21B5 = new(mem_ctx) ir_if(operand(r21B7).val);
                                 exec_list *const f21B5_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f21B5->then_instructions;

                                    body.emit(assign(r21B2, body.constant(int(16)), 0x01));

                                    body.emit(assign(r21B0, lshift(r21AA, body.constant(int(16))), 0x01));


                                 body.instructions = f21B5_parent_instructions;
                                 body.emit(f21B5);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r21B9 = bit_and(r21B0, body.constant(4278190080u));
                                 ir_expression *const r21BA = equal(r21B9, body.constant(0u));
                                 ir_if *f21B8 = new(mem_ctx) ir_if(operand(r21BA).val);
                                 exec_list *const f21B8_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f21B8->then_instructions;

                                    body.emit(assign(r21B2, add(r21B2, body.constant(int(8))), 0x01));

                                    body.emit(assign(r21B0, lshift(r21B0, body.constant(int(8))), 0x01));


                                 body.instructions = f21B8_parent_instructions;
                                 body.emit(f21B8);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r21BC = bit_and(r21B0, body.constant(4026531840u));
                                 ir_expression *const r21BD = equal(r21BC, body.constant(0u));
                                 ir_if *f21BB = new(mem_ctx) ir_if(operand(r21BD).val);
                                 exec_list *const f21BB_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f21BB->then_instructions;

                                    body.emit(assign(r21B2, add(r21B2, body.constant(int(4))), 0x01));

                                    body.emit(assign(r21B0, lshift(r21B0, body.constant(int(4))), 0x01));


                                 body.instructions = f21BB_parent_instructions;
                                 body.emit(f21BB);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r21BF = bit_and(r21B0, body.constant(3221225472u));
                                 ir_expression *const r21C0 = equal(r21BF, body.constant(0u));
                                 ir_if *f21BE = new(mem_ctx) ir_if(operand(r21C0).val);
                                 exec_list *const f21BE_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f21BE->then_instructions;

                                    body.emit(assign(r21B2, add(r21B2, body.constant(int(2))), 0x01));

                                    body.emit(assign(r21B0, lshift(r21B0, body.constant(int(2))), 0x01));


                                 body.instructions = f21BE_parent_instructions;
                                 body.emit(f21BE);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r21C2 = bit_and(r21B0, body.constant(2147483648u));
                                 ir_expression *const r21C3 = equal(r21C2, body.constant(0u));
                                 ir_if *f21C1 = new(mem_ctx) ir_if(operand(r21C3).val);
                                 exec_list *const f21C1_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f21C1->then_instructions;

                                    body.emit(assign(r21B2, add(r21B2, body.constant(int(1))), 0x01));


                                 body.instructions = f21C1_parent_instructions;
                                 body.emit(f21C1);

                                 /* END IF */

                                 body.emit(assign(r21B1, r21B2, 0x01));


                              body.instructions = f21B3_parent_instructions;
                              body.emit(f21B3);

                              /* END IF */

                              body.emit(assign(r21AD, add(r21B1, body.constant(int(-11))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r21C5 = lequal(body.constant(int(0)), r21AD);
                              ir_if *f21C4 = new(mem_ctx) ir_if(operand(r21C5).val);
                              exec_list *const f21C4_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f21C4->then_instructions;

                                 body.emit(assign(r21AC, body.constant(0u), 0x01));

                                 ir_variable *const r21C6 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                                 body.emit(assign(r21C6, lshift(r21AB, r21AD), 0x01));

                                 ir_variable *const r21C7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r21C9 = equal(r21AD, body.constant(int(0)));
                                 ir_if *f21C8 = new(mem_ctx) ir_if(operand(r21C9).val);
                                 exec_list *const f21C8_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f21C8->then_instructions;

                                    body.emit(assign(r21C7, r21AA, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f21C8->else_instructions;

                                    ir_expression *const r21CA = lshift(r21AA, r21AD);
                                    ir_expression *const r21CB = neg(r21AD);
                                    ir_expression *const r21CC = bit_and(r21CB, body.constant(int(31)));
                                    ir_expression *const r21CD = rshift(r21AB, r21CC);
                                    body.emit(assign(r21C7, bit_or(r21CA, r21CD), 0x01));


                                 body.instructions = f21C8_parent_instructions;
                                 body.emit(f21C8);

                                 /* END IF */

                                 body.emit(assign(r21AA, r21C7, 0x01));

                                 body.emit(assign(r21AB, r21C6, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f21C4->else_instructions;

                                 ir_variable *const r21CE = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r21CE, body.constant(0u), 0x01));

                                 ir_variable *const r21CF = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r21CF, neg(r21AD), 0x01));

                                 ir_variable *const r21D0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r21D0);
                                 ir_variable *const r21D1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r21D1);
                                 ir_variable *const r21D2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r21D2);
                                 ir_variable *const r21D3 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r21D4 = neg(r21CF);
                                 body.emit(assign(r21D3, bit_and(r21D4, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r21D6 = equal(r21CF, body.constant(int(0)));
                                 ir_if *f21D5 = new(mem_ctx) ir_if(operand(r21D6).val);
                                 exec_list *const f21D5_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f21D5->then_instructions;

                                    body.emit(assign(r21D0, r21CE, 0x01));

                                    body.emit(assign(r21D1, r21AB, 0x01));

                                    body.emit(assign(r21D2, r21AA, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f21D5->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r21D8 = less(r21CF, body.constant(int(32)));
                                    ir_if *f21D7 = new(mem_ctx) ir_if(operand(r21D8).val);
                                    exec_list *const f21D7_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f21D7->then_instructions;

                                       body.emit(assign(r21D0, lshift(r21AB, r21D3), 0x01));

                                       ir_expression *const r21D9 = lshift(r21AA, r21D3);
                                       ir_expression *const r21DA = rshift(r21AB, r21CF);
                                       body.emit(assign(r21D1, bit_or(r21D9, r21DA), 0x01));

                                       body.emit(assign(r21D2, rshift(r21AA, r21CF), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f21D7->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r21DC = equal(r21CF, body.constant(int(32)));
                                       ir_if *f21DB = new(mem_ctx) ir_if(operand(r21DC).val);
                                       exec_list *const f21DB_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f21DB->then_instructions;

                                          body.emit(assign(r21D0, r21AB, 0x01));

                                          body.emit(assign(r21D1, r21AA, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f21DB->else_instructions;

                                          body.emit(assign(r21CE, bit_or(body.constant(0u), r21AB), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r21DE = less(r21CF, body.constant(int(64)));
                                          ir_if *f21DD = new(mem_ctx) ir_if(operand(r21DE).val);
                                          exec_list *const f21DD_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f21DD->then_instructions;

                                             body.emit(assign(r21D0, lshift(r21AA, r21D3), 0x01));

                                             ir_expression *const r21DF = bit_and(r21CF, body.constant(int(31)));
                                             body.emit(assign(r21D1, rshift(r21AA, r21DF), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f21DD->else_instructions;

                                             ir_variable *const r21E0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r21E2 = equal(r21CF, body.constant(int(64)));
                                             ir_if *f21E1 = new(mem_ctx) ir_if(operand(r21E2).val);
                                             exec_list *const f21E1_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f21E1->then_instructions;

                                                body.emit(assign(r21E0, r21AA, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f21E1->else_instructions;

                                                ir_expression *const r21E3 = nequal(r21AA, body.constant(0u));
                                                ir_expression *const r21E4 = expr(ir_unop_b2i, r21E3);
                                                body.emit(assign(r21E0, expr(ir_unop_i2u, r21E4), 0x01));


                                             body.instructions = f21E1_parent_instructions;
                                             body.emit(f21E1);

                                             /* END IF */

                                             body.emit(assign(r21D0, r21E0, 0x01));

                                             body.emit(assign(r21D1, body.constant(0u), 0x01));


                                          body.instructions = f21DD_parent_instructions;
                                          body.emit(f21DD);

                                          /* END IF */


                                       body.instructions = f21DB_parent_instructions;
                                       body.emit(f21DB);

                                       /* END IF */

                                       body.emit(assign(r21D2, body.constant(0u), 0x01));


                                    body.instructions = f21D7_parent_instructions;
                                    body.emit(f21D7);

                                    /* END IF */

                                    ir_expression *const r21E5 = nequal(r21CE, body.constant(0u));
                                    ir_expression *const r21E6 = expr(ir_unop_b2i, r21E5);
                                    ir_expression *const r21E7 = expr(ir_unop_i2u, r21E6);
                                    body.emit(assign(r21D0, bit_or(r21D0, r21E7), 0x01));


                                 body.instructions = f21D5_parent_instructions;
                                 body.emit(f21D5);

                                 /* END IF */

                                 body.emit(assign(r21AA, r21D2, 0x01));

                                 body.emit(assign(r21AB, r21D1, 0x01));

                                 body.emit(assign(r21AC, r21D0, 0x01));


                              body.instructions = f21C4_parent_instructions;
                              body.emit(f21C4);

                              /* END IF */

                              body.emit(assign(r21A9, sub(r21A9, r21AD), 0x01));

                              ir_variable *const r21E8 = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r21E8, r21A9, 0x01));

                              ir_variable *const r21E9 = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r21E9, r21AA, 0x01));

                              ir_variable *const r21EA = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r21EA, r21AB, 0x01));

                              ir_variable *const r21EB = body.make_temp(glsl_type::uint_type, "zFrac2");
                              body.emit(assign(r21EB, r21AC, 0x01));

                              ir_variable *const r21EC = body.make_temp(glsl_type::bool_type, "execute_flag");
                              body.emit(assign(r21EC, body.constant(true), 0x01));

                              ir_variable *const r21ED = body.make_temp(glsl_type::uvec2_type, "return_value");
                              ir_variable *const r21EE = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                              body.emit(r21EE);
                              ir_expression *const r21EF = expr(ir_unop_u2i, r21AC);
                              body.emit(assign(r21EE, less(r21EF, body.constant(int(0))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r21F1 = lequal(body.constant(int(2045)), r21A9);
                              ir_if *f21F0 = new(mem_ctx) ir_if(operand(r21F1).val);
                              exec_list *const f21F0_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f21F0->then_instructions;

                                 ir_variable *const r21F2 = body.make_temp(glsl_type::bool_type, "or_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r21F4 = less(body.constant(int(2045)), r21A9);
                                 ir_if *f21F3 = new(mem_ctx) ir_if(operand(r21F4).val);
                                 exec_list *const f21F3_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f21F3->then_instructions;

                                    body.emit(assign(r21F2, body.constant(true), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f21F3->else_instructions;

                                    ir_variable *const r21F5 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r21F7 = equal(r21A9, body.constant(int(2045)));
                                    ir_if *f21F6 = new(mem_ctx) ir_if(operand(r21F7).val);
                                    exec_list *const f21F6_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f21F6->then_instructions;

                                       ir_expression *const r21F8 = equal(body.constant(2097151u), r21AA);
                                       ir_expression *const r21F9 = equal(body.constant(4294967295u), r21AB);
                                       body.emit(assign(r21F5, logic_and(r21F8, r21F9), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f21F6->else_instructions;

                                       body.emit(assign(r21F5, body.constant(false), 0x01));


                                    body.instructions = f21F6_parent_instructions;
                                    body.emit(f21F6);

                                    /* END IF */

                                    body.emit(assign(r21F2, logic_and(r21F5, r21EE), 0x01));


                                 body.instructions = f21F3_parent_instructions;
                                 body.emit(f21F3);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_if *f21FA = new(mem_ctx) ir_if(operand(r21F2).val);
                                 exec_list *const f21FA_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f21FA->then_instructions;

                                    ir_variable *const r21FB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                    body.emit(r21FB);
                                    ir_expression *const r21FC = lshift(r1E72, body.constant(int(31)));
                                    body.emit(assign(r21FB, add(r21FC, body.constant(2146435072u)), 0x02));

                                    body.emit(assign(r21FB, body.constant(0u), 0x01));

                                    body.emit(assign(r21ED, r21FB, 0x03));

                                    body.emit(assign(r21EC, body.constant(false), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f21FA->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r21FE = less(r21A9, body.constant(int(0)));
                                    ir_if *f21FD = new(mem_ctx) ir_if(operand(r21FE).val);
                                    exec_list *const f21FD_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f21FD->then_instructions;

                                       ir_variable *const r21FF = body.make_temp(glsl_type::uint_type, "a2");
                                       body.emit(assign(r21FF, r21AC, 0x01));

                                       ir_variable *const r2200 = body.make_temp(glsl_type::int_type, "count");
                                       body.emit(assign(r2200, neg(r21A9), 0x01));

                                       ir_variable *const r2201 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                       body.emit(r2201);
                                       ir_variable *const r2202 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                       body.emit(r2202);
                                       ir_variable *const r2203 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                       body.emit(r2203);
                                       ir_variable *const r2204 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                       ir_expression *const r2205 = neg(r2200);
                                       body.emit(assign(r2204, bit_and(r2205, body.constant(int(31))), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2207 = equal(r2200, body.constant(int(0)));
                                       ir_if *f2206 = new(mem_ctx) ir_if(operand(r2207).val);
                                       exec_list *const f2206_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2206->then_instructions;

                                          body.emit(assign(r2201, r21AC, 0x01));

                                          body.emit(assign(r2202, r21AB, 0x01));

                                          body.emit(assign(r2203, r21AA, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2206->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r2209 = less(r2200, body.constant(int(32)));
                                          ir_if *f2208 = new(mem_ctx) ir_if(operand(r2209).val);
                                          exec_list *const f2208_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2208->then_instructions;

                                             body.emit(assign(r2201, lshift(r21AB, r2204), 0x01));

                                             ir_expression *const r220A = lshift(r21AA, r2204);
                                             ir_expression *const r220B = rshift(r21AB, r2200);
                                             body.emit(assign(r2202, bit_or(r220A, r220B), 0x01));

                                             body.emit(assign(r2203, rshift(r21AA, r2200), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2208->else_instructions;

                                             /* IF CONDITION */
                                             ir_expression *const r220D = equal(r2200, body.constant(int(32)));
                                             ir_if *f220C = new(mem_ctx) ir_if(operand(r220D).val);
                                             exec_list *const f220C_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f220C->then_instructions;

                                                body.emit(assign(r2201, r21AB, 0x01));

                                                body.emit(assign(r2202, r21AA, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f220C->else_instructions;

                                                body.emit(assign(r21FF, bit_or(r21AC, r21AB), 0x01));

                                                /* IF CONDITION */
                                                ir_expression *const r220F = less(r2200, body.constant(int(64)));
                                                ir_if *f220E = new(mem_ctx) ir_if(operand(r220F).val);
                                                exec_list *const f220E_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f220E->then_instructions;

                                                   body.emit(assign(r2201, lshift(r21AA, r2204), 0x01));

                                                   ir_expression *const r2210 = bit_and(r2200, body.constant(int(31)));
                                                   body.emit(assign(r2202, rshift(r21AA, r2210), 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f220E->else_instructions;

                                                   ir_variable *const r2211 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                   /* IF CONDITION */
                                                   ir_expression *const r2213 = equal(r2200, body.constant(int(64)));
                                                   ir_if *f2212 = new(mem_ctx) ir_if(operand(r2213).val);
                                                   exec_list *const f2212_parent_instructions = body.instructions;

                                                      /* THEN INSTRUCTIONS */
                                                      body.instructions = &f2212->then_instructions;

                                                      body.emit(assign(r2211, r21AA, 0x01));


                                                      /* ELSE INSTRUCTIONS */
                                                      body.instructions = &f2212->else_instructions;

                                                      ir_expression *const r2214 = nequal(r21AA, body.constant(0u));
                                                      ir_expression *const r2215 = expr(ir_unop_b2i, r2214);
                                                      body.emit(assign(r2211, expr(ir_unop_i2u, r2215), 0x01));


                                                   body.instructions = f2212_parent_instructions;
                                                   body.emit(f2212);

                                                   /* END IF */

                                                   body.emit(assign(r2201, r2211, 0x01));

                                                   body.emit(assign(r2202, body.constant(0u), 0x01));


                                                body.instructions = f220E_parent_instructions;
                                                body.emit(f220E);

                                                /* END IF */


                                             body.instructions = f220C_parent_instructions;
                                             body.emit(f220C);

                                             /* END IF */

                                             body.emit(assign(r2203, body.constant(0u), 0x01));


                                          body.instructions = f2208_parent_instructions;
                                          body.emit(f2208);

                                          /* END IF */

                                          ir_expression *const r2216 = nequal(r21FF, body.constant(0u));
                                          ir_expression *const r2217 = expr(ir_unop_b2i, r2216);
                                          ir_expression *const r2218 = expr(ir_unop_i2u, r2217);
                                          body.emit(assign(r2201, bit_or(r2201, r2218), 0x01));


                                       body.instructions = f2206_parent_instructions;
                                       body.emit(f2206);

                                       /* END IF */

                                       body.emit(assign(r21E9, r2203, 0x01));

                                       body.emit(assign(r21EA, r2202, 0x01));

                                       body.emit(assign(r21EB, r2201, 0x01));

                                       body.emit(assign(r21E8, body.constant(int(0)), 0x01));

                                       body.emit(assign(r21EE, less(r2201, body.constant(0u)), 0x01));


                                    body.instructions = f21FD_parent_instructions;
                                    body.emit(f21FD);

                                    /* END IF */


                                 body.instructions = f21FA_parent_instructions;
                                 body.emit(f21FA);

                                 /* END IF */


                              body.instructions = f21F0_parent_instructions;
                              body.emit(f21F0);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f2219 = new(mem_ctx) ir_if(operand(r21EC).val);
                              exec_list *const f2219_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2219->then_instructions;

                                 /* IF CONDITION */
                                 ir_if *f221A = new(mem_ctx) ir_if(operand(r21EE).val);
                                 exec_list *const f221A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f221A->then_instructions;

                                    ir_variable *const r221B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                    body.emit(assign(r221B, add(r21EA, body.constant(1u)), 0x01));

                                    ir_expression *const r221C = less(r221B, r21EA);
                                    ir_expression *const r221D = expr(ir_unop_b2i, r221C);
                                    ir_expression *const r221E = expr(ir_unop_i2u, r221D);
                                    body.emit(assign(r21E9, add(r21E9, r221E), 0x01));

                                    ir_expression *const r221F = equal(r21EB, body.constant(0u));
                                    ir_expression *const r2220 = expr(ir_unop_b2i, r221F);
                                    ir_expression *const r2221 = expr(ir_unop_i2u, r2220);
                                    ir_expression *const r2222 = add(r21EB, r2221);
                                    ir_expression *const r2223 = bit_and(r2222, body.constant(1u));
                                    ir_expression *const r2224 = expr(ir_unop_bit_not, r2223);
                                    body.emit(assign(r21EA, bit_and(r221B, r2224), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f221A->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2226 = bit_or(r21E9, r21EA);
                                    ir_expression *const r2227 = equal(r2226, body.constant(0u));
                                    ir_if *f2225 = new(mem_ctx) ir_if(operand(r2227).val);
                                    exec_list *const f2225_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2225->then_instructions;

                                       body.emit(assign(r21E8, body.constant(int(0)), 0x01));


                                    body.instructions = f2225_parent_instructions;
                                    body.emit(f2225);

                                    /* END IF */


                                 body.instructions = f221A_parent_instructions;
                                 body.emit(f221A);

                                 /* END IF */

                                 ir_variable *const r2228 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r2228);
                                 ir_expression *const r2229 = lshift(r1E72, body.constant(int(31)));
                                 ir_expression *const r222A = expr(ir_unop_i2u, r21E8);
                                 ir_expression *const r222B = lshift(r222A, body.constant(int(20)));
                                 ir_expression *const r222C = add(r2229, r222B);
                                 body.emit(assign(r2228, add(r222C, r21E9), 0x02));

                                 body.emit(assign(r2228, r21EA, 0x01));

                                 body.emit(assign(r21ED, r2228, 0x03));

                                 body.emit(assign(r21EC, body.constant(false), 0x01));


                              body.instructions = f2219_parent_instructions;
                              body.emit(f2219);

                              /* END IF */

                              body.emit(assign(r1E73, r21ED, 0x03));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f21A1->else_instructions;

                              ir_variable *const r222D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r222D);
                              body.emit(assign(r222D, body.constant(0u), 0x02));

                              body.emit(assign(r222D, body.constant(0u), 0x01));

                              body.emit(assign(r1E73, r222D, 0x03));


                           body.instructions = f21A1_parent_instructions;
                           body.emit(f21A1);

                           /* END IF */


                        body.instructions = f2115_parent_instructions;
                        body.emit(f2115);

                        /* END IF */


                     body.instructions = f2089_parent_instructions;
                     body.emit(f2089);

                     /* END IF */


                  body.instructions = f1FFD_parent_instructions;
                  body.emit(f1FFD);

                  /* END IF */


               body.instructions = f1FE8_parent_instructions;
               body.emit(f1FE8);

               /* END IF */


            body.instructions = f1F37_parent_instructions;
            body.emit(f1F37);

            /* END IF */


         body.instructions = f1E84_parent_instructions;
         body.emit(f1E84);

         /* END IF */

         body.emit(assign(r1E6E, r1E73, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1E70->else_instructions;

         ir_variable *const r222E = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r222E, body.constant(true), 0x01));

         ir_variable *const r222F = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r2230 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r2230);
         ir_variable *const r2231 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
         body.emit(r2231);
         ir_variable *const r2232 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
         body.emit(r2232);
         ir_variable *const r2233 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r2233);
         ir_variable *const r2234 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
         body.emit(r2234);
         ir_variable *const r2235 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
         body.emit(r2235);
         body.emit(assign(r2235, body.constant(0u), 0x01));

         body.emit(assign(r2234, body.constant(0u), 0x01));

         ir_variable *const r2236 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
         body.emit(r2236);
         body.emit(assign(r2236, bit_and(swizzle_y(r1E39), body.constant(1048575u)), 0x02));

         body.emit(assign(r2236, swizzle_x(r1E39), 0x01));

         body.emit(assign(r2232, r2236, 0x03));

         ir_variable *const r2237 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r2238 = rshift(swizzle_y(r1E39), body.constant(int(20)));
         ir_expression *const r2239 = bit_and(r2238, body.constant(2047u));
         body.emit(assign(r2237, expr(ir_unop_u2i, r2239), 0x01));

         ir_variable *const r223A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
         body.emit(r223A);
         body.emit(assign(r223A, body.constant(0u), 0x02));

         body.emit(assign(r223A, body.constant(0u), 0x01));

         body.emit(assign(r2231, r223A, 0x03));

         ir_variable *const r223B = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         body.emit(assign(r223B, body.constant(int(1023)), 0x01));

         ir_variable *const r223C = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r223C, add(r2237, body.constant(int(-1023))), 0x01));

         body.emit(assign(r2230, r223C, 0x01));

         /* IF CONDITION */
         ir_expression *const r223E = less(body.constant(int(0)), r223C);
         ir_if *f223D = new(mem_ctx) ir_if(operand(r223E).val);
         exec_list *const f223D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f223D->then_instructions;

            /* IF CONDITION */
            ir_expression *const r2240 = equal(r2237, body.constant(int(2047)));
            ir_if *f223F = new(mem_ctx) ir_if(operand(r2240).val);
            exec_list *const f223F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f223F->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2242 = bit_or(swizzle_y(r2236), swizzle_x(r1E39));
               ir_expression *const r2243 = nequal(r2242, body.constant(0u));
               ir_if *f2241 = new(mem_ctx) ir_if(operand(r2243).val);
               exec_list *const f2241_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2241->then_instructions;

                  ir_variable *const r2244 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r2244, swizzle_x(r1E39), 0x01));

                  ir_variable *const r2245 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r2245, body.constant(0u), 0x01));

                  ir_variable *const r2246 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r2244, bit_or(swizzle_y(r1E39), body.constant(524288u)), 0x02));

                  body.emit(assign(r2245, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r2248 = lshift(swizzle_y(r1E39), body.constant(int(1)));
                  ir_expression *const r2249 = lequal(body.constant(4292870144u), r2248);
                  ir_expression *const r224A = nequal(swizzle_x(r1E39), body.constant(0u));
                  ir_expression *const r224B = bit_and(swizzle_y(r1E39), body.constant(1048575u));
                  ir_expression *const r224C = nequal(r224B, body.constant(0u));
                  ir_expression *const r224D = logic_or(r224A, r224C);
                  ir_expression *const r224E = logic_and(r2249, r224D);
                  ir_if *f2247 = new(mem_ctx) ir_if(operand(r224E).val);
                  exec_list *const f2247_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2247->then_instructions;

                     body.emit(assign(r2246, r2244, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2247->else_instructions;

                     body.emit(assign(r2246, r2245, 0x03));


                  body.instructions = f2247_parent_instructions;
                  body.emit(f2247);

                  /* END IF */

                  body.emit(assign(r222F, r2246, 0x03));

                  body.emit(assign(r222E, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2241->else_instructions;

                  body.emit(assign(r222F, r1E39, 0x03));

                  body.emit(assign(r222E, body.constant(false), 0x01));


               body.instructions = f2241_parent_instructions;
               body.emit(f2241);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f223F->else_instructions;

               body.emit(assign(r2231, body.constant(1048576u), 0x02));

               ir_variable *const r224F = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r224F, swizzle_y(r2231), 0x01));

               ir_variable *const r2250 = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r2250, swizzle_x(r2231), 0x01));

               ir_variable *const r2251 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r2251, body.constant(0u), 0x01));

               ir_variable *const r2252 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r2252);
               ir_variable *const r2253 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2253);
               ir_variable *const r2254 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2254);
               ir_variable *const r2255 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2256 = neg(r223C);
               body.emit(assign(r2255, bit_and(r2256, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2258 = equal(r223C, body.constant(int(0)));
               ir_if *f2257 = new(mem_ctx) ir_if(operand(r2258).val);
               exec_list *const f2257_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2257->then_instructions;

                  body.emit(assign(r2252, r2251, 0x01));

                  body.emit(assign(r2253, r2250, 0x01));

                  body.emit(assign(r2254, r224F, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2257->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r225A = less(r223C, body.constant(int(32)));
                  ir_if *f2259 = new(mem_ctx) ir_if(operand(r225A).val);
                  exec_list *const f2259_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2259->then_instructions;

                     body.emit(assign(r2252, body.constant(0u), 0x01));

                     ir_expression *const r225B = lshift(body.constant(1048576u), r2255);
                     body.emit(assign(r2253, bit_or(r225B, body.constant(0u)), 0x01));

                     body.emit(assign(r2254, rshift(body.constant(1048576u), r223C), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2259->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r225D = equal(r223C, body.constant(int(32)));
                     ir_if *f225C = new(mem_ctx) ir_if(operand(r225D).val);
                     exec_list *const f225C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f225C->then_instructions;

                        body.emit(assign(r2252, r2250, 0x01));

                        body.emit(assign(r2253, r224F, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f225C->else_instructions;

                        body.emit(assign(r2251, body.constant(0u), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r225F = less(r223C, body.constant(int(64)));
                        ir_if *f225E = new(mem_ctx) ir_if(operand(r225F).val);
                        exec_list *const f225E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f225E->then_instructions;

                           body.emit(assign(r2252, lshift(body.constant(1048576u), r2255), 0x01));

                           ir_expression *const r2260 = bit_and(r223C, body.constant(int(31)));
                           body.emit(assign(r2253, rshift(body.constant(1048576u), r2260), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f225E->else_instructions;

                           ir_variable *const r2261 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2263 = equal(r223C, body.constant(int(64)));
                           ir_if *f2262 = new(mem_ctx) ir_if(operand(r2263).val);
                           exec_list *const f2262_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2262->then_instructions;

                              body.emit(assign(r2261, r224F, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2262->else_instructions;

                              body.emit(assign(r2261, body.constant(1u), 0x01));


                           body.instructions = f2262_parent_instructions;
                           body.emit(f2262);

                           /* END IF */

                           body.emit(assign(r2252, r2261, 0x01));

                           body.emit(assign(r2253, body.constant(0u), 0x01));


                        body.instructions = f225E_parent_instructions;
                        body.emit(f225E);

                        /* END IF */


                     body.instructions = f225C_parent_instructions;
                     body.emit(f225C);

                     /* END IF */

                     body.emit(assign(r2254, body.constant(0u), 0x01));


                  body.instructions = f2259_parent_instructions;
                  body.emit(f2259);

                  /* END IF */

                  ir_expression *const r2264 = nequal(r2251, body.constant(0u));
                  ir_expression *const r2265 = expr(ir_unop_b2i, r2264);
                  ir_expression *const r2266 = expr(ir_unop_i2u, r2265);
                  body.emit(assign(r2252, bit_or(r2252, r2266), 0x01));


               body.instructions = f2257_parent_instructions;
               body.emit(f2257);

               /* END IF */

               body.emit(assign(r2231, r2254, 0x02));

               body.emit(assign(r2231, r2253, 0x01));

               body.emit(assign(r2234, r2252, 0x01));

               body.emit(assign(r2233, r2237, 0x01));


            body.instructions = f223F_parent_instructions;
            body.emit(f223F);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f223D->else_instructions;

            /* IF CONDITION */
            ir_expression *const r2268 = less(r223C, body.constant(int(0)));
            ir_if *f2267 = new(mem_ctx) ir_if(operand(r2268).val);
            exec_list *const f2267_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2267->then_instructions;

               /* IF CONDITION */
               ir_expression *const r226A = equal(r2237, body.constant(int(0)));
               ir_if *f2269 = new(mem_ctx) ir_if(operand(r226A).val);
               exec_list *const f2269_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2269->then_instructions;

                  body.emit(assign(r2230, add(r223C, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2269->else_instructions;

                  body.emit(assign(r2232, bit_or(swizzle_y(r2236), body.constant(1048576u)), 0x02));


               body.instructions = f2269_parent_instructions;
               body.emit(f2269);

               /* END IF */

               ir_variable *const r226B = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r226B, swizzle_y(r2232), 0x01));

               ir_variable *const r226C = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r226C, swizzle_x(r2232), 0x01));

               ir_variable *const r226D = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r226D, body.constant(0u), 0x01));

               ir_variable *const r226E = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r226E, neg(r2230), 0x01));

               ir_variable *const r226F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r226F);
               ir_variable *const r2270 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2270);
               ir_variable *const r2271 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2271);
               ir_variable *const r2272 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2273 = neg(r226E);
               body.emit(assign(r2272, bit_and(r2273, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2275 = equal(r226E, body.constant(int(0)));
               ir_if *f2274 = new(mem_ctx) ir_if(operand(r2275).val);
               exec_list *const f2274_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2274->then_instructions;

                  body.emit(assign(r226F, r226D, 0x01));

                  body.emit(assign(r2270, r226C, 0x01));

                  body.emit(assign(r2271, r226B, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2274->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2277 = less(r226E, body.constant(int(32)));
                  ir_if *f2276 = new(mem_ctx) ir_if(operand(r2277).val);
                  exec_list *const f2276_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2276->then_instructions;

                     body.emit(assign(r226F, lshift(swizzle_x(r2236), r2272), 0x01));

                     ir_expression *const r2278 = lshift(swizzle_y(r2232), r2272);
                     ir_expression *const r2279 = rshift(swizzle_x(r2236), r226E);
                     body.emit(assign(r2270, bit_or(r2278, r2279), 0x01));

                     body.emit(assign(r2271, rshift(swizzle_y(r2232), r226E), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2276->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r227B = equal(r226E, body.constant(int(32)));
                     ir_if *f227A = new(mem_ctx) ir_if(operand(r227B).val);
                     exec_list *const f227A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f227A->then_instructions;

                        body.emit(assign(r226F, r226C, 0x01));

                        body.emit(assign(r2270, r226B, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f227A->else_instructions;

                        body.emit(assign(r226D, bit_or(body.constant(0u), swizzle_x(r2236)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r227D = less(r226E, body.constant(int(64)));
                        ir_if *f227C = new(mem_ctx) ir_if(operand(r227D).val);
                        exec_list *const f227C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f227C->then_instructions;

                           body.emit(assign(r226F, lshift(swizzle_y(r2232), r2272), 0x01));

                           ir_expression *const r227E = bit_and(r226E, body.constant(int(31)));
                           body.emit(assign(r2270, rshift(swizzle_y(r2232), r227E), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f227C->else_instructions;

                           ir_variable *const r227F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2281 = equal(r226E, body.constant(int(64)));
                           ir_if *f2280 = new(mem_ctx) ir_if(operand(r2281).val);
                           exec_list *const f2280_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2280->then_instructions;

                              body.emit(assign(r227F, r226B, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2280->else_instructions;

                              ir_expression *const r2282 = nequal(swizzle_y(r2232), body.constant(0u));
                              ir_expression *const r2283 = expr(ir_unop_b2i, r2282);
                              body.emit(assign(r227F, expr(ir_unop_i2u, r2283), 0x01));


                           body.instructions = f2280_parent_instructions;
                           body.emit(f2280);

                           /* END IF */

                           body.emit(assign(r226F, r227F, 0x01));

                           body.emit(assign(r2270, body.constant(0u), 0x01));


                        body.instructions = f227C_parent_instructions;
                        body.emit(f227C);

                        /* END IF */


                     body.instructions = f227A_parent_instructions;
                     body.emit(f227A);

                     /* END IF */

                     body.emit(assign(r2271, body.constant(0u), 0x01));


                  body.instructions = f2276_parent_instructions;
                  body.emit(f2276);

                  /* END IF */

                  ir_expression *const r2284 = nequal(r226D, body.constant(0u));
                  ir_expression *const r2285 = expr(ir_unop_b2i, r2284);
                  ir_expression *const r2286 = expr(ir_unop_i2u, r2285);
                  body.emit(assign(r226F, bit_or(r226F, r2286), 0x01));


               body.instructions = f2274_parent_instructions;
               body.emit(f2274);

               /* END IF */

               body.emit(assign(r2232, r2271, 0x02));

               body.emit(assign(r2232, r2270, 0x01));

               body.emit(assign(r2234, r226F, 0x01));

               body.emit(assign(r2233, body.constant(int(1023)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2267->else_instructions;

               /* IF CONDITION */
               ir_expression *const r2288 = equal(r2237, body.constant(int(2047)));
               ir_if *f2287 = new(mem_ctx) ir_if(operand(r2288).val);
               exec_list *const f2287_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2287->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r228A = bit_or(swizzle_y(r2232), swizzle_x(r2232));
                  ir_expression *const r228B = bit_or(swizzle_y(r2231), swizzle_x(r2231));
                  ir_expression *const r228C = bit_or(r228A, r228B);
                  ir_expression *const r228D = nequal(r228C, body.constant(0u));
                  ir_if *f2289 = new(mem_ctx) ir_if(operand(r228D).val);
                  exec_list *const f2289_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2289->then_instructions;

                     ir_variable *const r228E = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r228E, swizzle_x(r1E39), 0x01));

                     ir_variable *const r228F = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r228F, body.constant(0u), 0x01));

                     ir_variable *const r2290 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r228E, bit_or(swizzle_y(r1E39), body.constant(524288u)), 0x02));

                     body.emit(assign(r228F, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r2292 = lshift(swizzle_y(r1E39), body.constant(int(1)));
                     ir_expression *const r2293 = lequal(body.constant(4292870144u), r2292);
                     ir_expression *const r2294 = nequal(swizzle_x(r1E39), body.constant(0u));
                     ir_expression *const r2295 = bit_and(swizzle_y(r1E39), body.constant(1048575u));
                     ir_expression *const r2296 = nequal(r2295, body.constant(0u));
                     ir_expression *const r2297 = logic_or(r2294, r2296);
                     ir_expression *const r2298 = logic_and(r2293, r2297);
                     ir_if *f2291 = new(mem_ctx) ir_if(operand(r2298).val);
                     exec_list *const f2291_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2291->then_instructions;

                        body.emit(assign(r2290, r228E, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2291->else_instructions;

                        body.emit(assign(r2290, r228F, 0x03));


                     body.instructions = f2291_parent_instructions;
                     body.emit(f2291);

                     /* END IF */

                     body.emit(assign(r222F, r2290, 0x03));

                     body.emit(assign(r222E, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2289->else_instructions;

                     body.emit(assign(r222F, r1E39, 0x03));

                     body.emit(assign(r222E, body.constant(false), 0x01));


                  body.instructions = f2289_parent_instructions;
                  body.emit(f2289);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2287->else_instructions;

                  ir_variable *const r2299 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r229A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r229A, add(swizzle_x(r2232), swizzle_x(r2231)), 0x01));

                  ir_expression *const r229B = add(swizzle_y(r2232), swizzle_y(r2231));
                  ir_expression *const r229C = less(r229A, swizzle_x(r2232));
                  ir_expression *const r229D = expr(ir_unop_b2i, r229C);
                  ir_expression *const r229E = expr(ir_unop_i2u, r229D);
                  body.emit(assign(r2299, add(r229B, r229E), 0x01));

                  body.emit(assign(r2235, r2299, 0x01));

                  /* IF CONDITION */
                  ir_expression *const r22A0 = equal(r2237, body.constant(int(0)));
                  ir_if *f229F = new(mem_ctx) ir_if(operand(r22A0).val);
                  exec_list *const f229F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f229F->then_instructions;

                     ir_variable *const r22A1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r22A1);
                     ir_expression *const r22A2 = lshift(r1E6F, body.constant(int(31)));
                     body.emit(assign(r22A1, add(r22A2, r2299), 0x02));

                     body.emit(assign(r22A1, r229A, 0x01));

                     body.emit(assign(r222F, r22A1, 0x03));

                     body.emit(assign(r222E, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f229F->else_instructions;

                     body.emit(assign(r2235, bit_or(r2299, body.constant(2097152u)), 0x01));

                     body.emit(assign(r2233, r2237, 0x01));

                     ir_variable *const r22A3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r22A3);
                     ir_variable *const r22A4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r22A4);
                     ir_variable *const r22A5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r22A5);
                     body.emit(assign(r22A3, lshift(r229A, body.constant(int(31))), 0x01));

                     ir_expression *const r22A6 = lshift(r2235, body.constant(int(31)));
                     ir_expression *const r22A7 = rshift(r229A, body.constant(int(1)));
                     body.emit(assign(r22A4, bit_or(r22A6, r22A7), 0x01));

                     body.emit(assign(r22A5, rshift(r2235, body.constant(int(1))), 0x01));

                     body.emit(assign(r22A3, bit_or(r22A3, body.constant(0u)), 0x01));

                     body.emit(assign(r2235, r22A5, 0x01));

                     body.emit(assign(r2234, r22A3, 0x01));

                     ir_variable *const r22A8 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r22A8, r2237, 0x01));

                     ir_variable *const r22A9 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r22A9, r22A5, 0x01));

                     ir_variable *const r22AA = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r22AA, r22A4, 0x01));

                     ir_variable *const r22AB = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r22AB, r22A3, 0x01));

                     ir_variable *const r22AC = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r22AC, body.constant(true), 0x01));

                     ir_variable *const r22AD = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r22AE = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r22AE);
                     ir_expression *const r22AF = expr(ir_unop_u2i, r22A3);
                     body.emit(assign(r22AE, less(r22AF, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r22B1 = lequal(body.constant(int(2045)), r2237);
                     ir_if *f22B0 = new(mem_ctx) ir_if(operand(r22B1).val);
                     exec_list *const f22B0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f22B0->then_instructions;

                        ir_variable *const r22B2 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r22B4 = less(body.constant(int(2045)), r2237);
                        ir_if *f22B3 = new(mem_ctx) ir_if(operand(r22B4).val);
                        exec_list *const f22B3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f22B3->then_instructions;

                           body.emit(assign(r22B2, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f22B3->else_instructions;

                           ir_variable *const r22B5 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r22B7 = equal(r2237, body.constant(int(2045)));
                           ir_if *f22B6 = new(mem_ctx) ir_if(operand(r22B7).val);
                           exec_list *const f22B6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f22B6->then_instructions;

                              ir_expression *const r22B8 = equal(body.constant(2097151u), r22A5);
                              ir_expression *const r22B9 = equal(body.constant(4294967295u), r22A4);
                              body.emit(assign(r22B5, logic_and(r22B8, r22B9), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f22B6->else_instructions;

                              body.emit(assign(r22B5, body.constant(false), 0x01));


                           body.instructions = f22B6_parent_instructions;
                           body.emit(f22B6);

                           /* END IF */

                           body.emit(assign(r22B2, logic_and(r22B5, r22AE), 0x01));


                        body.instructions = f22B3_parent_instructions;
                        body.emit(f22B3);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f22BA = new(mem_ctx) ir_if(operand(r22B2).val);
                        exec_list *const f22BA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f22BA->then_instructions;

                           ir_variable *const r22BB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r22BB);
                           ir_expression *const r22BC = lshift(r1E6F, body.constant(int(31)));
                           body.emit(assign(r22BB, add(r22BC, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r22BB, body.constant(0u), 0x01));

                           body.emit(assign(r22AD, r22BB, 0x03));

                           body.emit(assign(r22AC, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f22BA->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r22BE = less(r2237, body.constant(int(0)));
                           ir_if *f22BD = new(mem_ctx) ir_if(operand(r22BE).val);
                           exec_list *const f22BD_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f22BD->then_instructions;

                              ir_variable *const r22BF = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r22BF, r22A3, 0x01));

                              ir_variable *const r22C0 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r22C0, neg(r2237), 0x01));

                              ir_variable *const r22C1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r22C1);
                              ir_variable *const r22C2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r22C2);
                              ir_variable *const r22C3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r22C3);
                              ir_variable *const r22C4 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r22C5 = neg(r22C0);
                              body.emit(assign(r22C4, bit_and(r22C5, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r22C7 = equal(r22C0, body.constant(int(0)));
                              ir_if *f22C6 = new(mem_ctx) ir_if(operand(r22C7).val);
                              exec_list *const f22C6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f22C6->then_instructions;

                                 body.emit(assign(r22C1, r22A3, 0x01));

                                 body.emit(assign(r22C2, r22A4, 0x01));

                                 body.emit(assign(r22C3, r22A5, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f22C6->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r22C9 = less(r22C0, body.constant(int(32)));
                                 ir_if *f22C8 = new(mem_ctx) ir_if(operand(r22C9).val);
                                 exec_list *const f22C8_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f22C8->then_instructions;

                                    body.emit(assign(r22C1, lshift(r22A4, r22C4), 0x01));

                                    ir_expression *const r22CA = lshift(r22A5, r22C4);
                                    ir_expression *const r22CB = rshift(r22A4, r22C0);
                                    body.emit(assign(r22C2, bit_or(r22CA, r22CB), 0x01));

                                    body.emit(assign(r22C3, rshift(r22A5, r22C0), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f22C8->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r22CD = equal(r22C0, body.constant(int(32)));
                                    ir_if *f22CC = new(mem_ctx) ir_if(operand(r22CD).val);
                                    exec_list *const f22CC_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f22CC->then_instructions;

                                       body.emit(assign(r22C1, r22A4, 0x01));

                                       body.emit(assign(r22C2, r22A5, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f22CC->else_instructions;

                                       body.emit(assign(r22BF, bit_or(r22A3, r22A4), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r22CF = less(r22C0, body.constant(int(64)));
                                       ir_if *f22CE = new(mem_ctx) ir_if(operand(r22CF).val);
                                       exec_list *const f22CE_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f22CE->then_instructions;

                                          body.emit(assign(r22C1, lshift(r22A5, r22C4), 0x01));

                                          ir_expression *const r22D0 = bit_and(r22C0, body.constant(int(31)));
                                          body.emit(assign(r22C2, rshift(r22A5, r22D0), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f22CE->else_instructions;

                                          ir_variable *const r22D1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r22D3 = equal(r22C0, body.constant(int(64)));
                                          ir_if *f22D2 = new(mem_ctx) ir_if(operand(r22D3).val);
                                          exec_list *const f22D2_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f22D2->then_instructions;

                                             body.emit(assign(r22D1, r22A5, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f22D2->else_instructions;

                                             ir_expression *const r22D4 = nequal(r22A5, body.constant(0u));
                                             ir_expression *const r22D5 = expr(ir_unop_b2i, r22D4);
                                             body.emit(assign(r22D1, expr(ir_unop_i2u, r22D5), 0x01));


                                          body.instructions = f22D2_parent_instructions;
                                          body.emit(f22D2);

                                          /* END IF */

                                          body.emit(assign(r22C1, r22D1, 0x01));

                                          body.emit(assign(r22C2, body.constant(0u), 0x01));


                                       body.instructions = f22CE_parent_instructions;
                                       body.emit(f22CE);

                                       /* END IF */


                                    body.instructions = f22CC_parent_instructions;
                                    body.emit(f22CC);

                                    /* END IF */

                                    body.emit(assign(r22C3, body.constant(0u), 0x01));


                                 body.instructions = f22C8_parent_instructions;
                                 body.emit(f22C8);

                                 /* END IF */

                                 ir_expression *const r22D6 = nequal(r22BF, body.constant(0u));
                                 ir_expression *const r22D7 = expr(ir_unop_b2i, r22D6);
                                 ir_expression *const r22D8 = expr(ir_unop_i2u, r22D7);
                                 body.emit(assign(r22C1, bit_or(r22C1, r22D8), 0x01));


                              body.instructions = f22C6_parent_instructions;
                              body.emit(f22C6);

                              /* END IF */

                              body.emit(assign(r22A9, r22C3, 0x01));

                              body.emit(assign(r22AA, r22C2, 0x01));

                              body.emit(assign(r22AB, r22C1, 0x01));

                              body.emit(assign(r22A8, body.constant(int(0)), 0x01));

                              body.emit(assign(r22AE, less(r22C1, body.constant(0u)), 0x01));


                           body.instructions = f22BD_parent_instructions;
                           body.emit(f22BD);

                           /* END IF */


                        body.instructions = f22BA_parent_instructions;
                        body.emit(f22BA);

                        /* END IF */


                     body.instructions = f22B0_parent_instructions;
                     body.emit(f22B0);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f22D9 = new(mem_ctx) ir_if(operand(r22AC).val);
                     exec_list *const f22D9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f22D9->then_instructions;

                        /* IF CONDITION */
                        ir_if *f22DA = new(mem_ctx) ir_if(operand(r22AE).val);
                        exec_list *const f22DA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f22DA->then_instructions;

                           ir_variable *const r22DB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r22DB, add(r22AA, body.constant(1u)), 0x01));

                           ir_expression *const r22DC = less(r22DB, r22AA);
                           ir_expression *const r22DD = expr(ir_unop_b2i, r22DC);
                           ir_expression *const r22DE = expr(ir_unop_i2u, r22DD);
                           body.emit(assign(r22A9, add(r22A9, r22DE), 0x01));

                           ir_expression *const r22DF = equal(r22AB, body.constant(0u));
                           ir_expression *const r22E0 = expr(ir_unop_b2i, r22DF);
                           ir_expression *const r22E1 = expr(ir_unop_i2u, r22E0);
                           ir_expression *const r22E2 = add(r22AB, r22E1);
                           ir_expression *const r22E3 = bit_and(r22E2, body.constant(1u));
                           ir_expression *const r22E4 = expr(ir_unop_bit_not, r22E3);
                           body.emit(assign(r22AA, bit_and(r22DB, r22E4), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f22DA->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r22E6 = bit_or(r22A9, r22AA);
                           ir_expression *const r22E7 = equal(r22E6, body.constant(0u));
                           ir_if *f22E5 = new(mem_ctx) ir_if(operand(r22E7).val);
                           exec_list *const f22E5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f22E5->then_instructions;

                              body.emit(assign(r22A8, body.constant(int(0)), 0x01));


                           body.instructions = f22E5_parent_instructions;
                           body.emit(f22E5);

                           /* END IF */


                        body.instructions = f22DA_parent_instructions;
                        body.emit(f22DA);

                        /* END IF */

                        ir_variable *const r22E8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r22E8);
                        ir_expression *const r22E9 = lshift(r1E6F, body.constant(int(31)));
                        ir_expression *const r22EA = expr(ir_unop_i2u, r22A8);
                        ir_expression *const r22EB = lshift(r22EA, body.constant(int(20)));
                        ir_expression *const r22EC = add(r22E9, r22EB);
                        body.emit(assign(r22E8, add(r22EC, r22A9), 0x02));

                        body.emit(assign(r22E8, r22AA, 0x01));

                        body.emit(assign(r22AD, r22E8, 0x03));

                        body.emit(assign(r22AC, body.constant(false), 0x01));


                     body.instructions = f22D9_parent_instructions;
                     body.emit(f22D9);

                     /* END IF */

                     body.emit(assign(r222F, r22AD, 0x03));

                     body.emit(assign(r222E, body.constant(false), 0x01));


                  body.instructions = f229F_parent_instructions;
                  body.emit(f229F);

                  /* END IF */


               body.instructions = f2287_parent_instructions;
               body.emit(f2287);

               /* END IF */


            body.instructions = f2267_parent_instructions;
            body.emit(f2267);

            /* END IF */


         body.instructions = f223D_parent_instructions;
         body.emit(f223D);

         /* END IF */

         /* IF CONDITION */
         ir_if *f22ED = new(mem_ctx) ir_if(operand(r222E).val);
         exec_list *const f22ED_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f22ED->then_instructions;

            body.emit(assign(r2232, bit_or(swizzle_y(r2232), body.constant(1048576u)), 0x02));

            ir_variable *const r22EE = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r22EF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r22EF, add(swizzle_x(r2232), swizzle_x(r2231)), 0x01));

            ir_expression *const r22F0 = add(swizzle_y(r2232), swizzle_y(r2231));
            ir_expression *const r22F1 = less(r22EF, swizzle_x(r2232));
            ir_expression *const r22F2 = expr(ir_unop_b2i, r22F1);
            ir_expression *const r22F3 = expr(ir_unop_i2u, r22F2);
            body.emit(assign(r22EE, add(r22F0, r22F3), 0x01));

            body.emit(assign(r2235, r22EE, 0x01));

            body.emit(assign(r2233, add(r2233, body.constant(int(-1))), 0x01));

            /* IF CONDITION */
            ir_expression *const r22F5 = less(r22EE, body.constant(2097152u));
            ir_if *f22F4 = new(mem_ctx) ir_if(operand(r22F5).val);
            exec_list *const f22F4_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f22F4->then_instructions;

               ir_variable *const r22F6 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r22F6, r2233, 0x01));

               ir_variable *const r22F7 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r22F7, r22EE, 0x01));

               ir_variable *const r22F8 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r22F8, r22EF, 0x01));

               ir_variable *const r22F9 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r22F9, r2234, 0x01));

               ir_variable *const r22FA = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r22FA, body.constant(true), 0x01));

               ir_variable *const r22FB = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r22FC = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r22FC);
               ir_expression *const r22FD = expr(ir_unop_u2i, r2234);
               body.emit(assign(r22FC, less(r22FD, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r22FF = lequal(body.constant(int(2045)), r2233);
               ir_if *f22FE = new(mem_ctx) ir_if(operand(r22FF).val);
               exec_list *const f22FE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f22FE->then_instructions;

                  ir_variable *const r2300 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2302 = less(body.constant(int(2045)), r2233);
                  ir_if *f2301 = new(mem_ctx) ir_if(operand(r2302).val);
                  exec_list *const f2301_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2301->then_instructions;

                     body.emit(assign(r2300, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2301->else_instructions;

                     ir_variable *const r2303 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2305 = equal(r2233, body.constant(int(2045)));
                     ir_if *f2304 = new(mem_ctx) ir_if(operand(r2305).val);
                     exec_list *const f2304_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2304->then_instructions;

                        ir_expression *const r2306 = equal(body.constant(2097151u), r22EE);
                        ir_expression *const r2307 = equal(body.constant(4294967295u), r22EF);
                        body.emit(assign(r2303, logic_and(r2306, r2307), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2304->else_instructions;

                        body.emit(assign(r2303, body.constant(false), 0x01));


                     body.instructions = f2304_parent_instructions;
                     body.emit(f2304);

                     /* END IF */

                     body.emit(assign(r2300, logic_and(r2303, r22FC), 0x01));


                  body.instructions = f2301_parent_instructions;
                  body.emit(f2301);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2308 = new(mem_ctx) ir_if(operand(r2300).val);
                  exec_list *const f2308_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2308->then_instructions;

                     ir_variable *const r2309 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2309);
                     ir_expression *const r230A = lshift(r1E6F, body.constant(int(31)));
                     body.emit(assign(r2309, add(r230A, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r2309, body.constant(0u), 0x01));

                     body.emit(assign(r22FB, r2309, 0x03));

                     body.emit(assign(r22FA, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2308->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r230C = less(r2233, body.constant(int(0)));
                     ir_if *f230B = new(mem_ctx) ir_if(operand(r230C).val);
                     exec_list *const f230B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f230B->then_instructions;

                        ir_variable *const r230D = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r230D, r2234, 0x01));

                        ir_variable *const r230E = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r230E, neg(r2233), 0x01));

                        ir_variable *const r230F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r230F);
                        ir_variable *const r2310 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2310);
                        ir_variable *const r2311 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2311);
                        ir_variable *const r2312 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2313 = neg(r230E);
                        body.emit(assign(r2312, bit_and(r2313, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2315 = equal(r230E, body.constant(int(0)));
                        ir_if *f2314 = new(mem_ctx) ir_if(operand(r2315).val);
                        exec_list *const f2314_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2314->then_instructions;

                           body.emit(assign(r230F, r2234, 0x01));

                           body.emit(assign(r2310, r22EF, 0x01));

                           body.emit(assign(r2311, r22EE, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2314->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2317 = less(r230E, body.constant(int(32)));
                           ir_if *f2316 = new(mem_ctx) ir_if(operand(r2317).val);
                           exec_list *const f2316_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2316->then_instructions;

                              body.emit(assign(r230F, lshift(r22EF, r2312), 0x01));

                              ir_expression *const r2318 = lshift(r22EE, r2312);
                              ir_expression *const r2319 = rshift(r22EF, r230E);
                              body.emit(assign(r2310, bit_or(r2318, r2319), 0x01));

                              body.emit(assign(r2311, rshift(r22EE, r230E), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2316->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r231B = equal(r230E, body.constant(int(32)));
                              ir_if *f231A = new(mem_ctx) ir_if(operand(r231B).val);
                              exec_list *const f231A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f231A->then_instructions;

                                 body.emit(assign(r230F, r22EF, 0x01));

                                 body.emit(assign(r2310, r22EE, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f231A->else_instructions;

                                 body.emit(assign(r230D, bit_or(r2234, r22EF), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r231D = less(r230E, body.constant(int(64)));
                                 ir_if *f231C = new(mem_ctx) ir_if(operand(r231D).val);
                                 exec_list *const f231C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f231C->then_instructions;

                                    body.emit(assign(r230F, lshift(r22EE, r2312), 0x01));

                                    ir_expression *const r231E = bit_and(r230E, body.constant(int(31)));
                                    body.emit(assign(r2310, rshift(r22EE, r231E), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f231C->else_instructions;

                                    ir_variable *const r231F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2321 = equal(r230E, body.constant(int(64)));
                                    ir_if *f2320 = new(mem_ctx) ir_if(operand(r2321).val);
                                    exec_list *const f2320_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2320->then_instructions;

                                       body.emit(assign(r231F, r22EE, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2320->else_instructions;

                                       ir_expression *const r2322 = nequal(r22EE, body.constant(0u));
                                       ir_expression *const r2323 = expr(ir_unop_b2i, r2322);
                                       body.emit(assign(r231F, expr(ir_unop_i2u, r2323), 0x01));


                                    body.instructions = f2320_parent_instructions;
                                    body.emit(f2320);

                                    /* END IF */

                                    body.emit(assign(r230F, r231F, 0x01));

                                    body.emit(assign(r2310, body.constant(0u), 0x01));


                                 body.instructions = f231C_parent_instructions;
                                 body.emit(f231C);

                                 /* END IF */


                              body.instructions = f231A_parent_instructions;
                              body.emit(f231A);

                              /* END IF */

                              body.emit(assign(r2311, body.constant(0u), 0x01));


                           body.instructions = f2316_parent_instructions;
                           body.emit(f2316);

                           /* END IF */

                           ir_expression *const r2324 = nequal(r230D, body.constant(0u));
                           ir_expression *const r2325 = expr(ir_unop_b2i, r2324);
                           ir_expression *const r2326 = expr(ir_unop_i2u, r2325);
                           body.emit(assign(r230F, bit_or(r230F, r2326), 0x01));


                        body.instructions = f2314_parent_instructions;
                        body.emit(f2314);

                        /* END IF */

                        body.emit(assign(r22F7, r2311, 0x01));

                        body.emit(assign(r22F8, r2310, 0x01));

                        body.emit(assign(r22F9, r230F, 0x01));

                        body.emit(assign(r22F6, body.constant(int(0)), 0x01));

                        body.emit(assign(r22FC, less(r230F, body.constant(0u)), 0x01));


                     body.instructions = f230B_parent_instructions;
                     body.emit(f230B);

                     /* END IF */


                  body.instructions = f2308_parent_instructions;
                  body.emit(f2308);

                  /* END IF */


               body.instructions = f22FE_parent_instructions;
               body.emit(f22FE);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2327 = new(mem_ctx) ir_if(operand(r22FA).val);
               exec_list *const f2327_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2327->then_instructions;

                  /* IF CONDITION */
                  ir_if *f2328 = new(mem_ctx) ir_if(operand(r22FC).val);
                  exec_list *const f2328_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2328->then_instructions;

                     ir_variable *const r2329 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r2329, add(r22F8, body.constant(1u)), 0x01));

                     ir_expression *const r232A = less(r2329, r22F8);
                     ir_expression *const r232B = expr(ir_unop_b2i, r232A);
                     ir_expression *const r232C = expr(ir_unop_i2u, r232B);
                     body.emit(assign(r22F7, add(r22F7, r232C), 0x01));

                     ir_expression *const r232D = equal(r22F9, body.constant(0u));
                     ir_expression *const r232E = expr(ir_unop_b2i, r232D);
                     ir_expression *const r232F = expr(ir_unop_i2u, r232E);
                     ir_expression *const r2330 = add(r22F9, r232F);
                     ir_expression *const r2331 = bit_and(r2330, body.constant(1u));
                     ir_expression *const r2332 = expr(ir_unop_bit_not, r2331);
                     body.emit(assign(r22F8, bit_and(r2329, r2332), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2328->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2334 = bit_or(r22F7, r22F8);
                     ir_expression *const r2335 = equal(r2334, body.constant(0u));
                     ir_if *f2333 = new(mem_ctx) ir_if(operand(r2335).val);
                     exec_list *const f2333_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2333->then_instructions;

                        body.emit(assign(r22F6, body.constant(int(0)), 0x01));


                     body.instructions = f2333_parent_instructions;
                     body.emit(f2333);

                     /* END IF */


                  body.instructions = f2328_parent_instructions;
                  body.emit(f2328);

                  /* END IF */

                  ir_variable *const r2336 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2336);
                  ir_expression *const r2337 = lshift(r1E6F, body.constant(int(31)));
                  ir_expression *const r2338 = expr(ir_unop_i2u, r22F6);
                  ir_expression *const r2339 = lshift(r2338, body.constant(int(20)));
                  ir_expression *const r233A = add(r2337, r2339);
                  body.emit(assign(r2336, add(r233A, r22F7), 0x02));

                  body.emit(assign(r2336, r22F8, 0x01));

                  body.emit(assign(r22FB, r2336, 0x03));

                  body.emit(assign(r22FA, body.constant(false), 0x01));


               body.instructions = f2327_parent_instructions;
               body.emit(f2327);

               /* END IF */

               body.emit(assign(r222F, r22FB, 0x03));

               body.emit(assign(r222E, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f22F4->else_instructions;

               body.emit(assign(r2233, add(r2233, body.constant(int(1))), 0x01));

               ir_variable *const r233B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r233B);
               ir_variable *const r233C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r233C);
               ir_variable *const r233D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r233D);
               body.emit(assign(r233B, lshift(r22EF, body.constant(int(31))), 0x01));

               ir_expression *const r233E = lshift(r22EE, body.constant(int(31)));
               ir_expression *const r233F = rshift(r22EF, body.constant(int(1)));
               body.emit(assign(r233C, bit_or(r233E, r233F), 0x01));

               body.emit(assign(r233D, rshift(r22EE, body.constant(int(1))), 0x01));

               ir_expression *const r2340 = nequal(r2234, body.constant(0u));
               ir_expression *const r2341 = expr(ir_unop_b2i, r2340);
               ir_expression *const r2342 = expr(ir_unop_i2u, r2341);
               body.emit(assign(r233B, bit_or(r233B, r2342), 0x01));

               body.emit(assign(r2235, r233D, 0x01));

               body.emit(assign(r2234, r233B, 0x01));

               ir_variable *const r2343 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2343, r2233, 0x01));

               ir_variable *const r2344 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2344, r233D, 0x01));

               ir_variable *const r2345 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2345, r233C, 0x01));

               ir_variable *const r2346 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r2346, r233B, 0x01));

               ir_variable *const r2347 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r2347, body.constant(true), 0x01));

               ir_variable *const r2348 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2349 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2349);
               ir_expression *const r234A = expr(ir_unop_u2i, r233B);
               body.emit(assign(r2349, less(r234A, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r234C = lequal(body.constant(int(2045)), r2233);
               ir_if *f234B = new(mem_ctx) ir_if(operand(r234C).val);
               exec_list *const f234B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f234B->then_instructions;

                  ir_variable *const r234D = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r234F = less(body.constant(int(2045)), r2233);
                  ir_if *f234E = new(mem_ctx) ir_if(operand(r234F).val);
                  exec_list *const f234E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f234E->then_instructions;

                     body.emit(assign(r234D, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f234E->else_instructions;

                     ir_variable *const r2350 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2352 = equal(r2233, body.constant(int(2045)));
                     ir_if *f2351 = new(mem_ctx) ir_if(operand(r2352).val);
                     exec_list *const f2351_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2351->then_instructions;

                        ir_expression *const r2353 = equal(body.constant(2097151u), r233D);
                        ir_expression *const r2354 = equal(body.constant(4294967295u), r233C);
                        body.emit(assign(r2350, logic_and(r2353, r2354), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2351->else_instructions;

                        body.emit(assign(r2350, body.constant(false), 0x01));


                     body.instructions = f2351_parent_instructions;
                     body.emit(f2351);

                     /* END IF */

                     body.emit(assign(r234D, logic_and(r2350, r2349), 0x01));


                  body.instructions = f234E_parent_instructions;
                  body.emit(f234E);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2355 = new(mem_ctx) ir_if(operand(r234D).val);
                  exec_list *const f2355_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2355->then_instructions;

                     ir_variable *const r2356 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2356);
                     ir_expression *const r2357 = lshift(r1E6F, body.constant(int(31)));
                     body.emit(assign(r2356, add(r2357, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r2356, body.constant(0u), 0x01));

                     body.emit(assign(r2348, r2356, 0x03));

                     body.emit(assign(r2347, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2355->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2359 = less(r2233, body.constant(int(0)));
                     ir_if *f2358 = new(mem_ctx) ir_if(operand(r2359).val);
                     exec_list *const f2358_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2358->then_instructions;

                        ir_variable *const r235A = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r235A, r233B, 0x01));

                        ir_variable *const r235B = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r235B, neg(r2233), 0x01));

                        ir_variable *const r235C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r235C);
                        ir_variable *const r235D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r235D);
                        ir_variable *const r235E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r235E);
                        ir_variable *const r235F = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2360 = neg(r235B);
                        body.emit(assign(r235F, bit_and(r2360, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2362 = equal(r235B, body.constant(int(0)));
                        ir_if *f2361 = new(mem_ctx) ir_if(operand(r2362).val);
                        exec_list *const f2361_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2361->then_instructions;

                           body.emit(assign(r235C, r233B, 0x01));

                           body.emit(assign(r235D, r233C, 0x01));

                           body.emit(assign(r235E, r233D, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2361->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2364 = less(r235B, body.constant(int(32)));
                           ir_if *f2363 = new(mem_ctx) ir_if(operand(r2364).val);
                           exec_list *const f2363_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2363->then_instructions;

                              body.emit(assign(r235C, lshift(r233C, r235F), 0x01));

                              ir_expression *const r2365 = lshift(r233D, r235F);
                              ir_expression *const r2366 = rshift(r233C, r235B);
                              body.emit(assign(r235D, bit_or(r2365, r2366), 0x01));

                              body.emit(assign(r235E, rshift(r233D, r235B), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2363->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2368 = equal(r235B, body.constant(int(32)));
                              ir_if *f2367 = new(mem_ctx) ir_if(operand(r2368).val);
                              exec_list *const f2367_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2367->then_instructions;

                                 body.emit(assign(r235C, r233C, 0x01));

                                 body.emit(assign(r235D, r233D, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2367->else_instructions;

                                 body.emit(assign(r235A, bit_or(r233B, r233C), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r236A = less(r235B, body.constant(int(64)));
                                 ir_if *f2369 = new(mem_ctx) ir_if(operand(r236A).val);
                                 exec_list *const f2369_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2369->then_instructions;

                                    body.emit(assign(r235C, lshift(r233D, r235F), 0x01));

                                    ir_expression *const r236B = bit_and(r235B, body.constant(int(31)));
                                    body.emit(assign(r235D, rshift(r233D, r236B), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2369->else_instructions;

                                    ir_variable *const r236C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r236E = equal(r235B, body.constant(int(64)));
                                    ir_if *f236D = new(mem_ctx) ir_if(operand(r236E).val);
                                    exec_list *const f236D_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f236D->then_instructions;

                                       body.emit(assign(r236C, r233D, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f236D->else_instructions;

                                       ir_expression *const r236F = nequal(r233D, body.constant(0u));
                                       ir_expression *const r2370 = expr(ir_unop_b2i, r236F);
                                       body.emit(assign(r236C, expr(ir_unop_i2u, r2370), 0x01));


                                    body.instructions = f236D_parent_instructions;
                                    body.emit(f236D);

                                    /* END IF */

                                    body.emit(assign(r235C, r236C, 0x01));

                                    body.emit(assign(r235D, body.constant(0u), 0x01));


                                 body.instructions = f2369_parent_instructions;
                                 body.emit(f2369);

                                 /* END IF */


                              body.instructions = f2367_parent_instructions;
                              body.emit(f2367);

                              /* END IF */

                              body.emit(assign(r235E, body.constant(0u), 0x01));


                           body.instructions = f2363_parent_instructions;
                           body.emit(f2363);

                           /* END IF */

                           ir_expression *const r2371 = nequal(r235A, body.constant(0u));
                           ir_expression *const r2372 = expr(ir_unop_b2i, r2371);
                           ir_expression *const r2373 = expr(ir_unop_i2u, r2372);
                           body.emit(assign(r235C, bit_or(r235C, r2373), 0x01));


                        body.instructions = f2361_parent_instructions;
                        body.emit(f2361);

                        /* END IF */

                        body.emit(assign(r2344, r235E, 0x01));

                        body.emit(assign(r2345, r235D, 0x01));

                        body.emit(assign(r2346, r235C, 0x01));

                        body.emit(assign(r2343, body.constant(int(0)), 0x01));

                        body.emit(assign(r2349, less(r235C, body.constant(0u)), 0x01));


                     body.instructions = f2358_parent_instructions;
                     body.emit(f2358);

                     /* END IF */


                  body.instructions = f2355_parent_instructions;
                  body.emit(f2355);

                  /* END IF */


               body.instructions = f234B_parent_instructions;
               body.emit(f234B);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2374 = new(mem_ctx) ir_if(operand(r2347).val);
               exec_list *const f2374_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2374->then_instructions;

                  /* IF CONDITION */
                  ir_if *f2375 = new(mem_ctx) ir_if(operand(r2349).val);
                  exec_list *const f2375_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2375->then_instructions;

                     ir_variable *const r2376 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r2376, add(r2345, body.constant(1u)), 0x01));

                     ir_expression *const r2377 = less(r2376, r2345);
                     ir_expression *const r2378 = expr(ir_unop_b2i, r2377);
                     ir_expression *const r2379 = expr(ir_unop_i2u, r2378);
                     body.emit(assign(r2344, add(r2344, r2379), 0x01));

                     ir_expression *const r237A = equal(r2346, body.constant(0u));
                     ir_expression *const r237B = expr(ir_unop_b2i, r237A);
                     ir_expression *const r237C = expr(ir_unop_i2u, r237B);
                     ir_expression *const r237D = add(r2346, r237C);
                     ir_expression *const r237E = bit_and(r237D, body.constant(1u));
                     ir_expression *const r237F = expr(ir_unop_bit_not, r237E);
                     body.emit(assign(r2345, bit_and(r2376, r237F), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2375->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2381 = bit_or(r2344, r2345);
                     ir_expression *const r2382 = equal(r2381, body.constant(0u));
                     ir_if *f2380 = new(mem_ctx) ir_if(operand(r2382).val);
                     exec_list *const f2380_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2380->then_instructions;

                        body.emit(assign(r2343, body.constant(int(0)), 0x01));


                     body.instructions = f2380_parent_instructions;
                     body.emit(f2380);

                     /* END IF */


                  body.instructions = f2375_parent_instructions;
                  body.emit(f2375);

                  /* END IF */

                  ir_variable *const r2383 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2383);
                  ir_expression *const r2384 = lshift(r1E6F, body.constant(int(31)));
                  ir_expression *const r2385 = expr(ir_unop_i2u, r2343);
                  ir_expression *const r2386 = lshift(r2385, body.constant(int(20)));
                  ir_expression *const r2387 = add(r2384, r2386);
                  body.emit(assign(r2383, add(r2387, r2344), 0x02));

                  body.emit(assign(r2383, r2345, 0x01));

                  body.emit(assign(r2348, r2383, 0x03));

                  body.emit(assign(r2347, body.constant(false), 0x01));


               body.instructions = f2374_parent_instructions;
               body.emit(f2374);

               /* END IF */

               body.emit(assign(r222F, r2348, 0x03));

               body.emit(assign(r222E, body.constant(false), 0x01));


            body.instructions = f22F4_parent_instructions;
            body.emit(f22F4);

            /* END IF */


         body.instructions = f22ED_parent_instructions;
         body.emit(f22ED);

         /* END IF */

         body.emit(assign(r1E6E, r222F, 0x03));


      body.instructions = f1E70_parent_instructions;
      body.emit(f1E70);

      /* END IF */

      body.emit(assign(r1E6C, r1E6E, 0x03));


   body.instructions = f1E6D_parent_instructions;
   body.emit(f1E6D);

   /* END IF */

   body.emit(ret(r1E6C));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fceil64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r2388 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r2388);
   ir_variable *const r2389 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r238A = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r238B = rshift(swizzle_y(r2388), body.constant(int(20)));
   ir_expression *const r238C = bit_and(r238B, body.constant(2047u));
   ir_expression *const r238D = expr(ir_unop_u2i, r238C);
   body.emit(assign(r238A, add(r238D, body.constant(int(-1023))), 0x01));

   /* IF CONDITION */
   ir_expression *const r238F = less(r238A, body.constant(int(0)));
   ir_if *f238E = new(mem_ctx) ir_if(operand(r238F).val);
   exec_list *const f238E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f238E->then_instructions;

      body.emit(assign(r2389, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f238E->else_instructions;

      /* IF CONDITION */
      ir_expression *const r2391 = greater(r238A, body.constant(int(52)));
      ir_if *f2390 = new(mem_ctx) ir_if(operand(r2391).val);
      exec_list *const f2390_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f2390->then_instructions;

         body.emit(assign(r2389, r2388, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f2390->else_instructions;

         ir_variable *const r2392 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r2392);
         ir_variable *const r2393 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r2393, sub(body.constant(int(52)), r238A), 0x01));

         ir_variable *const r2394 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r2396 = gequal(r2393, body.constant(int(32)));
         ir_if *f2395 = new(mem_ctx) ir_if(operand(r2396).val);
         exec_list *const f2395_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2395->then_instructions;

            body.emit(assign(r2394, body.constant(0u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2395->else_instructions;

            body.emit(assign(r2394, lshift(body.constant(4294967295u), r2393), 0x01));


         body.instructions = f2395_parent_instructions;
         body.emit(f2395);

         /* END IF */

         ir_variable *const r2397 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r2399 = less(r2393, body.constant(int(33)));
         ir_if *f2398 = new(mem_ctx) ir_if(operand(r2399).val);
         exec_list *const f2398_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2398->then_instructions;

            body.emit(assign(r2397, body.constant(4294967295u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2398->else_instructions;

            ir_expression *const r239A = add(r2393, body.constant(int(-32)));
            body.emit(assign(r2397, lshift(body.constant(4294967295u), r239A), 0x01));


         body.instructions = f2398_parent_instructions;
         body.emit(f2398);

         /* END IF */

         body.emit(assign(r2392, bit_and(r2394, swizzle_x(r2388)), 0x01));

         body.emit(assign(r2392, bit_and(r2397, swizzle_y(r2388)), 0x02));

         body.emit(assign(r2389, r2392, 0x03));


      body.instructions = f2390_parent_instructions;
      body.emit(f2390);

      /* END IF */


   body.instructions = f238E_parent_instructions;
   body.emit(f238E);

   /* END IF */

   ir_variable *const r239B = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r239B, rshift(swizzle_y(r2388), body.constant(int(31))), 0x01));

   ir_variable *const r239C = body.make_temp(glsl_type::bool_type, "or_tmp");
   /* IF CONDITION */
   ir_expression *const r239E = expr(ir_unop_u2i, r239B);
   ir_expression *const r239F = expr(ir_unop_i2b, r239E);
   ir_if *f239D = new(mem_ctx) ir_if(operand(r239F).val);
   exec_list *const f239D_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f239D->then_instructions;

      body.emit(assign(r239C, body.constant(true), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f239D->else_instructions;

      ir_variable *const r23A0 = body.make_temp(glsl_type::bool_type, "return_value");
      ir_variable *const r23A1 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
      body.emit(r23A1);
      ir_variable *const r23A2 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
      body.emit(r23A2);
      ir_variable *const r23A3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r23A3);
      body.emit(assign(r23A3, bit_and(swizzle_y(r2388), body.constant(1048575u)), 0x02));

      body.emit(assign(r23A3, swizzle_x(r2388), 0x01));

      ir_variable *const r23A4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r23A4);
      body.emit(assign(r23A4, bit_and(swizzle_y(r2389), body.constant(1048575u)), 0x02));

      body.emit(assign(r23A4, swizzle_x(r2389), 0x01));

      ir_expression *const r23A5 = rshift(swizzle_y(r2388), body.constant(int(20)));
      ir_expression *const r23A6 = bit_and(r23A5, body.constant(2047u));
      ir_expression *const r23A7 = expr(ir_unop_u2i, r23A6);
      ir_expression *const r23A8 = equal(r23A7, body.constant(int(2047)));
      ir_expression *const r23A9 = bit_or(swizzle_y(r23A3), swizzle_x(r2388));
      ir_expression *const r23AA = nequal(r23A9, body.constant(0u));
      body.emit(assign(r23A2, logic_and(r23A8, r23AA), 0x01));

      ir_expression *const r23AB = rshift(swizzle_y(r2389), body.constant(int(20)));
      ir_expression *const r23AC = bit_and(r23AB, body.constant(2047u));
      ir_expression *const r23AD = expr(ir_unop_u2i, r23AC);
      ir_expression *const r23AE = equal(r23AD, body.constant(int(2047)));
      ir_expression *const r23AF = bit_or(swizzle_y(r23A4), swizzle_x(r2389));
      ir_expression *const r23B0 = nequal(r23AF, body.constant(0u));
      body.emit(assign(r23A1, logic_and(r23AE, r23B0), 0x01));

      /* IF CONDITION */
      ir_expression *const r23B2 = logic_or(r23A2, r23A1);
      ir_if *f23B1 = new(mem_ctx) ir_if(operand(r23B2).val);
      exec_list *const f23B1_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f23B1->then_instructions;

         body.emit(assign(r23A0, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f23B1->else_instructions;

         ir_expression *const r23B3 = equal(swizzle_x(r2388), swizzle_x(r2389));
         ir_expression *const r23B4 = equal(swizzle_y(r2388), swizzle_y(r2389));
         ir_expression *const r23B5 = equal(swizzle_x(r2388), body.constant(0u));
         ir_expression *const r23B6 = bit_or(swizzle_y(r2388), swizzle_y(r2389));
         ir_expression *const r23B7 = lshift(r23B6, body.constant(int(1)));
         ir_expression *const r23B8 = equal(r23B7, body.constant(0u));
         ir_expression *const r23B9 = logic_and(r23B5, r23B8);
         ir_expression *const r23BA = logic_or(r23B4, r23B9);
         body.emit(assign(r23A0, logic_and(r23B3, r23BA), 0x01));


      body.instructions = f23B1_parent_instructions;
      body.emit(f23B1);

      /* END IF */

      body.emit(assign(r239C, r23A0, 0x01));


   body.instructions = f239D_parent_instructions;
   body.emit(f239D);

   /* END IF */

   ir_variable *const r23BB = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
   /* IF CONDITION */
   ir_if *f23BC = new(mem_ctx) ir_if(operand(r239C).val);
   exec_list *const f23BC_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f23BC->then_instructions;

      body.emit(assign(r23BB, r2389, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f23BC->else_instructions;

      ir_variable *const r23BD = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r23BE = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r23BE, rshift(swizzle_y(r2389), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r23C0 = equal(r23BE, body.constant(0u));
      ir_if *f23BF = new(mem_ctx) ir_if(operand(r23C0).val);
      exec_list *const f23BF_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f23BF->then_instructions;

         ir_variable *const r23C1 = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r23C1, body.constant(true), 0x01));

         ir_variable *const r23C2 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r23C3 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r23C3);
         ir_variable *const r23C4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
         body.emit(r23C4);
         ir_variable *const r23C5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
         body.emit(r23C5);
         ir_variable *const r23C6 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r23C6);
         ir_variable *const r23C7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
         body.emit(r23C7);
         ir_variable *const r23C8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
         body.emit(r23C8);
         body.emit(assign(r23C8, body.constant(0u), 0x01));

         body.emit(assign(r23C7, body.constant(0u), 0x01));

         ir_variable *const r23C9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
         body.emit(r23C9);
         body.emit(assign(r23C9, bit_and(swizzle_y(r2389), body.constant(1048575u)), 0x02));

         body.emit(assign(r23C9, swizzle_x(r2389), 0x01));

         body.emit(assign(r23C5, r23C9, 0x03));

         ir_variable *const r23CA = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r23CB = rshift(swizzle_y(r2389), body.constant(int(20)));
         ir_expression *const r23CC = bit_and(r23CB, body.constant(2047u));
         body.emit(assign(r23CA, expr(ir_unop_u2i, r23CC), 0x01));

         ir_variable *const r23CD = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
         body.emit(r23CD);
         body.emit(assign(r23CD, body.constant(0u), 0x02));

         body.emit(assign(r23CD, body.constant(0u), 0x01));

         body.emit(assign(r23C4, r23CD, 0x03));

         ir_variable *const r23CE = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         body.emit(assign(r23CE, body.constant(int(1023)), 0x01));

         ir_variable *const r23CF = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r23CF, add(r23CA, body.constant(int(-1023))), 0x01));

         body.emit(assign(r23C3, r23CF, 0x01));

         /* IF CONDITION */
         ir_expression *const r23D1 = less(body.constant(int(0)), r23CF);
         ir_if *f23D0 = new(mem_ctx) ir_if(operand(r23D1).val);
         exec_list *const f23D0_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f23D0->then_instructions;

            /* IF CONDITION */
            ir_expression *const r23D3 = equal(r23CA, body.constant(int(2047)));
            ir_if *f23D2 = new(mem_ctx) ir_if(operand(r23D3).val);
            exec_list *const f23D2_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f23D2->then_instructions;

               /* IF CONDITION */
               ir_expression *const r23D5 = bit_or(swizzle_y(r23C9), swizzle_x(r2389));
               ir_expression *const r23D6 = nequal(r23D5, body.constant(0u));
               ir_if *f23D4 = new(mem_ctx) ir_if(operand(r23D6).val);
               exec_list *const f23D4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f23D4->then_instructions;

                  ir_variable *const r23D7 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r23D7, swizzle_x(r2389), 0x01));

                  ir_variable *const r23D8 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r23D8, body.constant(0u), 0x01));

                  ir_variable *const r23D9 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r23D7, bit_or(swizzle_y(r2389), body.constant(524288u)), 0x02));

                  body.emit(assign(r23D8, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r23DB = lshift(swizzle_y(r2389), body.constant(int(1)));
                  ir_expression *const r23DC = lequal(body.constant(4292870144u), r23DB);
                  ir_expression *const r23DD = nequal(swizzle_x(r2389), body.constant(0u));
                  ir_expression *const r23DE = bit_and(swizzle_y(r2389), body.constant(1048575u));
                  ir_expression *const r23DF = nequal(r23DE, body.constant(0u));
                  ir_expression *const r23E0 = logic_or(r23DD, r23DF);
                  ir_expression *const r23E1 = logic_and(r23DC, r23E0);
                  ir_if *f23DA = new(mem_ctx) ir_if(operand(r23E1).val);
                  exec_list *const f23DA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f23DA->then_instructions;

                     body.emit(assign(r23D9, r23D7, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f23DA->else_instructions;

                     body.emit(assign(r23D9, r23D8, 0x03));


                  body.instructions = f23DA_parent_instructions;
                  body.emit(f23DA);

                  /* END IF */

                  body.emit(assign(r23C2, r23D9, 0x03));

                  body.emit(assign(r23C1, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f23D4->else_instructions;

                  body.emit(assign(r23C2, r2389, 0x03));

                  body.emit(assign(r23C1, body.constant(false), 0x01));


               body.instructions = f23D4_parent_instructions;
               body.emit(f23D4);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f23D2->else_instructions;

               body.emit(assign(r23C4, body.constant(1048576u), 0x02));

               ir_variable *const r23E2 = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r23E2, swizzle_y(r23C4), 0x01));

               ir_variable *const r23E3 = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r23E3, swizzle_x(r23C4), 0x01));

               ir_variable *const r23E4 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r23E4, body.constant(0u), 0x01));

               ir_variable *const r23E5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r23E5);
               ir_variable *const r23E6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r23E6);
               ir_variable *const r23E7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r23E7);
               ir_variable *const r23E8 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r23E9 = neg(r23CF);
               body.emit(assign(r23E8, bit_and(r23E9, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r23EB = equal(r23CF, body.constant(int(0)));
               ir_if *f23EA = new(mem_ctx) ir_if(operand(r23EB).val);
               exec_list *const f23EA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f23EA->then_instructions;

                  body.emit(assign(r23E5, r23E4, 0x01));

                  body.emit(assign(r23E6, r23E3, 0x01));

                  body.emit(assign(r23E7, r23E2, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f23EA->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r23ED = less(r23CF, body.constant(int(32)));
                  ir_if *f23EC = new(mem_ctx) ir_if(operand(r23ED).val);
                  exec_list *const f23EC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f23EC->then_instructions;

                     body.emit(assign(r23E5, body.constant(0u), 0x01));

                     ir_expression *const r23EE = lshift(body.constant(1048576u), r23E8);
                     body.emit(assign(r23E6, bit_or(r23EE, body.constant(0u)), 0x01));

                     body.emit(assign(r23E7, rshift(body.constant(1048576u), r23CF), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f23EC->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r23F0 = equal(r23CF, body.constant(int(32)));
                     ir_if *f23EF = new(mem_ctx) ir_if(operand(r23F0).val);
                     exec_list *const f23EF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f23EF->then_instructions;

                        body.emit(assign(r23E5, r23E3, 0x01));

                        body.emit(assign(r23E6, r23E2, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f23EF->else_instructions;

                        body.emit(assign(r23E4, body.constant(0u), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r23F2 = less(r23CF, body.constant(int(64)));
                        ir_if *f23F1 = new(mem_ctx) ir_if(operand(r23F2).val);
                        exec_list *const f23F1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f23F1->then_instructions;

                           body.emit(assign(r23E5, lshift(body.constant(1048576u), r23E8), 0x01));

                           ir_expression *const r23F3 = bit_and(r23CF, body.constant(int(31)));
                           body.emit(assign(r23E6, rshift(body.constant(1048576u), r23F3), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f23F1->else_instructions;

                           ir_variable *const r23F4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r23F6 = equal(r23CF, body.constant(int(64)));
                           ir_if *f23F5 = new(mem_ctx) ir_if(operand(r23F6).val);
                           exec_list *const f23F5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f23F5->then_instructions;

                              body.emit(assign(r23F4, r23E2, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f23F5->else_instructions;

                              body.emit(assign(r23F4, body.constant(1u), 0x01));


                           body.instructions = f23F5_parent_instructions;
                           body.emit(f23F5);

                           /* END IF */

                           body.emit(assign(r23E5, r23F4, 0x01));

                           body.emit(assign(r23E6, body.constant(0u), 0x01));


                        body.instructions = f23F1_parent_instructions;
                        body.emit(f23F1);

                        /* END IF */


                     body.instructions = f23EF_parent_instructions;
                     body.emit(f23EF);

                     /* END IF */

                     body.emit(assign(r23E7, body.constant(0u), 0x01));


                  body.instructions = f23EC_parent_instructions;
                  body.emit(f23EC);

                  /* END IF */

                  ir_expression *const r23F7 = nequal(r23E4, body.constant(0u));
                  ir_expression *const r23F8 = expr(ir_unop_b2i, r23F7);
                  ir_expression *const r23F9 = expr(ir_unop_i2u, r23F8);
                  body.emit(assign(r23E5, bit_or(r23E5, r23F9), 0x01));


               body.instructions = f23EA_parent_instructions;
               body.emit(f23EA);

               /* END IF */

               body.emit(assign(r23C4, r23E7, 0x02));

               body.emit(assign(r23C4, r23E6, 0x01));

               body.emit(assign(r23C7, r23E5, 0x01));

               body.emit(assign(r23C6, r23CA, 0x01));


            body.instructions = f23D2_parent_instructions;
            body.emit(f23D2);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f23D0->else_instructions;

            /* IF CONDITION */
            ir_expression *const r23FB = less(r23CF, body.constant(int(0)));
            ir_if *f23FA = new(mem_ctx) ir_if(operand(r23FB).val);
            exec_list *const f23FA_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f23FA->then_instructions;

               /* IF CONDITION */
               ir_expression *const r23FD = equal(r23CA, body.constant(int(0)));
               ir_if *f23FC = new(mem_ctx) ir_if(operand(r23FD).val);
               exec_list *const f23FC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f23FC->then_instructions;

                  body.emit(assign(r23C3, add(r23CF, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f23FC->else_instructions;

                  body.emit(assign(r23C5, bit_or(swizzle_y(r23C9), body.constant(1048576u)), 0x02));


               body.instructions = f23FC_parent_instructions;
               body.emit(f23FC);

               /* END IF */

               ir_variable *const r23FE = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r23FE, swizzle_y(r23C5), 0x01));

               ir_variable *const r23FF = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r23FF, swizzle_x(r23C5), 0x01));

               ir_variable *const r2400 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r2400, body.constant(0u), 0x01));

               ir_variable *const r2401 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r2401, neg(r23C3), 0x01));

               ir_variable *const r2402 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r2402);
               ir_variable *const r2403 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2403);
               ir_variable *const r2404 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2404);
               ir_variable *const r2405 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2406 = neg(r2401);
               body.emit(assign(r2405, bit_and(r2406, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2408 = equal(r2401, body.constant(int(0)));
               ir_if *f2407 = new(mem_ctx) ir_if(operand(r2408).val);
               exec_list *const f2407_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2407->then_instructions;

                  body.emit(assign(r2402, r2400, 0x01));

                  body.emit(assign(r2403, r23FF, 0x01));

                  body.emit(assign(r2404, r23FE, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2407->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r240A = less(r2401, body.constant(int(32)));
                  ir_if *f2409 = new(mem_ctx) ir_if(operand(r240A).val);
                  exec_list *const f2409_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2409->then_instructions;

                     body.emit(assign(r2402, lshift(swizzle_x(r23C9), r2405), 0x01));

                     ir_expression *const r240B = lshift(swizzle_y(r23C5), r2405);
                     ir_expression *const r240C = rshift(swizzle_x(r23C9), r2401);
                     body.emit(assign(r2403, bit_or(r240B, r240C), 0x01));

                     body.emit(assign(r2404, rshift(swizzle_y(r23C5), r2401), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2409->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r240E = equal(r2401, body.constant(int(32)));
                     ir_if *f240D = new(mem_ctx) ir_if(operand(r240E).val);
                     exec_list *const f240D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f240D->then_instructions;

                        body.emit(assign(r2402, r23FF, 0x01));

                        body.emit(assign(r2403, r23FE, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f240D->else_instructions;

                        body.emit(assign(r2400, bit_or(body.constant(0u), swizzle_x(r23C9)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2410 = less(r2401, body.constant(int(64)));
                        ir_if *f240F = new(mem_ctx) ir_if(operand(r2410).val);
                        exec_list *const f240F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f240F->then_instructions;

                           body.emit(assign(r2402, lshift(swizzle_y(r23C5), r2405), 0x01));

                           ir_expression *const r2411 = bit_and(r2401, body.constant(int(31)));
                           body.emit(assign(r2403, rshift(swizzle_y(r23C5), r2411), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f240F->else_instructions;

                           ir_variable *const r2412 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2414 = equal(r2401, body.constant(int(64)));
                           ir_if *f2413 = new(mem_ctx) ir_if(operand(r2414).val);
                           exec_list *const f2413_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2413->then_instructions;

                              body.emit(assign(r2412, r23FE, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2413->else_instructions;

                              ir_expression *const r2415 = nequal(swizzle_y(r23C5), body.constant(0u));
                              ir_expression *const r2416 = expr(ir_unop_b2i, r2415);
                              body.emit(assign(r2412, expr(ir_unop_i2u, r2416), 0x01));


                           body.instructions = f2413_parent_instructions;
                           body.emit(f2413);

                           /* END IF */

                           body.emit(assign(r2402, r2412, 0x01));

                           body.emit(assign(r2403, body.constant(0u), 0x01));


                        body.instructions = f240F_parent_instructions;
                        body.emit(f240F);

                        /* END IF */


                     body.instructions = f240D_parent_instructions;
                     body.emit(f240D);

                     /* END IF */

                     body.emit(assign(r2404, body.constant(0u), 0x01));


                  body.instructions = f2409_parent_instructions;
                  body.emit(f2409);

                  /* END IF */

                  ir_expression *const r2417 = nequal(r2400, body.constant(0u));
                  ir_expression *const r2418 = expr(ir_unop_b2i, r2417);
                  ir_expression *const r2419 = expr(ir_unop_i2u, r2418);
                  body.emit(assign(r2402, bit_or(r2402, r2419), 0x01));


               body.instructions = f2407_parent_instructions;
               body.emit(f2407);

               /* END IF */

               body.emit(assign(r23C5, r2404, 0x02));

               body.emit(assign(r23C5, r2403, 0x01));

               body.emit(assign(r23C7, r2402, 0x01));

               body.emit(assign(r23C6, body.constant(int(1023)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f23FA->else_instructions;

               /* IF CONDITION */
               ir_expression *const r241B = equal(r23CA, body.constant(int(2047)));
               ir_if *f241A = new(mem_ctx) ir_if(operand(r241B).val);
               exec_list *const f241A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f241A->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r241D = bit_or(swizzle_y(r23C5), swizzle_x(r23C5));
                  ir_expression *const r241E = bit_or(swizzle_y(r23C4), swizzle_x(r23C4));
                  ir_expression *const r241F = bit_or(r241D, r241E);
                  ir_expression *const r2420 = nequal(r241F, body.constant(0u));
                  ir_if *f241C = new(mem_ctx) ir_if(operand(r2420).val);
                  exec_list *const f241C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f241C->then_instructions;

                     ir_variable *const r2421 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r2421, swizzle_x(r2389), 0x01));

                     ir_variable *const r2422 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r2422, body.constant(0u), 0x01));

                     ir_variable *const r2423 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r2421, bit_or(swizzle_y(r2389), body.constant(524288u)), 0x02));

                     body.emit(assign(r2422, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r2425 = lshift(swizzle_y(r2389), body.constant(int(1)));
                     ir_expression *const r2426 = lequal(body.constant(4292870144u), r2425);
                     ir_expression *const r2427 = nequal(swizzle_x(r2389), body.constant(0u));
                     ir_expression *const r2428 = bit_and(swizzle_y(r2389), body.constant(1048575u));
                     ir_expression *const r2429 = nequal(r2428, body.constant(0u));
                     ir_expression *const r242A = logic_or(r2427, r2429);
                     ir_expression *const r242B = logic_and(r2426, r242A);
                     ir_if *f2424 = new(mem_ctx) ir_if(operand(r242B).val);
                     exec_list *const f2424_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2424->then_instructions;

                        body.emit(assign(r2423, r2421, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2424->else_instructions;

                        body.emit(assign(r2423, r2422, 0x03));


                     body.instructions = f2424_parent_instructions;
                     body.emit(f2424);

                     /* END IF */

                     body.emit(assign(r23C2, r2423, 0x03));

                     body.emit(assign(r23C1, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f241C->else_instructions;

                     body.emit(assign(r23C2, r2389, 0x03));

                     body.emit(assign(r23C1, body.constant(false), 0x01));


                  body.instructions = f241C_parent_instructions;
                  body.emit(f241C);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f241A->else_instructions;

                  ir_variable *const r242C = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r242D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r242D, add(swizzle_x(r23C5), swizzle_x(r23C4)), 0x01));

                  ir_expression *const r242E = add(swizzle_y(r23C5), swizzle_y(r23C4));
                  ir_expression *const r242F = less(r242D, swizzle_x(r23C5));
                  ir_expression *const r2430 = expr(ir_unop_b2i, r242F);
                  ir_expression *const r2431 = expr(ir_unop_i2u, r2430);
                  body.emit(assign(r242C, add(r242E, r2431), 0x01));

                  body.emit(assign(r23C8, r242C, 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2433 = equal(r23CA, body.constant(int(0)));
                  ir_if *f2432 = new(mem_ctx) ir_if(operand(r2433).val);
                  exec_list *const f2432_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2432->then_instructions;

                     ir_variable *const r2434 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2434);
                     ir_expression *const r2435 = lshift(r23BE, body.constant(int(31)));
                     body.emit(assign(r2434, add(r2435, r242C), 0x02));

                     body.emit(assign(r2434, r242D, 0x01));

                     body.emit(assign(r23C2, r2434, 0x03));

                     body.emit(assign(r23C1, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2432->else_instructions;

                     body.emit(assign(r23C8, bit_or(r242C, body.constant(2097152u)), 0x01));

                     body.emit(assign(r23C6, r23CA, 0x01));

                     ir_variable *const r2436 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r2436);
                     ir_variable *const r2437 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r2437);
                     ir_variable *const r2438 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r2438);
                     body.emit(assign(r2436, lshift(r242D, body.constant(int(31))), 0x01));

                     ir_expression *const r2439 = lshift(r23C8, body.constant(int(31)));
                     ir_expression *const r243A = rshift(r242D, body.constant(int(1)));
                     body.emit(assign(r2437, bit_or(r2439, r243A), 0x01));

                     body.emit(assign(r2438, rshift(r23C8, body.constant(int(1))), 0x01));

                     body.emit(assign(r2436, bit_or(r2436, body.constant(0u)), 0x01));

                     body.emit(assign(r23C8, r2438, 0x01));

                     body.emit(assign(r23C7, r2436, 0x01));

                     ir_variable *const r243B = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r243B, r23CA, 0x01));

                     ir_variable *const r243C = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r243C, r2438, 0x01));

                     ir_variable *const r243D = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r243D, r2437, 0x01));

                     ir_variable *const r243E = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r243E, r2436, 0x01));

                     ir_variable *const r243F = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r243F, body.constant(true), 0x01));

                     ir_variable *const r2440 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r2441 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r2441);
                     ir_expression *const r2442 = expr(ir_unop_u2i, r2436);
                     body.emit(assign(r2441, less(r2442, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2444 = lequal(body.constant(int(2045)), r23CA);
                     ir_if *f2443 = new(mem_ctx) ir_if(operand(r2444).val);
                     exec_list *const f2443_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2443->then_instructions;

                        ir_variable *const r2445 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2447 = less(body.constant(int(2045)), r23CA);
                        ir_if *f2446 = new(mem_ctx) ir_if(operand(r2447).val);
                        exec_list *const f2446_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2446->then_instructions;

                           body.emit(assign(r2445, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2446->else_instructions;

                           ir_variable *const r2448 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r244A = equal(r23CA, body.constant(int(2045)));
                           ir_if *f2449 = new(mem_ctx) ir_if(operand(r244A).val);
                           exec_list *const f2449_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2449->then_instructions;

                              ir_expression *const r244B = equal(body.constant(2097151u), r2438);
                              ir_expression *const r244C = equal(body.constant(4294967295u), r2437);
                              body.emit(assign(r2448, logic_and(r244B, r244C), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2449->else_instructions;

                              body.emit(assign(r2448, body.constant(false), 0x01));


                           body.instructions = f2449_parent_instructions;
                           body.emit(f2449);

                           /* END IF */

                           body.emit(assign(r2445, logic_and(r2448, r2441), 0x01));


                        body.instructions = f2446_parent_instructions;
                        body.emit(f2446);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f244D = new(mem_ctx) ir_if(operand(r2445).val);
                        exec_list *const f244D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f244D->then_instructions;

                           ir_variable *const r244E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r244E);
                           ir_expression *const r244F = lshift(r23BE, body.constant(int(31)));
                           body.emit(assign(r244E, add(r244F, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r244E, body.constant(0u), 0x01));

                           body.emit(assign(r2440, r244E, 0x03));

                           body.emit(assign(r243F, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f244D->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2451 = less(r23CA, body.constant(int(0)));
                           ir_if *f2450 = new(mem_ctx) ir_if(operand(r2451).val);
                           exec_list *const f2450_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2450->then_instructions;

                              ir_variable *const r2452 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r2452, r2436, 0x01));

                              ir_variable *const r2453 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r2453, neg(r23CA), 0x01));

                              ir_variable *const r2454 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r2454);
                              ir_variable *const r2455 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r2455);
                              ir_variable *const r2456 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r2456);
                              ir_variable *const r2457 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r2458 = neg(r2453);
                              body.emit(assign(r2457, bit_and(r2458, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r245A = equal(r2453, body.constant(int(0)));
                              ir_if *f2459 = new(mem_ctx) ir_if(operand(r245A).val);
                              exec_list *const f2459_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2459->then_instructions;

                                 body.emit(assign(r2454, r2436, 0x01));

                                 body.emit(assign(r2455, r2437, 0x01));

                                 body.emit(assign(r2456, r2438, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2459->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r245C = less(r2453, body.constant(int(32)));
                                 ir_if *f245B = new(mem_ctx) ir_if(operand(r245C).val);
                                 exec_list *const f245B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f245B->then_instructions;

                                    body.emit(assign(r2454, lshift(r2437, r2457), 0x01));

                                    ir_expression *const r245D = lshift(r2438, r2457);
                                    ir_expression *const r245E = rshift(r2437, r2453);
                                    body.emit(assign(r2455, bit_or(r245D, r245E), 0x01));

                                    body.emit(assign(r2456, rshift(r2438, r2453), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f245B->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2460 = equal(r2453, body.constant(int(32)));
                                    ir_if *f245F = new(mem_ctx) ir_if(operand(r2460).val);
                                    exec_list *const f245F_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f245F->then_instructions;

                                       body.emit(assign(r2454, r2437, 0x01));

                                       body.emit(assign(r2455, r2438, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f245F->else_instructions;

                                       body.emit(assign(r2452, bit_or(r2436, r2437), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2462 = less(r2453, body.constant(int(64)));
                                       ir_if *f2461 = new(mem_ctx) ir_if(operand(r2462).val);
                                       exec_list *const f2461_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2461->then_instructions;

                                          body.emit(assign(r2454, lshift(r2438, r2457), 0x01));

                                          ir_expression *const r2463 = bit_and(r2453, body.constant(int(31)));
                                          body.emit(assign(r2455, rshift(r2438, r2463), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2461->else_instructions;

                                          ir_variable *const r2464 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r2466 = equal(r2453, body.constant(int(64)));
                                          ir_if *f2465 = new(mem_ctx) ir_if(operand(r2466).val);
                                          exec_list *const f2465_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2465->then_instructions;

                                             body.emit(assign(r2464, r2438, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2465->else_instructions;

                                             ir_expression *const r2467 = nequal(r2438, body.constant(0u));
                                             ir_expression *const r2468 = expr(ir_unop_b2i, r2467);
                                             body.emit(assign(r2464, expr(ir_unop_i2u, r2468), 0x01));


                                          body.instructions = f2465_parent_instructions;
                                          body.emit(f2465);

                                          /* END IF */

                                          body.emit(assign(r2454, r2464, 0x01));

                                          body.emit(assign(r2455, body.constant(0u), 0x01));


                                       body.instructions = f2461_parent_instructions;
                                       body.emit(f2461);

                                       /* END IF */


                                    body.instructions = f245F_parent_instructions;
                                    body.emit(f245F);

                                    /* END IF */

                                    body.emit(assign(r2456, body.constant(0u), 0x01));


                                 body.instructions = f245B_parent_instructions;
                                 body.emit(f245B);

                                 /* END IF */

                                 ir_expression *const r2469 = nequal(r2452, body.constant(0u));
                                 ir_expression *const r246A = expr(ir_unop_b2i, r2469);
                                 ir_expression *const r246B = expr(ir_unop_i2u, r246A);
                                 body.emit(assign(r2454, bit_or(r2454, r246B), 0x01));


                              body.instructions = f2459_parent_instructions;
                              body.emit(f2459);

                              /* END IF */

                              body.emit(assign(r243C, r2456, 0x01));

                              body.emit(assign(r243D, r2455, 0x01));

                              body.emit(assign(r243E, r2454, 0x01));

                              body.emit(assign(r243B, body.constant(int(0)), 0x01));

                              body.emit(assign(r2441, less(r2454, body.constant(0u)), 0x01));


                           body.instructions = f2450_parent_instructions;
                           body.emit(f2450);

                           /* END IF */


                        body.instructions = f244D_parent_instructions;
                        body.emit(f244D);

                        /* END IF */


                     body.instructions = f2443_parent_instructions;
                     body.emit(f2443);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f246C = new(mem_ctx) ir_if(operand(r243F).val);
                     exec_list *const f246C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f246C->then_instructions;

                        /* IF CONDITION */
                        ir_if *f246D = new(mem_ctx) ir_if(operand(r2441).val);
                        exec_list *const f246D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f246D->then_instructions;

                           ir_variable *const r246E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r246E, add(r243D, body.constant(1u)), 0x01));

                           ir_expression *const r246F = less(r246E, r243D);
                           ir_expression *const r2470 = expr(ir_unop_b2i, r246F);
                           ir_expression *const r2471 = expr(ir_unop_i2u, r2470);
                           body.emit(assign(r243C, add(r243C, r2471), 0x01));

                           ir_expression *const r2472 = equal(r243E, body.constant(0u));
                           ir_expression *const r2473 = expr(ir_unop_b2i, r2472);
                           ir_expression *const r2474 = expr(ir_unop_i2u, r2473);
                           ir_expression *const r2475 = add(r243E, r2474);
                           ir_expression *const r2476 = bit_and(r2475, body.constant(1u));
                           ir_expression *const r2477 = expr(ir_unop_bit_not, r2476);
                           body.emit(assign(r243D, bit_and(r246E, r2477), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f246D->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2479 = bit_or(r243C, r243D);
                           ir_expression *const r247A = equal(r2479, body.constant(0u));
                           ir_if *f2478 = new(mem_ctx) ir_if(operand(r247A).val);
                           exec_list *const f2478_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2478->then_instructions;

                              body.emit(assign(r243B, body.constant(int(0)), 0x01));


                           body.instructions = f2478_parent_instructions;
                           body.emit(f2478);

                           /* END IF */


                        body.instructions = f246D_parent_instructions;
                        body.emit(f246D);

                        /* END IF */

                        ir_variable *const r247B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r247B);
                        ir_expression *const r247C = lshift(r23BE, body.constant(int(31)));
                        ir_expression *const r247D = expr(ir_unop_i2u, r243B);
                        ir_expression *const r247E = lshift(r247D, body.constant(int(20)));
                        ir_expression *const r247F = add(r247C, r247E);
                        body.emit(assign(r247B, add(r247F, r243C), 0x02));

                        body.emit(assign(r247B, r243D, 0x01));

                        body.emit(assign(r2440, r247B, 0x03));

                        body.emit(assign(r243F, body.constant(false), 0x01));


                     body.instructions = f246C_parent_instructions;
                     body.emit(f246C);

                     /* END IF */

                     body.emit(assign(r23C2, r2440, 0x03));

                     body.emit(assign(r23C1, body.constant(false), 0x01));


                  body.instructions = f2432_parent_instructions;
                  body.emit(f2432);

                  /* END IF */


               body.instructions = f241A_parent_instructions;
               body.emit(f241A);

               /* END IF */


            body.instructions = f23FA_parent_instructions;
            body.emit(f23FA);

            /* END IF */


         body.instructions = f23D0_parent_instructions;
         body.emit(f23D0);

         /* END IF */

         /* IF CONDITION */
         ir_if *f2480 = new(mem_ctx) ir_if(operand(r23C1).val);
         exec_list *const f2480_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2480->then_instructions;

            body.emit(assign(r23C5, bit_or(swizzle_y(r23C5), body.constant(1048576u)), 0x02));

            ir_variable *const r2481 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r2482 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r2482, add(swizzle_x(r23C5), swizzle_x(r23C4)), 0x01));

            ir_expression *const r2483 = add(swizzle_y(r23C5), swizzle_y(r23C4));
            ir_expression *const r2484 = less(r2482, swizzle_x(r23C5));
            ir_expression *const r2485 = expr(ir_unop_b2i, r2484);
            ir_expression *const r2486 = expr(ir_unop_i2u, r2485);
            body.emit(assign(r2481, add(r2483, r2486), 0x01));

            body.emit(assign(r23C8, r2481, 0x01));

            body.emit(assign(r23C6, add(r23C6, body.constant(int(-1))), 0x01));

            /* IF CONDITION */
            ir_expression *const r2488 = less(r2481, body.constant(2097152u));
            ir_if *f2487 = new(mem_ctx) ir_if(operand(r2488).val);
            exec_list *const f2487_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2487->then_instructions;

               ir_variable *const r2489 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2489, r23C6, 0x01));

               ir_variable *const r248A = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r248A, r2481, 0x01));

               ir_variable *const r248B = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r248B, r2482, 0x01));

               ir_variable *const r248C = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r248C, r23C7, 0x01));

               ir_variable *const r248D = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r248D, body.constant(true), 0x01));

               ir_variable *const r248E = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r248F = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r248F);
               ir_expression *const r2490 = expr(ir_unop_u2i, r23C7);
               body.emit(assign(r248F, less(r2490, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2492 = lequal(body.constant(int(2045)), r23C6);
               ir_if *f2491 = new(mem_ctx) ir_if(operand(r2492).val);
               exec_list *const f2491_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2491->then_instructions;

                  ir_variable *const r2493 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2495 = less(body.constant(int(2045)), r23C6);
                  ir_if *f2494 = new(mem_ctx) ir_if(operand(r2495).val);
                  exec_list *const f2494_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2494->then_instructions;

                     body.emit(assign(r2493, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2494->else_instructions;

                     ir_variable *const r2496 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2498 = equal(r23C6, body.constant(int(2045)));
                     ir_if *f2497 = new(mem_ctx) ir_if(operand(r2498).val);
                     exec_list *const f2497_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2497->then_instructions;

                        ir_expression *const r2499 = equal(body.constant(2097151u), r2481);
                        ir_expression *const r249A = equal(body.constant(4294967295u), r2482);
                        body.emit(assign(r2496, logic_and(r2499, r249A), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2497->else_instructions;

                        body.emit(assign(r2496, body.constant(false), 0x01));


                     body.instructions = f2497_parent_instructions;
                     body.emit(f2497);

                     /* END IF */

                     body.emit(assign(r2493, logic_and(r2496, r248F), 0x01));


                  body.instructions = f2494_parent_instructions;
                  body.emit(f2494);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f249B = new(mem_ctx) ir_if(operand(r2493).val);
                  exec_list *const f249B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f249B->then_instructions;

                     ir_variable *const r249C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r249C);
                     ir_expression *const r249D = lshift(r23BE, body.constant(int(31)));
                     body.emit(assign(r249C, add(r249D, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r249C, body.constant(0u), 0x01));

                     body.emit(assign(r248E, r249C, 0x03));

                     body.emit(assign(r248D, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f249B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r249F = less(r23C6, body.constant(int(0)));
                     ir_if *f249E = new(mem_ctx) ir_if(operand(r249F).val);
                     exec_list *const f249E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f249E->then_instructions;

                        ir_variable *const r24A0 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r24A0, r23C7, 0x01));

                        ir_variable *const r24A1 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r24A1, neg(r23C6), 0x01));

                        ir_variable *const r24A2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r24A2);
                        ir_variable *const r24A3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r24A3);
                        ir_variable *const r24A4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r24A4);
                        ir_variable *const r24A5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r24A6 = neg(r24A1);
                        body.emit(assign(r24A5, bit_and(r24A6, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r24A8 = equal(r24A1, body.constant(int(0)));
                        ir_if *f24A7 = new(mem_ctx) ir_if(operand(r24A8).val);
                        exec_list *const f24A7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f24A7->then_instructions;

                           body.emit(assign(r24A2, r23C7, 0x01));

                           body.emit(assign(r24A3, r2482, 0x01));

                           body.emit(assign(r24A4, r2481, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f24A7->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r24AA = less(r24A1, body.constant(int(32)));
                           ir_if *f24A9 = new(mem_ctx) ir_if(operand(r24AA).val);
                           exec_list *const f24A9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f24A9->then_instructions;

                              body.emit(assign(r24A2, lshift(r2482, r24A5), 0x01));

                              ir_expression *const r24AB = lshift(r2481, r24A5);
                              ir_expression *const r24AC = rshift(r2482, r24A1);
                              body.emit(assign(r24A3, bit_or(r24AB, r24AC), 0x01));

                              body.emit(assign(r24A4, rshift(r2481, r24A1), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f24A9->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r24AE = equal(r24A1, body.constant(int(32)));
                              ir_if *f24AD = new(mem_ctx) ir_if(operand(r24AE).val);
                              exec_list *const f24AD_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f24AD->then_instructions;

                                 body.emit(assign(r24A2, r2482, 0x01));

                                 body.emit(assign(r24A3, r2481, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f24AD->else_instructions;

                                 body.emit(assign(r24A0, bit_or(r23C7, r2482), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r24B0 = less(r24A1, body.constant(int(64)));
                                 ir_if *f24AF = new(mem_ctx) ir_if(operand(r24B0).val);
                                 exec_list *const f24AF_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f24AF->then_instructions;

                                    body.emit(assign(r24A2, lshift(r2481, r24A5), 0x01));

                                    ir_expression *const r24B1 = bit_and(r24A1, body.constant(int(31)));
                                    body.emit(assign(r24A3, rshift(r2481, r24B1), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f24AF->else_instructions;

                                    ir_variable *const r24B2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r24B4 = equal(r24A1, body.constant(int(64)));
                                    ir_if *f24B3 = new(mem_ctx) ir_if(operand(r24B4).val);
                                    exec_list *const f24B3_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f24B3->then_instructions;

                                       body.emit(assign(r24B2, r2481, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f24B3->else_instructions;

                                       ir_expression *const r24B5 = nequal(r2481, body.constant(0u));
                                       ir_expression *const r24B6 = expr(ir_unop_b2i, r24B5);
                                       body.emit(assign(r24B2, expr(ir_unop_i2u, r24B6), 0x01));


                                    body.instructions = f24B3_parent_instructions;
                                    body.emit(f24B3);

                                    /* END IF */

                                    body.emit(assign(r24A2, r24B2, 0x01));

                                    body.emit(assign(r24A3, body.constant(0u), 0x01));


                                 body.instructions = f24AF_parent_instructions;
                                 body.emit(f24AF);

                                 /* END IF */


                              body.instructions = f24AD_parent_instructions;
                              body.emit(f24AD);

                              /* END IF */

                              body.emit(assign(r24A4, body.constant(0u), 0x01));


                           body.instructions = f24A9_parent_instructions;
                           body.emit(f24A9);

                           /* END IF */

                           ir_expression *const r24B7 = nequal(r24A0, body.constant(0u));
                           ir_expression *const r24B8 = expr(ir_unop_b2i, r24B7);
                           ir_expression *const r24B9 = expr(ir_unop_i2u, r24B8);
                           body.emit(assign(r24A2, bit_or(r24A2, r24B9), 0x01));


                        body.instructions = f24A7_parent_instructions;
                        body.emit(f24A7);

                        /* END IF */

                        body.emit(assign(r248A, r24A4, 0x01));

                        body.emit(assign(r248B, r24A3, 0x01));

                        body.emit(assign(r248C, r24A2, 0x01));

                        body.emit(assign(r2489, body.constant(int(0)), 0x01));

                        body.emit(assign(r248F, less(r24A2, body.constant(0u)), 0x01));


                     body.instructions = f249E_parent_instructions;
                     body.emit(f249E);

                     /* END IF */


                  body.instructions = f249B_parent_instructions;
                  body.emit(f249B);

                  /* END IF */


               body.instructions = f2491_parent_instructions;
               body.emit(f2491);

               /* END IF */

               /* IF CONDITION */
               ir_if *f24BA = new(mem_ctx) ir_if(operand(r248D).val);
               exec_list *const f24BA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f24BA->then_instructions;

                  /* IF CONDITION */
                  ir_if *f24BB = new(mem_ctx) ir_if(operand(r248F).val);
                  exec_list *const f24BB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f24BB->then_instructions;

                     ir_variable *const r24BC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r24BC, add(r248B, body.constant(1u)), 0x01));

                     ir_expression *const r24BD = less(r24BC, r248B);
                     ir_expression *const r24BE = expr(ir_unop_b2i, r24BD);
                     ir_expression *const r24BF = expr(ir_unop_i2u, r24BE);
                     body.emit(assign(r248A, add(r248A, r24BF), 0x01));

                     ir_expression *const r24C0 = equal(r248C, body.constant(0u));
                     ir_expression *const r24C1 = expr(ir_unop_b2i, r24C0);
                     ir_expression *const r24C2 = expr(ir_unop_i2u, r24C1);
                     ir_expression *const r24C3 = add(r248C, r24C2);
                     ir_expression *const r24C4 = bit_and(r24C3, body.constant(1u));
                     ir_expression *const r24C5 = expr(ir_unop_bit_not, r24C4);
                     body.emit(assign(r248B, bit_and(r24BC, r24C5), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f24BB->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r24C7 = bit_or(r248A, r248B);
                     ir_expression *const r24C8 = equal(r24C7, body.constant(0u));
                     ir_if *f24C6 = new(mem_ctx) ir_if(operand(r24C8).val);
                     exec_list *const f24C6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f24C6->then_instructions;

                        body.emit(assign(r2489, body.constant(int(0)), 0x01));


                     body.instructions = f24C6_parent_instructions;
                     body.emit(f24C6);

                     /* END IF */


                  body.instructions = f24BB_parent_instructions;
                  body.emit(f24BB);

                  /* END IF */

                  ir_variable *const r24C9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r24C9);
                  ir_expression *const r24CA = lshift(r23BE, body.constant(int(31)));
                  ir_expression *const r24CB = expr(ir_unop_i2u, r2489);
                  ir_expression *const r24CC = lshift(r24CB, body.constant(int(20)));
                  ir_expression *const r24CD = add(r24CA, r24CC);
                  body.emit(assign(r24C9, add(r24CD, r248A), 0x02));

                  body.emit(assign(r24C9, r248B, 0x01));

                  body.emit(assign(r248E, r24C9, 0x03));

                  body.emit(assign(r248D, body.constant(false), 0x01));


               body.instructions = f24BA_parent_instructions;
               body.emit(f24BA);

               /* END IF */

               body.emit(assign(r23C2, r248E, 0x03));

               body.emit(assign(r23C1, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2487->else_instructions;

               body.emit(assign(r23C6, add(r23C6, body.constant(int(1))), 0x01));

               ir_variable *const r24CE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r24CE);
               ir_variable *const r24CF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r24CF);
               ir_variable *const r24D0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r24D0);
               body.emit(assign(r24CE, lshift(r2482, body.constant(int(31))), 0x01));

               ir_expression *const r24D1 = lshift(r2481, body.constant(int(31)));
               ir_expression *const r24D2 = rshift(r2482, body.constant(int(1)));
               body.emit(assign(r24CF, bit_or(r24D1, r24D2), 0x01));

               body.emit(assign(r24D0, rshift(r2481, body.constant(int(1))), 0x01));

               ir_expression *const r24D3 = nequal(r23C7, body.constant(0u));
               ir_expression *const r24D4 = expr(ir_unop_b2i, r24D3);
               ir_expression *const r24D5 = expr(ir_unop_i2u, r24D4);
               body.emit(assign(r24CE, bit_or(r24CE, r24D5), 0x01));

               body.emit(assign(r23C8, r24D0, 0x01));

               body.emit(assign(r23C7, r24CE, 0x01));

               ir_variable *const r24D6 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r24D6, r23C6, 0x01));

               ir_variable *const r24D7 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r24D7, r24D0, 0x01));

               ir_variable *const r24D8 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r24D8, r24CF, 0x01));

               ir_variable *const r24D9 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r24D9, r24CE, 0x01));

               ir_variable *const r24DA = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r24DA, body.constant(true), 0x01));

               ir_variable *const r24DB = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r24DC = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r24DC);
               ir_expression *const r24DD = expr(ir_unop_u2i, r24CE);
               body.emit(assign(r24DC, less(r24DD, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r24DF = lequal(body.constant(int(2045)), r23C6);
               ir_if *f24DE = new(mem_ctx) ir_if(operand(r24DF).val);
               exec_list *const f24DE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f24DE->then_instructions;

                  ir_variable *const r24E0 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r24E2 = less(body.constant(int(2045)), r23C6);
                  ir_if *f24E1 = new(mem_ctx) ir_if(operand(r24E2).val);
                  exec_list *const f24E1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f24E1->then_instructions;

                     body.emit(assign(r24E0, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f24E1->else_instructions;

                     ir_variable *const r24E3 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r24E5 = equal(r23C6, body.constant(int(2045)));
                     ir_if *f24E4 = new(mem_ctx) ir_if(operand(r24E5).val);
                     exec_list *const f24E4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f24E4->then_instructions;

                        ir_expression *const r24E6 = equal(body.constant(2097151u), r24D0);
                        ir_expression *const r24E7 = equal(body.constant(4294967295u), r24CF);
                        body.emit(assign(r24E3, logic_and(r24E6, r24E7), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f24E4->else_instructions;

                        body.emit(assign(r24E3, body.constant(false), 0x01));


                     body.instructions = f24E4_parent_instructions;
                     body.emit(f24E4);

                     /* END IF */

                     body.emit(assign(r24E0, logic_and(r24E3, r24DC), 0x01));


                  body.instructions = f24E1_parent_instructions;
                  body.emit(f24E1);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f24E8 = new(mem_ctx) ir_if(operand(r24E0).val);
                  exec_list *const f24E8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f24E8->then_instructions;

                     ir_variable *const r24E9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r24E9);
                     ir_expression *const r24EA = lshift(r23BE, body.constant(int(31)));
                     body.emit(assign(r24E9, add(r24EA, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r24E9, body.constant(0u), 0x01));

                     body.emit(assign(r24DB, r24E9, 0x03));

                     body.emit(assign(r24DA, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f24E8->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r24EC = less(r23C6, body.constant(int(0)));
                     ir_if *f24EB = new(mem_ctx) ir_if(operand(r24EC).val);
                     exec_list *const f24EB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f24EB->then_instructions;

                        ir_variable *const r24ED = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r24ED, r24CE, 0x01));

                        ir_variable *const r24EE = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r24EE, neg(r23C6), 0x01));

                        ir_variable *const r24EF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r24EF);
                        ir_variable *const r24F0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r24F0);
                        ir_variable *const r24F1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r24F1);
                        ir_variable *const r24F2 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r24F3 = neg(r24EE);
                        body.emit(assign(r24F2, bit_and(r24F3, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r24F5 = equal(r24EE, body.constant(int(0)));
                        ir_if *f24F4 = new(mem_ctx) ir_if(operand(r24F5).val);
                        exec_list *const f24F4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f24F4->then_instructions;

                           body.emit(assign(r24EF, r24CE, 0x01));

                           body.emit(assign(r24F0, r24CF, 0x01));

                           body.emit(assign(r24F1, r24D0, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f24F4->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r24F7 = less(r24EE, body.constant(int(32)));
                           ir_if *f24F6 = new(mem_ctx) ir_if(operand(r24F7).val);
                           exec_list *const f24F6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f24F6->then_instructions;

                              body.emit(assign(r24EF, lshift(r24CF, r24F2), 0x01));

                              ir_expression *const r24F8 = lshift(r24D0, r24F2);
                              ir_expression *const r24F9 = rshift(r24CF, r24EE);
                              body.emit(assign(r24F0, bit_or(r24F8, r24F9), 0x01));

                              body.emit(assign(r24F1, rshift(r24D0, r24EE), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f24F6->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r24FB = equal(r24EE, body.constant(int(32)));
                              ir_if *f24FA = new(mem_ctx) ir_if(operand(r24FB).val);
                              exec_list *const f24FA_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f24FA->then_instructions;

                                 body.emit(assign(r24EF, r24CF, 0x01));

                                 body.emit(assign(r24F0, r24D0, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f24FA->else_instructions;

                                 body.emit(assign(r24ED, bit_or(r24CE, r24CF), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r24FD = less(r24EE, body.constant(int(64)));
                                 ir_if *f24FC = new(mem_ctx) ir_if(operand(r24FD).val);
                                 exec_list *const f24FC_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f24FC->then_instructions;

                                    body.emit(assign(r24EF, lshift(r24D0, r24F2), 0x01));

                                    ir_expression *const r24FE = bit_and(r24EE, body.constant(int(31)));
                                    body.emit(assign(r24F0, rshift(r24D0, r24FE), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f24FC->else_instructions;

                                    ir_variable *const r24FF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2501 = equal(r24EE, body.constant(int(64)));
                                    ir_if *f2500 = new(mem_ctx) ir_if(operand(r2501).val);
                                    exec_list *const f2500_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2500->then_instructions;

                                       body.emit(assign(r24FF, r24D0, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2500->else_instructions;

                                       ir_expression *const r2502 = nequal(r24D0, body.constant(0u));
                                       ir_expression *const r2503 = expr(ir_unop_b2i, r2502);
                                       body.emit(assign(r24FF, expr(ir_unop_i2u, r2503), 0x01));


                                    body.instructions = f2500_parent_instructions;
                                    body.emit(f2500);

                                    /* END IF */

                                    body.emit(assign(r24EF, r24FF, 0x01));

                                    body.emit(assign(r24F0, body.constant(0u), 0x01));


                                 body.instructions = f24FC_parent_instructions;
                                 body.emit(f24FC);

                                 /* END IF */


                              body.instructions = f24FA_parent_instructions;
                              body.emit(f24FA);

                              /* END IF */

                              body.emit(assign(r24F1, body.constant(0u), 0x01));


                           body.instructions = f24F6_parent_instructions;
                           body.emit(f24F6);

                           /* END IF */

                           ir_expression *const r2504 = nequal(r24ED, body.constant(0u));
                           ir_expression *const r2505 = expr(ir_unop_b2i, r2504);
                           ir_expression *const r2506 = expr(ir_unop_i2u, r2505);
                           body.emit(assign(r24EF, bit_or(r24EF, r2506), 0x01));


                        body.instructions = f24F4_parent_instructions;
                        body.emit(f24F4);

                        /* END IF */

                        body.emit(assign(r24D7, r24F1, 0x01));

                        body.emit(assign(r24D8, r24F0, 0x01));

                        body.emit(assign(r24D9, r24EF, 0x01));

                        body.emit(assign(r24D6, body.constant(int(0)), 0x01));

                        body.emit(assign(r24DC, less(r24EF, body.constant(0u)), 0x01));


                     body.instructions = f24EB_parent_instructions;
                     body.emit(f24EB);

                     /* END IF */


                  body.instructions = f24E8_parent_instructions;
                  body.emit(f24E8);

                  /* END IF */


               body.instructions = f24DE_parent_instructions;
               body.emit(f24DE);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2507 = new(mem_ctx) ir_if(operand(r24DA).val);
               exec_list *const f2507_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2507->then_instructions;

                  /* IF CONDITION */
                  ir_if *f2508 = new(mem_ctx) ir_if(operand(r24DC).val);
                  exec_list *const f2508_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2508->then_instructions;

                     ir_variable *const r2509 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r2509, add(r24D8, body.constant(1u)), 0x01));

                     ir_expression *const r250A = less(r2509, r24D8);
                     ir_expression *const r250B = expr(ir_unop_b2i, r250A);
                     ir_expression *const r250C = expr(ir_unop_i2u, r250B);
                     body.emit(assign(r24D7, add(r24D7, r250C), 0x01));

                     ir_expression *const r250D = equal(r24D9, body.constant(0u));
                     ir_expression *const r250E = expr(ir_unop_b2i, r250D);
                     ir_expression *const r250F = expr(ir_unop_i2u, r250E);
                     ir_expression *const r2510 = add(r24D9, r250F);
                     ir_expression *const r2511 = bit_and(r2510, body.constant(1u));
                     ir_expression *const r2512 = expr(ir_unop_bit_not, r2511);
                     body.emit(assign(r24D8, bit_and(r2509, r2512), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2508->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2514 = bit_or(r24D7, r24D8);
                     ir_expression *const r2515 = equal(r2514, body.constant(0u));
                     ir_if *f2513 = new(mem_ctx) ir_if(operand(r2515).val);
                     exec_list *const f2513_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2513->then_instructions;

                        body.emit(assign(r24D6, body.constant(int(0)), 0x01));


                     body.instructions = f2513_parent_instructions;
                     body.emit(f2513);

                     /* END IF */


                  body.instructions = f2508_parent_instructions;
                  body.emit(f2508);

                  /* END IF */

                  ir_variable *const r2516 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2516);
                  ir_expression *const r2517 = lshift(r23BE, body.constant(int(31)));
                  ir_expression *const r2518 = expr(ir_unop_i2u, r24D6);
                  ir_expression *const r2519 = lshift(r2518, body.constant(int(20)));
                  ir_expression *const r251A = add(r2517, r2519);
                  body.emit(assign(r2516, add(r251A, r24D7), 0x02));

                  body.emit(assign(r2516, r24D8, 0x01));

                  body.emit(assign(r24DB, r2516, 0x03));

                  body.emit(assign(r24DA, body.constant(false), 0x01));


               body.instructions = f2507_parent_instructions;
               body.emit(f2507);

               /* END IF */

               body.emit(assign(r23C2, r24DB, 0x03));

               body.emit(assign(r23C1, body.constant(false), 0x01));


            body.instructions = f2487_parent_instructions;
            body.emit(f2487);

            /* END IF */


         body.instructions = f2480_parent_instructions;
         body.emit(f2480);

         /* END IF */

         body.emit(assign(r23BD, r23C2, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f23BF->else_instructions;

         ir_variable *const r251B = body.make_temp(glsl_type::uint_type, "zSign");
         body.emit(assign(r251B, r23BE, 0x01));

         ir_variable *const r251C = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r251D = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r251D);
         ir_variable *const r251E = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
         body.emit(r251E);
         ir_variable *const r251F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
         body.emit(r251F);
         ir_variable *const r2520 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
         body.emit(r2520);
         ir_variable *const r2521 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
         body.emit(r2521);
         ir_variable *const r2522 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r2522);
         ir_variable *const r2523 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
         body.emit(r2523);
         body.emit(assign(r2523, bit_and(swizzle_y(r2389), body.constant(1048575u)), 0x02));

         body.emit(assign(r2523, swizzle_x(r2389), 0x01));

         ir_variable *const r2524 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r2525 = rshift(swizzle_y(r2389), body.constant(int(20)));
         ir_expression *const r2526 = bit_and(r2525, body.constant(2047u));
         body.emit(assign(r2524, expr(ir_unop_u2i, r2526), 0x01));

         body.emit(assign(r2520, r2524, 0x01));

         ir_variable *const r2527 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
         body.emit(r2527);
         body.emit(assign(r2527, body.constant(0u), 0x02));

         body.emit(assign(r2527, body.constant(0u), 0x01));

         body.emit(assign(r251E, body.constant(int(1023)), 0x01));

         body.emit(assign(r251D, add(r2524, body.constant(int(-1023))), 0x01));

         ir_variable *const r2528 = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r2528, lshift(swizzle_x(r2389), body.constant(int(10))), 0x01));

         ir_variable *const r2529 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         ir_expression *const r252A = lshift(swizzle_y(r2523), body.constant(int(10)));
         ir_expression *const r252B = rshift(swizzle_x(r2389), body.constant(int(22)));
         body.emit(assign(r2529, bit_or(r252A, r252B), 0x01));

         body.emit(assign(r2521, r2529, 0x02));

         body.emit(assign(r2521, r2528, 0x01));

         ir_variable *const r252C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         body.emit(assign(r252C, body.constant(0u), 0x01));

         body.emit(assign(r251F, r252C, 0x02));

         body.emit(assign(r251F, body.constant(0u), 0x01));

         /* IF CONDITION */
         ir_expression *const r252E = less(body.constant(int(0)), r251D);
         ir_if *f252D = new(mem_ctx) ir_if(operand(r252E).val);
         exec_list *const f252D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f252D->then_instructions;

            /* IF CONDITION */
            ir_expression *const r2530 = equal(r2524, body.constant(int(2047)));
            ir_if *f252F = new(mem_ctx) ir_if(operand(r2530).val);
            exec_list *const f252F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f252F->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2532 = bit_or(r2529, r2528);
               ir_expression *const r2533 = nequal(r2532, body.constant(0u));
               ir_if *f2531 = new(mem_ctx) ir_if(operand(r2533).val);
               exec_list *const f2531_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2531->then_instructions;

                  ir_variable *const r2534 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r2534, swizzle_x(r2389), 0x01));

                  ir_variable *const r2535 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r2535, body.constant(0u), 0x01));

                  ir_variable *const r2536 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r2534, bit_or(swizzle_y(r2389), body.constant(524288u)), 0x02));

                  body.emit(assign(r2535, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r2538 = lshift(swizzle_y(r2389), body.constant(int(1)));
                  ir_expression *const r2539 = lequal(body.constant(4292870144u), r2538);
                  ir_expression *const r253A = nequal(swizzle_x(r2389), body.constant(0u));
                  ir_expression *const r253B = bit_and(swizzle_y(r2389), body.constant(1048575u));
                  ir_expression *const r253C = nequal(r253B, body.constant(0u));
                  ir_expression *const r253D = logic_or(r253A, r253C);
                  ir_expression *const r253E = logic_and(r2539, r253D);
                  ir_if *f2537 = new(mem_ctx) ir_if(operand(r253E).val);
                  exec_list *const f2537_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2537->then_instructions;

                     body.emit(assign(r2536, r2534, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2537->else_instructions;

                     body.emit(assign(r2536, r2535, 0x03));


                  body.instructions = f2537_parent_instructions;
                  body.emit(f2537);

                  /* END IF */

                  body.emit(assign(r251C, r2536, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2531->else_instructions;

                  body.emit(assign(r251C, r2389, 0x03));


               body.instructions = f2531_parent_instructions;
               body.emit(f2531);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f252F->else_instructions;

               body.emit(assign(r251F, body.constant(1073741824u), 0x02));

               ir_variable *const r253F = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r253F, body.constant(1073741824u), 0x01));

               ir_variable *const r2540 = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r2540, body.constant(0u), 0x01));

               ir_variable *const r2541 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2541);
               ir_variable *const r2542 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2542);
               ir_variable *const r2543 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2544 = neg(r251D);
               body.emit(assign(r2543, bit_and(r2544, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2546 = equal(r251D, body.constant(int(0)));
               ir_if *f2545 = new(mem_ctx) ir_if(operand(r2546).val);
               exec_list *const f2545_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2545->then_instructions;

                  body.emit(assign(r2541, r2540, 0x01));

                  body.emit(assign(r2542, r253F, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2545->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2548 = less(r251D, body.constant(int(32)));
                  ir_if *f2547 = new(mem_ctx) ir_if(operand(r2548).val);
                  exec_list *const f2547_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2547->then_instructions;

                     ir_expression *const r2549 = lshift(body.constant(1073741824u), r2543);
                     ir_expression *const r254A = bit_or(r2549, body.constant(0u));
                     body.emit(assign(r2541, bit_or(r254A, body.constant(0u)), 0x01));

                     body.emit(assign(r2542, rshift(body.constant(1073741824u), r251D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2547->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r254C = equal(r251D, body.constant(int(32)));
                     ir_if *f254B = new(mem_ctx) ir_if(operand(r254C).val);
                     exec_list *const f254B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f254B->then_instructions;

                        body.emit(assign(r2541, body.constant(1073741824u), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f254B->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r254E = less(r251D, body.constant(int(64)));
                        ir_if *f254D = new(mem_ctx) ir_if(operand(r254E).val);
                        exec_list *const f254D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f254D->then_instructions;

                           ir_expression *const r254F = bit_and(r251D, body.constant(int(31)));
                           ir_expression *const r2550 = rshift(body.constant(1073741824u), r254F);
                           ir_expression *const r2551 = lshift(body.constant(1073741824u), r2543);
                           ir_expression *const r2552 = bit_or(r2551, body.constant(0u));
                           ir_expression *const r2553 = nequal(r2552, body.constant(0u));
                           ir_expression *const r2554 = expr(ir_unop_b2i, r2553);
                           ir_expression *const r2555 = expr(ir_unop_i2u, r2554);
                           body.emit(assign(r2541, bit_or(r2550, r2555), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f254D->else_instructions;

                           body.emit(assign(r2541, body.constant(1u), 0x01));


                        body.instructions = f254D_parent_instructions;
                        body.emit(f254D);

                        /* END IF */


                     body.instructions = f254B_parent_instructions;
                     body.emit(f254B);

                     /* END IF */

                     body.emit(assign(r2542, body.constant(0u), 0x01));


                  body.instructions = f2547_parent_instructions;
                  body.emit(f2547);

                  /* END IF */


               body.instructions = f2545_parent_instructions;
               body.emit(f2545);

               /* END IF */

               body.emit(assign(r251F, r2542, 0x02));

               body.emit(assign(r251F, r2541, 0x01));

               body.emit(assign(r2521, bit_or(r2529, body.constant(1073741824u)), 0x02));

               ir_variable *const r2556 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r2557 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r2557, sub(r2528, r2541), 0x01));

               ir_expression *const r2558 = sub(swizzle_y(r2521), r2542);
               ir_expression *const r2559 = less(r2528, r2541);
               ir_expression *const r255A = expr(ir_unop_b2i, r2559);
               ir_expression *const r255B = expr(ir_unop_i2u, r255A);
               body.emit(assign(r2556, sub(r2558, r255B), 0x01));

               body.emit(assign(r2522, add(r2524, body.constant(int(-1))), 0x01));

               ir_variable *const r255C = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r255C, add(r2522, body.constant(int(-10))), 0x01));

               ir_variable *const r255D = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r255D, r2556, 0x01));

               ir_variable *const r255E = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r255E, r2557, 0x01));

               ir_variable *const r255F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r255F);
               ir_variable *const r2560 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r2560);
               /* IF CONDITION */
               ir_expression *const r2562 = equal(r2556, body.constant(0u));
               ir_if *f2561 = new(mem_ctx) ir_if(operand(r2562).val);
               exec_list *const f2561_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2561->then_instructions;

                  body.emit(assign(r255D, r2557, 0x01));

                  body.emit(assign(r255E, body.constant(0u), 0x01));

                  body.emit(assign(r255C, add(r255C, body.constant(int(-32))), 0x01));


               body.instructions = f2561_parent_instructions;
               body.emit(f2561);

               /* END IF */

               ir_variable *const r2563 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r2563, r255D, 0x01));

               ir_variable *const r2564 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r2565 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r2565);
               /* IF CONDITION */
               ir_expression *const r2567 = equal(r255D, body.constant(0u));
               ir_if *f2566 = new(mem_ctx) ir_if(operand(r2567).val);
               exec_list *const f2566_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2566->then_instructions;

                  body.emit(assign(r2564, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2566->else_instructions;

                  body.emit(assign(r2565, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2569 = bit_and(r255D, body.constant(4294901760u));
                  ir_expression *const r256A = equal(r2569, body.constant(0u));
                  ir_if *f2568 = new(mem_ctx) ir_if(operand(r256A).val);
                  exec_list *const f2568_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2568->then_instructions;

                     body.emit(assign(r2565, body.constant(int(16)), 0x01));

                     body.emit(assign(r2563, lshift(r255D, body.constant(int(16))), 0x01));


                  body.instructions = f2568_parent_instructions;
                  body.emit(f2568);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r256C = bit_and(r2563, body.constant(4278190080u));
                  ir_expression *const r256D = equal(r256C, body.constant(0u));
                  ir_if *f256B = new(mem_ctx) ir_if(operand(r256D).val);
                  exec_list *const f256B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f256B->then_instructions;

                     body.emit(assign(r2565, add(r2565, body.constant(int(8))), 0x01));

                     body.emit(assign(r2563, lshift(r2563, body.constant(int(8))), 0x01));


                  body.instructions = f256B_parent_instructions;
                  body.emit(f256B);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r256F = bit_and(r2563, body.constant(4026531840u));
                  ir_expression *const r2570 = equal(r256F, body.constant(0u));
                  ir_if *f256E = new(mem_ctx) ir_if(operand(r2570).val);
                  exec_list *const f256E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f256E->then_instructions;

                     body.emit(assign(r2565, add(r2565, body.constant(int(4))), 0x01));

                     body.emit(assign(r2563, lshift(r2563, body.constant(int(4))), 0x01));


                  body.instructions = f256E_parent_instructions;
                  body.emit(f256E);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2572 = bit_and(r2563, body.constant(3221225472u));
                  ir_expression *const r2573 = equal(r2572, body.constant(0u));
                  ir_if *f2571 = new(mem_ctx) ir_if(operand(r2573).val);
                  exec_list *const f2571_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2571->then_instructions;

                     body.emit(assign(r2565, add(r2565, body.constant(int(2))), 0x01));

                     body.emit(assign(r2563, lshift(r2563, body.constant(int(2))), 0x01));


                  body.instructions = f2571_parent_instructions;
                  body.emit(f2571);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2575 = bit_and(r2563, body.constant(2147483648u));
                  ir_expression *const r2576 = equal(r2575, body.constant(0u));
                  ir_if *f2574 = new(mem_ctx) ir_if(operand(r2576).val);
                  exec_list *const f2574_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2574->then_instructions;

                     body.emit(assign(r2565, add(r2565, body.constant(int(1))), 0x01));


                  body.instructions = f2574_parent_instructions;
                  body.emit(f2574);

                  /* END IF */

                  body.emit(assign(r2564, r2565, 0x01));


               body.instructions = f2566_parent_instructions;
               body.emit(f2566);

               /* END IF */

               body.emit(assign(r2560, add(r2564, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2578 = lequal(body.constant(int(0)), r2560);
               ir_if *f2577 = new(mem_ctx) ir_if(operand(r2578).val);
               exec_list *const f2577_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2577->then_instructions;

                  body.emit(assign(r255F, body.constant(0u), 0x01));

                  ir_variable *const r2579 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r2579, lshift(r255E, r2560), 0x01));

                  ir_variable *const r257A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r257C = equal(r2560, body.constant(int(0)));
                  ir_if *f257B = new(mem_ctx) ir_if(operand(r257C).val);
                  exec_list *const f257B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f257B->then_instructions;

                     body.emit(assign(r257A, r255D, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f257B->else_instructions;

                     ir_expression *const r257D = lshift(r255D, r2560);
                     ir_expression *const r257E = neg(r2560);
                     ir_expression *const r257F = bit_and(r257E, body.constant(int(31)));
                     ir_expression *const r2580 = rshift(r255E, r257F);
                     body.emit(assign(r257A, bit_or(r257D, r2580), 0x01));


                  body.instructions = f257B_parent_instructions;
                  body.emit(f257B);

                  /* END IF */

                  body.emit(assign(r255D, r257A, 0x01));

                  body.emit(assign(r255E, r2579, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2577->else_instructions;

                  ir_variable *const r2581 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r2581, body.constant(0u), 0x01));

                  ir_variable *const r2582 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r2582, neg(r2560), 0x01));

                  ir_variable *const r2583 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r2583);
                  ir_variable *const r2584 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r2584);
                  ir_variable *const r2585 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r2585);
                  ir_variable *const r2586 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r2587 = neg(r2582);
                  body.emit(assign(r2586, bit_and(r2587, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2589 = equal(r2582, body.constant(int(0)));
                  ir_if *f2588 = new(mem_ctx) ir_if(operand(r2589).val);
                  exec_list *const f2588_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2588->then_instructions;

                     body.emit(assign(r2583, r2581, 0x01));

                     body.emit(assign(r2584, r255E, 0x01));

                     body.emit(assign(r2585, r255D, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2588->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r258B = less(r2582, body.constant(int(32)));
                     ir_if *f258A = new(mem_ctx) ir_if(operand(r258B).val);
                     exec_list *const f258A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f258A->then_instructions;

                        body.emit(assign(r2583, lshift(r255E, r2586), 0x01));

                        ir_expression *const r258C = lshift(r255D, r2586);
                        ir_expression *const r258D = rshift(r255E, r2582);
                        body.emit(assign(r2584, bit_or(r258C, r258D), 0x01));

                        body.emit(assign(r2585, rshift(r255D, r2582), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f258A->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r258F = equal(r2582, body.constant(int(32)));
                        ir_if *f258E = new(mem_ctx) ir_if(operand(r258F).val);
                        exec_list *const f258E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f258E->then_instructions;

                           body.emit(assign(r2583, r255E, 0x01));

                           body.emit(assign(r2584, r255D, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f258E->else_instructions;

                           body.emit(assign(r2581, bit_or(body.constant(0u), r255E), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2591 = less(r2582, body.constant(int(64)));
                           ir_if *f2590 = new(mem_ctx) ir_if(operand(r2591).val);
                           exec_list *const f2590_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2590->then_instructions;

                              body.emit(assign(r2583, lshift(r255D, r2586), 0x01));

                              ir_expression *const r2592 = bit_and(r2582, body.constant(int(31)));
                              body.emit(assign(r2584, rshift(r255D, r2592), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2590->else_instructions;

                              ir_variable *const r2593 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2595 = equal(r2582, body.constant(int(64)));
                              ir_if *f2594 = new(mem_ctx) ir_if(operand(r2595).val);
                              exec_list *const f2594_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2594->then_instructions;

                                 body.emit(assign(r2593, r255D, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2594->else_instructions;

                                 ir_expression *const r2596 = nequal(r255D, body.constant(0u));
                                 ir_expression *const r2597 = expr(ir_unop_b2i, r2596);
                                 body.emit(assign(r2593, expr(ir_unop_i2u, r2597), 0x01));


                              body.instructions = f2594_parent_instructions;
                              body.emit(f2594);

                              /* END IF */

                              body.emit(assign(r2583, r2593, 0x01));

                              body.emit(assign(r2584, body.constant(0u), 0x01));


                           body.instructions = f2590_parent_instructions;
                           body.emit(f2590);

                           /* END IF */


                        body.instructions = f258E_parent_instructions;
                        body.emit(f258E);

                        /* END IF */

                        body.emit(assign(r2585, body.constant(0u), 0x01));


                     body.instructions = f258A_parent_instructions;
                     body.emit(f258A);

                     /* END IF */

                     ir_expression *const r2598 = nequal(r2581, body.constant(0u));
                     ir_expression *const r2599 = expr(ir_unop_b2i, r2598);
                     ir_expression *const r259A = expr(ir_unop_i2u, r2599);
                     body.emit(assign(r2583, bit_or(r2583, r259A), 0x01));


                  body.instructions = f2588_parent_instructions;
                  body.emit(f2588);

                  /* END IF */

                  body.emit(assign(r255D, r2585, 0x01));

                  body.emit(assign(r255E, r2584, 0x01));

                  body.emit(assign(r255F, r2583, 0x01));


               body.instructions = f2577_parent_instructions;
               body.emit(f2577);

               /* END IF */

               body.emit(assign(r255C, sub(r255C, r2560), 0x01));

               ir_variable *const r259B = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r259B, r255C, 0x01));

               ir_variable *const r259C = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r259C, r255D, 0x01));

               ir_variable *const r259D = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r259D, r255E, 0x01));

               ir_variable *const r259E = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r259E, r255F, 0x01));

               ir_variable *const r259F = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r259F, body.constant(true), 0x01));

               ir_variable *const r25A0 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r25A1 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r25A1);
               ir_expression *const r25A2 = expr(ir_unop_u2i, r255F);
               body.emit(assign(r25A1, less(r25A2, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r25A4 = lequal(body.constant(int(2045)), r255C);
               ir_if *f25A3 = new(mem_ctx) ir_if(operand(r25A4).val);
               exec_list *const f25A3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f25A3->then_instructions;

                  ir_variable *const r25A5 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r25A7 = less(body.constant(int(2045)), r255C);
                  ir_if *f25A6 = new(mem_ctx) ir_if(operand(r25A7).val);
                  exec_list *const f25A6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f25A6->then_instructions;

                     body.emit(assign(r25A5, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f25A6->else_instructions;

                     ir_variable *const r25A8 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r25AA = equal(r255C, body.constant(int(2045)));
                     ir_if *f25A9 = new(mem_ctx) ir_if(operand(r25AA).val);
                     exec_list *const f25A9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f25A9->then_instructions;

                        ir_expression *const r25AB = equal(body.constant(2097151u), r255D);
                        ir_expression *const r25AC = equal(body.constant(4294967295u), r255E);
                        body.emit(assign(r25A8, logic_and(r25AB, r25AC), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f25A9->else_instructions;

                        body.emit(assign(r25A8, body.constant(false), 0x01));


                     body.instructions = f25A9_parent_instructions;
                     body.emit(f25A9);

                     /* END IF */

                     body.emit(assign(r25A5, logic_and(r25A8, r25A1), 0x01));


                  body.instructions = f25A6_parent_instructions;
                  body.emit(f25A6);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f25AD = new(mem_ctx) ir_if(operand(r25A5).val);
                  exec_list *const f25AD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f25AD->then_instructions;

                     ir_variable *const r25AE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r25AE);
                     ir_expression *const r25AF = lshift(r23BE, body.constant(int(31)));
                     body.emit(assign(r25AE, add(r25AF, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r25AE, body.constant(0u), 0x01));

                     body.emit(assign(r25A0, r25AE, 0x03));

                     body.emit(assign(r259F, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f25AD->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r25B1 = less(r255C, body.constant(int(0)));
                     ir_if *f25B0 = new(mem_ctx) ir_if(operand(r25B1).val);
                     exec_list *const f25B0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f25B0->then_instructions;

                        ir_variable *const r25B2 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r25B2, r255F, 0x01));

                        ir_variable *const r25B3 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r25B3, neg(r255C), 0x01));

                        ir_variable *const r25B4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r25B4);
                        ir_variable *const r25B5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r25B5);
                        ir_variable *const r25B6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r25B6);
                        ir_variable *const r25B7 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r25B8 = neg(r25B3);
                        body.emit(assign(r25B7, bit_and(r25B8, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r25BA = equal(r25B3, body.constant(int(0)));
                        ir_if *f25B9 = new(mem_ctx) ir_if(operand(r25BA).val);
                        exec_list *const f25B9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f25B9->then_instructions;

                           body.emit(assign(r25B4, r255F, 0x01));

                           body.emit(assign(r25B5, r255E, 0x01));

                           body.emit(assign(r25B6, r255D, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f25B9->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r25BC = less(r25B3, body.constant(int(32)));
                           ir_if *f25BB = new(mem_ctx) ir_if(operand(r25BC).val);
                           exec_list *const f25BB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f25BB->then_instructions;

                              body.emit(assign(r25B4, lshift(r255E, r25B7), 0x01));

                              ir_expression *const r25BD = lshift(r255D, r25B7);
                              ir_expression *const r25BE = rshift(r255E, r25B3);
                              body.emit(assign(r25B5, bit_or(r25BD, r25BE), 0x01));

                              body.emit(assign(r25B6, rshift(r255D, r25B3), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f25BB->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r25C0 = equal(r25B3, body.constant(int(32)));
                              ir_if *f25BF = new(mem_ctx) ir_if(operand(r25C0).val);
                              exec_list *const f25BF_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f25BF->then_instructions;

                                 body.emit(assign(r25B4, r255E, 0x01));

                                 body.emit(assign(r25B5, r255D, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f25BF->else_instructions;

                                 body.emit(assign(r25B2, bit_or(r255F, r255E), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r25C2 = less(r25B3, body.constant(int(64)));
                                 ir_if *f25C1 = new(mem_ctx) ir_if(operand(r25C2).val);
                                 exec_list *const f25C1_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f25C1->then_instructions;

                                    body.emit(assign(r25B4, lshift(r255D, r25B7), 0x01));

                                    ir_expression *const r25C3 = bit_and(r25B3, body.constant(int(31)));
                                    body.emit(assign(r25B5, rshift(r255D, r25C3), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f25C1->else_instructions;

                                    ir_variable *const r25C4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r25C6 = equal(r25B3, body.constant(int(64)));
                                    ir_if *f25C5 = new(mem_ctx) ir_if(operand(r25C6).val);
                                    exec_list *const f25C5_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f25C5->then_instructions;

                                       body.emit(assign(r25C4, r255D, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f25C5->else_instructions;

                                       ir_expression *const r25C7 = nequal(r255D, body.constant(0u));
                                       ir_expression *const r25C8 = expr(ir_unop_b2i, r25C7);
                                       body.emit(assign(r25C4, expr(ir_unop_i2u, r25C8), 0x01));


                                    body.instructions = f25C5_parent_instructions;
                                    body.emit(f25C5);

                                    /* END IF */

                                    body.emit(assign(r25B4, r25C4, 0x01));

                                    body.emit(assign(r25B5, body.constant(0u), 0x01));


                                 body.instructions = f25C1_parent_instructions;
                                 body.emit(f25C1);

                                 /* END IF */


                              body.instructions = f25BF_parent_instructions;
                              body.emit(f25BF);

                              /* END IF */

                              body.emit(assign(r25B6, body.constant(0u), 0x01));


                           body.instructions = f25BB_parent_instructions;
                           body.emit(f25BB);

                           /* END IF */

                           ir_expression *const r25C9 = nequal(r25B2, body.constant(0u));
                           ir_expression *const r25CA = expr(ir_unop_b2i, r25C9);
                           ir_expression *const r25CB = expr(ir_unop_i2u, r25CA);
                           body.emit(assign(r25B4, bit_or(r25B4, r25CB), 0x01));


                        body.instructions = f25B9_parent_instructions;
                        body.emit(f25B9);

                        /* END IF */

                        body.emit(assign(r259C, r25B6, 0x01));

                        body.emit(assign(r259D, r25B5, 0x01));

                        body.emit(assign(r259E, r25B4, 0x01));

                        body.emit(assign(r259B, body.constant(int(0)), 0x01));

                        body.emit(assign(r25A1, less(r25B4, body.constant(0u)), 0x01));


                     body.instructions = f25B0_parent_instructions;
                     body.emit(f25B0);

                     /* END IF */


                  body.instructions = f25AD_parent_instructions;
                  body.emit(f25AD);

                  /* END IF */


               body.instructions = f25A3_parent_instructions;
               body.emit(f25A3);

               /* END IF */

               /* IF CONDITION */
               ir_if *f25CC = new(mem_ctx) ir_if(operand(r259F).val);
               exec_list *const f25CC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f25CC->then_instructions;

                  /* IF CONDITION */
                  ir_if *f25CD = new(mem_ctx) ir_if(operand(r25A1).val);
                  exec_list *const f25CD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f25CD->then_instructions;

                     ir_variable *const r25CE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r25CE, add(r259D, body.constant(1u)), 0x01));

                     ir_expression *const r25CF = less(r25CE, r259D);
                     ir_expression *const r25D0 = expr(ir_unop_b2i, r25CF);
                     ir_expression *const r25D1 = expr(ir_unop_i2u, r25D0);
                     body.emit(assign(r259C, add(r259C, r25D1), 0x01));

                     ir_expression *const r25D2 = equal(r259E, body.constant(0u));
                     ir_expression *const r25D3 = expr(ir_unop_b2i, r25D2);
                     ir_expression *const r25D4 = expr(ir_unop_i2u, r25D3);
                     ir_expression *const r25D5 = add(r259E, r25D4);
                     ir_expression *const r25D6 = bit_and(r25D5, body.constant(1u));
                     ir_expression *const r25D7 = expr(ir_unop_bit_not, r25D6);
                     body.emit(assign(r259D, bit_and(r25CE, r25D7), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f25CD->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r25D9 = bit_or(r259C, r259D);
                     ir_expression *const r25DA = equal(r25D9, body.constant(0u));
                     ir_if *f25D8 = new(mem_ctx) ir_if(operand(r25DA).val);
                     exec_list *const f25D8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f25D8->then_instructions;

                        body.emit(assign(r259B, body.constant(int(0)), 0x01));


                     body.instructions = f25D8_parent_instructions;
                     body.emit(f25D8);

                     /* END IF */


                  body.instructions = f25CD_parent_instructions;
                  body.emit(f25CD);

                  /* END IF */

                  ir_variable *const r25DB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r25DB);
                  ir_expression *const r25DC = lshift(r23BE, body.constant(int(31)));
                  ir_expression *const r25DD = expr(ir_unop_i2u, r259B);
                  ir_expression *const r25DE = lshift(r25DD, body.constant(int(20)));
                  ir_expression *const r25DF = add(r25DC, r25DE);
                  body.emit(assign(r25DB, add(r25DF, r259C), 0x02));

                  body.emit(assign(r25DB, r259D, 0x01));

                  body.emit(assign(r25A0, r25DB, 0x03));

                  body.emit(assign(r259F, body.constant(false), 0x01));


               body.instructions = f25CC_parent_instructions;
               body.emit(f25CC);

               /* END IF */

               body.emit(assign(r251C, r25A0, 0x03));


            body.instructions = f252F_parent_instructions;
            body.emit(f252F);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f252D->else_instructions;

            /* IF CONDITION */
            ir_expression *const r25E1 = less(r251D, body.constant(int(0)));
            ir_if *f25E0 = new(mem_ctx) ir_if(operand(r25E1).val);
            exec_list *const f25E0_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f25E0->then_instructions;

               /* IF CONDITION */
               ir_expression *const r25E3 = equal(r2524, body.constant(int(0)));
               ir_if *f25E2 = new(mem_ctx) ir_if(operand(r25E3).val);
               exec_list *const f25E2_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f25E2->then_instructions;

                  body.emit(assign(r251D, add(r251D, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f25E2->else_instructions;

                  body.emit(assign(r2521, bit_or(swizzle_y(r2521), body.constant(1073741824u)), 0x02));


               body.instructions = f25E2_parent_instructions;
               body.emit(f25E2);

               /* END IF */

               ir_variable *const r25E4 = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r25E4, swizzle_y(r2521), 0x01));

               ir_variable *const r25E5 = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r25E5, swizzle_x(r2521), 0x01));

               ir_variable *const r25E6 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r25E6, neg(r251D), 0x01));

               ir_variable *const r25E7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r25E7);
               ir_variable *const r25E8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r25E8);
               ir_variable *const r25E9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r25EA = neg(r25E6);
               body.emit(assign(r25E9, bit_and(r25EA, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r25EC = equal(r25E6, body.constant(int(0)));
               ir_if *f25EB = new(mem_ctx) ir_if(operand(r25EC).val);
               exec_list *const f25EB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f25EB->then_instructions;

                  body.emit(assign(r25E7, r25E5, 0x01));

                  body.emit(assign(r25E8, r25E4, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f25EB->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r25EE = less(r25E6, body.constant(int(32)));
                  ir_if *f25ED = new(mem_ctx) ir_if(operand(r25EE).val);
                  exec_list *const f25ED_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f25ED->then_instructions;

                     ir_expression *const r25EF = lshift(swizzle_y(r2521), r25E9);
                     ir_expression *const r25F0 = rshift(r2528, r25E6);
                     ir_expression *const r25F1 = bit_or(r25EF, r25F0);
                     ir_expression *const r25F2 = lshift(r2528, r25E9);
                     ir_expression *const r25F3 = nequal(r25F2, body.constant(0u));
                     ir_expression *const r25F4 = expr(ir_unop_b2i, r25F3);
                     ir_expression *const r25F5 = expr(ir_unop_i2u, r25F4);
                     body.emit(assign(r25E7, bit_or(r25F1, r25F5), 0x01));

                     body.emit(assign(r25E8, rshift(swizzle_y(r2521), r25E6), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f25ED->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r25F7 = equal(r25E6, body.constant(int(32)));
                     ir_if *f25F6 = new(mem_ctx) ir_if(operand(r25F7).val);
                     exec_list *const f25F6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f25F6->then_instructions;

                        ir_expression *const r25F8 = nequal(r2528, body.constant(0u));
                        ir_expression *const r25F9 = expr(ir_unop_b2i, r25F8);
                        ir_expression *const r25FA = expr(ir_unop_i2u, r25F9);
                        body.emit(assign(r25E7, bit_or(swizzle_y(r2521), r25FA), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f25F6->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r25FC = less(r25E6, body.constant(int(64)));
                        ir_if *f25FB = new(mem_ctx) ir_if(operand(r25FC).val);
                        exec_list *const f25FB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f25FB->then_instructions;

                           ir_expression *const r25FD = bit_and(r25E6, body.constant(int(31)));
                           ir_expression *const r25FE = rshift(swizzle_y(r2521), r25FD);
                           ir_expression *const r25FF = lshift(swizzle_y(r2521), r25E9);
                           ir_expression *const r2600 = bit_or(r25FF, r2528);
                           ir_expression *const r2601 = nequal(r2600, body.constant(0u));
                           ir_expression *const r2602 = expr(ir_unop_b2i, r2601);
                           ir_expression *const r2603 = expr(ir_unop_i2u, r2602);
                           body.emit(assign(r25E7, bit_or(r25FE, r2603), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f25FB->else_instructions;

                           ir_expression *const r2604 = bit_or(swizzle_y(r2521), r2528);
                           ir_expression *const r2605 = nequal(r2604, body.constant(0u));
                           ir_expression *const r2606 = expr(ir_unop_b2i, r2605);
                           body.emit(assign(r25E7, expr(ir_unop_i2u, r2606), 0x01));


                        body.instructions = f25FB_parent_instructions;
                        body.emit(f25FB);

                        /* END IF */


                     body.instructions = f25F6_parent_instructions;
                     body.emit(f25F6);

                     /* END IF */

                     body.emit(assign(r25E8, body.constant(0u), 0x01));


                  body.instructions = f25ED_parent_instructions;
                  body.emit(f25ED);

                  /* END IF */


               body.instructions = f25EB_parent_instructions;
               body.emit(f25EB);

               /* END IF */

               body.emit(assign(r2521, r25E8, 0x02));

               body.emit(assign(r2521, r25E7, 0x01));

               body.emit(assign(r251F, bit_or(swizzle_y(r251F), body.constant(1073741824u)), 0x02));

               ir_variable *const r2607 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r2608 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r2608, sub(swizzle_x(r251F), r25E7), 0x01));

               ir_expression *const r2609 = sub(swizzle_y(r251F), r25E8);
               ir_expression *const r260A = less(swizzle_x(r251F), r25E7);
               ir_expression *const r260B = expr(ir_unop_b2i, r260A);
               ir_expression *const r260C = expr(ir_unop_i2u, r260B);
               body.emit(assign(r2607, sub(r2609, r260C), 0x01));

               body.emit(assign(r251B, bit_xor(r23BE, body.constant(1u)), 0x01));

               body.emit(assign(r2522, body.constant(int(1022)), 0x01));

               ir_variable *const r260D = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r260D, body.constant(int(1012)), 0x01));

               ir_variable *const r260E = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r260E, r2607, 0x01));

               ir_variable *const r260F = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r260F, r2608, 0x01));

               ir_variable *const r2610 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r2610);
               ir_variable *const r2611 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r2611);
               /* IF CONDITION */
               ir_expression *const r2613 = equal(r2607, body.constant(0u));
               ir_if *f2612 = new(mem_ctx) ir_if(operand(r2613).val);
               exec_list *const f2612_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2612->then_instructions;

                  body.emit(assign(r260E, r2608, 0x01));

                  body.emit(assign(r260F, body.constant(0u), 0x01));

                  body.emit(assign(r260D, body.constant(int(980)), 0x01));


               body.instructions = f2612_parent_instructions;
               body.emit(f2612);

               /* END IF */

               ir_variable *const r2614 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r2614, r260E, 0x01));

               ir_variable *const r2615 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r2616 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r2616);
               /* IF CONDITION */
               ir_expression *const r2618 = equal(r260E, body.constant(0u));
               ir_if *f2617 = new(mem_ctx) ir_if(operand(r2618).val);
               exec_list *const f2617_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2617->then_instructions;

                  body.emit(assign(r2615, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2617->else_instructions;

                  body.emit(assign(r2616, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r261A = bit_and(r260E, body.constant(4294901760u));
                  ir_expression *const r261B = equal(r261A, body.constant(0u));
                  ir_if *f2619 = new(mem_ctx) ir_if(operand(r261B).val);
                  exec_list *const f2619_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2619->then_instructions;

                     body.emit(assign(r2616, body.constant(int(16)), 0x01));

                     body.emit(assign(r2614, lshift(r260E, body.constant(int(16))), 0x01));


                  body.instructions = f2619_parent_instructions;
                  body.emit(f2619);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r261D = bit_and(r2614, body.constant(4278190080u));
                  ir_expression *const r261E = equal(r261D, body.constant(0u));
                  ir_if *f261C = new(mem_ctx) ir_if(operand(r261E).val);
                  exec_list *const f261C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f261C->then_instructions;

                     body.emit(assign(r2616, add(r2616, body.constant(int(8))), 0x01));

                     body.emit(assign(r2614, lshift(r2614, body.constant(int(8))), 0x01));


                  body.instructions = f261C_parent_instructions;
                  body.emit(f261C);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2620 = bit_and(r2614, body.constant(4026531840u));
                  ir_expression *const r2621 = equal(r2620, body.constant(0u));
                  ir_if *f261F = new(mem_ctx) ir_if(operand(r2621).val);
                  exec_list *const f261F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f261F->then_instructions;

                     body.emit(assign(r2616, add(r2616, body.constant(int(4))), 0x01));

                     body.emit(assign(r2614, lshift(r2614, body.constant(int(4))), 0x01));


                  body.instructions = f261F_parent_instructions;
                  body.emit(f261F);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2623 = bit_and(r2614, body.constant(3221225472u));
                  ir_expression *const r2624 = equal(r2623, body.constant(0u));
                  ir_if *f2622 = new(mem_ctx) ir_if(operand(r2624).val);
                  exec_list *const f2622_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2622->then_instructions;

                     body.emit(assign(r2616, add(r2616, body.constant(int(2))), 0x01));

                     body.emit(assign(r2614, lshift(r2614, body.constant(int(2))), 0x01));


                  body.instructions = f2622_parent_instructions;
                  body.emit(f2622);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2626 = bit_and(r2614, body.constant(2147483648u));
                  ir_expression *const r2627 = equal(r2626, body.constant(0u));
                  ir_if *f2625 = new(mem_ctx) ir_if(operand(r2627).val);
                  exec_list *const f2625_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2625->then_instructions;

                     body.emit(assign(r2616, add(r2616, body.constant(int(1))), 0x01));


                  body.instructions = f2625_parent_instructions;
                  body.emit(f2625);

                  /* END IF */

                  body.emit(assign(r2615, r2616, 0x01));


               body.instructions = f2617_parent_instructions;
               body.emit(f2617);

               /* END IF */

               body.emit(assign(r2611, add(r2615, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2629 = lequal(body.constant(int(0)), r2611);
               ir_if *f2628 = new(mem_ctx) ir_if(operand(r2629).val);
               exec_list *const f2628_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2628->then_instructions;

                  body.emit(assign(r2610, body.constant(0u), 0x01));

                  ir_variable *const r262A = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r262A, lshift(r260F, r2611), 0x01));

                  ir_variable *const r262B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r262D = equal(r2611, body.constant(int(0)));
                  ir_if *f262C = new(mem_ctx) ir_if(operand(r262D).val);
                  exec_list *const f262C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f262C->then_instructions;

                     body.emit(assign(r262B, r260E, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f262C->else_instructions;

                     ir_expression *const r262E = lshift(r260E, r2611);
                     ir_expression *const r262F = neg(r2611);
                     ir_expression *const r2630 = bit_and(r262F, body.constant(int(31)));
                     ir_expression *const r2631 = rshift(r260F, r2630);
                     body.emit(assign(r262B, bit_or(r262E, r2631), 0x01));


                  body.instructions = f262C_parent_instructions;
                  body.emit(f262C);

                  /* END IF */

                  body.emit(assign(r260E, r262B, 0x01));

                  body.emit(assign(r260F, r262A, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2628->else_instructions;

                  ir_variable *const r2632 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r2632, body.constant(0u), 0x01));

                  ir_variable *const r2633 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r2633, neg(r2611), 0x01));

                  ir_variable *const r2634 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r2634);
                  ir_variable *const r2635 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r2635);
                  ir_variable *const r2636 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r2636);
                  ir_variable *const r2637 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r2638 = neg(r2633);
                  body.emit(assign(r2637, bit_and(r2638, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r263A = equal(r2633, body.constant(int(0)));
                  ir_if *f2639 = new(mem_ctx) ir_if(operand(r263A).val);
                  exec_list *const f2639_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2639->then_instructions;

                     body.emit(assign(r2634, r2632, 0x01));

                     body.emit(assign(r2635, r260F, 0x01));

                     body.emit(assign(r2636, r260E, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2639->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r263C = less(r2633, body.constant(int(32)));
                     ir_if *f263B = new(mem_ctx) ir_if(operand(r263C).val);
                     exec_list *const f263B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f263B->then_instructions;

                        body.emit(assign(r2634, lshift(r260F, r2637), 0x01));

                        ir_expression *const r263D = lshift(r260E, r2637);
                        ir_expression *const r263E = rshift(r260F, r2633);
                        body.emit(assign(r2635, bit_or(r263D, r263E), 0x01));

                        body.emit(assign(r2636, rshift(r260E, r2633), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f263B->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2640 = equal(r2633, body.constant(int(32)));
                        ir_if *f263F = new(mem_ctx) ir_if(operand(r2640).val);
                        exec_list *const f263F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f263F->then_instructions;

                           body.emit(assign(r2634, r260F, 0x01));

                           body.emit(assign(r2635, r260E, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f263F->else_instructions;

                           body.emit(assign(r2632, bit_or(body.constant(0u), r260F), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2642 = less(r2633, body.constant(int(64)));
                           ir_if *f2641 = new(mem_ctx) ir_if(operand(r2642).val);
                           exec_list *const f2641_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2641->then_instructions;

                              body.emit(assign(r2634, lshift(r260E, r2637), 0x01));

                              ir_expression *const r2643 = bit_and(r2633, body.constant(int(31)));
                              body.emit(assign(r2635, rshift(r260E, r2643), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2641->else_instructions;

                              ir_variable *const r2644 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2646 = equal(r2633, body.constant(int(64)));
                              ir_if *f2645 = new(mem_ctx) ir_if(operand(r2646).val);
                              exec_list *const f2645_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2645->then_instructions;

                                 body.emit(assign(r2644, r260E, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2645->else_instructions;

                                 ir_expression *const r2647 = nequal(r260E, body.constant(0u));
                                 ir_expression *const r2648 = expr(ir_unop_b2i, r2647);
                                 body.emit(assign(r2644, expr(ir_unop_i2u, r2648), 0x01));


                              body.instructions = f2645_parent_instructions;
                              body.emit(f2645);

                              /* END IF */

                              body.emit(assign(r2634, r2644, 0x01));

                              body.emit(assign(r2635, body.constant(0u), 0x01));


                           body.instructions = f2641_parent_instructions;
                           body.emit(f2641);

                           /* END IF */


                        body.instructions = f263F_parent_instructions;
                        body.emit(f263F);

                        /* END IF */

                        body.emit(assign(r2636, body.constant(0u), 0x01));


                     body.instructions = f263B_parent_instructions;
                     body.emit(f263B);

                     /* END IF */

                     ir_expression *const r2649 = nequal(r2632, body.constant(0u));
                     ir_expression *const r264A = expr(ir_unop_b2i, r2649);
                     ir_expression *const r264B = expr(ir_unop_i2u, r264A);
                     body.emit(assign(r2634, bit_or(r2634, r264B), 0x01));


                  body.instructions = f2639_parent_instructions;
                  body.emit(f2639);

                  /* END IF */

                  body.emit(assign(r260E, r2636, 0x01));

                  body.emit(assign(r260F, r2635, 0x01));

                  body.emit(assign(r2610, r2634, 0x01));


               body.instructions = f2628_parent_instructions;
               body.emit(f2628);

               /* END IF */

               body.emit(assign(r260D, sub(r260D, r2611), 0x01));

               ir_variable *const r264C = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r264C, r260D, 0x01));

               ir_variable *const r264D = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r264D, r260E, 0x01));

               ir_variable *const r264E = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r264E, r260F, 0x01));

               ir_variable *const r264F = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r264F, r2610, 0x01));

               ir_variable *const r2650 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r2650, body.constant(true), 0x01));

               ir_variable *const r2651 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2652 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2652);
               ir_expression *const r2653 = expr(ir_unop_u2i, r2610);
               body.emit(assign(r2652, less(r2653, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2655 = lequal(body.constant(int(2045)), r260D);
               ir_if *f2654 = new(mem_ctx) ir_if(operand(r2655).val);
               exec_list *const f2654_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2654->then_instructions;

                  ir_variable *const r2656 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2658 = less(body.constant(int(2045)), r260D);
                  ir_if *f2657 = new(mem_ctx) ir_if(operand(r2658).val);
                  exec_list *const f2657_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2657->then_instructions;

                     body.emit(assign(r2656, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2657->else_instructions;

                     ir_variable *const r2659 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r265B = equal(r260D, body.constant(int(2045)));
                     ir_if *f265A = new(mem_ctx) ir_if(operand(r265B).val);
                     exec_list *const f265A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f265A->then_instructions;

                        ir_expression *const r265C = equal(body.constant(2097151u), r260E);
                        ir_expression *const r265D = equal(body.constant(4294967295u), r260F);
                        body.emit(assign(r2659, logic_and(r265C, r265D), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f265A->else_instructions;

                        body.emit(assign(r2659, body.constant(false), 0x01));


                     body.instructions = f265A_parent_instructions;
                     body.emit(f265A);

                     /* END IF */

                     body.emit(assign(r2656, logic_and(r2659, r2652), 0x01));


                  body.instructions = f2657_parent_instructions;
                  body.emit(f2657);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f265E = new(mem_ctx) ir_if(operand(r2656).val);
                  exec_list *const f265E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f265E->then_instructions;

                     ir_variable *const r265F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r265F);
                     ir_expression *const r2660 = lshift(r251B, body.constant(int(31)));
                     body.emit(assign(r265F, add(r2660, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r265F, body.constant(0u), 0x01));

                     body.emit(assign(r2651, r265F, 0x03));

                     body.emit(assign(r2650, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f265E->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2662 = less(r260D, body.constant(int(0)));
                     ir_if *f2661 = new(mem_ctx) ir_if(operand(r2662).val);
                     exec_list *const f2661_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2661->then_instructions;

                        ir_variable *const r2663 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2663, r2610, 0x01));

                        ir_variable *const r2664 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2664, neg(r260D), 0x01));

                        ir_variable *const r2665 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2665);
                        ir_variable *const r2666 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2666);
                        ir_variable *const r2667 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2667);
                        ir_variable *const r2668 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2669 = neg(r2664);
                        body.emit(assign(r2668, bit_and(r2669, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r266B = equal(r2664, body.constant(int(0)));
                        ir_if *f266A = new(mem_ctx) ir_if(operand(r266B).val);
                        exec_list *const f266A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f266A->then_instructions;

                           body.emit(assign(r2665, r2610, 0x01));

                           body.emit(assign(r2666, r260F, 0x01));

                           body.emit(assign(r2667, r260E, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f266A->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r266D = less(r2664, body.constant(int(32)));
                           ir_if *f266C = new(mem_ctx) ir_if(operand(r266D).val);
                           exec_list *const f266C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f266C->then_instructions;

                              body.emit(assign(r2665, lshift(r260F, r2668), 0x01));

                              ir_expression *const r266E = lshift(r260E, r2668);
                              ir_expression *const r266F = rshift(r260F, r2664);
                              body.emit(assign(r2666, bit_or(r266E, r266F), 0x01));

                              body.emit(assign(r2667, rshift(r260E, r2664), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f266C->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2671 = equal(r2664, body.constant(int(32)));
                              ir_if *f2670 = new(mem_ctx) ir_if(operand(r2671).val);
                              exec_list *const f2670_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2670->then_instructions;

                                 body.emit(assign(r2665, r260F, 0x01));

                                 body.emit(assign(r2666, r260E, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2670->else_instructions;

                                 body.emit(assign(r2663, bit_or(r2610, r260F), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2673 = less(r2664, body.constant(int(64)));
                                 ir_if *f2672 = new(mem_ctx) ir_if(operand(r2673).val);
                                 exec_list *const f2672_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2672->then_instructions;

                                    body.emit(assign(r2665, lshift(r260E, r2668), 0x01));

                                    ir_expression *const r2674 = bit_and(r2664, body.constant(int(31)));
                                    body.emit(assign(r2666, rshift(r260E, r2674), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2672->else_instructions;

                                    ir_variable *const r2675 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2677 = equal(r2664, body.constant(int(64)));
                                    ir_if *f2676 = new(mem_ctx) ir_if(operand(r2677).val);
                                    exec_list *const f2676_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2676->then_instructions;

                                       body.emit(assign(r2675, r260E, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2676->else_instructions;

                                       ir_expression *const r2678 = nequal(r260E, body.constant(0u));
                                       ir_expression *const r2679 = expr(ir_unop_b2i, r2678);
                                       body.emit(assign(r2675, expr(ir_unop_i2u, r2679), 0x01));


                                    body.instructions = f2676_parent_instructions;
                                    body.emit(f2676);

                                    /* END IF */

                                    body.emit(assign(r2665, r2675, 0x01));

                                    body.emit(assign(r2666, body.constant(0u), 0x01));


                                 body.instructions = f2672_parent_instructions;
                                 body.emit(f2672);

                                 /* END IF */


                              body.instructions = f2670_parent_instructions;
                              body.emit(f2670);

                              /* END IF */

                              body.emit(assign(r2667, body.constant(0u), 0x01));


                           body.instructions = f266C_parent_instructions;
                           body.emit(f266C);

                           /* END IF */

                           ir_expression *const r267A = nequal(r2663, body.constant(0u));
                           ir_expression *const r267B = expr(ir_unop_b2i, r267A);
                           ir_expression *const r267C = expr(ir_unop_i2u, r267B);
                           body.emit(assign(r2665, bit_or(r2665, r267C), 0x01));


                        body.instructions = f266A_parent_instructions;
                        body.emit(f266A);

                        /* END IF */

                        body.emit(assign(r264D, r2667, 0x01));

                        body.emit(assign(r264E, r2666, 0x01));

                        body.emit(assign(r264F, r2665, 0x01));

                        body.emit(assign(r264C, body.constant(int(0)), 0x01));

                        body.emit(assign(r2652, less(r2665, body.constant(0u)), 0x01));


                     body.instructions = f2661_parent_instructions;
                     body.emit(f2661);

                     /* END IF */


                  body.instructions = f265E_parent_instructions;
                  body.emit(f265E);

                  /* END IF */


               body.instructions = f2654_parent_instructions;
               body.emit(f2654);

               /* END IF */

               /* IF CONDITION */
               ir_if *f267D = new(mem_ctx) ir_if(operand(r2650).val);
               exec_list *const f267D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f267D->then_instructions;

                  /* IF CONDITION */
                  ir_if *f267E = new(mem_ctx) ir_if(operand(r2652).val);
                  exec_list *const f267E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f267E->then_instructions;

                     ir_variable *const r267F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r267F, add(r264E, body.constant(1u)), 0x01));

                     ir_expression *const r2680 = less(r267F, r264E);
                     ir_expression *const r2681 = expr(ir_unop_b2i, r2680);
                     ir_expression *const r2682 = expr(ir_unop_i2u, r2681);
                     body.emit(assign(r264D, add(r264D, r2682), 0x01));

                     ir_expression *const r2683 = equal(r264F, body.constant(0u));
                     ir_expression *const r2684 = expr(ir_unop_b2i, r2683);
                     ir_expression *const r2685 = expr(ir_unop_i2u, r2684);
                     ir_expression *const r2686 = add(r264F, r2685);
                     ir_expression *const r2687 = bit_and(r2686, body.constant(1u));
                     ir_expression *const r2688 = expr(ir_unop_bit_not, r2687);
                     body.emit(assign(r264E, bit_and(r267F, r2688), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f267E->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r268A = bit_or(r264D, r264E);
                     ir_expression *const r268B = equal(r268A, body.constant(0u));
                     ir_if *f2689 = new(mem_ctx) ir_if(operand(r268B).val);
                     exec_list *const f2689_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2689->then_instructions;

                        body.emit(assign(r264C, body.constant(int(0)), 0x01));


                     body.instructions = f2689_parent_instructions;
                     body.emit(f2689);

                     /* END IF */


                  body.instructions = f267E_parent_instructions;
                  body.emit(f267E);

                  /* END IF */

                  ir_variable *const r268C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r268C);
                  ir_expression *const r268D = lshift(r251B, body.constant(int(31)));
                  ir_expression *const r268E = expr(ir_unop_i2u, r264C);
                  ir_expression *const r268F = lshift(r268E, body.constant(int(20)));
                  ir_expression *const r2690 = add(r268D, r268F);
                  body.emit(assign(r268C, add(r2690, r264D), 0x02));

                  body.emit(assign(r268C, r264E, 0x01));

                  body.emit(assign(r2651, r268C, 0x03));

                  body.emit(assign(r2650, body.constant(false), 0x01));


               body.instructions = f267D_parent_instructions;
               body.emit(f267D);

               /* END IF */

               body.emit(assign(r251C, r2651, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f25E0->else_instructions;

               /* IF CONDITION */
               ir_expression *const r2692 = equal(r2524, body.constant(int(2047)));
               ir_if *f2691 = new(mem_ctx) ir_if(operand(r2692).val);
               exec_list *const f2691_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2691->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2694 = bit_or(swizzle_y(r2521), swizzle_x(r2521));
                  ir_expression *const r2695 = bit_or(swizzle_y(r251F), swizzle_x(r251F));
                  ir_expression *const r2696 = bit_or(r2694, r2695);
                  ir_expression *const r2697 = nequal(r2696, body.constant(0u));
                  ir_if *f2693 = new(mem_ctx) ir_if(operand(r2697).val);
                  exec_list *const f2693_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2693->then_instructions;

                     ir_variable *const r2698 = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r2698, swizzle_x(r2389), 0x01));

                     ir_variable *const r2699 = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r2699, body.constant(0u), 0x01));

                     ir_variable *const r269A = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r2698, bit_or(swizzle_y(r2389), body.constant(524288u)), 0x02));

                     body.emit(assign(r2699, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r269C = lshift(swizzle_y(r2389), body.constant(int(1)));
                     ir_expression *const r269D = lequal(body.constant(4292870144u), r269C);
                     ir_expression *const r269E = nequal(swizzle_x(r2389), body.constant(0u));
                     ir_expression *const r269F = bit_and(swizzle_y(r2389), body.constant(1048575u));
                     ir_expression *const r26A0 = nequal(r269F, body.constant(0u));
                     ir_expression *const r26A1 = logic_or(r269E, r26A0);
                     ir_expression *const r26A2 = logic_and(r269D, r26A1);
                     ir_if *f269B = new(mem_ctx) ir_if(operand(r26A2).val);
                     exec_list *const f269B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f269B->then_instructions;

                        body.emit(assign(r269A, r2698, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f269B->else_instructions;

                        body.emit(assign(r269A, r2699, 0x03));


                     body.instructions = f269B_parent_instructions;
                     body.emit(f269B);

                     /* END IF */

                     body.emit(assign(r251C, r269A, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2693->else_instructions;

                     ir_constant_data r26A3_data;
                     memset(&r26A3_data, 0, sizeof(ir_constant_data));
                     r26A3_data.u[0] = 4294967295;
                     r26A3_data.u[1] = 4294967295;
                     ir_constant *const r26A3 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r26A3_data);
                     body.emit(assign(r251C, r26A3, 0x03));


                  body.instructions = f2693_parent_instructions;
                  body.emit(f2693);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2691->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r26A5 = equal(r2524, body.constant(int(0)));
                  ir_if *f26A4 = new(mem_ctx) ir_if(operand(r26A5).val);
                  exec_list *const f26A4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f26A4->then_instructions;

                     body.emit(assign(r2520, body.constant(int(1)), 0x01));

                     body.emit(assign(r251E, body.constant(int(1)), 0x01));


                  body.instructions = f26A4_parent_instructions;
                  body.emit(f26A4);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r26A7 = less(swizzle_y(r251F), swizzle_y(r2521));
                  ir_if *f26A6 = new(mem_ctx) ir_if(operand(r26A7).val);
                  exec_list *const f26A6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f26A6->then_instructions;

                     ir_variable *const r26A8 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r26A9 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r26A9, sub(swizzle_x(r2521), swizzle_x(r251F)), 0x01));

                     ir_expression *const r26AA = sub(swizzle_y(r2521), swizzle_y(r251F));
                     ir_expression *const r26AB = less(swizzle_x(r2521), swizzle_x(r251F));
                     ir_expression *const r26AC = expr(ir_unop_b2i, r26AB);
                     ir_expression *const r26AD = expr(ir_unop_i2u, r26AC);
                     body.emit(assign(r26A8, sub(r26AA, r26AD), 0x01));

                     body.emit(assign(r2522, add(r2520, body.constant(int(-1))), 0x01));

                     ir_variable *const r26AE = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r26AE, add(r2522, body.constant(int(-10))), 0x01));

                     ir_variable *const r26AF = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r26AF, r26A8, 0x01));

                     ir_variable *const r26B0 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r26B0, r26A9, 0x01));

                     ir_variable *const r26B1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r26B1);
                     ir_variable *const r26B2 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r26B2);
                     /* IF CONDITION */
                     ir_expression *const r26B4 = equal(r26A8, body.constant(0u));
                     ir_if *f26B3 = new(mem_ctx) ir_if(operand(r26B4).val);
                     exec_list *const f26B3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f26B3->then_instructions;

                        body.emit(assign(r26AF, r26A9, 0x01));

                        body.emit(assign(r26B0, body.constant(0u), 0x01));

                        body.emit(assign(r26AE, add(r26AE, body.constant(int(-32))), 0x01));


                     body.instructions = f26B3_parent_instructions;
                     body.emit(f26B3);

                     /* END IF */

                     ir_variable *const r26B5 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r26B5, r26AF, 0x01));

                     ir_variable *const r26B6 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r26B7 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r26B7);
                     /* IF CONDITION */
                     ir_expression *const r26B9 = equal(r26AF, body.constant(0u));
                     ir_if *f26B8 = new(mem_ctx) ir_if(operand(r26B9).val);
                     exec_list *const f26B8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f26B8->then_instructions;

                        body.emit(assign(r26B6, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f26B8->else_instructions;

                        body.emit(assign(r26B7, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r26BB = bit_and(r26AF, body.constant(4294901760u));
                        ir_expression *const r26BC = equal(r26BB, body.constant(0u));
                        ir_if *f26BA = new(mem_ctx) ir_if(operand(r26BC).val);
                        exec_list *const f26BA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f26BA->then_instructions;

                           body.emit(assign(r26B7, body.constant(int(16)), 0x01));

                           body.emit(assign(r26B5, lshift(r26AF, body.constant(int(16))), 0x01));


                        body.instructions = f26BA_parent_instructions;
                        body.emit(f26BA);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r26BE = bit_and(r26B5, body.constant(4278190080u));
                        ir_expression *const r26BF = equal(r26BE, body.constant(0u));
                        ir_if *f26BD = new(mem_ctx) ir_if(operand(r26BF).val);
                        exec_list *const f26BD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f26BD->then_instructions;

                           body.emit(assign(r26B7, add(r26B7, body.constant(int(8))), 0x01));

                           body.emit(assign(r26B5, lshift(r26B5, body.constant(int(8))), 0x01));


                        body.instructions = f26BD_parent_instructions;
                        body.emit(f26BD);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r26C1 = bit_and(r26B5, body.constant(4026531840u));
                        ir_expression *const r26C2 = equal(r26C1, body.constant(0u));
                        ir_if *f26C0 = new(mem_ctx) ir_if(operand(r26C2).val);
                        exec_list *const f26C0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f26C0->then_instructions;

                           body.emit(assign(r26B7, add(r26B7, body.constant(int(4))), 0x01));

                           body.emit(assign(r26B5, lshift(r26B5, body.constant(int(4))), 0x01));


                        body.instructions = f26C0_parent_instructions;
                        body.emit(f26C0);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r26C4 = bit_and(r26B5, body.constant(3221225472u));
                        ir_expression *const r26C5 = equal(r26C4, body.constant(0u));
                        ir_if *f26C3 = new(mem_ctx) ir_if(operand(r26C5).val);
                        exec_list *const f26C3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f26C3->then_instructions;

                           body.emit(assign(r26B7, add(r26B7, body.constant(int(2))), 0x01));

                           body.emit(assign(r26B5, lshift(r26B5, body.constant(int(2))), 0x01));


                        body.instructions = f26C3_parent_instructions;
                        body.emit(f26C3);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r26C7 = bit_and(r26B5, body.constant(2147483648u));
                        ir_expression *const r26C8 = equal(r26C7, body.constant(0u));
                        ir_if *f26C6 = new(mem_ctx) ir_if(operand(r26C8).val);
                        exec_list *const f26C6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f26C6->then_instructions;

                           body.emit(assign(r26B7, add(r26B7, body.constant(int(1))), 0x01));


                        body.instructions = f26C6_parent_instructions;
                        body.emit(f26C6);

                        /* END IF */

                        body.emit(assign(r26B6, r26B7, 0x01));


                     body.instructions = f26B8_parent_instructions;
                     body.emit(f26B8);

                     /* END IF */

                     body.emit(assign(r26B2, add(r26B6, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r26CA = lequal(body.constant(int(0)), r26B2);
                     ir_if *f26C9 = new(mem_ctx) ir_if(operand(r26CA).val);
                     exec_list *const f26C9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f26C9->then_instructions;

                        body.emit(assign(r26B1, body.constant(0u), 0x01));

                        ir_variable *const r26CB = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r26CB, lshift(r26B0, r26B2), 0x01));

                        ir_variable *const r26CC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r26CE = equal(r26B2, body.constant(int(0)));
                        ir_if *f26CD = new(mem_ctx) ir_if(operand(r26CE).val);
                        exec_list *const f26CD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f26CD->then_instructions;

                           body.emit(assign(r26CC, r26AF, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f26CD->else_instructions;

                           ir_expression *const r26CF = lshift(r26AF, r26B2);
                           ir_expression *const r26D0 = neg(r26B2);
                           ir_expression *const r26D1 = bit_and(r26D0, body.constant(int(31)));
                           ir_expression *const r26D2 = rshift(r26B0, r26D1);
                           body.emit(assign(r26CC, bit_or(r26CF, r26D2), 0x01));


                        body.instructions = f26CD_parent_instructions;
                        body.emit(f26CD);

                        /* END IF */

                        body.emit(assign(r26AF, r26CC, 0x01));

                        body.emit(assign(r26B0, r26CB, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f26C9->else_instructions;

                        ir_variable *const r26D3 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r26D3, body.constant(0u), 0x01));

                        ir_variable *const r26D4 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r26D4, neg(r26B2), 0x01));

                        ir_variable *const r26D5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r26D5);
                        ir_variable *const r26D6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r26D6);
                        ir_variable *const r26D7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r26D7);
                        ir_variable *const r26D8 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r26D9 = neg(r26D4);
                        body.emit(assign(r26D8, bit_and(r26D9, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r26DB = equal(r26D4, body.constant(int(0)));
                        ir_if *f26DA = new(mem_ctx) ir_if(operand(r26DB).val);
                        exec_list *const f26DA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f26DA->then_instructions;

                           body.emit(assign(r26D5, r26D3, 0x01));

                           body.emit(assign(r26D6, r26B0, 0x01));

                           body.emit(assign(r26D7, r26AF, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f26DA->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r26DD = less(r26D4, body.constant(int(32)));
                           ir_if *f26DC = new(mem_ctx) ir_if(operand(r26DD).val);
                           exec_list *const f26DC_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f26DC->then_instructions;

                              body.emit(assign(r26D5, lshift(r26B0, r26D8), 0x01));

                              ir_expression *const r26DE = lshift(r26AF, r26D8);
                              ir_expression *const r26DF = rshift(r26B0, r26D4);
                              body.emit(assign(r26D6, bit_or(r26DE, r26DF), 0x01));

                              body.emit(assign(r26D7, rshift(r26AF, r26D4), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f26DC->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r26E1 = equal(r26D4, body.constant(int(32)));
                              ir_if *f26E0 = new(mem_ctx) ir_if(operand(r26E1).val);
                              exec_list *const f26E0_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f26E0->then_instructions;

                                 body.emit(assign(r26D5, r26B0, 0x01));

                                 body.emit(assign(r26D6, r26AF, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f26E0->else_instructions;

                                 body.emit(assign(r26D3, bit_or(body.constant(0u), r26B0), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r26E3 = less(r26D4, body.constant(int(64)));
                                 ir_if *f26E2 = new(mem_ctx) ir_if(operand(r26E3).val);
                                 exec_list *const f26E2_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f26E2->then_instructions;

                                    body.emit(assign(r26D5, lshift(r26AF, r26D8), 0x01));

                                    ir_expression *const r26E4 = bit_and(r26D4, body.constant(int(31)));
                                    body.emit(assign(r26D6, rshift(r26AF, r26E4), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f26E2->else_instructions;

                                    ir_variable *const r26E5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r26E7 = equal(r26D4, body.constant(int(64)));
                                    ir_if *f26E6 = new(mem_ctx) ir_if(operand(r26E7).val);
                                    exec_list *const f26E6_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f26E6->then_instructions;

                                       body.emit(assign(r26E5, r26AF, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f26E6->else_instructions;

                                       ir_expression *const r26E8 = nequal(r26AF, body.constant(0u));
                                       ir_expression *const r26E9 = expr(ir_unop_b2i, r26E8);
                                       body.emit(assign(r26E5, expr(ir_unop_i2u, r26E9), 0x01));


                                    body.instructions = f26E6_parent_instructions;
                                    body.emit(f26E6);

                                    /* END IF */

                                    body.emit(assign(r26D5, r26E5, 0x01));

                                    body.emit(assign(r26D6, body.constant(0u), 0x01));


                                 body.instructions = f26E2_parent_instructions;
                                 body.emit(f26E2);

                                 /* END IF */


                              body.instructions = f26E0_parent_instructions;
                              body.emit(f26E0);

                              /* END IF */

                              body.emit(assign(r26D7, body.constant(0u), 0x01));


                           body.instructions = f26DC_parent_instructions;
                           body.emit(f26DC);

                           /* END IF */

                           ir_expression *const r26EA = nequal(r26D3, body.constant(0u));
                           ir_expression *const r26EB = expr(ir_unop_b2i, r26EA);
                           ir_expression *const r26EC = expr(ir_unop_i2u, r26EB);
                           body.emit(assign(r26D5, bit_or(r26D5, r26EC), 0x01));


                        body.instructions = f26DA_parent_instructions;
                        body.emit(f26DA);

                        /* END IF */

                        body.emit(assign(r26AF, r26D7, 0x01));

                        body.emit(assign(r26B0, r26D6, 0x01));

                        body.emit(assign(r26B1, r26D5, 0x01));


                     body.instructions = f26C9_parent_instructions;
                     body.emit(f26C9);

                     /* END IF */

                     body.emit(assign(r26AE, sub(r26AE, r26B2), 0x01));

                     ir_variable *const r26ED = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r26ED, r26AE, 0x01));

                     ir_variable *const r26EE = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r26EE, r26AF, 0x01));

                     ir_variable *const r26EF = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r26EF, r26B0, 0x01));

                     ir_variable *const r26F0 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r26F0, r26B1, 0x01));

                     ir_variable *const r26F1 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r26F1, body.constant(true), 0x01));

                     ir_variable *const r26F2 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r26F3 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r26F3);
                     ir_expression *const r26F4 = expr(ir_unop_u2i, r26B1);
                     body.emit(assign(r26F3, less(r26F4, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r26F6 = lequal(body.constant(int(2045)), r26AE);
                     ir_if *f26F5 = new(mem_ctx) ir_if(operand(r26F6).val);
                     exec_list *const f26F5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f26F5->then_instructions;

                        ir_variable *const r26F7 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r26F9 = less(body.constant(int(2045)), r26AE);
                        ir_if *f26F8 = new(mem_ctx) ir_if(operand(r26F9).val);
                        exec_list *const f26F8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f26F8->then_instructions;

                           body.emit(assign(r26F7, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f26F8->else_instructions;

                           ir_variable *const r26FA = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r26FC = equal(r26AE, body.constant(int(2045)));
                           ir_if *f26FB = new(mem_ctx) ir_if(operand(r26FC).val);
                           exec_list *const f26FB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f26FB->then_instructions;

                              ir_expression *const r26FD = equal(body.constant(2097151u), r26AF);
                              ir_expression *const r26FE = equal(body.constant(4294967295u), r26B0);
                              body.emit(assign(r26FA, logic_and(r26FD, r26FE), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f26FB->else_instructions;

                              body.emit(assign(r26FA, body.constant(false), 0x01));


                           body.instructions = f26FB_parent_instructions;
                           body.emit(f26FB);

                           /* END IF */

                           body.emit(assign(r26F7, logic_and(r26FA, r26F3), 0x01));


                        body.instructions = f26F8_parent_instructions;
                        body.emit(f26F8);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f26FF = new(mem_ctx) ir_if(operand(r26F7).val);
                        exec_list *const f26FF_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f26FF->then_instructions;

                           ir_variable *const r2700 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r2700);
                           ir_expression *const r2701 = lshift(r251B, body.constant(int(31)));
                           body.emit(assign(r2700, add(r2701, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r2700, body.constant(0u), 0x01));

                           body.emit(assign(r26F2, r2700, 0x03));

                           body.emit(assign(r26F1, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f26FF->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2703 = less(r26AE, body.constant(int(0)));
                           ir_if *f2702 = new(mem_ctx) ir_if(operand(r2703).val);
                           exec_list *const f2702_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2702->then_instructions;

                              ir_variable *const r2704 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r2704, r26B1, 0x01));

                              ir_variable *const r2705 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r2705, neg(r26AE), 0x01));

                              ir_variable *const r2706 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r2706);
                              ir_variable *const r2707 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r2707);
                              ir_variable *const r2708 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r2708);
                              ir_variable *const r2709 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r270A = neg(r2705);
                              body.emit(assign(r2709, bit_and(r270A, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r270C = equal(r2705, body.constant(int(0)));
                              ir_if *f270B = new(mem_ctx) ir_if(operand(r270C).val);
                              exec_list *const f270B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f270B->then_instructions;

                                 body.emit(assign(r2706, r26B1, 0x01));

                                 body.emit(assign(r2707, r26B0, 0x01));

                                 body.emit(assign(r2708, r26AF, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f270B->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r270E = less(r2705, body.constant(int(32)));
                                 ir_if *f270D = new(mem_ctx) ir_if(operand(r270E).val);
                                 exec_list *const f270D_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f270D->then_instructions;

                                    body.emit(assign(r2706, lshift(r26B0, r2709), 0x01));

                                    ir_expression *const r270F = lshift(r26AF, r2709);
                                    ir_expression *const r2710 = rshift(r26B0, r2705);
                                    body.emit(assign(r2707, bit_or(r270F, r2710), 0x01));

                                    body.emit(assign(r2708, rshift(r26AF, r2705), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f270D->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2712 = equal(r2705, body.constant(int(32)));
                                    ir_if *f2711 = new(mem_ctx) ir_if(operand(r2712).val);
                                    exec_list *const f2711_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2711->then_instructions;

                                       body.emit(assign(r2706, r26B0, 0x01));

                                       body.emit(assign(r2707, r26AF, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2711->else_instructions;

                                       body.emit(assign(r2704, bit_or(r26B1, r26B0), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2714 = less(r2705, body.constant(int(64)));
                                       ir_if *f2713 = new(mem_ctx) ir_if(operand(r2714).val);
                                       exec_list *const f2713_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2713->then_instructions;

                                          body.emit(assign(r2706, lshift(r26AF, r2709), 0x01));

                                          ir_expression *const r2715 = bit_and(r2705, body.constant(int(31)));
                                          body.emit(assign(r2707, rshift(r26AF, r2715), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2713->else_instructions;

                                          ir_variable *const r2716 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r2718 = equal(r2705, body.constant(int(64)));
                                          ir_if *f2717 = new(mem_ctx) ir_if(operand(r2718).val);
                                          exec_list *const f2717_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2717->then_instructions;

                                             body.emit(assign(r2716, r26AF, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2717->else_instructions;

                                             ir_expression *const r2719 = nequal(r26AF, body.constant(0u));
                                             ir_expression *const r271A = expr(ir_unop_b2i, r2719);
                                             body.emit(assign(r2716, expr(ir_unop_i2u, r271A), 0x01));


                                          body.instructions = f2717_parent_instructions;
                                          body.emit(f2717);

                                          /* END IF */

                                          body.emit(assign(r2706, r2716, 0x01));

                                          body.emit(assign(r2707, body.constant(0u), 0x01));


                                       body.instructions = f2713_parent_instructions;
                                       body.emit(f2713);

                                       /* END IF */


                                    body.instructions = f2711_parent_instructions;
                                    body.emit(f2711);

                                    /* END IF */

                                    body.emit(assign(r2708, body.constant(0u), 0x01));


                                 body.instructions = f270D_parent_instructions;
                                 body.emit(f270D);

                                 /* END IF */

                                 ir_expression *const r271B = nequal(r2704, body.constant(0u));
                                 ir_expression *const r271C = expr(ir_unop_b2i, r271B);
                                 ir_expression *const r271D = expr(ir_unop_i2u, r271C);
                                 body.emit(assign(r2706, bit_or(r2706, r271D), 0x01));


                              body.instructions = f270B_parent_instructions;
                              body.emit(f270B);

                              /* END IF */

                              body.emit(assign(r26EE, r2708, 0x01));

                              body.emit(assign(r26EF, r2707, 0x01));

                              body.emit(assign(r26F0, r2706, 0x01));

                              body.emit(assign(r26ED, body.constant(int(0)), 0x01));

                              body.emit(assign(r26F3, less(r2706, body.constant(0u)), 0x01));


                           body.instructions = f2702_parent_instructions;
                           body.emit(f2702);

                           /* END IF */


                        body.instructions = f26FF_parent_instructions;
                        body.emit(f26FF);

                        /* END IF */


                     body.instructions = f26F5_parent_instructions;
                     body.emit(f26F5);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f271E = new(mem_ctx) ir_if(operand(r26F1).val);
                     exec_list *const f271E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f271E->then_instructions;

                        /* IF CONDITION */
                        ir_if *f271F = new(mem_ctx) ir_if(operand(r26F3).val);
                        exec_list *const f271F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f271F->then_instructions;

                           ir_variable *const r2720 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r2720, add(r26EF, body.constant(1u)), 0x01));

                           ir_expression *const r2721 = less(r2720, r26EF);
                           ir_expression *const r2722 = expr(ir_unop_b2i, r2721);
                           ir_expression *const r2723 = expr(ir_unop_i2u, r2722);
                           body.emit(assign(r26EE, add(r26EE, r2723), 0x01));

                           ir_expression *const r2724 = equal(r26F0, body.constant(0u));
                           ir_expression *const r2725 = expr(ir_unop_b2i, r2724);
                           ir_expression *const r2726 = expr(ir_unop_i2u, r2725);
                           ir_expression *const r2727 = add(r26F0, r2726);
                           ir_expression *const r2728 = bit_and(r2727, body.constant(1u));
                           ir_expression *const r2729 = expr(ir_unop_bit_not, r2728);
                           body.emit(assign(r26EF, bit_and(r2720, r2729), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f271F->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r272B = bit_or(r26EE, r26EF);
                           ir_expression *const r272C = equal(r272B, body.constant(0u));
                           ir_if *f272A = new(mem_ctx) ir_if(operand(r272C).val);
                           exec_list *const f272A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f272A->then_instructions;

                              body.emit(assign(r26ED, body.constant(int(0)), 0x01));


                           body.instructions = f272A_parent_instructions;
                           body.emit(f272A);

                           /* END IF */


                        body.instructions = f271F_parent_instructions;
                        body.emit(f271F);

                        /* END IF */

                        ir_variable *const r272D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r272D);
                        ir_expression *const r272E = lshift(r251B, body.constant(int(31)));
                        ir_expression *const r272F = expr(ir_unop_i2u, r26ED);
                        ir_expression *const r2730 = lshift(r272F, body.constant(int(20)));
                        ir_expression *const r2731 = add(r272E, r2730);
                        body.emit(assign(r272D, add(r2731, r26EE), 0x02));

                        body.emit(assign(r272D, r26EF, 0x01));

                        body.emit(assign(r26F2, r272D, 0x03));

                        body.emit(assign(r26F1, body.constant(false), 0x01));


                     body.instructions = f271E_parent_instructions;
                     body.emit(f271E);

                     /* END IF */

                     body.emit(assign(r251C, r26F2, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f26A6->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2733 = less(swizzle_y(r2521), swizzle_y(r251F));
                     ir_if *f2732 = new(mem_ctx) ir_if(operand(r2733).val);
                     exec_list *const f2732_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2732->then_instructions;

                        ir_variable *const r2734 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r2735 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r2735, sub(swizzle_x(r251F), swizzle_x(r2521)), 0x01));

                        ir_expression *const r2736 = sub(swizzle_y(r251F), swizzle_y(r2521));
                        ir_expression *const r2737 = less(swizzle_x(r251F), swizzle_x(r2521));
                        ir_expression *const r2738 = expr(ir_unop_b2i, r2737);
                        ir_expression *const r2739 = expr(ir_unop_i2u, r2738);
                        body.emit(assign(r2734, sub(r2736, r2739), 0x01));

                        body.emit(assign(r251B, bit_xor(r251B, body.constant(1u)), 0x01));

                        body.emit(assign(r2522, add(r251E, body.constant(int(-1))), 0x01));

                        ir_variable *const r273A = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r273A, add(r2522, body.constant(int(-10))), 0x01));

                        ir_variable *const r273B = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r273B, r2734, 0x01));

                        ir_variable *const r273C = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r273C, r2735, 0x01));

                        ir_variable *const r273D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r273D);
                        ir_variable *const r273E = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r273E);
                        /* IF CONDITION */
                        ir_expression *const r2740 = equal(r2734, body.constant(0u));
                        ir_if *f273F = new(mem_ctx) ir_if(operand(r2740).val);
                        exec_list *const f273F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f273F->then_instructions;

                           body.emit(assign(r273B, r2735, 0x01));

                           body.emit(assign(r273C, body.constant(0u), 0x01));

                           body.emit(assign(r273A, add(r273A, body.constant(int(-32))), 0x01));


                        body.instructions = f273F_parent_instructions;
                        body.emit(f273F);

                        /* END IF */

                        ir_variable *const r2741 = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r2741, r273B, 0x01));

                        ir_variable *const r2742 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r2743 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r2743);
                        /* IF CONDITION */
                        ir_expression *const r2745 = equal(r273B, body.constant(0u));
                        ir_if *f2744 = new(mem_ctx) ir_if(operand(r2745).val);
                        exec_list *const f2744_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2744->then_instructions;

                           body.emit(assign(r2742, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2744->else_instructions;

                           body.emit(assign(r2743, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2747 = bit_and(r273B, body.constant(4294901760u));
                           ir_expression *const r2748 = equal(r2747, body.constant(0u));
                           ir_if *f2746 = new(mem_ctx) ir_if(operand(r2748).val);
                           exec_list *const f2746_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2746->then_instructions;

                              body.emit(assign(r2743, body.constant(int(16)), 0x01));

                              body.emit(assign(r2741, lshift(r273B, body.constant(int(16))), 0x01));


                           body.instructions = f2746_parent_instructions;
                           body.emit(f2746);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r274A = bit_and(r2741, body.constant(4278190080u));
                           ir_expression *const r274B = equal(r274A, body.constant(0u));
                           ir_if *f2749 = new(mem_ctx) ir_if(operand(r274B).val);
                           exec_list *const f2749_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2749->then_instructions;

                              body.emit(assign(r2743, add(r2743, body.constant(int(8))), 0x01));

                              body.emit(assign(r2741, lshift(r2741, body.constant(int(8))), 0x01));


                           body.instructions = f2749_parent_instructions;
                           body.emit(f2749);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r274D = bit_and(r2741, body.constant(4026531840u));
                           ir_expression *const r274E = equal(r274D, body.constant(0u));
                           ir_if *f274C = new(mem_ctx) ir_if(operand(r274E).val);
                           exec_list *const f274C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f274C->then_instructions;

                              body.emit(assign(r2743, add(r2743, body.constant(int(4))), 0x01));

                              body.emit(assign(r2741, lshift(r2741, body.constant(int(4))), 0x01));


                           body.instructions = f274C_parent_instructions;
                           body.emit(f274C);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2750 = bit_and(r2741, body.constant(3221225472u));
                           ir_expression *const r2751 = equal(r2750, body.constant(0u));
                           ir_if *f274F = new(mem_ctx) ir_if(operand(r2751).val);
                           exec_list *const f274F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f274F->then_instructions;

                              body.emit(assign(r2743, add(r2743, body.constant(int(2))), 0x01));

                              body.emit(assign(r2741, lshift(r2741, body.constant(int(2))), 0x01));


                           body.instructions = f274F_parent_instructions;
                           body.emit(f274F);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2753 = bit_and(r2741, body.constant(2147483648u));
                           ir_expression *const r2754 = equal(r2753, body.constant(0u));
                           ir_if *f2752 = new(mem_ctx) ir_if(operand(r2754).val);
                           exec_list *const f2752_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2752->then_instructions;

                              body.emit(assign(r2743, add(r2743, body.constant(int(1))), 0x01));


                           body.instructions = f2752_parent_instructions;
                           body.emit(f2752);

                           /* END IF */

                           body.emit(assign(r2742, r2743, 0x01));


                        body.instructions = f2744_parent_instructions;
                        body.emit(f2744);

                        /* END IF */

                        body.emit(assign(r273E, add(r2742, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2756 = lequal(body.constant(int(0)), r273E);
                        ir_if *f2755 = new(mem_ctx) ir_if(operand(r2756).val);
                        exec_list *const f2755_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2755->then_instructions;

                           body.emit(assign(r273D, body.constant(0u), 0x01));

                           ir_variable *const r2757 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r2757, lshift(r273C, r273E), 0x01));

                           ir_variable *const r2758 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r275A = equal(r273E, body.constant(int(0)));
                           ir_if *f2759 = new(mem_ctx) ir_if(operand(r275A).val);
                           exec_list *const f2759_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2759->then_instructions;

                              body.emit(assign(r2758, r273B, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2759->else_instructions;

                              ir_expression *const r275B = lshift(r273B, r273E);
                              ir_expression *const r275C = neg(r273E);
                              ir_expression *const r275D = bit_and(r275C, body.constant(int(31)));
                              ir_expression *const r275E = rshift(r273C, r275D);
                              body.emit(assign(r2758, bit_or(r275B, r275E), 0x01));


                           body.instructions = f2759_parent_instructions;
                           body.emit(f2759);

                           /* END IF */

                           body.emit(assign(r273B, r2758, 0x01));

                           body.emit(assign(r273C, r2757, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2755->else_instructions;

                           ir_variable *const r275F = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r275F, body.constant(0u), 0x01));

                           ir_variable *const r2760 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r2760, neg(r273E), 0x01));

                           ir_variable *const r2761 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r2761);
                           ir_variable *const r2762 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r2762);
                           ir_variable *const r2763 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r2763);
                           ir_variable *const r2764 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r2765 = neg(r2760);
                           body.emit(assign(r2764, bit_and(r2765, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2767 = equal(r2760, body.constant(int(0)));
                           ir_if *f2766 = new(mem_ctx) ir_if(operand(r2767).val);
                           exec_list *const f2766_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2766->then_instructions;

                              body.emit(assign(r2761, r275F, 0x01));

                              body.emit(assign(r2762, r273C, 0x01));

                              body.emit(assign(r2763, r273B, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2766->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2769 = less(r2760, body.constant(int(32)));
                              ir_if *f2768 = new(mem_ctx) ir_if(operand(r2769).val);
                              exec_list *const f2768_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2768->then_instructions;

                                 body.emit(assign(r2761, lshift(r273C, r2764), 0x01));

                                 ir_expression *const r276A = lshift(r273B, r2764);
                                 ir_expression *const r276B = rshift(r273C, r2760);
                                 body.emit(assign(r2762, bit_or(r276A, r276B), 0x01));

                                 body.emit(assign(r2763, rshift(r273B, r2760), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2768->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r276D = equal(r2760, body.constant(int(32)));
                                 ir_if *f276C = new(mem_ctx) ir_if(operand(r276D).val);
                                 exec_list *const f276C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f276C->then_instructions;

                                    body.emit(assign(r2761, r273C, 0x01));

                                    body.emit(assign(r2762, r273B, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f276C->else_instructions;

                                    body.emit(assign(r275F, bit_or(body.constant(0u), r273C), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r276F = less(r2760, body.constant(int(64)));
                                    ir_if *f276E = new(mem_ctx) ir_if(operand(r276F).val);
                                    exec_list *const f276E_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f276E->then_instructions;

                                       body.emit(assign(r2761, lshift(r273B, r2764), 0x01));

                                       ir_expression *const r2770 = bit_and(r2760, body.constant(int(31)));
                                       body.emit(assign(r2762, rshift(r273B, r2770), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f276E->else_instructions;

                                       ir_variable *const r2771 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r2773 = equal(r2760, body.constant(int(64)));
                                       ir_if *f2772 = new(mem_ctx) ir_if(operand(r2773).val);
                                       exec_list *const f2772_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2772->then_instructions;

                                          body.emit(assign(r2771, r273B, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2772->else_instructions;

                                          ir_expression *const r2774 = nequal(r273B, body.constant(0u));
                                          ir_expression *const r2775 = expr(ir_unop_b2i, r2774);
                                          body.emit(assign(r2771, expr(ir_unop_i2u, r2775), 0x01));


                                       body.instructions = f2772_parent_instructions;
                                       body.emit(f2772);

                                       /* END IF */

                                       body.emit(assign(r2761, r2771, 0x01));

                                       body.emit(assign(r2762, body.constant(0u), 0x01));


                                    body.instructions = f276E_parent_instructions;
                                    body.emit(f276E);

                                    /* END IF */


                                 body.instructions = f276C_parent_instructions;
                                 body.emit(f276C);

                                 /* END IF */

                                 body.emit(assign(r2763, body.constant(0u), 0x01));


                              body.instructions = f2768_parent_instructions;
                              body.emit(f2768);

                              /* END IF */

                              ir_expression *const r2776 = nequal(r275F, body.constant(0u));
                              ir_expression *const r2777 = expr(ir_unop_b2i, r2776);
                              ir_expression *const r2778 = expr(ir_unop_i2u, r2777);
                              body.emit(assign(r2761, bit_or(r2761, r2778), 0x01));


                           body.instructions = f2766_parent_instructions;
                           body.emit(f2766);

                           /* END IF */

                           body.emit(assign(r273B, r2763, 0x01));

                           body.emit(assign(r273C, r2762, 0x01));

                           body.emit(assign(r273D, r2761, 0x01));


                        body.instructions = f2755_parent_instructions;
                        body.emit(f2755);

                        /* END IF */

                        body.emit(assign(r273A, sub(r273A, r273E), 0x01));

                        ir_variable *const r2779 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r2779, r273A, 0x01));

                        ir_variable *const r277A = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r277A, r273B, 0x01));

                        ir_variable *const r277B = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r277B, r273C, 0x01));

                        ir_variable *const r277C = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r277C, r273D, 0x01));

                        ir_variable *const r277D = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r277D, body.constant(true), 0x01));

                        ir_variable *const r277E = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r277F = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r277F);
                        ir_expression *const r2780 = expr(ir_unop_u2i, r273D);
                        body.emit(assign(r277F, less(r2780, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2782 = lequal(body.constant(int(2045)), r273A);
                        ir_if *f2781 = new(mem_ctx) ir_if(operand(r2782).val);
                        exec_list *const f2781_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2781->then_instructions;

                           ir_variable *const r2783 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2785 = less(body.constant(int(2045)), r273A);
                           ir_if *f2784 = new(mem_ctx) ir_if(operand(r2785).val);
                           exec_list *const f2784_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2784->then_instructions;

                              body.emit(assign(r2783, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2784->else_instructions;

                              ir_variable *const r2786 = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2788 = equal(r273A, body.constant(int(2045)));
                              ir_if *f2787 = new(mem_ctx) ir_if(operand(r2788).val);
                              exec_list *const f2787_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2787->then_instructions;

                                 ir_expression *const r2789 = equal(body.constant(2097151u), r273B);
                                 ir_expression *const r278A = equal(body.constant(4294967295u), r273C);
                                 body.emit(assign(r2786, logic_and(r2789, r278A), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2787->else_instructions;

                                 body.emit(assign(r2786, body.constant(false), 0x01));


                              body.instructions = f2787_parent_instructions;
                              body.emit(f2787);

                              /* END IF */

                              body.emit(assign(r2783, logic_and(r2786, r277F), 0x01));


                           body.instructions = f2784_parent_instructions;
                           body.emit(f2784);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f278B = new(mem_ctx) ir_if(operand(r2783).val);
                           exec_list *const f278B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f278B->then_instructions;

                              ir_variable *const r278C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r278C);
                              ir_expression *const r278D = lshift(r251B, body.constant(int(31)));
                              body.emit(assign(r278C, add(r278D, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r278C, body.constant(0u), 0x01));

                              body.emit(assign(r277E, r278C, 0x03));

                              body.emit(assign(r277D, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f278B->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r278F = less(r273A, body.constant(int(0)));
                              ir_if *f278E = new(mem_ctx) ir_if(operand(r278F).val);
                              exec_list *const f278E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f278E->then_instructions;

                                 ir_variable *const r2790 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r2790, r273D, 0x01));

                                 ir_variable *const r2791 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r2791, neg(r273A), 0x01));

                                 ir_variable *const r2792 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r2792);
                                 ir_variable *const r2793 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r2793);
                                 ir_variable *const r2794 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r2794);
                                 ir_variable *const r2795 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r2796 = neg(r2791);
                                 body.emit(assign(r2795, bit_and(r2796, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2798 = equal(r2791, body.constant(int(0)));
                                 ir_if *f2797 = new(mem_ctx) ir_if(operand(r2798).val);
                                 exec_list *const f2797_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2797->then_instructions;

                                    body.emit(assign(r2792, r273D, 0x01));

                                    body.emit(assign(r2793, r273C, 0x01));

                                    body.emit(assign(r2794, r273B, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2797->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r279A = less(r2791, body.constant(int(32)));
                                    ir_if *f2799 = new(mem_ctx) ir_if(operand(r279A).val);
                                    exec_list *const f2799_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2799->then_instructions;

                                       body.emit(assign(r2792, lshift(r273C, r2795), 0x01));

                                       ir_expression *const r279B = lshift(r273B, r2795);
                                       ir_expression *const r279C = rshift(r273C, r2791);
                                       body.emit(assign(r2793, bit_or(r279B, r279C), 0x01));

                                       body.emit(assign(r2794, rshift(r273B, r2791), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2799->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r279E = equal(r2791, body.constant(int(32)));
                                       ir_if *f279D = new(mem_ctx) ir_if(operand(r279E).val);
                                       exec_list *const f279D_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f279D->then_instructions;

                                          body.emit(assign(r2792, r273C, 0x01));

                                          body.emit(assign(r2793, r273B, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f279D->else_instructions;

                                          body.emit(assign(r2790, bit_or(r273D, r273C), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r27A0 = less(r2791, body.constant(int(64)));
                                          ir_if *f279F = new(mem_ctx) ir_if(operand(r27A0).val);
                                          exec_list *const f279F_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f279F->then_instructions;

                                             body.emit(assign(r2792, lshift(r273B, r2795), 0x01));

                                             ir_expression *const r27A1 = bit_and(r2791, body.constant(int(31)));
                                             body.emit(assign(r2793, rshift(r273B, r27A1), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f279F->else_instructions;

                                             ir_variable *const r27A2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r27A4 = equal(r2791, body.constant(int(64)));
                                             ir_if *f27A3 = new(mem_ctx) ir_if(operand(r27A4).val);
                                             exec_list *const f27A3_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f27A3->then_instructions;

                                                body.emit(assign(r27A2, r273B, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f27A3->else_instructions;

                                                ir_expression *const r27A5 = nequal(r273B, body.constant(0u));
                                                ir_expression *const r27A6 = expr(ir_unop_b2i, r27A5);
                                                body.emit(assign(r27A2, expr(ir_unop_i2u, r27A6), 0x01));


                                             body.instructions = f27A3_parent_instructions;
                                             body.emit(f27A3);

                                             /* END IF */

                                             body.emit(assign(r2792, r27A2, 0x01));

                                             body.emit(assign(r2793, body.constant(0u), 0x01));


                                          body.instructions = f279F_parent_instructions;
                                          body.emit(f279F);

                                          /* END IF */


                                       body.instructions = f279D_parent_instructions;
                                       body.emit(f279D);

                                       /* END IF */

                                       body.emit(assign(r2794, body.constant(0u), 0x01));


                                    body.instructions = f2799_parent_instructions;
                                    body.emit(f2799);

                                    /* END IF */

                                    ir_expression *const r27A7 = nequal(r2790, body.constant(0u));
                                    ir_expression *const r27A8 = expr(ir_unop_b2i, r27A7);
                                    ir_expression *const r27A9 = expr(ir_unop_i2u, r27A8);
                                    body.emit(assign(r2792, bit_or(r2792, r27A9), 0x01));


                                 body.instructions = f2797_parent_instructions;
                                 body.emit(f2797);

                                 /* END IF */

                                 body.emit(assign(r277A, r2794, 0x01));

                                 body.emit(assign(r277B, r2793, 0x01));

                                 body.emit(assign(r277C, r2792, 0x01));

                                 body.emit(assign(r2779, body.constant(int(0)), 0x01));

                                 body.emit(assign(r277F, less(r2792, body.constant(0u)), 0x01));


                              body.instructions = f278E_parent_instructions;
                              body.emit(f278E);

                              /* END IF */


                           body.instructions = f278B_parent_instructions;
                           body.emit(f278B);

                           /* END IF */


                        body.instructions = f2781_parent_instructions;
                        body.emit(f2781);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f27AA = new(mem_ctx) ir_if(operand(r277D).val);
                        exec_list *const f27AA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f27AA->then_instructions;

                           /* IF CONDITION */
                           ir_if *f27AB = new(mem_ctx) ir_if(operand(r277F).val);
                           exec_list *const f27AB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f27AB->then_instructions;

                              ir_variable *const r27AC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r27AC, add(r277B, body.constant(1u)), 0x01));

                              ir_expression *const r27AD = less(r27AC, r277B);
                              ir_expression *const r27AE = expr(ir_unop_b2i, r27AD);
                              ir_expression *const r27AF = expr(ir_unop_i2u, r27AE);
                              body.emit(assign(r277A, add(r277A, r27AF), 0x01));

                              ir_expression *const r27B0 = equal(r277C, body.constant(0u));
                              ir_expression *const r27B1 = expr(ir_unop_b2i, r27B0);
                              ir_expression *const r27B2 = expr(ir_unop_i2u, r27B1);
                              ir_expression *const r27B3 = add(r277C, r27B2);
                              ir_expression *const r27B4 = bit_and(r27B3, body.constant(1u));
                              ir_expression *const r27B5 = expr(ir_unop_bit_not, r27B4);
                              body.emit(assign(r277B, bit_and(r27AC, r27B5), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f27AB->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r27B7 = bit_or(r277A, r277B);
                              ir_expression *const r27B8 = equal(r27B7, body.constant(0u));
                              ir_if *f27B6 = new(mem_ctx) ir_if(operand(r27B8).val);
                              exec_list *const f27B6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f27B6->then_instructions;

                                 body.emit(assign(r2779, body.constant(int(0)), 0x01));


                              body.instructions = f27B6_parent_instructions;
                              body.emit(f27B6);

                              /* END IF */


                           body.instructions = f27AB_parent_instructions;
                           body.emit(f27AB);

                           /* END IF */

                           ir_variable *const r27B9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r27B9);
                           ir_expression *const r27BA = lshift(r251B, body.constant(int(31)));
                           ir_expression *const r27BB = expr(ir_unop_i2u, r2779);
                           ir_expression *const r27BC = lshift(r27BB, body.constant(int(20)));
                           ir_expression *const r27BD = add(r27BA, r27BC);
                           body.emit(assign(r27B9, add(r27BD, r277A), 0x02));

                           body.emit(assign(r27B9, r277B, 0x01));

                           body.emit(assign(r277E, r27B9, 0x03));

                           body.emit(assign(r277D, body.constant(false), 0x01));


                        body.instructions = f27AA_parent_instructions;
                        body.emit(f27AA);

                        /* END IF */

                        body.emit(assign(r251C, r277E, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2732->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r27BF = less(swizzle_x(r251F), swizzle_x(r2521));
                        ir_if *f27BE = new(mem_ctx) ir_if(operand(r27BF).val);
                        exec_list *const f27BE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f27BE->then_instructions;

                           ir_variable *const r27C0 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r27C1 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r27C1, sub(swizzle_x(r2521), swizzle_x(r251F)), 0x01));

                           ir_expression *const r27C2 = sub(swizzle_y(r2521), swizzle_y(r251F));
                           ir_expression *const r27C3 = less(swizzle_x(r2521), swizzle_x(r251F));
                           ir_expression *const r27C4 = expr(ir_unop_b2i, r27C3);
                           ir_expression *const r27C5 = expr(ir_unop_i2u, r27C4);
                           body.emit(assign(r27C0, sub(r27C2, r27C5), 0x01));

                           body.emit(assign(r2522, add(r2520, body.constant(int(-1))), 0x01));

                           ir_variable *const r27C6 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r27C6, add(r2522, body.constant(int(-10))), 0x01));

                           ir_variable *const r27C7 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r27C7, r27C0, 0x01));

                           ir_variable *const r27C8 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r27C8, r27C1, 0x01));

                           ir_variable *const r27C9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r27C9);
                           ir_variable *const r27CA = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r27CA);
                           /* IF CONDITION */
                           ir_expression *const r27CC = equal(r27C0, body.constant(0u));
                           ir_if *f27CB = new(mem_ctx) ir_if(operand(r27CC).val);
                           exec_list *const f27CB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f27CB->then_instructions;

                              body.emit(assign(r27C7, r27C1, 0x01));

                              body.emit(assign(r27C8, body.constant(0u), 0x01));

                              body.emit(assign(r27C6, add(r27C6, body.constant(int(-32))), 0x01));


                           body.instructions = f27CB_parent_instructions;
                           body.emit(f27CB);

                           /* END IF */

                           ir_variable *const r27CD = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r27CD, r27C7, 0x01));

                           ir_variable *const r27CE = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r27CF = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r27CF);
                           /* IF CONDITION */
                           ir_expression *const r27D1 = equal(r27C7, body.constant(0u));
                           ir_if *f27D0 = new(mem_ctx) ir_if(operand(r27D1).val);
                           exec_list *const f27D0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f27D0->then_instructions;

                              body.emit(assign(r27CE, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f27D0->else_instructions;

                              body.emit(assign(r27CF, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r27D3 = bit_and(r27C7, body.constant(4294901760u));
                              ir_expression *const r27D4 = equal(r27D3, body.constant(0u));
                              ir_if *f27D2 = new(mem_ctx) ir_if(operand(r27D4).val);
                              exec_list *const f27D2_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f27D2->then_instructions;

                                 body.emit(assign(r27CF, body.constant(int(16)), 0x01));

                                 body.emit(assign(r27CD, lshift(r27C7, body.constant(int(16))), 0x01));


                              body.instructions = f27D2_parent_instructions;
                              body.emit(f27D2);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r27D6 = bit_and(r27CD, body.constant(4278190080u));
                              ir_expression *const r27D7 = equal(r27D6, body.constant(0u));
                              ir_if *f27D5 = new(mem_ctx) ir_if(operand(r27D7).val);
                              exec_list *const f27D5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f27D5->then_instructions;

                                 body.emit(assign(r27CF, add(r27CF, body.constant(int(8))), 0x01));

                                 body.emit(assign(r27CD, lshift(r27CD, body.constant(int(8))), 0x01));


                              body.instructions = f27D5_parent_instructions;
                              body.emit(f27D5);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r27D9 = bit_and(r27CD, body.constant(4026531840u));
                              ir_expression *const r27DA = equal(r27D9, body.constant(0u));
                              ir_if *f27D8 = new(mem_ctx) ir_if(operand(r27DA).val);
                              exec_list *const f27D8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f27D8->then_instructions;

                                 body.emit(assign(r27CF, add(r27CF, body.constant(int(4))), 0x01));

                                 body.emit(assign(r27CD, lshift(r27CD, body.constant(int(4))), 0x01));


                              body.instructions = f27D8_parent_instructions;
                              body.emit(f27D8);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r27DC = bit_and(r27CD, body.constant(3221225472u));
                              ir_expression *const r27DD = equal(r27DC, body.constant(0u));
                              ir_if *f27DB = new(mem_ctx) ir_if(operand(r27DD).val);
                              exec_list *const f27DB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f27DB->then_instructions;

                                 body.emit(assign(r27CF, add(r27CF, body.constant(int(2))), 0x01));

                                 body.emit(assign(r27CD, lshift(r27CD, body.constant(int(2))), 0x01));


                              body.instructions = f27DB_parent_instructions;
                              body.emit(f27DB);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r27DF = bit_and(r27CD, body.constant(2147483648u));
                              ir_expression *const r27E0 = equal(r27DF, body.constant(0u));
                              ir_if *f27DE = new(mem_ctx) ir_if(operand(r27E0).val);
                              exec_list *const f27DE_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f27DE->then_instructions;

                                 body.emit(assign(r27CF, add(r27CF, body.constant(int(1))), 0x01));


                              body.instructions = f27DE_parent_instructions;
                              body.emit(f27DE);

                              /* END IF */

                              body.emit(assign(r27CE, r27CF, 0x01));


                           body.instructions = f27D0_parent_instructions;
                           body.emit(f27D0);

                           /* END IF */

                           body.emit(assign(r27CA, add(r27CE, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r27E2 = lequal(body.constant(int(0)), r27CA);
                           ir_if *f27E1 = new(mem_ctx) ir_if(operand(r27E2).val);
                           exec_list *const f27E1_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f27E1->then_instructions;

                              body.emit(assign(r27C9, body.constant(0u), 0x01));

                              ir_variable *const r27E3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r27E3, lshift(r27C8, r27CA), 0x01));

                              ir_variable *const r27E4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r27E6 = equal(r27CA, body.constant(int(0)));
                              ir_if *f27E5 = new(mem_ctx) ir_if(operand(r27E6).val);
                              exec_list *const f27E5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f27E5->then_instructions;

                                 body.emit(assign(r27E4, r27C7, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f27E5->else_instructions;

                                 ir_expression *const r27E7 = lshift(r27C7, r27CA);
                                 ir_expression *const r27E8 = neg(r27CA);
                                 ir_expression *const r27E9 = bit_and(r27E8, body.constant(int(31)));
                                 ir_expression *const r27EA = rshift(r27C8, r27E9);
                                 body.emit(assign(r27E4, bit_or(r27E7, r27EA), 0x01));


                              body.instructions = f27E5_parent_instructions;
                              body.emit(f27E5);

                              /* END IF */

                              body.emit(assign(r27C7, r27E4, 0x01));

                              body.emit(assign(r27C8, r27E3, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f27E1->else_instructions;

                              ir_variable *const r27EB = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r27EB, body.constant(0u), 0x01));

                              ir_variable *const r27EC = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r27EC, neg(r27CA), 0x01));

                              ir_variable *const r27ED = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r27ED);
                              ir_variable *const r27EE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r27EE);
                              ir_variable *const r27EF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r27EF);
                              ir_variable *const r27F0 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r27F1 = neg(r27EC);
                              body.emit(assign(r27F0, bit_and(r27F1, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r27F3 = equal(r27EC, body.constant(int(0)));
                              ir_if *f27F2 = new(mem_ctx) ir_if(operand(r27F3).val);
                              exec_list *const f27F2_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f27F2->then_instructions;

                                 body.emit(assign(r27ED, r27EB, 0x01));

                                 body.emit(assign(r27EE, r27C8, 0x01));

                                 body.emit(assign(r27EF, r27C7, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f27F2->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r27F5 = less(r27EC, body.constant(int(32)));
                                 ir_if *f27F4 = new(mem_ctx) ir_if(operand(r27F5).val);
                                 exec_list *const f27F4_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f27F4->then_instructions;

                                    body.emit(assign(r27ED, lshift(r27C8, r27F0), 0x01));

                                    ir_expression *const r27F6 = lshift(r27C7, r27F0);
                                    ir_expression *const r27F7 = rshift(r27C8, r27EC);
                                    body.emit(assign(r27EE, bit_or(r27F6, r27F7), 0x01));

                                    body.emit(assign(r27EF, rshift(r27C7, r27EC), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f27F4->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r27F9 = equal(r27EC, body.constant(int(32)));
                                    ir_if *f27F8 = new(mem_ctx) ir_if(operand(r27F9).val);
                                    exec_list *const f27F8_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f27F8->then_instructions;

                                       body.emit(assign(r27ED, r27C8, 0x01));

                                       body.emit(assign(r27EE, r27C7, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f27F8->else_instructions;

                                       body.emit(assign(r27EB, bit_or(body.constant(0u), r27C8), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r27FB = less(r27EC, body.constant(int(64)));
                                       ir_if *f27FA = new(mem_ctx) ir_if(operand(r27FB).val);
                                       exec_list *const f27FA_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f27FA->then_instructions;

                                          body.emit(assign(r27ED, lshift(r27C7, r27F0), 0x01));

                                          ir_expression *const r27FC = bit_and(r27EC, body.constant(int(31)));
                                          body.emit(assign(r27EE, rshift(r27C7, r27FC), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f27FA->else_instructions;

                                          ir_variable *const r27FD = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r27FF = equal(r27EC, body.constant(int(64)));
                                          ir_if *f27FE = new(mem_ctx) ir_if(operand(r27FF).val);
                                          exec_list *const f27FE_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f27FE->then_instructions;

                                             body.emit(assign(r27FD, r27C7, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f27FE->else_instructions;

                                             ir_expression *const r2800 = nequal(r27C7, body.constant(0u));
                                             ir_expression *const r2801 = expr(ir_unop_b2i, r2800);
                                             body.emit(assign(r27FD, expr(ir_unop_i2u, r2801), 0x01));


                                          body.instructions = f27FE_parent_instructions;
                                          body.emit(f27FE);

                                          /* END IF */

                                          body.emit(assign(r27ED, r27FD, 0x01));

                                          body.emit(assign(r27EE, body.constant(0u), 0x01));


                                       body.instructions = f27FA_parent_instructions;
                                       body.emit(f27FA);

                                       /* END IF */


                                    body.instructions = f27F8_parent_instructions;
                                    body.emit(f27F8);

                                    /* END IF */

                                    body.emit(assign(r27EF, body.constant(0u), 0x01));


                                 body.instructions = f27F4_parent_instructions;
                                 body.emit(f27F4);

                                 /* END IF */

                                 ir_expression *const r2802 = nequal(r27EB, body.constant(0u));
                                 ir_expression *const r2803 = expr(ir_unop_b2i, r2802);
                                 ir_expression *const r2804 = expr(ir_unop_i2u, r2803);
                                 body.emit(assign(r27ED, bit_or(r27ED, r2804), 0x01));


                              body.instructions = f27F2_parent_instructions;
                              body.emit(f27F2);

                              /* END IF */

                              body.emit(assign(r27C7, r27EF, 0x01));

                              body.emit(assign(r27C8, r27EE, 0x01));

                              body.emit(assign(r27C9, r27ED, 0x01));


                           body.instructions = f27E1_parent_instructions;
                           body.emit(f27E1);

                           /* END IF */

                           body.emit(assign(r27C6, sub(r27C6, r27CA), 0x01));

                           ir_variable *const r2805 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r2805, r27C6, 0x01));

                           ir_variable *const r2806 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r2806, r27C7, 0x01));

                           ir_variable *const r2807 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r2807, r27C8, 0x01));

                           ir_variable *const r2808 = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r2808, r27C9, 0x01));

                           ir_variable *const r2809 = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r2809, body.constant(true), 0x01));

                           ir_variable *const r280A = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r280B = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r280B);
                           ir_expression *const r280C = expr(ir_unop_u2i, r27C9);
                           body.emit(assign(r280B, less(r280C, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r280E = lequal(body.constant(int(2045)), r27C6);
                           ir_if *f280D = new(mem_ctx) ir_if(operand(r280E).val);
                           exec_list *const f280D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f280D->then_instructions;

                              ir_variable *const r280F = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2811 = less(body.constant(int(2045)), r27C6);
                              ir_if *f2810 = new(mem_ctx) ir_if(operand(r2811).val);
                              exec_list *const f2810_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2810->then_instructions;

                                 body.emit(assign(r280F, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2810->else_instructions;

                                 ir_variable *const r2812 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2814 = equal(r27C6, body.constant(int(2045)));
                                 ir_if *f2813 = new(mem_ctx) ir_if(operand(r2814).val);
                                 exec_list *const f2813_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2813->then_instructions;

                                    ir_expression *const r2815 = equal(body.constant(2097151u), r27C7);
                                    ir_expression *const r2816 = equal(body.constant(4294967295u), r27C8);
                                    body.emit(assign(r2812, logic_and(r2815, r2816), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2813->else_instructions;

                                    body.emit(assign(r2812, body.constant(false), 0x01));


                                 body.instructions = f2813_parent_instructions;
                                 body.emit(f2813);

                                 /* END IF */

                                 body.emit(assign(r280F, logic_and(r2812, r280B), 0x01));


                              body.instructions = f2810_parent_instructions;
                              body.emit(f2810);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f2817 = new(mem_ctx) ir_if(operand(r280F).val);
                              exec_list *const f2817_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2817->then_instructions;

                                 ir_variable *const r2818 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r2818);
                                 ir_expression *const r2819 = lshift(r251B, body.constant(int(31)));
                                 body.emit(assign(r2818, add(r2819, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r2818, body.constant(0u), 0x01));

                                 body.emit(assign(r280A, r2818, 0x03));

                                 body.emit(assign(r2809, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2817->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r281B = less(r27C6, body.constant(int(0)));
                                 ir_if *f281A = new(mem_ctx) ir_if(operand(r281B).val);
                                 exec_list *const f281A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f281A->then_instructions;

                                    ir_variable *const r281C = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r281C, r27C9, 0x01));

                                    ir_variable *const r281D = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r281D, neg(r27C6), 0x01));

                                    ir_variable *const r281E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r281E);
                                    ir_variable *const r281F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r281F);
                                    ir_variable *const r2820 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r2820);
                                    ir_variable *const r2821 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r2822 = neg(r281D);
                                    body.emit(assign(r2821, bit_and(r2822, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r2824 = equal(r281D, body.constant(int(0)));
                                    ir_if *f2823 = new(mem_ctx) ir_if(operand(r2824).val);
                                    exec_list *const f2823_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2823->then_instructions;

                                       body.emit(assign(r281E, r27C9, 0x01));

                                       body.emit(assign(r281F, r27C8, 0x01));

                                       body.emit(assign(r2820, r27C7, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2823->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r2826 = less(r281D, body.constant(int(32)));
                                       ir_if *f2825 = new(mem_ctx) ir_if(operand(r2826).val);
                                       exec_list *const f2825_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2825->then_instructions;

                                          body.emit(assign(r281E, lshift(r27C8, r2821), 0x01));

                                          ir_expression *const r2827 = lshift(r27C7, r2821);
                                          ir_expression *const r2828 = rshift(r27C8, r281D);
                                          body.emit(assign(r281F, bit_or(r2827, r2828), 0x01));

                                          body.emit(assign(r2820, rshift(r27C7, r281D), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2825->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r282A = equal(r281D, body.constant(int(32)));
                                          ir_if *f2829 = new(mem_ctx) ir_if(operand(r282A).val);
                                          exec_list *const f2829_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2829->then_instructions;

                                             body.emit(assign(r281E, r27C8, 0x01));

                                             body.emit(assign(r281F, r27C7, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2829->else_instructions;

                                             body.emit(assign(r281C, bit_or(r27C9, r27C8), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r282C = less(r281D, body.constant(int(64)));
                                             ir_if *f282B = new(mem_ctx) ir_if(operand(r282C).val);
                                             exec_list *const f282B_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f282B->then_instructions;

                                                body.emit(assign(r281E, lshift(r27C7, r2821), 0x01));

                                                ir_expression *const r282D = bit_and(r281D, body.constant(int(31)));
                                                body.emit(assign(r281F, rshift(r27C7, r282D), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f282B->else_instructions;

                                                ir_variable *const r282E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r2830 = equal(r281D, body.constant(int(64)));
                                                ir_if *f282F = new(mem_ctx) ir_if(operand(r2830).val);
                                                exec_list *const f282F_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f282F->then_instructions;

                                                   body.emit(assign(r282E, r27C7, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f282F->else_instructions;

                                                   ir_expression *const r2831 = nequal(r27C7, body.constant(0u));
                                                   ir_expression *const r2832 = expr(ir_unop_b2i, r2831);
                                                   body.emit(assign(r282E, expr(ir_unop_i2u, r2832), 0x01));


                                                body.instructions = f282F_parent_instructions;
                                                body.emit(f282F);

                                                /* END IF */

                                                body.emit(assign(r281E, r282E, 0x01));

                                                body.emit(assign(r281F, body.constant(0u), 0x01));


                                             body.instructions = f282B_parent_instructions;
                                             body.emit(f282B);

                                             /* END IF */


                                          body.instructions = f2829_parent_instructions;
                                          body.emit(f2829);

                                          /* END IF */

                                          body.emit(assign(r2820, body.constant(0u), 0x01));


                                       body.instructions = f2825_parent_instructions;
                                       body.emit(f2825);

                                       /* END IF */

                                       ir_expression *const r2833 = nequal(r281C, body.constant(0u));
                                       ir_expression *const r2834 = expr(ir_unop_b2i, r2833);
                                       ir_expression *const r2835 = expr(ir_unop_i2u, r2834);
                                       body.emit(assign(r281E, bit_or(r281E, r2835), 0x01));


                                    body.instructions = f2823_parent_instructions;
                                    body.emit(f2823);

                                    /* END IF */

                                    body.emit(assign(r2806, r2820, 0x01));

                                    body.emit(assign(r2807, r281F, 0x01));

                                    body.emit(assign(r2808, r281E, 0x01));

                                    body.emit(assign(r2805, body.constant(int(0)), 0x01));

                                    body.emit(assign(r280B, less(r281E, body.constant(0u)), 0x01));


                                 body.instructions = f281A_parent_instructions;
                                 body.emit(f281A);

                                 /* END IF */


                              body.instructions = f2817_parent_instructions;
                              body.emit(f2817);

                              /* END IF */


                           body.instructions = f280D_parent_instructions;
                           body.emit(f280D);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f2836 = new(mem_ctx) ir_if(operand(r2809).val);
                           exec_list *const f2836_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2836->then_instructions;

                              /* IF CONDITION */
                              ir_if *f2837 = new(mem_ctx) ir_if(operand(r280B).val);
                              exec_list *const f2837_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2837->then_instructions;

                                 ir_variable *const r2838 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r2838, add(r2807, body.constant(1u)), 0x01));

                                 ir_expression *const r2839 = less(r2838, r2807);
                                 ir_expression *const r283A = expr(ir_unop_b2i, r2839);
                                 ir_expression *const r283B = expr(ir_unop_i2u, r283A);
                                 body.emit(assign(r2806, add(r2806, r283B), 0x01));

                                 ir_expression *const r283C = equal(r2808, body.constant(0u));
                                 ir_expression *const r283D = expr(ir_unop_b2i, r283C);
                                 ir_expression *const r283E = expr(ir_unop_i2u, r283D);
                                 ir_expression *const r283F = add(r2808, r283E);
                                 ir_expression *const r2840 = bit_and(r283F, body.constant(1u));
                                 ir_expression *const r2841 = expr(ir_unop_bit_not, r2840);
                                 body.emit(assign(r2807, bit_and(r2838, r2841), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2837->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2843 = bit_or(r2806, r2807);
                                 ir_expression *const r2844 = equal(r2843, body.constant(0u));
                                 ir_if *f2842 = new(mem_ctx) ir_if(operand(r2844).val);
                                 exec_list *const f2842_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2842->then_instructions;

                                    body.emit(assign(r2805, body.constant(int(0)), 0x01));


                                 body.instructions = f2842_parent_instructions;
                                 body.emit(f2842);

                                 /* END IF */


                              body.instructions = f2837_parent_instructions;
                              body.emit(f2837);

                              /* END IF */

                              ir_variable *const r2845 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r2845);
                              ir_expression *const r2846 = lshift(r251B, body.constant(int(31)));
                              ir_expression *const r2847 = expr(ir_unop_i2u, r2805);
                              ir_expression *const r2848 = lshift(r2847, body.constant(int(20)));
                              ir_expression *const r2849 = add(r2846, r2848);
                              body.emit(assign(r2845, add(r2849, r2806), 0x02));

                              body.emit(assign(r2845, r2807, 0x01));

                              body.emit(assign(r280A, r2845, 0x03));

                              body.emit(assign(r2809, body.constant(false), 0x01));


                           body.instructions = f2836_parent_instructions;
                           body.emit(f2836);

                           /* END IF */

                           body.emit(assign(r251C, r280A, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f27BE->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r284B = less(swizzle_x(r2521), swizzle_x(r251F));
                           ir_if *f284A = new(mem_ctx) ir_if(operand(r284B).val);
                           exec_list *const f284A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f284A->then_instructions;

                              ir_variable *const r284C = body.make_temp(glsl_type::uint_type, "z0Ptr");
                              ir_variable *const r284D = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r284D, sub(swizzle_x(r251F), swizzle_x(r2521)), 0x01));

                              ir_expression *const r284E = sub(swizzle_y(r251F), swizzle_y(r2521));
                              ir_expression *const r284F = less(swizzle_x(r251F), swizzle_x(r2521));
                              ir_expression *const r2850 = expr(ir_unop_b2i, r284F);
                              ir_expression *const r2851 = expr(ir_unop_i2u, r2850);
                              body.emit(assign(r284C, sub(r284E, r2851), 0x01));

                              body.emit(assign(r251B, bit_xor(r251B, body.constant(1u)), 0x01));

                              body.emit(assign(r2522, add(r251E, body.constant(int(-1))), 0x01));

                              ir_variable *const r2852 = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r2852, add(r2522, body.constant(int(-10))), 0x01));

                              ir_variable *const r2853 = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r2853, r284C, 0x01));

                              ir_variable *const r2854 = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r2854, r284D, 0x01));

                              ir_variable *const r2855 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                              body.emit(r2855);
                              ir_variable *const r2856 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r2856);
                              /* IF CONDITION */
                              ir_expression *const r2858 = equal(r284C, body.constant(0u));
                              ir_if *f2857 = new(mem_ctx) ir_if(operand(r2858).val);
                              exec_list *const f2857_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2857->then_instructions;

                                 body.emit(assign(r2853, r284D, 0x01));

                                 body.emit(assign(r2854, body.constant(0u), 0x01));

                                 body.emit(assign(r2852, add(r2852, body.constant(int(-32))), 0x01));


                              body.instructions = f2857_parent_instructions;
                              body.emit(f2857);

                              /* END IF */

                              ir_variable *const r2859 = body.make_temp(glsl_type::uint_type, "a");
                              body.emit(assign(r2859, r2853, 0x01));

                              ir_variable *const r285A = body.make_temp(glsl_type::int_type, "return_value");
                              ir_variable *const r285B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r285B);
                              /* IF CONDITION */
                              ir_expression *const r285D = equal(r2853, body.constant(0u));
                              ir_if *f285C = new(mem_ctx) ir_if(operand(r285D).val);
                              exec_list *const f285C_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f285C->then_instructions;

                                 body.emit(assign(r285A, body.constant(int(32)), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f285C->else_instructions;

                                 body.emit(assign(r285B, body.constant(int(0)), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r285F = bit_and(r2853, body.constant(4294901760u));
                                 ir_expression *const r2860 = equal(r285F, body.constant(0u));
                                 ir_if *f285E = new(mem_ctx) ir_if(operand(r2860).val);
                                 exec_list *const f285E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f285E->then_instructions;

                                    body.emit(assign(r285B, body.constant(int(16)), 0x01));

                                    body.emit(assign(r2859, lshift(r2853, body.constant(int(16))), 0x01));


                                 body.instructions = f285E_parent_instructions;
                                 body.emit(f285E);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2862 = bit_and(r2859, body.constant(4278190080u));
                                 ir_expression *const r2863 = equal(r2862, body.constant(0u));
                                 ir_if *f2861 = new(mem_ctx) ir_if(operand(r2863).val);
                                 exec_list *const f2861_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2861->then_instructions;

                                    body.emit(assign(r285B, add(r285B, body.constant(int(8))), 0x01));

                                    body.emit(assign(r2859, lshift(r2859, body.constant(int(8))), 0x01));


                                 body.instructions = f2861_parent_instructions;
                                 body.emit(f2861);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2865 = bit_and(r2859, body.constant(4026531840u));
                                 ir_expression *const r2866 = equal(r2865, body.constant(0u));
                                 ir_if *f2864 = new(mem_ctx) ir_if(operand(r2866).val);
                                 exec_list *const f2864_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2864->then_instructions;

                                    body.emit(assign(r285B, add(r285B, body.constant(int(4))), 0x01));

                                    body.emit(assign(r2859, lshift(r2859, body.constant(int(4))), 0x01));


                                 body.instructions = f2864_parent_instructions;
                                 body.emit(f2864);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2868 = bit_and(r2859, body.constant(3221225472u));
                                 ir_expression *const r2869 = equal(r2868, body.constant(0u));
                                 ir_if *f2867 = new(mem_ctx) ir_if(operand(r2869).val);
                                 exec_list *const f2867_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2867->then_instructions;

                                    body.emit(assign(r285B, add(r285B, body.constant(int(2))), 0x01));

                                    body.emit(assign(r2859, lshift(r2859, body.constant(int(2))), 0x01));


                                 body.instructions = f2867_parent_instructions;
                                 body.emit(f2867);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r286B = bit_and(r2859, body.constant(2147483648u));
                                 ir_expression *const r286C = equal(r286B, body.constant(0u));
                                 ir_if *f286A = new(mem_ctx) ir_if(operand(r286C).val);
                                 exec_list *const f286A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f286A->then_instructions;

                                    body.emit(assign(r285B, add(r285B, body.constant(int(1))), 0x01));


                                 body.instructions = f286A_parent_instructions;
                                 body.emit(f286A);

                                 /* END IF */

                                 body.emit(assign(r285A, r285B, 0x01));


                              body.instructions = f285C_parent_instructions;
                              body.emit(f285C);

                              /* END IF */

                              body.emit(assign(r2856, add(r285A, body.constant(int(-11))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r286E = lequal(body.constant(int(0)), r2856);
                              ir_if *f286D = new(mem_ctx) ir_if(operand(r286E).val);
                              exec_list *const f286D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f286D->then_instructions;

                                 body.emit(assign(r2855, body.constant(0u), 0x01));

                                 ir_variable *const r286F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                                 body.emit(assign(r286F, lshift(r2854, r2856), 0x01));

                                 ir_variable *const r2870 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2872 = equal(r2856, body.constant(int(0)));
                                 ir_if *f2871 = new(mem_ctx) ir_if(operand(r2872).val);
                                 exec_list *const f2871_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2871->then_instructions;

                                    body.emit(assign(r2870, r2853, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2871->else_instructions;

                                    ir_expression *const r2873 = lshift(r2853, r2856);
                                    ir_expression *const r2874 = neg(r2856);
                                    ir_expression *const r2875 = bit_and(r2874, body.constant(int(31)));
                                    ir_expression *const r2876 = rshift(r2854, r2875);
                                    body.emit(assign(r2870, bit_or(r2873, r2876), 0x01));


                                 body.instructions = f2871_parent_instructions;
                                 body.emit(f2871);

                                 /* END IF */

                                 body.emit(assign(r2853, r2870, 0x01));

                                 body.emit(assign(r2854, r286F, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f286D->else_instructions;

                                 ir_variable *const r2877 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r2877, body.constant(0u), 0x01));

                                 ir_variable *const r2878 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r2878, neg(r2856), 0x01));

                                 ir_variable *const r2879 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r2879);
                                 ir_variable *const r287A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r287A);
                                 ir_variable *const r287B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r287B);
                                 ir_variable *const r287C = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r287D = neg(r2878);
                                 body.emit(assign(r287C, bit_and(r287D, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r287F = equal(r2878, body.constant(int(0)));
                                 ir_if *f287E = new(mem_ctx) ir_if(operand(r287F).val);
                                 exec_list *const f287E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f287E->then_instructions;

                                    body.emit(assign(r2879, r2877, 0x01));

                                    body.emit(assign(r287A, r2854, 0x01));

                                    body.emit(assign(r287B, r2853, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f287E->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2881 = less(r2878, body.constant(int(32)));
                                    ir_if *f2880 = new(mem_ctx) ir_if(operand(r2881).val);
                                    exec_list *const f2880_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2880->then_instructions;

                                       body.emit(assign(r2879, lshift(r2854, r287C), 0x01));

                                       ir_expression *const r2882 = lshift(r2853, r287C);
                                       ir_expression *const r2883 = rshift(r2854, r2878);
                                       body.emit(assign(r287A, bit_or(r2882, r2883), 0x01));

                                       body.emit(assign(r287B, rshift(r2853, r2878), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2880->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r2885 = equal(r2878, body.constant(int(32)));
                                       ir_if *f2884 = new(mem_ctx) ir_if(operand(r2885).val);
                                       exec_list *const f2884_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2884->then_instructions;

                                          body.emit(assign(r2879, r2854, 0x01));

                                          body.emit(assign(r287A, r2853, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2884->else_instructions;

                                          body.emit(assign(r2877, bit_or(body.constant(0u), r2854), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r2887 = less(r2878, body.constant(int(64)));
                                          ir_if *f2886 = new(mem_ctx) ir_if(operand(r2887).val);
                                          exec_list *const f2886_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2886->then_instructions;

                                             body.emit(assign(r2879, lshift(r2853, r287C), 0x01));

                                             ir_expression *const r2888 = bit_and(r2878, body.constant(int(31)));
                                             body.emit(assign(r287A, rshift(r2853, r2888), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2886->else_instructions;

                                             ir_variable *const r2889 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r288B = equal(r2878, body.constant(int(64)));
                                             ir_if *f288A = new(mem_ctx) ir_if(operand(r288B).val);
                                             exec_list *const f288A_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f288A->then_instructions;

                                                body.emit(assign(r2889, r2853, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f288A->else_instructions;

                                                ir_expression *const r288C = nequal(r2853, body.constant(0u));
                                                ir_expression *const r288D = expr(ir_unop_b2i, r288C);
                                                body.emit(assign(r2889, expr(ir_unop_i2u, r288D), 0x01));


                                             body.instructions = f288A_parent_instructions;
                                             body.emit(f288A);

                                             /* END IF */

                                             body.emit(assign(r2879, r2889, 0x01));

                                             body.emit(assign(r287A, body.constant(0u), 0x01));


                                          body.instructions = f2886_parent_instructions;
                                          body.emit(f2886);

                                          /* END IF */


                                       body.instructions = f2884_parent_instructions;
                                       body.emit(f2884);

                                       /* END IF */

                                       body.emit(assign(r287B, body.constant(0u), 0x01));


                                    body.instructions = f2880_parent_instructions;
                                    body.emit(f2880);

                                    /* END IF */

                                    ir_expression *const r288E = nequal(r2877, body.constant(0u));
                                    ir_expression *const r288F = expr(ir_unop_b2i, r288E);
                                    ir_expression *const r2890 = expr(ir_unop_i2u, r288F);
                                    body.emit(assign(r2879, bit_or(r2879, r2890), 0x01));


                                 body.instructions = f287E_parent_instructions;
                                 body.emit(f287E);

                                 /* END IF */

                                 body.emit(assign(r2853, r287B, 0x01));

                                 body.emit(assign(r2854, r287A, 0x01));

                                 body.emit(assign(r2855, r2879, 0x01));


                              body.instructions = f286D_parent_instructions;
                              body.emit(f286D);

                              /* END IF */

                              body.emit(assign(r2852, sub(r2852, r2856), 0x01));

                              ir_variable *const r2891 = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r2891, r2852, 0x01));

                              ir_variable *const r2892 = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r2892, r2853, 0x01));

                              ir_variable *const r2893 = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r2893, r2854, 0x01));

                              ir_variable *const r2894 = body.make_temp(glsl_type::uint_type, "zFrac2");
                              body.emit(assign(r2894, r2855, 0x01));

                              ir_variable *const r2895 = body.make_temp(glsl_type::bool_type, "execute_flag");
                              body.emit(assign(r2895, body.constant(true), 0x01));

                              ir_variable *const r2896 = body.make_temp(glsl_type::uvec2_type, "return_value");
                              ir_variable *const r2897 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                              body.emit(r2897);
                              ir_expression *const r2898 = expr(ir_unop_u2i, r2855);
                              body.emit(assign(r2897, less(r2898, body.constant(int(0))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r289A = lequal(body.constant(int(2045)), r2852);
                              ir_if *f2899 = new(mem_ctx) ir_if(operand(r289A).val);
                              exec_list *const f2899_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2899->then_instructions;

                                 ir_variable *const r289B = body.make_temp(glsl_type::bool_type, "or_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r289D = less(body.constant(int(2045)), r2852);
                                 ir_if *f289C = new(mem_ctx) ir_if(operand(r289D).val);
                                 exec_list *const f289C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f289C->then_instructions;

                                    body.emit(assign(r289B, body.constant(true), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f289C->else_instructions;

                                    ir_variable *const r289E = body.make_temp(glsl_type::bool_type, "and_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r28A0 = equal(r2852, body.constant(int(2045)));
                                    ir_if *f289F = new(mem_ctx) ir_if(operand(r28A0).val);
                                    exec_list *const f289F_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f289F->then_instructions;

                                       ir_expression *const r28A1 = equal(body.constant(2097151u), r2853);
                                       ir_expression *const r28A2 = equal(body.constant(4294967295u), r2854);
                                       body.emit(assign(r289E, logic_and(r28A1, r28A2), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f289F->else_instructions;

                                       body.emit(assign(r289E, body.constant(false), 0x01));


                                    body.instructions = f289F_parent_instructions;
                                    body.emit(f289F);

                                    /* END IF */

                                    body.emit(assign(r289B, logic_and(r289E, r2897), 0x01));


                                 body.instructions = f289C_parent_instructions;
                                 body.emit(f289C);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_if *f28A3 = new(mem_ctx) ir_if(operand(r289B).val);
                                 exec_list *const f28A3_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f28A3->then_instructions;

                                    ir_variable *const r28A4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                    body.emit(r28A4);
                                    ir_expression *const r28A5 = lshift(r251B, body.constant(int(31)));
                                    body.emit(assign(r28A4, add(r28A5, body.constant(2146435072u)), 0x02));

                                    body.emit(assign(r28A4, body.constant(0u), 0x01));

                                    body.emit(assign(r2896, r28A4, 0x03));

                                    body.emit(assign(r2895, body.constant(false), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f28A3->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r28A7 = less(r2852, body.constant(int(0)));
                                    ir_if *f28A6 = new(mem_ctx) ir_if(operand(r28A7).val);
                                    exec_list *const f28A6_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f28A6->then_instructions;

                                       ir_variable *const r28A8 = body.make_temp(glsl_type::uint_type, "a2");
                                       body.emit(assign(r28A8, r2855, 0x01));

                                       ir_variable *const r28A9 = body.make_temp(glsl_type::int_type, "count");
                                       body.emit(assign(r28A9, neg(r2852), 0x01));

                                       ir_variable *const r28AA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                       body.emit(r28AA);
                                       ir_variable *const r28AB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                       body.emit(r28AB);
                                       ir_variable *const r28AC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                       body.emit(r28AC);
                                       ir_variable *const r28AD = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                       ir_expression *const r28AE = neg(r28A9);
                                       body.emit(assign(r28AD, bit_and(r28AE, body.constant(int(31))), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r28B0 = equal(r28A9, body.constant(int(0)));
                                       ir_if *f28AF = new(mem_ctx) ir_if(operand(r28B0).val);
                                       exec_list *const f28AF_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f28AF->then_instructions;

                                          body.emit(assign(r28AA, r2855, 0x01));

                                          body.emit(assign(r28AB, r2854, 0x01));

                                          body.emit(assign(r28AC, r2853, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f28AF->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r28B2 = less(r28A9, body.constant(int(32)));
                                          ir_if *f28B1 = new(mem_ctx) ir_if(operand(r28B2).val);
                                          exec_list *const f28B1_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f28B1->then_instructions;

                                             body.emit(assign(r28AA, lshift(r2854, r28AD), 0x01));

                                             ir_expression *const r28B3 = lshift(r2853, r28AD);
                                             ir_expression *const r28B4 = rshift(r2854, r28A9);
                                             body.emit(assign(r28AB, bit_or(r28B3, r28B4), 0x01));

                                             body.emit(assign(r28AC, rshift(r2853, r28A9), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f28B1->else_instructions;

                                             /* IF CONDITION */
                                             ir_expression *const r28B6 = equal(r28A9, body.constant(int(32)));
                                             ir_if *f28B5 = new(mem_ctx) ir_if(operand(r28B6).val);
                                             exec_list *const f28B5_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f28B5->then_instructions;

                                                body.emit(assign(r28AA, r2854, 0x01));

                                                body.emit(assign(r28AB, r2853, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f28B5->else_instructions;

                                                body.emit(assign(r28A8, bit_or(r2855, r2854), 0x01));

                                                /* IF CONDITION */
                                                ir_expression *const r28B8 = less(r28A9, body.constant(int(64)));
                                                ir_if *f28B7 = new(mem_ctx) ir_if(operand(r28B8).val);
                                                exec_list *const f28B7_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f28B7->then_instructions;

                                                   body.emit(assign(r28AA, lshift(r2853, r28AD), 0x01));

                                                   ir_expression *const r28B9 = bit_and(r28A9, body.constant(int(31)));
                                                   body.emit(assign(r28AB, rshift(r2853, r28B9), 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f28B7->else_instructions;

                                                   ir_variable *const r28BA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                   /* IF CONDITION */
                                                   ir_expression *const r28BC = equal(r28A9, body.constant(int(64)));
                                                   ir_if *f28BB = new(mem_ctx) ir_if(operand(r28BC).val);
                                                   exec_list *const f28BB_parent_instructions = body.instructions;

                                                      /* THEN INSTRUCTIONS */
                                                      body.instructions = &f28BB->then_instructions;

                                                      body.emit(assign(r28BA, r2853, 0x01));


                                                      /* ELSE INSTRUCTIONS */
                                                      body.instructions = &f28BB->else_instructions;

                                                      ir_expression *const r28BD = nequal(r2853, body.constant(0u));
                                                      ir_expression *const r28BE = expr(ir_unop_b2i, r28BD);
                                                      body.emit(assign(r28BA, expr(ir_unop_i2u, r28BE), 0x01));


                                                   body.instructions = f28BB_parent_instructions;
                                                   body.emit(f28BB);

                                                   /* END IF */

                                                   body.emit(assign(r28AA, r28BA, 0x01));

                                                   body.emit(assign(r28AB, body.constant(0u), 0x01));


                                                body.instructions = f28B7_parent_instructions;
                                                body.emit(f28B7);

                                                /* END IF */


                                             body.instructions = f28B5_parent_instructions;
                                             body.emit(f28B5);

                                             /* END IF */

                                             body.emit(assign(r28AC, body.constant(0u), 0x01));


                                          body.instructions = f28B1_parent_instructions;
                                          body.emit(f28B1);

                                          /* END IF */

                                          ir_expression *const r28BF = nequal(r28A8, body.constant(0u));
                                          ir_expression *const r28C0 = expr(ir_unop_b2i, r28BF);
                                          ir_expression *const r28C1 = expr(ir_unop_i2u, r28C0);
                                          body.emit(assign(r28AA, bit_or(r28AA, r28C1), 0x01));


                                       body.instructions = f28AF_parent_instructions;
                                       body.emit(f28AF);

                                       /* END IF */

                                       body.emit(assign(r2892, r28AC, 0x01));

                                       body.emit(assign(r2893, r28AB, 0x01));

                                       body.emit(assign(r2894, r28AA, 0x01));

                                       body.emit(assign(r2891, body.constant(int(0)), 0x01));

                                       body.emit(assign(r2897, less(r28AA, body.constant(0u)), 0x01));


                                    body.instructions = f28A6_parent_instructions;
                                    body.emit(f28A6);

                                    /* END IF */


                                 body.instructions = f28A3_parent_instructions;
                                 body.emit(f28A3);

                                 /* END IF */


                              body.instructions = f2899_parent_instructions;
                              body.emit(f2899);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f28C2 = new(mem_ctx) ir_if(operand(r2895).val);
                              exec_list *const f28C2_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f28C2->then_instructions;

                                 /* IF CONDITION */
                                 ir_if *f28C3 = new(mem_ctx) ir_if(operand(r2897).val);
                                 exec_list *const f28C3_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f28C3->then_instructions;

                                    ir_variable *const r28C4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                    body.emit(assign(r28C4, add(r2893, body.constant(1u)), 0x01));

                                    ir_expression *const r28C5 = less(r28C4, r2893);
                                    ir_expression *const r28C6 = expr(ir_unop_b2i, r28C5);
                                    ir_expression *const r28C7 = expr(ir_unop_i2u, r28C6);
                                    body.emit(assign(r2892, add(r2892, r28C7), 0x01));

                                    ir_expression *const r28C8 = equal(r2894, body.constant(0u));
                                    ir_expression *const r28C9 = expr(ir_unop_b2i, r28C8);
                                    ir_expression *const r28CA = expr(ir_unop_i2u, r28C9);
                                    ir_expression *const r28CB = add(r2894, r28CA);
                                    ir_expression *const r28CC = bit_and(r28CB, body.constant(1u));
                                    ir_expression *const r28CD = expr(ir_unop_bit_not, r28CC);
                                    body.emit(assign(r2893, bit_and(r28C4, r28CD), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f28C3->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r28CF = bit_or(r2892, r2893);
                                    ir_expression *const r28D0 = equal(r28CF, body.constant(0u));
                                    ir_if *f28CE = new(mem_ctx) ir_if(operand(r28D0).val);
                                    exec_list *const f28CE_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f28CE->then_instructions;

                                       body.emit(assign(r2891, body.constant(int(0)), 0x01));


                                    body.instructions = f28CE_parent_instructions;
                                    body.emit(f28CE);

                                    /* END IF */


                                 body.instructions = f28C3_parent_instructions;
                                 body.emit(f28C3);

                                 /* END IF */

                                 ir_variable *const r28D1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r28D1);
                                 ir_expression *const r28D2 = lshift(r251B, body.constant(int(31)));
                                 ir_expression *const r28D3 = expr(ir_unop_i2u, r2891);
                                 ir_expression *const r28D4 = lshift(r28D3, body.constant(int(20)));
                                 ir_expression *const r28D5 = add(r28D2, r28D4);
                                 body.emit(assign(r28D1, add(r28D5, r2892), 0x02));

                                 body.emit(assign(r28D1, r2893, 0x01));

                                 body.emit(assign(r2896, r28D1, 0x03));

                                 body.emit(assign(r2895, body.constant(false), 0x01));


                              body.instructions = f28C2_parent_instructions;
                              body.emit(f28C2);

                              /* END IF */

                              body.emit(assign(r251C, r2896, 0x03));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f284A->else_instructions;

                              ir_variable *const r28D6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r28D6);
                              body.emit(assign(r28D6, body.constant(0u), 0x02));

                              body.emit(assign(r28D6, body.constant(0u), 0x01));

                              body.emit(assign(r251C, r28D6, 0x03));


                           body.instructions = f284A_parent_instructions;
                           body.emit(f284A);

                           /* END IF */


                        body.instructions = f27BE_parent_instructions;
                        body.emit(f27BE);

                        /* END IF */


                     body.instructions = f2732_parent_instructions;
                     body.emit(f2732);

                     /* END IF */


                  body.instructions = f26A6_parent_instructions;
                  body.emit(f26A6);

                  /* END IF */


               body.instructions = f2691_parent_instructions;
               body.emit(f2691);

               /* END IF */


            body.instructions = f25E0_parent_instructions;
            body.emit(f25E0);

            /* END IF */


         body.instructions = f252D_parent_instructions;
         body.emit(f252D);

         /* END IF */

         body.emit(assign(r23BD, r251C, 0x03));


      body.instructions = f23BF_parent_instructions;
      body.emit(f23BF);

      /* END IF */

      body.emit(assign(r23BB, r23BD, 0x03));


   body.instructions = f23BC_parent_instructions;
   body.emit(f23BC);

   /* END IF */

   body.emit(ret(r23BB));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
ffract64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r28D7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r28D7);
   ir_variable *const r28D8 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r28D9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r28DA = rshift(swizzle_y(r28D7), body.constant(int(20)));
   ir_expression *const r28DB = bit_and(r28DA, body.constant(2047u));
   ir_expression *const r28DC = expr(ir_unop_u2i, r28DB);
   body.emit(assign(r28D9, add(r28DC, body.constant(int(-1023))), 0x01));

   /* IF CONDITION */
   ir_expression *const r28DE = less(r28D9, body.constant(int(0)));
   ir_if *f28DD = new(mem_ctx) ir_if(operand(r28DE).val);
   exec_list *const f28DD_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f28DD->then_instructions;

      body.emit(assign(r28D8, ir_constant::zero(mem_ctx, glsl_type::uvec2_type), 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f28DD->else_instructions;

      /* IF CONDITION */
      ir_expression *const r28E0 = greater(r28D9, body.constant(int(52)));
      ir_if *f28DF = new(mem_ctx) ir_if(operand(r28E0).val);
      exec_list *const f28DF_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f28DF->then_instructions;

         body.emit(assign(r28D8, r28D7, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f28DF->else_instructions;

         ir_variable *const r28E1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r28E1);
         ir_variable *const r28E2 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r28E2, sub(body.constant(int(52)), r28D9), 0x01));

         ir_variable *const r28E3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r28E5 = gequal(r28E2, body.constant(int(32)));
         ir_if *f28E4 = new(mem_ctx) ir_if(operand(r28E5).val);
         exec_list *const f28E4_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f28E4->then_instructions;

            body.emit(assign(r28E3, body.constant(0u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f28E4->else_instructions;

            body.emit(assign(r28E3, lshift(body.constant(4294967295u), r28E2), 0x01));


         body.instructions = f28E4_parent_instructions;
         body.emit(f28E4);

         /* END IF */

         ir_variable *const r28E6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r28E8 = less(r28E2, body.constant(int(33)));
         ir_if *f28E7 = new(mem_ctx) ir_if(operand(r28E8).val);
         exec_list *const f28E7_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f28E7->then_instructions;

            body.emit(assign(r28E6, body.constant(4294967295u), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f28E7->else_instructions;

            ir_expression *const r28E9 = add(r28E2, body.constant(int(-32)));
            body.emit(assign(r28E6, lshift(body.constant(4294967295u), r28E9), 0x01));


         body.instructions = f28E7_parent_instructions;
         body.emit(f28E7);

         /* END IF */

         body.emit(assign(r28E1, bit_and(r28E3, swizzle_x(r28D7)), 0x01));

         body.emit(assign(r28E1, bit_and(r28E6, swizzle_y(r28D7)), 0x02));

         body.emit(assign(r28D8, r28E1, 0x03));


      body.instructions = f28DF_parent_instructions;
      body.emit(f28DF);

      /* END IF */


   body.instructions = f28DD_parent_instructions;
   body.emit(f28DD);

   /* END IF */

   ir_variable *const r28EA = body.make_temp(glsl_type::bool_type, "assignment_tmp");
   ir_expression *const r28EB = rshift(swizzle_y(r28D7), body.constant(int(31)));
   ir_expression *const r28EC = expr(ir_unop_u2i, r28EB);
   body.emit(assign(r28EA, expr(ir_unop_i2b, r28EC), 0x01));

   ir_variable *const r28ED = body.make_temp(glsl_type::bool_type, "or_tmp");
   /* IF CONDITION */
   ir_expression *const r28EF = expr(ir_unop_logic_not, r28EA);
   ir_if *f28EE = new(mem_ctx) ir_if(operand(r28EF).val);
   exec_list *const f28EE_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f28EE->then_instructions;

      body.emit(assign(r28ED, body.constant(true), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f28EE->else_instructions;

      ir_variable *const r28F0 = body.make_temp(glsl_type::bool_type, "return_value");
      ir_variable *const r28F1 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
      body.emit(r28F1);
      ir_variable *const r28F2 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
      body.emit(r28F2);
      ir_variable *const r28F3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r28F3);
      body.emit(assign(r28F3, bit_and(swizzle_y(r28D7), body.constant(1048575u)), 0x02));

      body.emit(assign(r28F3, swizzle_x(r28D7), 0x01));

      ir_variable *const r28F4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r28F4);
      body.emit(assign(r28F4, bit_and(swizzle_y(r28D8), body.constant(1048575u)), 0x02));

      body.emit(assign(r28F4, swizzle_x(r28D8), 0x01));

      ir_expression *const r28F5 = rshift(swizzle_y(r28D7), body.constant(int(20)));
      ir_expression *const r28F6 = bit_and(r28F5, body.constant(2047u));
      ir_expression *const r28F7 = expr(ir_unop_u2i, r28F6);
      ir_expression *const r28F8 = equal(r28F7, body.constant(int(2047)));
      ir_expression *const r28F9 = bit_or(swizzle_y(r28F3), swizzle_x(r28D7));
      ir_expression *const r28FA = nequal(r28F9, body.constant(0u));
      body.emit(assign(r28F2, logic_and(r28F8, r28FA), 0x01));

      ir_expression *const r28FB = rshift(swizzle_y(r28D8), body.constant(int(20)));
      ir_expression *const r28FC = bit_and(r28FB, body.constant(2047u));
      ir_expression *const r28FD = expr(ir_unop_u2i, r28FC);
      ir_expression *const r28FE = equal(r28FD, body.constant(int(2047)));
      ir_expression *const r28FF = bit_or(swizzle_y(r28F4), swizzle_x(r28D8));
      ir_expression *const r2900 = nequal(r28FF, body.constant(0u));
      body.emit(assign(r28F1, logic_and(r28FE, r2900), 0x01));

      /* IF CONDITION */
      ir_expression *const r2902 = logic_or(r28F2, r28F1);
      ir_if *f2901 = new(mem_ctx) ir_if(operand(r2902).val);
      exec_list *const f2901_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f2901->then_instructions;

         body.emit(assign(r28F0, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f2901->else_instructions;

         ir_expression *const r2903 = equal(swizzle_x(r28D7), swizzle_x(r28D8));
         ir_expression *const r2904 = equal(swizzle_y(r28D7), swizzle_y(r28D8));
         ir_expression *const r2905 = equal(swizzle_x(r28D7), body.constant(0u));
         ir_expression *const r2906 = bit_or(swizzle_y(r28D7), swizzle_y(r28D8));
         ir_expression *const r2907 = lshift(r2906, body.constant(int(1)));
         ir_expression *const r2908 = equal(r2907, body.constant(0u));
         ir_expression *const r2909 = logic_and(r2905, r2908);
         ir_expression *const r290A = logic_or(r2904, r2909);
         body.emit(assign(r28F0, logic_and(r2903, r290A), 0x01));


      body.instructions = f2901_parent_instructions;
      body.emit(f2901);

      /* END IF */

      body.emit(assign(r28ED, r28F0, 0x01));


   body.instructions = f28EE_parent_instructions;
   body.emit(f28EE);

   /* END IF */

   ir_variable *const r290B = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
   /* IF CONDITION */
   ir_if *f290C = new(mem_ctx) ir_if(operand(r28ED).val);
   exec_list *const f290C_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f290C->then_instructions;

      body.emit(assign(r290B, r28D8, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f290C->else_instructions;

      ir_variable *const r290D = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r290E = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r290E, rshift(swizzle_y(r28D8), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r2910 = equal(r290E, body.constant(0u));
      ir_if *f290F = new(mem_ctx) ir_if(operand(r2910).val);
      exec_list *const f290F_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f290F->then_instructions;

         ir_variable *const r2911 = body.make_temp(glsl_type::uint_type, "zSign");
         body.emit(assign(r2911, r290E, 0x01));

         ir_variable *const r2912 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r2913 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r2913);
         ir_variable *const r2914 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
         body.emit(r2914);
         ir_variable *const r2915 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
         body.emit(r2915);
         ir_variable *const r2916 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
         body.emit(r2916);
         ir_variable *const r2917 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
         body.emit(r2917);
         ir_variable *const r2918 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r2918);
         ir_variable *const r2919 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
         body.emit(r2919);
         body.emit(assign(r2919, bit_and(swizzle_y(r28D8), body.constant(1048575u)), 0x02));

         body.emit(assign(r2919, swizzle_x(r28D8), 0x01));

         ir_variable *const r291A = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r291B = rshift(swizzle_y(r28D8), body.constant(int(20)));
         ir_expression *const r291C = bit_and(r291B, body.constant(2047u));
         body.emit(assign(r291A, expr(ir_unop_u2i, r291C), 0x01));

         body.emit(assign(r2916, r291A, 0x01));

         ir_variable *const r291D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
         body.emit(r291D);
         body.emit(assign(r291D, body.constant(0u), 0x02));

         body.emit(assign(r291D, body.constant(0u), 0x01));

         body.emit(assign(r2914, body.constant(int(1023)), 0x01));

         body.emit(assign(r2913, add(r291A, body.constant(int(-1023))), 0x01));

         ir_variable *const r291E = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r291E, lshift(swizzle_x(r28D8), body.constant(int(10))), 0x01));

         ir_variable *const r291F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         ir_expression *const r2920 = lshift(swizzle_y(r2919), body.constant(int(10)));
         ir_expression *const r2921 = rshift(swizzle_x(r28D8), body.constant(int(22)));
         body.emit(assign(r291F, bit_or(r2920, r2921), 0x01));

         body.emit(assign(r2917, r291F, 0x02));

         body.emit(assign(r2917, r291E, 0x01));

         ir_variable *const r2922 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         body.emit(assign(r2922, body.constant(0u), 0x01));

         body.emit(assign(r2915, r2922, 0x02));

         body.emit(assign(r2915, body.constant(0u), 0x01));

         /* IF CONDITION */
         ir_expression *const r2924 = less(body.constant(int(0)), r2913);
         ir_if *f2923 = new(mem_ctx) ir_if(operand(r2924).val);
         exec_list *const f2923_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2923->then_instructions;

            /* IF CONDITION */
            ir_expression *const r2926 = equal(r291A, body.constant(int(2047)));
            ir_if *f2925 = new(mem_ctx) ir_if(operand(r2926).val);
            exec_list *const f2925_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2925->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2928 = bit_or(r291F, r291E);
               ir_expression *const r2929 = nequal(r2928, body.constant(0u));
               ir_if *f2927 = new(mem_ctx) ir_if(operand(r2929).val);
               exec_list *const f2927_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2927->then_instructions;

                  ir_variable *const r292A = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r292A, swizzle_x(r28D8), 0x01));

                  ir_variable *const r292B = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r292B, body.constant(0u), 0x01));

                  ir_variable *const r292C = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r292A, bit_or(swizzle_y(r28D8), body.constant(524288u)), 0x02));

                  body.emit(assign(r292B, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r292E = lshift(swizzle_y(r28D8), body.constant(int(1)));
                  ir_expression *const r292F = lequal(body.constant(4292870144u), r292E);
                  ir_expression *const r2930 = nequal(swizzle_x(r28D8), body.constant(0u));
                  ir_expression *const r2931 = bit_and(swizzle_y(r28D8), body.constant(1048575u));
                  ir_expression *const r2932 = nequal(r2931, body.constant(0u));
                  ir_expression *const r2933 = logic_or(r2930, r2932);
                  ir_expression *const r2934 = logic_and(r292F, r2933);
                  ir_if *f292D = new(mem_ctx) ir_if(operand(r2934).val);
                  exec_list *const f292D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f292D->then_instructions;

                     body.emit(assign(r292C, r292A, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f292D->else_instructions;

                     body.emit(assign(r292C, r292B, 0x03));


                  body.instructions = f292D_parent_instructions;
                  body.emit(f292D);

                  /* END IF */

                  body.emit(assign(r2912, r292C, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2927->else_instructions;

                  body.emit(assign(r2912, r28D8, 0x03));


               body.instructions = f2927_parent_instructions;
               body.emit(f2927);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2925->else_instructions;

               body.emit(assign(r2915, body.constant(1073741824u), 0x02));

               ir_variable *const r2935 = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r2935, body.constant(1073741824u), 0x01));

               ir_variable *const r2936 = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r2936, body.constant(0u), 0x01));

               ir_variable *const r2937 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2937);
               ir_variable *const r2938 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2938);
               ir_variable *const r2939 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r293A = neg(r2913);
               body.emit(assign(r2939, bit_and(r293A, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r293C = equal(r2913, body.constant(int(0)));
               ir_if *f293B = new(mem_ctx) ir_if(operand(r293C).val);
               exec_list *const f293B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f293B->then_instructions;

                  body.emit(assign(r2937, r2936, 0x01));

                  body.emit(assign(r2938, r2935, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f293B->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r293E = less(r2913, body.constant(int(32)));
                  ir_if *f293D = new(mem_ctx) ir_if(operand(r293E).val);
                  exec_list *const f293D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f293D->then_instructions;

                     ir_expression *const r293F = lshift(body.constant(1073741824u), r2939);
                     ir_expression *const r2940 = bit_or(r293F, body.constant(0u));
                     body.emit(assign(r2937, bit_or(r2940, body.constant(0u)), 0x01));

                     body.emit(assign(r2938, rshift(body.constant(1073741824u), r2913), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f293D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2942 = equal(r2913, body.constant(int(32)));
                     ir_if *f2941 = new(mem_ctx) ir_if(operand(r2942).val);
                     exec_list *const f2941_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2941->then_instructions;

                        body.emit(assign(r2937, body.constant(1073741824u), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2941->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2944 = less(r2913, body.constant(int(64)));
                        ir_if *f2943 = new(mem_ctx) ir_if(operand(r2944).val);
                        exec_list *const f2943_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2943->then_instructions;

                           ir_expression *const r2945 = bit_and(r2913, body.constant(int(31)));
                           ir_expression *const r2946 = rshift(body.constant(1073741824u), r2945);
                           ir_expression *const r2947 = lshift(body.constant(1073741824u), r2939);
                           ir_expression *const r2948 = bit_or(r2947, body.constant(0u));
                           ir_expression *const r2949 = nequal(r2948, body.constant(0u));
                           ir_expression *const r294A = expr(ir_unop_b2i, r2949);
                           ir_expression *const r294B = expr(ir_unop_i2u, r294A);
                           body.emit(assign(r2937, bit_or(r2946, r294B), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2943->else_instructions;

                           body.emit(assign(r2937, body.constant(1u), 0x01));


                        body.instructions = f2943_parent_instructions;
                        body.emit(f2943);

                        /* END IF */


                     body.instructions = f2941_parent_instructions;
                     body.emit(f2941);

                     /* END IF */

                     body.emit(assign(r2938, body.constant(0u), 0x01));


                  body.instructions = f293D_parent_instructions;
                  body.emit(f293D);

                  /* END IF */


               body.instructions = f293B_parent_instructions;
               body.emit(f293B);

               /* END IF */

               body.emit(assign(r2915, r2938, 0x02));

               body.emit(assign(r2915, r2937, 0x01));

               body.emit(assign(r2917, bit_or(r291F, body.constant(1073741824u)), 0x02));

               ir_variable *const r294C = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r294D = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r294D, sub(r291E, r2937), 0x01));

               ir_expression *const r294E = sub(swizzle_y(r2917), r2938);
               ir_expression *const r294F = less(r291E, r2937);
               ir_expression *const r2950 = expr(ir_unop_b2i, r294F);
               ir_expression *const r2951 = expr(ir_unop_i2u, r2950);
               body.emit(assign(r294C, sub(r294E, r2951), 0x01));

               body.emit(assign(r2918, add(r291A, body.constant(int(-1))), 0x01));

               ir_variable *const r2952 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2952, add(r2918, body.constant(int(-10))), 0x01));

               ir_variable *const r2953 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2953, r294C, 0x01));

               ir_variable *const r2954 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2954, r294D, 0x01));

               ir_variable *const r2955 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r2955);
               ir_variable *const r2956 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r2956);
               /* IF CONDITION */
               ir_expression *const r2958 = equal(r294C, body.constant(0u));
               ir_if *f2957 = new(mem_ctx) ir_if(operand(r2958).val);
               exec_list *const f2957_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2957->then_instructions;

                  body.emit(assign(r2953, r294D, 0x01));

                  body.emit(assign(r2954, body.constant(0u), 0x01));

                  body.emit(assign(r2952, add(r2952, body.constant(int(-32))), 0x01));


               body.instructions = f2957_parent_instructions;
               body.emit(f2957);

               /* END IF */

               ir_variable *const r2959 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r2959, r2953, 0x01));

               ir_variable *const r295A = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r295B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r295B);
               /* IF CONDITION */
               ir_expression *const r295D = equal(r2953, body.constant(0u));
               ir_if *f295C = new(mem_ctx) ir_if(operand(r295D).val);
               exec_list *const f295C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f295C->then_instructions;

                  body.emit(assign(r295A, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f295C->else_instructions;

                  body.emit(assign(r295B, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r295F = bit_and(r2953, body.constant(4294901760u));
                  ir_expression *const r2960 = equal(r295F, body.constant(0u));
                  ir_if *f295E = new(mem_ctx) ir_if(operand(r2960).val);
                  exec_list *const f295E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f295E->then_instructions;

                     body.emit(assign(r295B, body.constant(int(16)), 0x01));

                     body.emit(assign(r2959, lshift(r2953, body.constant(int(16))), 0x01));


                  body.instructions = f295E_parent_instructions;
                  body.emit(f295E);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2962 = bit_and(r2959, body.constant(4278190080u));
                  ir_expression *const r2963 = equal(r2962, body.constant(0u));
                  ir_if *f2961 = new(mem_ctx) ir_if(operand(r2963).val);
                  exec_list *const f2961_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2961->then_instructions;

                     body.emit(assign(r295B, add(r295B, body.constant(int(8))), 0x01));

                     body.emit(assign(r2959, lshift(r2959, body.constant(int(8))), 0x01));


                  body.instructions = f2961_parent_instructions;
                  body.emit(f2961);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2965 = bit_and(r2959, body.constant(4026531840u));
                  ir_expression *const r2966 = equal(r2965, body.constant(0u));
                  ir_if *f2964 = new(mem_ctx) ir_if(operand(r2966).val);
                  exec_list *const f2964_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2964->then_instructions;

                     body.emit(assign(r295B, add(r295B, body.constant(int(4))), 0x01));

                     body.emit(assign(r2959, lshift(r2959, body.constant(int(4))), 0x01));


                  body.instructions = f2964_parent_instructions;
                  body.emit(f2964);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2968 = bit_and(r2959, body.constant(3221225472u));
                  ir_expression *const r2969 = equal(r2968, body.constant(0u));
                  ir_if *f2967 = new(mem_ctx) ir_if(operand(r2969).val);
                  exec_list *const f2967_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2967->then_instructions;

                     body.emit(assign(r295B, add(r295B, body.constant(int(2))), 0x01));

                     body.emit(assign(r2959, lshift(r2959, body.constant(int(2))), 0x01));


                  body.instructions = f2967_parent_instructions;
                  body.emit(f2967);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r296B = bit_and(r2959, body.constant(2147483648u));
                  ir_expression *const r296C = equal(r296B, body.constant(0u));
                  ir_if *f296A = new(mem_ctx) ir_if(operand(r296C).val);
                  exec_list *const f296A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f296A->then_instructions;

                     body.emit(assign(r295B, add(r295B, body.constant(int(1))), 0x01));


                  body.instructions = f296A_parent_instructions;
                  body.emit(f296A);

                  /* END IF */

                  body.emit(assign(r295A, r295B, 0x01));


               body.instructions = f295C_parent_instructions;
               body.emit(f295C);

               /* END IF */

               body.emit(assign(r2956, add(r295A, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r296E = lequal(body.constant(int(0)), r2956);
               ir_if *f296D = new(mem_ctx) ir_if(operand(r296E).val);
               exec_list *const f296D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f296D->then_instructions;

                  body.emit(assign(r2955, body.constant(0u), 0x01));

                  ir_variable *const r296F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r296F, lshift(r2954, r2956), 0x01));

                  ir_variable *const r2970 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2972 = equal(r2956, body.constant(int(0)));
                  ir_if *f2971 = new(mem_ctx) ir_if(operand(r2972).val);
                  exec_list *const f2971_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2971->then_instructions;

                     body.emit(assign(r2970, r2953, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2971->else_instructions;

                     ir_expression *const r2973 = lshift(r2953, r2956);
                     ir_expression *const r2974 = neg(r2956);
                     ir_expression *const r2975 = bit_and(r2974, body.constant(int(31)));
                     ir_expression *const r2976 = rshift(r2954, r2975);
                     body.emit(assign(r2970, bit_or(r2973, r2976), 0x01));


                  body.instructions = f2971_parent_instructions;
                  body.emit(f2971);

                  /* END IF */

                  body.emit(assign(r2953, r2970, 0x01));

                  body.emit(assign(r2954, r296F, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f296D->else_instructions;

                  ir_variable *const r2977 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r2977, body.constant(0u), 0x01));

                  ir_variable *const r2978 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r2978, neg(r2956), 0x01));

                  ir_variable *const r2979 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r2979);
                  ir_variable *const r297A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r297A);
                  ir_variable *const r297B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r297B);
                  ir_variable *const r297C = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r297D = neg(r2978);
                  body.emit(assign(r297C, bit_and(r297D, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r297F = equal(r2978, body.constant(int(0)));
                  ir_if *f297E = new(mem_ctx) ir_if(operand(r297F).val);
                  exec_list *const f297E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f297E->then_instructions;

                     body.emit(assign(r2979, r2977, 0x01));

                     body.emit(assign(r297A, r2954, 0x01));

                     body.emit(assign(r297B, r2953, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f297E->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2981 = less(r2978, body.constant(int(32)));
                     ir_if *f2980 = new(mem_ctx) ir_if(operand(r2981).val);
                     exec_list *const f2980_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2980->then_instructions;

                        body.emit(assign(r2979, lshift(r2954, r297C), 0x01));

                        ir_expression *const r2982 = lshift(r2953, r297C);
                        ir_expression *const r2983 = rshift(r2954, r2978);
                        body.emit(assign(r297A, bit_or(r2982, r2983), 0x01));

                        body.emit(assign(r297B, rshift(r2953, r2978), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2980->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2985 = equal(r2978, body.constant(int(32)));
                        ir_if *f2984 = new(mem_ctx) ir_if(operand(r2985).val);
                        exec_list *const f2984_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2984->then_instructions;

                           body.emit(assign(r2979, r2954, 0x01));

                           body.emit(assign(r297A, r2953, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2984->else_instructions;

                           body.emit(assign(r2977, bit_or(body.constant(0u), r2954), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2987 = less(r2978, body.constant(int(64)));
                           ir_if *f2986 = new(mem_ctx) ir_if(operand(r2987).val);
                           exec_list *const f2986_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2986->then_instructions;

                              body.emit(assign(r2979, lshift(r2953, r297C), 0x01));

                              ir_expression *const r2988 = bit_and(r2978, body.constant(int(31)));
                              body.emit(assign(r297A, rshift(r2953, r2988), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2986->else_instructions;

                              ir_variable *const r2989 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r298B = equal(r2978, body.constant(int(64)));
                              ir_if *f298A = new(mem_ctx) ir_if(operand(r298B).val);
                              exec_list *const f298A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f298A->then_instructions;

                                 body.emit(assign(r2989, r2953, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f298A->else_instructions;

                                 ir_expression *const r298C = nequal(r2953, body.constant(0u));
                                 ir_expression *const r298D = expr(ir_unop_b2i, r298C);
                                 body.emit(assign(r2989, expr(ir_unop_i2u, r298D), 0x01));


                              body.instructions = f298A_parent_instructions;
                              body.emit(f298A);

                              /* END IF */

                              body.emit(assign(r2979, r2989, 0x01));

                              body.emit(assign(r297A, body.constant(0u), 0x01));


                           body.instructions = f2986_parent_instructions;
                           body.emit(f2986);

                           /* END IF */


                        body.instructions = f2984_parent_instructions;
                        body.emit(f2984);

                        /* END IF */

                        body.emit(assign(r297B, body.constant(0u), 0x01));


                     body.instructions = f2980_parent_instructions;
                     body.emit(f2980);

                     /* END IF */

                     ir_expression *const r298E = nequal(r2977, body.constant(0u));
                     ir_expression *const r298F = expr(ir_unop_b2i, r298E);
                     ir_expression *const r2990 = expr(ir_unop_i2u, r298F);
                     body.emit(assign(r2979, bit_or(r2979, r2990), 0x01));


                  body.instructions = f297E_parent_instructions;
                  body.emit(f297E);

                  /* END IF */

                  body.emit(assign(r2953, r297B, 0x01));

                  body.emit(assign(r2954, r297A, 0x01));

                  body.emit(assign(r2955, r2979, 0x01));


               body.instructions = f296D_parent_instructions;
               body.emit(f296D);

               /* END IF */

               body.emit(assign(r2952, sub(r2952, r2956), 0x01));

               ir_variable *const r2991 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2991, r2952, 0x01));

               ir_variable *const r2992 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2992, r2953, 0x01));

               ir_variable *const r2993 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2993, r2954, 0x01));

               ir_variable *const r2994 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r2994, r2955, 0x01));

               ir_variable *const r2995 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r2995, body.constant(true), 0x01));

               ir_variable *const r2996 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2997 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2997);
               ir_expression *const r2998 = expr(ir_unop_u2i, r2955);
               body.emit(assign(r2997, less(r2998, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r299A = lequal(body.constant(int(2045)), r2952);
               ir_if *f2999 = new(mem_ctx) ir_if(operand(r299A).val);
               exec_list *const f2999_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2999->then_instructions;

                  ir_variable *const r299B = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r299D = less(body.constant(int(2045)), r2952);
                  ir_if *f299C = new(mem_ctx) ir_if(operand(r299D).val);
                  exec_list *const f299C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f299C->then_instructions;

                     body.emit(assign(r299B, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f299C->else_instructions;

                     ir_variable *const r299E = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r29A0 = equal(r2952, body.constant(int(2045)));
                     ir_if *f299F = new(mem_ctx) ir_if(operand(r29A0).val);
                     exec_list *const f299F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f299F->then_instructions;

                        ir_expression *const r29A1 = equal(body.constant(2097151u), r2953);
                        ir_expression *const r29A2 = equal(body.constant(4294967295u), r2954);
                        body.emit(assign(r299E, logic_and(r29A1, r29A2), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f299F->else_instructions;

                        body.emit(assign(r299E, body.constant(false), 0x01));


                     body.instructions = f299F_parent_instructions;
                     body.emit(f299F);

                     /* END IF */

                     body.emit(assign(r299B, logic_and(r299E, r2997), 0x01));


                  body.instructions = f299C_parent_instructions;
                  body.emit(f299C);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f29A3 = new(mem_ctx) ir_if(operand(r299B).val);
                  exec_list *const f29A3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f29A3->then_instructions;

                     ir_variable *const r29A4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r29A4);
                     ir_expression *const r29A5 = lshift(r290E, body.constant(int(31)));
                     body.emit(assign(r29A4, add(r29A5, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r29A4, body.constant(0u), 0x01));

                     body.emit(assign(r2996, r29A4, 0x03));

                     body.emit(assign(r2995, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f29A3->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r29A7 = less(r2952, body.constant(int(0)));
                     ir_if *f29A6 = new(mem_ctx) ir_if(operand(r29A7).val);
                     exec_list *const f29A6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f29A6->then_instructions;

                        ir_variable *const r29A8 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r29A8, r2955, 0x01));

                        ir_variable *const r29A9 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r29A9, neg(r2952), 0x01));

                        ir_variable *const r29AA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r29AA);
                        ir_variable *const r29AB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r29AB);
                        ir_variable *const r29AC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r29AC);
                        ir_variable *const r29AD = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r29AE = neg(r29A9);
                        body.emit(assign(r29AD, bit_and(r29AE, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r29B0 = equal(r29A9, body.constant(int(0)));
                        ir_if *f29AF = new(mem_ctx) ir_if(operand(r29B0).val);
                        exec_list *const f29AF_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f29AF->then_instructions;

                           body.emit(assign(r29AA, r2955, 0x01));

                           body.emit(assign(r29AB, r2954, 0x01));

                           body.emit(assign(r29AC, r2953, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f29AF->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r29B2 = less(r29A9, body.constant(int(32)));
                           ir_if *f29B1 = new(mem_ctx) ir_if(operand(r29B2).val);
                           exec_list *const f29B1_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f29B1->then_instructions;

                              body.emit(assign(r29AA, lshift(r2954, r29AD), 0x01));

                              ir_expression *const r29B3 = lshift(r2953, r29AD);
                              ir_expression *const r29B4 = rshift(r2954, r29A9);
                              body.emit(assign(r29AB, bit_or(r29B3, r29B4), 0x01));

                              body.emit(assign(r29AC, rshift(r2953, r29A9), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f29B1->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r29B6 = equal(r29A9, body.constant(int(32)));
                              ir_if *f29B5 = new(mem_ctx) ir_if(operand(r29B6).val);
                              exec_list *const f29B5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f29B5->then_instructions;

                                 body.emit(assign(r29AA, r2954, 0x01));

                                 body.emit(assign(r29AB, r2953, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f29B5->else_instructions;

                                 body.emit(assign(r29A8, bit_or(r2955, r2954), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r29B8 = less(r29A9, body.constant(int(64)));
                                 ir_if *f29B7 = new(mem_ctx) ir_if(operand(r29B8).val);
                                 exec_list *const f29B7_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f29B7->then_instructions;

                                    body.emit(assign(r29AA, lshift(r2953, r29AD), 0x01));

                                    ir_expression *const r29B9 = bit_and(r29A9, body.constant(int(31)));
                                    body.emit(assign(r29AB, rshift(r2953, r29B9), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f29B7->else_instructions;

                                    ir_variable *const r29BA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r29BC = equal(r29A9, body.constant(int(64)));
                                    ir_if *f29BB = new(mem_ctx) ir_if(operand(r29BC).val);
                                    exec_list *const f29BB_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f29BB->then_instructions;

                                       body.emit(assign(r29BA, r2953, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f29BB->else_instructions;

                                       ir_expression *const r29BD = nequal(r2953, body.constant(0u));
                                       ir_expression *const r29BE = expr(ir_unop_b2i, r29BD);
                                       body.emit(assign(r29BA, expr(ir_unop_i2u, r29BE), 0x01));


                                    body.instructions = f29BB_parent_instructions;
                                    body.emit(f29BB);

                                    /* END IF */

                                    body.emit(assign(r29AA, r29BA, 0x01));

                                    body.emit(assign(r29AB, body.constant(0u), 0x01));


                                 body.instructions = f29B7_parent_instructions;
                                 body.emit(f29B7);

                                 /* END IF */


                              body.instructions = f29B5_parent_instructions;
                              body.emit(f29B5);

                              /* END IF */

                              body.emit(assign(r29AC, body.constant(0u), 0x01));


                           body.instructions = f29B1_parent_instructions;
                           body.emit(f29B1);

                           /* END IF */

                           ir_expression *const r29BF = nequal(r29A8, body.constant(0u));
                           ir_expression *const r29C0 = expr(ir_unop_b2i, r29BF);
                           ir_expression *const r29C1 = expr(ir_unop_i2u, r29C0);
                           body.emit(assign(r29AA, bit_or(r29AA, r29C1), 0x01));


                        body.instructions = f29AF_parent_instructions;
                        body.emit(f29AF);

                        /* END IF */

                        body.emit(assign(r2992, r29AC, 0x01));

                        body.emit(assign(r2993, r29AB, 0x01));

                        body.emit(assign(r2994, r29AA, 0x01));

                        body.emit(assign(r2991, body.constant(int(0)), 0x01));

                        body.emit(assign(r2997, less(r29AA, body.constant(0u)), 0x01));


                     body.instructions = f29A6_parent_instructions;
                     body.emit(f29A6);

                     /* END IF */


                  body.instructions = f29A3_parent_instructions;
                  body.emit(f29A3);

                  /* END IF */


               body.instructions = f2999_parent_instructions;
               body.emit(f2999);

               /* END IF */

               /* IF CONDITION */
               ir_if *f29C2 = new(mem_ctx) ir_if(operand(r2995).val);
               exec_list *const f29C2_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f29C2->then_instructions;

                  /* IF CONDITION */
                  ir_if *f29C3 = new(mem_ctx) ir_if(operand(r2997).val);
                  exec_list *const f29C3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f29C3->then_instructions;

                     ir_variable *const r29C4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r29C4, add(r2993, body.constant(1u)), 0x01));

                     ir_expression *const r29C5 = less(r29C4, r2993);
                     ir_expression *const r29C6 = expr(ir_unop_b2i, r29C5);
                     ir_expression *const r29C7 = expr(ir_unop_i2u, r29C6);
                     body.emit(assign(r2992, add(r2992, r29C7), 0x01));

                     ir_expression *const r29C8 = equal(r2994, body.constant(0u));
                     ir_expression *const r29C9 = expr(ir_unop_b2i, r29C8);
                     ir_expression *const r29CA = expr(ir_unop_i2u, r29C9);
                     ir_expression *const r29CB = add(r2994, r29CA);
                     ir_expression *const r29CC = bit_and(r29CB, body.constant(1u));
                     ir_expression *const r29CD = expr(ir_unop_bit_not, r29CC);
                     body.emit(assign(r2993, bit_and(r29C4, r29CD), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f29C3->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r29CF = bit_or(r2992, r2993);
                     ir_expression *const r29D0 = equal(r29CF, body.constant(0u));
                     ir_if *f29CE = new(mem_ctx) ir_if(operand(r29D0).val);
                     exec_list *const f29CE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f29CE->then_instructions;

                        body.emit(assign(r2991, body.constant(int(0)), 0x01));


                     body.instructions = f29CE_parent_instructions;
                     body.emit(f29CE);

                     /* END IF */


                  body.instructions = f29C3_parent_instructions;
                  body.emit(f29C3);

                  /* END IF */

                  ir_variable *const r29D1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r29D1);
                  ir_expression *const r29D2 = lshift(r290E, body.constant(int(31)));
                  ir_expression *const r29D3 = expr(ir_unop_i2u, r2991);
                  ir_expression *const r29D4 = lshift(r29D3, body.constant(int(20)));
                  ir_expression *const r29D5 = add(r29D2, r29D4);
                  body.emit(assign(r29D1, add(r29D5, r2992), 0x02));

                  body.emit(assign(r29D1, r2993, 0x01));

                  body.emit(assign(r2996, r29D1, 0x03));

                  body.emit(assign(r2995, body.constant(false), 0x01));


               body.instructions = f29C2_parent_instructions;
               body.emit(f29C2);

               /* END IF */

               body.emit(assign(r2912, r2996, 0x03));


            body.instructions = f2925_parent_instructions;
            body.emit(f2925);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2923->else_instructions;

            /* IF CONDITION */
            ir_expression *const r29D7 = less(r2913, body.constant(int(0)));
            ir_if *f29D6 = new(mem_ctx) ir_if(operand(r29D7).val);
            exec_list *const f29D6_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f29D6->then_instructions;

               /* IF CONDITION */
               ir_expression *const r29D9 = equal(r291A, body.constant(int(0)));
               ir_if *f29D8 = new(mem_ctx) ir_if(operand(r29D9).val);
               exec_list *const f29D8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f29D8->then_instructions;

                  body.emit(assign(r2913, add(r2913, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f29D8->else_instructions;

                  body.emit(assign(r2917, bit_or(swizzle_y(r2917), body.constant(1073741824u)), 0x02));


               body.instructions = f29D8_parent_instructions;
               body.emit(f29D8);

               /* END IF */

               ir_variable *const r29DA = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r29DA, swizzle_y(r2917), 0x01));

               ir_variable *const r29DB = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r29DB, swizzle_x(r2917), 0x01));

               ir_variable *const r29DC = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r29DC, neg(r2913), 0x01));

               ir_variable *const r29DD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r29DD);
               ir_variable *const r29DE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r29DE);
               ir_variable *const r29DF = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r29E0 = neg(r29DC);
               body.emit(assign(r29DF, bit_and(r29E0, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r29E2 = equal(r29DC, body.constant(int(0)));
               ir_if *f29E1 = new(mem_ctx) ir_if(operand(r29E2).val);
               exec_list *const f29E1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f29E1->then_instructions;

                  body.emit(assign(r29DD, r29DB, 0x01));

                  body.emit(assign(r29DE, r29DA, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f29E1->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r29E4 = less(r29DC, body.constant(int(32)));
                  ir_if *f29E3 = new(mem_ctx) ir_if(operand(r29E4).val);
                  exec_list *const f29E3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f29E3->then_instructions;

                     ir_expression *const r29E5 = lshift(swizzle_y(r2917), r29DF);
                     ir_expression *const r29E6 = rshift(r291E, r29DC);
                     ir_expression *const r29E7 = bit_or(r29E5, r29E6);
                     ir_expression *const r29E8 = lshift(r291E, r29DF);
                     ir_expression *const r29E9 = nequal(r29E8, body.constant(0u));
                     ir_expression *const r29EA = expr(ir_unop_b2i, r29E9);
                     ir_expression *const r29EB = expr(ir_unop_i2u, r29EA);
                     body.emit(assign(r29DD, bit_or(r29E7, r29EB), 0x01));

                     body.emit(assign(r29DE, rshift(swizzle_y(r2917), r29DC), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f29E3->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r29ED = equal(r29DC, body.constant(int(32)));
                     ir_if *f29EC = new(mem_ctx) ir_if(operand(r29ED).val);
                     exec_list *const f29EC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f29EC->then_instructions;

                        ir_expression *const r29EE = nequal(r291E, body.constant(0u));
                        ir_expression *const r29EF = expr(ir_unop_b2i, r29EE);
                        ir_expression *const r29F0 = expr(ir_unop_i2u, r29EF);
                        body.emit(assign(r29DD, bit_or(swizzle_y(r2917), r29F0), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f29EC->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r29F2 = less(r29DC, body.constant(int(64)));
                        ir_if *f29F1 = new(mem_ctx) ir_if(operand(r29F2).val);
                        exec_list *const f29F1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f29F1->then_instructions;

                           ir_expression *const r29F3 = bit_and(r29DC, body.constant(int(31)));
                           ir_expression *const r29F4 = rshift(swizzle_y(r2917), r29F3);
                           ir_expression *const r29F5 = lshift(swizzle_y(r2917), r29DF);
                           ir_expression *const r29F6 = bit_or(r29F5, r291E);
                           ir_expression *const r29F7 = nequal(r29F6, body.constant(0u));
                           ir_expression *const r29F8 = expr(ir_unop_b2i, r29F7);
                           ir_expression *const r29F9 = expr(ir_unop_i2u, r29F8);
                           body.emit(assign(r29DD, bit_or(r29F4, r29F9), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f29F1->else_instructions;

                           ir_expression *const r29FA = bit_or(swizzle_y(r2917), r291E);
                           ir_expression *const r29FB = nequal(r29FA, body.constant(0u));
                           ir_expression *const r29FC = expr(ir_unop_b2i, r29FB);
                           body.emit(assign(r29DD, expr(ir_unop_i2u, r29FC), 0x01));


                        body.instructions = f29F1_parent_instructions;
                        body.emit(f29F1);

                        /* END IF */


                     body.instructions = f29EC_parent_instructions;
                     body.emit(f29EC);

                     /* END IF */

                     body.emit(assign(r29DE, body.constant(0u), 0x01));


                  body.instructions = f29E3_parent_instructions;
                  body.emit(f29E3);

                  /* END IF */


               body.instructions = f29E1_parent_instructions;
               body.emit(f29E1);

               /* END IF */

               body.emit(assign(r2917, r29DE, 0x02));

               body.emit(assign(r2917, r29DD, 0x01));

               body.emit(assign(r2915, bit_or(swizzle_y(r2915), body.constant(1073741824u)), 0x02));

               ir_variable *const r29FD = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r29FE = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r29FE, sub(swizzle_x(r2915), r29DD), 0x01));

               ir_expression *const r29FF = sub(swizzle_y(r2915), r29DE);
               ir_expression *const r2A00 = less(swizzle_x(r2915), r29DD);
               ir_expression *const r2A01 = expr(ir_unop_b2i, r2A00);
               ir_expression *const r2A02 = expr(ir_unop_i2u, r2A01);
               body.emit(assign(r29FD, sub(r29FF, r2A02), 0x01));

               body.emit(assign(r2911, bit_xor(r290E, body.constant(1u)), 0x01));

               body.emit(assign(r2918, body.constant(int(1022)), 0x01));

               ir_variable *const r2A03 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2A03, body.constant(int(1012)), 0x01));

               ir_variable *const r2A04 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2A04, r29FD, 0x01));

               ir_variable *const r2A05 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2A05, r29FE, 0x01));

               ir_variable *const r2A06 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r2A06);
               ir_variable *const r2A07 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r2A07);
               /* IF CONDITION */
               ir_expression *const r2A09 = equal(r29FD, body.constant(0u));
               ir_if *f2A08 = new(mem_ctx) ir_if(operand(r2A09).val);
               exec_list *const f2A08_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2A08->then_instructions;

                  body.emit(assign(r2A04, r29FE, 0x01));

                  body.emit(assign(r2A05, body.constant(0u), 0x01));

                  body.emit(assign(r2A03, body.constant(int(980)), 0x01));


               body.instructions = f2A08_parent_instructions;
               body.emit(f2A08);

               /* END IF */

               ir_variable *const r2A0A = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r2A0A, r2A04, 0x01));

               ir_variable *const r2A0B = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r2A0C = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r2A0C);
               /* IF CONDITION */
               ir_expression *const r2A0E = equal(r2A04, body.constant(0u));
               ir_if *f2A0D = new(mem_ctx) ir_if(operand(r2A0E).val);
               exec_list *const f2A0D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2A0D->then_instructions;

                  body.emit(assign(r2A0B, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2A0D->else_instructions;

                  body.emit(assign(r2A0C, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2A10 = bit_and(r2A04, body.constant(4294901760u));
                  ir_expression *const r2A11 = equal(r2A10, body.constant(0u));
                  ir_if *f2A0F = new(mem_ctx) ir_if(operand(r2A11).val);
                  exec_list *const f2A0F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2A0F->then_instructions;

                     body.emit(assign(r2A0C, body.constant(int(16)), 0x01));

                     body.emit(assign(r2A0A, lshift(r2A04, body.constant(int(16))), 0x01));


                  body.instructions = f2A0F_parent_instructions;
                  body.emit(f2A0F);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2A13 = bit_and(r2A0A, body.constant(4278190080u));
                  ir_expression *const r2A14 = equal(r2A13, body.constant(0u));
                  ir_if *f2A12 = new(mem_ctx) ir_if(operand(r2A14).val);
                  exec_list *const f2A12_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2A12->then_instructions;

                     body.emit(assign(r2A0C, add(r2A0C, body.constant(int(8))), 0x01));

                     body.emit(assign(r2A0A, lshift(r2A0A, body.constant(int(8))), 0x01));


                  body.instructions = f2A12_parent_instructions;
                  body.emit(f2A12);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2A16 = bit_and(r2A0A, body.constant(4026531840u));
                  ir_expression *const r2A17 = equal(r2A16, body.constant(0u));
                  ir_if *f2A15 = new(mem_ctx) ir_if(operand(r2A17).val);
                  exec_list *const f2A15_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2A15->then_instructions;

                     body.emit(assign(r2A0C, add(r2A0C, body.constant(int(4))), 0x01));

                     body.emit(assign(r2A0A, lshift(r2A0A, body.constant(int(4))), 0x01));


                  body.instructions = f2A15_parent_instructions;
                  body.emit(f2A15);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2A19 = bit_and(r2A0A, body.constant(3221225472u));
                  ir_expression *const r2A1A = equal(r2A19, body.constant(0u));
                  ir_if *f2A18 = new(mem_ctx) ir_if(operand(r2A1A).val);
                  exec_list *const f2A18_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2A18->then_instructions;

                     body.emit(assign(r2A0C, add(r2A0C, body.constant(int(2))), 0x01));

                     body.emit(assign(r2A0A, lshift(r2A0A, body.constant(int(2))), 0x01));


                  body.instructions = f2A18_parent_instructions;
                  body.emit(f2A18);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2A1C = bit_and(r2A0A, body.constant(2147483648u));
                  ir_expression *const r2A1D = equal(r2A1C, body.constant(0u));
                  ir_if *f2A1B = new(mem_ctx) ir_if(operand(r2A1D).val);
                  exec_list *const f2A1B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2A1B->then_instructions;

                     body.emit(assign(r2A0C, add(r2A0C, body.constant(int(1))), 0x01));


                  body.instructions = f2A1B_parent_instructions;
                  body.emit(f2A1B);

                  /* END IF */

                  body.emit(assign(r2A0B, r2A0C, 0x01));


               body.instructions = f2A0D_parent_instructions;
               body.emit(f2A0D);

               /* END IF */

               body.emit(assign(r2A07, add(r2A0B, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2A1F = lequal(body.constant(int(0)), r2A07);
               ir_if *f2A1E = new(mem_ctx) ir_if(operand(r2A1F).val);
               exec_list *const f2A1E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2A1E->then_instructions;

                  body.emit(assign(r2A06, body.constant(0u), 0x01));

                  ir_variable *const r2A20 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r2A20, lshift(r2A05, r2A07), 0x01));

                  ir_variable *const r2A21 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2A23 = equal(r2A07, body.constant(int(0)));
                  ir_if *f2A22 = new(mem_ctx) ir_if(operand(r2A23).val);
                  exec_list *const f2A22_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2A22->then_instructions;

                     body.emit(assign(r2A21, r2A04, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2A22->else_instructions;

                     ir_expression *const r2A24 = lshift(r2A04, r2A07);
                     ir_expression *const r2A25 = neg(r2A07);
                     ir_expression *const r2A26 = bit_and(r2A25, body.constant(int(31)));
                     ir_expression *const r2A27 = rshift(r2A05, r2A26);
                     body.emit(assign(r2A21, bit_or(r2A24, r2A27), 0x01));


                  body.instructions = f2A22_parent_instructions;
                  body.emit(f2A22);

                  /* END IF */

                  body.emit(assign(r2A04, r2A21, 0x01));

                  body.emit(assign(r2A05, r2A20, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2A1E->else_instructions;

                  ir_variable *const r2A28 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r2A28, body.constant(0u), 0x01));

                  ir_variable *const r2A29 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r2A29, neg(r2A07), 0x01));

                  ir_variable *const r2A2A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r2A2A);
                  ir_variable *const r2A2B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r2A2B);
                  ir_variable *const r2A2C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r2A2C);
                  ir_variable *const r2A2D = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r2A2E = neg(r2A29);
                  body.emit(assign(r2A2D, bit_and(r2A2E, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2A30 = equal(r2A29, body.constant(int(0)));
                  ir_if *f2A2F = new(mem_ctx) ir_if(operand(r2A30).val);
                  exec_list *const f2A2F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2A2F->then_instructions;

                     body.emit(assign(r2A2A, r2A28, 0x01));

                     body.emit(assign(r2A2B, r2A05, 0x01));

                     body.emit(assign(r2A2C, r2A04, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2A2F->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2A32 = less(r2A29, body.constant(int(32)));
                     ir_if *f2A31 = new(mem_ctx) ir_if(operand(r2A32).val);
                     exec_list *const f2A31_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2A31->then_instructions;

                        body.emit(assign(r2A2A, lshift(r2A05, r2A2D), 0x01));

                        ir_expression *const r2A33 = lshift(r2A04, r2A2D);
                        ir_expression *const r2A34 = rshift(r2A05, r2A29);
                        body.emit(assign(r2A2B, bit_or(r2A33, r2A34), 0x01));

                        body.emit(assign(r2A2C, rshift(r2A04, r2A29), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2A31->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2A36 = equal(r2A29, body.constant(int(32)));
                        ir_if *f2A35 = new(mem_ctx) ir_if(operand(r2A36).val);
                        exec_list *const f2A35_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2A35->then_instructions;

                           body.emit(assign(r2A2A, r2A05, 0x01));

                           body.emit(assign(r2A2B, r2A04, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2A35->else_instructions;

                           body.emit(assign(r2A28, bit_or(body.constant(0u), r2A05), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2A38 = less(r2A29, body.constant(int(64)));
                           ir_if *f2A37 = new(mem_ctx) ir_if(operand(r2A38).val);
                           exec_list *const f2A37_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2A37->then_instructions;

                              body.emit(assign(r2A2A, lshift(r2A04, r2A2D), 0x01));

                              ir_expression *const r2A39 = bit_and(r2A29, body.constant(int(31)));
                              body.emit(assign(r2A2B, rshift(r2A04, r2A39), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2A37->else_instructions;

                              ir_variable *const r2A3A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2A3C = equal(r2A29, body.constant(int(64)));
                              ir_if *f2A3B = new(mem_ctx) ir_if(operand(r2A3C).val);
                              exec_list *const f2A3B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A3B->then_instructions;

                                 body.emit(assign(r2A3A, r2A04, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2A3B->else_instructions;

                                 ir_expression *const r2A3D = nequal(r2A04, body.constant(0u));
                                 ir_expression *const r2A3E = expr(ir_unop_b2i, r2A3D);
                                 body.emit(assign(r2A3A, expr(ir_unop_i2u, r2A3E), 0x01));


                              body.instructions = f2A3B_parent_instructions;
                              body.emit(f2A3B);

                              /* END IF */

                              body.emit(assign(r2A2A, r2A3A, 0x01));

                              body.emit(assign(r2A2B, body.constant(0u), 0x01));


                           body.instructions = f2A37_parent_instructions;
                           body.emit(f2A37);

                           /* END IF */


                        body.instructions = f2A35_parent_instructions;
                        body.emit(f2A35);

                        /* END IF */

                        body.emit(assign(r2A2C, body.constant(0u), 0x01));


                     body.instructions = f2A31_parent_instructions;
                     body.emit(f2A31);

                     /* END IF */

                     ir_expression *const r2A3F = nequal(r2A28, body.constant(0u));
                     ir_expression *const r2A40 = expr(ir_unop_b2i, r2A3F);
                     ir_expression *const r2A41 = expr(ir_unop_i2u, r2A40);
                     body.emit(assign(r2A2A, bit_or(r2A2A, r2A41), 0x01));


                  body.instructions = f2A2F_parent_instructions;
                  body.emit(f2A2F);

                  /* END IF */

                  body.emit(assign(r2A04, r2A2C, 0x01));

                  body.emit(assign(r2A05, r2A2B, 0x01));

                  body.emit(assign(r2A06, r2A2A, 0x01));


               body.instructions = f2A1E_parent_instructions;
               body.emit(f2A1E);

               /* END IF */

               body.emit(assign(r2A03, sub(r2A03, r2A07), 0x01));

               ir_variable *const r2A42 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2A42, r2A03, 0x01));

               ir_variable *const r2A43 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2A43, r2A04, 0x01));

               ir_variable *const r2A44 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2A44, r2A05, 0x01));

               ir_variable *const r2A45 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r2A45, r2A06, 0x01));

               ir_variable *const r2A46 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r2A46, body.constant(true), 0x01));

               ir_variable *const r2A47 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2A48 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2A48);
               ir_expression *const r2A49 = expr(ir_unop_u2i, r2A06);
               body.emit(assign(r2A48, less(r2A49, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2A4B = lequal(body.constant(int(2045)), r2A03);
               ir_if *f2A4A = new(mem_ctx) ir_if(operand(r2A4B).val);
               exec_list *const f2A4A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2A4A->then_instructions;

                  ir_variable *const r2A4C = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2A4E = less(body.constant(int(2045)), r2A03);
                  ir_if *f2A4D = new(mem_ctx) ir_if(operand(r2A4E).val);
                  exec_list *const f2A4D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2A4D->then_instructions;

                     body.emit(assign(r2A4C, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2A4D->else_instructions;

                     ir_variable *const r2A4F = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2A51 = equal(r2A03, body.constant(int(2045)));
                     ir_if *f2A50 = new(mem_ctx) ir_if(operand(r2A51).val);
                     exec_list *const f2A50_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2A50->then_instructions;

                        ir_expression *const r2A52 = equal(body.constant(2097151u), r2A04);
                        ir_expression *const r2A53 = equal(body.constant(4294967295u), r2A05);
                        body.emit(assign(r2A4F, logic_and(r2A52, r2A53), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2A50->else_instructions;

                        body.emit(assign(r2A4F, body.constant(false), 0x01));


                     body.instructions = f2A50_parent_instructions;
                     body.emit(f2A50);

                     /* END IF */

                     body.emit(assign(r2A4C, logic_and(r2A4F, r2A48), 0x01));


                  body.instructions = f2A4D_parent_instructions;
                  body.emit(f2A4D);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2A54 = new(mem_ctx) ir_if(operand(r2A4C).val);
                  exec_list *const f2A54_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2A54->then_instructions;

                     ir_variable *const r2A55 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2A55);
                     ir_expression *const r2A56 = lshift(r2911, body.constant(int(31)));
                     body.emit(assign(r2A55, add(r2A56, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r2A55, body.constant(0u), 0x01));

                     body.emit(assign(r2A47, r2A55, 0x03));

                     body.emit(assign(r2A46, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2A54->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2A58 = less(r2A03, body.constant(int(0)));
                     ir_if *f2A57 = new(mem_ctx) ir_if(operand(r2A58).val);
                     exec_list *const f2A57_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2A57->then_instructions;

                        ir_variable *const r2A59 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2A59, r2A06, 0x01));

                        ir_variable *const r2A5A = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2A5A, neg(r2A03), 0x01));

                        ir_variable *const r2A5B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2A5B);
                        ir_variable *const r2A5C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2A5C);
                        ir_variable *const r2A5D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2A5D);
                        ir_variable *const r2A5E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2A5F = neg(r2A5A);
                        body.emit(assign(r2A5E, bit_and(r2A5F, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2A61 = equal(r2A5A, body.constant(int(0)));
                        ir_if *f2A60 = new(mem_ctx) ir_if(operand(r2A61).val);
                        exec_list *const f2A60_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2A60->then_instructions;

                           body.emit(assign(r2A5B, r2A06, 0x01));

                           body.emit(assign(r2A5C, r2A05, 0x01));

                           body.emit(assign(r2A5D, r2A04, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2A60->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2A63 = less(r2A5A, body.constant(int(32)));
                           ir_if *f2A62 = new(mem_ctx) ir_if(operand(r2A63).val);
                           exec_list *const f2A62_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2A62->then_instructions;

                              body.emit(assign(r2A5B, lshift(r2A05, r2A5E), 0x01));

                              ir_expression *const r2A64 = lshift(r2A04, r2A5E);
                              ir_expression *const r2A65 = rshift(r2A05, r2A5A);
                              body.emit(assign(r2A5C, bit_or(r2A64, r2A65), 0x01));

                              body.emit(assign(r2A5D, rshift(r2A04, r2A5A), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2A62->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2A67 = equal(r2A5A, body.constant(int(32)));
                              ir_if *f2A66 = new(mem_ctx) ir_if(operand(r2A67).val);
                              exec_list *const f2A66_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2A66->then_instructions;

                                 body.emit(assign(r2A5B, r2A05, 0x01));

                                 body.emit(assign(r2A5C, r2A04, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2A66->else_instructions;

                                 body.emit(assign(r2A59, bit_or(r2A06, r2A05), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2A69 = less(r2A5A, body.constant(int(64)));
                                 ir_if *f2A68 = new(mem_ctx) ir_if(operand(r2A69).val);
                                 exec_list *const f2A68_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2A68->then_instructions;

                                    body.emit(assign(r2A5B, lshift(r2A04, r2A5E), 0x01));

                                    ir_expression *const r2A6A = bit_and(r2A5A, body.constant(int(31)));
                                    body.emit(assign(r2A5C, rshift(r2A04, r2A6A), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2A68->else_instructions;

                                    ir_variable *const r2A6B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2A6D = equal(r2A5A, body.constant(int(64)));
                                    ir_if *f2A6C = new(mem_ctx) ir_if(operand(r2A6D).val);
                                    exec_list *const f2A6C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2A6C->then_instructions;

                                       body.emit(assign(r2A6B, r2A04, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2A6C->else_instructions;

                                       ir_expression *const r2A6E = nequal(r2A04, body.constant(0u));
                                       ir_expression *const r2A6F = expr(ir_unop_b2i, r2A6E);
                                       body.emit(assign(r2A6B, expr(ir_unop_i2u, r2A6F), 0x01));


                                    body.instructions = f2A6C_parent_instructions;
                                    body.emit(f2A6C);

                                    /* END IF */

                                    body.emit(assign(r2A5B, r2A6B, 0x01));

                                    body.emit(assign(r2A5C, body.constant(0u), 0x01));


                                 body.instructions = f2A68_parent_instructions;
                                 body.emit(f2A68);

                                 /* END IF */


                              body.instructions = f2A66_parent_instructions;
                              body.emit(f2A66);

                              /* END IF */

                              body.emit(assign(r2A5D, body.constant(0u), 0x01));


                           body.instructions = f2A62_parent_instructions;
                           body.emit(f2A62);

                           /* END IF */

                           ir_expression *const r2A70 = nequal(r2A59, body.constant(0u));
                           ir_expression *const r2A71 = expr(ir_unop_b2i, r2A70);
                           ir_expression *const r2A72 = expr(ir_unop_i2u, r2A71);
                           body.emit(assign(r2A5B, bit_or(r2A5B, r2A72), 0x01));


                        body.instructions = f2A60_parent_instructions;
                        body.emit(f2A60);

                        /* END IF */

                        body.emit(assign(r2A43, r2A5D, 0x01));

                        body.emit(assign(r2A44, r2A5C, 0x01));

                        body.emit(assign(r2A45, r2A5B, 0x01));

                        body.emit(assign(r2A42, body.constant(int(0)), 0x01));

                        body.emit(assign(r2A48, less(r2A5B, body.constant(0u)), 0x01));


                     body.instructions = f2A57_parent_instructions;
                     body.emit(f2A57);

                     /* END IF */


                  body.instructions = f2A54_parent_instructions;
                  body.emit(f2A54);

                  /* END IF */


               body.instructions = f2A4A_parent_instructions;
               body.emit(f2A4A);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2A73 = new(mem_ctx) ir_if(operand(r2A46).val);
               exec_list *const f2A73_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2A73->then_instructions;

                  /* IF CONDITION */
                  ir_if *f2A74 = new(mem_ctx) ir_if(operand(r2A48).val);
                  exec_list *const f2A74_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2A74->then_instructions;

                     ir_variable *const r2A75 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r2A75, add(r2A44, body.constant(1u)), 0x01));

                     ir_expression *const r2A76 = less(r2A75, r2A44);
                     ir_expression *const r2A77 = expr(ir_unop_b2i, r2A76);
                     ir_expression *const r2A78 = expr(ir_unop_i2u, r2A77);
                     body.emit(assign(r2A43, add(r2A43, r2A78), 0x01));

                     ir_expression *const r2A79 = equal(r2A45, body.constant(0u));
                     ir_expression *const r2A7A = expr(ir_unop_b2i, r2A79);
                     ir_expression *const r2A7B = expr(ir_unop_i2u, r2A7A);
                     ir_expression *const r2A7C = add(r2A45, r2A7B);
                     ir_expression *const r2A7D = bit_and(r2A7C, body.constant(1u));
                     ir_expression *const r2A7E = expr(ir_unop_bit_not, r2A7D);
                     body.emit(assign(r2A44, bit_and(r2A75, r2A7E), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2A74->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2A80 = bit_or(r2A43, r2A44);
                     ir_expression *const r2A81 = equal(r2A80, body.constant(0u));
                     ir_if *f2A7F = new(mem_ctx) ir_if(operand(r2A81).val);
                     exec_list *const f2A7F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2A7F->then_instructions;

                        body.emit(assign(r2A42, body.constant(int(0)), 0x01));


                     body.instructions = f2A7F_parent_instructions;
                     body.emit(f2A7F);

                     /* END IF */


                  body.instructions = f2A74_parent_instructions;
                  body.emit(f2A74);

                  /* END IF */

                  ir_variable *const r2A82 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2A82);
                  ir_expression *const r2A83 = lshift(r2911, body.constant(int(31)));
                  ir_expression *const r2A84 = expr(ir_unop_i2u, r2A42);
                  ir_expression *const r2A85 = lshift(r2A84, body.constant(int(20)));
                  ir_expression *const r2A86 = add(r2A83, r2A85);
                  body.emit(assign(r2A82, add(r2A86, r2A43), 0x02));

                  body.emit(assign(r2A82, r2A44, 0x01));

                  body.emit(assign(r2A47, r2A82, 0x03));

                  body.emit(assign(r2A46, body.constant(false), 0x01));


               body.instructions = f2A73_parent_instructions;
               body.emit(f2A73);

               /* END IF */

               body.emit(assign(r2912, r2A47, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f29D6->else_instructions;

               /* IF CONDITION */
               ir_expression *const r2A88 = equal(r291A, body.constant(int(2047)));
               ir_if *f2A87 = new(mem_ctx) ir_if(operand(r2A88).val);
               exec_list *const f2A87_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2A87->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2A8A = bit_or(swizzle_y(r2917), swizzle_x(r2917));
                  ir_expression *const r2A8B = bit_or(swizzle_y(r2915), swizzle_x(r2915));
                  ir_expression *const r2A8C = bit_or(r2A8A, r2A8B);
                  ir_expression *const r2A8D = nequal(r2A8C, body.constant(0u));
                  ir_if *f2A89 = new(mem_ctx) ir_if(operand(r2A8D).val);
                  exec_list *const f2A89_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2A89->then_instructions;

                     ir_variable *const r2A8E = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r2A8E, swizzle_x(r28D8), 0x01));

                     ir_variable *const r2A8F = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r2A8F, body.constant(0u), 0x01));

                     ir_variable *const r2A90 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r2A8E, bit_or(swizzle_y(r28D8), body.constant(524288u)), 0x02));

                     body.emit(assign(r2A8F, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r2A92 = lshift(swizzle_y(r28D8), body.constant(int(1)));
                     ir_expression *const r2A93 = lequal(body.constant(4292870144u), r2A92);
                     ir_expression *const r2A94 = nequal(swizzle_x(r28D8), body.constant(0u));
                     ir_expression *const r2A95 = bit_and(swizzle_y(r28D8), body.constant(1048575u));
                     ir_expression *const r2A96 = nequal(r2A95, body.constant(0u));
                     ir_expression *const r2A97 = logic_or(r2A94, r2A96);
                     ir_expression *const r2A98 = logic_and(r2A93, r2A97);
                     ir_if *f2A91 = new(mem_ctx) ir_if(operand(r2A98).val);
                     exec_list *const f2A91_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2A91->then_instructions;

                        body.emit(assign(r2A90, r2A8E, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2A91->else_instructions;

                        body.emit(assign(r2A90, r2A8F, 0x03));


                     body.instructions = f2A91_parent_instructions;
                     body.emit(f2A91);

                     /* END IF */

                     body.emit(assign(r2912, r2A90, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2A89->else_instructions;

                     ir_constant_data r2A99_data;
                     memset(&r2A99_data, 0, sizeof(ir_constant_data));
                     r2A99_data.u[0] = 4294967295;
                     r2A99_data.u[1] = 4294967295;
                     ir_constant *const r2A99 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r2A99_data);
                     body.emit(assign(r2912, r2A99, 0x03));


                  body.instructions = f2A89_parent_instructions;
                  body.emit(f2A89);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2A87->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2A9B = equal(r291A, body.constant(int(0)));
                  ir_if *f2A9A = new(mem_ctx) ir_if(operand(r2A9B).val);
                  exec_list *const f2A9A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2A9A->then_instructions;

                     body.emit(assign(r2916, body.constant(int(1)), 0x01));

                     body.emit(assign(r2914, body.constant(int(1)), 0x01));


                  body.instructions = f2A9A_parent_instructions;
                  body.emit(f2A9A);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2A9D = less(swizzle_y(r2915), swizzle_y(r2917));
                  ir_if *f2A9C = new(mem_ctx) ir_if(operand(r2A9D).val);
                  exec_list *const f2A9C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2A9C->then_instructions;

                     ir_variable *const r2A9E = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r2A9F = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r2A9F, sub(swizzle_x(r2917), swizzle_x(r2915)), 0x01));

                     ir_expression *const r2AA0 = sub(swizzle_y(r2917), swizzle_y(r2915));
                     ir_expression *const r2AA1 = less(swizzle_x(r2917), swizzle_x(r2915));
                     ir_expression *const r2AA2 = expr(ir_unop_b2i, r2AA1);
                     ir_expression *const r2AA3 = expr(ir_unop_i2u, r2AA2);
                     body.emit(assign(r2A9E, sub(r2AA0, r2AA3), 0x01));

                     body.emit(assign(r2918, add(r2916, body.constant(int(-1))), 0x01));

                     ir_variable *const r2AA4 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r2AA4, add(r2918, body.constant(int(-10))), 0x01));

                     ir_variable *const r2AA5 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r2AA5, r2A9E, 0x01));

                     ir_variable *const r2AA6 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r2AA6, r2A9F, 0x01));

                     ir_variable *const r2AA7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r2AA7);
                     ir_variable *const r2AA8 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r2AA8);
                     /* IF CONDITION */
                     ir_expression *const r2AAA = equal(r2A9E, body.constant(0u));
                     ir_if *f2AA9 = new(mem_ctx) ir_if(operand(r2AAA).val);
                     exec_list *const f2AA9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2AA9->then_instructions;

                        body.emit(assign(r2AA5, r2A9F, 0x01));

                        body.emit(assign(r2AA6, body.constant(0u), 0x01));

                        body.emit(assign(r2AA4, add(r2AA4, body.constant(int(-32))), 0x01));


                     body.instructions = f2AA9_parent_instructions;
                     body.emit(f2AA9);

                     /* END IF */

                     ir_variable *const r2AAB = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r2AAB, r2AA5, 0x01));

                     ir_variable *const r2AAC = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r2AAD = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r2AAD);
                     /* IF CONDITION */
                     ir_expression *const r2AAF = equal(r2AA5, body.constant(0u));
                     ir_if *f2AAE = new(mem_ctx) ir_if(operand(r2AAF).val);
                     exec_list *const f2AAE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2AAE->then_instructions;

                        body.emit(assign(r2AAC, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2AAE->else_instructions;

                        body.emit(assign(r2AAD, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2AB1 = bit_and(r2AA5, body.constant(4294901760u));
                        ir_expression *const r2AB2 = equal(r2AB1, body.constant(0u));
                        ir_if *f2AB0 = new(mem_ctx) ir_if(operand(r2AB2).val);
                        exec_list *const f2AB0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2AB0->then_instructions;

                           body.emit(assign(r2AAD, body.constant(int(16)), 0x01));

                           body.emit(assign(r2AAB, lshift(r2AA5, body.constant(int(16))), 0x01));


                        body.instructions = f2AB0_parent_instructions;
                        body.emit(f2AB0);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2AB4 = bit_and(r2AAB, body.constant(4278190080u));
                        ir_expression *const r2AB5 = equal(r2AB4, body.constant(0u));
                        ir_if *f2AB3 = new(mem_ctx) ir_if(operand(r2AB5).val);
                        exec_list *const f2AB3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2AB3->then_instructions;

                           body.emit(assign(r2AAD, add(r2AAD, body.constant(int(8))), 0x01));

                           body.emit(assign(r2AAB, lshift(r2AAB, body.constant(int(8))), 0x01));


                        body.instructions = f2AB3_parent_instructions;
                        body.emit(f2AB3);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2AB7 = bit_and(r2AAB, body.constant(4026531840u));
                        ir_expression *const r2AB8 = equal(r2AB7, body.constant(0u));
                        ir_if *f2AB6 = new(mem_ctx) ir_if(operand(r2AB8).val);
                        exec_list *const f2AB6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2AB6->then_instructions;

                           body.emit(assign(r2AAD, add(r2AAD, body.constant(int(4))), 0x01));

                           body.emit(assign(r2AAB, lshift(r2AAB, body.constant(int(4))), 0x01));


                        body.instructions = f2AB6_parent_instructions;
                        body.emit(f2AB6);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2ABA = bit_and(r2AAB, body.constant(3221225472u));
                        ir_expression *const r2ABB = equal(r2ABA, body.constant(0u));
                        ir_if *f2AB9 = new(mem_ctx) ir_if(operand(r2ABB).val);
                        exec_list *const f2AB9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2AB9->then_instructions;

                           body.emit(assign(r2AAD, add(r2AAD, body.constant(int(2))), 0x01));

                           body.emit(assign(r2AAB, lshift(r2AAB, body.constant(int(2))), 0x01));


                        body.instructions = f2AB9_parent_instructions;
                        body.emit(f2AB9);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r2ABD = bit_and(r2AAB, body.constant(2147483648u));
                        ir_expression *const r2ABE = equal(r2ABD, body.constant(0u));
                        ir_if *f2ABC = new(mem_ctx) ir_if(operand(r2ABE).val);
                        exec_list *const f2ABC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2ABC->then_instructions;

                           body.emit(assign(r2AAD, add(r2AAD, body.constant(int(1))), 0x01));


                        body.instructions = f2ABC_parent_instructions;
                        body.emit(f2ABC);

                        /* END IF */

                        body.emit(assign(r2AAC, r2AAD, 0x01));


                     body.instructions = f2AAE_parent_instructions;
                     body.emit(f2AAE);

                     /* END IF */

                     body.emit(assign(r2AA8, add(r2AAC, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2AC0 = lequal(body.constant(int(0)), r2AA8);
                     ir_if *f2ABF = new(mem_ctx) ir_if(operand(r2AC0).val);
                     exec_list *const f2ABF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2ABF->then_instructions;

                        body.emit(assign(r2AA7, body.constant(0u), 0x01));

                        ir_variable *const r2AC1 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r2AC1, lshift(r2AA6, r2AA8), 0x01));

                        ir_variable *const r2AC2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2AC4 = equal(r2AA8, body.constant(int(0)));
                        ir_if *f2AC3 = new(mem_ctx) ir_if(operand(r2AC4).val);
                        exec_list *const f2AC3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2AC3->then_instructions;

                           body.emit(assign(r2AC2, r2AA5, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2AC3->else_instructions;

                           ir_expression *const r2AC5 = lshift(r2AA5, r2AA8);
                           ir_expression *const r2AC6 = neg(r2AA8);
                           ir_expression *const r2AC7 = bit_and(r2AC6, body.constant(int(31)));
                           ir_expression *const r2AC8 = rshift(r2AA6, r2AC7);
                           body.emit(assign(r2AC2, bit_or(r2AC5, r2AC8), 0x01));


                        body.instructions = f2AC3_parent_instructions;
                        body.emit(f2AC3);

                        /* END IF */

                        body.emit(assign(r2AA5, r2AC2, 0x01));

                        body.emit(assign(r2AA6, r2AC1, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2ABF->else_instructions;

                        ir_variable *const r2AC9 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2AC9, body.constant(0u), 0x01));

                        ir_variable *const r2ACA = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2ACA, neg(r2AA8), 0x01));

                        ir_variable *const r2ACB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2ACB);
                        ir_variable *const r2ACC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2ACC);
                        ir_variable *const r2ACD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2ACD);
                        ir_variable *const r2ACE = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2ACF = neg(r2ACA);
                        body.emit(assign(r2ACE, bit_and(r2ACF, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2AD1 = equal(r2ACA, body.constant(int(0)));
                        ir_if *f2AD0 = new(mem_ctx) ir_if(operand(r2AD1).val);
                        exec_list *const f2AD0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2AD0->then_instructions;

                           body.emit(assign(r2ACB, r2AC9, 0x01));

                           body.emit(assign(r2ACC, r2AA6, 0x01));

                           body.emit(assign(r2ACD, r2AA5, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2AD0->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2AD3 = less(r2ACA, body.constant(int(32)));
                           ir_if *f2AD2 = new(mem_ctx) ir_if(operand(r2AD3).val);
                           exec_list *const f2AD2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2AD2->then_instructions;

                              body.emit(assign(r2ACB, lshift(r2AA6, r2ACE), 0x01));

                              ir_expression *const r2AD4 = lshift(r2AA5, r2ACE);
                              ir_expression *const r2AD5 = rshift(r2AA6, r2ACA);
                              body.emit(assign(r2ACC, bit_or(r2AD4, r2AD5), 0x01));

                              body.emit(assign(r2ACD, rshift(r2AA5, r2ACA), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2AD2->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2AD7 = equal(r2ACA, body.constant(int(32)));
                              ir_if *f2AD6 = new(mem_ctx) ir_if(operand(r2AD7).val);
                              exec_list *const f2AD6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2AD6->then_instructions;

                                 body.emit(assign(r2ACB, r2AA6, 0x01));

                                 body.emit(assign(r2ACC, r2AA5, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2AD6->else_instructions;

                                 body.emit(assign(r2AC9, bit_or(body.constant(0u), r2AA6), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2AD9 = less(r2ACA, body.constant(int(64)));
                                 ir_if *f2AD8 = new(mem_ctx) ir_if(operand(r2AD9).val);
                                 exec_list *const f2AD8_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2AD8->then_instructions;

                                    body.emit(assign(r2ACB, lshift(r2AA5, r2ACE), 0x01));

                                    ir_expression *const r2ADA = bit_and(r2ACA, body.constant(int(31)));
                                    body.emit(assign(r2ACC, rshift(r2AA5, r2ADA), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2AD8->else_instructions;

                                    ir_variable *const r2ADB = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2ADD = equal(r2ACA, body.constant(int(64)));
                                    ir_if *f2ADC = new(mem_ctx) ir_if(operand(r2ADD).val);
                                    exec_list *const f2ADC_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2ADC->then_instructions;

                                       body.emit(assign(r2ADB, r2AA5, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2ADC->else_instructions;

                                       ir_expression *const r2ADE = nequal(r2AA5, body.constant(0u));
                                       ir_expression *const r2ADF = expr(ir_unop_b2i, r2ADE);
                                       body.emit(assign(r2ADB, expr(ir_unop_i2u, r2ADF), 0x01));


                                    body.instructions = f2ADC_parent_instructions;
                                    body.emit(f2ADC);

                                    /* END IF */

                                    body.emit(assign(r2ACB, r2ADB, 0x01));

                                    body.emit(assign(r2ACC, body.constant(0u), 0x01));


                                 body.instructions = f2AD8_parent_instructions;
                                 body.emit(f2AD8);

                                 /* END IF */


                              body.instructions = f2AD6_parent_instructions;
                              body.emit(f2AD6);

                              /* END IF */

                              body.emit(assign(r2ACD, body.constant(0u), 0x01));


                           body.instructions = f2AD2_parent_instructions;
                           body.emit(f2AD2);

                           /* END IF */

                           ir_expression *const r2AE0 = nequal(r2AC9, body.constant(0u));
                           ir_expression *const r2AE1 = expr(ir_unop_b2i, r2AE0);
                           ir_expression *const r2AE2 = expr(ir_unop_i2u, r2AE1);
                           body.emit(assign(r2ACB, bit_or(r2ACB, r2AE2), 0x01));


                        body.instructions = f2AD0_parent_instructions;
                        body.emit(f2AD0);

                        /* END IF */

                        body.emit(assign(r2AA5, r2ACD, 0x01));

                        body.emit(assign(r2AA6, r2ACC, 0x01));

                        body.emit(assign(r2AA7, r2ACB, 0x01));


                     body.instructions = f2ABF_parent_instructions;
                     body.emit(f2ABF);

                     /* END IF */

                     body.emit(assign(r2AA4, sub(r2AA4, r2AA8), 0x01));

                     ir_variable *const r2AE3 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r2AE3, r2AA4, 0x01));

                     ir_variable *const r2AE4 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r2AE4, r2AA5, 0x01));

                     ir_variable *const r2AE5 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r2AE5, r2AA6, 0x01));

                     ir_variable *const r2AE6 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r2AE6, r2AA7, 0x01));

                     ir_variable *const r2AE7 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r2AE7, body.constant(true), 0x01));

                     ir_variable *const r2AE8 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r2AE9 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r2AE9);
                     ir_expression *const r2AEA = expr(ir_unop_u2i, r2AA7);
                     body.emit(assign(r2AE9, less(r2AEA, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2AEC = lequal(body.constant(int(2045)), r2AA4);
                     ir_if *f2AEB = new(mem_ctx) ir_if(operand(r2AEC).val);
                     exec_list *const f2AEB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2AEB->then_instructions;

                        ir_variable *const r2AED = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2AEF = less(body.constant(int(2045)), r2AA4);
                        ir_if *f2AEE = new(mem_ctx) ir_if(operand(r2AEF).val);
                        exec_list *const f2AEE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2AEE->then_instructions;

                           body.emit(assign(r2AED, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2AEE->else_instructions;

                           ir_variable *const r2AF0 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2AF2 = equal(r2AA4, body.constant(int(2045)));
                           ir_if *f2AF1 = new(mem_ctx) ir_if(operand(r2AF2).val);
                           exec_list *const f2AF1_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2AF1->then_instructions;

                              ir_expression *const r2AF3 = equal(body.constant(2097151u), r2AA5);
                              ir_expression *const r2AF4 = equal(body.constant(4294967295u), r2AA6);
                              body.emit(assign(r2AF0, logic_and(r2AF3, r2AF4), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2AF1->else_instructions;

                              body.emit(assign(r2AF0, body.constant(false), 0x01));


                           body.instructions = f2AF1_parent_instructions;
                           body.emit(f2AF1);

                           /* END IF */

                           body.emit(assign(r2AED, logic_and(r2AF0, r2AE9), 0x01));


                        body.instructions = f2AEE_parent_instructions;
                        body.emit(f2AEE);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f2AF5 = new(mem_ctx) ir_if(operand(r2AED).val);
                        exec_list *const f2AF5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2AF5->then_instructions;

                           ir_variable *const r2AF6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r2AF6);
                           ir_expression *const r2AF7 = lshift(r2911, body.constant(int(31)));
                           body.emit(assign(r2AF6, add(r2AF7, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r2AF6, body.constant(0u), 0x01));

                           body.emit(assign(r2AE8, r2AF6, 0x03));

                           body.emit(assign(r2AE7, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2AF5->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2AF9 = less(r2AA4, body.constant(int(0)));
                           ir_if *f2AF8 = new(mem_ctx) ir_if(operand(r2AF9).val);
                           exec_list *const f2AF8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2AF8->then_instructions;

                              ir_variable *const r2AFA = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r2AFA, r2AA7, 0x01));

                              ir_variable *const r2AFB = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r2AFB, neg(r2AA4), 0x01));

                              ir_variable *const r2AFC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r2AFC);
                              ir_variable *const r2AFD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r2AFD);
                              ir_variable *const r2AFE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r2AFE);
                              ir_variable *const r2AFF = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r2B00 = neg(r2AFB);
                              body.emit(assign(r2AFF, bit_and(r2B00, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2B02 = equal(r2AFB, body.constant(int(0)));
                              ir_if *f2B01 = new(mem_ctx) ir_if(operand(r2B02).val);
                              exec_list *const f2B01_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2B01->then_instructions;

                                 body.emit(assign(r2AFC, r2AA7, 0x01));

                                 body.emit(assign(r2AFD, r2AA6, 0x01));

                                 body.emit(assign(r2AFE, r2AA5, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2B01->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2B04 = less(r2AFB, body.constant(int(32)));
                                 ir_if *f2B03 = new(mem_ctx) ir_if(operand(r2B04).val);
                                 exec_list *const f2B03_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2B03->then_instructions;

                                    body.emit(assign(r2AFC, lshift(r2AA6, r2AFF), 0x01));

                                    ir_expression *const r2B05 = lshift(r2AA5, r2AFF);
                                    ir_expression *const r2B06 = rshift(r2AA6, r2AFB);
                                    body.emit(assign(r2AFD, bit_or(r2B05, r2B06), 0x01));

                                    body.emit(assign(r2AFE, rshift(r2AA5, r2AFB), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2B03->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2B08 = equal(r2AFB, body.constant(int(32)));
                                    ir_if *f2B07 = new(mem_ctx) ir_if(operand(r2B08).val);
                                    exec_list *const f2B07_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2B07->then_instructions;

                                       body.emit(assign(r2AFC, r2AA6, 0x01));

                                       body.emit(assign(r2AFD, r2AA5, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2B07->else_instructions;

                                       body.emit(assign(r2AFA, bit_or(r2AA7, r2AA6), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2B0A = less(r2AFB, body.constant(int(64)));
                                       ir_if *f2B09 = new(mem_ctx) ir_if(operand(r2B0A).val);
                                       exec_list *const f2B09_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2B09->then_instructions;

                                          body.emit(assign(r2AFC, lshift(r2AA5, r2AFF), 0x01));

                                          ir_expression *const r2B0B = bit_and(r2AFB, body.constant(int(31)));
                                          body.emit(assign(r2AFD, rshift(r2AA5, r2B0B), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2B09->else_instructions;

                                          ir_variable *const r2B0C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r2B0E = equal(r2AFB, body.constant(int(64)));
                                          ir_if *f2B0D = new(mem_ctx) ir_if(operand(r2B0E).val);
                                          exec_list *const f2B0D_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2B0D->then_instructions;

                                             body.emit(assign(r2B0C, r2AA5, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2B0D->else_instructions;

                                             ir_expression *const r2B0F = nequal(r2AA5, body.constant(0u));
                                             ir_expression *const r2B10 = expr(ir_unop_b2i, r2B0F);
                                             body.emit(assign(r2B0C, expr(ir_unop_i2u, r2B10), 0x01));


                                          body.instructions = f2B0D_parent_instructions;
                                          body.emit(f2B0D);

                                          /* END IF */

                                          body.emit(assign(r2AFC, r2B0C, 0x01));

                                          body.emit(assign(r2AFD, body.constant(0u), 0x01));


                                       body.instructions = f2B09_parent_instructions;
                                       body.emit(f2B09);

                                       /* END IF */


                                    body.instructions = f2B07_parent_instructions;
                                    body.emit(f2B07);

                                    /* END IF */

                                    body.emit(assign(r2AFE, body.constant(0u), 0x01));


                                 body.instructions = f2B03_parent_instructions;
                                 body.emit(f2B03);

                                 /* END IF */

                                 ir_expression *const r2B11 = nequal(r2AFA, body.constant(0u));
                                 ir_expression *const r2B12 = expr(ir_unop_b2i, r2B11);
                                 ir_expression *const r2B13 = expr(ir_unop_i2u, r2B12);
                                 body.emit(assign(r2AFC, bit_or(r2AFC, r2B13), 0x01));


                              body.instructions = f2B01_parent_instructions;
                              body.emit(f2B01);

                              /* END IF */

                              body.emit(assign(r2AE4, r2AFE, 0x01));

                              body.emit(assign(r2AE5, r2AFD, 0x01));

                              body.emit(assign(r2AE6, r2AFC, 0x01));

                              body.emit(assign(r2AE3, body.constant(int(0)), 0x01));

                              body.emit(assign(r2AE9, less(r2AFC, body.constant(0u)), 0x01));


                           body.instructions = f2AF8_parent_instructions;
                           body.emit(f2AF8);

                           /* END IF */


                        body.instructions = f2AF5_parent_instructions;
                        body.emit(f2AF5);

                        /* END IF */


                     body.instructions = f2AEB_parent_instructions;
                     body.emit(f2AEB);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f2B14 = new(mem_ctx) ir_if(operand(r2AE7).val);
                     exec_list *const f2B14_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2B14->then_instructions;

                        /* IF CONDITION */
                        ir_if *f2B15 = new(mem_ctx) ir_if(operand(r2AE9).val);
                        exec_list *const f2B15_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2B15->then_instructions;

                           ir_variable *const r2B16 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r2B16, add(r2AE5, body.constant(1u)), 0x01));

                           ir_expression *const r2B17 = less(r2B16, r2AE5);
                           ir_expression *const r2B18 = expr(ir_unop_b2i, r2B17);
                           ir_expression *const r2B19 = expr(ir_unop_i2u, r2B18);
                           body.emit(assign(r2AE4, add(r2AE4, r2B19), 0x01));

                           ir_expression *const r2B1A = equal(r2AE6, body.constant(0u));
                           ir_expression *const r2B1B = expr(ir_unop_b2i, r2B1A);
                           ir_expression *const r2B1C = expr(ir_unop_i2u, r2B1B);
                           ir_expression *const r2B1D = add(r2AE6, r2B1C);
                           ir_expression *const r2B1E = bit_and(r2B1D, body.constant(1u));
                           ir_expression *const r2B1F = expr(ir_unop_bit_not, r2B1E);
                           body.emit(assign(r2AE5, bit_and(r2B16, r2B1F), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2B15->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2B21 = bit_or(r2AE4, r2AE5);
                           ir_expression *const r2B22 = equal(r2B21, body.constant(0u));
                           ir_if *f2B20 = new(mem_ctx) ir_if(operand(r2B22).val);
                           exec_list *const f2B20_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2B20->then_instructions;

                              body.emit(assign(r2AE3, body.constant(int(0)), 0x01));


                           body.instructions = f2B20_parent_instructions;
                           body.emit(f2B20);

                           /* END IF */


                        body.instructions = f2B15_parent_instructions;
                        body.emit(f2B15);

                        /* END IF */

                        ir_variable *const r2B23 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r2B23);
                        ir_expression *const r2B24 = lshift(r2911, body.constant(int(31)));
                        ir_expression *const r2B25 = expr(ir_unop_i2u, r2AE3);
                        ir_expression *const r2B26 = lshift(r2B25, body.constant(int(20)));
                        ir_expression *const r2B27 = add(r2B24, r2B26);
                        body.emit(assign(r2B23, add(r2B27, r2AE4), 0x02));

                        body.emit(assign(r2B23, r2AE5, 0x01));

                        body.emit(assign(r2AE8, r2B23, 0x03));

                        body.emit(assign(r2AE7, body.constant(false), 0x01));


                     body.instructions = f2B14_parent_instructions;
                     body.emit(f2B14);

                     /* END IF */

                     body.emit(assign(r2912, r2AE8, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2A9C->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2B29 = less(swizzle_y(r2917), swizzle_y(r2915));
                     ir_if *f2B28 = new(mem_ctx) ir_if(operand(r2B29).val);
                     exec_list *const f2B28_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2B28->then_instructions;

                        ir_variable *const r2B2A = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r2B2B = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r2B2B, sub(swizzle_x(r2915), swizzle_x(r2917)), 0x01));

                        ir_expression *const r2B2C = sub(swizzle_y(r2915), swizzle_y(r2917));
                        ir_expression *const r2B2D = less(swizzle_x(r2915), swizzle_x(r2917));
                        ir_expression *const r2B2E = expr(ir_unop_b2i, r2B2D);
                        ir_expression *const r2B2F = expr(ir_unop_i2u, r2B2E);
                        body.emit(assign(r2B2A, sub(r2B2C, r2B2F), 0x01));

                        body.emit(assign(r2911, bit_xor(r2911, body.constant(1u)), 0x01));

                        body.emit(assign(r2918, add(r2914, body.constant(int(-1))), 0x01));

                        ir_variable *const r2B30 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r2B30, add(r2918, body.constant(int(-10))), 0x01));

                        ir_variable *const r2B31 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r2B31, r2B2A, 0x01));

                        ir_variable *const r2B32 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r2B32, r2B2B, 0x01));

                        ir_variable *const r2B33 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r2B33);
                        ir_variable *const r2B34 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r2B34);
                        /* IF CONDITION */
                        ir_expression *const r2B36 = equal(r2B2A, body.constant(0u));
                        ir_if *f2B35 = new(mem_ctx) ir_if(operand(r2B36).val);
                        exec_list *const f2B35_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2B35->then_instructions;

                           body.emit(assign(r2B31, r2B2B, 0x01));

                           body.emit(assign(r2B32, body.constant(0u), 0x01));

                           body.emit(assign(r2B30, add(r2B30, body.constant(int(-32))), 0x01));


                        body.instructions = f2B35_parent_instructions;
                        body.emit(f2B35);

                        /* END IF */

                        ir_variable *const r2B37 = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r2B37, r2B31, 0x01));

                        ir_variable *const r2B38 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r2B39 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r2B39);
                        /* IF CONDITION */
                        ir_expression *const r2B3B = equal(r2B31, body.constant(0u));
                        ir_if *f2B3A = new(mem_ctx) ir_if(operand(r2B3B).val);
                        exec_list *const f2B3A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2B3A->then_instructions;

                           body.emit(assign(r2B38, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2B3A->else_instructions;

                           body.emit(assign(r2B39, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2B3D = bit_and(r2B31, body.constant(4294901760u));
                           ir_expression *const r2B3E = equal(r2B3D, body.constant(0u));
                           ir_if *f2B3C = new(mem_ctx) ir_if(operand(r2B3E).val);
                           exec_list *const f2B3C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2B3C->then_instructions;

                              body.emit(assign(r2B39, body.constant(int(16)), 0x01));

                              body.emit(assign(r2B37, lshift(r2B31, body.constant(int(16))), 0x01));


                           body.instructions = f2B3C_parent_instructions;
                           body.emit(f2B3C);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2B40 = bit_and(r2B37, body.constant(4278190080u));
                           ir_expression *const r2B41 = equal(r2B40, body.constant(0u));
                           ir_if *f2B3F = new(mem_ctx) ir_if(operand(r2B41).val);
                           exec_list *const f2B3F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2B3F->then_instructions;

                              body.emit(assign(r2B39, add(r2B39, body.constant(int(8))), 0x01));

                              body.emit(assign(r2B37, lshift(r2B37, body.constant(int(8))), 0x01));


                           body.instructions = f2B3F_parent_instructions;
                           body.emit(f2B3F);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2B43 = bit_and(r2B37, body.constant(4026531840u));
                           ir_expression *const r2B44 = equal(r2B43, body.constant(0u));
                           ir_if *f2B42 = new(mem_ctx) ir_if(operand(r2B44).val);
                           exec_list *const f2B42_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2B42->then_instructions;

                              body.emit(assign(r2B39, add(r2B39, body.constant(int(4))), 0x01));

                              body.emit(assign(r2B37, lshift(r2B37, body.constant(int(4))), 0x01));


                           body.instructions = f2B42_parent_instructions;
                           body.emit(f2B42);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2B46 = bit_and(r2B37, body.constant(3221225472u));
                           ir_expression *const r2B47 = equal(r2B46, body.constant(0u));
                           ir_if *f2B45 = new(mem_ctx) ir_if(operand(r2B47).val);
                           exec_list *const f2B45_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2B45->then_instructions;

                              body.emit(assign(r2B39, add(r2B39, body.constant(int(2))), 0x01));

                              body.emit(assign(r2B37, lshift(r2B37, body.constant(int(2))), 0x01));


                           body.instructions = f2B45_parent_instructions;
                           body.emit(f2B45);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r2B49 = bit_and(r2B37, body.constant(2147483648u));
                           ir_expression *const r2B4A = equal(r2B49, body.constant(0u));
                           ir_if *f2B48 = new(mem_ctx) ir_if(operand(r2B4A).val);
                           exec_list *const f2B48_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2B48->then_instructions;

                              body.emit(assign(r2B39, add(r2B39, body.constant(int(1))), 0x01));


                           body.instructions = f2B48_parent_instructions;
                           body.emit(f2B48);

                           /* END IF */

                           body.emit(assign(r2B38, r2B39, 0x01));


                        body.instructions = f2B3A_parent_instructions;
                        body.emit(f2B3A);

                        /* END IF */

                        body.emit(assign(r2B34, add(r2B38, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2B4C = lequal(body.constant(int(0)), r2B34);
                        ir_if *f2B4B = new(mem_ctx) ir_if(operand(r2B4C).val);
                        exec_list *const f2B4B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2B4B->then_instructions;

                           body.emit(assign(r2B33, body.constant(0u), 0x01));

                           ir_variable *const r2B4D = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r2B4D, lshift(r2B32, r2B34), 0x01));

                           ir_variable *const r2B4E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2B50 = equal(r2B34, body.constant(int(0)));
                           ir_if *f2B4F = new(mem_ctx) ir_if(operand(r2B50).val);
                           exec_list *const f2B4F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2B4F->then_instructions;

                              body.emit(assign(r2B4E, r2B31, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2B4F->else_instructions;

                              ir_expression *const r2B51 = lshift(r2B31, r2B34);
                              ir_expression *const r2B52 = neg(r2B34);
                              ir_expression *const r2B53 = bit_and(r2B52, body.constant(int(31)));
                              ir_expression *const r2B54 = rshift(r2B32, r2B53);
                              body.emit(assign(r2B4E, bit_or(r2B51, r2B54), 0x01));


                           body.instructions = f2B4F_parent_instructions;
                           body.emit(f2B4F);

                           /* END IF */

                           body.emit(assign(r2B31, r2B4E, 0x01));

                           body.emit(assign(r2B32, r2B4D, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2B4B->else_instructions;

                           ir_variable *const r2B55 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r2B55, body.constant(0u), 0x01));

                           ir_variable *const r2B56 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r2B56, neg(r2B34), 0x01));

                           ir_variable *const r2B57 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r2B57);
                           ir_variable *const r2B58 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r2B58);
                           ir_variable *const r2B59 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r2B59);
                           ir_variable *const r2B5A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r2B5B = neg(r2B56);
                           body.emit(assign(r2B5A, bit_and(r2B5B, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2B5D = equal(r2B56, body.constant(int(0)));
                           ir_if *f2B5C = new(mem_ctx) ir_if(operand(r2B5D).val);
                           exec_list *const f2B5C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2B5C->then_instructions;

                              body.emit(assign(r2B57, r2B55, 0x01));

                              body.emit(assign(r2B58, r2B32, 0x01));

                              body.emit(assign(r2B59, r2B31, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2B5C->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2B5F = less(r2B56, body.constant(int(32)));
                              ir_if *f2B5E = new(mem_ctx) ir_if(operand(r2B5F).val);
                              exec_list *const f2B5E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2B5E->then_instructions;

                                 body.emit(assign(r2B57, lshift(r2B32, r2B5A), 0x01));

                                 ir_expression *const r2B60 = lshift(r2B31, r2B5A);
                                 ir_expression *const r2B61 = rshift(r2B32, r2B56);
                                 body.emit(assign(r2B58, bit_or(r2B60, r2B61), 0x01));

                                 body.emit(assign(r2B59, rshift(r2B31, r2B56), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2B5E->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2B63 = equal(r2B56, body.constant(int(32)));
                                 ir_if *f2B62 = new(mem_ctx) ir_if(operand(r2B63).val);
                                 exec_list *const f2B62_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2B62->then_instructions;

                                    body.emit(assign(r2B57, r2B32, 0x01));

                                    body.emit(assign(r2B58, r2B31, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2B62->else_instructions;

                                    body.emit(assign(r2B55, bit_or(body.constant(0u), r2B32), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r2B65 = less(r2B56, body.constant(int(64)));
                                    ir_if *f2B64 = new(mem_ctx) ir_if(operand(r2B65).val);
                                    exec_list *const f2B64_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2B64->then_instructions;

                                       body.emit(assign(r2B57, lshift(r2B31, r2B5A), 0x01));

                                       ir_expression *const r2B66 = bit_and(r2B56, body.constant(int(31)));
                                       body.emit(assign(r2B58, rshift(r2B31, r2B66), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2B64->else_instructions;

                                       ir_variable *const r2B67 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r2B69 = equal(r2B56, body.constant(int(64)));
                                       ir_if *f2B68 = new(mem_ctx) ir_if(operand(r2B69).val);
                                       exec_list *const f2B68_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2B68->then_instructions;

                                          body.emit(assign(r2B67, r2B31, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2B68->else_instructions;

                                          ir_expression *const r2B6A = nequal(r2B31, body.constant(0u));
                                          ir_expression *const r2B6B = expr(ir_unop_b2i, r2B6A);
                                          body.emit(assign(r2B67, expr(ir_unop_i2u, r2B6B), 0x01));


                                       body.instructions = f2B68_parent_instructions;
                                       body.emit(f2B68);

                                       /* END IF */

                                       body.emit(assign(r2B57, r2B67, 0x01));

                                       body.emit(assign(r2B58, body.constant(0u), 0x01));


                                    body.instructions = f2B64_parent_instructions;
                                    body.emit(f2B64);

                                    /* END IF */


                                 body.instructions = f2B62_parent_instructions;
                                 body.emit(f2B62);

                                 /* END IF */

                                 body.emit(assign(r2B59, body.constant(0u), 0x01));


                              body.instructions = f2B5E_parent_instructions;
                              body.emit(f2B5E);

                              /* END IF */

                              ir_expression *const r2B6C = nequal(r2B55, body.constant(0u));
                              ir_expression *const r2B6D = expr(ir_unop_b2i, r2B6C);
                              ir_expression *const r2B6E = expr(ir_unop_i2u, r2B6D);
                              body.emit(assign(r2B57, bit_or(r2B57, r2B6E), 0x01));


                           body.instructions = f2B5C_parent_instructions;
                           body.emit(f2B5C);

                           /* END IF */

                           body.emit(assign(r2B31, r2B59, 0x01));

                           body.emit(assign(r2B32, r2B58, 0x01));

                           body.emit(assign(r2B33, r2B57, 0x01));


                        body.instructions = f2B4B_parent_instructions;
                        body.emit(f2B4B);

                        /* END IF */

                        body.emit(assign(r2B30, sub(r2B30, r2B34), 0x01));

                        ir_variable *const r2B6F = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r2B6F, r2B30, 0x01));

                        ir_variable *const r2B70 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r2B70, r2B31, 0x01));

                        ir_variable *const r2B71 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r2B71, r2B32, 0x01));

                        ir_variable *const r2B72 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r2B72, r2B33, 0x01));

                        ir_variable *const r2B73 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r2B73, body.constant(true), 0x01));

                        ir_variable *const r2B74 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r2B75 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r2B75);
                        ir_expression *const r2B76 = expr(ir_unop_u2i, r2B33);
                        body.emit(assign(r2B75, less(r2B76, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2B78 = lequal(body.constant(int(2045)), r2B30);
                        ir_if *f2B77 = new(mem_ctx) ir_if(operand(r2B78).val);
                        exec_list *const f2B77_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2B77->then_instructions;

                           ir_variable *const r2B79 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2B7B = less(body.constant(int(2045)), r2B30);
                           ir_if *f2B7A = new(mem_ctx) ir_if(operand(r2B7B).val);
                           exec_list *const f2B7A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2B7A->then_instructions;

                              body.emit(assign(r2B79, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2B7A->else_instructions;

                              ir_variable *const r2B7C = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2B7E = equal(r2B30, body.constant(int(2045)));
                              ir_if *f2B7D = new(mem_ctx) ir_if(operand(r2B7E).val);
                              exec_list *const f2B7D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2B7D->then_instructions;

                                 ir_expression *const r2B7F = equal(body.constant(2097151u), r2B31);
                                 ir_expression *const r2B80 = equal(body.constant(4294967295u), r2B32);
                                 body.emit(assign(r2B7C, logic_and(r2B7F, r2B80), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2B7D->else_instructions;

                                 body.emit(assign(r2B7C, body.constant(false), 0x01));


                              body.instructions = f2B7D_parent_instructions;
                              body.emit(f2B7D);

                              /* END IF */

                              body.emit(assign(r2B79, logic_and(r2B7C, r2B75), 0x01));


                           body.instructions = f2B7A_parent_instructions;
                           body.emit(f2B7A);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f2B81 = new(mem_ctx) ir_if(operand(r2B79).val);
                           exec_list *const f2B81_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2B81->then_instructions;

                              ir_variable *const r2B82 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r2B82);
                              ir_expression *const r2B83 = lshift(r2911, body.constant(int(31)));
                              body.emit(assign(r2B82, add(r2B83, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r2B82, body.constant(0u), 0x01));

                              body.emit(assign(r2B74, r2B82, 0x03));

                              body.emit(assign(r2B73, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2B81->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2B85 = less(r2B30, body.constant(int(0)));
                              ir_if *f2B84 = new(mem_ctx) ir_if(operand(r2B85).val);
                              exec_list *const f2B84_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2B84->then_instructions;

                                 ir_variable *const r2B86 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r2B86, r2B33, 0x01));

                                 ir_variable *const r2B87 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r2B87, neg(r2B30), 0x01));

                                 ir_variable *const r2B88 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r2B88);
                                 ir_variable *const r2B89 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r2B89);
                                 ir_variable *const r2B8A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r2B8A);
                                 ir_variable *const r2B8B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r2B8C = neg(r2B87);
                                 body.emit(assign(r2B8B, bit_and(r2B8C, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2B8E = equal(r2B87, body.constant(int(0)));
                                 ir_if *f2B8D = new(mem_ctx) ir_if(operand(r2B8E).val);
                                 exec_list *const f2B8D_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2B8D->then_instructions;

                                    body.emit(assign(r2B88, r2B33, 0x01));

                                    body.emit(assign(r2B89, r2B32, 0x01));

                                    body.emit(assign(r2B8A, r2B31, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2B8D->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2B90 = less(r2B87, body.constant(int(32)));
                                    ir_if *f2B8F = new(mem_ctx) ir_if(operand(r2B90).val);
                                    exec_list *const f2B8F_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2B8F->then_instructions;

                                       body.emit(assign(r2B88, lshift(r2B32, r2B8B), 0x01));

                                       ir_expression *const r2B91 = lshift(r2B31, r2B8B);
                                       ir_expression *const r2B92 = rshift(r2B32, r2B87);
                                       body.emit(assign(r2B89, bit_or(r2B91, r2B92), 0x01));

                                       body.emit(assign(r2B8A, rshift(r2B31, r2B87), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2B8F->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r2B94 = equal(r2B87, body.constant(int(32)));
                                       ir_if *f2B93 = new(mem_ctx) ir_if(operand(r2B94).val);
                                       exec_list *const f2B93_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2B93->then_instructions;

                                          body.emit(assign(r2B88, r2B32, 0x01));

                                          body.emit(assign(r2B89, r2B31, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2B93->else_instructions;

                                          body.emit(assign(r2B86, bit_or(r2B33, r2B32), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r2B96 = less(r2B87, body.constant(int(64)));
                                          ir_if *f2B95 = new(mem_ctx) ir_if(operand(r2B96).val);
                                          exec_list *const f2B95_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2B95->then_instructions;

                                             body.emit(assign(r2B88, lshift(r2B31, r2B8B), 0x01));

                                             ir_expression *const r2B97 = bit_and(r2B87, body.constant(int(31)));
                                             body.emit(assign(r2B89, rshift(r2B31, r2B97), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2B95->else_instructions;

                                             ir_variable *const r2B98 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r2B9A = equal(r2B87, body.constant(int(64)));
                                             ir_if *f2B99 = new(mem_ctx) ir_if(operand(r2B9A).val);
                                             exec_list *const f2B99_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2B99->then_instructions;

                                                body.emit(assign(r2B98, r2B31, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2B99->else_instructions;

                                                ir_expression *const r2B9B = nequal(r2B31, body.constant(0u));
                                                ir_expression *const r2B9C = expr(ir_unop_b2i, r2B9B);
                                                body.emit(assign(r2B98, expr(ir_unop_i2u, r2B9C), 0x01));


                                             body.instructions = f2B99_parent_instructions;
                                             body.emit(f2B99);

                                             /* END IF */

                                             body.emit(assign(r2B88, r2B98, 0x01));

                                             body.emit(assign(r2B89, body.constant(0u), 0x01));


                                          body.instructions = f2B95_parent_instructions;
                                          body.emit(f2B95);

                                          /* END IF */


                                       body.instructions = f2B93_parent_instructions;
                                       body.emit(f2B93);

                                       /* END IF */

                                       body.emit(assign(r2B8A, body.constant(0u), 0x01));


                                    body.instructions = f2B8F_parent_instructions;
                                    body.emit(f2B8F);

                                    /* END IF */

                                    ir_expression *const r2B9D = nequal(r2B86, body.constant(0u));
                                    ir_expression *const r2B9E = expr(ir_unop_b2i, r2B9D);
                                    ir_expression *const r2B9F = expr(ir_unop_i2u, r2B9E);
                                    body.emit(assign(r2B88, bit_or(r2B88, r2B9F), 0x01));


                                 body.instructions = f2B8D_parent_instructions;
                                 body.emit(f2B8D);

                                 /* END IF */

                                 body.emit(assign(r2B70, r2B8A, 0x01));

                                 body.emit(assign(r2B71, r2B89, 0x01));

                                 body.emit(assign(r2B72, r2B88, 0x01));

                                 body.emit(assign(r2B6F, body.constant(int(0)), 0x01));

                                 body.emit(assign(r2B75, less(r2B88, body.constant(0u)), 0x01));


                              body.instructions = f2B84_parent_instructions;
                              body.emit(f2B84);

                              /* END IF */


                           body.instructions = f2B81_parent_instructions;
                           body.emit(f2B81);

                           /* END IF */


                        body.instructions = f2B77_parent_instructions;
                        body.emit(f2B77);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f2BA0 = new(mem_ctx) ir_if(operand(r2B73).val);
                        exec_list *const f2BA0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2BA0->then_instructions;

                           /* IF CONDITION */
                           ir_if *f2BA1 = new(mem_ctx) ir_if(operand(r2B75).val);
                           exec_list *const f2BA1_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2BA1->then_instructions;

                              ir_variable *const r2BA2 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r2BA2, add(r2B71, body.constant(1u)), 0x01));

                              ir_expression *const r2BA3 = less(r2BA2, r2B71);
                              ir_expression *const r2BA4 = expr(ir_unop_b2i, r2BA3);
                              ir_expression *const r2BA5 = expr(ir_unop_i2u, r2BA4);
                              body.emit(assign(r2B70, add(r2B70, r2BA5), 0x01));

                              ir_expression *const r2BA6 = equal(r2B72, body.constant(0u));
                              ir_expression *const r2BA7 = expr(ir_unop_b2i, r2BA6);
                              ir_expression *const r2BA8 = expr(ir_unop_i2u, r2BA7);
                              ir_expression *const r2BA9 = add(r2B72, r2BA8);
                              ir_expression *const r2BAA = bit_and(r2BA9, body.constant(1u));
                              ir_expression *const r2BAB = expr(ir_unop_bit_not, r2BAA);
                              body.emit(assign(r2B71, bit_and(r2BA2, r2BAB), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2BA1->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2BAD = bit_or(r2B70, r2B71);
                              ir_expression *const r2BAE = equal(r2BAD, body.constant(0u));
                              ir_if *f2BAC = new(mem_ctx) ir_if(operand(r2BAE).val);
                              exec_list *const f2BAC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2BAC->then_instructions;

                                 body.emit(assign(r2B6F, body.constant(int(0)), 0x01));


                              body.instructions = f2BAC_parent_instructions;
                              body.emit(f2BAC);

                              /* END IF */


                           body.instructions = f2BA1_parent_instructions;
                           body.emit(f2BA1);

                           /* END IF */

                           ir_variable *const r2BAF = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r2BAF);
                           ir_expression *const r2BB0 = lshift(r2911, body.constant(int(31)));
                           ir_expression *const r2BB1 = expr(ir_unop_i2u, r2B6F);
                           ir_expression *const r2BB2 = lshift(r2BB1, body.constant(int(20)));
                           ir_expression *const r2BB3 = add(r2BB0, r2BB2);
                           body.emit(assign(r2BAF, add(r2BB3, r2B70), 0x02));

                           body.emit(assign(r2BAF, r2B71, 0x01));

                           body.emit(assign(r2B74, r2BAF, 0x03));

                           body.emit(assign(r2B73, body.constant(false), 0x01));


                        body.instructions = f2BA0_parent_instructions;
                        body.emit(f2BA0);

                        /* END IF */

                        body.emit(assign(r2912, r2B74, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2B28->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2BB5 = less(swizzle_x(r2915), swizzle_x(r2917));
                        ir_if *f2BB4 = new(mem_ctx) ir_if(operand(r2BB5).val);
                        exec_list *const f2BB4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2BB4->then_instructions;

                           ir_variable *const r2BB6 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r2BB7 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r2BB7, sub(swizzle_x(r2917), swizzle_x(r2915)), 0x01));

                           ir_expression *const r2BB8 = sub(swizzle_y(r2917), swizzle_y(r2915));
                           ir_expression *const r2BB9 = less(swizzle_x(r2917), swizzle_x(r2915));
                           ir_expression *const r2BBA = expr(ir_unop_b2i, r2BB9);
                           ir_expression *const r2BBB = expr(ir_unop_i2u, r2BBA);
                           body.emit(assign(r2BB6, sub(r2BB8, r2BBB), 0x01));

                           body.emit(assign(r2918, add(r2916, body.constant(int(-1))), 0x01));

                           ir_variable *const r2BBC = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r2BBC, add(r2918, body.constant(int(-10))), 0x01));

                           ir_variable *const r2BBD = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r2BBD, r2BB6, 0x01));

                           ir_variable *const r2BBE = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r2BBE, r2BB7, 0x01));

                           ir_variable *const r2BBF = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r2BBF);
                           ir_variable *const r2BC0 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r2BC0);
                           /* IF CONDITION */
                           ir_expression *const r2BC2 = equal(r2BB6, body.constant(0u));
                           ir_if *f2BC1 = new(mem_ctx) ir_if(operand(r2BC2).val);
                           exec_list *const f2BC1_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2BC1->then_instructions;

                              body.emit(assign(r2BBD, r2BB7, 0x01));

                              body.emit(assign(r2BBE, body.constant(0u), 0x01));

                              body.emit(assign(r2BBC, add(r2BBC, body.constant(int(-32))), 0x01));


                           body.instructions = f2BC1_parent_instructions;
                           body.emit(f2BC1);

                           /* END IF */

                           ir_variable *const r2BC3 = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r2BC3, r2BBD, 0x01));

                           ir_variable *const r2BC4 = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r2BC5 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r2BC5);
                           /* IF CONDITION */
                           ir_expression *const r2BC7 = equal(r2BBD, body.constant(0u));
                           ir_if *f2BC6 = new(mem_ctx) ir_if(operand(r2BC7).val);
                           exec_list *const f2BC6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2BC6->then_instructions;

                              body.emit(assign(r2BC4, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2BC6->else_instructions;

                              body.emit(assign(r2BC5, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2BC9 = bit_and(r2BBD, body.constant(4294901760u));
                              ir_expression *const r2BCA = equal(r2BC9, body.constant(0u));
                              ir_if *f2BC8 = new(mem_ctx) ir_if(operand(r2BCA).val);
                              exec_list *const f2BC8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2BC8->then_instructions;

                                 body.emit(assign(r2BC5, body.constant(int(16)), 0x01));

                                 body.emit(assign(r2BC3, lshift(r2BBD, body.constant(int(16))), 0x01));


                              body.instructions = f2BC8_parent_instructions;
                              body.emit(f2BC8);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2BCC = bit_and(r2BC3, body.constant(4278190080u));
                              ir_expression *const r2BCD = equal(r2BCC, body.constant(0u));
                              ir_if *f2BCB = new(mem_ctx) ir_if(operand(r2BCD).val);
                              exec_list *const f2BCB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2BCB->then_instructions;

                                 body.emit(assign(r2BC5, add(r2BC5, body.constant(int(8))), 0x01));

                                 body.emit(assign(r2BC3, lshift(r2BC3, body.constant(int(8))), 0x01));


                              body.instructions = f2BCB_parent_instructions;
                              body.emit(f2BCB);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2BCF = bit_and(r2BC3, body.constant(4026531840u));
                              ir_expression *const r2BD0 = equal(r2BCF, body.constant(0u));
                              ir_if *f2BCE = new(mem_ctx) ir_if(operand(r2BD0).val);
                              exec_list *const f2BCE_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2BCE->then_instructions;

                                 body.emit(assign(r2BC5, add(r2BC5, body.constant(int(4))), 0x01));

                                 body.emit(assign(r2BC3, lshift(r2BC3, body.constant(int(4))), 0x01));


                              body.instructions = f2BCE_parent_instructions;
                              body.emit(f2BCE);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2BD2 = bit_and(r2BC3, body.constant(3221225472u));
                              ir_expression *const r2BD3 = equal(r2BD2, body.constant(0u));
                              ir_if *f2BD1 = new(mem_ctx) ir_if(operand(r2BD3).val);
                              exec_list *const f2BD1_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2BD1->then_instructions;

                                 body.emit(assign(r2BC5, add(r2BC5, body.constant(int(2))), 0x01));

                                 body.emit(assign(r2BC3, lshift(r2BC3, body.constant(int(2))), 0x01));


                              body.instructions = f2BD1_parent_instructions;
                              body.emit(f2BD1);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r2BD5 = bit_and(r2BC3, body.constant(2147483648u));
                              ir_expression *const r2BD6 = equal(r2BD5, body.constant(0u));
                              ir_if *f2BD4 = new(mem_ctx) ir_if(operand(r2BD6).val);
                              exec_list *const f2BD4_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2BD4->then_instructions;

                                 body.emit(assign(r2BC5, add(r2BC5, body.constant(int(1))), 0x01));


                              body.instructions = f2BD4_parent_instructions;
                              body.emit(f2BD4);

                              /* END IF */

                              body.emit(assign(r2BC4, r2BC5, 0x01));


                           body.instructions = f2BC6_parent_instructions;
                           body.emit(f2BC6);

                           /* END IF */

                           body.emit(assign(r2BC0, add(r2BC4, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2BD8 = lequal(body.constant(int(0)), r2BC0);
                           ir_if *f2BD7 = new(mem_ctx) ir_if(operand(r2BD8).val);
                           exec_list *const f2BD7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2BD7->then_instructions;

                              body.emit(assign(r2BBF, body.constant(0u), 0x01));

                              ir_variable *const r2BD9 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r2BD9, lshift(r2BBE, r2BC0), 0x01));

                              ir_variable *const r2BDA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2BDC = equal(r2BC0, body.constant(int(0)));
                              ir_if *f2BDB = new(mem_ctx) ir_if(operand(r2BDC).val);
                              exec_list *const f2BDB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2BDB->then_instructions;

                                 body.emit(assign(r2BDA, r2BBD, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2BDB->else_instructions;

                                 ir_expression *const r2BDD = lshift(r2BBD, r2BC0);
                                 ir_expression *const r2BDE = neg(r2BC0);
                                 ir_expression *const r2BDF = bit_and(r2BDE, body.constant(int(31)));
                                 ir_expression *const r2BE0 = rshift(r2BBE, r2BDF);
                                 body.emit(assign(r2BDA, bit_or(r2BDD, r2BE0), 0x01));


                              body.instructions = f2BDB_parent_instructions;
                              body.emit(f2BDB);

                              /* END IF */

                              body.emit(assign(r2BBD, r2BDA, 0x01));

                              body.emit(assign(r2BBE, r2BD9, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2BD7->else_instructions;

                              ir_variable *const r2BE1 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r2BE1, body.constant(0u), 0x01));

                              ir_variable *const r2BE2 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r2BE2, neg(r2BC0), 0x01));

                              ir_variable *const r2BE3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r2BE3);
                              ir_variable *const r2BE4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r2BE4);
                              ir_variable *const r2BE5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r2BE5);
                              ir_variable *const r2BE6 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r2BE7 = neg(r2BE2);
                              body.emit(assign(r2BE6, bit_and(r2BE7, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2BE9 = equal(r2BE2, body.constant(int(0)));
                              ir_if *f2BE8 = new(mem_ctx) ir_if(operand(r2BE9).val);
                              exec_list *const f2BE8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2BE8->then_instructions;

                                 body.emit(assign(r2BE3, r2BE1, 0x01));

                                 body.emit(assign(r2BE4, r2BBE, 0x01));

                                 body.emit(assign(r2BE5, r2BBD, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2BE8->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2BEB = less(r2BE2, body.constant(int(32)));
                                 ir_if *f2BEA = new(mem_ctx) ir_if(operand(r2BEB).val);
                                 exec_list *const f2BEA_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2BEA->then_instructions;

                                    body.emit(assign(r2BE3, lshift(r2BBE, r2BE6), 0x01));

                                    ir_expression *const r2BEC = lshift(r2BBD, r2BE6);
                                    ir_expression *const r2BED = rshift(r2BBE, r2BE2);
                                    body.emit(assign(r2BE4, bit_or(r2BEC, r2BED), 0x01));

                                    body.emit(assign(r2BE5, rshift(r2BBD, r2BE2), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2BEA->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2BEF = equal(r2BE2, body.constant(int(32)));
                                    ir_if *f2BEE = new(mem_ctx) ir_if(operand(r2BEF).val);
                                    exec_list *const f2BEE_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2BEE->then_instructions;

                                       body.emit(assign(r2BE3, r2BBE, 0x01));

                                       body.emit(assign(r2BE4, r2BBD, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2BEE->else_instructions;

                                       body.emit(assign(r2BE1, bit_or(body.constant(0u), r2BBE), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2BF1 = less(r2BE2, body.constant(int(64)));
                                       ir_if *f2BF0 = new(mem_ctx) ir_if(operand(r2BF1).val);
                                       exec_list *const f2BF0_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2BF0->then_instructions;

                                          body.emit(assign(r2BE3, lshift(r2BBD, r2BE6), 0x01));

                                          ir_expression *const r2BF2 = bit_and(r2BE2, body.constant(int(31)));
                                          body.emit(assign(r2BE4, rshift(r2BBD, r2BF2), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2BF0->else_instructions;

                                          ir_variable *const r2BF3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r2BF5 = equal(r2BE2, body.constant(int(64)));
                                          ir_if *f2BF4 = new(mem_ctx) ir_if(operand(r2BF5).val);
                                          exec_list *const f2BF4_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2BF4->then_instructions;

                                             body.emit(assign(r2BF3, r2BBD, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2BF4->else_instructions;

                                             ir_expression *const r2BF6 = nequal(r2BBD, body.constant(0u));
                                             ir_expression *const r2BF7 = expr(ir_unop_b2i, r2BF6);
                                             body.emit(assign(r2BF3, expr(ir_unop_i2u, r2BF7), 0x01));


                                          body.instructions = f2BF4_parent_instructions;
                                          body.emit(f2BF4);

                                          /* END IF */

                                          body.emit(assign(r2BE3, r2BF3, 0x01));

                                          body.emit(assign(r2BE4, body.constant(0u), 0x01));


                                       body.instructions = f2BF0_parent_instructions;
                                       body.emit(f2BF0);

                                       /* END IF */


                                    body.instructions = f2BEE_parent_instructions;
                                    body.emit(f2BEE);

                                    /* END IF */

                                    body.emit(assign(r2BE5, body.constant(0u), 0x01));


                                 body.instructions = f2BEA_parent_instructions;
                                 body.emit(f2BEA);

                                 /* END IF */

                                 ir_expression *const r2BF8 = nequal(r2BE1, body.constant(0u));
                                 ir_expression *const r2BF9 = expr(ir_unop_b2i, r2BF8);
                                 ir_expression *const r2BFA = expr(ir_unop_i2u, r2BF9);
                                 body.emit(assign(r2BE3, bit_or(r2BE3, r2BFA), 0x01));


                              body.instructions = f2BE8_parent_instructions;
                              body.emit(f2BE8);

                              /* END IF */

                              body.emit(assign(r2BBD, r2BE5, 0x01));

                              body.emit(assign(r2BBE, r2BE4, 0x01));

                              body.emit(assign(r2BBF, r2BE3, 0x01));


                           body.instructions = f2BD7_parent_instructions;
                           body.emit(f2BD7);

                           /* END IF */

                           body.emit(assign(r2BBC, sub(r2BBC, r2BC0), 0x01));

                           ir_variable *const r2BFB = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r2BFB, r2BBC, 0x01));

                           ir_variable *const r2BFC = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r2BFC, r2BBD, 0x01));

                           ir_variable *const r2BFD = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r2BFD, r2BBE, 0x01));

                           ir_variable *const r2BFE = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r2BFE, r2BBF, 0x01));

                           ir_variable *const r2BFF = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r2BFF, body.constant(true), 0x01));

                           ir_variable *const r2C00 = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r2C01 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r2C01);
                           ir_expression *const r2C02 = expr(ir_unop_u2i, r2BBF);
                           body.emit(assign(r2C01, less(r2C02, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2C04 = lequal(body.constant(int(2045)), r2BBC);
                           ir_if *f2C03 = new(mem_ctx) ir_if(operand(r2C04).val);
                           exec_list *const f2C03_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2C03->then_instructions;

                              ir_variable *const r2C05 = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2C07 = less(body.constant(int(2045)), r2BBC);
                              ir_if *f2C06 = new(mem_ctx) ir_if(operand(r2C07).val);
                              exec_list *const f2C06_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2C06->then_instructions;

                                 body.emit(assign(r2C05, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2C06->else_instructions;

                                 ir_variable *const r2C08 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2C0A = equal(r2BBC, body.constant(int(2045)));
                                 ir_if *f2C09 = new(mem_ctx) ir_if(operand(r2C0A).val);
                                 exec_list *const f2C09_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2C09->then_instructions;

                                    ir_expression *const r2C0B = equal(body.constant(2097151u), r2BBD);
                                    ir_expression *const r2C0C = equal(body.constant(4294967295u), r2BBE);
                                    body.emit(assign(r2C08, logic_and(r2C0B, r2C0C), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2C09->else_instructions;

                                    body.emit(assign(r2C08, body.constant(false), 0x01));


                                 body.instructions = f2C09_parent_instructions;
                                 body.emit(f2C09);

                                 /* END IF */

                                 body.emit(assign(r2C05, logic_and(r2C08, r2C01), 0x01));


                              body.instructions = f2C06_parent_instructions;
                              body.emit(f2C06);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f2C0D = new(mem_ctx) ir_if(operand(r2C05).val);
                              exec_list *const f2C0D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2C0D->then_instructions;

                                 ir_variable *const r2C0E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r2C0E);
                                 ir_expression *const r2C0F = lshift(r2911, body.constant(int(31)));
                                 body.emit(assign(r2C0E, add(r2C0F, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r2C0E, body.constant(0u), 0x01));

                                 body.emit(assign(r2C00, r2C0E, 0x03));

                                 body.emit(assign(r2BFF, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2C0D->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2C11 = less(r2BBC, body.constant(int(0)));
                                 ir_if *f2C10 = new(mem_ctx) ir_if(operand(r2C11).val);
                                 exec_list *const f2C10_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2C10->then_instructions;

                                    ir_variable *const r2C12 = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r2C12, r2BBF, 0x01));

                                    ir_variable *const r2C13 = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r2C13, neg(r2BBC), 0x01));

                                    ir_variable *const r2C14 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r2C14);
                                    ir_variable *const r2C15 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r2C15);
                                    ir_variable *const r2C16 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r2C16);
                                    ir_variable *const r2C17 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r2C18 = neg(r2C13);
                                    body.emit(assign(r2C17, bit_and(r2C18, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r2C1A = equal(r2C13, body.constant(int(0)));
                                    ir_if *f2C19 = new(mem_ctx) ir_if(operand(r2C1A).val);
                                    exec_list *const f2C19_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2C19->then_instructions;

                                       body.emit(assign(r2C14, r2BBF, 0x01));

                                       body.emit(assign(r2C15, r2BBE, 0x01));

                                       body.emit(assign(r2C16, r2BBD, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2C19->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r2C1C = less(r2C13, body.constant(int(32)));
                                       ir_if *f2C1B = new(mem_ctx) ir_if(operand(r2C1C).val);
                                       exec_list *const f2C1B_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2C1B->then_instructions;

                                          body.emit(assign(r2C14, lshift(r2BBE, r2C17), 0x01));

                                          ir_expression *const r2C1D = lshift(r2BBD, r2C17);
                                          ir_expression *const r2C1E = rshift(r2BBE, r2C13);
                                          body.emit(assign(r2C15, bit_or(r2C1D, r2C1E), 0x01));

                                          body.emit(assign(r2C16, rshift(r2BBD, r2C13), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2C1B->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r2C20 = equal(r2C13, body.constant(int(32)));
                                          ir_if *f2C1F = new(mem_ctx) ir_if(operand(r2C20).val);
                                          exec_list *const f2C1F_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2C1F->then_instructions;

                                             body.emit(assign(r2C14, r2BBE, 0x01));

                                             body.emit(assign(r2C15, r2BBD, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2C1F->else_instructions;

                                             body.emit(assign(r2C12, bit_or(r2BBF, r2BBE), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r2C22 = less(r2C13, body.constant(int(64)));
                                             ir_if *f2C21 = new(mem_ctx) ir_if(operand(r2C22).val);
                                             exec_list *const f2C21_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2C21->then_instructions;

                                                body.emit(assign(r2C14, lshift(r2BBD, r2C17), 0x01));

                                                ir_expression *const r2C23 = bit_and(r2C13, body.constant(int(31)));
                                                body.emit(assign(r2C15, rshift(r2BBD, r2C23), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2C21->else_instructions;

                                                ir_variable *const r2C24 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r2C26 = equal(r2C13, body.constant(int(64)));
                                                ir_if *f2C25 = new(mem_ctx) ir_if(operand(r2C26).val);
                                                exec_list *const f2C25_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f2C25->then_instructions;

                                                   body.emit(assign(r2C24, r2BBD, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f2C25->else_instructions;

                                                   ir_expression *const r2C27 = nequal(r2BBD, body.constant(0u));
                                                   ir_expression *const r2C28 = expr(ir_unop_b2i, r2C27);
                                                   body.emit(assign(r2C24, expr(ir_unop_i2u, r2C28), 0x01));


                                                body.instructions = f2C25_parent_instructions;
                                                body.emit(f2C25);

                                                /* END IF */

                                                body.emit(assign(r2C14, r2C24, 0x01));

                                                body.emit(assign(r2C15, body.constant(0u), 0x01));


                                             body.instructions = f2C21_parent_instructions;
                                             body.emit(f2C21);

                                             /* END IF */


                                          body.instructions = f2C1F_parent_instructions;
                                          body.emit(f2C1F);

                                          /* END IF */

                                          body.emit(assign(r2C16, body.constant(0u), 0x01));


                                       body.instructions = f2C1B_parent_instructions;
                                       body.emit(f2C1B);

                                       /* END IF */

                                       ir_expression *const r2C29 = nequal(r2C12, body.constant(0u));
                                       ir_expression *const r2C2A = expr(ir_unop_b2i, r2C29);
                                       ir_expression *const r2C2B = expr(ir_unop_i2u, r2C2A);
                                       body.emit(assign(r2C14, bit_or(r2C14, r2C2B), 0x01));


                                    body.instructions = f2C19_parent_instructions;
                                    body.emit(f2C19);

                                    /* END IF */

                                    body.emit(assign(r2BFC, r2C16, 0x01));

                                    body.emit(assign(r2BFD, r2C15, 0x01));

                                    body.emit(assign(r2BFE, r2C14, 0x01));

                                    body.emit(assign(r2BFB, body.constant(int(0)), 0x01));

                                    body.emit(assign(r2C01, less(r2C14, body.constant(0u)), 0x01));


                                 body.instructions = f2C10_parent_instructions;
                                 body.emit(f2C10);

                                 /* END IF */


                              body.instructions = f2C0D_parent_instructions;
                              body.emit(f2C0D);

                              /* END IF */


                           body.instructions = f2C03_parent_instructions;
                           body.emit(f2C03);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f2C2C = new(mem_ctx) ir_if(operand(r2BFF).val);
                           exec_list *const f2C2C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2C2C->then_instructions;

                              /* IF CONDITION */
                              ir_if *f2C2D = new(mem_ctx) ir_if(operand(r2C01).val);
                              exec_list *const f2C2D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2C2D->then_instructions;

                                 ir_variable *const r2C2E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r2C2E, add(r2BFD, body.constant(1u)), 0x01));

                                 ir_expression *const r2C2F = less(r2C2E, r2BFD);
                                 ir_expression *const r2C30 = expr(ir_unop_b2i, r2C2F);
                                 ir_expression *const r2C31 = expr(ir_unop_i2u, r2C30);
                                 body.emit(assign(r2BFC, add(r2BFC, r2C31), 0x01));

                                 ir_expression *const r2C32 = equal(r2BFE, body.constant(0u));
                                 ir_expression *const r2C33 = expr(ir_unop_b2i, r2C32);
                                 ir_expression *const r2C34 = expr(ir_unop_i2u, r2C33);
                                 ir_expression *const r2C35 = add(r2BFE, r2C34);
                                 ir_expression *const r2C36 = bit_and(r2C35, body.constant(1u));
                                 ir_expression *const r2C37 = expr(ir_unop_bit_not, r2C36);
                                 body.emit(assign(r2BFD, bit_and(r2C2E, r2C37), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2C2D->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2C39 = bit_or(r2BFC, r2BFD);
                                 ir_expression *const r2C3A = equal(r2C39, body.constant(0u));
                                 ir_if *f2C38 = new(mem_ctx) ir_if(operand(r2C3A).val);
                                 exec_list *const f2C38_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2C38->then_instructions;

                                    body.emit(assign(r2BFB, body.constant(int(0)), 0x01));


                                 body.instructions = f2C38_parent_instructions;
                                 body.emit(f2C38);

                                 /* END IF */


                              body.instructions = f2C2D_parent_instructions;
                              body.emit(f2C2D);

                              /* END IF */

                              ir_variable *const r2C3B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r2C3B);
                              ir_expression *const r2C3C = lshift(r2911, body.constant(int(31)));
                              ir_expression *const r2C3D = expr(ir_unop_i2u, r2BFB);
                              ir_expression *const r2C3E = lshift(r2C3D, body.constant(int(20)));
                              ir_expression *const r2C3F = add(r2C3C, r2C3E);
                              body.emit(assign(r2C3B, add(r2C3F, r2BFC), 0x02));

                              body.emit(assign(r2C3B, r2BFD, 0x01));

                              body.emit(assign(r2C00, r2C3B, 0x03));

                              body.emit(assign(r2BFF, body.constant(false), 0x01));


                           body.instructions = f2C2C_parent_instructions;
                           body.emit(f2C2C);

                           /* END IF */

                           body.emit(assign(r2912, r2C00, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2BB4->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2C41 = less(swizzle_x(r2917), swizzle_x(r2915));
                           ir_if *f2C40 = new(mem_ctx) ir_if(operand(r2C41).val);
                           exec_list *const f2C40_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2C40->then_instructions;

                              ir_variable *const r2C42 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                              ir_variable *const r2C43 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r2C43, sub(swizzle_x(r2915), swizzle_x(r2917)), 0x01));

                              ir_expression *const r2C44 = sub(swizzle_y(r2915), swizzle_y(r2917));
                              ir_expression *const r2C45 = less(swizzle_x(r2915), swizzle_x(r2917));
                              ir_expression *const r2C46 = expr(ir_unop_b2i, r2C45);
                              ir_expression *const r2C47 = expr(ir_unop_i2u, r2C46);
                              body.emit(assign(r2C42, sub(r2C44, r2C47), 0x01));

                              body.emit(assign(r2911, bit_xor(r2911, body.constant(1u)), 0x01));

                              body.emit(assign(r2918, add(r2914, body.constant(int(-1))), 0x01));

                              ir_variable *const r2C48 = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r2C48, add(r2918, body.constant(int(-10))), 0x01));

                              ir_variable *const r2C49 = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r2C49, r2C42, 0x01));

                              ir_variable *const r2C4A = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r2C4A, r2C43, 0x01));

                              ir_variable *const r2C4B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                              body.emit(r2C4B);
                              ir_variable *const r2C4C = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r2C4C);
                              /* IF CONDITION */
                              ir_expression *const r2C4E = equal(r2C42, body.constant(0u));
                              ir_if *f2C4D = new(mem_ctx) ir_if(operand(r2C4E).val);
                              exec_list *const f2C4D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2C4D->then_instructions;

                                 body.emit(assign(r2C49, r2C43, 0x01));

                                 body.emit(assign(r2C4A, body.constant(0u), 0x01));

                                 body.emit(assign(r2C48, add(r2C48, body.constant(int(-32))), 0x01));


                              body.instructions = f2C4D_parent_instructions;
                              body.emit(f2C4D);

                              /* END IF */

                              ir_variable *const r2C4F = body.make_temp(glsl_type::uint_type, "a");
                              body.emit(assign(r2C4F, r2C49, 0x01));

                              ir_variable *const r2C50 = body.make_temp(glsl_type::int_type, "return_value");
                              ir_variable *const r2C51 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                              body.emit(r2C51);
                              /* IF CONDITION */
                              ir_expression *const r2C53 = equal(r2C49, body.constant(0u));
                              ir_if *f2C52 = new(mem_ctx) ir_if(operand(r2C53).val);
                              exec_list *const f2C52_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2C52->then_instructions;

                                 body.emit(assign(r2C50, body.constant(int(32)), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2C52->else_instructions;

                                 body.emit(assign(r2C51, body.constant(int(0)), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2C55 = bit_and(r2C49, body.constant(4294901760u));
                                 ir_expression *const r2C56 = equal(r2C55, body.constant(0u));
                                 ir_if *f2C54 = new(mem_ctx) ir_if(operand(r2C56).val);
                                 exec_list *const f2C54_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2C54->then_instructions;

                                    body.emit(assign(r2C51, body.constant(int(16)), 0x01));

                                    body.emit(assign(r2C4F, lshift(r2C49, body.constant(int(16))), 0x01));


                                 body.instructions = f2C54_parent_instructions;
                                 body.emit(f2C54);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2C58 = bit_and(r2C4F, body.constant(4278190080u));
                                 ir_expression *const r2C59 = equal(r2C58, body.constant(0u));
                                 ir_if *f2C57 = new(mem_ctx) ir_if(operand(r2C59).val);
                                 exec_list *const f2C57_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2C57->then_instructions;

                                    body.emit(assign(r2C51, add(r2C51, body.constant(int(8))), 0x01));

                                    body.emit(assign(r2C4F, lshift(r2C4F, body.constant(int(8))), 0x01));


                                 body.instructions = f2C57_parent_instructions;
                                 body.emit(f2C57);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2C5B = bit_and(r2C4F, body.constant(4026531840u));
                                 ir_expression *const r2C5C = equal(r2C5B, body.constant(0u));
                                 ir_if *f2C5A = new(mem_ctx) ir_if(operand(r2C5C).val);
                                 exec_list *const f2C5A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2C5A->then_instructions;

                                    body.emit(assign(r2C51, add(r2C51, body.constant(int(4))), 0x01));

                                    body.emit(assign(r2C4F, lshift(r2C4F, body.constant(int(4))), 0x01));


                                 body.instructions = f2C5A_parent_instructions;
                                 body.emit(f2C5A);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2C5E = bit_and(r2C4F, body.constant(3221225472u));
                                 ir_expression *const r2C5F = equal(r2C5E, body.constant(0u));
                                 ir_if *f2C5D = new(mem_ctx) ir_if(operand(r2C5F).val);
                                 exec_list *const f2C5D_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2C5D->then_instructions;

                                    body.emit(assign(r2C51, add(r2C51, body.constant(int(2))), 0x01));

                                    body.emit(assign(r2C4F, lshift(r2C4F, body.constant(int(2))), 0x01));


                                 body.instructions = f2C5D_parent_instructions;
                                 body.emit(f2C5D);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_expression *const r2C61 = bit_and(r2C4F, body.constant(2147483648u));
                                 ir_expression *const r2C62 = equal(r2C61, body.constant(0u));
                                 ir_if *f2C60 = new(mem_ctx) ir_if(operand(r2C62).val);
                                 exec_list *const f2C60_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2C60->then_instructions;

                                    body.emit(assign(r2C51, add(r2C51, body.constant(int(1))), 0x01));


                                 body.instructions = f2C60_parent_instructions;
                                 body.emit(f2C60);

                                 /* END IF */

                                 body.emit(assign(r2C50, r2C51, 0x01));


                              body.instructions = f2C52_parent_instructions;
                              body.emit(f2C52);

                              /* END IF */

                              body.emit(assign(r2C4C, add(r2C50, body.constant(int(-11))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2C64 = lequal(body.constant(int(0)), r2C4C);
                              ir_if *f2C63 = new(mem_ctx) ir_if(operand(r2C64).val);
                              exec_list *const f2C63_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2C63->then_instructions;

                                 body.emit(assign(r2C4B, body.constant(0u), 0x01));

                                 ir_variable *const r2C65 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                                 body.emit(assign(r2C65, lshift(r2C4A, r2C4C), 0x01));

                                 ir_variable *const r2C66 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2C68 = equal(r2C4C, body.constant(int(0)));
                                 ir_if *f2C67 = new(mem_ctx) ir_if(operand(r2C68).val);
                                 exec_list *const f2C67_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2C67->then_instructions;

                                    body.emit(assign(r2C66, r2C49, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2C67->else_instructions;

                                    ir_expression *const r2C69 = lshift(r2C49, r2C4C);
                                    ir_expression *const r2C6A = neg(r2C4C);
                                    ir_expression *const r2C6B = bit_and(r2C6A, body.constant(int(31)));
                                    ir_expression *const r2C6C = rshift(r2C4A, r2C6B);
                                    body.emit(assign(r2C66, bit_or(r2C69, r2C6C), 0x01));


                                 body.instructions = f2C67_parent_instructions;
                                 body.emit(f2C67);

                                 /* END IF */

                                 body.emit(assign(r2C49, r2C66, 0x01));

                                 body.emit(assign(r2C4A, r2C65, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2C63->else_instructions;

                                 ir_variable *const r2C6D = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r2C6D, body.constant(0u), 0x01));

                                 ir_variable *const r2C6E = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r2C6E, neg(r2C4C), 0x01));

                                 ir_variable *const r2C6F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r2C6F);
                                 ir_variable *const r2C70 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r2C70);
                                 ir_variable *const r2C71 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r2C71);
                                 ir_variable *const r2C72 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r2C73 = neg(r2C6E);
                                 body.emit(assign(r2C72, bit_and(r2C73, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2C75 = equal(r2C6E, body.constant(int(0)));
                                 ir_if *f2C74 = new(mem_ctx) ir_if(operand(r2C75).val);
                                 exec_list *const f2C74_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2C74->then_instructions;

                                    body.emit(assign(r2C6F, r2C6D, 0x01));

                                    body.emit(assign(r2C70, r2C4A, 0x01));

                                    body.emit(assign(r2C71, r2C49, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2C74->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2C77 = less(r2C6E, body.constant(int(32)));
                                    ir_if *f2C76 = new(mem_ctx) ir_if(operand(r2C77).val);
                                    exec_list *const f2C76_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2C76->then_instructions;

                                       body.emit(assign(r2C6F, lshift(r2C4A, r2C72), 0x01));

                                       ir_expression *const r2C78 = lshift(r2C49, r2C72);
                                       ir_expression *const r2C79 = rshift(r2C4A, r2C6E);
                                       body.emit(assign(r2C70, bit_or(r2C78, r2C79), 0x01));

                                       body.emit(assign(r2C71, rshift(r2C49, r2C6E), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2C76->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r2C7B = equal(r2C6E, body.constant(int(32)));
                                       ir_if *f2C7A = new(mem_ctx) ir_if(operand(r2C7B).val);
                                       exec_list *const f2C7A_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2C7A->then_instructions;

                                          body.emit(assign(r2C6F, r2C4A, 0x01));

                                          body.emit(assign(r2C70, r2C49, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2C7A->else_instructions;

                                          body.emit(assign(r2C6D, bit_or(body.constant(0u), r2C4A), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r2C7D = less(r2C6E, body.constant(int(64)));
                                          ir_if *f2C7C = new(mem_ctx) ir_if(operand(r2C7D).val);
                                          exec_list *const f2C7C_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2C7C->then_instructions;

                                             body.emit(assign(r2C6F, lshift(r2C49, r2C72), 0x01));

                                             ir_expression *const r2C7E = bit_and(r2C6E, body.constant(int(31)));
                                             body.emit(assign(r2C70, rshift(r2C49, r2C7E), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2C7C->else_instructions;

                                             ir_variable *const r2C7F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r2C81 = equal(r2C6E, body.constant(int(64)));
                                             ir_if *f2C80 = new(mem_ctx) ir_if(operand(r2C81).val);
                                             exec_list *const f2C80_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2C80->then_instructions;

                                                body.emit(assign(r2C7F, r2C49, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2C80->else_instructions;

                                                ir_expression *const r2C82 = nequal(r2C49, body.constant(0u));
                                                ir_expression *const r2C83 = expr(ir_unop_b2i, r2C82);
                                                body.emit(assign(r2C7F, expr(ir_unop_i2u, r2C83), 0x01));


                                             body.instructions = f2C80_parent_instructions;
                                             body.emit(f2C80);

                                             /* END IF */

                                             body.emit(assign(r2C6F, r2C7F, 0x01));

                                             body.emit(assign(r2C70, body.constant(0u), 0x01));


                                          body.instructions = f2C7C_parent_instructions;
                                          body.emit(f2C7C);

                                          /* END IF */


                                       body.instructions = f2C7A_parent_instructions;
                                       body.emit(f2C7A);

                                       /* END IF */

                                       body.emit(assign(r2C71, body.constant(0u), 0x01));


                                    body.instructions = f2C76_parent_instructions;
                                    body.emit(f2C76);

                                    /* END IF */

                                    ir_expression *const r2C84 = nequal(r2C6D, body.constant(0u));
                                    ir_expression *const r2C85 = expr(ir_unop_b2i, r2C84);
                                    ir_expression *const r2C86 = expr(ir_unop_i2u, r2C85);
                                    body.emit(assign(r2C6F, bit_or(r2C6F, r2C86), 0x01));


                                 body.instructions = f2C74_parent_instructions;
                                 body.emit(f2C74);

                                 /* END IF */

                                 body.emit(assign(r2C49, r2C71, 0x01));

                                 body.emit(assign(r2C4A, r2C70, 0x01));

                                 body.emit(assign(r2C4B, r2C6F, 0x01));


                              body.instructions = f2C63_parent_instructions;
                              body.emit(f2C63);

                              /* END IF */

                              body.emit(assign(r2C48, sub(r2C48, r2C4C), 0x01));

                              ir_variable *const r2C87 = body.make_temp(glsl_type::int_type, "zExp");
                              body.emit(assign(r2C87, r2C48, 0x01));

                              ir_variable *const r2C88 = body.make_temp(glsl_type::uint_type, "zFrac0");
                              body.emit(assign(r2C88, r2C49, 0x01));

                              ir_variable *const r2C89 = body.make_temp(glsl_type::uint_type, "zFrac1");
                              body.emit(assign(r2C89, r2C4A, 0x01));

                              ir_variable *const r2C8A = body.make_temp(glsl_type::uint_type, "zFrac2");
                              body.emit(assign(r2C8A, r2C4B, 0x01));

                              ir_variable *const r2C8B = body.make_temp(glsl_type::bool_type, "execute_flag");
                              body.emit(assign(r2C8B, body.constant(true), 0x01));

                              ir_variable *const r2C8C = body.make_temp(glsl_type::uvec2_type, "return_value");
                              ir_variable *const r2C8D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                              body.emit(r2C8D);
                              ir_expression *const r2C8E = expr(ir_unop_u2i, r2C4B);
                              body.emit(assign(r2C8D, less(r2C8E, body.constant(int(0))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2C90 = lequal(body.constant(int(2045)), r2C48);
                              ir_if *f2C8F = new(mem_ctx) ir_if(operand(r2C90).val);
                              exec_list *const f2C8F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2C8F->then_instructions;

                                 ir_variable *const r2C91 = body.make_temp(glsl_type::bool_type, "or_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2C93 = less(body.constant(int(2045)), r2C48);
                                 ir_if *f2C92 = new(mem_ctx) ir_if(operand(r2C93).val);
                                 exec_list *const f2C92_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2C92->then_instructions;

                                    body.emit(assign(r2C91, body.constant(true), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2C92->else_instructions;

                                    ir_variable *const r2C94 = body.make_temp(glsl_type::bool_type, "and_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2C96 = equal(r2C48, body.constant(int(2045)));
                                    ir_if *f2C95 = new(mem_ctx) ir_if(operand(r2C96).val);
                                    exec_list *const f2C95_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2C95->then_instructions;

                                       ir_expression *const r2C97 = equal(body.constant(2097151u), r2C49);
                                       ir_expression *const r2C98 = equal(body.constant(4294967295u), r2C4A);
                                       body.emit(assign(r2C94, logic_and(r2C97, r2C98), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2C95->else_instructions;

                                       body.emit(assign(r2C94, body.constant(false), 0x01));


                                    body.instructions = f2C95_parent_instructions;
                                    body.emit(f2C95);

                                    /* END IF */

                                    body.emit(assign(r2C91, logic_and(r2C94, r2C8D), 0x01));


                                 body.instructions = f2C92_parent_instructions;
                                 body.emit(f2C92);

                                 /* END IF */

                                 /* IF CONDITION */
                                 ir_if *f2C99 = new(mem_ctx) ir_if(operand(r2C91).val);
                                 exec_list *const f2C99_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2C99->then_instructions;

                                    ir_variable *const r2C9A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                    body.emit(r2C9A);
                                    ir_expression *const r2C9B = lshift(r2911, body.constant(int(31)));
                                    body.emit(assign(r2C9A, add(r2C9B, body.constant(2146435072u)), 0x02));

                                    body.emit(assign(r2C9A, body.constant(0u), 0x01));

                                    body.emit(assign(r2C8C, r2C9A, 0x03));

                                    body.emit(assign(r2C8B, body.constant(false), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2C99->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2C9D = less(r2C48, body.constant(int(0)));
                                    ir_if *f2C9C = new(mem_ctx) ir_if(operand(r2C9D).val);
                                    exec_list *const f2C9C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2C9C->then_instructions;

                                       ir_variable *const r2C9E = body.make_temp(glsl_type::uint_type, "a2");
                                       body.emit(assign(r2C9E, r2C4B, 0x01));

                                       ir_variable *const r2C9F = body.make_temp(glsl_type::int_type, "count");
                                       body.emit(assign(r2C9F, neg(r2C48), 0x01));

                                       ir_variable *const r2CA0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                       body.emit(r2CA0);
                                       ir_variable *const r2CA1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                       body.emit(r2CA1);
                                       ir_variable *const r2CA2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                       body.emit(r2CA2);
                                       ir_variable *const r2CA3 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                       ir_expression *const r2CA4 = neg(r2C9F);
                                       body.emit(assign(r2CA3, bit_and(r2CA4, body.constant(int(31))), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2CA6 = equal(r2C9F, body.constant(int(0)));
                                       ir_if *f2CA5 = new(mem_ctx) ir_if(operand(r2CA6).val);
                                       exec_list *const f2CA5_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2CA5->then_instructions;

                                          body.emit(assign(r2CA0, r2C4B, 0x01));

                                          body.emit(assign(r2CA1, r2C4A, 0x01));

                                          body.emit(assign(r2CA2, r2C49, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2CA5->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r2CA8 = less(r2C9F, body.constant(int(32)));
                                          ir_if *f2CA7 = new(mem_ctx) ir_if(operand(r2CA8).val);
                                          exec_list *const f2CA7_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2CA7->then_instructions;

                                             body.emit(assign(r2CA0, lshift(r2C4A, r2CA3), 0x01));

                                             ir_expression *const r2CA9 = lshift(r2C49, r2CA3);
                                             ir_expression *const r2CAA = rshift(r2C4A, r2C9F);
                                             body.emit(assign(r2CA1, bit_or(r2CA9, r2CAA), 0x01));

                                             body.emit(assign(r2CA2, rshift(r2C49, r2C9F), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2CA7->else_instructions;

                                             /* IF CONDITION */
                                             ir_expression *const r2CAC = equal(r2C9F, body.constant(int(32)));
                                             ir_if *f2CAB = new(mem_ctx) ir_if(operand(r2CAC).val);
                                             exec_list *const f2CAB_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f2CAB->then_instructions;

                                                body.emit(assign(r2CA0, r2C4A, 0x01));

                                                body.emit(assign(r2CA1, r2C49, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f2CAB->else_instructions;

                                                body.emit(assign(r2C9E, bit_or(r2C4B, r2C4A), 0x01));

                                                /* IF CONDITION */
                                                ir_expression *const r2CAE = less(r2C9F, body.constant(int(64)));
                                                ir_if *f2CAD = new(mem_ctx) ir_if(operand(r2CAE).val);
                                                exec_list *const f2CAD_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f2CAD->then_instructions;

                                                   body.emit(assign(r2CA0, lshift(r2C49, r2CA3), 0x01));

                                                   ir_expression *const r2CAF = bit_and(r2C9F, body.constant(int(31)));
                                                   body.emit(assign(r2CA1, rshift(r2C49, r2CAF), 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f2CAD->else_instructions;

                                                   ir_variable *const r2CB0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                   /* IF CONDITION */
                                                   ir_expression *const r2CB2 = equal(r2C9F, body.constant(int(64)));
                                                   ir_if *f2CB1 = new(mem_ctx) ir_if(operand(r2CB2).val);
                                                   exec_list *const f2CB1_parent_instructions = body.instructions;

                                                      /* THEN INSTRUCTIONS */
                                                      body.instructions = &f2CB1->then_instructions;

                                                      body.emit(assign(r2CB0, r2C49, 0x01));


                                                      /* ELSE INSTRUCTIONS */
                                                      body.instructions = &f2CB1->else_instructions;

                                                      ir_expression *const r2CB3 = nequal(r2C49, body.constant(0u));
                                                      ir_expression *const r2CB4 = expr(ir_unop_b2i, r2CB3);
                                                      body.emit(assign(r2CB0, expr(ir_unop_i2u, r2CB4), 0x01));


                                                   body.instructions = f2CB1_parent_instructions;
                                                   body.emit(f2CB1);

                                                   /* END IF */

                                                   body.emit(assign(r2CA0, r2CB0, 0x01));

                                                   body.emit(assign(r2CA1, body.constant(0u), 0x01));


                                                body.instructions = f2CAD_parent_instructions;
                                                body.emit(f2CAD);

                                                /* END IF */


                                             body.instructions = f2CAB_parent_instructions;
                                             body.emit(f2CAB);

                                             /* END IF */

                                             body.emit(assign(r2CA2, body.constant(0u), 0x01));


                                          body.instructions = f2CA7_parent_instructions;
                                          body.emit(f2CA7);

                                          /* END IF */

                                          ir_expression *const r2CB5 = nequal(r2C9E, body.constant(0u));
                                          ir_expression *const r2CB6 = expr(ir_unop_b2i, r2CB5);
                                          ir_expression *const r2CB7 = expr(ir_unop_i2u, r2CB6);
                                          body.emit(assign(r2CA0, bit_or(r2CA0, r2CB7), 0x01));


                                       body.instructions = f2CA5_parent_instructions;
                                       body.emit(f2CA5);

                                       /* END IF */

                                       body.emit(assign(r2C88, r2CA2, 0x01));

                                       body.emit(assign(r2C89, r2CA1, 0x01));

                                       body.emit(assign(r2C8A, r2CA0, 0x01));

                                       body.emit(assign(r2C87, body.constant(int(0)), 0x01));

                                       body.emit(assign(r2C8D, less(r2CA0, body.constant(0u)), 0x01));


                                    body.instructions = f2C9C_parent_instructions;
                                    body.emit(f2C9C);

                                    /* END IF */


                                 body.instructions = f2C99_parent_instructions;
                                 body.emit(f2C99);

                                 /* END IF */


                              body.instructions = f2C8F_parent_instructions;
                              body.emit(f2C8F);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f2CB8 = new(mem_ctx) ir_if(operand(r2C8B).val);
                              exec_list *const f2CB8_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2CB8->then_instructions;

                                 /* IF CONDITION */
                                 ir_if *f2CB9 = new(mem_ctx) ir_if(operand(r2C8D).val);
                                 exec_list *const f2CB9_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2CB9->then_instructions;

                                    ir_variable *const r2CBA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                    body.emit(assign(r2CBA, add(r2C89, body.constant(1u)), 0x01));

                                    ir_expression *const r2CBB = less(r2CBA, r2C89);
                                    ir_expression *const r2CBC = expr(ir_unop_b2i, r2CBB);
                                    ir_expression *const r2CBD = expr(ir_unop_i2u, r2CBC);
                                    body.emit(assign(r2C88, add(r2C88, r2CBD), 0x01));

                                    ir_expression *const r2CBE = equal(r2C8A, body.constant(0u));
                                    ir_expression *const r2CBF = expr(ir_unop_b2i, r2CBE);
                                    ir_expression *const r2CC0 = expr(ir_unop_i2u, r2CBF);
                                    ir_expression *const r2CC1 = add(r2C8A, r2CC0);
                                    ir_expression *const r2CC2 = bit_and(r2CC1, body.constant(1u));
                                    ir_expression *const r2CC3 = expr(ir_unop_bit_not, r2CC2);
                                    body.emit(assign(r2C89, bit_and(r2CBA, r2CC3), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2CB9->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2CC5 = bit_or(r2C88, r2C89);
                                    ir_expression *const r2CC6 = equal(r2CC5, body.constant(0u));
                                    ir_if *f2CC4 = new(mem_ctx) ir_if(operand(r2CC6).val);
                                    exec_list *const f2CC4_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2CC4->then_instructions;

                                       body.emit(assign(r2C87, body.constant(int(0)), 0x01));


                                    body.instructions = f2CC4_parent_instructions;
                                    body.emit(f2CC4);

                                    /* END IF */


                                 body.instructions = f2CB9_parent_instructions;
                                 body.emit(f2CB9);

                                 /* END IF */

                                 ir_variable *const r2CC7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r2CC7);
                                 ir_expression *const r2CC8 = lshift(r2911, body.constant(int(31)));
                                 ir_expression *const r2CC9 = expr(ir_unop_i2u, r2C87);
                                 ir_expression *const r2CCA = lshift(r2CC9, body.constant(int(20)));
                                 ir_expression *const r2CCB = add(r2CC8, r2CCA);
                                 body.emit(assign(r2CC7, add(r2CCB, r2C88), 0x02));

                                 body.emit(assign(r2CC7, r2C89, 0x01));

                                 body.emit(assign(r2C8C, r2CC7, 0x03));

                                 body.emit(assign(r2C8B, body.constant(false), 0x01));


                              body.instructions = f2CB8_parent_instructions;
                              body.emit(f2CB8);

                              /* END IF */

                              body.emit(assign(r2912, r2C8C, 0x03));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2C40->else_instructions;

                              ir_variable *const r2CCC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r2CCC);
                              body.emit(assign(r2CCC, body.constant(0u), 0x02));

                              body.emit(assign(r2CCC, body.constant(0u), 0x01));

                              body.emit(assign(r2912, r2CCC, 0x03));


                           body.instructions = f2C40_parent_instructions;
                           body.emit(f2C40);

                           /* END IF */


                        body.instructions = f2BB4_parent_instructions;
                        body.emit(f2BB4);

                        /* END IF */


                     body.instructions = f2B28_parent_instructions;
                     body.emit(f2B28);

                     /* END IF */


                  body.instructions = f2A9C_parent_instructions;
                  body.emit(f2A9C);

                  /* END IF */


               body.instructions = f2A87_parent_instructions;
               body.emit(f2A87);

               /* END IF */


            body.instructions = f29D6_parent_instructions;
            body.emit(f29D6);

            /* END IF */


         body.instructions = f2923_parent_instructions;
         body.emit(f2923);

         /* END IF */

         body.emit(assign(r290D, r2912, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f290F->else_instructions;

         ir_variable *const r2CCD = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r2CCD, body.constant(true), 0x01));

         ir_variable *const r2CCE = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r2CCF = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
         body.emit(r2CCF);
         ir_variable *const r2CD0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
         body.emit(r2CD0);
         ir_variable *const r2CD1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
         body.emit(r2CD1);
         ir_variable *const r2CD2 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
         body.emit(r2CD2);
         ir_variable *const r2CD3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
         body.emit(r2CD3);
         ir_variable *const r2CD4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
         body.emit(r2CD4);
         body.emit(assign(r2CD4, body.constant(0u), 0x01));

         body.emit(assign(r2CD3, body.constant(0u), 0x01));

         ir_variable *const r2CD5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
         body.emit(r2CD5);
         body.emit(assign(r2CD5, bit_and(swizzle_y(r28D8), body.constant(1048575u)), 0x02));

         body.emit(assign(r2CD5, swizzle_x(r28D8), 0x01));

         body.emit(assign(r2CD1, r2CD5, 0x03));

         ir_variable *const r2CD6 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         ir_expression *const r2CD7 = rshift(swizzle_y(r28D8), body.constant(int(20)));
         ir_expression *const r2CD8 = bit_and(r2CD7, body.constant(2047u));
         body.emit(assign(r2CD6, expr(ir_unop_u2i, r2CD8), 0x01));

         ir_variable *const r2CD9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
         body.emit(r2CD9);
         body.emit(assign(r2CD9, body.constant(0u), 0x02));

         body.emit(assign(r2CD9, body.constant(0u), 0x01));

         body.emit(assign(r2CD0, r2CD9, 0x03));

         ir_variable *const r2CDA = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
         body.emit(assign(r2CDA, body.constant(int(1023)), 0x01));

         ir_variable *const r2CDB = body.make_temp(glsl_type::int_type, "assignment_tmp");
         body.emit(assign(r2CDB, add(r2CD6, body.constant(int(-1023))), 0x01));

         body.emit(assign(r2CCF, r2CDB, 0x01));

         /* IF CONDITION */
         ir_expression *const r2CDD = less(body.constant(int(0)), r2CDB);
         ir_if *f2CDC = new(mem_ctx) ir_if(operand(r2CDD).val);
         exec_list *const f2CDC_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2CDC->then_instructions;

            /* IF CONDITION */
            ir_expression *const r2CDF = equal(r2CD6, body.constant(int(2047)));
            ir_if *f2CDE = new(mem_ctx) ir_if(operand(r2CDF).val);
            exec_list *const f2CDE_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2CDE->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2CE1 = bit_or(swizzle_y(r2CD5), swizzle_x(r28D8));
               ir_expression *const r2CE2 = nequal(r2CE1, body.constant(0u));
               ir_if *f2CE0 = new(mem_ctx) ir_if(operand(r2CE2).val);
               exec_list *const f2CE0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2CE0->then_instructions;

                  ir_variable *const r2CE3 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r2CE3, swizzle_x(r28D8), 0x01));

                  ir_variable *const r2CE4 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r2CE4, body.constant(0u), 0x01));

                  ir_variable *const r2CE5 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  body.emit(assign(r2CE3, bit_or(swizzle_y(r28D8), body.constant(524288u)), 0x02));

                  body.emit(assign(r2CE4, body.constant(1073217536u), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r2CE7 = lshift(swizzle_y(r28D8), body.constant(int(1)));
                  ir_expression *const r2CE8 = lequal(body.constant(4292870144u), r2CE7);
                  ir_expression *const r2CE9 = nequal(swizzle_x(r28D8), body.constant(0u));
                  ir_expression *const r2CEA = bit_and(swizzle_y(r28D8), body.constant(1048575u));
                  ir_expression *const r2CEB = nequal(r2CEA, body.constant(0u));
                  ir_expression *const r2CEC = logic_or(r2CE9, r2CEB);
                  ir_expression *const r2CED = logic_and(r2CE8, r2CEC);
                  ir_if *f2CE6 = new(mem_ctx) ir_if(operand(r2CED).val);
                  exec_list *const f2CE6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2CE6->then_instructions;

                     body.emit(assign(r2CE5, r2CE3, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2CE6->else_instructions;

                     body.emit(assign(r2CE5, r2CE4, 0x03));


                  body.instructions = f2CE6_parent_instructions;
                  body.emit(f2CE6);

                  /* END IF */

                  body.emit(assign(r2CCE, r2CE5, 0x03));

                  body.emit(assign(r2CCD, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2CE0->else_instructions;

                  body.emit(assign(r2CCE, r28D8, 0x03));

                  body.emit(assign(r2CCD, body.constant(false), 0x01));


               body.instructions = f2CE0_parent_instructions;
               body.emit(f2CE0);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2CDE->else_instructions;

               body.emit(assign(r2CD0, body.constant(1048576u), 0x02));

               ir_variable *const r2CEE = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r2CEE, swizzle_y(r2CD0), 0x01));

               ir_variable *const r2CEF = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r2CEF, swizzle_x(r2CD0), 0x01));

               ir_variable *const r2CF0 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r2CF0, body.constant(0u), 0x01));

               ir_variable *const r2CF1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r2CF1);
               ir_variable *const r2CF2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2CF2);
               ir_variable *const r2CF3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2CF3);
               ir_variable *const r2CF4 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2CF5 = neg(r2CDB);
               body.emit(assign(r2CF4, bit_and(r2CF5, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2CF7 = equal(r2CDB, body.constant(int(0)));
               ir_if *f2CF6 = new(mem_ctx) ir_if(operand(r2CF7).val);
               exec_list *const f2CF6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2CF6->then_instructions;

                  body.emit(assign(r2CF1, r2CF0, 0x01));

                  body.emit(assign(r2CF2, r2CEF, 0x01));

                  body.emit(assign(r2CF3, r2CEE, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2CF6->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2CF9 = less(r2CDB, body.constant(int(32)));
                  ir_if *f2CF8 = new(mem_ctx) ir_if(operand(r2CF9).val);
                  exec_list *const f2CF8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2CF8->then_instructions;

                     body.emit(assign(r2CF1, body.constant(0u), 0x01));

                     ir_expression *const r2CFA = lshift(body.constant(1048576u), r2CF4);
                     body.emit(assign(r2CF2, bit_or(r2CFA, body.constant(0u)), 0x01));

                     body.emit(assign(r2CF3, rshift(body.constant(1048576u), r2CDB), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2CF8->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2CFC = equal(r2CDB, body.constant(int(32)));
                     ir_if *f2CFB = new(mem_ctx) ir_if(operand(r2CFC).val);
                     exec_list *const f2CFB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2CFB->then_instructions;

                        body.emit(assign(r2CF1, r2CEF, 0x01));

                        body.emit(assign(r2CF2, r2CEE, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2CFB->else_instructions;

                        body.emit(assign(r2CF0, body.constant(0u), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2CFE = less(r2CDB, body.constant(int(64)));
                        ir_if *f2CFD = new(mem_ctx) ir_if(operand(r2CFE).val);
                        exec_list *const f2CFD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2CFD->then_instructions;

                           body.emit(assign(r2CF1, lshift(body.constant(1048576u), r2CF4), 0x01));

                           ir_expression *const r2CFF = bit_and(r2CDB, body.constant(int(31)));
                           body.emit(assign(r2CF2, rshift(body.constant(1048576u), r2CFF), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2CFD->else_instructions;

                           ir_variable *const r2D00 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2D02 = equal(r2CDB, body.constant(int(64)));
                           ir_if *f2D01 = new(mem_ctx) ir_if(operand(r2D02).val);
                           exec_list *const f2D01_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2D01->then_instructions;

                              body.emit(assign(r2D00, r2CEE, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2D01->else_instructions;

                              body.emit(assign(r2D00, body.constant(1u), 0x01));


                           body.instructions = f2D01_parent_instructions;
                           body.emit(f2D01);

                           /* END IF */

                           body.emit(assign(r2CF1, r2D00, 0x01));

                           body.emit(assign(r2CF2, body.constant(0u), 0x01));


                        body.instructions = f2CFD_parent_instructions;
                        body.emit(f2CFD);

                        /* END IF */


                     body.instructions = f2CFB_parent_instructions;
                     body.emit(f2CFB);

                     /* END IF */

                     body.emit(assign(r2CF3, body.constant(0u), 0x01));


                  body.instructions = f2CF8_parent_instructions;
                  body.emit(f2CF8);

                  /* END IF */

                  ir_expression *const r2D03 = nequal(r2CF0, body.constant(0u));
                  ir_expression *const r2D04 = expr(ir_unop_b2i, r2D03);
                  ir_expression *const r2D05 = expr(ir_unop_i2u, r2D04);
                  body.emit(assign(r2CF1, bit_or(r2CF1, r2D05), 0x01));


               body.instructions = f2CF6_parent_instructions;
               body.emit(f2CF6);

               /* END IF */

               body.emit(assign(r2CD0, r2CF3, 0x02));

               body.emit(assign(r2CD0, r2CF2, 0x01));

               body.emit(assign(r2CD3, r2CF1, 0x01));

               body.emit(assign(r2CD2, r2CD6, 0x01));


            body.instructions = f2CDE_parent_instructions;
            body.emit(f2CDE);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2CDC->else_instructions;

            /* IF CONDITION */
            ir_expression *const r2D07 = less(r2CDB, body.constant(int(0)));
            ir_if *f2D06 = new(mem_ctx) ir_if(operand(r2D07).val);
            exec_list *const f2D06_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2D06->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2D09 = equal(r2CD6, body.constant(int(0)));
               ir_if *f2D08 = new(mem_ctx) ir_if(operand(r2D09).val);
               exec_list *const f2D08_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2D08->then_instructions;

                  body.emit(assign(r2CCF, add(r2CDB, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2D08->else_instructions;

                  body.emit(assign(r2CD1, bit_or(swizzle_y(r2CD5), body.constant(1048576u)), 0x02));


               body.instructions = f2D08_parent_instructions;
               body.emit(f2D08);

               /* END IF */

               ir_variable *const r2D0A = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r2D0A, swizzle_y(r2CD1), 0x01));

               ir_variable *const r2D0B = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r2D0B, swizzle_x(r2CD1), 0x01));

               ir_variable *const r2D0C = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r2D0C, body.constant(0u), 0x01));

               ir_variable *const r2D0D = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r2D0D, neg(r2CCF), 0x01));

               ir_variable *const r2D0E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r2D0E);
               ir_variable *const r2D0F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2D0F);
               ir_variable *const r2D10 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2D10);
               ir_variable *const r2D11 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2D12 = neg(r2D0D);
               body.emit(assign(r2D11, bit_and(r2D12, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2D14 = equal(r2D0D, body.constant(int(0)));
               ir_if *f2D13 = new(mem_ctx) ir_if(operand(r2D14).val);
               exec_list *const f2D13_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2D13->then_instructions;

                  body.emit(assign(r2D0E, r2D0C, 0x01));

                  body.emit(assign(r2D0F, r2D0B, 0x01));

                  body.emit(assign(r2D10, r2D0A, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2D13->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2D16 = less(r2D0D, body.constant(int(32)));
                  ir_if *f2D15 = new(mem_ctx) ir_if(operand(r2D16).val);
                  exec_list *const f2D15_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2D15->then_instructions;

                     body.emit(assign(r2D0E, lshift(swizzle_x(r2CD5), r2D11), 0x01));

                     ir_expression *const r2D17 = lshift(swizzle_y(r2CD1), r2D11);
                     ir_expression *const r2D18 = rshift(swizzle_x(r2CD5), r2D0D);
                     body.emit(assign(r2D0F, bit_or(r2D17, r2D18), 0x01));

                     body.emit(assign(r2D10, rshift(swizzle_y(r2CD1), r2D0D), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2D15->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2D1A = equal(r2D0D, body.constant(int(32)));
                     ir_if *f2D19 = new(mem_ctx) ir_if(operand(r2D1A).val);
                     exec_list *const f2D19_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2D19->then_instructions;

                        body.emit(assign(r2D0E, r2D0B, 0x01));

                        body.emit(assign(r2D0F, r2D0A, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2D19->else_instructions;

                        body.emit(assign(r2D0C, bit_or(body.constant(0u), swizzle_x(r2CD5)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2D1C = less(r2D0D, body.constant(int(64)));
                        ir_if *f2D1B = new(mem_ctx) ir_if(operand(r2D1C).val);
                        exec_list *const f2D1B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2D1B->then_instructions;

                           body.emit(assign(r2D0E, lshift(swizzle_y(r2CD1), r2D11), 0x01));

                           ir_expression *const r2D1D = bit_and(r2D0D, body.constant(int(31)));
                           body.emit(assign(r2D0F, rshift(swizzle_y(r2CD1), r2D1D), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2D1B->else_instructions;

                           ir_variable *const r2D1E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2D20 = equal(r2D0D, body.constant(int(64)));
                           ir_if *f2D1F = new(mem_ctx) ir_if(operand(r2D20).val);
                           exec_list *const f2D1F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2D1F->then_instructions;

                              body.emit(assign(r2D1E, r2D0A, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2D1F->else_instructions;

                              ir_expression *const r2D21 = nequal(swizzle_y(r2CD1), body.constant(0u));
                              ir_expression *const r2D22 = expr(ir_unop_b2i, r2D21);
                              body.emit(assign(r2D1E, expr(ir_unop_i2u, r2D22), 0x01));


                           body.instructions = f2D1F_parent_instructions;
                           body.emit(f2D1F);

                           /* END IF */

                           body.emit(assign(r2D0E, r2D1E, 0x01));

                           body.emit(assign(r2D0F, body.constant(0u), 0x01));


                        body.instructions = f2D1B_parent_instructions;
                        body.emit(f2D1B);

                        /* END IF */


                     body.instructions = f2D19_parent_instructions;
                     body.emit(f2D19);

                     /* END IF */

                     body.emit(assign(r2D10, body.constant(0u), 0x01));


                  body.instructions = f2D15_parent_instructions;
                  body.emit(f2D15);

                  /* END IF */

                  ir_expression *const r2D23 = nequal(r2D0C, body.constant(0u));
                  ir_expression *const r2D24 = expr(ir_unop_b2i, r2D23);
                  ir_expression *const r2D25 = expr(ir_unop_i2u, r2D24);
                  body.emit(assign(r2D0E, bit_or(r2D0E, r2D25), 0x01));


               body.instructions = f2D13_parent_instructions;
               body.emit(f2D13);

               /* END IF */

               body.emit(assign(r2CD1, r2D10, 0x02));

               body.emit(assign(r2CD1, r2D0F, 0x01));

               body.emit(assign(r2CD3, r2D0E, 0x01));

               body.emit(assign(r2CD2, body.constant(int(1023)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2D06->else_instructions;

               /* IF CONDITION */
               ir_expression *const r2D27 = equal(r2CD6, body.constant(int(2047)));
               ir_if *f2D26 = new(mem_ctx) ir_if(operand(r2D27).val);
               exec_list *const f2D26_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2D26->then_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2D29 = bit_or(swizzle_y(r2CD1), swizzle_x(r2CD1));
                  ir_expression *const r2D2A = bit_or(swizzle_y(r2CD0), swizzle_x(r2CD0));
                  ir_expression *const r2D2B = bit_or(r2D29, r2D2A);
                  ir_expression *const r2D2C = nequal(r2D2B, body.constant(0u));
                  ir_if *f2D28 = new(mem_ctx) ir_if(operand(r2D2C).val);
                  exec_list *const f2D28_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2D28->then_instructions;

                     ir_variable *const r2D2D = body.make_temp(glsl_type::uvec2_type, "a");
                     body.emit(assign(r2D2D, swizzle_x(r28D8), 0x01));

                     ir_variable *const r2D2E = body.make_temp(glsl_type::uvec2_type, "b");
                     body.emit(assign(r2D2E, body.constant(0u), 0x01));

                     ir_variable *const r2D2F = body.make_temp(glsl_type::uvec2_type, "return_value");
                     body.emit(assign(r2D2D, bit_or(swizzle_y(r28D8), body.constant(524288u)), 0x02));

                     body.emit(assign(r2D2E, body.constant(1073217536u), 0x02));

                     /* IF CONDITION */
                     ir_expression *const r2D31 = lshift(swizzle_y(r28D8), body.constant(int(1)));
                     ir_expression *const r2D32 = lequal(body.constant(4292870144u), r2D31);
                     ir_expression *const r2D33 = nequal(swizzle_x(r28D8), body.constant(0u));
                     ir_expression *const r2D34 = bit_and(swizzle_y(r28D8), body.constant(1048575u));
                     ir_expression *const r2D35 = nequal(r2D34, body.constant(0u));
                     ir_expression *const r2D36 = logic_or(r2D33, r2D35);
                     ir_expression *const r2D37 = logic_and(r2D32, r2D36);
                     ir_if *f2D30 = new(mem_ctx) ir_if(operand(r2D37).val);
                     exec_list *const f2D30_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2D30->then_instructions;

                        body.emit(assign(r2D2F, r2D2D, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2D30->else_instructions;

                        body.emit(assign(r2D2F, r2D2E, 0x03));


                     body.instructions = f2D30_parent_instructions;
                     body.emit(f2D30);

                     /* END IF */

                     body.emit(assign(r2CCE, r2D2F, 0x03));

                     body.emit(assign(r2CCD, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2D28->else_instructions;

                     body.emit(assign(r2CCE, r28D8, 0x03));

                     body.emit(assign(r2CCD, body.constant(false), 0x01));


                  body.instructions = f2D28_parent_instructions;
                  body.emit(f2D28);

                  /* END IF */


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2D26->else_instructions;

                  ir_variable *const r2D38 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r2D39 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2D39, add(swizzle_x(r2CD1), swizzle_x(r2CD0)), 0x01));

                  ir_expression *const r2D3A = add(swizzle_y(r2CD1), swizzle_y(r2CD0));
                  ir_expression *const r2D3B = less(r2D39, swizzle_x(r2CD1));
                  ir_expression *const r2D3C = expr(ir_unop_b2i, r2D3B);
                  ir_expression *const r2D3D = expr(ir_unop_i2u, r2D3C);
                  body.emit(assign(r2D38, add(r2D3A, r2D3D), 0x01));

                  body.emit(assign(r2CD4, r2D38, 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2D3F = equal(r2CD6, body.constant(int(0)));
                  ir_if *f2D3E = new(mem_ctx) ir_if(operand(r2D3F).val);
                  exec_list *const f2D3E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2D3E->then_instructions;

                     ir_variable *const r2D40 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2D40);
                     ir_expression *const r2D41 = lshift(r290E, body.constant(int(31)));
                     body.emit(assign(r2D40, add(r2D41, r2D38), 0x02));

                     body.emit(assign(r2D40, r2D39, 0x01));

                     body.emit(assign(r2CCE, r2D40, 0x03));

                     body.emit(assign(r2CCD, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2D3E->else_instructions;

                     body.emit(assign(r2CD4, bit_or(r2D38, body.constant(2097152u)), 0x01));

                     body.emit(assign(r2CD2, r2CD6, 0x01));

                     ir_variable *const r2D42 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r2D42);
                     ir_variable *const r2D43 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r2D43);
                     ir_variable *const r2D44 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r2D44);
                     body.emit(assign(r2D42, lshift(r2D39, body.constant(int(31))), 0x01));

                     ir_expression *const r2D45 = lshift(r2CD4, body.constant(int(31)));
                     ir_expression *const r2D46 = rshift(r2D39, body.constant(int(1)));
                     body.emit(assign(r2D43, bit_or(r2D45, r2D46), 0x01));

                     body.emit(assign(r2D44, rshift(r2CD4, body.constant(int(1))), 0x01));

                     body.emit(assign(r2D42, bit_or(r2D42, body.constant(0u)), 0x01));

                     body.emit(assign(r2CD4, r2D44, 0x01));

                     body.emit(assign(r2CD3, r2D42, 0x01));

                     ir_variable *const r2D47 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r2D47, r2CD6, 0x01));

                     ir_variable *const r2D48 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r2D48, r2D44, 0x01));

                     ir_variable *const r2D49 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r2D49, r2D43, 0x01));

                     ir_variable *const r2D4A = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r2D4A, r2D42, 0x01));

                     ir_variable *const r2D4B = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r2D4B, body.constant(true), 0x01));

                     ir_variable *const r2D4C = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r2D4D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r2D4D);
                     ir_expression *const r2D4E = expr(ir_unop_u2i, r2D42);
                     body.emit(assign(r2D4D, less(r2D4E, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2D50 = lequal(body.constant(int(2045)), r2CD6);
                     ir_if *f2D4F = new(mem_ctx) ir_if(operand(r2D50).val);
                     exec_list *const f2D4F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2D4F->then_instructions;

                        ir_variable *const r2D51 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r2D53 = less(body.constant(int(2045)), r2CD6);
                        ir_if *f2D52 = new(mem_ctx) ir_if(operand(r2D53).val);
                        exec_list *const f2D52_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2D52->then_instructions;

                           body.emit(assign(r2D51, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2D52->else_instructions;

                           ir_variable *const r2D54 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2D56 = equal(r2CD6, body.constant(int(2045)));
                           ir_if *f2D55 = new(mem_ctx) ir_if(operand(r2D56).val);
                           exec_list *const f2D55_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2D55->then_instructions;

                              ir_expression *const r2D57 = equal(body.constant(2097151u), r2D44);
                              ir_expression *const r2D58 = equal(body.constant(4294967295u), r2D43);
                              body.emit(assign(r2D54, logic_and(r2D57, r2D58), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2D55->else_instructions;

                              body.emit(assign(r2D54, body.constant(false), 0x01));


                           body.instructions = f2D55_parent_instructions;
                           body.emit(f2D55);

                           /* END IF */

                           body.emit(assign(r2D51, logic_and(r2D54, r2D4D), 0x01));


                        body.instructions = f2D52_parent_instructions;
                        body.emit(f2D52);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f2D59 = new(mem_ctx) ir_if(operand(r2D51).val);
                        exec_list *const f2D59_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2D59->then_instructions;

                           ir_variable *const r2D5A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r2D5A);
                           ir_expression *const r2D5B = lshift(r290E, body.constant(int(31)));
                           body.emit(assign(r2D5A, add(r2D5B, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r2D5A, body.constant(0u), 0x01));

                           body.emit(assign(r2D4C, r2D5A, 0x03));

                           body.emit(assign(r2D4B, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2D59->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2D5D = less(r2CD6, body.constant(int(0)));
                           ir_if *f2D5C = new(mem_ctx) ir_if(operand(r2D5D).val);
                           exec_list *const f2D5C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2D5C->then_instructions;

                              ir_variable *const r2D5E = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r2D5E, r2D42, 0x01));

                              ir_variable *const r2D5F = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r2D5F, neg(r2CD6), 0x01));

                              ir_variable *const r2D60 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r2D60);
                              ir_variable *const r2D61 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r2D61);
                              ir_variable *const r2D62 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r2D62);
                              ir_variable *const r2D63 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r2D64 = neg(r2D5F);
                              body.emit(assign(r2D63, bit_and(r2D64, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2D66 = equal(r2D5F, body.constant(int(0)));
                              ir_if *f2D65 = new(mem_ctx) ir_if(operand(r2D66).val);
                              exec_list *const f2D65_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2D65->then_instructions;

                                 body.emit(assign(r2D60, r2D42, 0x01));

                                 body.emit(assign(r2D61, r2D43, 0x01));

                                 body.emit(assign(r2D62, r2D44, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2D65->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r2D68 = less(r2D5F, body.constant(int(32)));
                                 ir_if *f2D67 = new(mem_ctx) ir_if(operand(r2D68).val);
                                 exec_list *const f2D67_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2D67->then_instructions;

                                    body.emit(assign(r2D60, lshift(r2D43, r2D63), 0x01));

                                    ir_expression *const r2D69 = lshift(r2D44, r2D63);
                                    ir_expression *const r2D6A = rshift(r2D43, r2D5F);
                                    body.emit(assign(r2D61, bit_or(r2D69, r2D6A), 0x01));

                                    body.emit(assign(r2D62, rshift(r2D44, r2D5F), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2D67->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r2D6C = equal(r2D5F, body.constant(int(32)));
                                    ir_if *f2D6B = new(mem_ctx) ir_if(operand(r2D6C).val);
                                    exec_list *const f2D6B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2D6B->then_instructions;

                                       body.emit(assign(r2D60, r2D43, 0x01));

                                       body.emit(assign(r2D61, r2D44, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2D6B->else_instructions;

                                       body.emit(assign(r2D5E, bit_or(r2D42, r2D43), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r2D6E = less(r2D5F, body.constant(int(64)));
                                       ir_if *f2D6D = new(mem_ctx) ir_if(operand(r2D6E).val);
                                       exec_list *const f2D6D_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f2D6D->then_instructions;

                                          body.emit(assign(r2D60, lshift(r2D44, r2D63), 0x01));

                                          ir_expression *const r2D6F = bit_and(r2D5F, body.constant(int(31)));
                                          body.emit(assign(r2D61, rshift(r2D44, r2D6F), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f2D6D->else_instructions;

                                          ir_variable *const r2D70 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r2D72 = equal(r2D5F, body.constant(int(64)));
                                          ir_if *f2D71 = new(mem_ctx) ir_if(operand(r2D72).val);
                                          exec_list *const f2D71_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f2D71->then_instructions;

                                             body.emit(assign(r2D70, r2D44, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f2D71->else_instructions;

                                             ir_expression *const r2D73 = nequal(r2D44, body.constant(0u));
                                             ir_expression *const r2D74 = expr(ir_unop_b2i, r2D73);
                                             body.emit(assign(r2D70, expr(ir_unop_i2u, r2D74), 0x01));


                                          body.instructions = f2D71_parent_instructions;
                                          body.emit(f2D71);

                                          /* END IF */

                                          body.emit(assign(r2D60, r2D70, 0x01));

                                          body.emit(assign(r2D61, body.constant(0u), 0x01));


                                       body.instructions = f2D6D_parent_instructions;
                                       body.emit(f2D6D);

                                       /* END IF */


                                    body.instructions = f2D6B_parent_instructions;
                                    body.emit(f2D6B);

                                    /* END IF */

                                    body.emit(assign(r2D62, body.constant(0u), 0x01));


                                 body.instructions = f2D67_parent_instructions;
                                 body.emit(f2D67);

                                 /* END IF */

                                 ir_expression *const r2D75 = nequal(r2D5E, body.constant(0u));
                                 ir_expression *const r2D76 = expr(ir_unop_b2i, r2D75);
                                 ir_expression *const r2D77 = expr(ir_unop_i2u, r2D76);
                                 body.emit(assign(r2D60, bit_or(r2D60, r2D77), 0x01));


                              body.instructions = f2D65_parent_instructions;
                              body.emit(f2D65);

                              /* END IF */

                              body.emit(assign(r2D48, r2D62, 0x01));

                              body.emit(assign(r2D49, r2D61, 0x01));

                              body.emit(assign(r2D4A, r2D60, 0x01));

                              body.emit(assign(r2D47, body.constant(int(0)), 0x01));

                              body.emit(assign(r2D4D, less(r2D60, body.constant(0u)), 0x01));


                           body.instructions = f2D5C_parent_instructions;
                           body.emit(f2D5C);

                           /* END IF */


                        body.instructions = f2D59_parent_instructions;
                        body.emit(f2D59);

                        /* END IF */


                     body.instructions = f2D4F_parent_instructions;
                     body.emit(f2D4F);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f2D78 = new(mem_ctx) ir_if(operand(r2D4B).val);
                     exec_list *const f2D78_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2D78->then_instructions;

                        /* IF CONDITION */
                        ir_if *f2D79 = new(mem_ctx) ir_if(operand(r2D4D).val);
                        exec_list *const f2D79_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2D79->then_instructions;

                           ir_variable *const r2D7A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r2D7A, add(r2D49, body.constant(1u)), 0x01));

                           ir_expression *const r2D7B = less(r2D7A, r2D49);
                           ir_expression *const r2D7C = expr(ir_unop_b2i, r2D7B);
                           ir_expression *const r2D7D = expr(ir_unop_i2u, r2D7C);
                           body.emit(assign(r2D48, add(r2D48, r2D7D), 0x01));

                           ir_expression *const r2D7E = equal(r2D4A, body.constant(0u));
                           ir_expression *const r2D7F = expr(ir_unop_b2i, r2D7E);
                           ir_expression *const r2D80 = expr(ir_unop_i2u, r2D7F);
                           ir_expression *const r2D81 = add(r2D4A, r2D80);
                           ir_expression *const r2D82 = bit_and(r2D81, body.constant(1u));
                           ir_expression *const r2D83 = expr(ir_unop_bit_not, r2D82);
                           body.emit(assign(r2D49, bit_and(r2D7A, r2D83), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2D79->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2D85 = bit_or(r2D48, r2D49);
                           ir_expression *const r2D86 = equal(r2D85, body.constant(0u));
                           ir_if *f2D84 = new(mem_ctx) ir_if(operand(r2D86).val);
                           exec_list *const f2D84_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2D84->then_instructions;

                              body.emit(assign(r2D47, body.constant(int(0)), 0x01));


                           body.instructions = f2D84_parent_instructions;
                           body.emit(f2D84);

                           /* END IF */


                        body.instructions = f2D79_parent_instructions;
                        body.emit(f2D79);

                        /* END IF */

                        ir_variable *const r2D87 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r2D87);
                        ir_expression *const r2D88 = lshift(r290E, body.constant(int(31)));
                        ir_expression *const r2D89 = expr(ir_unop_i2u, r2D47);
                        ir_expression *const r2D8A = lshift(r2D89, body.constant(int(20)));
                        ir_expression *const r2D8B = add(r2D88, r2D8A);
                        body.emit(assign(r2D87, add(r2D8B, r2D48), 0x02));

                        body.emit(assign(r2D87, r2D49, 0x01));

                        body.emit(assign(r2D4C, r2D87, 0x03));

                        body.emit(assign(r2D4B, body.constant(false), 0x01));


                     body.instructions = f2D78_parent_instructions;
                     body.emit(f2D78);

                     /* END IF */

                     body.emit(assign(r2CCE, r2D4C, 0x03));

                     body.emit(assign(r2CCD, body.constant(false), 0x01));


                  body.instructions = f2D3E_parent_instructions;
                  body.emit(f2D3E);

                  /* END IF */


               body.instructions = f2D26_parent_instructions;
               body.emit(f2D26);

               /* END IF */


            body.instructions = f2D06_parent_instructions;
            body.emit(f2D06);

            /* END IF */


         body.instructions = f2CDC_parent_instructions;
         body.emit(f2CDC);

         /* END IF */

         /* IF CONDITION */
         ir_if *f2D8C = new(mem_ctx) ir_if(operand(r2CCD).val);
         exec_list *const f2D8C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2D8C->then_instructions;

            body.emit(assign(r2CD1, bit_or(swizzle_y(r2CD1), body.constant(1048576u)), 0x02));

            ir_variable *const r2D8D = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r2D8E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r2D8E, add(swizzle_x(r2CD1), swizzle_x(r2CD0)), 0x01));

            ir_expression *const r2D8F = add(swizzle_y(r2CD1), swizzle_y(r2CD0));
            ir_expression *const r2D90 = less(r2D8E, swizzle_x(r2CD1));
            ir_expression *const r2D91 = expr(ir_unop_b2i, r2D90);
            ir_expression *const r2D92 = expr(ir_unop_i2u, r2D91);
            body.emit(assign(r2D8D, add(r2D8F, r2D92), 0x01));

            body.emit(assign(r2CD4, r2D8D, 0x01));

            body.emit(assign(r2CD2, add(r2CD2, body.constant(int(-1))), 0x01));

            /* IF CONDITION */
            ir_expression *const r2D94 = less(r2D8D, body.constant(2097152u));
            ir_if *f2D93 = new(mem_ctx) ir_if(operand(r2D94).val);
            exec_list *const f2D93_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2D93->then_instructions;

               ir_variable *const r2D95 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2D95, r2CD2, 0x01));

               ir_variable *const r2D96 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2D96, r2D8D, 0x01));

               ir_variable *const r2D97 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2D97, r2D8E, 0x01));

               ir_variable *const r2D98 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r2D98, r2CD3, 0x01));

               ir_variable *const r2D99 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r2D99, body.constant(true), 0x01));

               ir_variable *const r2D9A = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2D9B = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2D9B);
               ir_expression *const r2D9C = expr(ir_unop_u2i, r2CD3);
               body.emit(assign(r2D9B, less(r2D9C, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2D9E = lequal(body.constant(int(2045)), r2CD2);
               ir_if *f2D9D = new(mem_ctx) ir_if(operand(r2D9E).val);
               exec_list *const f2D9D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2D9D->then_instructions;

                  ir_variable *const r2D9F = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2DA1 = less(body.constant(int(2045)), r2CD2);
                  ir_if *f2DA0 = new(mem_ctx) ir_if(operand(r2DA1).val);
                  exec_list *const f2DA0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2DA0->then_instructions;

                     body.emit(assign(r2D9F, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2DA0->else_instructions;

                     ir_variable *const r2DA2 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2DA4 = equal(r2CD2, body.constant(int(2045)));
                     ir_if *f2DA3 = new(mem_ctx) ir_if(operand(r2DA4).val);
                     exec_list *const f2DA3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2DA3->then_instructions;

                        ir_expression *const r2DA5 = equal(body.constant(2097151u), r2D8D);
                        ir_expression *const r2DA6 = equal(body.constant(4294967295u), r2D8E);
                        body.emit(assign(r2DA2, logic_and(r2DA5, r2DA6), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2DA3->else_instructions;

                        body.emit(assign(r2DA2, body.constant(false), 0x01));


                     body.instructions = f2DA3_parent_instructions;
                     body.emit(f2DA3);

                     /* END IF */

                     body.emit(assign(r2D9F, logic_and(r2DA2, r2D9B), 0x01));


                  body.instructions = f2DA0_parent_instructions;
                  body.emit(f2DA0);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2DA7 = new(mem_ctx) ir_if(operand(r2D9F).val);
                  exec_list *const f2DA7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2DA7->then_instructions;

                     ir_variable *const r2DA8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2DA8);
                     ir_expression *const r2DA9 = lshift(r290E, body.constant(int(31)));
                     body.emit(assign(r2DA8, add(r2DA9, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r2DA8, body.constant(0u), 0x01));

                     body.emit(assign(r2D9A, r2DA8, 0x03));

                     body.emit(assign(r2D99, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2DA7->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2DAB = less(r2CD2, body.constant(int(0)));
                     ir_if *f2DAA = new(mem_ctx) ir_if(operand(r2DAB).val);
                     exec_list *const f2DAA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2DAA->then_instructions;

                        ir_variable *const r2DAC = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2DAC, r2CD3, 0x01));

                        ir_variable *const r2DAD = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2DAD, neg(r2CD2), 0x01));

                        ir_variable *const r2DAE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2DAE);
                        ir_variable *const r2DAF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2DAF);
                        ir_variable *const r2DB0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2DB0);
                        ir_variable *const r2DB1 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2DB2 = neg(r2DAD);
                        body.emit(assign(r2DB1, bit_and(r2DB2, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2DB4 = equal(r2DAD, body.constant(int(0)));
                        ir_if *f2DB3 = new(mem_ctx) ir_if(operand(r2DB4).val);
                        exec_list *const f2DB3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2DB3->then_instructions;

                           body.emit(assign(r2DAE, r2CD3, 0x01));

                           body.emit(assign(r2DAF, r2D8E, 0x01));

                           body.emit(assign(r2DB0, r2D8D, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2DB3->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2DB6 = less(r2DAD, body.constant(int(32)));
                           ir_if *f2DB5 = new(mem_ctx) ir_if(operand(r2DB6).val);
                           exec_list *const f2DB5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2DB5->then_instructions;

                              body.emit(assign(r2DAE, lshift(r2D8E, r2DB1), 0x01));

                              ir_expression *const r2DB7 = lshift(r2D8D, r2DB1);
                              ir_expression *const r2DB8 = rshift(r2D8E, r2DAD);
                              body.emit(assign(r2DAF, bit_or(r2DB7, r2DB8), 0x01));

                              body.emit(assign(r2DB0, rshift(r2D8D, r2DAD), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2DB5->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2DBA = equal(r2DAD, body.constant(int(32)));
                              ir_if *f2DB9 = new(mem_ctx) ir_if(operand(r2DBA).val);
                              exec_list *const f2DB9_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2DB9->then_instructions;

                                 body.emit(assign(r2DAE, r2D8E, 0x01));

                                 body.emit(assign(r2DAF, r2D8D, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2DB9->else_instructions;

                                 body.emit(assign(r2DAC, bit_or(r2CD3, r2D8E), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2DBC = less(r2DAD, body.constant(int(64)));
                                 ir_if *f2DBB = new(mem_ctx) ir_if(operand(r2DBC).val);
                                 exec_list *const f2DBB_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2DBB->then_instructions;

                                    body.emit(assign(r2DAE, lshift(r2D8D, r2DB1), 0x01));

                                    ir_expression *const r2DBD = bit_and(r2DAD, body.constant(int(31)));
                                    body.emit(assign(r2DAF, rshift(r2D8D, r2DBD), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2DBB->else_instructions;

                                    ir_variable *const r2DBE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2DC0 = equal(r2DAD, body.constant(int(64)));
                                    ir_if *f2DBF = new(mem_ctx) ir_if(operand(r2DC0).val);
                                    exec_list *const f2DBF_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2DBF->then_instructions;

                                       body.emit(assign(r2DBE, r2D8D, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2DBF->else_instructions;

                                       ir_expression *const r2DC1 = nequal(r2D8D, body.constant(0u));
                                       ir_expression *const r2DC2 = expr(ir_unop_b2i, r2DC1);
                                       body.emit(assign(r2DBE, expr(ir_unop_i2u, r2DC2), 0x01));


                                    body.instructions = f2DBF_parent_instructions;
                                    body.emit(f2DBF);

                                    /* END IF */

                                    body.emit(assign(r2DAE, r2DBE, 0x01));

                                    body.emit(assign(r2DAF, body.constant(0u), 0x01));


                                 body.instructions = f2DBB_parent_instructions;
                                 body.emit(f2DBB);

                                 /* END IF */


                              body.instructions = f2DB9_parent_instructions;
                              body.emit(f2DB9);

                              /* END IF */

                              body.emit(assign(r2DB0, body.constant(0u), 0x01));


                           body.instructions = f2DB5_parent_instructions;
                           body.emit(f2DB5);

                           /* END IF */

                           ir_expression *const r2DC3 = nequal(r2DAC, body.constant(0u));
                           ir_expression *const r2DC4 = expr(ir_unop_b2i, r2DC3);
                           ir_expression *const r2DC5 = expr(ir_unop_i2u, r2DC4);
                           body.emit(assign(r2DAE, bit_or(r2DAE, r2DC5), 0x01));


                        body.instructions = f2DB3_parent_instructions;
                        body.emit(f2DB3);

                        /* END IF */

                        body.emit(assign(r2D96, r2DB0, 0x01));

                        body.emit(assign(r2D97, r2DAF, 0x01));

                        body.emit(assign(r2D98, r2DAE, 0x01));

                        body.emit(assign(r2D95, body.constant(int(0)), 0x01));

                        body.emit(assign(r2D9B, less(r2DAE, body.constant(0u)), 0x01));


                     body.instructions = f2DAA_parent_instructions;
                     body.emit(f2DAA);

                     /* END IF */


                  body.instructions = f2DA7_parent_instructions;
                  body.emit(f2DA7);

                  /* END IF */


               body.instructions = f2D9D_parent_instructions;
               body.emit(f2D9D);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2DC6 = new(mem_ctx) ir_if(operand(r2D99).val);
               exec_list *const f2DC6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2DC6->then_instructions;

                  /* IF CONDITION */
                  ir_if *f2DC7 = new(mem_ctx) ir_if(operand(r2D9B).val);
                  exec_list *const f2DC7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2DC7->then_instructions;

                     ir_variable *const r2DC8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r2DC8, add(r2D97, body.constant(1u)), 0x01));

                     ir_expression *const r2DC9 = less(r2DC8, r2D97);
                     ir_expression *const r2DCA = expr(ir_unop_b2i, r2DC9);
                     ir_expression *const r2DCB = expr(ir_unop_i2u, r2DCA);
                     body.emit(assign(r2D96, add(r2D96, r2DCB), 0x01));

                     ir_expression *const r2DCC = equal(r2D98, body.constant(0u));
                     ir_expression *const r2DCD = expr(ir_unop_b2i, r2DCC);
                     ir_expression *const r2DCE = expr(ir_unop_i2u, r2DCD);
                     ir_expression *const r2DCF = add(r2D98, r2DCE);
                     ir_expression *const r2DD0 = bit_and(r2DCF, body.constant(1u));
                     ir_expression *const r2DD1 = expr(ir_unop_bit_not, r2DD0);
                     body.emit(assign(r2D97, bit_and(r2DC8, r2DD1), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2DC7->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2DD3 = bit_or(r2D96, r2D97);
                     ir_expression *const r2DD4 = equal(r2DD3, body.constant(0u));
                     ir_if *f2DD2 = new(mem_ctx) ir_if(operand(r2DD4).val);
                     exec_list *const f2DD2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2DD2->then_instructions;

                        body.emit(assign(r2D95, body.constant(int(0)), 0x01));


                     body.instructions = f2DD2_parent_instructions;
                     body.emit(f2DD2);

                     /* END IF */


                  body.instructions = f2DC7_parent_instructions;
                  body.emit(f2DC7);

                  /* END IF */

                  ir_variable *const r2DD5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2DD5);
                  ir_expression *const r2DD6 = lshift(r290E, body.constant(int(31)));
                  ir_expression *const r2DD7 = expr(ir_unop_i2u, r2D95);
                  ir_expression *const r2DD8 = lshift(r2DD7, body.constant(int(20)));
                  ir_expression *const r2DD9 = add(r2DD6, r2DD8);
                  body.emit(assign(r2DD5, add(r2DD9, r2D96), 0x02));

                  body.emit(assign(r2DD5, r2D97, 0x01));

                  body.emit(assign(r2D9A, r2DD5, 0x03));

                  body.emit(assign(r2D99, body.constant(false), 0x01));


               body.instructions = f2DC6_parent_instructions;
               body.emit(f2DC6);

               /* END IF */

               body.emit(assign(r2CCE, r2D9A, 0x03));

               body.emit(assign(r2CCD, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2D93->else_instructions;

               body.emit(assign(r2CD2, add(r2CD2, body.constant(int(1))), 0x01));

               ir_variable *const r2DDA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r2DDA);
               ir_variable *const r2DDB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2DDB);
               ir_variable *const r2DDC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2DDC);
               body.emit(assign(r2DDA, lshift(r2D8E, body.constant(int(31))), 0x01));

               ir_expression *const r2DDD = lshift(r2D8D, body.constant(int(31)));
               ir_expression *const r2DDE = rshift(r2D8E, body.constant(int(1)));
               body.emit(assign(r2DDB, bit_or(r2DDD, r2DDE), 0x01));

               body.emit(assign(r2DDC, rshift(r2D8D, body.constant(int(1))), 0x01));

               ir_expression *const r2DDF = nequal(r2CD3, body.constant(0u));
               ir_expression *const r2DE0 = expr(ir_unop_b2i, r2DDF);
               ir_expression *const r2DE1 = expr(ir_unop_i2u, r2DE0);
               body.emit(assign(r2DDA, bit_or(r2DDA, r2DE1), 0x01));

               body.emit(assign(r2CD4, r2DDC, 0x01));

               body.emit(assign(r2CD3, r2DDA, 0x01));

               ir_variable *const r2DE2 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2DE2, r2CD2, 0x01));

               ir_variable *const r2DE3 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2DE3, r2DDC, 0x01));

               ir_variable *const r2DE4 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2DE4, r2DDB, 0x01));

               ir_variable *const r2DE5 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r2DE5, r2DDA, 0x01));

               ir_variable *const r2DE6 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r2DE6, body.constant(true), 0x01));

               ir_variable *const r2DE7 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2DE8 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2DE8);
               ir_expression *const r2DE9 = expr(ir_unop_u2i, r2DDA);
               body.emit(assign(r2DE8, less(r2DE9, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2DEB = lequal(body.constant(int(2045)), r2CD2);
               ir_if *f2DEA = new(mem_ctx) ir_if(operand(r2DEB).val);
               exec_list *const f2DEA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2DEA->then_instructions;

                  ir_variable *const r2DEC = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2DEE = less(body.constant(int(2045)), r2CD2);
                  ir_if *f2DED = new(mem_ctx) ir_if(operand(r2DEE).val);
                  exec_list *const f2DED_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2DED->then_instructions;

                     body.emit(assign(r2DEC, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2DED->else_instructions;

                     ir_variable *const r2DEF = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2DF1 = equal(r2CD2, body.constant(int(2045)));
                     ir_if *f2DF0 = new(mem_ctx) ir_if(operand(r2DF1).val);
                     exec_list *const f2DF0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2DF0->then_instructions;

                        ir_expression *const r2DF2 = equal(body.constant(2097151u), r2DDC);
                        ir_expression *const r2DF3 = equal(body.constant(4294967295u), r2DDB);
                        body.emit(assign(r2DEF, logic_and(r2DF2, r2DF3), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2DF0->else_instructions;

                        body.emit(assign(r2DEF, body.constant(false), 0x01));


                     body.instructions = f2DF0_parent_instructions;
                     body.emit(f2DF0);

                     /* END IF */

                     body.emit(assign(r2DEC, logic_and(r2DEF, r2DE8), 0x01));


                  body.instructions = f2DED_parent_instructions;
                  body.emit(f2DED);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2DF4 = new(mem_ctx) ir_if(operand(r2DEC).val);
                  exec_list *const f2DF4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2DF4->then_instructions;

                     ir_variable *const r2DF5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2DF5);
                     ir_expression *const r2DF6 = lshift(r290E, body.constant(int(31)));
                     body.emit(assign(r2DF5, add(r2DF6, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r2DF5, body.constant(0u), 0x01));

                     body.emit(assign(r2DE7, r2DF5, 0x03));

                     body.emit(assign(r2DE6, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2DF4->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2DF8 = less(r2CD2, body.constant(int(0)));
                     ir_if *f2DF7 = new(mem_ctx) ir_if(operand(r2DF8).val);
                     exec_list *const f2DF7_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2DF7->then_instructions;

                        ir_variable *const r2DF9 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2DF9, r2DDA, 0x01));

                        ir_variable *const r2DFA = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2DFA, neg(r2CD2), 0x01));

                        ir_variable *const r2DFB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2DFB);
                        ir_variable *const r2DFC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2DFC);
                        ir_variable *const r2DFD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2DFD);
                        ir_variable *const r2DFE = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2DFF = neg(r2DFA);
                        body.emit(assign(r2DFE, bit_and(r2DFF, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2E01 = equal(r2DFA, body.constant(int(0)));
                        ir_if *f2E00 = new(mem_ctx) ir_if(operand(r2E01).val);
                        exec_list *const f2E00_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2E00->then_instructions;

                           body.emit(assign(r2DFB, r2DDA, 0x01));

                           body.emit(assign(r2DFC, r2DDB, 0x01));

                           body.emit(assign(r2DFD, r2DDC, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2E00->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2E03 = less(r2DFA, body.constant(int(32)));
                           ir_if *f2E02 = new(mem_ctx) ir_if(operand(r2E03).val);
                           exec_list *const f2E02_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2E02->then_instructions;

                              body.emit(assign(r2DFB, lshift(r2DDB, r2DFE), 0x01));

                              ir_expression *const r2E04 = lshift(r2DDC, r2DFE);
                              ir_expression *const r2E05 = rshift(r2DDB, r2DFA);
                              body.emit(assign(r2DFC, bit_or(r2E04, r2E05), 0x01));

                              body.emit(assign(r2DFD, rshift(r2DDC, r2DFA), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2E02->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2E07 = equal(r2DFA, body.constant(int(32)));
                              ir_if *f2E06 = new(mem_ctx) ir_if(operand(r2E07).val);
                              exec_list *const f2E06_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2E06->then_instructions;

                                 body.emit(assign(r2DFB, r2DDB, 0x01));

                                 body.emit(assign(r2DFC, r2DDC, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2E06->else_instructions;

                                 body.emit(assign(r2DF9, bit_or(r2DDA, r2DDB), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2E09 = less(r2DFA, body.constant(int(64)));
                                 ir_if *f2E08 = new(mem_ctx) ir_if(operand(r2E09).val);
                                 exec_list *const f2E08_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2E08->then_instructions;

                                    body.emit(assign(r2DFB, lshift(r2DDC, r2DFE), 0x01));

                                    ir_expression *const r2E0A = bit_and(r2DFA, body.constant(int(31)));
                                    body.emit(assign(r2DFC, rshift(r2DDC, r2E0A), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2E08->else_instructions;

                                    ir_variable *const r2E0B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2E0D = equal(r2DFA, body.constant(int(64)));
                                    ir_if *f2E0C = new(mem_ctx) ir_if(operand(r2E0D).val);
                                    exec_list *const f2E0C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2E0C->then_instructions;

                                       body.emit(assign(r2E0B, r2DDC, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2E0C->else_instructions;

                                       ir_expression *const r2E0E = nequal(r2DDC, body.constant(0u));
                                       ir_expression *const r2E0F = expr(ir_unop_b2i, r2E0E);
                                       body.emit(assign(r2E0B, expr(ir_unop_i2u, r2E0F), 0x01));


                                    body.instructions = f2E0C_parent_instructions;
                                    body.emit(f2E0C);

                                    /* END IF */

                                    body.emit(assign(r2DFB, r2E0B, 0x01));

                                    body.emit(assign(r2DFC, body.constant(0u), 0x01));


                                 body.instructions = f2E08_parent_instructions;
                                 body.emit(f2E08);

                                 /* END IF */


                              body.instructions = f2E06_parent_instructions;
                              body.emit(f2E06);

                              /* END IF */

                              body.emit(assign(r2DFD, body.constant(0u), 0x01));


                           body.instructions = f2E02_parent_instructions;
                           body.emit(f2E02);

                           /* END IF */

                           ir_expression *const r2E10 = nequal(r2DF9, body.constant(0u));
                           ir_expression *const r2E11 = expr(ir_unop_b2i, r2E10);
                           ir_expression *const r2E12 = expr(ir_unop_i2u, r2E11);
                           body.emit(assign(r2DFB, bit_or(r2DFB, r2E12), 0x01));


                        body.instructions = f2E00_parent_instructions;
                        body.emit(f2E00);

                        /* END IF */

                        body.emit(assign(r2DE3, r2DFD, 0x01));

                        body.emit(assign(r2DE4, r2DFC, 0x01));

                        body.emit(assign(r2DE5, r2DFB, 0x01));

                        body.emit(assign(r2DE2, body.constant(int(0)), 0x01));

                        body.emit(assign(r2DE8, less(r2DFB, body.constant(0u)), 0x01));


                     body.instructions = f2DF7_parent_instructions;
                     body.emit(f2DF7);

                     /* END IF */


                  body.instructions = f2DF4_parent_instructions;
                  body.emit(f2DF4);

                  /* END IF */


               body.instructions = f2DEA_parent_instructions;
               body.emit(f2DEA);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2E13 = new(mem_ctx) ir_if(operand(r2DE6).val);
               exec_list *const f2E13_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2E13->then_instructions;

                  /* IF CONDITION */
                  ir_if *f2E14 = new(mem_ctx) ir_if(operand(r2DE8).val);
                  exec_list *const f2E14_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2E14->then_instructions;

                     ir_variable *const r2E15 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r2E15, add(r2DE4, body.constant(1u)), 0x01));

                     ir_expression *const r2E16 = less(r2E15, r2DE4);
                     ir_expression *const r2E17 = expr(ir_unop_b2i, r2E16);
                     ir_expression *const r2E18 = expr(ir_unop_i2u, r2E17);
                     body.emit(assign(r2DE3, add(r2DE3, r2E18), 0x01));

                     ir_expression *const r2E19 = equal(r2DE5, body.constant(0u));
                     ir_expression *const r2E1A = expr(ir_unop_b2i, r2E19);
                     ir_expression *const r2E1B = expr(ir_unop_i2u, r2E1A);
                     ir_expression *const r2E1C = add(r2DE5, r2E1B);
                     ir_expression *const r2E1D = bit_and(r2E1C, body.constant(1u));
                     ir_expression *const r2E1E = expr(ir_unop_bit_not, r2E1D);
                     body.emit(assign(r2DE4, bit_and(r2E15, r2E1E), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2E14->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2E20 = bit_or(r2DE3, r2DE4);
                     ir_expression *const r2E21 = equal(r2E20, body.constant(0u));
                     ir_if *f2E1F = new(mem_ctx) ir_if(operand(r2E21).val);
                     exec_list *const f2E1F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E1F->then_instructions;

                        body.emit(assign(r2DE2, body.constant(int(0)), 0x01));


                     body.instructions = f2E1F_parent_instructions;
                     body.emit(f2E1F);

                     /* END IF */


                  body.instructions = f2E14_parent_instructions;
                  body.emit(f2E14);

                  /* END IF */

                  ir_variable *const r2E22 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2E22);
                  ir_expression *const r2E23 = lshift(r290E, body.constant(int(31)));
                  ir_expression *const r2E24 = expr(ir_unop_i2u, r2DE2);
                  ir_expression *const r2E25 = lshift(r2E24, body.constant(int(20)));
                  ir_expression *const r2E26 = add(r2E23, r2E25);
                  body.emit(assign(r2E22, add(r2E26, r2DE3), 0x02));

                  body.emit(assign(r2E22, r2DE4, 0x01));

                  body.emit(assign(r2DE7, r2E22, 0x03));

                  body.emit(assign(r2DE6, body.constant(false), 0x01));


               body.instructions = f2E13_parent_instructions;
               body.emit(f2E13);

               /* END IF */

               body.emit(assign(r2CCE, r2DE7, 0x03));

               body.emit(assign(r2CCD, body.constant(false), 0x01));


            body.instructions = f2D93_parent_instructions;
            body.emit(f2D93);

            /* END IF */


         body.instructions = f2D8C_parent_instructions;
         body.emit(f2D8C);

         /* END IF */

         body.emit(assign(r290D, r2CCE, 0x03));


      body.instructions = f290F_parent_instructions;
      body.emit(f290F);

      /* END IF */

      body.emit(assign(r290B, r290D, 0x03));


   body.instructions = f290C_parent_instructions;
   body.emit(f290C);

   /* END IF */

   ir_variable *const r2E27 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r2E28 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r2E28, rshift(swizzle_y(r28D7), body.constant(int(31))), 0x01));

   ir_variable *const r2E29 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r2E29, rshift(swizzle_y(r290B), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r2E2B = equal(r2E28, r2E29);
   ir_if *f2E2A = new(mem_ctx) ir_if(operand(r2E2B).val);
   exec_list *const f2E2A_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f2E2A->then_instructions;

      ir_variable *const r2E2C = body.make_temp(glsl_type::uint_type, "zSign");
      body.emit(assign(r2E2C, r2E28, 0x01));

      ir_variable *const r2E2D = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r2E2E = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r2E2E);
      ir_variable *const r2E2F = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
      body.emit(r2E2F);
      ir_variable *const r2E30 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
      body.emit(r2E30);
      ir_variable *const r2E31 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
      body.emit(r2E31);
      ir_variable *const r2E32 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
      body.emit(r2E32);
      ir_variable *const r2E33 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r2E33);
      ir_variable *const r2E34 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r2E34);
      body.emit(assign(r2E34, bit_and(swizzle_y(r28D7), body.constant(1048575u)), 0x02));

      body.emit(assign(r2E34, swizzle_x(r28D7), 0x01));

      ir_variable *const r2E35 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r2E36 = rshift(swizzle_y(r28D7), body.constant(int(20)));
      ir_expression *const r2E37 = bit_and(r2E36, body.constant(2047u));
      body.emit(assign(r2E35, expr(ir_unop_u2i, r2E37), 0x01));

      body.emit(assign(r2E31, r2E35, 0x01));

      ir_variable *const r2E38 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r2E38);
      body.emit(assign(r2E38, bit_and(swizzle_y(r290B), body.constant(1048575u)), 0x02));

      body.emit(assign(r2E38, swizzle_x(r290B), 0x01));

      ir_variable *const r2E39 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r2E3A = rshift(swizzle_y(r290B), body.constant(int(20)));
      ir_expression *const r2E3B = bit_and(r2E3A, body.constant(2047u));
      body.emit(assign(r2E39, expr(ir_unop_u2i, r2E3B), 0x01));

      body.emit(assign(r2E2F, r2E39, 0x01));

      body.emit(assign(r2E2E, sub(r2E35, r2E39), 0x01));

      ir_variable *const r2E3C = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r2E3C, lshift(swizzle_x(r28D7), body.constant(int(10))), 0x01));

      ir_variable *const r2E3D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r2E3E = lshift(swizzle_y(r2E34), body.constant(int(10)));
      ir_expression *const r2E3F = rshift(swizzle_x(r28D7), body.constant(int(22)));
      body.emit(assign(r2E3D, bit_or(r2E3E, r2E3F), 0x01));

      body.emit(assign(r2E32, r2E3D, 0x02));

      body.emit(assign(r2E32, r2E3C, 0x01));

      ir_variable *const r2E40 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r2E40, lshift(swizzle_x(r290B), body.constant(int(10))), 0x01));

      ir_variable *const r2E41 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r2E42 = lshift(swizzle_y(r2E38), body.constant(int(10)));
      ir_expression *const r2E43 = rshift(swizzle_x(r290B), body.constant(int(22)));
      body.emit(assign(r2E41, bit_or(r2E42, r2E43), 0x01));

      body.emit(assign(r2E30, r2E41, 0x02));

      body.emit(assign(r2E30, r2E40, 0x01));

      /* IF CONDITION */
      ir_expression *const r2E45 = less(body.constant(int(0)), r2E2E);
      ir_if *f2E44 = new(mem_ctx) ir_if(operand(r2E45).val);
      exec_list *const f2E44_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f2E44->then_instructions;

         /* IF CONDITION */
         ir_expression *const r2E47 = equal(r2E35, body.constant(int(2047)));
         ir_if *f2E46 = new(mem_ctx) ir_if(operand(r2E47).val);
         exec_list *const f2E46_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2E46->then_instructions;

            /* IF CONDITION */
            ir_expression *const r2E49 = bit_or(r2E3D, r2E3C);
            ir_expression *const r2E4A = nequal(r2E49, body.constant(0u));
            ir_if *f2E48 = new(mem_ctx) ir_if(operand(r2E4A).val);
            exec_list *const f2E48_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2E48->then_instructions;

               ir_variable *const r2E4B = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r2E4B, swizzle_x(r28D7), 0x01));

               ir_variable *const r2E4C = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r2E4C, swizzle_x(r290B), 0x01));

               ir_variable *const r2E4D = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2E4E = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r2E4F = rshift(swizzle_y(r28D7), body.constant(int(19)));
               ir_expression *const r2E50 = bit_and(r2E4F, body.constant(4095u));
               ir_expression *const r2E51 = equal(r2E50, body.constant(4094u));
               ir_expression *const r2E52 = nequal(swizzle_x(r28D7), body.constant(0u));
               ir_expression *const r2E53 = bit_and(swizzle_y(r28D7), body.constant(524287u));
               ir_expression *const r2E54 = nequal(r2E53, body.constant(0u));
               ir_expression *const r2E55 = logic_or(r2E52, r2E54);
               body.emit(assign(r2E4E, logic_and(r2E51, r2E55), 0x01));

               ir_variable *const r2E56 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r2E57 = lshift(swizzle_y(r290B), body.constant(int(1)));
               ir_expression *const r2E58 = lequal(body.constant(4292870144u), r2E57);
               ir_expression *const r2E59 = nequal(swizzle_x(r290B), body.constant(0u));
               ir_expression *const r2E5A = bit_and(swizzle_y(r290B), body.constant(1048575u));
               ir_expression *const r2E5B = nequal(r2E5A, body.constant(0u));
               ir_expression *const r2E5C = logic_or(r2E59, r2E5B);
               body.emit(assign(r2E56, logic_and(r2E58, r2E5C), 0x01));

               body.emit(assign(r2E4B, bit_or(swizzle_y(r28D7), body.constant(524288u)), 0x02));

               body.emit(assign(r2E4C, bit_or(swizzle_y(r290B), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r2E5E = lshift(swizzle_y(r28D7), body.constant(int(1)));
               ir_expression *const r2E5F = lequal(body.constant(4292870144u), r2E5E);
               ir_expression *const r2E60 = nequal(swizzle_x(r28D7), body.constant(0u));
               ir_expression *const r2E61 = bit_and(swizzle_y(r28D7), body.constant(1048575u));
               ir_expression *const r2E62 = nequal(r2E61, body.constant(0u));
               ir_expression *const r2E63 = logic_or(r2E60, r2E62);
               ir_expression *const r2E64 = logic_and(r2E5F, r2E63);
               ir_if *f2E5D = new(mem_ctx) ir_if(operand(r2E64).val);
               exec_list *const f2E5D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2E5D->then_instructions;

                  ir_variable *const r2E65 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2E67 = logic_and(r2E4E, r2E56);
                  ir_if *f2E66 = new(mem_ctx) ir_if(operand(r2E67).val);
                  exec_list *const f2E66_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2E66->then_instructions;

                     body.emit(assign(r2E65, r2E4C, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2E66->else_instructions;

                     body.emit(assign(r2E65, r2E4B, 0x03));


                  body.instructions = f2E66_parent_instructions;
                  body.emit(f2E66);

                  /* END IF */

                  body.emit(assign(r2E4D, r2E65, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2E5D->else_instructions;

                  body.emit(assign(r2E4D, r2E4C, 0x03));


               body.instructions = f2E5D_parent_instructions;
               body.emit(f2E5D);

               /* END IF */

               body.emit(assign(r2E2D, r2E4D, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2E48->else_instructions;

               body.emit(assign(r2E2D, r28D7, 0x03));


            body.instructions = f2E48_parent_instructions;
            body.emit(f2E48);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2E46->else_instructions;

            /* IF CONDITION */
            ir_expression *const r2E69 = equal(r2E39, body.constant(int(0)));
            ir_if *f2E68 = new(mem_ctx) ir_if(operand(r2E69).val);
            exec_list *const f2E68_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2E68->then_instructions;

               body.emit(assign(r2E2E, add(r2E2E, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2E68->else_instructions;

               body.emit(assign(r2E30, bit_or(r2E41, body.constant(1073741824u)), 0x02));


            body.instructions = f2E68_parent_instructions;
            body.emit(f2E68);

            /* END IF */

            ir_variable *const r2E6A = body.make_temp(glsl_type::uint_type, "a0");
            body.emit(assign(r2E6A, swizzle_y(r2E30), 0x01));

            ir_variable *const r2E6B = body.make_temp(glsl_type::uint_type, "a1");
            body.emit(assign(r2E6B, swizzle_x(r2E30), 0x01));

            ir_variable *const r2E6C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r2E6C);
            ir_variable *const r2E6D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r2E6D);
            ir_variable *const r2E6E = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r2E6F = neg(r2E2E);
            body.emit(assign(r2E6E, bit_and(r2E6F, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r2E71 = equal(r2E2E, body.constant(int(0)));
            ir_if *f2E70 = new(mem_ctx) ir_if(operand(r2E71).val);
            exec_list *const f2E70_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2E70->then_instructions;

               body.emit(assign(r2E6C, r2E6B, 0x01));

               body.emit(assign(r2E6D, r2E6A, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2E70->else_instructions;

               /* IF CONDITION */
               ir_expression *const r2E73 = less(r2E2E, body.constant(int(32)));
               ir_if *f2E72 = new(mem_ctx) ir_if(operand(r2E73).val);
               exec_list *const f2E72_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2E72->then_instructions;

                  ir_expression *const r2E74 = lshift(swizzle_y(r2E30), r2E6E);
                  ir_expression *const r2E75 = rshift(r2E40, r2E2E);
                  ir_expression *const r2E76 = bit_or(r2E74, r2E75);
                  ir_expression *const r2E77 = lshift(r2E40, r2E6E);
                  ir_expression *const r2E78 = nequal(r2E77, body.constant(0u));
                  ir_expression *const r2E79 = expr(ir_unop_b2i, r2E78);
                  ir_expression *const r2E7A = expr(ir_unop_i2u, r2E79);
                  body.emit(assign(r2E6C, bit_or(r2E76, r2E7A), 0x01));

                  body.emit(assign(r2E6D, rshift(swizzle_y(r2E30), r2E2E), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2E72->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2E7C = equal(r2E2E, body.constant(int(32)));
                  ir_if *f2E7B = new(mem_ctx) ir_if(operand(r2E7C).val);
                  exec_list *const f2E7B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2E7B->then_instructions;

                     ir_expression *const r2E7D = nequal(r2E40, body.constant(0u));
                     ir_expression *const r2E7E = expr(ir_unop_b2i, r2E7D);
                     ir_expression *const r2E7F = expr(ir_unop_i2u, r2E7E);
                     body.emit(assign(r2E6C, bit_or(swizzle_y(r2E30), r2E7F), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2E7B->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2E81 = less(r2E2E, body.constant(int(64)));
                     ir_if *f2E80 = new(mem_ctx) ir_if(operand(r2E81).val);
                     exec_list *const f2E80_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2E80->then_instructions;

                        ir_expression *const r2E82 = bit_and(r2E2E, body.constant(int(31)));
                        ir_expression *const r2E83 = rshift(swizzle_y(r2E30), r2E82);
                        ir_expression *const r2E84 = lshift(swizzle_y(r2E30), r2E6E);
                        ir_expression *const r2E85 = bit_or(r2E84, r2E40);
                        ir_expression *const r2E86 = nequal(r2E85, body.constant(0u));
                        ir_expression *const r2E87 = expr(ir_unop_b2i, r2E86);
                        ir_expression *const r2E88 = expr(ir_unop_i2u, r2E87);
                        body.emit(assign(r2E6C, bit_or(r2E83, r2E88), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2E80->else_instructions;

                        ir_expression *const r2E89 = bit_or(swizzle_y(r2E30), r2E40);
                        ir_expression *const r2E8A = nequal(r2E89, body.constant(0u));
                        ir_expression *const r2E8B = expr(ir_unop_b2i, r2E8A);
                        body.emit(assign(r2E6C, expr(ir_unop_i2u, r2E8B), 0x01));


                     body.instructions = f2E80_parent_instructions;
                     body.emit(f2E80);

                     /* END IF */


                  body.instructions = f2E7B_parent_instructions;
                  body.emit(f2E7B);

                  /* END IF */

                  body.emit(assign(r2E6D, body.constant(0u), 0x01));


               body.instructions = f2E72_parent_instructions;
               body.emit(f2E72);

               /* END IF */


            body.instructions = f2E70_parent_instructions;
            body.emit(f2E70);

            /* END IF */

            body.emit(assign(r2E30, r2E6D, 0x02));

            body.emit(assign(r2E30, r2E6C, 0x01));

            body.emit(assign(r2E32, bit_or(r2E3D, body.constant(1073741824u)), 0x02));

            ir_variable *const r2E8C = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r2E8D = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r2E8D, sub(r2E3C, r2E6C), 0x01));

            ir_expression *const r2E8E = sub(swizzle_y(r2E32), r2E6D);
            ir_expression *const r2E8F = less(r2E3C, r2E6C);
            ir_expression *const r2E90 = expr(ir_unop_b2i, r2E8F);
            ir_expression *const r2E91 = expr(ir_unop_i2u, r2E90);
            body.emit(assign(r2E8C, sub(r2E8E, r2E91), 0x01));

            body.emit(assign(r2E33, add(r2E35, body.constant(int(-1))), 0x01));

            ir_variable *const r2E92 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r2E92, add(r2E33, body.constant(int(-10))), 0x01));

            ir_variable *const r2E93 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r2E93, r2E8C, 0x01));

            ir_variable *const r2E94 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r2E94, r2E8D, 0x01));

            ir_variable *const r2E95 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
            body.emit(r2E95);
            ir_variable *const r2E96 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r2E96);
            /* IF CONDITION */
            ir_expression *const r2E98 = equal(r2E8C, body.constant(0u));
            ir_if *f2E97 = new(mem_ctx) ir_if(operand(r2E98).val);
            exec_list *const f2E97_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2E97->then_instructions;

               body.emit(assign(r2E93, r2E8D, 0x01));

               body.emit(assign(r2E94, body.constant(0u), 0x01));

               body.emit(assign(r2E92, add(r2E92, body.constant(int(-32))), 0x01));


            body.instructions = f2E97_parent_instructions;
            body.emit(f2E97);

            /* END IF */

            ir_variable *const r2E99 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r2E99, r2E93, 0x01));

            ir_variable *const r2E9A = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r2E9B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r2E9B);
            /* IF CONDITION */
            ir_expression *const r2E9D = equal(r2E93, body.constant(0u));
            ir_if *f2E9C = new(mem_ctx) ir_if(operand(r2E9D).val);
            exec_list *const f2E9C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2E9C->then_instructions;

               body.emit(assign(r2E9A, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2E9C->else_instructions;

               body.emit(assign(r2E9B, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r2E9F = bit_and(r2E93, body.constant(4294901760u));
               ir_expression *const r2EA0 = equal(r2E9F, body.constant(0u));
               ir_if *f2E9E = new(mem_ctx) ir_if(operand(r2EA0).val);
               exec_list *const f2E9E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2E9E->then_instructions;

                  body.emit(assign(r2E9B, body.constant(int(16)), 0x01));

                  body.emit(assign(r2E99, lshift(r2E93, body.constant(int(16))), 0x01));


               body.instructions = f2E9E_parent_instructions;
               body.emit(f2E9E);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r2EA2 = bit_and(r2E99, body.constant(4278190080u));
               ir_expression *const r2EA3 = equal(r2EA2, body.constant(0u));
               ir_if *f2EA1 = new(mem_ctx) ir_if(operand(r2EA3).val);
               exec_list *const f2EA1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2EA1->then_instructions;

                  body.emit(assign(r2E9B, add(r2E9B, body.constant(int(8))), 0x01));

                  body.emit(assign(r2E99, lshift(r2E99, body.constant(int(8))), 0x01));


               body.instructions = f2EA1_parent_instructions;
               body.emit(f2EA1);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r2EA5 = bit_and(r2E99, body.constant(4026531840u));
               ir_expression *const r2EA6 = equal(r2EA5, body.constant(0u));
               ir_if *f2EA4 = new(mem_ctx) ir_if(operand(r2EA6).val);
               exec_list *const f2EA4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2EA4->then_instructions;

                  body.emit(assign(r2E9B, add(r2E9B, body.constant(int(4))), 0x01));

                  body.emit(assign(r2E99, lshift(r2E99, body.constant(int(4))), 0x01));


               body.instructions = f2EA4_parent_instructions;
               body.emit(f2EA4);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r2EA8 = bit_and(r2E99, body.constant(3221225472u));
               ir_expression *const r2EA9 = equal(r2EA8, body.constant(0u));
               ir_if *f2EA7 = new(mem_ctx) ir_if(operand(r2EA9).val);
               exec_list *const f2EA7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2EA7->then_instructions;

                  body.emit(assign(r2E9B, add(r2E9B, body.constant(int(2))), 0x01));

                  body.emit(assign(r2E99, lshift(r2E99, body.constant(int(2))), 0x01));


               body.instructions = f2EA7_parent_instructions;
               body.emit(f2EA7);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r2EAB = bit_and(r2E99, body.constant(2147483648u));
               ir_expression *const r2EAC = equal(r2EAB, body.constant(0u));
               ir_if *f2EAA = new(mem_ctx) ir_if(operand(r2EAC).val);
               exec_list *const f2EAA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2EAA->then_instructions;

                  body.emit(assign(r2E9B, add(r2E9B, body.constant(int(1))), 0x01));


               body.instructions = f2EAA_parent_instructions;
               body.emit(f2EAA);

               /* END IF */

               body.emit(assign(r2E9A, r2E9B, 0x01));


            body.instructions = f2E9C_parent_instructions;
            body.emit(f2E9C);

            /* END IF */

            body.emit(assign(r2E96, add(r2E9A, body.constant(int(-11))), 0x01));

            /* IF CONDITION */
            ir_expression *const r2EAE = lequal(body.constant(int(0)), r2E96);
            ir_if *f2EAD = new(mem_ctx) ir_if(operand(r2EAE).val);
            exec_list *const f2EAD_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2EAD->then_instructions;

               body.emit(assign(r2E95, body.constant(0u), 0x01));

               ir_variable *const r2EAF = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r2EAF, lshift(r2E94, r2E96), 0x01));

               ir_variable *const r2EB0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r2EB2 = equal(r2E96, body.constant(int(0)));
               ir_if *f2EB1 = new(mem_ctx) ir_if(operand(r2EB2).val);
               exec_list *const f2EB1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2EB1->then_instructions;

                  body.emit(assign(r2EB0, r2E93, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2EB1->else_instructions;

                  ir_expression *const r2EB3 = lshift(r2E93, r2E96);
                  ir_expression *const r2EB4 = neg(r2E96);
                  ir_expression *const r2EB5 = bit_and(r2EB4, body.constant(int(31)));
                  ir_expression *const r2EB6 = rshift(r2E94, r2EB5);
                  body.emit(assign(r2EB0, bit_or(r2EB3, r2EB6), 0x01));


               body.instructions = f2EB1_parent_instructions;
               body.emit(f2EB1);

               /* END IF */

               body.emit(assign(r2E93, r2EB0, 0x01));

               body.emit(assign(r2E94, r2EAF, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2EAD->else_instructions;

               ir_variable *const r2EB7 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r2EB7, body.constant(0u), 0x01));

               ir_variable *const r2EB8 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r2EB8, neg(r2E96), 0x01));

               ir_variable *const r2EB9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r2EB9);
               ir_variable *const r2EBA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2EBA);
               ir_variable *const r2EBB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2EBB);
               ir_variable *const r2EBC = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2EBD = neg(r2EB8);
               body.emit(assign(r2EBC, bit_and(r2EBD, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2EBF = equal(r2EB8, body.constant(int(0)));
               ir_if *f2EBE = new(mem_ctx) ir_if(operand(r2EBF).val);
               exec_list *const f2EBE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2EBE->then_instructions;

                  body.emit(assign(r2EB9, r2EB7, 0x01));

                  body.emit(assign(r2EBA, r2E94, 0x01));

                  body.emit(assign(r2EBB, r2E93, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2EBE->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2EC1 = less(r2EB8, body.constant(int(32)));
                  ir_if *f2EC0 = new(mem_ctx) ir_if(operand(r2EC1).val);
                  exec_list *const f2EC0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2EC0->then_instructions;

                     body.emit(assign(r2EB9, lshift(r2E94, r2EBC), 0x01));

                     ir_expression *const r2EC2 = lshift(r2E93, r2EBC);
                     ir_expression *const r2EC3 = rshift(r2E94, r2EB8);
                     body.emit(assign(r2EBA, bit_or(r2EC2, r2EC3), 0x01));

                     body.emit(assign(r2EBB, rshift(r2E93, r2EB8), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2EC0->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2EC5 = equal(r2EB8, body.constant(int(32)));
                     ir_if *f2EC4 = new(mem_ctx) ir_if(operand(r2EC5).val);
                     exec_list *const f2EC4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2EC4->then_instructions;

                        body.emit(assign(r2EB9, r2E94, 0x01));

                        body.emit(assign(r2EBA, r2E93, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2EC4->else_instructions;

                        body.emit(assign(r2EB7, bit_or(body.constant(0u), r2E94), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2EC7 = less(r2EB8, body.constant(int(64)));
                        ir_if *f2EC6 = new(mem_ctx) ir_if(operand(r2EC7).val);
                        exec_list *const f2EC6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2EC6->then_instructions;

                           body.emit(assign(r2EB9, lshift(r2E93, r2EBC), 0x01));

                           ir_expression *const r2EC8 = bit_and(r2EB8, body.constant(int(31)));
                           body.emit(assign(r2EBA, rshift(r2E93, r2EC8), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2EC6->else_instructions;

                           ir_variable *const r2EC9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r2ECB = equal(r2EB8, body.constant(int(64)));
                           ir_if *f2ECA = new(mem_ctx) ir_if(operand(r2ECB).val);
                           exec_list *const f2ECA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2ECA->then_instructions;

                              body.emit(assign(r2EC9, r2E93, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2ECA->else_instructions;

                              ir_expression *const r2ECC = nequal(r2E93, body.constant(0u));
                              ir_expression *const r2ECD = expr(ir_unop_b2i, r2ECC);
                              body.emit(assign(r2EC9, expr(ir_unop_i2u, r2ECD), 0x01));


                           body.instructions = f2ECA_parent_instructions;
                           body.emit(f2ECA);

                           /* END IF */

                           body.emit(assign(r2EB9, r2EC9, 0x01));

                           body.emit(assign(r2EBA, body.constant(0u), 0x01));


                        body.instructions = f2EC6_parent_instructions;
                        body.emit(f2EC6);

                        /* END IF */


                     body.instructions = f2EC4_parent_instructions;
                     body.emit(f2EC4);

                     /* END IF */

                     body.emit(assign(r2EBB, body.constant(0u), 0x01));


                  body.instructions = f2EC0_parent_instructions;
                  body.emit(f2EC0);

                  /* END IF */

                  ir_expression *const r2ECE = nequal(r2EB7, body.constant(0u));
                  ir_expression *const r2ECF = expr(ir_unop_b2i, r2ECE);
                  ir_expression *const r2ED0 = expr(ir_unop_i2u, r2ECF);
                  body.emit(assign(r2EB9, bit_or(r2EB9, r2ED0), 0x01));


               body.instructions = f2EBE_parent_instructions;
               body.emit(f2EBE);

               /* END IF */

               body.emit(assign(r2E93, r2EBB, 0x01));

               body.emit(assign(r2E94, r2EBA, 0x01));

               body.emit(assign(r2E95, r2EB9, 0x01));


            body.instructions = f2EAD_parent_instructions;
            body.emit(f2EAD);

            /* END IF */

            body.emit(assign(r2E92, sub(r2E92, r2E96), 0x01));

            ir_variable *const r2ED1 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r2ED1, r2E92, 0x01));

            ir_variable *const r2ED2 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r2ED2, r2E93, 0x01));

            ir_variable *const r2ED3 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r2ED3, r2E94, 0x01));

            ir_variable *const r2ED4 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r2ED4, r2E95, 0x01));

            ir_variable *const r2ED5 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r2ED5, body.constant(true), 0x01));

            ir_variable *const r2ED6 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r2ED7 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r2ED7);
            ir_expression *const r2ED8 = expr(ir_unop_u2i, r2E95);
            body.emit(assign(r2ED7, less(r2ED8, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r2EDA = lequal(body.constant(int(2045)), r2E92);
            ir_if *f2ED9 = new(mem_ctx) ir_if(operand(r2EDA).val);
            exec_list *const f2ED9_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2ED9->then_instructions;

               ir_variable *const r2EDB = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r2EDD = less(body.constant(int(2045)), r2E92);
               ir_if *f2EDC = new(mem_ctx) ir_if(operand(r2EDD).val);
               exec_list *const f2EDC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2EDC->then_instructions;

                  body.emit(assign(r2EDB, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2EDC->else_instructions;

                  ir_variable *const r2EDE = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2EE0 = equal(r2E92, body.constant(int(2045)));
                  ir_if *f2EDF = new(mem_ctx) ir_if(operand(r2EE0).val);
                  exec_list *const f2EDF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2EDF->then_instructions;

                     ir_expression *const r2EE1 = equal(body.constant(2097151u), r2E93);
                     ir_expression *const r2EE2 = equal(body.constant(4294967295u), r2E94);
                     body.emit(assign(r2EDE, logic_and(r2EE1, r2EE2), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2EDF->else_instructions;

                     body.emit(assign(r2EDE, body.constant(false), 0x01));


                  body.instructions = f2EDF_parent_instructions;
                  body.emit(f2EDF);

                  /* END IF */

                  body.emit(assign(r2EDB, logic_and(r2EDE, r2ED7), 0x01));


               body.instructions = f2EDC_parent_instructions;
               body.emit(f2EDC);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2EE3 = new(mem_ctx) ir_if(operand(r2EDB).val);
               exec_list *const f2EE3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2EE3->then_instructions;

                  ir_variable *const r2EE4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2EE4);
                  ir_expression *const r2EE5 = lshift(r2E28, body.constant(int(31)));
                  body.emit(assign(r2EE4, add(r2EE5, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r2EE4, body.constant(0u), 0x01));

                  body.emit(assign(r2ED6, r2EE4, 0x03));

                  body.emit(assign(r2ED5, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2EE3->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2EE7 = less(r2E92, body.constant(int(0)));
                  ir_if *f2EE6 = new(mem_ctx) ir_if(operand(r2EE7).val);
                  exec_list *const f2EE6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2EE6->then_instructions;

                     ir_variable *const r2EE8 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r2EE8, r2E95, 0x01));

                     ir_variable *const r2EE9 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r2EE9, neg(r2E92), 0x01));

                     ir_variable *const r2EEA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r2EEA);
                     ir_variable *const r2EEB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r2EEB);
                     ir_variable *const r2EEC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r2EEC);
                     ir_variable *const r2EED = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r2EEE = neg(r2EE9);
                     body.emit(assign(r2EED, bit_and(r2EEE, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r2EF0 = equal(r2EE9, body.constant(int(0)));
                     ir_if *f2EEF = new(mem_ctx) ir_if(operand(r2EF0).val);
                     exec_list *const f2EEF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2EEF->then_instructions;

                        body.emit(assign(r2EEA, r2E95, 0x01));

                        body.emit(assign(r2EEB, r2E94, 0x01));

                        body.emit(assign(r2EEC, r2E93, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2EEF->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2EF2 = less(r2EE9, body.constant(int(32)));
                        ir_if *f2EF1 = new(mem_ctx) ir_if(operand(r2EF2).val);
                        exec_list *const f2EF1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2EF1->then_instructions;

                           body.emit(assign(r2EEA, lshift(r2E94, r2EED), 0x01));

                           ir_expression *const r2EF3 = lshift(r2E93, r2EED);
                           ir_expression *const r2EF4 = rshift(r2E94, r2EE9);
                           body.emit(assign(r2EEB, bit_or(r2EF3, r2EF4), 0x01));

                           body.emit(assign(r2EEC, rshift(r2E93, r2EE9), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2EF1->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2EF6 = equal(r2EE9, body.constant(int(32)));
                           ir_if *f2EF5 = new(mem_ctx) ir_if(operand(r2EF6).val);
                           exec_list *const f2EF5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2EF5->then_instructions;

                              body.emit(assign(r2EEA, r2E94, 0x01));

                              body.emit(assign(r2EEB, r2E93, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2EF5->else_instructions;

                              body.emit(assign(r2EE8, bit_or(r2E95, r2E94), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r2EF8 = less(r2EE9, body.constant(int(64)));
                              ir_if *f2EF7 = new(mem_ctx) ir_if(operand(r2EF8).val);
                              exec_list *const f2EF7_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2EF7->then_instructions;

                                 body.emit(assign(r2EEA, lshift(r2E93, r2EED), 0x01));

                                 ir_expression *const r2EF9 = bit_and(r2EE9, body.constant(int(31)));
                                 body.emit(assign(r2EEB, rshift(r2E93, r2EF9), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2EF7->else_instructions;

                                 ir_variable *const r2EFA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r2EFC = equal(r2EE9, body.constant(int(64)));
                                 ir_if *f2EFB = new(mem_ctx) ir_if(operand(r2EFC).val);
                                 exec_list *const f2EFB_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2EFB->then_instructions;

                                    body.emit(assign(r2EFA, r2E93, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2EFB->else_instructions;

                                    ir_expression *const r2EFD = nequal(r2E93, body.constant(0u));
                                    ir_expression *const r2EFE = expr(ir_unop_b2i, r2EFD);
                                    body.emit(assign(r2EFA, expr(ir_unop_i2u, r2EFE), 0x01));


                                 body.instructions = f2EFB_parent_instructions;
                                 body.emit(f2EFB);

                                 /* END IF */

                                 body.emit(assign(r2EEA, r2EFA, 0x01));

                                 body.emit(assign(r2EEB, body.constant(0u), 0x01));


                              body.instructions = f2EF7_parent_instructions;
                              body.emit(f2EF7);

                              /* END IF */


                           body.instructions = f2EF5_parent_instructions;
                           body.emit(f2EF5);

                           /* END IF */

                           body.emit(assign(r2EEC, body.constant(0u), 0x01));


                        body.instructions = f2EF1_parent_instructions;
                        body.emit(f2EF1);

                        /* END IF */

                        ir_expression *const r2EFF = nequal(r2EE8, body.constant(0u));
                        ir_expression *const r2F00 = expr(ir_unop_b2i, r2EFF);
                        ir_expression *const r2F01 = expr(ir_unop_i2u, r2F00);
                        body.emit(assign(r2EEA, bit_or(r2EEA, r2F01), 0x01));


                     body.instructions = f2EEF_parent_instructions;
                     body.emit(f2EEF);

                     /* END IF */

                     body.emit(assign(r2ED2, r2EEC, 0x01));

                     body.emit(assign(r2ED3, r2EEB, 0x01));

                     body.emit(assign(r2ED4, r2EEA, 0x01));

                     body.emit(assign(r2ED1, body.constant(int(0)), 0x01));

                     body.emit(assign(r2ED7, less(r2EEA, body.constant(0u)), 0x01));


                  body.instructions = f2EE6_parent_instructions;
                  body.emit(f2EE6);

                  /* END IF */


               body.instructions = f2EE3_parent_instructions;
               body.emit(f2EE3);

               /* END IF */


            body.instructions = f2ED9_parent_instructions;
            body.emit(f2ED9);

            /* END IF */

            /* IF CONDITION */
            ir_if *f2F02 = new(mem_ctx) ir_if(operand(r2ED5).val);
            exec_list *const f2F02_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2F02->then_instructions;

               /* IF CONDITION */
               ir_if *f2F03 = new(mem_ctx) ir_if(operand(r2ED7).val);
               exec_list *const f2F03_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2F03->then_instructions;

                  ir_variable *const r2F04 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r2F04, add(r2ED3, body.constant(1u)), 0x01));

                  ir_expression *const r2F05 = less(r2F04, r2ED3);
                  ir_expression *const r2F06 = expr(ir_unop_b2i, r2F05);
                  ir_expression *const r2F07 = expr(ir_unop_i2u, r2F06);
                  body.emit(assign(r2ED2, add(r2ED2, r2F07), 0x01));

                  ir_expression *const r2F08 = equal(r2ED4, body.constant(0u));
                  ir_expression *const r2F09 = expr(ir_unop_b2i, r2F08);
                  ir_expression *const r2F0A = expr(ir_unop_i2u, r2F09);
                  ir_expression *const r2F0B = add(r2ED4, r2F0A);
                  ir_expression *const r2F0C = bit_and(r2F0B, body.constant(1u));
                  ir_expression *const r2F0D = expr(ir_unop_bit_not, r2F0C);
                  body.emit(assign(r2ED3, bit_and(r2F04, r2F0D), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2F03->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2F0F = bit_or(r2ED2, r2ED3);
                  ir_expression *const r2F10 = equal(r2F0F, body.constant(0u));
                  ir_if *f2F0E = new(mem_ctx) ir_if(operand(r2F10).val);
                  exec_list *const f2F0E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2F0E->then_instructions;

                     body.emit(assign(r2ED1, body.constant(int(0)), 0x01));


                  body.instructions = f2F0E_parent_instructions;
                  body.emit(f2F0E);

                  /* END IF */


               body.instructions = f2F03_parent_instructions;
               body.emit(f2F03);

               /* END IF */

               ir_variable *const r2F11 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r2F11);
               ir_expression *const r2F12 = lshift(r2E28, body.constant(int(31)));
               ir_expression *const r2F13 = expr(ir_unop_i2u, r2ED1);
               ir_expression *const r2F14 = lshift(r2F13, body.constant(int(20)));
               ir_expression *const r2F15 = add(r2F12, r2F14);
               body.emit(assign(r2F11, add(r2F15, r2ED2), 0x02));

               body.emit(assign(r2F11, r2ED3, 0x01));

               body.emit(assign(r2ED6, r2F11, 0x03));

               body.emit(assign(r2ED5, body.constant(false), 0x01));


            body.instructions = f2F02_parent_instructions;
            body.emit(f2F02);

            /* END IF */

            body.emit(assign(r2E2D, r2ED6, 0x03));


         body.instructions = f2E46_parent_instructions;
         body.emit(f2E46);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f2E44->else_instructions;

         /* IF CONDITION */
         ir_expression *const r2F17 = less(r2E2E, body.constant(int(0)));
         ir_if *f2F16 = new(mem_ctx) ir_if(operand(r2F17).val);
         exec_list *const f2F16_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f2F16->then_instructions;

            /* IF CONDITION */
            ir_expression *const r2F19 = equal(r2E39, body.constant(int(2047)));
            ir_if *f2F18 = new(mem_ctx) ir_if(operand(r2F19).val);
            exec_list *const f2F18_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2F18->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2F1B = bit_or(swizzle_y(r2E30), swizzle_x(r2E30));
               ir_expression *const r2F1C = nequal(r2F1B, body.constant(0u));
               ir_if *f2F1A = new(mem_ctx) ir_if(operand(r2F1C).val);
               exec_list *const f2F1A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2F1A->then_instructions;

                  ir_variable *const r2F1D = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r2F1D, swizzle_x(r28D7), 0x01));

                  ir_variable *const r2F1E = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r2F1E, swizzle_x(r290B), 0x01));

                  ir_variable *const r2F1F = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r2F20 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r2F21 = rshift(swizzle_y(r28D7), body.constant(int(19)));
                  ir_expression *const r2F22 = bit_and(r2F21, body.constant(4095u));
                  ir_expression *const r2F23 = equal(r2F22, body.constant(4094u));
                  ir_expression *const r2F24 = nequal(swizzle_x(r28D7), body.constant(0u));
                  ir_expression *const r2F25 = bit_and(swizzle_y(r28D7), body.constant(524287u));
                  ir_expression *const r2F26 = nequal(r2F25, body.constant(0u));
                  ir_expression *const r2F27 = logic_or(r2F24, r2F26);
                  body.emit(assign(r2F20, logic_and(r2F23, r2F27), 0x01));

                  ir_variable *const r2F28 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r2F29 = lshift(swizzle_y(r290B), body.constant(int(1)));
                  ir_expression *const r2F2A = lequal(body.constant(4292870144u), r2F29);
                  ir_expression *const r2F2B = nequal(swizzle_x(r290B), body.constant(0u));
                  ir_expression *const r2F2C = bit_and(swizzle_y(r290B), body.constant(1048575u));
                  ir_expression *const r2F2D = nequal(r2F2C, body.constant(0u));
                  ir_expression *const r2F2E = logic_or(r2F2B, r2F2D);
                  body.emit(assign(r2F28, logic_and(r2F2A, r2F2E), 0x01));

                  body.emit(assign(r2F1D, bit_or(swizzle_y(r28D7), body.constant(524288u)), 0x02));

                  body.emit(assign(r2F1E, bit_or(swizzle_y(r290B), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r2F30 = lshift(swizzle_y(r28D7), body.constant(int(1)));
                  ir_expression *const r2F31 = lequal(body.constant(4292870144u), r2F30);
                  ir_expression *const r2F32 = nequal(swizzle_x(r28D7), body.constant(0u));
                  ir_expression *const r2F33 = bit_and(swizzle_y(r28D7), body.constant(1048575u));
                  ir_expression *const r2F34 = nequal(r2F33, body.constant(0u));
                  ir_expression *const r2F35 = logic_or(r2F32, r2F34);
                  ir_expression *const r2F36 = logic_and(r2F31, r2F35);
                  ir_if *f2F2F = new(mem_ctx) ir_if(operand(r2F36).val);
                  exec_list *const f2F2F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2F2F->then_instructions;

                     ir_variable *const r2F37 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2F39 = logic_and(r2F20, r2F28);
                     ir_if *f2F38 = new(mem_ctx) ir_if(operand(r2F39).val);
                     exec_list *const f2F38_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2F38->then_instructions;

                        body.emit(assign(r2F37, r2F1E, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2F38->else_instructions;

                        body.emit(assign(r2F37, r2F1D, 0x03));


                     body.instructions = f2F38_parent_instructions;
                     body.emit(f2F38);

                     /* END IF */

                     body.emit(assign(r2F1F, r2F37, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2F2F->else_instructions;

                     body.emit(assign(r2F1F, r2F1E, 0x03));


                  body.instructions = f2F2F_parent_instructions;
                  body.emit(f2F2F);

                  /* END IF */

                  body.emit(assign(r2E2D, r2F1F, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2F1A->else_instructions;

                  ir_variable *const r2F3A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2F3A);
                  ir_expression *const r2F3B = bit_xor(r2E28, body.constant(1u));
                  ir_expression *const r2F3C = lshift(r2F3B, body.constant(int(31)));
                  body.emit(assign(r2F3A, add(r2F3C, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r2F3A, body.constant(0u), 0x01));

                  body.emit(assign(r2E2D, r2F3A, 0x03));


               body.instructions = f2F1A_parent_instructions;
               body.emit(f2F1A);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2F18->else_instructions;

               /* IF CONDITION */
               ir_expression *const r2F3E = equal(r2E35, body.constant(int(0)));
               ir_if *f2F3D = new(mem_ctx) ir_if(operand(r2F3E).val);
               exec_list *const f2F3D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2F3D->then_instructions;

                  body.emit(assign(r2E2E, add(r2E2E, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2F3D->else_instructions;

                  body.emit(assign(r2E32, bit_or(swizzle_y(r2E32), body.constant(1073741824u)), 0x02));


               body.instructions = f2F3D_parent_instructions;
               body.emit(f2F3D);

               /* END IF */

               ir_variable *const r2F3F = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r2F3F, swizzle_y(r2E32), 0x01));

               ir_variable *const r2F40 = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r2F40, swizzle_x(r2E32), 0x01));

               ir_variable *const r2F41 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r2F41, neg(r2E2E), 0x01));

               ir_variable *const r2F42 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r2F42);
               ir_variable *const r2F43 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r2F43);
               ir_variable *const r2F44 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r2F45 = neg(r2F41);
               body.emit(assign(r2F44, bit_and(r2F45, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2F47 = equal(r2F41, body.constant(int(0)));
               ir_if *f2F46 = new(mem_ctx) ir_if(operand(r2F47).val);
               exec_list *const f2F46_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2F46->then_instructions;

                  body.emit(assign(r2F42, r2F40, 0x01));

                  body.emit(assign(r2F43, r2F3F, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2F46->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r2F49 = less(r2F41, body.constant(int(32)));
                  ir_if *f2F48 = new(mem_ctx) ir_if(operand(r2F49).val);
                  exec_list *const f2F48_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2F48->then_instructions;

                     ir_expression *const r2F4A = lshift(swizzle_y(r2E32), r2F44);
                     ir_expression *const r2F4B = rshift(r2E3C, r2F41);
                     ir_expression *const r2F4C = bit_or(r2F4A, r2F4B);
                     ir_expression *const r2F4D = lshift(r2E3C, r2F44);
                     ir_expression *const r2F4E = nequal(r2F4D, body.constant(0u));
                     ir_expression *const r2F4F = expr(ir_unop_b2i, r2F4E);
                     ir_expression *const r2F50 = expr(ir_unop_i2u, r2F4F);
                     body.emit(assign(r2F42, bit_or(r2F4C, r2F50), 0x01));

                     body.emit(assign(r2F43, rshift(swizzle_y(r2E32), r2F41), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2F48->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2F52 = equal(r2F41, body.constant(int(32)));
                     ir_if *f2F51 = new(mem_ctx) ir_if(operand(r2F52).val);
                     exec_list *const f2F51_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2F51->then_instructions;

                        ir_expression *const r2F53 = nequal(r2E3C, body.constant(0u));
                        ir_expression *const r2F54 = expr(ir_unop_b2i, r2F53);
                        ir_expression *const r2F55 = expr(ir_unop_i2u, r2F54);
                        body.emit(assign(r2F42, bit_or(swizzle_y(r2E32), r2F55), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2F51->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2F57 = less(r2F41, body.constant(int(64)));
                        ir_if *f2F56 = new(mem_ctx) ir_if(operand(r2F57).val);
                        exec_list *const f2F56_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2F56->then_instructions;

                           ir_expression *const r2F58 = bit_and(r2F41, body.constant(int(31)));
                           ir_expression *const r2F59 = rshift(swizzle_y(r2E32), r2F58);
                           ir_expression *const r2F5A = lshift(swizzle_y(r2E32), r2F44);
                           ir_expression *const r2F5B = bit_or(r2F5A, r2E3C);
                           ir_expression *const r2F5C = nequal(r2F5B, body.constant(0u));
                           ir_expression *const r2F5D = expr(ir_unop_b2i, r2F5C);
                           ir_expression *const r2F5E = expr(ir_unop_i2u, r2F5D);
                           body.emit(assign(r2F42, bit_or(r2F59, r2F5E), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2F56->else_instructions;

                           ir_expression *const r2F5F = bit_or(swizzle_y(r2E32), r2E3C);
                           ir_expression *const r2F60 = nequal(r2F5F, body.constant(0u));
                           ir_expression *const r2F61 = expr(ir_unop_b2i, r2F60);
                           body.emit(assign(r2F42, expr(ir_unop_i2u, r2F61), 0x01));


                        body.instructions = f2F56_parent_instructions;
                        body.emit(f2F56);

                        /* END IF */


                     body.instructions = f2F51_parent_instructions;
                     body.emit(f2F51);

                     /* END IF */

                     body.emit(assign(r2F43, body.constant(0u), 0x01));


                  body.instructions = f2F48_parent_instructions;
                  body.emit(f2F48);

                  /* END IF */


               body.instructions = f2F46_parent_instructions;
               body.emit(f2F46);

               /* END IF */

               body.emit(assign(r2E32, r2F43, 0x02));

               body.emit(assign(r2E32, r2F42, 0x01));

               body.emit(assign(r2E30, bit_or(swizzle_y(r2E30), body.constant(1073741824u)), 0x02));

               ir_variable *const r2F62 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r2F63 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r2F63, sub(swizzle_x(r2E30), r2F42), 0x01));

               ir_expression *const r2F64 = sub(swizzle_y(r2E30), r2F43);
               ir_expression *const r2F65 = less(swizzle_x(r2E30), r2F42);
               ir_expression *const r2F66 = expr(ir_unop_b2i, r2F65);
               ir_expression *const r2F67 = expr(ir_unop_i2u, r2F66);
               body.emit(assign(r2F62, sub(r2F64, r2F67), 0x01));

               body.emit(assign(r2E2C, bit_xor(r2E28, body.constant(1u)), 0x01));

               body.emit(assign(r2E33, add(r2E39, body.constant(int(-1))), 0x01));

               ir_variable *const r2F68 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2F68, add(r2E33, body.constant(int(-10))), 0x01));

               ir_variable *const r2F69 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2F69, r2F62, 0x01));

               ir_variable *const r2F6A = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2F6A, r2F63, 0x01));

               ir_variable *const r2F6B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r2F6B);
               ir_variable *const r2F6C = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r2F6C);
               /* IF CONDITION */
               ir_expression *const r2F6E = equal(r2F62, body.constant(0u));
               ir_if *f2F6D = new(mem_ctx) ir_if(operand(r2F6E).val);
               exec_list *const f2F6D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2F6D->then_instructions;

                  body.emit(assign(r2F69, r2F63, 0x01));

                  body.emit(assign(r2F6A, body.constant(0u), 0x01));

                  body.emit(assign(r2F68, add(r2F68, body.constant(int(-32))), 0x01));


               body.instructions = f2F6D_parent_instructions;
               body.emit(f2F6D);

               /* END IF */

               ir_variable *const r2F6F = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r2F6F, r2F69, 0x01));

               ir_variable *const r2F70 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r2F71 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r2F71);
               /* IF CONDITION */
               ir_expression *const r2F73 = equal(r2F69, body.constant(0u));
               ir_if *f2F72 = new(mem_ctx) ir_if(operand(r2F73).val);
               exec_list *const f2F72_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2F72->then_instructions;

                  body.emit(assign(r2F70, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2F72->else_instructions;

                  body.emit(assign(r2F71, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2F75 = bit_and(r2F69, body.constant(4294901760u));
                  ir_expression *const r2F76 = equal(r2F75, body.constant(0u));
                  ir_if *f2F74 = new(mem_ctx) ir_if(operand(r2F76).val);
                  exec_list *const f2F74_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2F74->then_instructions;

                     body.emit(assign(r2F71, body.constant(int(16)), 0x01));

                     body.emit(assign(r2F6F, lshift(r2F69, body.constant(int(16))), 0x01));


                  body.instructions = f2F74_parent_instructions;
                  body.emit(f2F74);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2F78 = bit_and(r2F6F, body.constant(4278190080u));
                  ir_expression *const r2F79 = equal(r2F78, body.constant(0u));
                  ir_if *f2F77 = new(mem_ctx) ir_if(operand(r2F79).val);
                  exec_list *const f2F77_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2F77->then_instructions;

                     body.emit(assign(r2F71, add(r2F71, body.constant(int(8))), 0x01));

                     body.emit(assign(r2F6F, lshift(r2F6F, body.constant(int(8))), 0x01));


                  body.instructions = f2F77_parent_instructions;
                  body.emit(f2F77);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2F7B = bit_and(r2F6F, body.constant(4026531840u));
                  ir_expression *const r2F7C = equal(r2F7B, body.constant(0u));
                  ir_if *f2F7A = new(mem_ctx) ir_if(operand(r2F7C).val);
                  exec_list *const f2F7A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2F7A->then_instructions;

                     body.emit(assign(r2F71, add(r2F71, body.constant(int(4))), 0x01));

                     body.emit(assign(r2F6F, lshift(r2F6F, body.constant(int(4))), 0x01));


                  body.instructions = f2F7A_parent_instructions;
                  body.emit(f2F7A);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2F7E = bit_and(r2F6F, body.constant(3221225472u));
                  ir_expression *const r2F7F = equal(r2F7E, body.constant(0u));
                  ir_if *f2F7D = new(mem_ctx) ir_if(operand(r2F7F).val);
                  exec_list *const f2F7D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2F7D->then_instructions;

                     body.emit(assign(r2F71, add(r2F71, body.constant(int(2))), 0x01));

                     body.emit(assign(r2F6F, lshift(r2F6F, body.constant(int(2))), 0x01));


                  body.instructions = f2F7D_parent_instructions;
                  body.emit(f2F7D);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r2F81 = bit_and(r2F6F, body.constant(2147483648u));
                  ir_expression *const r2F82 = equal(r2F81, body.constant(0u));
                  ir_if *f2F80 = new(mem_ctx) ir_if(operand(r2F82).val);
                  exec_list *const f2F80_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2F80->then_instructions;

                     body.emit(assign(r2F71, add(r2F71, body.constant(int(1))), 0x01));


                  body.instructions = f2F80_parent_instructions;
                  body.emit(f2F80);

                  /* END IF */

                  body.emit(assign(r2F70, r2F71, 0x01));


               body.instructions = f2F72_parent_instructions;
               body.emit(f2F72);

               /* END IF */

               body.emit(assign(r2F6C, add(r2F70, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2F84 = lequal(body.constant(int(0)), r2F6C);
               ir_if *f2F83 = new(mem_ctx) ir_if(operand(r2F84).val);
               exec_list *const f2F83_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2F83->then_instructions;

                  body.emit(assign(r2F6B, body.constant(0u), 0x01));

                  ir_variable *const r2F85 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r2F85, lshift(r2F6A, r2F6C), 0x01));

                  ir_variable *const r2F86 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2F88 = equal(r2F6C, body.constant(int(0)));
                  ir_if *f2F87 = new(mem_ctx) ir_if(operand(r2F88).val);
                  exec_list *const f2F87_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2F87->then_instructions;

                     body.emit(assign(r2F86, r2F69, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2F87->else_instructions;

                     ir_expression *const r2F89 = lshift(r2F69, r2F6C);
                     ir_expression *const r2F8A = neg(r2F6C);
                     ir_expression *const r2F8B = bit_and(r2F8A, body.constant(int(31)));
                     ir_expression *const r2F8C = rshift(r2F6A, r2F8B);
                     body.emit(assign(r2F86, bit_or(r2F89, r2F8C), 0x01));


                  body.instructions = f2F87_parent_instructions;
                  body.emit(f2F87);

                  /* END IF */

                  body.emit(assign(r2F69, r2F86, 0x01));

                  body.emit(assign(r2F6A, r2F85, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2F83->else_instructions;

                  ir_variable *const r2F8D = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r2F8D, body.constant(0u), 0x01));

                  ir_variable *const r2F8E = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r2F8E, neg(r2F6C), 0x01));

                  ir_variable *const r2F8F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r2F8F);
                  ir_variable *const r2F90 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r2F90);
                  ir_variable *const r2F91 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r2F91);
                  ir_variable *const r2F92 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r2F93 = neg(r2F8E);
                  body.emit(assign(r2F92, bit_and(r2F93, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r2F95 = equal(r2F8E, body.constant(int(0)));
                  ir_if *f2F94 = new(mem_ctx) ir_if(operand(r2F95).val);
                  exec_list *const f2F94_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2F94->then_instructions;

                     body.emit(assign(r2F8F, r2F8D, 0x01));

                     body.emit(assign(r2F90, r2F6A, 0x01));

                     body.emit(assign(r2F91, r2F69, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2F94->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2F97 = less(r2F8E, body.constant(int(32)));
                     ir_if *f2F96 = new(mem_ctx) ir_if(operand(r2F97).val);
                     exec_list *const f2F96_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2F96->then_instructions;

                        body.emit(assign(r2F8F, lshift(r2F6A, r2F92), 0x01));

                        ir_expression *const r2F98 = lshift(r2F69, r2F92);
                        ir_expression *const r2F99 = rshift(r2F6A, r2F8E);
                        body.emit(assign(r2F90, bit_or(r2F98, r2F99), 0x01));

                        body.emit(assign(r2F91, rshift(r2F69, r2F8E), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2F96->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r2F9B = equal(r2F8E, body.constant(int(32)));
                        ir_if *f2F9A = new(mem_ctx) ir_if(operand(r2F9B).val);
                        exec_list *const f2F9A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2F9A->then_instructions;

                           body.emit(assign(r2F8F, r2F6A, 0x01));

                           body.emit(assign(r2F90, r2F69, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2F9A->else_instructions;

                           body.emit(assign(r2F8D, bit_or(body.constant(0u), r2F6A), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r2F9D = less(r2F8E, body.constant(int(64)));
                           ir_if *f2F9C = new(mem_ctx) ir_if(operand(r2F9D).val);
                           exec_list *const f2F9C_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2F9C->then_instructions;

                              body.emit(assign(r2F8F, lshift(r2F69, r2F92), 0x01));

                              ir_expression *const r2F9E = bit_and(r2F8E, body.constant(int(31)));
                              body.emit(assign(r2F90, rshift(r2F69, r2F9E), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2F9C->else_instructions;

                              ir_variable *const r2F9F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r2FA1 = equal(r2F8E, body.constant(int(64)));
                              ir_if *f2FA0 = new(mem_ctx) ir_if(operand(r2FA1).val);
                              exec_list *const f2FA0_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2FA0->then_instructions;

                                 body.emit(assign(r2F9F, r2F69, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2FA0->else_instructions;

                                 ir_expression *const r2FA2 = nequal(r2F69, body.constant(0u));
                                 ir_expression *const r2FA3 = expr(ir_unop_b2i, r2FA2);
                                 body.emit(assign(r2F9F, expr(ir_unop_i2u, r2FA3), 0x01));


                              body.instructions = f2FA0_parent_instructions;
                              body.emit(f2FA0);

                              /* END IF */

                              body.emit(assign(r2F8F, r2F9F, 0x01));

                              body.emit(assign(r2F90, body.constant(0u), 0x01));


                           body.instructions = f2F9C_parent_instructions;
                           body.emit(f2F9C);

                           /* END IF */


                        body.instructions = f2F9A_parent_instructions;
                        body.emit(f2F9A);

                        /* END IF */

                        body.emit(assign(r2F91, body.constant(0u), 0x01));


                     body.instructions = f2F96_parent_instructions;
                     body.emit(f2F96);

                     /* END IF */

                     ir_expression *const r2FA4 = nequal(r2F8D, body.constant(0u));
                     ir_expression *const r2FA5 = expr(ir_unop_b2i, r2FA4);
                     ir_expression *const r2FA6 = expr(ir_unop_i2u, r2FA5);
                     body.emit(assign(r2F8F, bit_or(r2F8F, r2FA6), 0x01));


                  body.instructions = f2F94_parent_instructions;
                  body.emit(f2F94);

                  /* END IF */

                  body.emit(assign(r2F69, r2F91, 0x01));

                  body.emit(assign(r2F6A, r2F90, 0x01));

                  body.emit(assign(r2F6B, r2F8F, 0x01));


               body.instructions = f2F83_parent_instructions;
               body.emit(f2F83);

               /* END IF */

               body.emit(assign(r2F68, sub(r2F68, r2F6C), 0x01));

               ir_variable *const r2FA7 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r2FA7, r2F68, 0x01));

               ir_variable *const r2FA8 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r2FA8, r2F69, 0x01));

               ir_variable *const r2FA9 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r2FA9, r2F6A, 0x01));

               ir_variable *const r2FAA = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r2FAA, r2F6B, 0x01));

               ir_variable *const r2FAB = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r2FAB, body.constant(true), 0x01));

               ir_variable *const r2FAC = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r2FAD = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r2FAD);
               ir_expression *const r2FAE = expr(ir_unop_u2i, r2F6B);
               body.emit(assign(r2FAD, less(r2FAE, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r2FB0 = lequal(body.constant(int(2045)), r2F68);
               ir_if *f2FAF = new(mem_ctx) ir_if(operand(r2FB0).val);
               exec_list *const f2FAF_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2FAF->then_instructions;

                  ir_variable *const r2FB1 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r2FB3 = less(body.constant(int(2045)), r2F68);
                  ir_if *f2FB2 = new(mem_ctx) ir_if(operand(r2FB3).val);
                  exec_list *const f2FB2_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2FB2->then_instructions;

                     body.emit(assign(r2FB1, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2FB2->else_instructions;

                     ir_variable *const r2FB4 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r2FB6 = equal(r2F68, body.constant(int(2045)));
                     ir_if *f2FB5 = new(mem_ctx) ir_if(operand(r2FB6).val);
                     exec_list *const f2FB5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2FB5->then_instructions;

                        ir_expression *const r2FB7 = equal(body.constant(2097151u), r2F69);
                        ir_expression *const r2FB8 = equal(body.constant(4294967295u), r2F6A);
                        body.emit(assign(r2FB4, logic_and(r2FB7, r2FB8), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f2FB5->else_instructions;

                        body.emit(assign(r2FB4, body.constant(false), 0x01));


                     body.instructions = f2FB5_parent_instructions;
                     body.emit(f2FB5);

                     /* END IF */

                     body.emit(assign(r2FB1, logic_and(r2FB4, r2FAD), 0x01));


                  body.instructions = f2FB2_parent_instructions;
                  body.emit(f2FB2);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f2FB9 = new(mem_ctx) ir_if(operand(r2FB1).val);
                  exec_list *const f2FB9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2FB9->then_instructions;

                     ir_variable *const r2FBA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r2FBA);
                     ir_expression *const r2FBB = lshift(r2E2C, body.constant(int(31)));
                     body.emit(assign(r2FBA, add(r2FBB, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r2FBA, body.constant(0u), 0x01));

                     body.emit(assign(r2FAC, r2FBA, 0x03));

                     body.emit(assign(r2FAB, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2FB9->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2FBD = less(r2F68, body.constant(int(0)));
                     ir_if *f2FBC = new(mem_ctx) ir_if(operand(r2FBD).val);
                     exec_list *const f2FBC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2FBC->then_instructions;

                        ir_variable *const r2FBE = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r2FBE, r2F6B, 0x01));

                        ir_variable *const r2FBF = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r2FBF, neg(r2F68), 0x01));

                        ir_variable *const r2FC0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r2FC0);
                        ir_variable *const r2FC1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r2FC1);
                        ir_variable *const r2FC2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r2FC2);
                        ir_variable *const r2FC3 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r2FC4 = neg(r2FBF);
                        body.emit(assign(r2FC3, bit_and(r2FC4, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r2FC6 = equal(r2FBF, body.constant(int(0)));
                        ir_if *f2FC5 = new(mem_ctx) ir_if(operand(r2FC6).val);
                        exec_list *const f2FC5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f2FC5->then_instructions;

                           body.emit(assign(r2FC0, r2F6B, 0x01));

                           body.emit(assign(r2FC1, r2F6A, 0x01));

                           body.emit(assign(r2FC2, r2F69, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f2FC5->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r2FC8 = less(r2FBF, body.constant(int(32)));
                           ir_if *f2FC7 = new(mem_ctx) ir_if(operand(r2FC8).val);
                           exec_list *const f2FC7_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f2FC7->then_instructions;

                              body.emit(assign(r2FC0, lshift(r2F6A, r2FC3), 0x01));

                              ir_expression *const r2FC9 = lshift(r2F69, r2FC3);
                              ir_expression *const r2FCA = rshift(r2F6A, r2FBF);
                              body.emit(assign(r2FC1, bit_or(r2FC9, r2FCA), 0x01));

                              body.emit(assign(r2FC2, rshift(r2F69, r2FBF), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f2FC7->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r2FCC = equal(r2FBF, body.constant(int(32)));
                              ir_if *f2FCB = new(mem_ctx) ir_if(operand(r2FCC).val);
                              exec_list *const f2FCB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f2FCB->then_instructions;

                                 body.emit(assign(r2FC0, r2F6A, 0x01));

                                 body.emit(assign(r2FC1, r2F69, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f2FCB->else_instructions;

                                 body.emit(assign(r2FBE, bit_or(r2F6B, r2F6A), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r2FCE = less(r2FBF, body.constant(int(64)));
                                 ir_if *f2FCD = new(mem_ctx) ir_if(operand(r2FCE).val);
                                 exec_list *const f2FCD_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f2FCD->then_instructions;

                                    body.emit(assign(r2FC0, lshift(r2F69, r2FC3), 0x01));

                                    ir_expression *const r2FCF = bit_and(r2FBF, body.constant(int(31)));
                                    body.emit(assign(r2FC1, rshift(r2F69, r2FCF), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f2FCD->else_instructions;

                                    ir_variable *const r2FD0 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r2FD2 = equal(r2FBF, body.constant(int(64)));
                                    ir_if *f2FD1 = new(mem_ctx) ir_if(operand(r2FD2).val);
                                    exec_list *const f2FD1_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f2FD1->then_instructions;

                                       body.emit(assign(r2FD0, r2F69, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f2FD1->else_instructions;

                                       ir_expression *const r2FD3 = nequal(r2F69, body.constant(0u));
                                       ir_expression *const r2FD4 = expr(ir_unop_b2i, r2FD3);
                                       body.emit(assign(r2FD0, expr(ir_unop_i2u, r2FD4), 0x01));


                                    body.instructions = f2FD1_parent_instructions;
                                    body.emit(f2FD1);

                                    /* END IF */

                                    body.emit(assign(r2FC0, r2FD0, 0x01));

                                    body.emit(assign(r2FC1, body.constant(0u), 0x01));


                                 body.instructions = f2FCD_parent_instructions;
                                 body.emit(f2FCD);

                                 /* END IF */


                              body.instructions = f2FCB_parent_instructions;
                              body.emit(f2FCB);

                              /* END IF */

                              body.emit(assign(r2FC2, body.constant(0u), 0x01));


                           body.instructions = f2FC7_parent_instructions;
                           body.emit(f2FC7);

                           /* END IF */

                           ir_expression *const r2FD5 = nequal(r2FBE, body.constant(0u));
                           ir_expression *const r2FD6 = expr(ir_unop_b2i, r2FD5);
                           ir_expression *const r2FD7 = expr(ir_unop_i2u, r2FD6);
                           body.emit(assign(r2FC0, bit_or(r2FC0, r2FD7), 0x01));


                        body.instructions = f2FC5_parent_instructions;
                        body.emit(f2FC5);

                        /* END IF */

                        body.emit(assign(r2FA8, r2FC2, 0x01));

                        body.emit(assign(r2FA9, r2FC1, 0x01));

                        body.emit(assign(r2FAA, r2FC0, 0x01));

                        body.emit(assign(r2FA7, body.constant(int(0)), 0x01));

                        body.emit(assign(r2FAD, less(r2FC0, body.constant(0u)), 0x01));


                     body.instructions = f2FBC_parent_instructions;
                     body.emit(f2FBC);

                     /* END IF */


                  body.instructions = f2FB9_parent_instructions;
                  body.emit(f2FB9);

                  /* END IF */


               body.instructions = f2FAF_parent_instructions;
               body.emit(f2FAF);

               /* END IF */

               /* IF CONDITION */
               ir_if *f2FD8 = new(mem_ctx) ir_if(operand(r2FAB).val);
               exec_list *const f2FD8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2FD8->then_instructions;

                  /* IF CONDITION */
                  ir_if *f2FD9 = new(mem_ctx) ir_if(operand(r2FAD).val);
                  exec_list *const f2FD9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f2FD9->then_instructions;

                     ir_variable *const r2FDA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r2FDA, add(r2FA9, body.constant(1u)), 0x01));

                     ir_expression *const r2FDB = less(r2FDA, r2FA9);
                     ir_expression *const r2FDC = expr(ir_unop_b2i, r2FDB);
                     ir_expression *const r2FDD = expr(ir_unop_i2u, r2FDC);
                     body.emit(assign(r2FA8, add(r2FA8, r2FDD), 0x01));

                     ir_expression *const r2FDE = equal(r2FAA, body.constant(0u));
                     ir_expression *const r2FDF = expr(ir_unop_b2i, r2FDE);
                     ir_expression *const r2FE0 = expr(ir_unop_i2u, r2FDF);
                     ir_expression *const r2FE1 = add(r2FAA, r2FE0);
                     ir_expression *const r2FE2 = bit_and(r2FE1, body.constant(1u));
                     ir_expression *const r2FE3 = expr(ir_unop_bit_not, r2FE2);
                     body.emit(assign(r2FA9, bit_and(r2FDA, r2FE3), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f2FD9->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r2FE5 = bit_or(r2FA8, r2FA9);
                     ir_expression *const r2FE6 = equal(r2FE5, body.constant(0u));
                     ir_if *f2FE4 = new(mem_ctx) ir_if(operand(r2FE6).val);
                     exec_list *const f2FE4_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f2FE4->then_instructions;

                        body.emit(assign(r2FA7, body.constant(int(0)), 0x01));


                     body.instructions = f2FE4_parent_instructions;
                     body.emit(f2FE4);

                     /* END IF */


                  body.instructions = f2FD9_parent_instructions;
                  body.emit(f2FD9);

                  /* END IF */

                  ir_variable *const r2FE7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r2FE7);
                  ir_expression *const r2FE8 = lshift(r2E2C, body.constant(int(31)));
                  ir_expression *const r2FE9 = expr(ir_unop_i2u, r2FA7);
                  ir_expression *const r2FEA = lshift(r2FE9, body.constant(int(20)));
                  ir_expression *const r2FEB = add(r2FE8, r2FEA);
                  body.emit(assign(r2FE7, add(r2FEB, r2FA8), 0x02));

                  body.emit(assign(r2FE7, r2FA9, 0x01));

                  body.emit(assign(r2FAC, r2FE7, 0x03));

                  body.emit(assign(r2FAB, body.constant(false), 0x01));


               body.instructions = f2FD8_parent_instructions;
               body.emit(f2FD8);

               /* END IF */

               body.emit(assign(r2E2D, r2FAC, 0x03));


            body.instructions = f2F18_parent_instructions;
            body.emit(f2F18);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f2F16->else_instructions;

            /* IF CONDITION */
            ir_expression *const r2FED = equal(r2E35, body.constant(int(2047)));
            ir_if *f2FEC = new(mem_ctx) ir_if(operand(r2FED).val);
            exec_list *const f2FEC_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f2FEC->then_instructions;

               /* IF CONDITION */
               ir_expression *const r2FEF = bit_or(swizzle_y(r2E32), swizzle_x(r2E32));
               ir_expression *const r2FF0 = bit_or(swizzle_y(r2E30), swizzle_x(r2E30));
               ir_expression *const r2FF1 = bit_or(r2FEF, r2FF0);
               ir_expression *const r2FF2 = nequal(r2FF1, body.constant(0u));
               ir_if *f2FEE = new(mem_ctx) ir_if(operand(r2FF2).val);
               exec_list *const f2FEE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f2FEE->then_instructions;

                  ir_variable *const r2FF3 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r2FF3, swizzle_x(r28D7), 0x01));

                  ir_variable *const r2FF4 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r2FF4, swizzle_x(r290B), 0x01));

                  ir_variable *const r2FF5 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r2FF6 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r2FF7 = rshift(swizzle_y(r28D7), body.constant(int(19)));
                  ir_expression *const r2FF8 = bit_and(r2FF7, body.constant(4095u));
                  ir_expression *const r2FF9 = equal(r2FF8, body.constant(4094u));
                  ir_expression *const r2FFA = nequal(swizzle_x(r28D7), body.constant(0u));
                  ir_expression *const r2FFB = bit_and(swizzle_y(r28D7), body.constant(524287u));
                  ir_expression *const r2FFC = nequal(r2FFB, body.constant(0u));
                  ir_expression *const r2FFD = logic_or(r2FFA, r2FFC);
                  body.emit(assign(r2FF6, logic_and(r2FF9, r2FFD), 0x01));

                  ir_variable *const r2FFE = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r2FFF = lshift(swizzle_y(r290B), body.constant(int(1)));
                  ir_expression *const r3000 = lequal(body.constant(4292870144u), r2FFF);
                  ir_expression *const r3001 = nequal(swizzle_x(r290B), body.constant(0u));
                  ir_expression *const r3002 = bit_and(swizzle_y(r290B), body.constant(1048575u));
                  ir_expression *const r3003 = nequal(r3002, body.constant(0u));
                  ir_expression *const r3004 = logic_or(r3001, r3003);
                  body.emit(assign(r2FFE, logic_and(r3000, r3004), 0x01));

                  body.emit(assign(r2FF3, bit_or(swizzle_y(r28D7), body.constant(524288u)), 0x02));

                  body.emit(assign(r2FF4, bit_or(swizzle_y(r290B), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r3006 = lshift(swizzle_y(r28D7), body.constant(int(1)));
                  ir_expression *const r3007 = lequal(body.constant(4292870144u), r3006);
                  ir_expression *const r3008 = nequal(swizzle_x(r28D7), body.constant(0u));
                  ir_expression *const r3009 = bit_and(swizzle_y(r28D7), body.constant(1048575u));
                  ir_expression *const r300A = nequal(r3009, body.constant(0u));
                  ir_expression *const r300B = logic_or(r3008, r300A);
                  ir_expression *const r300C = logic_and(r3007, r300B);
                  ir_if *f3005 = new(mem_ctx) ir_if(operand(r300C).val);
                  exec_list *const f3005_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3005->then_instructions;

                     ir_variable *const r300D = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r300F = logic_and(r2FF6, r2FFE);
                     ir_if *f300E = new(mem_ctx) ir_if(operand(r300F).val);
                     exec_list *const f300E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f300E->then_instructions;

                        body.emit(assign(r300D, r2FF4, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f300E->else_instructions;

                        body.emit(assign(r300D, r2FF3, 0x03));


                     body.instructions = f300E_parent_instructions;
                     body.emit(f300E);

                     /* END IF */

                     body.emit(assign(r2FF5, r300D, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3005->else_instructions;

                     body.emit(assign(r2FF5, r2FF4, 0x03));


                  body.instructions = f3005_parent_instructions;
                  body.emit(f3005);

                  /* END IF */

                  body.emit(assign(r2E2D, r2FF5, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f2FEE->else_instructions;

                  ir_constant_data r3010_data;
                  memset(&r3010_data, 0, sizeof(ir_constant_data));
                  r3010_data.u[0] = 4294967295;
                  r3010_data.u[1] = 4294967295;
                  ir_constant *const r3010 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r3010_data);
                  body.emit(assign(r2E2D, r3010, 0x03));


               body.instructions = f2FEE_parent_instructions;
               body.emit(f2FEE);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f2FEC->else_instructions;

               /* IF CONDITION */
               ir_expression *const r3012 = equal(r2E35, body.constant(int(0)));
               ir_if *f3011 = new(mem_ctx) ir_if(operand(r3012).val);
               exec_list *const f3011_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3011->then_instructions;

                  body.emit(assign(r2E31, body.constant(int(1)), 0x01));

                  body.emit(assign(r2E2F, body.constant(int(1)), 0x01));


               body.instructions = f3011_parent_instructions;
               body.emit(f3011);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r3014 = less(swizzle_y(r2E30), swizzle_y(r2E32));
               ir_if *f3013 = new(mem_ctx) ir_if(operand(r3014).val);
               exec_list *const f3013_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3013->then_instructions;

                  ir_variable *const r3015 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r3016 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r3016, sub(swizzle_x(r2E32), swizzle_x(r2E30)), 0x01));

                  ir_expression *const r3017 = sub(swizzle_y(r2E32), swizzle_y(r2E30));
                  ir_expression *const r3018 = less(swizzle_x(r2E32), swizzle_x(r2E30));
                  ir_expression *const r3019 = expr(ir_unop_b2i, r3018);
                  ir_expression *const r301A = expr(ir_unop_i2u, r3019);
                  body.emit(assign(r3015, sub(r3017, r301A), 0x01));

                  body.emit(assign(r2E33, add(r2E31, body.constant(int(-1))), 0x01));

                  ir_variable *const r301B = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r301B, add(r2E33, body.constant(int(-10))), 0x01));

                  ir_variable *const r301C = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r301C, r3015, 0x01));

                  ir_variable *const r301D = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r301D, r3016, 0x01));

                  ir_variable *const r301E = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r301E);
                  ir_variable *const r301F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r301F);
                  /* IF CONDITION */
                  ir_expression *const r3021 = equal(r3015, body.constant(0u));
                  ir_if *f3020 = new(mem_ctx) ir_if(operand(r3021).val);
                  exec_list *const f3020_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3020->then_instructions;

                     body.emit(assign(r301C, r3016, 0x01));

                     body.emit(assign(r301D, body.constant(0u), 0x01));

                     body.emit(assign(r301B, add(r301B, body.constant(int(-32))), 0x01));


                  body.instructions = f3020_parent_instructions;
                  body.emit(f3020);

                  /* END IF */

                  ir_variable *const r3022 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r3022, r301C, 0x01));

                  ir_variable *const r3023 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r3024 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r3024);
                  /* IF CONDITION */
                  ir_expression *const r3026 = equal(r301C, body.constant(0u));
                  ir_if *f3025 = new(mem_ctx) ir_if(operand(r3026).val);
                  exec_list *const f3025_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3025->then_instructions;

                     body.emit(assign(r3023, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3025->else_instructions;

                     body.emit(assign(r3024, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3028 = bit_and(r301C, body.constant(4294901760u));
                     ir_expression *const r3029 = equal(r3028, body.constant(0u));
                     ir_if *f3027 = new(mem_ctx) ir_if(operand(r3029).val);
                     exec_list *const f3027_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3027->then_instructions;

                        body.emit(assign(r3024, body.constant(int(16)), 0x01));

                        body.emit(assign(r3022, lshift(r301C, body.constant(int(16))), 0x01));


                     body.instructions = f3027_parent_instructions;
                     body.emit(f3027);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r302B = bit_and(r3022, body.constant(4278190080u));
                     ir_expression *const r302C = equal(r302B, body.constant(0u));
                     ir_if *f302A = new(mem_ctx) ir_if(operand(r302C).val);
                     exec_list *const f302A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f302A->then_instructions;

                        body.emit(assign(r3024, add(r3024, body.constant(int(8))), 0x01));

                        body.emit(assign(r3022, lshift(r3022, body.constant(int(8))), 0x01));


                     body.instructions = f302A_parent_instructions;
                     body.emit(f302A);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r302E = bit_and(r3022, body.constant(4026531840u));
                     ir_expression *const r302F = equal(r302E, body.constant(0u));
                     ir_if *f302D = new(mem_ctx) ir_if(operand(r302F).val);
                     exec_list *const f302D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f302D->then_instructions;

                        body.emit(assign(r3024, add(r3024, body.constant(int(4))), 0x01));

                        body.emit(assign(r3022, lshift(r3022, body.constant(int(4))), 0x01));


                     body.instructions = f302D_parent_instructions;
                     body.emit(f302D);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3031 = bit_and(r3022, body.constant(3221225472u));
                     ir_expression *const r3032 = equal(r3031, body.constant(0u));
                     ir_if *f3030 = new(mem_ctx) ir_if(operand(r3032).val);
                     exec_list *const f3030_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3030->then_instructions;

                        body.emit(assign(r3024, add(r3024, body.constant(int(2))), 0x01));

                        body.emit(assign(r3022, lshift(r3022, body.constant(int(2))), 0x01));


                     body.instructions = f3030_parent_instructions;
                     body.emit(f3030);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r3034 = bit_and(r3022, body.constant(2147483648u));
                     ir_expression *const r3035 = equal(r3034, body.constant(0u));
                     ir_if *f3033 = new(mem_ctx) ir_if(operand(r3035).val);
                     exec_list *const f3033_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3033->then_instructions;

                        body.emit(assign(r3024, add(r3024, body.constant(int(1))), 0x01));


                     body.instructions = f3033_parent_instructions;
                     body.emit(f3033);

                     /* END IF */

                     body.emit(assign(r3023, r3024, 0x01));


                  body.instructions = f3025_parent_instructions;
                  body.emit(f3025);

                  /* END IF */

                  body.emit(assign(r301F, add(r3023, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3037 = lequal(body.constant(int(0)), r301F);
                  ir_if *f3036 = new(mem_ctx) ir_if(operand(r3037).val);
                  exec_list *const f3036_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3036->then_instructions;

                     body.emit(assign(r301E, body.constant(0u), 0x01));

                     ir_variable *const r3038 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r3038, lshift(r301D, r301F), 0x01));

                     ir_variable *const r3039 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r303B = equal(r301F, body.constant(int(0)));
                     ir_if *f303A = new(mem_ctx) ir_if(operand(r303B).val);
                     exec_list *const f303A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f303A->then_instructions;

                        body.emit(assign(r3039, r301C, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f303A->else_instructions;

                        ir_expression *const r303C = lshift(r301C, r301F);
                        ir_expression *const r303D = neg(r301F);
                        ir_expression *const r303E = bit_and(r303D, body.constant(int(31)));
                        ir_expression *const r303F = rshift(r301D, r303E);
                        body.emit(assign(r3039, bit_or(r303C, r303F), 0x01));


                     body.instructions = f303A_parent_instructions;
                     body.emit(f303A);

                     /* END IF */

                     body.emit(assign(r301C, r3039, 0x01));

                     body.emit(assign(r301D, r3038, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3036->else_instructions;

                     ir_variable *const r3040 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r3040, body.constant(0u), 0x01));

                     ir_variable *const r3041 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r3041, neg(r301F), 0x01));

                     ir_variable *const r3042 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r3042);
                     ir_variable *const r3043 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r3043);
                     ir_variable *const r3044 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r3044);
                     ir_variable *const r3045 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r3046 = neg(r3041);
                     body.emit(assign(r3045, bit_and(r3046, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r3048 = equal(r3041, body.constant(int(0)));
                     ir_if *f3047 = new(mem_ctx) ir_if(operand(r3048).val);
                     exec_list *const f3047_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3047->then_instructions;

                        body.emit(assign(r3042, r3040, 0x01));

                        body.emit(assign(r3043, r301D, 0x01));

                        body.emit(assign(r3044, r301C, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3047->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r304A = less(r3041, body.constant(int(32)));
                        ir_if *f3049 = new(mem_ctx) ir_if(operand(r304A).val);
                        exec_list *const f3049_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3049->then_instructions;

                           body.emit(assign(r3042, lshift(r301D, r3045), 0x01));

                           ir_expression *const r304B = lshift(r301C, r3045);
                           ir_expression *const r304C = rshift(r301D, r3041);
                           body.emit(assign(r3043, bit_or(r304B, r304C), 0x01));

                           body.emit(assign(r3044, rshift(r301C, r3041), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3049->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r304E = equal(r3041, body.constant(int(32)));
                           ir_if *f304D = new(mem_ctx) ir_if(operand(r304E).val);
                           exec_list *const f304D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f304D->then_instructions;

                              body.emit(assign(r3042, r301D, 0x01));

                              body.emit(assign(r3043, r301C, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f304D->else_instructions;

                              body.emit(assign(r3040, bit_or(body.constant(0u), r301D), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3050 = less(r3041, body.constant(int(64)));
                              ir_if *f304F = new(mem_ctx) ir_if(operand(r3050).val);
                              exec_list *const f304F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f304F->then_instructions;

                                 body.emit(assign(r3042, lshift(r301C, r3045), 0x01));

                                 ir_expression *const r3051 = bit_and(r3041, body.constant(int(31)));
                                 body.emit(assign(r3043, rshift(r301C, r3051), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f304F->else_instructions;

                                 ir_variable *const r3052 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r3054 = equal(r3041, body.constant(int(64)));
                                 ir_if *f3053 = new(mem_ctx) ir_if(operand(r3054).val);
                                 exec_list *const f3053_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3053->then_instructions;

                                    body.emit(assign(r3052, r301C, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3053->else_instructions;

                                    ir_expression *const r3055 = nequal(r301C, body.constant(0u));
                                    ir_expression *const r3056 = expr(ir_unop_b2i, r3055);
                                    body.emit(assign(r3052, expr(ir_unop_i2u, r3056), 0x01));


                                 body.instructions = f3053_parent_instructions;
                                 body.emit(f3053);

                                 /* END IF */

                                 body.emit(assign(r3042, r3052, 0x01));

                                 body.emit(assign(r3043, body.constant(0u), 0x01));


                              body.instructions = f304F_parent_instructions;
                              body.emit(f304F);

                              /* END IF */


                           body.instructions = f304D_parent_instructions;
                           body.emit(f304D);

                           /* END IF */

                           body.emit(assign(r3044, body.constant(0u), 0x01));


                        body.instructions = f3049_parent_instructions;
                        body.emit(f3049);

                        /* END IF */

                        ir_expression *const r3057 = nequal(r3040, body.constant(0u));
                        ir_expression *const r3058 = expr(ir_unop_b2i, r3057);
                        ir_expression *const r3059 = expr(ir_unop_i2u, r3058);
                        body.emit(assign(r3042, bit_or(r3042, r3059), 0x01));


                     body.instructions = f3047_parent_instructions;
                     body.emit(f3047);

                     /* END IF */

                     body.emit(assign(r301C, r3044, 0x01));

                     body.emit(assign(r301D, r3043, 0x01));

                     body.emit(assign(r301E, r3042, 0x01));


                  body.instructions = f3036_parent_instructions;
                  body.emit(f3036);

                  /* END IF */

                  body.emit(assign(r301B, sub(r301B, r301F), 0x01));

                  ir_variable *const r305A = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r305A, r301B, 0x01));

                  ir_variable *const r305B = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r305B, r301C, 0x01));

                  ir_variable *const r305C = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r305C, r301D, 0x01));

                  ir_variable *const r305D = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r305D, r301E, 0x01));

                  ir_variable *const r305E = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r305E, body.constant(true), 0x01));

                  ir_variable *const r305F = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r3060 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r3060);
                  ir_expression *const r3061 = expr(ir_unop_u2i, r301E);
                  body.emit(assign(r3060, less(r3061, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3063 = lequal(body.constant(int(2045)), r301B);
                  ir_if *f3062 = new(mem_ctx) ir_if(operand(r3063).val);
                  exec_list *const f3062_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3062->then_instructions;

                     ir_variable *const r3064 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3066 = less(body.constant(int(2045)), r301B);
                     ir_if *f3065 = new(mem_ctx) ir_if(operand(r3066).val);
                     exec_list *const f3065_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3065->then_instructions;

                        body.emit(assign(r3064, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3065->else_instructions;

                        ir_variable *const r3067 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r3069 = equal(r301B, body.constant(int(2045)));
                        ir_if *f3068 = new(mem_ctx) ir_if(operand(r3069).val);
                        exec_list *const f3068_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3068->then_instructions;

                           ir_expression *const r306A = equal(body.constant(2097151u), r301C);
                           ir_expression *const r306B = equal(body.constant(4294967295u), r301D);
                           body.emit(assign(r3067, logic_and(r306A, r306B), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3068->else_instructions;

                           body.emit(assign(r3067, body.constant(false), 0x01));


                        body.instructions = f3068_parent_instructions;
                        body.emit(f3068);

                        /* END IF */

                        body.emit(assign(r3064, logic_and(r3067, r3060), 0x01));


                     body.instructions = f3065_parent_instructions;
                     body.emit(f3065);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f306C = new(mem_ctx) ir_if(operand(r3064).val);
                     exec_list *const f306C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f306C->then_instructions;

                        ir_variable *const r306D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r306D);
                        ir_expression *const r306E = lshift(r2E2C, body.constant(int(31)));
                        body.emit(assign(r306D, add(r306E, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r306D, body.constant(0u), 0x01));

                        body.emit(assign(r305F, r306D, 0x03));

                        body.emit(assign(r305E, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f306C->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3070 = less(r301B, body.constant(int(0)));
                        ir_if *f306F = new(mem_ctx) ir_if(operand(r3070).val);
                        exec_list *const f306F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f306F->then_instructions;

                           ir_variable *const r3071 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r3071, r301E, 0x01));

                           ir_variable *const r3072 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r3072, neg(r301B), 0x01));

                           ir_variable *const r3073 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r3073);
                           ir_variable *const r3074 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r3074);
                           ir_variable *const r3075 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r3075);
                           ir_variable *const r3076 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r3077 = neg(r3072);
                           body.emit(assign(r3076, bit_and(r3077, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3079 = equal(r3072, body.constant(int(0)));
                           ir_if *f3078 = new(mem_ctx) ir_if(operand(r3079).val);
                           exec_list *const f3078_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3078->then_instructions;

                              body.emit(assign(r3073, r301E, 0x01));

                              body.emit(assign(r3074, r301D, 0x01));

                              body.emit(assign(r3075, r301C, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3078->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r307B = less(r3072, body.constant(int(32)));
                              ir_if *f307A = new(mem_ctx) ir_if(operand(r307B).val);
                              exec_list *const f307A_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f307A->then_instructions;

                                 body.emit(assign(r3073, lshift(r301D, r3076), 0x01));

                                 ir_expression *const r307C = lshift(r301C, r3076);
                                 ir_expression *const r307D = rshift(r301D, r3072);
                                 body.emit(assign(r3074, bit_or(r307C, r307D), 0x01));

                                 body.emit(assign(r3075, rshift(r301C, r3072), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f307A->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r307F = equal(r3072, body.constant(int(32)));
                                 ir_if *f307E = new(mem_ctx) ir_if(operand(r307F).val);
                                 exec_list *const f307E_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f307E->then_instructions;

                                    body.emit(assign(r3073, r301D, 0x01));

                                    body.emit(assign(r3074, r301C, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f307E->else_instructions;

                                    body.emit(assign(r3071, bit_or(r301E, r301D), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r3081 = less(r3072, body.constant(int(64)));
                                    ir_if *f3080 = new(mem_ctx) ir_if(operand(r3081).val);
                                    exec_list *const f3080_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3080->then_instructions;

                                       body.emit(assign(r3073, lshift(r301C, r3076), 0x01));

                                       ir_expression *const r3082 = bit_and(r3072, body.constant(int(31)));
                                       body.emit(assign(r3074, rshift(r301C, r3082), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3080->else_instructions;

                                       ir_variable *const r3083 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r3085 = equal(r3072, body.constant(int(64)));
                                       ir_if *f3084 = new(mem_ctx) ir_if(operand(r3085).val);
                                       exec_list *const f3084_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3084->then_instructions;

                                          body.emit(assign(r3083, r301C, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3084->else_instructions;

                                          ir_expression *const r3086 = nequal(r301C, body.constant(0u));
                                          ir_expression *const r3087 = expr(ir_unop_b2i, r3086);
                                          body.emit(assign(r3083, expr(ir_unop_i2u, r3087), 0x01));


                                       body.instructions = f3084_parent_instructions;
                                       body.emit(f3084);

                                       /* END IF */

                                       body.emit(assign(r3073, r3083, 0x01));

                                       body.emit(assign(r3074, body.constant(0u), 0x01));


                                    body.instructions = f3080_parent_instructions;
                                    body.emit(f3080);

                                    /* END IF */


                                 body.instructions = f307E_parent_instructions;
                                 body.emit(f307E);

                                 /* END IF */

                                 body.emit(assign(r3075, body.constant(0u), 0x01));


                              body.instructions = f307A_parent_instructions;
                              body.emit(f307A);

                              /* END IF */

                              ir_expression *const r3088 = nequal(r3071, body.constant(0u));
                              ir_expression *const r3089 = expr(ir_unop_b2i, r3088);
                              ir_expression *const r308A = expr(ir_unop_i2u, r3089);
                              body.emit(assign(r3073, bit_or(r3073, r308A), 0x01));


                           body.instructions = f3078_parent_instructions;
                           body.emit(f3078);

                           /* END IF */

                           body.emit(assign(r305B, r3075, 0x01));

                           body.emit(assign(r305C, r3074, 0x01));

                           body.emit(assign(r305D, r3073, 0x01));

                           body.emit(assign(r305A, body.constant(int(0)), 0x01));

                           body.emit(assign(r3060, less(r3073, body.constant(0u)), 0x01));


                        body.instructions = f306F_parent_instructions;
                        body.emit(f306F);

                        /* END IF */


                     body.instructions = f306C_parent_instructions;
                     body.emit(f306C);

                     /* END IF */


                  body.instructions = f3062_parent_instructions;
                  body.emit(f3062);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f308B = new(mem_ctx) ir_if(operand(r305E).val);
                  exec_list *const f308B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f308B->then_instructions;

                     /* IF CONDITION */
                     ir_if *f308C = new(mem_ctx) ir_if(operand(r3060).val);
                     exec_list *const f308C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f308C->then_instructions;

                        ir_variable *const r308D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r308D, add(r305C, body.constant(1u)), 0x01));

                        ir_expression *const r308E = less(r308D, r305C);
                        ir_expression *const r308F = expr(ir_unop_b2i, r308E);
                        ir_expression *const r3090 = expr(ir_unop_i2u, r308F);
                        body.emit(assign(r305B, add(r305B, r3090), 0x01));

                        ir_expression *const r3091 = equal(r305D, body.constant(0u));
                        ir_expression *const r3092 = expr(ir_unop_b2i, r3091);
                        ir_expression *const r3093 = expr(ir_unop_i2u, r3092);
                        ir_expression *const r3094 = add(r305D, r3093);
                        ir_expression *const r3095 = bit_and(r3094, body.constant(1u));
                        ir_expression *const r3096 = expr(ir_unop_bit_not, r3095);
                        body.emit(assign(r305C, bit_and(r308D, r3096), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f308C->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3098 = bit_or(r305B, r305C);
                        ir_expression *const r3099 = equal(r3098, body.constant(0u));
                        ir_if *f3097 = new(mem_ctx) ir_if(operand(r3099).val);
                        exec_list *const f3097_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3097->then_instructions;

                           body.emit(assign(r305A, body.constant(int(0)), 0x01));


                        body.instructions = f3097_parent_instructions;
                        body.emit(f3097);

                        /* END IF */


                     body.instructions = f308C_parent_instructions;
                     body.emit(f308C);

                     /* END IF */

                     ir_variable *const r309A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r309A);
                     ir_expression *const r309B = lshift(r2E2C, body.constant(int(31)));
                     ir_expression *const r309C = expr(ir_unop_i2u, r305A);
                     ir_expression *const r309D = lshift(r309C, body.constant(int(20)));
                     ir_expression *const r309E = add(r309B, r309D);
                     body.emit(assign(r309A, add(r309E, r305B), 0x02));

                     body.emit(assign(r309A, r305C, 0x01));

                     body.emit(assign(r305F, r309A, 0x03));

                     body.emit(assign(r305E, body.constant(false), 0x01));


                  body.instructions = f308B_parent_instructions;
                  body.emit(f308B);

                  /* END IF */

                  body.emit(assign(r2E2D, r305F, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3013->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r30A0 = less(swizzle_y(r2E32), swizzle_y(r2E30));
                  ir_if *f309F = new(mem_ctx) ir_if(operand(r30A0).val);
                  exec_list *const f309F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f309F->then_instructions;

                     ir_variable *const r30A1 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r30A2 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r30A2, sub(swizzle_x(r2E30), swizzle_x(r2E32)), 0x01));

                     ir_expression *const r30A3 = sub(swizzle_y(r2E30), swizzle_y(r2E32));
                     ir_expression *const r30A4 = less(swizzle_x(r2E30), swizzle_x(r2E32));
                     ir_expression *const r30A5 = expr(ir_unop_b2i, r30A4);
                     ir_expression *const r30A6 = expr(ir_unop_i2u, r30A5);
                     body.emit(assign(r30A1, sub(r30A3, r30A6), 0x01));

                     body.emit(assign(r2E2C, bit_xor(r2E2C, body.constant(1u)), 0x01));

                     body.emit(assign(r2E33, add(r2E2F, body.constant(int(-1))), 0x01));

                     ir_variable *const r30A7 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r30A7, add(r2E33, body.constant(int(-10))), 0x01));

                     ir_variable *const r30A8 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r30A8, r30A1, 0x01));

                     ir_variable *const r30A9 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r30A9, r30A2, 0x01));

                     ir_variable *const r30AA = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r30AA);
                     ir_variable *const r30AB = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r30AB);
                     /* IF CONDITION */
                     ir_expression *const r30AD = equal(r30A1, body.constant(0u));
                     ir_if *f30AC = new(mem_ctx) ir_if(operand(r30AD).val);
                     exec_list *const f30AC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f30AC->then_instructions;

                        body.emit(assign(r30A8, r30A2, 0x01));

                        body.emit(assign(r30A9, body.constant(0u), 0x01));

                        body.emit(assign(r30A7, add(r30A7, body.constant(int(-32))), 0x01));


                     body.instructions = f30AC_parent_instructions;
                     body.emit(f30AC);

                     /* END IF */

                     ir_variable *const r30AE = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r30AE, r30A8, 0x01));

                     ir_variable *const r30AF = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r30B0 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r30B0);
                     /* IF CONDITION */
                     ir_expression *const r30B2 = equal(r30A8, body.constant(0u));
                     ir_if *f30B1 = new(mem_ctx) ir_if(operand(r30B2).val);
                     exec_list *const f30B1_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f30B1->then_instructions;

                        body.emit(assign(r30AF, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f30B1->else_instructions;

                        body.emit(assign(r30B0, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r30B4 = bit_and(r30A8, body.constant(4294901760u));
                        ir_expression *const r30B5 = equal(r30B4, body.constant(0u));
                        ir_if *f30B3 = new(mem_ctx) ir_if(operand(r30B5).val);
                        exec_list *const f30B3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f30B3->then_instructions;

                           body.emit(assign(r30B0, body.constant(int(16)), 0x01));

                           body.emit(assign(r30AE, lshift(r30A8, body.constant(int(16))), 0x01));


                        body.instructions = f30B3_parent_instructions;
                        body.emit(f30B3);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r30B7 = bit_and(r30AE, body.constant(4278190080u));
                        ir_expression *const r30B8 = equal(r30B7, body.constant(0u));
                        ir_if *f30B6 = new(mem_ctx) ir_if(operand(r30B8).val);
                        exec_list *const f30B6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f30B6->then_instructions;

                           body.emit(assign(r30B0, add(r30B0, body.constant(int(8))), 0x01));

                           body.emit(assign(r30AE, lshift(r30AE, body.constant(int(8))), 0x01));


                        body.instructions = f30B6_parent_instructions;
                        body.emit(f30B6);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r30BA = bit_and(r30AE, body.constant(4026531840u));
                        ir_expression *const r30BB = equal(r30BA, body.constant(0u));
                        ir_if *f30B9 = new(mem_ctx) ir_if(operand(r30BB).val);
                        exec_list *const f30B9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f30B9->then_instructions;

                           body.emit(assign(r30B0, add(r30B0, body.constant(int(4))), 0x01));

                           body.emit(assign(r30AE, lshift(r30AE, body.constant(int(4))), 0x01));


                        body.instructions = f30B9_parent_instructions;
                        body.emit(f30B9);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r30BD = bit_and(r30AE, body.constant(3221225472u));
                        ir_expression *const r30BE = equal(r30BD, body.constant(0u));
                        ir_if *f30BC = new(mem_ctx) ir_if(operand(r30BE).val);
                        exec_list *const f30BC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f30BC->then_instructions;

                           body.emit(assign(r30B0, add(r30B0, body.constant(int(2))), 0x01));

                           body.emit(assign(r30AE, lshift(r30AE, body.constant(int(2))), 0x01));


                        body.instructions = f30BC_parent_instructions;
                        body.emit(f30BC);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r30C0 = bit_and(r30AE, body.constant(2147483648u));
                        ir_expression *const r30C1 = equal(r30C0, body.constant(0u));
                        ir_if *f30BF = new(mem_ctx) ir_if(operand(r30C1).val);
                        exec_list *const f30BF_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f30BF->then_instructions;

                           body.emit(assign(r30B0, add(r30B0, body.constant(int(1))), 0x01));


                        body.instructions = f30BF_parent_instructions;
                        body.emit(f30BF);

                        /* END IF */

                        body.emit(assign(r30AF, r30B0, 0x01));


                     body.instructions = f30B1_parent_instructions;
                     body.emit(f30B1);

                     /* END IF */

                     body.emit(assign(r30AB, add(r30AF, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r30C3 = lequal(body.constant(int(0)), r30AB);
                     ir_if *f30C2 = new(mem_ctx) ir_if(operand(r30C3).val);
                     exec_list *const f30C2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f30C2->then_instructions;

                        body.emit(assign(r30AA, body.constant(0u), 0x01));

                        ir_variable *const r30C4 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r30C4, lshift(r30A9, r30AB), 0x01));

                        ir_variable *const r30C5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r30C7 = equal(r30AB, body.constant(int(0)));
                        ir_if *f30C6 = new(mem_ctx) ir_if(operand(r30C7).val);
                        exec_list *const f30C6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f30C6->then_instructions;

                           body.emit(assign(r30C5, r30A8, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f30C6->else_instructions;

                           ir_expression *const r30C8 = lshift(r30A8, r30AB);
                           ir_expression *const r30C9 = neg(r30AB);
                           ir_expression *const r30CA = bit_and(r30C9, body.constant(int(31)));
                           ir_expression *const r30CB = rshift(r30A9, r30CA);
                           body.emit(assign(r30C5, bit_or(r30C8, r30CB), 0x01));


                        body.instructions = f30C6_parent_instructions;
                        body.emit(f30C6);

                        /* END IF */

                        body.emit(assign(r30A8, r30C5, 0x01));

                        body.emit(assign(r30A9, r30C4, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f30C2->else_instructions;

                        ir_variable *const r30CC = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r30CC, body.constant(0u), 0x01));

                        ir_variable *const r30CD = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r30CD, neg(r30AB), 0x01));

                        ir_variable *const r30CE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r30CE);
                        ir_variable *const r30CF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r30CF);
                        ir_variable *const r30D0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r30D0);
                        ir_variable *const r30D1 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r30D2 = neg(r30CD);
                        body.emit(assign(r30D1, bit_and(r30D2, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r30D4 = equal(r30CD, body.constant(int(0)));
                        ir_if *f30D3 = new(mem_ctx) ir_if(operand(r30D4).val);
                        exec_list *const f30D3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f30D3->then_instructions;

                           body.emit(assign(r30CE, r30CC, 0x01));

                           body.emit(assign(r30CF, r30A9, 0x01));

                           body.emit(assign(r30D0, r30A8, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f30D3->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r30D6 = less(r30CD, body.constant(int(32)));
                           ir_if *f30D5 = new(mem_ctx) ir_if(operand(r30D6).val);
                           exec_list *const f30D5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f30D5->then_instructions;

                              body.emit(assign(r30CE, lshift(r30A9, r30D1), 0x01));

                              ir_expression *const r30D7 = lshift(r30A8, r30D1);
                              ir_expression *const r30D8 = rshift(r30A9, r30CD);
                              body.emit(assign(r30CF, bit_or(r30D7, r30D8), 0x01));

                              body.emit(assign(r30D0, rshift(r30A8, r30CD), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f30D5->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r30DA = equal(r30CD, body.constant(int(32)));
                              ir_if *f30D9 = new(mem_ctx) ir_if(operand(r30DA).val);
                              exec_list *const f30D9_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f30D9->then_instructions;

                                 body.emit(assign(r30CE, r30A9, 0x01));

                                 body.emit(assign(r30CF, r30A8, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f30D9->else_instructions;

                                 body.emit(assign(r30CC, bit_or(body.constant(0u), r30A9), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r30DC = less(r30CD, body.constant(int(64)));
                                 ir_if *f30DB = new(mem_ctx) ir_if(operand(r30DC).val);
                                 exec_list *const f30DB_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f30DB->then_instructions;

                                    body.emit(assign(r30CE, lshift(r30A8, r30D1), 0x01));

                                    ir_expression *const r30DD = bit_and(r30CD, body.constant(int(31)));
                                    body.emit(assign(r30CF, rshift(r30A8, r30DD), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f30DB->else_instructions;

                                    ir_variable *const r30DE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r30E0 = equal(r30CD, body.constant(int(64)));
                                    ir_if *f30DF = new(mem_ctx) ir_if(operand(r30E0).val);
                                    exec_list *const f30DF_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f30DF->then_instructions;

                                       body.emit(assign(r30DE, r30A8, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f30DF->else_instructions;

                                       ir_expression *const r30E1 = nequal(r30A8, body.constant(0u));
                                       ir_expression *const r30E2 = expr(ir_unop_b2i, r30E1);
                                       body.emit(assign(r30DE, expr(ir_unop_i2u, r30E2), 0x01));


                                    body.instructions = f30DF_parent_instructions;
                                    body.emit(f30DF);

                                    /* END IF */

                                    body.emit(assign(r30CE, r30DE, 0x01));

                                    body.emit(assign(r30CF, body.constant(0u), 0x01));


                                 body.instructions = f30DB_parent_instructions;
                                 body.emit(f30DB);

                                 /* END IF */


                              body.instructions = f30D9_parent_instructions;
                              body.emit(f30D9);

                              /* END IF */

                              body.emit(assign(r30D0, body.constant(0u), 0x01));


                           body.instructions = f30D5_parent_instructions;
                           body.emit(f30D5);

                           /* END IF */

                           ir_expression *const r30E3 = nequal(r30CC, body.constant(0u));
                           ir_expression *const r30E4 = expr(ir_unop_b2i, r30E3);
                           ir_expression *const r30E5 = expr(ir_unop_i2u, r30E4);
                           body.emit(assign(r30CE, bit_or(r30CE, r30E5), 0x01));


                        body.instructions = f30D3_parent_instructions;
                        body.emit(f30D3);

                        /* END IF */

                        body.emit(assign(r30A8, r30D0, 0x01));

                        body.emit(assign(r30A9, r30CF, 0x01));

                        body.emit(assign(r30AA, r30CE, 0x01));


                     body.instructions = f30C2_parent_instructions;
                     body.emit(f30C2);

                     /* END IF */

                     body.emit(assign(r30A7, sub(r30A7, r30AB), 0x01));

                     ir_variable *const r30E6 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r30E6, r30A7, 0x01));

                     ir_variable *const r30E7 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r30E7, r30A8, 0x01));

                     ir_variable *const r30E8 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r30E8, r30A9, 0x01));

                     ir_variable *const r30E9 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r30E9, r30AA, 0x01));

                     ir_variable *const r30EA = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r30EA, body.constant(true), 0x01));

                     ir_variable *const r30EB = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r30EC = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r30EC);
                     ir_expression *const r30ED = expr(ir_unop_u2i, r30AA);
                     body.emit(assign(r30EC, less(r30ED, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r30EF = lequal(body.constant(int(2045)), r30A7);
                     ir_if *f30EE = new(mem_ctx) ir_if(operand(r30EF).val);
                     exec_list *const f30EE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f30EE->then_instructions;

                        ir_variable *const r30F0 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r30F2 = less(body.constant(int(2045)), r30A7);
                        ir_if *f30F1 = new(mem_ctx) ir_if(operand(r30F2).val);
                        exec_list *const f30F1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f30F1->then_instructions;

                           body.emit(assign(r30F0, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f30F1->else_instructions;

                           ir_variable *const r30F3 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r30F5 = equal(r30A7, body.constant(int(2045)));
                           ir_if *f30F4 = new(mem_ctx) ir_if(operand(r30F5).val);
                           exec_list *const f30F4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f30F4->then_instructions;

                              ir_expression *const r30F6 = equal(body.constant(2097151u), r30A8);
                              ir_expression *const r30F7 = equal(body.constant(4294967295u), r30A9);
                              body.emit(assign(r30F3, logic_and(r30F6, r30F7), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f30F4->else_instructions;

                              body.emit(assign(r30F3, body.constant(false), 0x01));


                           body.instructions = f30F4_parent_instructions;
                           body.emit(f30F4);

                           /* END IF */

                           body.emit(assign(r30F0, logic_and(r30F3, r30EC), 0x01));


                        body.instructions = f30F1_parent_instructions;
                        body.emit(f30F1);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f30F8 = new(mem_ctx) ir_if(operand(r30F0).val);
                        exec_list *const f30F8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f30F8->then_instructions;

                           ir_variable *const r30F9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r30F9);
                           ir_expression *const r30FA = lshift(r2E2C, body.constant(int(31)));
                           body.emit(assign(r30F9, add(r30FA, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r30F9, body.constant(0u), 0x01));

                           body.emit(assign(r30EB, r30F9, 0x03));

                           body.emit(assign(r30EA, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f30F8->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r30FC = less(r30A7, body.constant(int(0)));
                           ir_if *f30FB = new(mem_ctx) ir_if(operand(r30FC).val);
                           exec_list *const f30FB_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f30FB->then_instructions;

                              ir_variable *const r30FD = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r30FD, r30AA, 0x01));

                              ir_variable *const r30FE = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r30FE, neg(r30A7), 0x01));

                              ir_variable *const r30FF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r30FF);
                              ir_variable *const r3100 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r3100);
                              ir_variable *const r3101 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r3101);
                              ir_variable *const r3102 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r3103 = neg(r30FE);
                              body.emit(assign(r3102, bit_and(r3103, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3105 = equal(r30FE, body.constant(int(0)));
                              ir_if *f3104 = new(mem_ctx) ir_if(operand(r3105).val);
                              exec_list *const f3104_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3104->then_instructions;

                                 body.emit(assign(r30FF, r30AA, 0x01));

                                 body.emit(assign(r3100, r30A9, 0x01));

                                 body.emit(assign(r3101, r30A8, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3104->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3107 = less(r30FE, body.constant(int(32)));
                                 ir_if *f3106 = new(mem_ctx) ir_if(operand(r3107).val);
                                 exec_list *const f3106_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3106->then_instructions;

                                    body.emit(assign(r30FF, lshift(r30A9, r3102), 0x01));

                                    ir_expression *const r3108 = lshift(r30A8, r3102);
                                    ir_expression *const r3109 = rshift(r30A9, r30FE);
                                    body.emit(assign(r3100, bit_or(r3108, r3109), 0x01));

                                    body.emit(assign(r3101, rshift(r30A8, r30FE), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3106->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r310B = equal(r30FE, body.constant(int(32)));
                                    ir_if *f310A = new(mem_ctx) ir_if(operand(r310B).val);
                                    exec_list *const f310A_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f310A->then_instructions;

                                       body.emit(assign(r30FF, r30A9, 0x01));

                                       body.emit(assign(r3100, r30A8, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f310A->else_instructions;

                                       body.emit(assign(r30FD, bit_or(r30AA, r30A9), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r310D = less(r30FE, body.constant(int(64)));
                                       ir_if *f310C = new(mem_ctx) ir_if(operand(r310D).val);
                                       exec_list *const f310C_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f310C->then_instructions;

                                          body.emit(assign(r30FF, lshift(r30A8, r3102), 0x01));

                                          ir_expression *const r310E = bit_and(r30FE, body.constant(int(31)));
                                          body.emit(assign(r3100, rshift(r30A8, r310E), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f310C->else_instructions;

                                          ir_variable *const r310F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r3111 = equal(r30FE, body.constant(int(64)));
                                          ir_if *f3110 = new(mem_ctx) ir_if(operand(r3111).val);
                                          exec_list *const f3110_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3110->then_instructions;

                                             body.emit(assign(r310F, r30A8, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3110->else_instructions;

                                             ir_expression *const r3112 = nequal(r30A8, body.constant(0u));
                                             ir_expression *const r3113 = expr(ir_unop_b2i, r3112);
                                             body.emit(assign(r310F, expr(ir_unop_i2u, r3113), 0x01));


                                          body.instructions = f3110_parent_instructions;
                                          body.emit(f3110);

                                          /* END IF */

                                          body.emit(assign(r30FF, r310F, 0x01));

                                          body.emit(assign(r3100, body.constant(0u), 0x01));


                                       body.instructions = f310C_parent_instructions;
                                       body.emit(f310C);

                                       /* END IF */


                                    body.instructions = f310A_parent_instructions;
                                    body.emit(f310A);

                                    /* END IF */

                                    body.emit(assign(r3101, body.constant(0u), 0x01));


                                 body.instructions = f3106_parent_instructions;
                                 body.emit(f3106);

                                 /* END IF */

                                 ir_expression *const r3114 = nequal(r30FD, body.constant(0u));
                                 ir_expression *const r3115 = expr(ir_unop_b2i, r3114);
                                 ir_expression *const r3116 = expr(ir_unop_i2u, r3115);
                                 body.emit(assign(r30FF, bit_or(r30FF, r3116), 0x01));


                              body.instructions = f3104_parent_instructions;
                              body.emit(f3104);

                              /* END IF */

                              body.emit(assign(r30E7, r3101, 0x01));

                              body.emit(assign(r30E8, r3100, 0x01));

                              body.emit(assign(r30E9, r30FF, 0x01));

                              body.emit(assign(r30E6, body.constant(int(0)), 0x01));

                              body.emit(assign(r30EC, less(r30FF, body.constant(0u)), 0x01));


                           body.instructions = f30FB_parent_instructions;
                           body.emit(f30FB);

                           /* END IF */


                        body.instructions = f30F8_parent_instructions;
                        body.emit(f30F8);

                        /* END IF */


                     body.instructions = f30EE_parent_instructions;
                     body.emit(f30EE);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f3117 = new(mem_ctx) ir_if(operand(r30EA).val);
                     exec_list *const f3117_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3117->then_instructions;

                        /* IF CONDITION */
                        ir_if *f3118 = new(mem_ctx) ir_if(operand(r30EC).val);
                        exec_list *const f3118_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3118->then_instructions;

                           ir_variable *const r3119 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r3119, add(r30E8, body.constant(1u)), 0x01));

                           ir_expression *const r311A = less(r3119, r30E8);
                           ir_expression *const r311B = expr(ir_unop_b2i, r311A);
                           ir_expression *const r311C = expr(ir_unop_i2u, r311B);
                           body.emit(assign(r30E7, add(r30E7, r311C), 0x01));

                           ir_expression *const r311D = equal(r30E9, body.constant(0u));
                           ir_expression *const r311E = expr(ir_unop_b2i, r311D);
                           ir_expression *const r311F = expr(ir_unop_i2u, r311E);
                           ir_expression *const r3120 = add(r30E9, r311F);
                           ir_expression *const r3121 = bit_and(r3120, body.constant(1u));
                           ir_expression *const r3122 = expr(ir_unop_bit_not, r3121);
                           body.emit(assign(r30E8, bit_and(r3119, r3122), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f3118->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3124 = bit_or(r30E7, r30E8);
                           ir_expression *const r3125 = equal(r3124, body.constant(0u));
                           ir_if *f3123 = new(mem_ctx) ir_if(operand(r3125).val);
                           exec_list *const f3123_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3123->then_instructions;

                              body.emit(assign(r30E6, body.constant(int(0)), 0x01));


                           body.instructions = f3123_parent_instructions;
                           body.emit(f3123);

                           /* END IF */


                        body.instructions = f3118_parent_instructions;
                        body.emit(f3118);

                        /* END IF */

                        ir_variable *const r3126 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r3126);
                        ir_expression *const r3127 = lshift(r2E2C, body.constant(int(31)));
                        ir_expression *const r3128 = expr(ir_unop_i2u, r30E6);
                        ir_expression *const r3129 = lshift(r3128, body.constant(int(20)));
                        ir_expression *const r312A = add(r3127, r3129);
                        body.emit(assign(r3126, add(r312A, r30E7), 0x02));

                        body.emit(assign(r3126, r30E8, 0x01));

                        body.emit(assign(r30EB, r3126, 0x03));

                        body.emit(assign(r30EA, body.constant(false), 0x01));


                     body.instructions = f3117_parent_instructions;
                     body.emit(f3117);

                     /* END IF */

                     body.emit(assign(r2E2D, r30EB, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f309F->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r312C = less(swizzle_x(r2E30), swizzle_x(r2E32));
                     ir_if *f312B = new(mem_ctx) ir_if(operand(r312C).val);
                     exec_list *const f312B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f312B->then_instructions;

                        ir_variable *const r312D = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r312E = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r312E, sub(swizzle_x(r2E32), swizzle_x(r2E30)), 0x01));

                        ir_expression *const r312F = sub(swizzle_y(r2E32), swizzle_y(r2E30));
                        ir_expression *const r3130 = less(swizzle_x(r2E32), swizzle_x(r2E30));
                        ir_expression *const r3131 = expr(ir_unop_b2i, r3130);
                        ir_expression *const r3132 = expr(ir_unop_i2u, r3131);
                        body.emit(assign(r312D, sub(r312F, r3132), 0x01));

                        body.emit(assign(r2E33, add(r2E31, body.constant(int(-1))), 0x01));

                        ir_variable *const r3133 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r3133, add(r2E33, body.constant(int(-10))), 0x01));

                        ir_variable *const r3134 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r3134, r312D, 0x01));

                        ir_variable *const r3135 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r3135, r312E, 0x01));

                        ir_variable *const r3136 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r3136);
                        ir_variable *const r3137 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r3137);
                        /* IF CONDITION */
                        ir_expression *const r3139 = equal(r312D, body.constant(0u));
                        ir_if *f3138 = new(mem_ctx) ir_if(operand(r3139).val);
                        exec_list *const f3138_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3138->then_instructions;

                           body.emit(assign(r3134, r312E, 0x01));

                           body.emit(assign(r3135, body.constant(0u), 0x01));

                           body.emit(assign(r3133, add(r3133, body.constant(int(-32))), 0x01));


                        body.instructions = f3138_parent_instructions;
                        body.emit(f3138);

                        /* END IF */

                        ir_variable *const r313A = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r313A, r3134, 0x01));

                        ir_variable *const r313B = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r313C = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r313C);
                        /* IF CONDITION */
                        ir_expression *const r313E = equal(r3134, body.constant(0u));
                        ir_if *f313D = new(mem_ctx) ir_if(operand(r313E).val);
                        exec_list *const f313D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f313D->then_instructions;

                           body.emit(assign(r313B, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f313D->else_instructions;

                           body.emit(assign(r313C, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3140 = bit_and(r3134, body.constant(4294901760u));
                           ir_expression *const r3141 = equal(r3140, body.constant(0u));
                           ir_if *f313F = new(mem_ctx) ir_if(operand(r3141).val);
                           exec_list *const f313F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f313F->then_instructions;

                              body.emit(assign(r313C, body.constant(int(16)), 0x01));

                              body.emit(assign(r313A, lshift(r3134, body.constant(int(16))), 0x01));


                           body.instructions = f313F_parent_instructions;
                           body.emit(f313F);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r3143 = bit_and(r313A, body.constant(4278190080u));
                           ir_expression *const r3144 = equal(r3143, body.constant(0u));
                           ir_if *f3142 = new(mem_ctx) ir_if(operand(r3144).val);
                           exec_list *const f3142_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3142->then_instructions;

                              body.emit(assign(r313C, add(r313C, body.constant(int(8))), 0x01));

                              body.emit(assign(r313A, lshift(r313A, body.constant(int(8))), 0x01));


                           body.instructions = f3142_parent_instructions;
                           body.emit(f3142);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r3146 = bit_and(r313A, body.constant(4026531840u));
                           ir_expression *const r3147 = equal(r3146, body.constant(0u));
                           ir_if *f3145 = new(mem_ctx) ir_if(operand(r3147).val);
                           exec_list *const f3145_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3145->then_instructions;

                              body.emit(assign(r313C, add(r313C, body.constant(int(4))), 0x01));

                              body.emit(assign(r313A, lshift(r313A, body.constant(int(4))), 0x01));


                           body.instructions = f3145_parent_instructions;
                           body.emit(f3145);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r3149 = bit_and(r313A, body.constant(3221225472u));
                           ir_expression *const r314A = equal(r3149, body.constant(0u));
                           ir_if *f3148 = new(mem_ctx) ir_if(operand(r314A).val);
                           exec_list *const f3148_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3148->then_instructions;

                              body.emit(assign(r313C, add(r313C, body.constant(int(2))), 0x01));

                              body.emit(assign(r313A, lshift(r313A, body.constant(int(2))), 0x01));


                           body.instructions = f3148_parent_instructions;
                           body.emit(f3148);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r314C = bit_and(r313A, body.constant(2147483648u));
                           ir_expression *const r314D = equal(r314C, body.constant(0u));
                           ir_if *f314B = new(mem_ctx) ir_if(operand(r314D).val);
                           exec_list *const f314B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f314B->then_instructions;

                              body.emit(assign(r313C, add(r313C, body.constant(int(1))), 0x01));


                           body.instructions = f314B_parent_instructions;
                           body.emit(f314B);

                           /* END IF */

                           body.emit(assign(r313B, r313C, 0x01));


                        body.instructions = f313D_parent_instructions;
                        body.emit(f313D);

                        /* END IF */

                        body.emit(assign(r3137, add(r313B, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r314F = lequal(body.constant(int(0)), r3137);
                        ir_if *f314E = new(mem_ctx) ir_if(operand(r314F).val);
                        exec_list *const f314E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f314E->then_instructions;

                           body.emit(assign(r3136, body.constant(0u), 0x01));

                           ir_variable *const r3150 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r3150, lshift(r3135, r3137), 0x01));

                           ir_variable *const r3151 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r3153 = equal(r3137, body.constant(int(0)));
                           ir_if *f3152 = new(mem_ctx) ir_if(operand(r3153).val);
                           exec_list *const f3152_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3152->then_instructions;

                              body.emit(assign(r3151, r3134, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3152->else_instructions;

                              ir_expression *const r3154 = lshift(r3134, r3137);
                              ir_expression *const r3155 = neg(r3137);
                              ir_expression *const r3156 = bit_and(r3155, body.constant(int(31)));
                              ir_expression *const r3157 = rshift(r3135, r3156);
                              body.emit(assign(r3151, bit_or(r3154, r3157), 0x01));


                           body.instructions = f3152_parent_instructions;
                           body.emit(f3152);

                           /* END IF */

                           body.emit(assign(r3134, r3151, 0x01));

                           body.emit(assign(r3135, r3150, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f314E->else_instructions;

                           ir_variable *const r3158 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r3158, body.constant(0u), 0x01));

                           ir_variable *const r3159 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r3159, neg(r3137), 0x01));

                           ir_variable *const r315A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r315A);
                           ir_variable *const r315B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r315B);
                           ir_variable *const r315C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r315C);
                           ir_variable *const r315D = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r315E = neg(r3159);
                           body.emit(assign(r315D, bit_and(r315E, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3160 = equal(r3159, body.constant(int(0)));
                           ir_if *f315F = new(mem_ctx) ir_if(operand(r3160).val);
                           exec_list *const f315F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f315F->then_instructions;

                              body.emit(assign(r315A, r3158, 0x01));

                              body.emit(assign(r315B, r3135, 0x01));

                              body.emit(assign(r315C, r3134, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f315F->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3162 = less(r3159, body.constant(int(32)));
                              ir_if *f3161 = new(mem_ctx) ir_if(operand(r3162).val);
                              exec_list *const f3161_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3161->then_instructions;

                                 body.emit(assign(r315A, lshift(r3135, r315D), 0x01));

                                 ir_expression *const r3163 = lshift(r3134, r315D);
                                 ir_expression *const r3164 = rshift(r3135, r3159);
                                 body.emit(assign(r315B, bit_or(r3163, r3164), 0x01));

                                 body.emit(assign(r315C, rshift(r3134, r3159), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3161->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3166 = equal(r3159, body.constant(int(32)));
                                 ir_if *f3165 = new(mem_ctx) ir_if(operand(r3166).val);
                                 exec_list *const f3165_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3165->then_instructions;

                                    body.emit(assign(r315A, r3135, 0x01));

                                    body.emit(assign(r315B, r3134, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3165->else_instructions;

                                    body.emit(assign(r3158, bit_or(body.constant(0u), r3135), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r3168 = less(r3159, body.constant(int(64)));
                                    ir_if *f3167 = new(mem_ctx) ir_if(operand(r3168).val);
                                    exec_list *const f3167_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3167->then_instructions;

                                       body.emit(assign(r315A, lshift(r3134, r315D), 0x01));

                                       ir_expression *const r3169 = bit_and(r3159, body.constant(int(31)));
                                       body.emit(assign(r315B, rshift(r3134, r3169), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3167->else_instructions;

                                       ir_variable *const r316A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r316C = equal(r3159, body.constant(int(64)));
                                       ir_if *f316B = new(mem_ctx) ir_if(operand(r316C).val);
                                       exec_list *const f316B_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f316B->then_instructions;

                                          body.emit(assign(r316A, r3134, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f316B->else_instructions;

                                          ir_expression *const r316D = nequal(r3134, body.constant(0u));
                                          ir_expression *const r316E = expr(ir_unop_b2i, r316D);
                                          body.emit(assign(r316A, expr(ir_unop_i2u, r316E), 0x01));


                                       body.instructions = f316B_parent_instructions;
                                       body.emit(f316B);

                                       /* END IF */

                                       body.emit(assign(r315A, r316A, 0x01));

                                       body.emit(assign(r315B, body.constant(0u), 0x01));


                                    body.instructions = f3167_parent_instructions;
                                    body.emit(f3167);

                                    /* END IF */


                                 body.instructions = f3165_parent_instructions;
                                 body.emit(f3165);

                                 /* END IF */

                                 body.emit(assign(r315C, body.constant(0u), 0x01));


                              body.instructions = f3161_parent_instructions;
                              body.emit(f3161);

                              /* END IF */

                              ir_expression *const r316F = nequal(r3158, body.constant(0u));
                              ir_expression *const r3170 = expr(ir_unop_b2i, r316F);
                              ir_expression *const r3171 = expr(ir_unop_i2u, r3170);
                              body.emit(assign(r315A, bit_or(r315A, r3171), 0x01));


                           body.instructions = f315F_parent_instructions;
                           body.emit(f315F);

                           /* END IF */

                           body.emit(assign(r3134, r315C, 0x01));

                           body.emit(assign(r3135, r315B, 0x01));

                           body.emit(assign(r3136, r315A, 0x01));


                        body.instructions = f314E_parent_instructions;
                        body.emit(f314E);

                        /* END IF */

                        body.emit(assign(r3133, sub(r3133, r3137), 0x01));

                        ir_variable *const r3172 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r3172, r3133, 0x01));

                        ir_variable *const r3173 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r3173, r3134, 0x01));

                        ir_variable *const r3174 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r3174, r3135, 0x01));

                        ir_variable *const r3175 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r3175, r3136, 0x01));

                        ir_variable *const r3176 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r3176, body.constant(true), 0x01));

                        ir_variable *const r3177 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r3178 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r3178);
                        ir_expression *const r3179 = expr(ir_unop_u2i, r3136);
                        body.emit(assign(r3178, less(r3179, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r317B = lequal(body.constant(int(2045)), r3133);
                        ir_if *f317A = new(mem_ctx) ir_if(operand(r317B).val);
                        exec_list *const f317A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f317A->then_instructions;

                           ir_variable *const r317C = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r317E = less(body.constant(int(2045)), r3133);
                           ir_if *f317D = new(mem_ctx) ir_if(operand(r317E).val);
                           exec_list *const f317D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f317D->then_instructions;

                              body.emit(assign(r317C, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f317D->else_instructions;

                              ir_variable *const r317F = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r3181 = equal(r3133, body.constant(int(2045)));
                              ir_if *f3180 = new(mem_ctx) ir_if(operand(r3181).val);
                              exec_list *const f3180_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3180->then_instructions;

                                 ir_expression *const r3182 = equal(body.constant(2097151u), r3134);
                                 ir_expression *const r3183 = equal(body.constant(4294967295u), r3135);
                                 body.emit(assign(r317F, logic_and(r3182, r3183), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3180->else_instructions;

                                 body.emit(assign(r317F, body.constant(false), 0x01));


                              body.instructions = f3180_parent_instructions;
                              body.emit(f3180);

                              /* END IF */

                              body.emit(assign(r317C, logic_and(r317F, r3178), 0x01));


                           body.instructions = f317D_parent_instructions;
                           body.emit(f317D);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f3184 = new(mem_ctx) ir_if(operand(r317C).val);
                           exec_list *const f3184_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3184->then_instructions;

                              ir_variable *const r3185 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r3185);
                              ir_expression *const r3186 = lshift(r2E2C, body.constant(int(31)));
                              body.emit(assign(r3185, add(r3186, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r3185, body.constant(0u), 0x01));

                              body.emit(assign(r3177, r3185, 0x03));

                              body.emit(assign(r3176, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f3184->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r3188 = less(r3133, body.constant(int(0)));
                              ir_if *f3187 = new(mem_ctx) ir_if(operand(r3188).val);
                              exec_list *const f3187_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3187->then_instructions;

                                 ir_variable *const r3189 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r3189, r3136, 0x01));

                                 ir_variable *const r318A = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r318A, neg(r3133), 0x01));

                                 ir_variable *const r318B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r318B);
                                 ir_variable *const r318C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r318C);
                                 ir_variable *const r318D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r318D);
                                 ir_variable *const r318E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r318F = neg(r318A);
                                 body.emit(assign(r318E, bit_and(r318F, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r3191 = equal(r318A, body.constant(int(0)));
                                 ir_if *f3190 = new(mem_ctx) ir_if(operand(r3191).val);
                                 exec_list *const f3190_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3190->then_instructions;

                                    body.emit(assign(r318B, r3136, 0x01));

                                    body.emit(assign(r318C, r3135, 0x01));

                                    body.emit(assign(r318D, r3134, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3190->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r3193 = less(r318A, body.constant(int(32)));
                                    ir_if *f3192 = new(mem_ctx) ir_if(operand(r3193).val);
                                    exec_list *const f3192_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3192->then_instructions;

                                       body.emit(assign(r318B, lshift(r3135, r318E), 0x01));

                                       ir_expression *const r3194 = lshift(r3134, r318E);
                                       ir_expression *const r3195 = rshift(r3135, r318A);
                                       body.emit(assign(r318C, bit_or(r3194, r3195), 0x01));

                                       body.emit(assign(r318D, rshift(r3134, r318A), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3192->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r3197 = equal(r318A, body.constant(int(32)));
                                       ir_if *f3196 = new(mem_ctx) ir_if(operand(r3197).val);
                                       exec_list *const f3196_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3196->then_instructions;

                                          body.emit(assign(r318B, r3135, 0x01));

                                          body.emit(assign(r318C, r3134, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3196->else_instructions;

                                          body.emit(assign(r3189, bit_or(r3136, r3135), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r3199 = less(r318A, body.constant(int(64)));
                                          ir_if *f3198 = new(mem_ctx) ir_if(operand(r3199).val);
                                          exec_list *const f3198_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3198->then_instructions;

                                             body.emit(assign(r318B, lshift(r3134, r318E), 0x01));

                                             ir_expression *const r319A = bit_and(r318A, body.constant(int(31)));
                                             body.emit(assign(r318C, rshift(r3134, r319A), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3198->else_instructions;

                                             ir_variable *const r319B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r319D = equal(r318A, body.constant(int(64)));
                                             ir_if *f319C = new(mem_ctx) ir_if(operand(r319D).val);
                                             exec_list *const f319C_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f319C->then_instructions;

                                                body.emit(assign(r319B, r3134, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f319C->else_instructions;

                                                ir_expression *const r319E = nequal(r3134, body.constant(0u));
                                                ir_expression *const r319F = expr(ir_unop_b2i, r319E);
                                                body.emit(assign(r319B, expr(ir_unop_i2u, r319F), 0x01));


                                             body.instructions = f319C_parent_instructions;
                                             body.emit(f319C);

                                             /* END IF */

                                             body.emit(assign(r318B, r319B, 0x01));

                                             body.emit(assign(r318C, body.constant(0u), 0x01));


                                          body.instructions = f3198_parent_instructions;
                                          body.emit(f3198);

                                          /* END IF */


                                       body.instructions = f3196_parent_instructions;
                                       body.emit(f3196);

                                       /* END IF */

                                       body.emit(assign(r318D, body.constant(0u), 0x01));


                                    body.instructions = f3192_parent_instructions;
                                    body.emit(f3192);

                                    /* END IF */

                                    ir_expression *const r31A0 = nequal(r3189, body.constant(0u));
                                    ir_expression *const r31A1 = expr(ir_unop_b2i, r31A0);
                                    ir_expression *const r31A2 = expr(ir_unop_i2u, r31A1);
                                    body.emit(assign(r318B, bit_or(r318B, r31A2), 0x01));


                                 body.instructions = f3190_parent_instructions;
                                 body.emit(f3190);

                                 /* END IF */

                                 body.emit(assign(r3173, r318D, 0x01));

                                 body.emit(assign(r3174, r318C, 0x01));

                                 body.emit(assign(r3175, r318B, 0x01));

                                 body.emit(assign(r3172, body.constant(int(0)), 0x01));

                                 body.emit(assign(r3178, less(r318B, body.constant(0u)), 0x01));


                              body.instructions = f3187_parent_instructions;
                              body.emit(f3187);

                              /* END IF */


                           body.instructions = f3184_parent_instructions;
                           body.emit(f3184);

                           /* END IF */


                        body.instructions = f317A_parent_instructions;
                        body.emit(f317A);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f31A3 = new(mem_ctx) ir_if(operand(r3176).val);
                        exec_list *const f31A3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f31A3->then_instructions;

                           /* IF CONDITION */
                           ir_if *f31A4 = new(mem_ctx) ir_if(operand(r3178).val);
                           exec_list *const f31A4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f31A4->then_instructions;

                              ir_variable *const r31A5 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r31A5, add(r3174, body.constant(1u)), 0x01));

                              ir_expression *const r31A6 = less(r31A5, r3174);
                              ir_expression *const r31A7 = expr(ir_unop_b2i, r31A6);
                              ir_expression *const r31A8 = expr(ir_unop_i2u, r31A7);
                              body.emit(assign(r3173, add(r3173, r31A8), 0x01));

                              ir_expression *const r31A9 = equal(r3175, body.constant(0u));
                              ir_expression *const r31AA = expr(ir_unop_b2i, r31A9);
                              ir_expression *const r31AB = expr(ir_unop_i2u, r31AA);
                              ir_expression *const r31AC = add(r3175, r31AB);
                              ir_expression *const r31AD = bit_and(r31AC, body.constant(1u));
                              ir_expression *const r31AE = expr(ir_unop_bit_not, r31AD);
                              body.emit(assign(r3174, bit_and(r31A5, r31AE), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f31A4->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r31B0 = bit_or(r3173, r3174);
                              ir_expression *const r31B1 = equal(r31B0, body.constant(0u));
                              ir_if *f31AF = new(mem_ctx) ir_if(operand(r31B1).val);
                              exec_list *const f31AF_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f31AF->then_instructions;

                                 body.emit(assign(r3172, body.constant(int(0)), 0x01));


                              body.instructions = f31AF_parent_instructions;
                              body.emit(f31AF);

                              /* END IF */


                           body.instructions = f31A4_parent_instructions;
                           body.emit(f31A4);

                           /* END IF */

                           ir_variable *const r31B2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r31B2);
                           ir_expression *const r31B3 = lshift(r2E2C, body.constant(int(31)));
                           ir_expression *const r31B4 = expr(ir_unop_i2u, r3172);
                           ir_expression *const r31B5 = lshift(r31B4, body.constant(int(20)));
                           ir_expression *const r31B6 = add(r31B3, r31B5);
                           body.emit(assign(r31B2, add(r31B6, r3173), 0x02));

                           body.emit(assign(r31B2, r3174, 0x01));

                           body.emit(assign(r3177, r31B2, 0x03));

                           body.emit(assign(r3176, body.constant(false), 0x01));


                        body.instructions = f31A3_parent_instructions;
                        body.emit(f31A3);

                        /* END IF */

                        body.emit(assign(r2E2D, r3177, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f312B->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r31B8 = less(swizzle_x(r2E32), swizzle_x(r2E30));
                        ir_if *f31B7 = new(mem_ctx) ir_if(operand(r31B8).val);
                        exec_list *const f31B7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f31B7->then_instructions;

                           ir_variable *const r31B9 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r31BA = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r31BA, sub(swizzle_x(r2E30), swizzle_x(r2E32)), 0x01));

                           ir_expression *const r31BB = sub(swizzle_y(r2E30), swizzle_y(r2E32));
                           ir_expression *const r31BC = less(swizzle_x(r2E30), swizzle_x(r2E32));
                           ir_expression *const r31BD = expr(ir_unop_b2i, r31BC);
                           ir_expression *const r31BE = expr(ir_unop_i2u, r31BD);
                           body.emit(assign(r31B9, sub(r31BB, r31BE), 0x01));

                           body.emit(assign(r2E2C, bit_xor(r2E2C, body.constant(1u)), 0x01));

                           body.emit(assign(r2E33, add(r2E2F, body.constant(int(-1))), 0x01));

                           ir_variable *const r31BF = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r31BF, add(r2E33, body.constant(int(-10))), 0x01));

                           ir_variable *const r31C0 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r31C0, r31B9, 0x01));

                           ir_variable *const r31C1 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r31C1, r31BA, 0x01));

                           ir_variable *const r31C2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r31C2);
                           ir_variable *const r31C3 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r31C3);
                           /* IF CONDITION */
                           ir_expression *const r31C5 = equal(r31B9, body.constant(0u));
                           ir_if *f31C4 = new(mem_ctx) ir_if(operand(r31C5).val);
                           exec_list *const f31C4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f31C4->then_instructions;

                              body.emit(assign(r31C0, r31BA, 0x01));

                              body.emit(assign(r31C1, body.constant(0u), 0x01));

                              body.emit(assign(r31BF, add(r31BF, body.constant(int(-32))), 0x01));


                           body.instructions = f31C4_parent_instructions;
                           body.emit(f31C4);

                           /* END IF */

                           ir_variable *const r31C6 = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r31C6, r31C0, 0x01));

                           ir_variable *const r31C7 = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r31C8 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r31C8);
                           /* IF CONDITION */
                           ir_expression *const r31CA = equal(r31C0, body.constant(0u));
                           ir_if *f31C9 = new(mem_ctx) ir_if(operand(r31CA).val);
                           exec_list *const f31C9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f31C9->then_instructions;

                              body.emit(assign(r31C7, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f31C9->else_instructions;

                              body.emit(assign(r31C8, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r31CC = bit_and(r31C0, body.constant(4294901760u));
                              ir_expression *const r31CD = equal(r31CC, body.constant(0u));
                              ir_if *f31CB = new(mem_ctx) ir_if(operand(r31CD).val);
                              exec_list *const f31CB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f31CB->then_instructions;

                                 body.emit(assign(r31C8, body.constant(int(16)), 0x01));

                                 body.emit(assign(r31C6, lshift(r31C0, body.constant(int(16))), 0x01));


                              body.instructions = f31CB_parent_instructions;
                              body.emit(f31CB);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r31CF = bit_and(r31C6, body.constant(4278190080u));
                              ir_expression *const r31D0 = equal(r31CF, body.constant(0u));
                              ir_if *f31CE = new(mem_ctx) ir_if(operand(r31D0).val);
                              exec_list *const f31CE_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f31CE->then_instructions;

                                 body.emit(assign(r31C8, add(r31C8, body.constant(int(8))), 0x01));

                                 body.emit(assign(r31C6, lshift(r31C6, body.constant(int(8))), 0x01));


                              body.instructions = f31CE_parent_instructions;
                              body.emit(f31CE);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r31D2 = bit_and(r31C6, body.constant(4026531840u));
                              ir_expression *const r31D3 = equal(r31D2, body.constant(0u));
                              ir_if *f31D1 = new(mem_ctx) ir_if(operand(r31D3).val);
                              exec_list *const f31D1_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f31D1->then_instructions;

                                 body.emit(assign(r31C8, add(r31C8, body.constant(int(4))), 0x01));

                                 body.emit(assign(r31C6, lshift(r31C6, body.constant(int(4))), 0x01));


                              body.instructions = f31D1_parent_instructions;
                              body.emit(f31D1);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r31D5 = bit_and(r31C6, body.constant(3221225472u));
                              ir_expression *const r31D6 = equal(r31D5, body.constant(0u));
                              ir_if *f31D4 = new(mem_ctx) ir_if(operand(r31D6).val);
                              exec_list *const f31D4_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f31D4->then_instructions;

                                 body.emit(assign(r31C8, add(r31C8, body.constant(int(2))), 0x01));

                                 body.emit(assign(r31C6, lshift(r31C6, body.constant(int(2))), 0x01));


                              body.instructions = f31D4_parent_instructions;
                              body.emit(f31D4);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r31D8 = bit_and(r31C6, body.constant(2147483648u));
                              ir_expression *const r31D9 = equal(r31D8, body.constant(0u));
                              ir_if *f31D7 = new(mem_ctx) ir_if(operand(r31D9).val);
                              exec_list *const f31D7_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f31D7->then_instructions;

                                 body.emit(assign(r31C8, add(r31C8, body.constant(int(1))), 0x01));


                              body.instructions = f31D7_parent_instructions;
                              body.emit(f31D7);

                              /* END IF */

                              body.emit(assign(r31C7, r31C8, 0x01));


                           body.instructions = f31C9_parent_instructions;
                           body.emit(f31C9);

                           /* END IF */

                           body.emit(assign(r31C3, add(r31C7, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r31DB = lequal(body.constant(int(0)), r31C3);
                           ir_if *f31DA = new(mem_ctx) ir_if(operand(r31DB).val);
                           exec_list *const f31DA_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f31DA->then_instructions;

                              body.emit(assign(r31C2, body.constant(0u), 0x01));

                              ir_variable *const r31DC = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r31DC, lshift(r31C1, r31C3), 0x01));

                              ir_variable *const r31DD = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r31DF = equal(r31C3, body.constant(int(0)));
                              ir_if *f31DE = new(mem_ctx) ir_if(operand(r31DF).val);
                              exec_list *const f31DE_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f31DE->then_instructions;

                                 body.emit(assign(r31DD, r31C0, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f31DE->else_instructions;

                                 ir_expression *const r31E0 = lshift(r31C0, r31C3);
                                 ir_expression *const r31E1 = neg(r31C3);
                                 ir_expression *const r31E2 = bit_and(r31E1, body.constant(int(31)));
                                 ir_expression *const r31E3 = rshift(r31C1, r31E2);
                                 body.emit(assign(r31DD, bit_or(r31E0, r31E3), 0x01));


                              body.instructions = f31DE_parent_instructions;
                              body.emit(f31DE);

                              /* END IF */

                              body.emit(assign(r31C0, r31DD, 0x01));

                              body.emit(assign(r31C1, r31DC, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f31DA->else_instructions;

                              ir_variable *const r31E4 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r31E4, body.constant(0u), 0x01));

                              ir_variable *const r31E5 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r31E5, neg(r31C3), 0x01));

                              ir_variable *const r31E6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r31E6);
                              ir_variable *const r31E7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r31E7);
                              ir_variable *const r31E8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r31E8);
                              ir_variable *const r31E9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r31EA = neg(r31E5);
                              body.emit(assign(r31E9, bit_and(r31EA, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r31EC = equal(r31E5, body.constant(int(0)));
                              ir_if *f31EB = new(mem_ctx) ir_if(operand(r31EC).val);
                              exec_list *const f31EB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f31EB->then_instructions;

                                 body.emit(assign(r31E6, r31E4, 0x01));

                                 body.emit(assign(r31E7, r31C1, 0x01));

                                 body.emit(assign(r31E8, r31C0, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f31EB->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r31EE = less(r31E5, body.constant(int(32)));
                                 ir_if *f31ED = new(mem_ctx) ir_if(operand(r31EE).val);
                                 exec_list *const f31ED_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f31ED->then_instructions;

                                    body.emit(assign(r31E6, lshift(r31C1, r31E9), 0x01));

                                    ir_expression *const r31EF = lshift(r31C0, r31E9);
                                    ir_expression *const r31F0 = rshift(r31C1, r31E5);
                                    body.emit(assign(r31E7, bit_or(r31EF, r31F0), 0x01));

                                    body.emit(assign(r31E8, rshift(r31C0, r31E5), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f31ED->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r31F2 = equal(r31E5, body.constant(int(32)));
                                    ir_if *f31F1 = new(mem_ctx) ir_if(operand(r31F2).val);
                                    exec_list *const f31F1_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f31F1->then_instructions;

                                       body.emit(assign(r31E6, r31C1, 0x01));

                                       body.emit(assign(r31E7, r31C0, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f31F1->else_instructions;

                                       body.emit(assign(r31E4, bit_or(body.constant(0u), r31C1), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r31F4 = less(r31E5, body.constant(int(64)));
                                       ir_if *f31F3 = new(mem_ctx) ir_if(operand(r31F4).val);
                                       exec_list *const f31F3_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f31F3->then_instructions;

                                          body.emit(assign(r31E6, lshift(r31C0, r31E9), 0x01));

                                          ir_expression *const r31F5 = bit_and(r31E5, body.constant(int(31)));
                                          body.emit(assign(r31E7, rshift(r31C0, r31F5), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f31F3->else_instructions;

                                          ir_variable *const r31F6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r31F8 = equal(r31E5, body.constant(int(64)));
                                          ir_if *f31F7 = new(mem_ctx) ir_if(operand(r31F8).val);
                                          exec_list *const f31F7_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f31F7->then_instructions;

                                             body.emit(assign(r31F6, r31C0, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f31F7->else_instructions;

                                             ir_expression *const r31F9 = nequal(r31C0, body.constant(0u));
                                             ir_expression *const r31FA = expr(ir_unop_b2i, r31F9);
                                             body.emit(assign(r31F6, expr(ir_unop_i2u, r31FA), 0x01));


                                          body.instructions = f31F7_parent_instructions;
                                          body.emit(f31F7);

                                          /* END IF */

                                          body.emit(assign(r31E6, r31F6, 0x01));

                                          body.emit(assign(r31E7, body.constant(0u), 0x01));


                                       body.instructions = f31F3_parent_instructions;
                                       body.emit(f31F3);

                                       /* END IF */


                                    body.instructions = f31F1_parent_instructions;
                                    body.emit(f31F1);

                                    /* END IF */

                                    body.emit(assign(r31E8, body.constant(0u), 0x01));


                                 body.instructions = f31ED_parent_instructions;
                                 body.emit(f31ED);

                                 /* END IF */

                                 ir_expression *const r31FB = nequal(r31E4, body.constant(0u));
                                 ir_expression *const r31FC = expr(ir_unop_b2i, r31FB);
                                 ir_expression *const r31FD = expr(ir_unop_i2u, r31FC);
                                 body.emit(assign(r31E6, bit_or(r31E6, r31FD), 0x01));


                              body.instructions = f31EB_parent_instructions;
                              body.emit(f31EB);

                              /* END IF */

                              body.emit(assign(r31C0, r31E8, 0x01));

                              body.emit(assign(r31C1, r31E7, 0x01));

                              body.emit(assign(r31C2, r31E6, 0x01));


                           body.instructions = f31DA_parent_instructions;
                           body.emit(f31DA);

                           /* END IF */

                           body.emit(assign(r31BF, sub(r31BF, r31C3), 0x01));

                           ir_variable *const r31FE = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r31FE, r31BF, 0x01));

                           ir_variable *const r31FF = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r31FF, r31C0, 0x01));

                           ir_variable *const r3200 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r3200, r31C1, 0x01));

                           ir_variable *const r3201 = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r3201, r31C2, 0x01));

                           ir_variable *const r3202 = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r3202, body.constant(true), 0x01));

                           ir_variable *const r3203 = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r3204 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r3204);
                           ir_expression *const r3205 = expr(ir_unop_u2i, r31C2);
                           body.emit(assign(r3204, less(r3205, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r3207 = lequal(body.constant(int(2045)), r31BF);
                           ir_if *f3206 = new(mem_ctx) ir_if(operand(r3207).val);
                           exec_list *const f3206_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f3206->then_instructions;

                              ir_variable *const r3208 = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r320A = less(body.constant(int(2045)), r31BF);
                              ir_if *f3209 = new(mem_ctx) ir_if(operand(r320A).val);
                              exec_list *const f3209_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3209->then_instructions;

                                 body.emit(assign(r3208, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3209->else_instructions;

                                 ir_variable *const r320B = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r320D = equal(r31BF, body.constant(int(2045)));
                                 ir_if *f320C = new(mem_ctx) ir_if(operand(r320D).val);
                                 exec_list *const f320C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f320C->then_instructions;

                                    ir_expression *const r320E = equal(body.constant(2097151u), r31C0);
                                    ir_expression *const r320F = equal(body.constant(4294967295u), r31C1);
                                    body.emit(assign(r320B, logic_and(r320E, r320F), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f320C->else_instructions;

                                    body.emit(assign(r320B, body.constant(false), 0x01));


                                 body.instructions = f320C_parent_instructions;
                                 body.emit(f320C);

                                 /* END IF */

                                 body.emit(assign(r3208, logic_and(r320B, r3204), 0x01));


                              body.instructions = f3209_parent_instructions;
                              body.emit(f3209);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f3210 = new(mem_ctx) ir_if(operand(r3208).val);
                              exec_list *const f3210_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3210->then_instructions;

                                 ir_variable *const r3211 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r3211);
                                 ir_expression *const r3212 = lshift(r2E2C, body.constant(int(31)));
                                 body.emit(assign(r3211, add(r3212, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r3211, body.constant(0u), 0x01));

                                 body.emit(assign(r3203, r3211, 0x03));

                                 body.emit(assign(r3202, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3210->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3214 = less(r31BF, body.constant(int(0)));
                                 ir_if *f3213 = new(mem_ctx) ir_if(operand(r3214).val);
                                 exec_list *const f3213_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3213->then_instructions;

                                    ir_variable *const r3215 = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r3215, r31C2, 0x01));

                                    ir_variable *const r3216 = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r3216, neg(r31BF), 0x01));

                                    ir_variable *const r3217 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r3217);
                                    ir_variable *const r3218 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r3218);
                                    ir_variable *const r3219 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r3219);
                                    ir_variable *const r321A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r321B = neg(r3216);
                                    body.emit(assign(r321A, bit_and(r321B, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r321D = equal(r3216, body.constant(int(0)));
                                    ir_if *f321C = new(mem_ctx) ir_if(operand(r321D).val);
                                    exec_list *const f321C_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f321C->then_instructions;

                                       body.emit(assign(r3217, r31C2, 0x01));

                                       body.emit(assign(r3218, r31C1, 0x01));

                                       body.emit(assign(r3219, r31C0, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f321C->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r321F = less(r3216, body.constant(int(32)));
                                       ir_if *f321E = new(mem_ctx) ir_if(operand(r321F).val);
                                       exec_list *const f321E_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f321E->then_instructions;

                                          body.emit(assign(r3217, lshift(r31C1, r321A), 0x01));

                                          ir_expression *const r3220 = lshift(r31C0, r321A);
                                          ir_expression *const r3221 = rshift(r31C1, r3216);
                                          body.emit(assign(r3218, bit_or(r3220, r3221), 0x01));

                                          body.emit(assign(r3219, rshift(r31C0, r3216), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f321E->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r3223 = equal(r3216, body.constant(int(32)));
                                          ir_if *f3222 = new(mem_ctx) ir_if(operand(r3223).val);
                                          exec_list *const f3222_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f3222->then_instructions;

                                             body.emit(assign(r3217, r31C1, 0x01));

                                             body.emit(assign(r3218, r31C0, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f3222->else_instructions;

                                             body.emit(assign(r3215, bit_or(r31C2, r31C1), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r3225 = less(r3216, body.constant(int(64)));
                                             ir_if *f3224 = new(mem_ctx) ir_if(operand(r3225).val);
                                             exec_list *const f3224_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f3224->then_instructions;

                                                body.emit(assign(r3217, lshift(r31C0, r321A), 0x01));

                                                ir_expression *const r3226 = bit_and(r3216, body.constant(int(31)));
                                                body.emit(assign(r3218, rshift(r31C0, r3226), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f3224->else_instructions;

                                                ir_variable *const r3227 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r3229 = equal(r3216, body.constant(int(64)));
                                                ir_if *f3228 = new(mem_ctx) ir_if(operand(r3229).val);
                                                exec_list *const f3228_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f3228->then_instructions;

                                                   body.emit(assign(r3227, r31C0, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f3228->else_instructions;

                                                   ir_expression *const r322A = nequal(r31C0, body.constant(0u));
                                                   ir_expression *const r322B = expr(ir_unop_b2i, r322A);
                                                   body.emit(assign(r3227, expr(ir_unop_i2u, r322B), 0x01));


                                                body.instructions = f3228_parent_instructions;
                                                body.emit(f3228);

                                                /* END IF */

                                                body.emit(assign(r3217, r3227, 0x01));

                                                body.emit(assign(r3218, body.constant(0u), 0x01));


                                             body.instructions = f3224_parent_instructions;
                                             body.emit(f3224);

                                             /* END IF */


                                          body.instructions = f3222_parent_instructions;
                                          body.emit(f3222);

                                          /* END IF */

                                          body.emit(assign(r3219, body.constant(0u), 0x01));


                                       body.instructions = f321E_parent_instructions;
                                       body.emit(f321E);

                                       /* END IF */

                                       ir_expression *const r322C = nequal(r3215, body.constant(0u));
                                       ir_expression *const r322D = expr(ir_unop_b2i, r322C);
                                       ir_expression *const r322E = expr(ir_unop_i2u, r322D);
                                       body.emit(assign(r3217, bit_or(r3217, r322E), 0x01));


                                    body.instructions = f321C_parent_instructions;
                                    body.emit(f321C);

                                    /* END IF */

                                    body.emit(assign(r31FF, r3219, 0x01));

                                    body.emit(assign(r3200, r3218, 0x01));

                                    body.emit(assign(r3201, r3217, 0x01));

                                    body.emit(assign(r31FE, body.constant(int(0)), 0x01));

                                    body.emit(assign(r3204, less(r3217, body.constant(0u)), 0x01));


                                 body.instructions = f3213_parent_instructions;
                                 body.emit(f3213);

                                 /* END IF */


                              body.instructions = f3210_parent_instructions;
                              body.emit(f3210);

                              /* END IF */


                           body.instructions = f3206_parent_instructions;
                           body.emit(f3206);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f322F = new(mem_ctx) ir_if(operand(r3202).val);
                           exec_list *const f322F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f322F->then_instructions;

                              /* IF CONDITION */
                              ir_if *f3230 = new(mem_ctx) ir_if(operand(r3204).val);
                              exec_list *const f3230_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3230->then_instructions;

                                 ir_variable *const r3231 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r3231, add(r3200, body.constant(1u)), 0x01));

                                 ir_expression *const r3232 = less(r3231, r3200);
                                 ir_expression *const r3233 = expr(ir_unop_b2i, r3232);
                                 ir_expression *const r3234 = expr(ir_unop_i2u, r3233);
                                 body.emit(assign(r31FF, add(r31FF, r3234), 0x01));

                                 ir_expression *const r3235 = equal(r3201, body.constant(0u));
                                 ir_expression *const r3236 = expr(ir_unop_b2i, r3235);
                                 ir_expression *const r3237 = expr(ir_unop_i2u, r3236);
                                 ir_expression *const r3238 = add(r3201, r3237);
                                 ir_expression *const r3239 = bit_and(r3238, body.constant(1u));
                                 ir_expression *const r323A = expr(ir_unop_bit_not, r3239);
                                 body.emit(assign(r3200, bit_and(r3231, r323A), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3230->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r323C = bit_or(r31FF, r3200);
                                 ir_expression *const r323D = equal(r323C, body.constant(0u));
                                 ir_if *f323B = new(mem_ctx) ir_if(operand(r323D).val);
                                 exec_list *const f323B_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f323B->then_instructions;

                                    body.emit(assign(r31FE, body.constant(int(0)), 0x01));


                                 body.instructions = f323B_parent_instructions;
                                 body.emit(f323B);

                                 /* END IF */


                              body.instructions = f3230_parent_instructions;
                              body.emit(f3230);

                              /* END IF */

                              ir_variable *const r323E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r323E);
                              ir_expression *const r323F = lshift(r2E2C, body.constant(int(31)));
                              ir_expression *const r3240 = expr(ir_unop_i2u, r31FE);
                              ir_expression *const r3241 = lshift(r3240, body.constant(int(20)));
                              ir_expression *const r3242 = add(r323F, r3241);
                              body.emit(assign(r323E, add(r3242, r31FF), 0x02));

                              body.emit(assign(r323E, r3200, 0x01));

                              body.emit(assign(r3203, r323E, 0x03));

                              body.emit(assign(r3202, body.constant(false), 0x01));


                           body.instructions = f322F_parent_instructions;
                           body.emit(f322F);

                           /* END IF */

                           body.emit(assign(r2E2D, r3203, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f31B7->else_instructions;

                           ir_variable *const r3243 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r3243);
                           body.emit(assign(r3243, body.constant(0u), 0x02));

                           body.emit(assign(r3243, body.constant(0u), 0x01));

                           body.emit(assign(r2E2D, r3243, 0x03));


                        body.instructions = f31B7_parent_instructions;
                        body.emit(f31B7);

                        /* END IF */


                     body.instructions = f312B_parent_instructions;
                     body.emit(f312B);

                     /* END IF */


                  body.instructions = f309F_parent_instructions;
                  body.emit(f309F);

                  /* END IF */


               body.instructions = f3013_parent_instructions;
               body.emit(f3013);

               /* END IF */


            body.instructions = f2FEC_parent_instructions;
            body.emit(f2FEC);

            /* END IF */


         body.instructions = f2F16_parent_instructions;
         body.emit(f2F16);

         /* END IF */


      body.instructions = f2E44_parent_instructions;
      body.emit(f2E44);

      /* END IF */

      body.emit(assign(r2E27, r2E2D, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f2E2A->else_instructions;

      ir_variable *const r3244 = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r3244, body.constant(true), 0x01));

      ir_variable *const r3245 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r3246 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r3246);
      ir_variable *const r3247 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
      body.emit(r3247);
      ir_variable *const r3248 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
      body.emit(r3248);
      ir_variable *const r3249 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r3249);
      ir_variable *const r324A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
      body.emit(r324A);
      ir_variable *const r324B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
      body.emit(r324B);
      body.emit(assign(r324B, body.constant(0u), 0x01));

      body.emit(assign(r324A, body.constant(0u), 0x01));

      ir_variable *const r324C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r324C);
      body.emit(assign(r324C, bit_and(swizzle_y(r28D7), body.constant(1048575u)), 0x02));

      body.emit(assign(r324C, swizzle_x(r28D7), 0x01));

      body.emit(assign(r3248, r324C, 0x03));

      ir_variable *const r324D = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r324E = rshift(swizzle_y(r28D7), body.constant(int(20)));
      ir_expression *const r324F = bit_and(r324E, body.constant(2047u));
      body.emit(assign(r324D, expr(ir_unop_u2i, r324F), 0x01));

      ir_variable *const r3250 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "frac", ir_var_auto);
      body.emit(r3250);
      body.emit(assign(r3250, bit_and(swizzle_y(r290B), body.constant(1048575u)), 0x02));

      body.emit(assign(r3250, swizzle_x(r290B), 0x01));

      body.emit(assign(r3247, r3250, 0x03));

      ir_variable *const r3251 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r3252 = rshift(swizzle_y(r290B), body.constant(int(20)));
      ir_expression *const r3253 = bit_and(r3252, body.constant(2047u));
      body.emit(assign(r3251, expr(ir_unop_u2i, r3253), 0x01));

      ir_variable *const r3254 = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r3254, sub(r324D, r3251), 0x01));

      body.emit(assign(r3246, r3254, 0x01));

      /* IF CONDITION */
      ir_expression *const r3256 = less(body.constant(int(0)), r3254);
      ir_if *f3255 = new(mem_ctx) ir_if(operand(r3256).val);
      exec_list *const f3255_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f3255->then_instructions;

         /* IF CONDITION */
         ir_expression *const r3258 = equal(r324D, body.constant(int(2047)));
         ir_if *f3257 = new(mem_ctx) ir_if(operand(r3258).val);
         exec_list *const f3257_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3257->then_instructions;

            /* IF CONDITION */
            ir_expression *const r325A = bit_or(swizzle_y(r324C), swizzle_x(r28D7));
            ir_expression *const r325B = nequal(r325A, body.constant(0u));
            ir_if *f3259 = new(mem_ctx) ir_if(operand(r325B).val);
            exec_list *const f3259_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3259->then_instructions;

               ir_variable *const r325C = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r325C, swizzle_x(r28D7), 0x01));

               ir_variable *const r325D = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r325D, swizzle_x(r290B), 0x01));

               ir_variable *const r325E = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r325F = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r3260 = rshift(swizzle_y(r28D7), body.constant(int(19)));
               ir_expression *const r3261 = bit_and(r3260, body.constant(4095u));
               ir_expression *const r3262 = equal(r3261, body.constant(4094u));
               ir_expression *const r3263 = nequal(swizzle_x(r28D7), body.constant(0u));
               ir_expression *const r3264 = bit_and(swizzle_y(r28D7), body.constant(524287u));
               ir_expression *const r3265 = nequal(r3264, body.constant(0u));
               ir_expression *const r3266 = logic_or(r3263, r3265);
               body.emit(assign(r325F, logic_and(r3262, r3266), 0x01));

               ir_variable *const r3267 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r3268 = lshift(swizzle_y(r290B), body.constant(int(1)));
               ir_expression *const r3269 = lequal(body.constant(4292870144u), r3268);
               ir_expression *const r326A = nequal(swizzle_x(r290B), body.constant(0u));
               ir_expression *const r326B = bit_and(swizzle_y(r290B), body.constant(1048575u));
               ir_expression *const r326C = nequal(r326B, body.constant(0u));
               ir_expression *const r326D = logic_or(r326A, r326C);
               body.emit(assign(r3267, logic_and(r3269, r326D), 0x01));

               body.emit(assign(r325C, bit_or(swizzle_y(r28D7), body.constant(524288u)), 0x02));

               body.emit(assign(r325D, bit_or(swizzle_y(r290B), body.constant(524288u)), 0x02));

               /* IF CONDITION */
               ir_expression *const r326F = lshift(swizzle_y(r28D7), body.constant(int(1)));
               ir_expression *const r3270 = lequal(body.constant(4292870144u), r326F);
               ir_expression *const r3271 = nequal(swizzle_x(r28D7), body.constant(0u));
               ir_expression *const r3272 = bit_and(swizzle_y(r28D7), body.constant(1048575u));
               ir_expression *const r3273 = nequal(r3272, body.constant(0u));
               ir_expression *const r3274 = logic_or(r3271, r3273);
               ir_expression *const r3275 = logic_and(r3270, r3274);
               ir_if *f326E = new(mem_ctx) ir_if(operand(r3275).val);
               exec_list *const f326E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f326E->then_instructions;

                  ir_variable *const r3276 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r3278 = logic_and(r325F, r3267);
                  ir_if *f3277 = new(mem_ctx) ir_if(operand(r3278).val);
                  exec_list *const f3277_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3277->then_instructions;

                     body.emit(assign(r3276, r325D, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3277->else_instructions;

                     body.emit(assign(r3276, r325C, 0x03));


                  body.instructions = f3277_parent_instructions;
                  body.emit(f3277);

                  /* END IF */

                  body.emit(assign(r325E, r3276, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f326E->else_instructions;

                  body.emit(assign(r325E, r325D, 0x03));


               body.instructions = f326E_parent_instructions;
               body.emit(f326E);

               /* END IF */

               body.emit(assign(r3245, r325E, 0x03));

               body.emit(assign(r3244, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3259->else_instructions;

               body.emit(assign(r3245, r28D7, 0x03));

               body.emit(assign(r3244, body.constant(false), 0x01));


            body.instructions = f3259_parent_instructions;
            body.emit(f3259);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3257->else_instructions;

            /* IF CONDITION */
            ir_expression *const r327A = equal(r3251, body.constant(int(0)));
            ir_if *f3279 = new(mem_ctx) ir_if(operand(r327A).val);
            exec_list *const f3279_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3279->then_instructions;

               body.emit(assign(r3246, add(r3254, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3279->else_instructions;

               body.emit(assign(r3247, bit_or(swizzle_y(r3250), body.constant(1048576u)), 0x02));


            body.instructions = f3279_parent_instructions;
            body.emit(f3279);

            /* END IF */

            ir_variable *const r327B = body.make_temp(glsl_type::uint_type, "a0");
            body.emit(assign(r327B, swizzle_y(r3247), 0x01));

            ir_variable *const r327C = body.make_temp(glsl_type::uint_type, "a1");
            body.emit(assign(r327C, swizzle_x(r3247), 0x01));

            ir_variable *const r327D = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r327D, body.constant(0u), 0x01));

            ir_variable *const r327E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r327E);
            ir_variable *const r327F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r327F);
            ir_variable *const r3280 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r3280);
            ir_variable *const r3281 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r3282 = neg(r3246);
            body.emit(assign(r3281, bit_and(r3282, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r3284 = equal(r3246, body.constant(int(0)));
            ir_if *f3283 = new(mem_ctx) ir_if(operand(r3284).val);
            exec_list *const f3283_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3283->then_instructions;

               body.emit(assign(r327E, r327D, 0x01));

               body.emit(assign(r327F, r327C, 0x01));

               body.emit(assign(r3280, r327B, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3283->else_instructions;

               /* IF CONDITION */
               ir_expression *const r3286 = less(r3246, body.constant(int(32)));
               ir_if *f3285 = new(mem_ctx) ir_if(operand(r3286).val);
               exec_list *const f3285_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3285->then_instructions;

                  body.emit(assign(r327E, lshift(swizzle_x(r3250), r3281), 0x01));

                  ir_expression *const r3287 = lshift(swizzle_y(r3247), r3281);
                  ir_expression *const r3288 = rshift(swizzle_x(r3250), r3246);
                  body.emit(assign(r327F, bit_or(r3287, r3288), 0x01));

                  body.emit(assign(r3280, rshift(swizzle_y(r3247), r3246), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3285->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r328A = equal(r3246, body.constant(int(32)));
                  ir_if *f3289 = new(mem_ctx) ir_if(operand(r328A).val);
                  exec_list *const f3289_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3289->then_instructions;

                     body.emit(assign(r327E, r327C, 0x01));

                     body.emit(assign(r327F, r327B, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3289->else_instructions;

                     body.emit(assign(r327D, bit_or(body.constant(0u), swizzle_x(r3250)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r328C = less(r3246, body.constant(int(64)));
                     ir_if *f328B = new(mem_ctx) ir_if(operand(r328C).val);
                     exec_list *const f328B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f328B->then_instructions;

                        body.emit(assign(r327E, lshift(swizzle_y(r3247), r3281), 0x01));

                        ir_expression *const r328D = bit_and(r3246, body.constant(int(31)));
                        body.emit(assign(r327F, rshift(swizzle_y(r3247), r328D), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f328B->else_instructions;

                        ir_variable *const r328E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r3290 = equal(r3246, body.constant(int(64)));
                        ir_if *f328F = new(mem_ctx) ir_if(operand(r3290).val);
                        exec_list *const f328F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f328F->then_instructions;

                           body.emit(assign(r328E, r327B, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f328F->else_instructions;

                           ir_expression *const r3291 = nequal(swizzle_y(r3247), body.constant(0u));
                           ir_expression *const r3292 = expr(ir_unop_b2i, r3291);
                           body.emit(assign(r328E, expr(ir_unop_i2u, r3292), 0x01));


                        body.instructions = f328F_parent_instructions;
                        body.emit(f328F);

                        /* END IF */

                        body.emit(assign(r327E, r328E, 0x01));

                        body.emit(assign(r327F, body.constant(0u), 0x01));


                     body.instructions = f328B_parent_instructions;
                     body.emit(f328B);

                     /* END IF */


                  body.instructions = f3289_parent_instructions;
                  body.emit(f3289);

                  /* END IF */

                  body.emit(assign(r3280, body.constant(0u), 0x01));


               body.instructions = f3285_parent_instructions;
               body.emit(f3285);

               /* END IF */

               ir_expression *const r3293 = nequal(r327D, body.constant(0u));
               ir_expression *const r3294 = expr(ir_unop_b2i, r3293);
               ir_expression *const r3295 = expr(ir_unop_i2u, r3294);
               body.emit(assign(r327E, bit_or(r327E, r3295), 0x01));


            body.instructions = f3283_parent_instructions;
            body.emit(f3283);

            /* END IF */

            body.emit(assign(r3247, r3280, 0x02));

            body.emit(assign(r3247, r327F, 0x01));

            body.emit(assign(r324A, r327E, 0x01));

            body.emit(assign(r3249, r324D, 0x01));


         body.instructions = f3257_parent_instructions;
         body.emit(f3257);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f3255->else_instructions;

         /* IF CONDITION */
         ir_expression *const r3297 = less(r3246, body.constant(int(0)));
         ir_if *f3296 = new(mem_ctx) ir_if(operand(r3297).val);
         exec_list *const f3296_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3296->then_instructions;

            /* IF CONDITION */
            ir_expression *const r3299 = equal(r3251, body.constant(int(2047)));
            ir_if *f3298 = new(mem_ctx) ir_if(operand(r3299).val);
            exec_list *const f3298_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3298->then_instructions;

               /* IF CONDITION */
               ir_expression *const r329B = bit_or(swizzle_y(r3247), swizzle_x(r3247));
               ir_expression *const r329C = nequal(r329B, body.constant(0u));
               ir_if *f329A = new(mem_ctx) ir_if(operand(r329C).val);
               exec_list *const f329A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f329A->then_instructions;

                  ir_variable *const r329D = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r329D, swizzle_x(r28D7), 0x01));

                  ir_variable *const r329E = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r329E, swizzle_x(r290B), 0x01));

                  ir_variable *const r329F = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r32A0 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r32A1 = rshift(swizzle_y(r28D7), body.constant(int(19)));
                  ir_expression *const r32A2 = bit_and(r32A1, body.constant(4095u));
                  ir_expression *const r32A3 = equal(r32A2, body.constant(4094u));
                  ir_expression *const r32A4 = nequal(swizzle_x(r28D7), body.constant(0u));
                  ir_expression *const r32A5 = bit_and(swizzle_y(r28D7), body.constant(524287u));
                  ir_expression *const r32A6 = nequal(r32A5, body.constant(0u));
                  ir_expression *const r32A7 = logic_or(r32A4, r32A6);
                  body.emit(assign(r32A0, logic_and(r32A3, r32A7), 0x01));

                  ir_variable *const r32A8 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r32A9 = lshift(swizzle_y(r290B), body.constant(int(1)));
                  ir_expression *const r32AA = lequal(body.constant(4292870144u), r32A9);
                  ir_expression *const r32AB = nequal(swizzle_x(r290B), body.constant(0u));
                  ir_expression *const r32AC = bit_and(swizzle_y(r290B), body.constant(1048575u));
                  ir_expression *const r32AD = nequal(r32AC, body.constant(0u));
                  ir_expression *const r32AE = logic_or(r32AB, r32AD);
                  body.emit(assign(r32A8, logic_and(r32AA, r32AE), 0x01));

                  body.emit(assign(r329D, bit_or(swizzle_y(r28D7), body.constant(524288u)), 0x02));

                  body.emit(assign(r329E, bit_or(swizzle_y(r290B), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r32B0 = lshift(swizzle_y(r28D7), body.constant(int(1)));
                  ir_expression *const r32B1 = lequal(body.constant(4292870144u), r32B0);
                  ir_expression *const r32B2 = nequal(swizzle_x(r28D7), body.constant(0u));
                  ir_expression *const r32B3 = bit_and(swizzle_y(r28D7), body.constant(1048575u));
                  ir_expression *const r32B4 = nequal(r32B3, body.constant(0u));
                  ir_expression *const r32B5 = logic_or(r32B2, r32B4);
                  ir_expression *const r32B6 = logic_and(r32B1, r32B5);
                  ir_if *f32AF = new(mem_ctx) ir_if(operand(r32B6).val);
                  exec_list *const f32AF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f32AF->then_instructions;

                     ir_variable *const r32B7 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r32B9 = logic_and(r32A0, r32A8);
                     ir_if *f32B8 = new(mem_ctx) ir_if(operand(r32B9).val);
                     exec_list *const f32B8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32B8->then_instructions;

                        body.emit(assign(r32B7, r329E, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f32B8->else_instructions;

                        body.emit(assign(r32B7, r329D, 0x03));


                     body.instructions = f32B8_parent_instructions;
                     body.emit(f32B8);

                     /* END IF */

                     body.emit(assign(r329F, r32B7, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f32AF->else_instructions;

                     body.emit(assign(r329F, r329E, 0x03));


                  body.instructions = f32AF_parent_instructions;
                  body.emit(f32AF);

                  /* END IF */

                  body.emit(assign(r3245, r329F, 0x03));

                  body.emit(assign(r3244, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f329A->else_instructions;

                  ir_variable *const r32BA = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r32BA);
                  ir_expression *const r32BB = lshift(r2E28, body.constant(int(31)));
                  body.emit(assign(r32BA, add(r32BB, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r32BA, body.constant(0u), 0x01));

                  body.emit(assign(r3245, r32BA, 0x03));

                  body.emit(assign(r3244, body.constant(false), 0x01));


               body.instructions = f329A_parent_instructions;
               body.emit(f329A);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f3298->else_instructions;

               /* IF CONDITION */
               ir_expression *const r32BD = equal(r324D, body.constant(int(0)));
               ir_if *f32BC = new(mem_ctx) ir_if(operand(r32BD).val);
               exec_list *const f32BC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f32BC->then_instructions;

                  body.emit(assign(r3246, add(r3246, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f32BC->else_instructions;

                  body.emit(assign(r3248, bit_or(swizzle_y(r324C), body.constant(1048576u)), 0x02));


               body.instructions = f32BC_parent_instructions;
               body.emit(f32BC);

               /* END IF */

               ir_variable *const r32BE = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r32BE, swizzle_y(r3248), 0x01));

               ir_variable *const r32BF = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r32BF, swizzle_x(r3248), 0x01));

               ir_variable *const r32C0 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r32C0, body.constant(0u), 0x01));

               ir_variable *const r32C1 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r32C1, neg(r3246), 0x01));

               ir_variable *const r32C2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r32C2);
               ir_variable *const r32C3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r32C3);
               ir_variable *const r32C4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r32C4);
               ir_variable *const r32C5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r32C6 = neg(r32C1);
               body.emit(assign(r32C5, bit_and(r32C6, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r32C8 = equal(r32C1, body.constant(int(0)));
               ir_if *f32C7 = new(mem_ctx) ir_if(operand(r32C8).val);
               exec_list *const f32C7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f32C7->then_instructions;

                  body.emit(assign(r32C2, r32C0, 0x01));

                  body.emit(assign(r32C3, r32BF, 0x01));

                  body.emit(assign(r32C4, r32BE, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f32C7->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r32CA = less(r32C1, body.constant(int(32)));
                  ir_if *f32C9 = new(mem_ctx) ir_if(operand(r32CA).val);
                  exec_list *const f32C9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f32C9->then_instructions;

                     body.emit(assign(r32C2, lshift(swizzle_x(r324C), r32C5), 0x01));

                     ir_expression *const r32CB = lshift(swizzle_y(r3248), r32C5);
                     ir_expression *const r32CC = rshift(swizzle_x(r324C), r32C1);
                     body.emit(assign(r32C3, bit_or(r32CB, r32CC), 0x01));

                     body.emit(assign(r32C4, rshift(swizzle_y(r3248), r32C1), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f32C9->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r32CE = equal(r32C1, body.constant(int(32)));
                     ir_if *f32CD = new(mem_ctx) ir_if(operand(r32CE).val);
                     exec_list *const f32CD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32CD->then_instructions;

                        body.emit(assign(r32C2, r32BF, 0x01));

                        body.emit(assign(r32C3, r32BE, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f32CD->else_instructions;

                        body.emit(assign(r32C0, bit_or(body.constant(0u), swizzle_x(r324C)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r32D0 = less(r32C1, body.constant(int(64)));
                        ir_if *f32CF = new(mem_ctx) ir_if(operand(r32D0).val);
                        exec_list *const f32CF_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f32CF->then_instructions;

                           body.emit(assign(r32C2, lshift(swizzle_y(r3248), r32C5), 0x01));

                           ir_expression *const r32D1 = bit_and(r32C1, body.constant(int(31)));
                           body.emit(assign(r32C3, rshift(swizzle_y(r3248), r32D1), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f32CF->else_instructions;

                           ir_variable *const r32D2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r32D4 = equal(r32C1, body.constant(int(64)));
                           ir_if *f32D3 = new(mem_ctx) ir_if(operand(r32D4).val);
                           exec_list *const f32D3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f32D3->then_instructions;

                              body.emit(assign(r32D2, r32BE, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f32D3->else_instructions;

                              ir_expression *const r32D5 = nequal(swizzle_y(r3248), body.constant(0u));
                              ir_expression *const r32D6 = expr(ir_unop_b2i, r32D5);
                              body.emit(assign(r32D2, expr(ir_unop_i2u, r32D6), 0x01));


                           body.instructions = f32D3_parent_instructions;
                           body.emit(f32D3);

                           /* END IF */

                           body.emit(assign(r32C2, r32D2, 0x01));

                           body.emit(assign(r32C3, body.constant(0u), 0x01));


                        body.instructions = f32CF_parent_instructions;
                        body.emit(f32CF);

                        /* END IF */


                     body.instructions = f32CD_parent_instructions;
                     body.emit(f32CD);

                     /* END IF */

                     body.emit(assign(r32C4, body.constant(0u), 0x01));


                  body.instructions = f32C9_parent_instructions;
                  body.emit(f32C9);

                  /* END IF */

                  ir_expression *const r32D7 = nequal(r32C0, body.constant(0u));
                  ir_expression *const r32D8 = expr(ir_unop_b2i, r32D7);
                  ir_expression *const r32D9 = expr(ir_unop_i2u, r32D8);
                  body.emit(assign(r32C2, bit_or(r32C2, r32D9), 0x01));


               body.instructions = f32C7_parent_instructions;
               body.emit(f32C7);

               /* END IF */

               body.emit(assign(r3248, r32C4, 0x02));

               body.emit(assign(r3248, r32C3, 0x01));

               body.emit(assign(r324A, r32C2, 0x01));

               body.emit(assign(r3249, r3251, 0x01));


            body.instructions = f3298_parent_instructions;
            body.emit(f3298);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3296->else_instructions;

            /* IF CONDITION */
            ir_expression *const r32DB = equal(r324D, body.constant(int(2047)));
            ir_if *f32DA = new(mem_ctx) ir_if(operand(r32DB).val);
            exec_list *const f32DA_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f32DA->then_instructions;

               /* IF CONDITION */
               ir_expression *const r32DD = bit_or(swizzle_y(r3248), swizzle_x(r3248));
               ir_expression *const r32DE = bit_or(swizzle_y(r3247), swizzle_x(r3247));
               ir_expression *const r32DF = bit_or(r32DD, r32DE);
               ir_expression *const r32E0 = nequal(r32DF, body.constant(0u));
               ir_if *f32DC = new(mem_ctx) ir_if(operand(r32E0).val);
               exec_list *const f32DC_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f32DC->then_instructions;

                  ir_variable *const r32E1 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r32E1, swizzle_x(r28D7), 0x01));

                  ir_variable *const r32E2 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r32E2, swizzle_x(r290B), 0x01));

                  ir_variable *const r32E3 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r32E4 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r32E5 = rshift(swizzle_y(r28D7), body.constant(int(19)));
                  ir_expression *const r32E6 = bit_and(r32E5, body.constant(4095u));
                  ir_expression *const r32E7 = equal(r32E6, body.constant(4094u));
                  ir_expression *const r32E8 = nequal(swizzle_x(r28D7), body.constant(0u));
                  ir_expression *const r32E9 = bit_and(swizzle_y(r28D7), body.constant(524287u));
                  ir_expression *const r32EA = nequal(r32E9, body.constant(0u));
                  ir_expression *const r32EB = logic_or(r32E8, r32EA);
                  body.emit(assign(r32E4, logic_and(r32E7, r32EB), 0x01));

                  ir_variable *const r32EC = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r32ED = lshift(swizzle_y(r290B), body.constant(int(1)));
                  ir_expression *const r32EE = lequal(body.constant(4292870144u), r32ED);
                  ir_expression *const r32EF = nequal(swizzle_x(r290B), body.constant(0u));
                  ir_expression *const r32F0 = bit_and(swizzle_y(r290B), body.constant(1048575u));
                  ir_expression *const r32F1 = nequal(r32F0, body.constant(0u));
                  ir_expression *const r32F2 = logic_or(r32EF, r32F1);
                  body.emit(assign(r32EC, logic_and(r32EE, r32F2), 0x01));

                  body.emit(assign(r32E1, bit_or(swizzle_y(r28D7), body.constant(524288u)), 0x02));

                  body.emit(assign(r32E2, bit_or(swizzle_y(r290B), body.constant(524288u)), 0x02));

                  /* IF CONDITION */
                  ir_expression *const r32F4 = lshift(swizzle_y(r28D7), body.constant(int(1)));
                  ir_expression *const r32F5 = lequal(body.constant(4292870144u), r32F4);
                  ir_expression *const r32F6 = nequal(swizzle_x(r28D7), body.constant(0u));
                  ir_expression *const r32F7 = bit_and(swizzle_y(r28D7), body.constant(1048575u));
                  ir_expression *const r32F8 = nequal(r32F7, body.constant(0u));
                  ir_expression *const r32F9 = logic_or(r32F6, r32F8);
                  ir_expression *const r32FA = logic_and(r32F5, r32F9);
                  ir_if *f32F3 = new(mem_ctx) ir_if(operand(r32FA).val);
                  exec_list *const f32F3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f32F3->then_instructions;

                     ir_variable *const r32FB = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r32FD = logic_and(r32E4, r32EC);
                     ir_if *f32FC = new(mem_ctx) ir_if(operand(r32FD).val);
                     exec_list *const f32FC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f32FC->then_instructions;

                        body.emit(assign(r32FB, r32E2, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f32FC->else_instructions;

                        body.emit(assign(r32FB, r32E1, 0x03));


                     body.instructions = f32FC_parent_instructions;
                     body.emit(f32FC);

                     /* END IF */

                     body.emit(assign(r32E3, r32FB, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f32F3->else_instructions;

                     body.emit(assign(r32E3, r32E2, 0x03));


                  body.instructions = f32F3_parent_instructions;
                  body.emit(f32F3);

                  /* END IF */

                  body.emit(assign(r3245, r32E3, 0x03));

                  body.emit(assign(r3244, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f32DC->else_instructions;

                  body.emit(assign(r3245, r28D7, 0x03));

                  body.emit(assign(r3244, body.constant(false), 0x01));


               body.instructions = f32DC_parent_instructions;
               body.emit(f32DC);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f32DA->else_instructions;

               ir_variable *const r32FE = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r32FF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r32FF, add(swizzle_x(r3248), swizzle_x(r3247)), 0x01));

               ir_expression *const r3300 = add(swizzle_y(r3248), swizzle_y(r3247));
               ir_expression *const r3301 = less(r32FF, swizzle_x(r3248));
               ir_expression *const r3302 = expr(ir_unop_b2i, r3301);
               ir_expression *const r3303 = expr(ir_unop_i2u, r3302);
               body.emit(assign(r32FE, add(r3300, r3303), 0x01));

               body.emit(assign(r324B, r32FE, 0x01));

               /* IF CONDITION */
               ir_expression *const r3305 = equal(r324D, body.constant(int(0)));
               ir_if *f3304 = new(mem_ctx) ir_if(operand(r3305).val);
               exec_list *const f3304_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3304->then_instructions;

                  ir_variable *const r3306 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r3306);
                  ir_expression *const r3307 = lshift(r2E28, body.constant(int(31)));
                  body.emit(assign(r3306, add(r3307, r32FE), 0x02));

                  body.emit(assign(r3306, r32FF, 0x01));

                  body.emit(assign(r3245, r3306, 0x03));

                  body.emit(assign(r3244, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3304->else_instructions;

                  body.emit(assign(r324B, bit_or(r32FE, body.constant(2097152u)), 0x01));

                  body.emit(assign(r3249, r324D, 0x01));

                  ir_variable *const r3308 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r3308);
                  ir_variable *const r3309 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r3309);
                  ir_variable *const r330A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r330A);
                  body.emit(assign(r3308, lshift(r32FF, body.constant(int(31))), 0x01));

                  ir_expression *const r330B = lshift(r324B, body.constant(int(31)));
                  ir_expression *const r330C = rshift(r32FF, body.constant(int(1)));
                  body.emit(assign(r3309, bit_or(r330B, r330C), 0x01));

                  body.emit(assign(r330A, rshift(r324B, body.constant(int(1))), 0x01));

                  body.emit(assign(r3308, bit_or(r3308, body.constant(0u)), 0x01));

                  body.emit(assign(r324B, r330A, 0x01));

                  body.emit(assign(r324A, r3308, 0x01));

                  ir_variable *const r330D = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r330D, r324D, 0x01));

                  ir_variable *const r330E = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r330E, r330A, 0x01));

                  ir_variable *const r330F = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r330F, r3309, 0x01));

                  ir_variable *const r3310 = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r3310, r3308, 0x01));

                  ir_variable *const r3311 = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r3311, body.constant(true), 0x01));

                  ir_variable *const r3312 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r3313 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r3313);
                  ir_expression *const r3314 = expr(ir_unop_u2i, r3308);
                  body.emit(assign(r3313, less(r3314, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r3316 = lequal(body.constant(int(2045)), r324D);
                  ir_if *f3315 = new(mem_ctx) ir_if(operand(r3316).val);
                  exec_list *const f3315_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3315->then_instructions;

                     ir_variable *const r3317 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r3319 = less(body.constant(int(2045)), r324D);
                     ir_if *f3318 = new(mem_ctx) ir_if(operand(r3319).val);
                     exec_list *const f3318_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3318->then_instructions;

                        body.emit(assign(r3317, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3318->else_instructions;

                        ir_variable *const r331A = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r331C = equal(r324D, body.constant(int(2045)));
                        ir_if *f331B = new(mem_ctx) ir_if(operand(r331C).val);
                        exec_list *const f331B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f331B->then_instructions;

                           ir_expression *const r331D = equal(body.constant(2097151u), r330A);
                           ir_expression *const r331E = equal(body.constant(4294967295u), r3309);
                           body.emit(assign(r331A, logic_and(r331D, r331E), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f331B->else_instructions;

                           body.emit(assign(r331A, body.constant(false), 0x01));


                        body.instructions = f331B_parent_instructions;
                        body.emit(f331B);

                        /* END IF */

                        body.emit(assign(r3317, logic_and(r331A, r3313), 0x01));


                     body.instructions = f3318_parent_instructions;
                     body.emit(f3318);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f331F = new(mem_ctx) ir_if(operand(r3317).val);
                     exec_list *const f331F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f331F->then_instructions;

                        ir_variable *const r3320 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r3320);
                        ir_expression *const r3321 = lshift(r2E28, body.constant(int(31)));
                        body.emit(assign(r3320, add(r3321, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r3320, body.constant(0u), 0x01));

                        body.emit(assign(r3312, r3320, 0x03));

                        body.emit(assign(r3311, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f331F->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r3323 = less(r324D, body.constant(int(0)));
                        ir_if *f3322 = new(mem_ctx) ir_if(operand(r3323).val);
                        exec_list *const f3322_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f3322->then_instructions;

                           ir_variable *const r3324 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r3324, r3308, 0x01));

                           ir_variable *const r3325 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r3325, neg(r324D), 0x01));

                           ir_variable *const r3326 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r3326);
                           ir_variable *const r3327 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r3327);
                           ir_variable *const r3328 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r3328);
                           ir_variable *const r3329 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r332A = neg(r3325);
                           body.emit(assign(r3329, bit_and(r332A, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r332C = equal(r3325, body.constant(int(0)));
                           ir_if *f332B = new(mem_ctx) ir_if(operand(r332C).val);
                           exec_list *const f332B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f332B->then_instructions;

                              body.emit(assign(r3326, r3308, 0x01));

                              body.emit(assign(r3327, r3309, 0x01));

                              body.emit(assign(r3328, r330A, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f332B->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r332E = less(r3325, body.constant(int(32)));
                              ir_if *f332D = new(mem_ctx) ir_if(operand(r332E).val);
                              exec_list *const f332D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f332D->then_instructions;

                                 body.emit(assign(r3326, lshift(r3309, r3329), 0x01));

                                 ir_expression *const r332F = lshift(r330A, r3329);
                                 ir_expression *const r3330 = rshift(r3309, r3325);
                                 body.emit(assign(r3327, bit_or(r332F, r3330), 0x01));

                                 body.emit(assign(r3328, rshift(r330A, r3325), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f332D->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r3332 = equal(r3325, body.constant(int(32)));
                                 ir_if *f3331 = new(mem_ctx) ir_if(operand(r3332).val);
                                 exec_list *const f3331_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3331->then_instructions;

                                    body.emit(assign(r3326, r3309, 0x01));

                                    body.emit(assign(r3327, r330A, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3331->else_instructions;

                                    body.emit(assign(r3324, bit_or(r3308, r3309), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r3334 = less(r3325, body.constant(int(64)));
                                    ir_if *f3333 = new(mem_ctx) ir_if(operand(r3334).val);
                                    exec_list *const f3333_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f3333->then_instructions;

                                       body.emit(assign(r3326, lshift(r330A, r3329), 0x01));

                                       ir_expression *const r3335 = bit_and(r3325, body.constant(int(31)));
                                       body.emit(assign(r3327, rshift(r330A, r3335), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f3333->else_instructions;

                                       ir_variable *const r3336 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r3338 = equal(r3325, body.constant(int(64)));
                                       ir_if *f3337 = new(mem_ctx) ir_if(operand(r3338).val);
                                       exec_list *const f3337_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f3337->then_instructions;

                                          body.emit(assign(r3336, r330A, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f3337->else_instructions;

                                          ir_expression *const r3339 = nequal(r330A, body.constant(0u));
                                          ir_expression *const r333A = expr(ir_unop_b2i, r3339);
                                          body.emit(assign(r3336, expr(ir_unop_i2u, r333A), 0x01));


                                       body.instructions = f3337_parent_instructions;
                                       body.emit(f3337);

                                       /* END IF */

                                       body.emit(assign(r3326, r3336, 0x01));

                                       body.emit(assign(r3327, body.constant(0u), 0x01));


                                    body.instructions = f3333_parent_instructions;
                                    body.emit(f3333);

                                    /* END IF */


                                 body.instructions = f3331_parent_instructions;
                                 body.emit(f3331);

                                 /* END IF */

                                 body.emit(assign(r3328, body.constant(0u), 0x01));


                              body.instructions = f332D_parent_instructions;
                              body.emit(f332D);

                              /* END IF */

                              ir_expression *const r333B = nequal(r3324, body.constant(0u));
                              ir_expression *const r333C = expr(ir_unop_b2i, r333B);
                              ir_expression *const r333D = expr(ir_unop_i2u, r333C);
                              body.emit(assign(r3326, bit_or(r3326, r333D), 0x01));


                           body.instructions = f332B_parent_instructions;
                           body.emit(f332B);

                           /* END IF */

                           body.emit(assign(r330E, r3328, 0x01));

                           body.emit(assign(r330F, r3327, 0x01));

                           body.emit(assign(r3310, r3326, 0x01));

                           body.emit(assign(r330D, body.constant(int(0)), 0x01));

                           body.emit(assign(r3313, less(r3326, body.constant(0u)), 0x01));


                        body.instructions = f3322_parent_instructions;
                        body.emit(f3322);

                        /* END IF */


                     body.instructions = f331F_parent_instructions;
                     body.emit(f331F);

                     /* END IF */


                  body.instructions = f3315_parent_instructions;
                  body.emit(f3315);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f333E = new(mem_ctx) ir_if(operand(r3311).val);
                  exec_list *const f333E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f333E->then_instructions;

                     /* IF CONDITION */
                     ir_if *f333F = new(mem_ctx) ir_if(operand(r3313).val);
                     exec_list *const f333F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f333F->then_instructions;

                        ir_variable *const r3340 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r3340, add(r330F, body.constant(1u)), 0x01));

                        ir_expression *const r3341 = less(r3340, r330F);
                        ir_expression *const r3342 = expr(ir_unop_b2i, r3341);
                        ir_expression *const r3343 = expr(ir_unop_i2u, r3342);
                        body.emit(assign(r330E, add(r330E, r3343), 0x01));

                        ir_expression *const r3344 = equal(r3310, body.constant(0u));
                        ir_expression *const r3345 = expr(ir_unop_b2i, r3344);
                        ir_expression *const r3346 = expr(ir_unop_i2u, r3345);
                        ir_expression *const r3347 = add(r3310, r3346);
                        ir_expression *const r3348 = bit_and(r3347, body.constant(1u));
                        ir_expression *const r3349 = expr(ir_unop_bit_not, r3348);
                        body.emit(assign(r330F, bit_and(r3340, r3349), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f333F->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r334B = bit_or(r330E, r330F);
                        ir_expression *const r334C = equal(r334B, body.constant(0u));
                        ir_if *f334A = new(mem_ctx) ir_if(operand(r334C).val);
                        exec_list *const f334A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f334A->then_instructions;

                           body.emit(assign(r330D, body.constant(int(0)), 0x01));


                        body.instructions = f334A_parent_instructions;
                        body.emit(f334A);

                        /* END IF */


                     body.instructions = f333F_parent_instructions;
                     body.emit(f333F);

                     /* END IF */

                     ir_variable *const r334D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r334D);
                     ir_expression *const r334E = lshift(r2E28, body.constant(int(31)));
                     ir_expression *const r334F = expr(ir_unop_i2u, r330D);
                     ir_expression *const r3350 = lshift(r334F, body.constant(int(20)));
                     ir_expression *const r3351 = add(r334E, r3350);
                     body.emit(assign(r334D, add(r3351, r330E), 0x02));

                     body.emit(assign(r334D, r330F, 0x01));

                     body.emit(assign(r3312, r334D, 0x03));

                     body.emit(assign(r3311, body.constant(false), 0x01));


                  body.instructions = f333E_parent_instructions;
                  body.emit(f333E);

                  /* END IF */

                  body.emit(assign(r3245, r3312, 0x03));

                  body.emit(assign(r3244, body.constant(false), 0x01));


               body.instructions = f3304_parent_instructions;
               body.emit(f3304);

               /* END IF */


            body.instructions = f32DA_parent_instructions;
            body.emit(f32DA);

            /* END IF */


         body.instructions = f3296_parent_instructions;
         body.emit(f3296);

         /* END IF */


      body.instructions = f3255_parent_instructions;
      body.emit(f3255);

      /* END IF */

      /* IF CONDITION */
      ir_if *f3352 = new(mem_ctx) ir_if(operand(r3244).val);
      exec_list *const f3352_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f3352->then_instructions;

         body.emit(assign(r3248, bit_or(swizzle_y(r3248), body.constant(1048576u)), 0x02));

         ir_variable *const r3353 = body.make_temp(glsl_type::uint_type, "z0Ptr");
         ir_variable *const r3354 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r3354, add(swizzle_x(r3248), swizzle_x(r3247)), 0x01));

         ir_expression *const r3355 = add(swizzle_y(r3248), swizzle_y(r3247));
         ir_expression *const r3356 = less(r3354, swizzle_x(r3248));
         ir_expression *const r3357 = expr(ir_unop_b2i, r3356);
         ir_expression *const r3358 = expr(ir_unop_i2u, r3357);
         body.emit(assign(r3353, add(r3355, r3358), 0x01));

         body.emit(assign(r324B, r3353, 0x01));

         body.emit(assign(r3249, add(r3249, body.constant(int(-1))), 0x01));

         /* IF CONDITION */
         ir_expression *const r335A = less(r3353, body.constant(2097152u));
         ir_if *f3359 = new(mem_ctx) ir_if(operand(r335A).val);
         exec_list *const f3359_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f3359->then_instructions;

            ir_variable *const r335B = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r335B, r3249, 0x01));

            ir_variable *const r335C = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r335C, r3353, 0x01));

            ir_variable *const r335D = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r335D, r3354, 0x01));

            ir_variable *const r335E = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r335E, r324A, 0x01));

            ir_variable *const r335F = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r335F, body.constant(true), 0x01));

            ir_variable *const r3360 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r3361 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r3361);
            ir_expression *const r3362 = expr(ir_unop_u2i, r324A);
            body.emit(assign(r3361, less(r3362, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r3364 = lequal(body.constant(int(2045)), r3249);
            ir_if *f3363 = new(mem_ctx) ir_if(operand(r3364).val);
            exec_list *const f3363_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f3363->then_instructions;

               ir_variable *const r3365 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r3367 = less(body.constant(int(2045)), r3249);
               ir_if *f3366 = new(mem_ctx) ir_if(operand(r3367).val);
               exec_list *const f3366_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f3366->then_instructions;

                  body.emit(assign(r3365, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f3366->else_instructions;

                  ir_variable *const r3368 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r336A = equal(r3249, body.constant(int(2045)));
                  ir_if *f3369 = new(mem_ctx) ir_if(operand(r336A).val);
                  exec_list *const f3369_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3369->then_instructions;

                     ir_expression *const r336B = equal(body.constant(2097151u), r3353);
                     ir_expression *const r336C = equal(body.constant(4294967295u), r3354);
                     body.emit(assign(r3368, logic_and(r336B, r336C), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f3369->else_instructions;

                     body.emit(assign(r3368, body.constant(false), 0x01));


                  body.instructions = f3369_parent_instructions;
                  body.emit(f3369);

                  /* END IF */

                  body.emit(assign(r3365, logic_and(r3368, r3361), 0x01));


               body.instructions = f3366_parent_instructions;
               body.emit(f3366);

               /* END IF */

               /* IF CONDITION */
               ir_if *f336D = new(mem_ctx) ir_if(operand(r3365).val);
               exec_list *const f336D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f336D->then_instructions;

                  ir_variable *const r336E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r336E);
                  ir_expression *const r336F = lshift(r2E28, body.constant(int(31)));
                  body.emit(assign(r336E, add(r336F, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r336E, body.constant(0u), 0x01));

                  body.emit(assign(r3360, r336E, 0x03));

                  body.emit(assign(r335F, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f336D->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3371 = less(r3249, body.constant(int(0)));
                  ir_if *f3370 = new(mem_ctx) ir_if(operand(r3371).val);
                  exec_list *const f3370_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3370->then_instructions;

                     ir_variable *const r3372 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r3372, r324A, 0x01));

                     ir_variable *const r3373 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r3373, neg(r3249), 0x01));

                     ir_variable *const r3374 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r3374);
                     ir_variable *const r3375 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r3375);
                     ir_variable *const r3376 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r3376);
                     ir_variable *const r3377 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r3378 = neg(r3373);
                     body.emit(assign(r3377, bit_and(r3378, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r337A = equal(r3373, body.constant(int(0)));
                     ir_if *f3379 = new(mem_ctx) ir_if(operand(r337A).val);
                     exec_list *const f3379_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f3379->then_instructions;

                        body.emit(assign(r3374, r324A, 0x01));

                        body.emit(assign(r3375, r3354, 0x01));

                        body.emit(assign(r3376, r3353, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f3379->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r337C = less(r3373, body.constant(int(32)));
                        ir_if *f337B = new(mem_ctx) ir_if(operand(r337C).val);
                        exec_list *const f337B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f337B->then_instructions;

                           body.emit(assign(r3374, lshift(r3354, r3377), 0x01));

                           ir_expression *const r337D = lshift(r3353, r3377);
                           ir_expression *const r337E = rshift(r3354, r3373);
                           body.emit(assign(r3375, bit_or(r337D, r337E), 0x01));

                           body.emit(assign(r3376, rshift(r3353, r3373), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f337B->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r3380 = equal(r3373, body.constant(int(32)));
                           ir_if *f337F = new(mem_ctx) ir_if(operand(r3380).val);
                           exec_list *const f337F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f337F->then_instructions;

                              body.emit(assign(r3374, r3354, 0x01));

                              body.emit(assign(r3375, r3353, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f337F->else_instructions;

                              body.emit(assign(r3372, bit_or(r324A, r3354), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r3382 = less(r3373, body.constant(int(64)));
                              ir_if *f3381 = new(mem_ctx) ir_if(operand(r3382).val);
                              exec_list *const f3381_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f3381->then_instructions;

                                 body.emit(assign(r3374, lshift(r3353, r3377), 0x01));

                                 ir_expression *const r3383 = bit_and(r3373, body.constant(int(31)));
                                 body.emit(assign(r3375, rshift(r3353, r3383), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f3381->else_instructions;

                                 ir_variable *const r3384 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r3386 = equal(r3373, body.constant(int(64)));
                                 ir_if *f3385 = new(mem_ctx) ir_if(operand(r3386).val);
                                 exec_list *const f3385_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f3385->then_instructions;

                                    body.emit(assign(r3384, r3353, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f3385->else_instructions;

                                    ir_expression *const r3387 = nequal(r3353, body.constant(0u));
                                    ir_expression *const r3388 = expr(ir_unop_b2i, r3387);
                                    body.emit(assign(r3384, expr(ir_unop_i2u, r3388), 0x01));


                                 body.instructions = f3385_parent_instructions;
                                 body.emit(f3385);

                                 /* END IF */

                                 body.emit(assign(r3374, r3384, 0x01));

                                 body.emit(assign(r3375, body.constant(0u), 0x01));


                              body.instructions = f3381_parent_instructions;
                              body.emit(f3381);

                              /* END IF */


                           body.instructions = f337F_parent_instructions;
                           body.emit(f337F);

                           /* END IF */

                           body.emit(assign(r3376, body.constant(0u), 0x01));


                        body.instructions = f337B_parent_instructions;
                        body.emit(f337B);

                        /* END IF */

                        ir_expression *const r3389 = nequal(r3372, body.constant(0u));
                        ir_expression *const r338A = expr(ir_unop_b2i, r3389);
                        ir_expression *const r338B = expr(ir_unop_i2u, r338A);
                        body.emit(assign(r3374, bit_or(r3374, r338B), 0x01));


                     body.instructions = f3379_parent_instructions;
                     body.emit(f3379);

                     /* END IF */

                     body.emit(assign(r335C, r3376, 0x01));

                     body.emit(assign(r335D, r3375, 0x01));

                     body.emit(assign(r335E, r3374, 0x01));

                     body.emit(assign(r335B, body.constant(int(0)), 0x01));

                     body.emit(assign(r3361, less(r3374, body.constant(0u)), 0x01));


                  body.instructions = f3370_parent_instructions;
                  body.emit(f3370);

                  /* END IF */


               body.instructions = f336D_parent_instructions;
               body.emit(f336D);

               /* END IF */


            body.instructions = f3363_parent_instructions;
            body.emit(f3363);

            /* END IF */

            /* IF CONDITION */
            ir_if *f338C = new(mem_ctx) ir_if(operand(r335F).val);
            exec_list *const f338C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f338C->then_instructions;

               /* IF CONDITION */
               ir_if *f338D = new(mem_ctx) ir_if(operand(r3361).val);
               exec_list *const f338D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f338D->then_instructions;

                  ir_variable *const r338E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r338E, add(r335D, body.constant(1u)), 0x01));

                  ir_expression *const r338F = less(r338E, r335D);
                  ir_expression *const r3390 = expr(ir_unop_b2i, r338F);
                  ir_expression *const r3391 = expr(ir_unop_i2u, r3390);
                  body.emit(assign(r335C, add(r335C, r3391), 0x01));

                  ir_expression *const r3392 = equal(r335E, body.constant(0u));
                  ir_expression *const r3393 = expr(ir_unop_b2i, r3392);
                  ir_expression *const r3394 = expr(ir_unop_i2u, r3393);
                  ir_expression *const r3395 = add(r335E, r3394);
                  ir_expression *const r3396 = bit_and(r3395, body.constant(1u));
                  ir_expression *const r3397 = expr(ir_unop_bit_not, r3396);
                  body.emit(assign(r335D, bit_and(r338E, r3397), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f338D->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r3399 = bit_or(r335C, r335D);
                  ir_expression *const r339A = equal(r3399, body.constant(0u));
                  ir_if *f3398 = new(mem_ctx) ir_if(operand(r339A).val);
                  exec_list *const f3398_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f3398->then_instructions;

                     body.emit(assign(r335B, body.constant(int(0)), 0x01));


                  body.instructions = f3398_parent_instructions;
                  body.emit(f3398);

                  /* END IF */


               body.instructions = f338D_parent_instructions;
               body.emit(f338D);

               /* END IF */

               ir_variable *const r339B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r339B);
               ir_expression *const r339C = lshift(r2E28, body.constant(int(31)));
               ir_expression *const r339D = expr(ir_unop_i2u, r335B);
               ir_expression *const r339E = lshift(r339D, body.constant(int(20)));
               ir_expression *const r339F = add(r339C, r339E);
               body.emit(assign(r339B, add(r339F, r335C), 0x02));

               body.emit(assign(r339B, r335D, 0x01));

               body.emit(assign(r3360, r339B, 0x03));

               body.emit(assign(r335F, body.constant(false), 0x01));


            body.instructions = f338C_parent_instructions;
            body.emit(f338C);

            /* END IF */

            body.emit(assign(r3245, r3360, 0x03));

            body.emit(assign(r3244, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f3359->else_instructions;

            body.emit(assign(r3249, add(r3249, body.constant(int(1))), 0x01));

            ir_variable *const r33A0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r33A0);
            ir_variable *const r33A1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r33A1);
            ir_variable *const r33A2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r33A2);
            body.emit(assign(r33A0, lshift(r3354, body.constant(int(31))), 0x01));

            ir_expression *const r33A3 = lshift(r3353, body.constant(int(31)));
            ir_expression *const r33A4 = rshift(r3354, body.constant(int(1)));
            body.emit(assign(r33A1, bit_or(r33A3, r33A4), 0x01));

            body.emit(assign(r33A2, rshift(r3353, body.constant(int(1))), 0x01));

            ir_expression *const r33A5 = nequal(r324A, body.constant(0u));
            ir_expression *const r33A6 = expr(ir_unop_b2i, r33A5);
            ir_expression *const r33A7 = expr(ir_unop_i2u, r33A6);
            body.emit(assign(r33A0, bit_or(r33A0, r33A7), 0x01));

            body.emit(assign(r324B, r33A2, 0x01));

            body.emit(assign(r324A, r33A0, 0x01));

            ir_variable *const r33A8 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r33A8, r3249, 0x01));

            ir_variable *const r33A9 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r33A9, r33A2, 0x01));

            ir_variable *const r33AA = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r33AA, r33A1, 0x01));

            ir_variable *const r33AB = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r33AB, r33A0, 0x01));

            ir_variable *const r33AC = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r33AC, body.constant(true), 0x01));

            ir_variable *const r33AD = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r33AE = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r33AE);
            ir_expression *const r33AF = expr(ir_unop_u2i, r33A0);
            body.emit(assign(r33AE, less(r33AF, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r33B1 = lequal(body.constant(int(2045)), r3249);
            ir_if *f33B0 = new(mem_ctx) ir_if(operand(r33B1).val);
            exec_list *const f33B0_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f33B0->then_instructions;

               ir_variable *const r33B2 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r33B4 = less(body.constant(int(2045)), r3249);
               ir_if *f33B3 = new(mem_ctx) ir_if(operand(r33B4).val);
               exec_list *const f33B3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f33B3->then_instructions;

                  body.emit(assign(r33B2, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f33B3->else_instructions;

                  ir_variable *const r33B5 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r33B7 = equal(r3249, body.constant(int(2045)));
                  ir_if *f33B6 = new(mem_ctx) ir_if(operand(r33B7).val);
                  exec_list *const f33B6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f33B6->then_instructions;

                     ir_expression *const r33B8 = equal(body.constant(2097151u), r33A2);
                     ir_expression *const r33B9 = equal(body.constant(4294967295u), r33A1);
                     body.emit(assign(r33B5, logic_and(r33B8, r33B9), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f33B6->else_instructions;

                     body.emit(assign(r33B5, body.constant(false), 0x01));


                  body.instructions = f33B6_parent_instructions;
                  body.emit(f33B6);

                  /* END IF */

                  body.emit(assign(r33B2, logic_and(r33B5, r33AE), 0x01));


               body.instructions = f33B3_parent_instructions;
               body.emit(f33B3);

               /* END IF */

               /* IF CONDITION */
               ir_if *f33BA = new(mem_ctx) ir_if(operand(r33B2).val);
               exec_list *const f33BA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f33BA->then_instructions;

                  ir_variable *const r33BB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r33BB);
                  ir_expression *const r33BC = lshift(r2E28, body.constant(int(31)));
                  body.emit(assign(r33BB, add(r33BC, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r33BB, body.constant(0u), 0x01));

                  body.emit(assign(r33AD, r33BB, 0x03));

                  body.emit(assign(r33AC, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f33BA->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r33BE = less(r3249, body.constant(int(0)));
                  ir_if *f33BD = new(mem_ctx) ir_if(operand(r33BE).val);
                  exec_list *const f33BD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f33BD->then_instructions;

                     ir_variable *const r33BF = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r33BF, r33A0, 0x01));

                     ir_variable *const r33C0 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r33C0, neg(r3249), 0x01));

                     ir_variable *const r33C1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r33C1);
                     ir_variable *const r33C2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r33C2);
                     ir_variable *const r33C3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r33C3);
                     ir_variable *const r33C4 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r33C5 = neg(r33C0);
                     body.emit(assign(r33C4, bit_and(r33C5, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r33C7 = equal(r33C0, body.constant(int(0)));
                     ir_if *f33C6 = new(mem_ctx) ir_if(operand(r33C7).val);
                     exec_list *const f33C6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f33C6->then_instructions;

                        body.emit(assign(r33C1, r33A0, 0x01));

                        body.emit(assign(r33C2, r33A1, 0x01));

                        body.emit(assign(r33C3, r33A2, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f33C6->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r33C9 = less(r33C0, body.constant(int(32)));
                        ir_if *f33C8 = new(mem_ctx) ir_if(operand(r33C9).val);
                        exec_list *const f33C8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f33C8->then_instructions;

                           body.emit(assign(r33C1, lshift(r33A1, r33C4), 0x01));

                           ir_expression *const r33CA = lshift(r33A2, r33C4);
                           ir_expression *const r33CB = rshift(r33A1, r33C0);
                           body.emit(assign(r33C2, bit_or(r33CA, r33CB), 0x01));

                           body.emit(assign(r33C3, rshift(r33A2, r33C0), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f33C8->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r33CD = equal(r33C0, body.constant(int(32)));
                           ir_if *f33CC = new(mem_ctx) ir_if(operand(r33CD).val);
                           exec_list *const f33CC_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f33CC->then_instructions;

                              body.emit(assign(r33C1, r33A1, 0x01));

                              body.emit(assign(r33C2, r33A2, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f33CC->else_instructions;

                              body.emit(assign(r33BF, bit_or(r33A0, r33A1), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r33CF = less(r33C0, body.constant(int(64)));
                              ir_if *f33CE = new(mem_ctx) ir_if(operand(r33CF).val);
                              exec_list *const f33CE_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f33CE->then_instructions;

                                 body.emit(assign(r33C1, lshift(r33A2, r33C4), 0x01));

                                 ir_expression *const r33D0 = bit_and(r33C0, body.constant(int(31)));
                                 body.emit(assign(r33C2, rshift(r33A2, r33D0), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f33CE->else_instructions;

                                 ir_variable *const r33D1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r33D3 = equal(r33C0, body.constant(int(64)));
                                 ir_if *f33D2 = new(mem_ctx) ir_if(operand(r33D3).val);
                                 exec_list *const f33D2_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f33D2->then_instructions;

                                    body.emit(assign(r33D1, r33A2, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f33D2->else_instructions;

                                    ir_expression *const r33D4 = nequal(r33A2, body.constant(0u));
                                    ir_expression *const r33D5 = expr(ir_unop_b2i, r33D4);
                                    body.emit(assign(r33D1, expr(ir_unop_i2u, r33D5), 0x01));


                                 body.instructions = f33D2_parent_instructions;
                                 body.emit(f33D2);

                                 /* END IF */

                                 body.emit(assign(r33C1, r33D1, 0x01));

                                 body.emit(assign(r33C2, body.constant(0u), 0x01));


                              body.instructions = f33CE_parent_instructions;
                              body.emit(f33CE);

                              /* END IF */


                           body.instructions = f33CC_parent_instructions;
                           body.emit(f33CC);

                           /* END IF */

                           body.emit(assign(r33C3, body.constant(0u), 0x01));


                        body.instructions = f33C8_parent_instructions;
                        body.emit(f33C8);

                        /* END IF */

                        ir_expression *const r33D6 = nequal(r33BF, body.constant(0u));
                        ir_expression *const r33D7 = expr(ir_unop_b2i, r33D6);
                        ir_expression *const r33D8 = expr(ir_unop_i2u, r33D7);
                        body.emit(assign(r33C1, bit_or(r33C1, r33D8), 0x01));


                     body.instructions = f33C6_parent_instructions;
                     body.emit(f33C6);

                     /* END IF */

                     body.emit(assign(r33A9, r33C3, 0x01));

                     body.emit(assign(r33AA, r33C2, 0x01));

                     body.emit(assign(r33AB, r33C1, 0x01));

                     body.emit(assign(r33A8, body.constant(int(0)), 0x01));

                     body.emit(assign(r33AE, less(r33C1, body.constant(0u)), 0x01));


                  body.instructions = f33BD_parent_instructions;
                  body.emit(f33BD);

                  /* END IF */


               body.instructions = f33BA_parent_instructions;
               body.emit(f33BA);

               /* END IF */


            body.instructions = f33B0_parent_instructions;
            body.emit(f33B0);

            /* END IF */

            /* IF CONDITION */
            ir_if *f33D9 = new(mem_ctx) ir_if(operand(r33AC).val);
            exec_list *const f33D9_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f33D9->then_instructions;

               /* IF CONDITION */
               ir_if *f33DA = new(mem_ctx) ir_if(operand(r33AE).val);
               exec_list *const f33DA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f33DA->then_instructions;

                  ir_variable *const r33DB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r33DB, add(r33AA, body.constant(1u)), 0x01));

                  ir_expression *const r33DC = less(r33DB, r33AA);
                  ir_expression *const r33DD = expr(ir_unop_b2i, r33DC);
                  ir_expression *const r33DE = expr(ir_unop_i2u, r33DD);
                  body.emit(assign(r33A9, add(r33A9, r33DE), 0x01));

                  ir_expression *const r33DF = equal(r33AB, body.constant(0u));
                  ir_expression *const r33E0 = expr(ir_unop_b2i, r33DF);
                  ir_expression *const r33E1 = expr(ir_unop_i2u, r33E0);
                  ir_expression *const r33E2 = add(r33AB, r33E1);
                  ir_expression *const r33E3 = bit_and(r33E2, body.constant(1u));
                  ir_expression *const r33E4 = expr(ir_unop_bit_not, r33E3);
                  body.emit(assign(r33AA, bit_and(r33DB, r33E4), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f33DA->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r33E6 = bit_or(r33A9, r33AA);
                  ir_expression *const r33E7 = equal(r33E6, body.constant(0u));
                  ir_if *f33E5 = new(mem_ctx) ir_if(operand(r33E7).val);
                  exec_list *const f33E5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f33E5->then_instructions;

                     body.emit(assign(r33A8, body.constant(int(0)), 0x01));


                  body.instructions = f33E5_parent_instructions;
                  body.emit(f33E5);

                  /* END IF */


               body.instructions = f33DA_parent_instructions;
               body.emit(f33DA);

               /* END IF */

               ir_variable *const r33E8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r33E8);
               ir_expression *const r33E9 = lshift(r2E28, body.constant(int(31)));
               ir_expression *const r33EA = expr(ir_unop_i2u, r33A8);
               ir_expression *const r33EB = lshift(r33EA, body.constant(int(20)));
               ir_expression *const r33EC = add(r33E9, r33EB);
               body.emit(assign(r33E8, add(r33EC, r33A9), 0x02));

               body.emit(assign(r33E8, r33AA, 0x01));

               body.emit(assign(r33AD, r33E8, 0x03));

               body.emit(assign(r33AC, body.constant(false), 0x01));


            body.instructions = f33D9_parent_instructions;
            body.emit(f33D9);

            /* END IF */

            body.emit(assign(r3245, r33AD, 0x03));

            body.emit(assign(r3244, body.constant(false), 0x01));


         body.instructions = f3359_parent_instructions;
         body.emit(f3359);

         /* END IF */


      body.instructions = f3352_parent_instructions;
      body.emit(f3352);

      /* END IF */

      body.emit(assign(r2E27, r3245, 0x03));


   body.instructions = f2E2A_parent_instructions;
   body.emit(f2E2A);

   /* END IF */

   body.emit(ret(r2E27));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
