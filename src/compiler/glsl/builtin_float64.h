ir_function_signature *
fabs64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r000B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r000B);
   body.emit(assign(r000B, bit_and(swizzle_y(r000B), body.constant(2147483647u)), 0x02));

   body.emit(ret(r000B));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
is_nan(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r000C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r000C);
   ir_expression *const r000D = lshift(swizzle_x(r000C), body.constant(int(1)));
   ir_expression *const r000E = lequal(body.constant(4292870144u), r000D);
   ir_expression *const r000F = nequal(swizzle_y(r000C), body.constant(0u));
   ir_expression *const r0010 = bit_and(swizzle_x(r000C), body.constant(1048575u));
   ir_expression *const r0011 = nequal(r0010, body.constant(0u));
   ir_expression *const r0012 = logic_or(r000F, r0011);
   ir_expression *const r0013 = logic_and(r000E, r0012);
   body.emit(ret(r0013));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fneg64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0014 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0014);
   ir_variable *const r0015 = body.make_temp(glsl_type::uvec2_type, "return_value");
   /* IF CONDITION */
   ir_expression *const r0017 = lshift(swizzle_x(r0014), body.constant(int(1)));
   ir_expression *const r0018 = lequal(body.constant(4292870144u), r0017);
   ir_expression *const r0019 = nequal(swizzle_y(r0014), body.constant(0u));
   ir_expression *const r001A = bit_and(swizzle_x(r0014), body.constant(1048575u));
   ir_expression *const r001B = nequal(r001A, body.constant(0u));
   ir_expression *const r001C = logic_or(r0019, r001B);
   ir_expression *const r001D = logic_and(r0018, r001C);
   ir_if *f0016 = new(mem_ctx) ir_if(operand(r001D).val);
   exec_list *const f0016_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0016->then_instructions;

      body.emit(assign(r0015, r0014, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0016->else_instructions;

      body.emit(assign(r0014, bit_xor(swizzle_y(r0014), body.constant(2147483648u)), 0x02));

      body.emit(assign(r0015, r0014, 0x03));


   body.instructions = f0016_parent_instructions;
   body.emit(f0016);

   /* END IF */

   body.emit(ret(r0015));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat64Frac(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r001E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r001E);
   ir_variable *const r001F = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
   body.emit(assign(r001F, bit_and(swizzle_y(r001E), body.constant(1048575u)), 0x01));

   body.emit(assign(r001F, swizzle_x(r001E), 0x02));

   body.emit(ret(r001F));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat64Exp(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::int_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0020 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0020);
   ir_expression *const r0021 = rshift(swizzle_y(r0020), body.constant(int(20)));
   ir_expression *const r0022 = bit_and(r0021, body.constant(2047u));
   ir_expression *const r0023 = expr(ir_unop_u2i, r0022);
   body.emit(ret(r0023));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
feq64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0024 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0024);
   ir_variable *const r0025 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0025);
   ir_variable *const r0026 = body.make_temp(glsl_type::bool_type, "return_value");
   ir_variable *const r0027 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
   body.emit(r0027);
   ir_variable *const r0028 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
   body.emit(r0028);
   ir_variable *const r0029 = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
   body.emit(assign(r0029, bit_and(swizzle_y(r0024), body.constant(1048575u)), 0x01));

   body.emit(assign(r0029, swizzle_x(r0024), 0x02));

   ir_variable *const r002A = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
   body.emit(assign(r002A, bit_and(swizzle_y(r0025), body.constant(1048575u)), 0x01));

   body.emit(assign(r002A, swizzle_x(r0025), 0x02));

   ir_expression *const r002B = rshift(swizzle_y(r0024), body.constant(int(20)));
   ir_expression *const r002C = bit_and(r002B, body.constant(2047u));
   ir_expression *const r002D = expr(ir_unop_u2i, r002C);
   ir_expression *const r002E = equal(r002D, body.constant(int(2047)));
   ir_expression *const r002F = bit_or(swizzle_x(r0024), swizzle_x(r0029));
   ir_expression *const r0030 = nequal(r002F, body.constant(0u));
   body.emit(assign(r0028, logic_and(r002E, r0030), 0x01));

   ir_expression *const r0031 = rshift(swizzle_y(r0025), body.constant(int(20)));
   ir_expression *const r0032 = bit_and(r0031, body.constant(2047u));
   ir_expression *const r0033 = expr(ir_unop_u2i, r0032);
   ir_expression *const r0034 = equal(r0033, body.constant(int(2047)));
   ir_expression *const r0035 = bit_or(swizzle_x(r0025), swizzle_x(r002A));
   ir_expression *const r0036 = nequal(r0035, body.constant(0u));
   body.emit(assign(r0027, logic_and(r0034, r0036), 0x01));

   /* IF CONDITION */
   ir_expression *const r0038 = logic_or(r0028, r0027);
   ir_if *f0037 = new(mem_ctx) ir_if(operand(r0038).val);
   exec_list *const f0037_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0037->then_instructions;

      body.emit(assign(r0026, body.constant(false), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0037->else_instructions;

      ir_expression *const r0039 = equal(swizzle_x(r0024), swizzle_x(r0025));
      ir_expression *const r003A = equal(swizzle_y(r0024), swizzle_y(r0025));
      ir_expression *const r003B = equal(swizzle_x(r0024), body.constant(0u));
      ir_expression *const r003C = bit_or(swizzle_y(r0024), swizzle_y(r0025));
      ir_expression *const r003D = lshift(r003C, body.constant(int(1)));
      ir_expression *const r003E = equal(r003D, body.constant(0u));
      ir_expression *const r003F = logic_and(r003B, r003E);
      ir_expression *const r0040 = logic_or(r003A, r003F);
      body.emit(assign(r0026, logic_and(r0039, r0040), 0x01));


   body.instructions = f0037_parent_instructions;
   body.emit(f0037);

   /* END IF */

   body.emit(ret(r0026));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat64Sign(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0041 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0041);
   ir_expression *const r0042 = rshift(swizzle_y(r0041), body.constant(int(31)));
   body.emit(ret(r0042));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
le64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0043 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r0043);
   ir_variable *const r0044 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r0044);
   ir_variable *const r0045 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r0045);
   ir_variable *const r0046 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r0046);
   ir_expression *const r0047 = less(r0043, r0045);
   ir_expression *const r0048 = equal(r0043, r0045);
   ir_expression *const r0049 = lequal(r0044, r0046);
   ir_expression *const r004A = logic_and(r0048, r0049);
   ir_expression *const r004B = logic_or(r0047, r004A);
   body.emit(ret(r004B));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fle64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r004C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r004C);
   ir_variable *const r004D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r004D);
   ir_variable *const r004E = body.make_temp(glsl_type::bool_type, "return_value");
   ir_variable *const r004F = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
   body.emit(r004F);
   ir_variable *const r0050 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
   body.emit(r0050);
   ir_variable *const r0051 = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
   body.emit(assign(r0051, bit_and(swizzle_y(r004C), body.constant(1048575u)), 0x01));

   body.emit(assign(r0051, swizzle_x(r004C), 0x02));

   ir_variable *const r0052 = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
   body.emit(assign(r0052, bit_and(swizzle_y(r004D), body.constant(1048575u)), 0x01));

   body.emit(assign(r0052, swizzle_x(r004D), 0x02));

   ir_expression *const r0053 = rshift(swizzle_y(r004C), body.constant(int(20)));
   ir_expression *const r0054 = bit_and(r0053, body.constant(2047u));
   ir_expression *const r0055 = expr(ir_unop_u2i, r0054);
   ir_expression *const r0056 = equal(r0055, body.constant(int(2047)));
   ir_expression *const r0057 = bit_or(swizzle_x(r004C), swizzle_x(r0051));
   ir_expression *const r0058 = nequal(r0057, body.constant(0u));
   body.emit(assign(r0050, logic_and(r0056, r0058), 0x01));

   ir_expression *const r0059 = rshift(swizzle_y(r004D), body.constant(int(20)));
   ir_expression *const r005A = bit_and(r0059, body.constant(2047u));
   ir_expression *const r005B = expr(ir_unop_u2i, r005A);
   ir_expression *const r005C = equal(r005B, body.constant(int(2047)));
   ir_expression *const r005D = bit_or(swizzle_x(r004D), swizzle_x(r0052));
   ir_expression *const r005E = nequal(r005D, body.constant(0u));
   body.emit(assign(r004F, logic_and(r005C, r005E), 0x01));

   /* IF CONDITION */
   ir_expression *const r0060 = logic_or(r0050, r004F);
   ir_if *f005F = new(mem_ctx) ir_if(operand(r0060).val);
   exec_list *const f005F_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f005F->then_instructions;

      body.emit(assign(r004E, body.constant(false), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f005F->else_instructions;

      ir_variable *const r0061 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r0061, rshift(swizzle_y(r004C), body.constant(int(31))), 0x01));

      ir_variable *const r0062 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r0062, rshift(swizzle_y(r004D), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r0064 = nequal(r0061, r0062);
      ir_if *f0063 = new(mem_ctx) ir_if(operand(r0064).val);
      exec_list *const f0063_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0063->then_instructions;

         ir_expression *const r0065 = nequal(r0061, body.constant(0u));
         ir_expression *const r0066 = bit_or(swizzle_y(r004C), swizzle_y(r004D));
         ir_expression *const r0067 = lshift(r0066, body.constant(int(1)));
         ir_expression *const r0068 = bit_or(r0067, swizzle_x(r004C));
         ir_expression *const r0069 = bit_or(r0068, swizzle_x(r004D));
         ir_expression *const r006A = equal(r0069, body.constant(0u));
         body.emit(assign(r004E, logic_or(r0065, r006A), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0063->else_instructions;

         ir_variable *const r006B = body.make_temp(glsl_type::bool_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r006D = nequal(r0061, body.constant(0u));
         ir_if *f006C = new(mem_ctx) ir_if(operand(r006D).val);
         exec_list *const f006C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f006C->then_instructions;

            ir_expression *const r006E = less(swizzle_y(r004D), swizzle_y(r004C));
            ir_expression *const r006F = equal(swizzle_y(r004D), swizzle_y(r004C));
            ir_expression *const r0070 = lequal(swizzle_x(r004D), swizzle_x(r004C));
            ir_expression *const r0071 = logic_and(r006F, r0070);
            body.emit(assign(r006B, logic_or(r006E, r0071), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f006C->else_instructions;

            ir_expression *const r0072 = less(swizzle_y(r004C), swizzle_y(r004D));
            ir_expression *const r0073 = equal(swizzle_y(r004C), swizzle_y(r004D));
            ir_expression *const r0074 = lequal(swizzle_x(r004C), swizzle_x(r004D));
            ir_expression *const r0075 = logic_and(r0073, r0074);
            body.emit(assign(r006B, logic_or(r0072, r0075), 0x01));


         body.instructions = f006C_parent_instructions;
         body.emit(f006C);

         /* END IF */

         body.emit(assign(r004E, r006B, 0x01));


      body.instructions = f0063_parent_instructions;
      body.emit(f0063);

      /* END IF */


   body.instructions = f005F_parent_instructions;
   body.emit(f005F);

   /* END IF */

   body.emit(ret(r004E));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
lt64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0076 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r0076);
   ir_variable *const r0077 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r0077);
   ir_variable *const r0078 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r0078);
   ir_variable *const r0079 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r0079);
   ir_expression *const r007A = less(r0076, r0078);
   ir_expression *const r007B = equal(r0076, r0078);
   ir_expression *const r007C = less(r0077, r0079);
   ir_expression *const r007D = logic_and(r007B, r007C);
   ir_expression *const r007E = logic_or(r007A, r007D);
   body.emit(ret(r007E));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
flt64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r007F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r007F);
   ir_variable *const r0080 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0080);
   ir_variable *const r0081 = body.make_temp(glsl_type::bool_type, "return_value");
   ir_variable *const r0082 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isbNaN", ir_var_auto);
   body.emit(r0082);
   ir_variable *const r0083 = new(mem_ctx) ir_variable(glsl_type::bool_type, "isaNaN", ir_var_auto);
   body.emit(r0083);
   ir_variable *const r0084 = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
   body.emit(assign(r0084, bit_and(swizzle_y(r007F), body.constant(1048575u)), 0x01));

   body.emit(assign(r0084, swizzle_x(r007F), 0x02));

   ir_variable *const r0085 = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
   body.emit(assign(r0085, bit_and(swizzle_y(r0080), body.constant(1048575u)), 0x01));

   body.emit(assign(r0085, swizzle_x(r0080), 0x02));

   ir_expression *const r0086 = rshift(swizzle_y(r007F), body.constant(int(20)));
   ir_expression *const r0087 = bit_and(r0086, body.constant(2047u));
   ir_expression *const r0088 = expr(ir_unop_u2i, r0087);
   ir_expression *const r0089 = equal(r0088, body.constant(int(2047)));
   ir_expression *const r008A = bit_or(swizzle_x(r007F), swizzle_x(r0084));
   ir_expression *const r008B = nequal(r008A, body.constant(0u));
   body.emit(assign(r0083, logic_and(r0089, r008B), 0x01));

   ir_expression *const r008C = rshift(swizzle_y(r0080), body.constant(int(20)));
   ir_expression *const r008D = bit_and(r008C, body.constant(2047u));
   ir_expression *const r008E = expr(ir_unop_u2i, r008D);
   ir_expression *const r008F = equal(r008E, body.constant(int(2047)));
   ir_expression *const r0090 = bit_or(swizzle_x(r0080), swizzle_x(r0085));
   ir_expression *const r0091 = nequal(r0090, body.constant(0u));
   body.emit(assign(r0082, logic_and(r008F, r0091), 0x01));

   /* IF CONDITION */
   ir_expression *const r0093 = logic_or(r0083, r0082);
   ir_if *f0092 = new(mem_ctx) ir_if(operand(r0093).val);
   exec_list *const f0092_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0092->then_instructions;

      body.emit(assign(r0081, body.constant(false), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0092->else_instructions;

      ir_variable *const r0094 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r0094, rshift(swizzle_y(r007F), body.constant(int(31))), 0x01));

      ir_variable *const r0095 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
      body.emit(assign(r0095, rshift(swizzle_y(r0080), body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r0097 = nequal(r0094, r0095);
      ir_if *f0096 = new(mem_ctx) ir_if(operand(r0097).val);
      exec_list *const f0096_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0096->then_instructions;

         ir_expression *const r0098 = nequal(r0094, body.constant(0u));
         ir_expression *const r0099 = bit_or(swizzle_y(r007F), swizzle_y(r0080));
         ir_expression *const r009A = lshift(r0099, body.constant(int(1)));
         ir_expression *const r009B = bit_or(r009A, swizzle_x(r007F));
         ir_expression *const r009C = bit_or(r009B, swizzle_x(r0080));
         ir_expression *const r009D = nequal(r009C, body.constant(0u));
         body.emit(assign(r0081, logic_and(r0098, r009D), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0096->else_instructions;

         ir_variable *const r009E = body.make_temp(glsl_type::bool_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r00A0 = nequal(r0094, body.constant(0u));
         ir_if *f009F = new(mem_ctx) ir_if(operand(r00A0).val);
         exec_list *const f009F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f009F->then_instructions;

            ir_expression *const r00A1 = less(swizzle_y(r0080), swizzle_y(r007F));
            ir_expression *const r00A2 = equal(swizzle_y(r0080), swizzle_y(r007F));
            ir_expression *const r00A3 = less(swizzle_x(r0080), swizzle_x(r007F));
            ir_expression *const r00A4 = logic_and(r00A2, r00A3);
            body.emit(assign(r009E, logic_or(r00A1, r00A4), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f009F->else_instructions;

            ir_expression *const r00A5 = less(swizzle_y(r007F), swizzle_y(r0080));
            ir_expression *const r00A6 = equal(swizzle_y(r007F), swizzle_y(r0080));
            ir_expression *const r00A7 = less(swizzle_x(r007F), swizzle_x(r0080));
            ir_expression *const r00A8 = logic_and(r00A6, r00A7);
            body.emit(assign(r009E, logic_or(r00A5, r00A8), 0x01));


         body.instructions = f009F_parent_instructions;
         body.emit(f009F);

         /* END IF */

         body.emit(assign(r0081, r009E, 0x01));


      body.instructions = f0096_parent_instructions;
      body.emit(f0096);

      /* END IF */


   body.instructions = f0092_parent_instructions;
   body.emit(f0092);

   /* END IF */

   body.emit(ret(r0081));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
add64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00A9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00A9);
   ir_variable *const r00AA = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00AA);
   ir_variable *const r00AB = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r00AB);
   ir_variable *const r00AC = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r00AC);
   ir_variable *const r00AD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00AD);
   ir_variable *const r00AE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00AE);
   ir_variable *const r00AF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r00AF, add(r00AA, r00AC), 0x01));

   body.emit(assign(r00AE, r00AF, 0x01));

   ir_expression *const r00B0 = add(r00A9, r00AB);
   ir_expression *const r00B1 = less(r00AF, r00AA);
   ir_expression *const r00B2 = expr(ir_unop_b2i, r00B1);
   ir_expression *const r00B3 = expr(ir_unop_i2u, r00B2);
   body.emit(assign(r00AD, add(r00B0, r00B3), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
sub64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00B4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00B4);
   ir_variable *const r00B5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00B5);
   ir_variable *const r00B6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r00B6);
   ir_variable *const r00B7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r00B7);
   ir_variable *const r00B8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00B8);
   ir_variable *const r00B9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00B9);
   body.emit(assign(r00B9, sub(r00B5, r00B7), 0x01));

   ir_expression *const r00BA = sub(r00B4, r00B6);
   ir_expression *const r00BB = less(r00B5, r00B7);
   ir_expression *const r00BC = expr(ir_unop_b2i, r00BB);
   ir_expression *const r00BD = expr(ir_unop_i2u, r00BC);
   body.emit(assign(r00B8, sub(r00BA, r00BD), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
eq64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00BE = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00BE);
   ir_variable *const r00BF = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00BF);
   ir_variable *const r00C0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r00C0);
   ir_variable *const r00C1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r00C1);
   ir_expression *const r00C2 = equal(r00BE, r00C0);
   ir_expression *const r00C3 = equal(r00BF, r00C1);
   ir_expression *const r00C4 = logic_and(r00C2, r00C3);
   body.emit(ret(r00C4));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
float64_is_signaling_nan(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::bool_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00C5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r00C5);
   ir_expression *const r00C6 = rshift(swizzle_x(r00C5), body.constant(int(19)));
   ir_expression *const r00C7 = bit_and(r00C6, body.constant(4095u));
   ir_expression *const r00C8 = equal(r00C7, body.constant(4094u));
   ir_expression *const r00C9 = nequal(swizzle_y(r00C5), body.constant(0u));
   ir_expression *const r00CA = bit_and(swizzle_x(r00C5), body.constant(524287u));
   ir_expression *const r00CB = nequal(r00CA, body.constant(0u));
   ir_expression *const r00CC = logic_or(r00C9, r00CB);
   ir_expression *const r00CD = logic_and(r00C8, r00CC);
   body.emit(ret(r00CD));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift64RightJamming(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00CE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r00CE);
   ir_variable *const r00CF = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r00CF);
   ir_variable *const r00D0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00D0);
   ir_variable *const r00D1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00D1);
   ir_variable *const r00D2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r00D2);
   ir_variable *const r00D3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r00D3);
   ir_variable *const r00D4 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r00D5 = neg(r00CF);
   body.emit(assign(r00D4, bit_and(r00D5, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r00D7 = equal(r00CF, body.constant(int(0)));
   ir_if *f00D6 = new(mem_ctx) ir_if(operand(r00D7).val);
   exec_list *const f00D6_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f00D6->then_instructions;

      body.emit(assign(r00D2, swizzle_x(r00CE), 0x01));

      body.emit(assign(r00D3, swizzle_y(r00CE), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f00D6->else_instructions;

      /* IF CONDITION */
      ir_expression *const r00D9 = less(r00CF, body.constant(int(32)));
      ir_if *f00D8 = new(mem_ctx) ir_if(operand(r00D9).val);
      exec_list *const f00D8_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f00D8->then_instructions;

         ir_expression *const r00DA = lshift(swizzle_y(r00CE), r00D4);
         ir_expression *const r00DB = rshift(swizzle_x(r00CE), r00CF);
         ir_expression *const r00DC = bit_or(r00DA, r00DB);
         ir_expression *const r00DD = lshift(swizzle_x(r00CE), r00D4);
         ir_expression *const r00DE = nequal(r00DD, body.constant(0u));
         ir_expression *const r00DF = expr(ir_unop_b2i, r00DE);
         ir_expression *const r00E0 = expr(ir_unop_i2u, r00DF);
         body.emit(assign(r00D2, bit_or(r00DC, r00E0), 0x01));

         body.emit(assign(r00D3, rshift(swizzle_y(r00CE), r00CF), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f00D8->else_instructions;

         /* IF CONDITION */
         ir_expression *const r00E2 = equal(r00CF, body.constant(int(32)));
         ir_if *f00E1 = new(mem_ctx) ir_if(operand(r00E2).val);
         exec_list *const f00E1_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f00E1->then_instructions;

            ir_expression *const r00E3 = nequal(swizzle_x(r00CE), body.constant(0u));
            ir_expression *const r00E4 = expr(ir_unop_b2i, r00E3);
            ir_expression *const r00E5 = expr(ir_unop_i2u, r00E4);
            body.emit(assign(r00D2, bit_or(swizzle_y(r00CE), r00E5), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f00E1->else_instructions;

            /* IF CONDITION */
            ir_expression *const r00E7 = less(r00CF, body.constant(int(64)));
            ir_if *f00E6 = new(mem_ctx) ir_if(operand(r00E7).val);
            exec_list *const f00E6_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f00E6->then_instructions;

               ir_expression *const r00E8 = bit_and(r00CF, body.constant(int(31)));
               ir_expression *const r00E9 = rshift(swizzle_y(r00CE), r00E8);
               ir_expression *const r00EA = lshift(swizzle_y(r00CE), r00D4);
               ir_expression *const r00EB = bit_or(r00EA, swizzle_x(r00CE));
               ir_expression *const r00EC = nequal(r00EB, body.constant(0u));
               ir_expression *const r00ED = expr(ir_unop_b2i, r00EC);
               ir_expression *const r00EE = expr(ir_unop_i2u, r00ED);
               body.emit(assign(r00D2, bit_or(r00E9, r00EE), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f00E6->else_instructions;

               ir_expression *const r00EF = bit_or(swizzle_y(r00CE), swizzle_x(r00CE));
               ir_expression *const r00F0 = nequal(r00EF, body.constant(0u));
               ir_expression *const r00F1 = expr(ir_unop_b2i, r00F0);
               body.emit(assign(r00D2, expr(ir_unop_i2u, r00F1), 0x01));


            body.instructions = f00E6_parent_instructions;
            body.emit(f00E6);

            /* END IF */


         body.instructions = f00E1_parent_instructions;
         body.emit(f00E1);

         /* END IF */

         body.emit(assign(r00D3, body.constant(0u), 0x01));


      body.instructions = f00D8_parent_instructions;
      body.emit(f00D8);

      /* END IF */


   body.instructions = f00D6_parent_instructions;
   body.emit(f00D6);

   /* END IF */

   body.emit(assign(r00D1, r00D2, 0x01));

   body.emit(assign(r00D0, r00D3, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift64ExtraRightJamming(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r00F2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r00F2);
   ir_variable *const r00F3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r00F3);
   ir_variable *const r00F4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a2", ir_var_function_in);
   sig_parameters.push_tail(r00F4);
   ir_variable *const r00F5 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r00F5);
   ir_variable *const r00F6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00F6);
   ir_variable *const r00F7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00F7);
   ir_variable *const r00F8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r00F8);
   ir_variable *const r00F9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
   body.emit(r00F9);
   ir_variable *const r00FA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r00FA);
   ir_variable *const r00FB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r00FB);
   ir_variable *const r00FC = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r00FD = neg(r00F5);
   body.emit(assign(r00FC, bit_and(r00FD, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r00FF = equal(r00F5, body.constant(int(0)));
   ir_if *f00FE = new(mem_ctx) ir_if(operand(r00FF).val);
   exec_list *const f00FE_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f00FE->then_instructions;

      body.emit(assign(r00F9, r00F4, 0x01));

      body.emit(assign(r00FA, r00F3, 0x01));

      body.emit(assign(r00FB, r00F2, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f00FE->else_instructions;

      /* IF CONDITION */
      ir_expression *const r0101 = less(r00F5, body.constant(int(32)));
      ir_if *f0100 = new(mem_ctx) ir_if(operand(r0101).val);
      exec_list *const f0100_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0100->then_instructions;

         body.emit(assign(r00F9, lshift(r00F3, r00FC), 0x01));

         ir_expression *const r0102 = lshift(r00F2, r00FC);
         ir_expression *const r0103 = rshift(r00F3, r00F5);
         body.emit(assign(r00FA, bit_or(r0102, r0103), 0x01));

         body.emit(assign(r00FB, rshift(r00F2, r00F5), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0100->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0105 = equal(r00F5, body.constant(int(32)));
         ir_if *f0104 = new(mem_ctx) ir_if(operand(r0105).val);
         exec_list *const f0104_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0104->then_instructions;

            body.emit(assign(r00F9, r00F3, 0x01));

            body.emit(assign(r00FA, r00F2, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0104->else_instructions;

            body.emit(assign(r00F4, bit_or(r00F4, r00F3), 0x01));

            /* IF CONDITION */
            ir_expression *const r0107 = less(r00F5, body.constant(int(64)));
            ir_if *f0106 = new(mem_ctx) ir_if(operand(r0107).val);
            exec_list *const f0106_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0106->then_instructions;

               body.emit(assign(r00F9, lshift(r00F2, r00FC), 0x01));

               ir_expression *const r0108 = bit_and(r00F5, body.constant(int(31)));
               body.emit(assign(r00FA, rshift(r00F2, r0108), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0106->else_instructions;

               ir_variable *const r0109 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r010B = equal(r00F5, body.constant(int(64)));
               ir_if *f010A = new(mem_ctx) ir_if(operand(r010B).val);
               exec_list *const f010A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f010A->then_instructions;

                  body.emit(assign(r0109, r00F2, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f010A->else_instructions;

                  ir_expression *const r010C = nequal(r00F2, body.constant(0u));
                  ir_expression *const r010D = expr(ir_unop_b2i, r010C);
                  body.emit(assign(r0109, expr(ir_unop_i2u, r010D), 0x01));


               body.instructions = f010A_parent_instructions;
               body.emit(f010A);

               /* END IF */

               body.emit(assign(r00F9, r0109, 0x01));

               body.emit(assign(r00FA, body.constant(0u), 0x01));


            body.instructions = f0106_parent_instructions;
            body.emit(f0106);

            /* END IF */


         body.instructions = f0104_parent_instructions;
         body.emit(f0104);

         /* END IF */

         body.emit(assign(r00FB, body.constant(0u), 0x01));


      body.instructions = f0100_parent_instructions;
      body.emit(f0100);

      /* END IF */

      ir_expression *const r010E = nequal(r00F4, body.constant(0u));
      ir_expression *const r010F = expr(ir_unop_b2i, r010E);
      ir_expression *const r0110 = expr(ir_unop_i2u, r010F);
      body.emit(assign(r00F9, bit_or(r00F9, r0110), 0x01));


   body.instructions = f00FE_parent_instructions;
   body.emit(f00FE);

   /* END IF */

   body.emit(assign(r00F8, r00F9, 0x01));

   body.emit(assign(r00F7, r00FA, 0x01));

   body.emit(assign(r00F6, r00FB, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shortShift64Left(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0111 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r0111);
   ir_variable *const r0112 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r0112);
   ir_variable *const r0113 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r0113);
   ir_variable *const r0114 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0114);
   ir_variable *const r0115 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0115);
   body.emit(assign(r0115, lshift(r0112, r0113), 0x01));

   ir_variable *const r0116 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
   /* IF CONDITION */
   ir_expression *const r0118 = equal(r0113, body.constant(int(0)));
   ir_if *f0117 = new(mem_ctx) ir_if(operand(r0118).val);
   exec_list *const f0117_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0117->then_instructions;

      body.emit(assign(r0116, r0111, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0117->else_instructions;

      ir_expression *const r0119 = lshift(r0111, r0113);
      ir_expression *const r011A = neg(r0113);
      ir_expression *const r011B = bit_and(r011A, body.constant(int(31)));
      ir_expression *const r011C = rshift(r0112, r011B);
      body.emit(assign(r0116, bit_or(r0119, r011C), 0x01));


   body.instructions = f0117_parent_instructions;
   body.emit(f0117);

   /* END IF */

   body.emit(assign(r0114, r0116, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
packFloat64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r011D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r011D);
   ir_variable *const r011E = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r011E);
   ir_variable *const r011F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_function_in);
   sig_parameters.push_tail(r011F);
   ir_variable *const r0120 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_function_in);
   sig_parameters.push_tail(r0120);
   ir_variable *const r0121 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
   body.emit(r0121);
   ir_expression *const r0122 = lshift(r011D, body.constant(int(31)));
   ir_expression *const r0123 = expr(ir_unop_i2u, r011E);
   ir_expression *const r0124 = lshift(r0123, body.constant(int(20)));
   ir_expression *const r0125 = add(r0122, r0124);
   body.emit(assign(r0121, add(r0125, r011F), 0x02));

   body.emit(assign(r0121, r0120, 0x01));

   body.emit(ret(r0121));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
roundAndPackFloat64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0126 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r0126);
   ir_variable *const r0127 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r0127);
   ir_variable *const r0128 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_function_in);
   sig_parameters.push_tail(r0128);
   ir_variable *const r0129 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_function_in);
   sig_parameters.push_tail(r0129);
   ir_variable *const r012A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_function_in);
   sig_parameters.push_tail(r012A);
   ir_variable *const r012B = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r012B, body.constant(true), 0x01));

   ir_variable *const r012C = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r012D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
   body.emit(r012D);
   ir_expression *const r012E = expr(ir_unop_u2i, r012A);
   body.emit(assign(r012D, less(r012E, body.constant(int(0))), 0x01));

   /* IF CONDITION */
   ir_expression *const r0130 = lequal(body.constant(int(2045)), r0127);
   ir_if *f012F = new(mem_ctx) ir_if(operand(r0130).val);
   exec_list *const f012F_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f012F->then_instructions;

      ir_variable *const r0131 = body.make_temp(glsl_type::bool_type, "or_tmp");
      /* IF CONDITION */
      ir_expression *const r0133 = less(body.constant(int(2045)), r0127);
      ir_if *f0132 = new(mem_ctx) ir_if(operand(r0133).val);
      exec_list *const f0132_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0132->then_instructions;

         body.emit(assign(r0131, body.constant(true), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0132->else_instructions;

         ir_variable *const r0134 = body.make_temp(glsl_type::bool_type, "and_tmp");
         /* IF CONDITION */
         ir_expression *const r0136 = equal(r0127, body.constant(int(2045)));
         ir_if *f0135 = new(mem_ctx) ir_if(operand(r0136).val);
         exec_list *const f0135_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0135->then_instructions;

            ir_expression *const r0137 = equal(body.constant(2097151u), r0128);
            ir_expression *const r0138 = equal(body.constant(4294967295u), r0129);
            body.emit(assign(r0134, logic_and(r0137, r0138), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0135->else_instructions;

            body.emit(assign(r0134, body.constant(false), 0x01));


         body.instructions = f0135_parent_instructions;
         body.emit(f0135);

         /* END IF */

         body.emit(assign(r0131, logic_and(r0134, r012D), 0x01));


      body.instructions = f0132_parent_instructions;
      body.emit(f0132);

      /* END IF */

      /* IF CONDITION */
      ir_if *f0139 = new(mem_ctx) ir_if(operand(r0131).val);
      exec_list *const f0139_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0139->then_instructions;

         ir_variable *const r013A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r013A);
         ir_expression *const r013B = lshift(r0126, body.constant(int(31)));
         body.emit(assign(r013A, add(r013B, body.constant(2146435072u)), 0x02));

         body.emit(assign(r013A, body.constant(0u), 0x01));

         body.emit(assign(r012C, r013A, 0x03));

         body.emit(assign(r012B, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0139->else_instructions;

         /* IF CONDITION */
         ir_expression *const r013D = less(r0127, body.constant(int(0)));
         ir_if *f013C = new(mem_ctx) ir_if(operand(r013D).val);
         exec_list *const f013C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f013C->then_instructions;

            ir_variable *const r013E = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r013E, r012A, 0x01));

            ir_variable *const r013F = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r013F, neg(r0127), 0x01));

            ir_variable *const r0140 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r0140);
            ir_variable *const r0141 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r0141);
            ir_variable *const r0142 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r0142);
            ir_variable *const r0143 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r0144 = neg(r013F);
            body.emit(assign(r0143, bit_and(r0144, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0146 = equal(r013F, body.constant(int(0)));
            ir_if *f0145 = new(mem_ctx) ir_if(operand(r0146).val);
            exec_list *const f0145_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0145->then_instructions;

               body.emit(assign(r0140, r012A, 0x01));

               body.emit(assign(r0141, r0129, 0x01));

               body.emit(assign(r0142, r0128, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0145->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0148 = less(r013F, body.constant(int(32)));
               ir_if *f0147 = new(mem_ctx) ir_if(operand(r0148).val);
               exec_list *const f0147_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0147->then_instructions;

                  body.emit(assign(r0140, lshift(r0129, r0143), 0x01));

                  ir_expression *const r0149 = lshift(r0128, r0143);
                  ir_expression *const r014A = rshift(r0129, r013F);
                  body.emit(assign(r0141, bit_or(r0149, r014A), 0x01));

                  body.emit(assign(r0142, rshift(r0128, r013F), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0147->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r014C = equal(r013F, body.constant(int(32)));
                  ir_if *f014B = new(mem_ctx) ir_if(operand(r014C).val);
                  exec_list *const f014B_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f014B->then_instructions;

                     body.emit(assign(r0140, r0129, 0x01));

                     body.emit(assign(r0141, r0128, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f014B->else_instructions;

                     body.emit(assign(r013E, bit_or(r012A, r0129), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r014E = less(r013F, body.constant(int(64)));
                     ir_if *f014D = new(mem_ctx) ir_if(operand(r014E).val);
                     exec_list *const f014D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f014D->then_instructions;

                        body.emit(assign(r0140, lshift(r0128, r0143), 0x01));

                        ir_expression *const r014F = bit_and(r013F, body.constant(int(31)));
                        body.emit(assign(r0141, rshift(r0128, r014F), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f014D->else_instructions;

                        ir_variable *const r0150 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0152 = equal(r013F, body.constant(int(64)));
                        ir_if *f0151 = new(mem_ctx) ir_if(operand(r0152).val);
                        exec_list *const f0151_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0151->then_instructions;

                           body.emit(assign(r0150, r0128, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0151->else_instructions;

                           ir_expression *const r0153 = nequal(r0128, body.constant(0u));
                           ir_expression *const r0154 = expr(ir_unop_b2i, r0153);
                           body.emit(assign(r0150, expr(ir_unop_i2u, r0154), 0x01));


                        body.instructions = f0151_parent_instructions;
                        body.emit(f0151);

                        /* END IF */

                        body.emit(assign(r0140, r0150, 0x01));

                        body.emit(assign(r0141, body.constant(0u), 0x01));


                     body.instructions = f014D_parent_instructions;
                     body.emit(f014D);

                     /* END IF */


                  body.instructions = f014B_parent_instructions;
                  body.emit(f014B);

                  /* END IF */

                  body.emit(assign(r0142, body.constant(0u), 0x01));


               body.instructions = f0147_parent_instructions;
               body.emit(f0147);

               /* END IF */

               ir_expression *const r0155 = nequal(r013E, body.constant(0u));
               ir_expression *const r0156 = expr(ir_unop_b2i, r0155);
               ir_expression *const r0157 = expr(ir_unop_i2u, r0156);
               body.emit(assign(r0140, bit_or(r0140, r0157), 0x01));


            body.instructions = f0145_parent_instructions;
            body.emit(f0145);

            /* END IF */

            body.emit(assign(r0128, r0142, 0x01));

            body.emit(assign(r0129, r0141, 0x01));

            body.emit(assign(r012A, r0140, 0x01));

            body.emit(assign(r0127, body.constant(int(0)), 0x01));

            body.emit(assign(r012D, less(r0140, body.constant(0u)), 0x01));


         body.instructions = f013C_parent_instructions;
         body.emit(f013C);

         /* END IF */


      body.instructions = f0139_parent_instructions;
      body.emit(f0139);

      /* END IF */


   body.instructions = f012F_parent_instructions;
   body.emit(f012F);

   /* END IF */

   /* IF CONDITION */
   ir_if *f0158 = new(mem_ctx) ir_if(operand(r012B).val);
   exec_list *const f0158_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0158->then_instructions;

      /* IF CONDITION */
      ir_if *f0159 = new(mem_ctx) ir_if(operand(r012D).val);
      exec_list *const f0159_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0159->then_instructions;

         ir_variable *const r015A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r015A, add(r0129, body.constant(1u)), 0x01));

         ir_expression *const r015B = less(r015A, r0129);
         ir_expression *const r015C = expr(ir_unop_b2i, r015B);
         ir_expression *const r015D = expr(ir_unop_i2u, r015C);
         body.emit(assign(r0128, add(r0128, r015D), 0x01));

         ir_expression *const r015E = equal(r012A, body.constant(0u));
         ir_expression *const r015F = expr(ir_unop_b2i, r015E);
         ir_expression *const r0160 = expr(ir_unop_i2u, r015F);
         ir_expression *const r0161 = add(r012A, r0160);
         ir_expression *const r0162 = bit_and(r0161, body.constant(1u));
         ir_expression *const r0163 = expr(ir_unop_bit_not, r0162);
         body.emit(assign(r0129, bit_and(r015A, r0163), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0159->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0165 = bit_or(r0128, r0129);
         ir_expression *const r0166 = equal(r0165, body.constant(0u));
         ir_if *f0164 = new(mem_ctx) ir_if(operand(r0166).val);
         exec_list *const f0164_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0164->then_instructions;

            body.emit(assign(r0127, body.constant(int(0)), 0x01));


         body.instructions = f0164_parent_instructions;
         body.emit(f0164);

         /* END IF */


      body.instructions = f0159_parent_instructions;
      body.emit(f0159);

      /* END IF */

      ir_variable *const r0167 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r0167);
      ir_expression *const r0168 = lshift(r0126, body.constant(int(31)));
      ir_expression *const r0169 = expr(ir_unop_i2u, r0127);
      ir_expression *const r016A = lshift(r0169, body.constant(int(20)));
      ir_expression *const r016B = add(r0168, r016A);
      body.emit(assign(r0167, add(r016B, r0128), 0x02));

      body.emit(assign(r0167, r0129, 0x01));

      body.emit(assign(r012C, r0167, 0x03));

      body.emit(assign(r012B, body.constant(false), 0x01));


   body.instructions = f0158_parent_instructions;
   body.emit(f0158);

   /* END IF */

   body.emit(ret(r012C));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
countLeadingZeros32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::int_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r016C = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r016C);
   ir_variable *const r016D = body.make_temp(glsl_type::int_type, "return_value");
   ir_variable *const r016E = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r016E);
   /* IF CONDITION */
   ir_expression *const r0170 = equal(r016C, body.constant(0u));
   ir_if *f016F = new(mem_ctx) ir_if(operand(r0170).val);
   exec_list *const f016F_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f016F->then_instructions;

      body.emit(assign(r016D, body.constant(int(32)), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f016F->else_instructions;

      body.emit(assign(r016E, body.constant(int(0)), 0x01));

      /* IF CONDITION */
      ir_expression *const r0172 = bit_and(r016C, body.constant(4294901760u));
      ir_expression *const r0173 = equal(r0172, body.constant(0u));
      ir_if *f0171 = new(mem_ctx) ir_if(operand(r0173).val);
      exec_list *const f0171_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0171->then_instructions;

         body.emit(assign(r016E, body.constant(int(16)), 0x01));

         body.emit(assign(r016C, lshift(r016C, body.constant(int(16))), 0x01));


      body.instructions = f0171_parent_instructions;
      body.emit(f0171);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0175 = bit_and(r016C, body.constant(4278190080u));
      ir_expression *const r0176 = equal(r0175, body.constant(0u));
      ir_if *f0174 = new(mem_ctx) ir_if(operand(r0176).val);
      exec_list *const f0174_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0174->then_instructions;

         body.emit(assign(r016E, add(r016E, body.constant(int(8))), 0x01));

         body.emit(assign(r016C, lshift(r016C, body.constant(int(8))), 0x01));


      body.instructions = f0174_parent_instructions;
      body.emit(f0174);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0178 = bit_and(r016C, body.constant(4026531840u));
      ir_expression *const r0179 = equal(r0178, body.constant(0u));
      ir_if *f0177 = new(mem_ctx) ir_if(operand(r0179).val);
      exec_list *const f0177_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0177->then_instructions;

         body.emit(assign(r016E, add(r016E, body.constant(int(4))), 0x01));

         body.emit(assign(r016C, lshift(r016C, body.constant(int(4))), 0x01));


      body.instructions = f0177_parent_instructions;
      body.emit(f0177);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r017B = bit_and(r016C, body.constant(3221225472u));
      ir_expression *const r017C = equal(r017B, body.constant(0u));
      ir_if *f017A = new(mem_ctx) ir_if(operand(r017C).val);
      exec_list *const f017A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f017A->then_instructions;

         body.emit(assign(r016E, add(r016E, body.constant(int(2))), 0x01));

         body.emit(assign(r016C, lshift(r016C, body.constant(int(2))), 0x01));


      body.instructions = f017A_parent_instructions;
      body.emit(f017A);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r017E = bit_and(r016C, body.constant(2147483648u));
      ir_expression *const r017F = equal(r017E, body.constant(0u));
      ir_if *f017D = new(mem_ctx) ir_if(operand(r017F).val);
      exec_list *const f017D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f017D->then_instructions;

         body.emit(assign(r016E, add(r016E, body.constant(int(1))), 0x01));


      body.instructions = f017D_parent_instructions;
      body.emit(f017D);

      /* END IF */

      body.emit(assign(r016D, r016E, 0x01));


   body.instructions = f016F_parent_instructions;
   body.emit(f016F);

   /* END IF */

   body.emit(ret(r016D));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
normalizeRoundAndPackFloat64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0180 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r0180);
   ir_variable *const r0181 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r0181);
   ir_variable *const r0182 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_function_in);
   sig_parameters.push_tail(r0182);
   ir_variable *const r0183 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_function_in);
   sig_parameters.push_tail(r0183);
   ir_variable *const r0184 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
   body.emit(r0184);
   ir_variable *const r0185 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r0185);
   /* IF CONDITION */
   ir_expression *const r0187 = equal(r0182, body.constant(0u));
   ir_if *f0186 = new(mem_ctx) ir_if(operand(r0187).val);
   exec_list *const f0186_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0186->then_instructions;

      body.emit(assign(r0182, r0183, 0x01));

      body.emit(assign(r0183, body.constant(0u), 0x01));

      body.emit(assign(r0181, add(r0181, body.constant(int(-32))), 0x01));


   body.instructions = f0186_parent_instructions;
   body.emit(f0186);

   /* END IF */

   ir_variable *const r0188 = body.make_temp(glsl_type::uint_type, "a");
   body.emit(assign(r0188, r0182, 0x01));

   ir_variable *const r0189 = body.make_temp(glsl_type::int_type, "return_value");
   ir_variable *const r018A = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r018A);
   /* IF CONDITION */
   ir_expression *const r018C = equal(r0182, body.constant(0u));
   ir_if *f018B = new(mem_ctx) ir_if(operand(r018C).val);
   exec_list *const f018B_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f018B->then_instructions;

      body.emit(assign(r0189, body.constant(int(32)), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f018B->else_instructions;

      body.emit(assign(r018A, body.constant(int(0)), 0x01));

      /* IF CONDITION */
      ir_expression *const r018E = bit_and(r0182, body.constant(4294901760u));
      ir_expression *const r018F = equal(r018E, body.constant(0u));
      ir_if *f018D = new(mem_ctx) ir_if(operand(r018F).val);
      exec_list *const f018D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f018D->then_instructions;

         body.emit(assign(r018A, body.constant(int(16)), 0x01));

         body.emit(assign(r0188, lshift(r0182, body.constant(int(16))), 0x01));


      body.instructions = f018D_parent_instructions;
      body.emit(f018D);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0191 = bit_and(r0188, body.constant(4278190080u));
      ir_expression *const r0192 = equal(r0191, body.constant(0u));
      ir_if *f0190 = new(mem_ctx) ir_if(operand(r0192).val);
      exec_list *const f0190_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0190->then_instructions;

         body.emit(assign(r018A, add(r018A, body.constant(int(8))), 0x01));

         body.emit(assign(r0188, lshift(r0188, body.constant(int(8))), 0x01));


      body.instructions = f0190_parent_instructions;
      body.emit(f0190);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0194 = bit_and(r0188, body.constant(4026531840u));
      ir_expression *const r0195 = equal(r0194, body.constant(0u));
      ir_if *f0193 = new(mem_ctx) ir_if(operand(r0195).val);
      exec_list *const f0193_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0193->then_instructions;

         body.emit(assign(r018A, add(r018A, body.constant(int(4))), 0x01));

         body.emit(assign(r0188, lshift(r0188, body.constant(int(4))), 0x01));


      body.instructions = f0193_parent_instructions;
      body.emit(f0193);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r0197 = bit_and(r0188, body.constant(3221225472u));
      ir_expression *const r0198 = equal(r0197, body.constant(0u));
      ir_if *f0196 = new(mem_ctx) ir_if(operand(r0198).val);
      exec_list *const f0196_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0196->then_instructions;

         body.emit(assign(r018A, add(r018A, body.constant(int(2))), 0x01));

         body.emit(assign(r0188, lshift(r0188, body.constant(int(2))), 0x01));


      body.instructions = f0196_parent_instructions;
      body.emit(f0196);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r019A = bit_and(r0188, body.constant(2147483648u));
      ir_expression *const r019B = equal(r019A, body.constant(0u));
      ir_if *f0199 = new(mem_ctx) ir_if(operand(r019B).val);
      exec_list *const f0199_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0199->then_instructions;

         body.emit(assign(r018A, add(r018A, body.constant(int(1))), 0x01));


      body.instructions = f0199_parent_instructions;
      body.emit(f0199);

      /* END IF */

      body.emit(assign(r0189, r018A, 0x01));


   body.instructions = f018B_parent_instructions;
   body.emit(f018B);

   /* END IF */

   body.emit(assign(r0185, add(r0189, body.constant(int(-11))), 0x01));

   /* IF CONDITION */
   ir_expression *const r019D = lequal(body.constant(int(0)), r0185);
   ir_if *f019C = new(mem_ctx) ir_if(operand(r019D).val);
   exec_list *const f019C_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f019C->then_instructions;

      body.emit(assign(r0184, body.constant(0u), 0x01));

      ir_variable *const r019E = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r019E, lshift(r0183, r0185), 0x01));

      ir_variable *const r019F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r01A1 = equal(r0185, body.constant(int(0)));
      ir_if *f01A0 = new(mem_ctx) ir_if(operand(r01A1).val);
      exec_list *const f01A0_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01A0->then_instructions;

         body.emit(assign(r019F, r0182, 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01A0->else_instructions;

         ir_expression *const r01A2 = lshift(r0182, r0185);
         ir_expression *const r01A3 = neg(r0185);
         ir_expression *const r01A4 = bit_and(r01A3, body.constant(int(31)));
         ir_expression *const r01A5 = rshift(r0183, r01A4);
         body.emit(assign(r019F, bit_or(r01A2, r01A5), 0x01));


      body.instructions = f01A0_parent_instructions;
      body.emit(f01A0);

      /* END IF */

      body.emit(assign(r0182, r019F, 0x01));

      body.emit(assign(r0183, r019E, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f019C->else_instructions;

      ir_variable *const r01A6 = body.make_temp(glsl_type::uint_type, "a2");
      body.emit(assign(r01A6, body.constant(0u), 0x01));

      ir_variable *const r01A7 = body.make_temp(glsl_type::int_type, "count");
      body.emit(assign(r01A7, neg(r0185), 0x01));

      ir_variable *const r01A8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
      body.emit(r01A8);
      ir_variable *const r01A9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r01A9);
      ir_variable *const r01AA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r01AA);
      ir_variable *const r01AB = body.make_temp(glsl_type::int_type, "assignment_tmp");
      ir_expression *const r01AC = neg(r01A7);
      body.emit(assign(r01AB, bit_and(r01AC, body.constant(int(31))), 0x01));

      /* IF CONDITION */
      ir_expression *const r01AE = equal(r01A7, body.constant(int(0)));
      ir_if *f01AD = new(mem_ctx) ir_if(operand(r01AE).val);
      exec_list *const f01AD_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01AD->then_instructions;

         body.emit(assign(r01A8, r01A6, 0x01));

         body.emit(assign(r01A9, r0183, 0x01));

         body.emit(assign(r01AA, r0182, 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01AD->else_instructions;

         /* IF CONDITION */
         ir_expression *const r01B0 = less(r01A7, body.constant(int(32)));
         ir_if *f01AF = new(mem_ctx) ir_if(operand(r01B0).val);
         exec_list *const f01AF_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f01AF->then_instructions;

            body.emit(assign(r01A8, lshift(r0183, r01AB), 0x01));

            ir_expression *const r01B1 = lshift(r0182, r01AB);
            ir_expression *const r01B2 = rshift(r0183, r01A7);
            body.emit(assign(r01A9, bit_or(r01B1, r01B2), 0x01));

            body.emit(assign(r01AA, rshift(r0182, r01A7), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f01AF->else_instructions;

            /* IF CONDITION */
            ir_expression *const r01B4 = equal(r01A7, body.constant(int(32)));
            ir_if *f01B3 = new(mem_ctx) ir_if(operand(r01B4).val);
            exec_list *const f01B3_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f01B3->then_instructions;

               body.emit(assign(r01A8, r0183, 0x01));

               body.emit(assign(r01A9, r0182, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f01B3->else_instructions;

               body.emit(assign(r01A6, bit_or(body.constant(0u), r0183), 0x01));

               /* IF CONDITION */
               ir_expression *const r01B6 = less(r01A7, body.constant(int(64)));
               ir_if *f01B5 = new(mem_ctx) ir_if(operand(r01B6).val);
               exec_list *const f01B5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f01B5->then_instructions;

                  body.emit(assign(r01A8, lshift(r0182, r01AB), 0x01));

                  ir_expression *const r01B7 = bit_and(r01A7, body.constant(int(31)));
                  body.emit(assign(r01A9, rshift(r0182, r01B7), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f01B5->else_instructions;

                  ir_variable *const r01B8 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r01BA = equal(r01A7, body.constant(int(64)));
                  ir_if *f01B9 = new(mem_ctx) ir_if(operand(r01BA).val);
                  exec_list *const f01B9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f01B9->then_instructions;

                     body.emit(assign(r01B8, r0182, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f01B9->else_instructions;

                     ir_expression *const r01BB = nequal(r0182, body.constant(0u));
                     ir_expression *const r01BC = expr(ir_unop_b2i, r01BB);
                     body.emit(assign(r01B8, expr(ir_unop_i2u, r01BC), 0x01));


                  body.instructions = f01B9_parent_instructions;
                  body.emit(f01B9);

                  /* END IF */

                  body.emit(assign(r01A8, r01B8, 0x01));

                  body.emit(assign(r01A9, body.constant(0u), 0x01));


               body.instructions = f01B5_parent_instructions;
               body.emit(f01B5);

               /* END IF */


            body.instructions = f01B3_parent_instructions;
            body.emit(f01B3);

            /* END IF */

            body.emit(assign(r01AA, body.constant(0u), 0x01));


         body.instructions = f01AF_parent_instructions;
         body.emit(f01AF);

         /* END IF */

         ir_expression *const r01BD = nequal(r01A6, body.constant(0u));
         ir_expression *const r01BE = expr(ir_unop_b2i, r01BD);
         ir_expression *const r01BF = expr(ir_unop_i2u, r01BE);
         body.emit(assign(r01A8, bit_or(r01A8, r01BF), 0x01));


      body.instructions = f01AD_parent_instructions;
      body.emit(f01AD);

      /* END IF */

      body.emit(assign(r0182, r01AA, 0x01));

      body.emit(assign(r0183, r01A9, 0x01));

      body.emit(assign(r0184, r01A8, 0x01));


   body.instructions = f019C_parent_instructions;
   body.emit(f019C);

   /* END IF */

   body.emit(assign(r0181, sub(r0181, r0185), 0x01));

   ir_variable *const r01C0 = body.make_temp(glsl_type::int_type, "zExp");
   body.emit(assign(r01C0, r0181, 0x01));

   ir_variable *const r01C1 = body.make_temp(glsl_type::uint_type, "zFrac0");
   body.emit(assign(r01C1, r0182, 0x01));

   ir_variable *const r01C2 = body.make_temp(glsl_type::uint_type, "zFrac1");
   body.emit(assign(r01C2, r0183, 0x01));

   ir_variable *const r01C3 = body.make_temp(glsl_type::uint_type, "zFrac2");
   body.emit(assign(r01C3, r0184, 0x01));

   ir_variable *const r01C4 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r01C4, body.constant(true), 0x01));

   ir_variable *const r01C5 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r01C6 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
   body.emit(r01C6);
   ir_expression *const r01C7 = expr(ir_unop_u2i, r0184);
   body.emit(assign(r01C6, less(r01C7, body.constant(int(0))), 0x01));

   /* IF CONDITION */
   ir_expression *const r01C9 = lequal(body.constant(int(2045)), r0181);
   ir_if *f01C8 = new(mem_ctx) ir_if(operand(r01C9).val);
   exec_list *const f01C8_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f01C8->then_instructions;

      ir_variable *const r01CA = body.make_temp(glsl_type::bool_type, "or_tmp");
      /* IF CONDITION */
      ir_expression *const r01CC = less(body.constant(int(2045)), r0181);
      ir_if *f01CB = new(mem_ctx) ir_if(operand(r01CC).val);
      exec_list *const f01CB_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01CB->then_instructions;

         body.emit(assign(r01CA, body.constant(true), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01CB->else_instructions;

         ir_variable *const r01CD = body.make_temp(glsl_type::bool_type, "and_tmp");
         /* IF CONDITION */
         ir_expression *const r01CF = equal(r0181, body.constant(int(2045)));
         ir_if *f01CE = new(mem_ctx) ir_if(operand(r01CF).val);
         exec_list *const f01CE_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f01CE->then_instructions;

            ir_expression *const r01D0 = equal(body.constant(2097151u), r0182);
            ir_expression *const r01D1 = equal(body.constant(4294967295u), r0183);
            body.emit(assign(r01CD, logic_and(r01D0, r01D1), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f01CE->else_instructions;

            body.emit(assign(r01CD, body.constant(false), 0x01));


         body.instructions = f01CE_parent_instructions;
         body.emit(f01CE);

         /* END IF */

         body.emit(assign(r01CA, logic_and(r01CD, r01C6), 0x01));


      body.instructions = f01CB_parent_instructions;
      body.emit(f01CB);

      /* END IF */

      /* IF CONDITION */
      ir_if *f01D2 = new(mem_ctx) ir_if(operand(r01CA).val);
      exec_list *const f01D2_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01D2->then_instructions;

         ir_variable *const r01D3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r01D3);
         ir_expression *const r01D4 = lshift(r0180, body.constant(int(31)));
         body.emit(assign(r01D3, add(r01D4, body.constant(2146435072u)), 0x02));

         body.emit(assign(r01D3, body.constant(0u), 0x01));

         body.emit(assign(r01C5, r01D3, 0x03));

         body.emit(assign(r01C4, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01D2->else_instructions;

         /* IF CONDITION */
         ir_expression *const r01D6 = less(r0181, body.constant(int(0)));
         ir_if *f01D5 = new(mem_ctx) ir_if(operand(r01D6).val);
         exec_list *const f01D5_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f01D5->then_instructions;

            ir_variable *const r01D7 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r01D7, r0184, 0x01));

            ir_variable *const r01D8 = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r01D8, neg(r0181), 0x01));

            ir_variable *const r01D9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r01D9);
            ir_variable *const r01DA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r01DA);
            ir_variable *const r01DB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r01DB);
            ir_variable *const r01DC = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r01DD = neg(r01D8);
            body.emit(assign(r01DC, bit_and(r01DD, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r01DF = equal(r01D8, body.constant(int(0)));
            ir_if *f01DE = new(mem_ctx) ir_if(operand(r01DF).val);
            exec_list *const f01DE_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f01DE->then_instructions;

               body.emit(assign(r01D9, r0184, 0x01));

               body.emit(assign(r01DA, r0183, 0x01));

               body.emit(assign(r01DB, r0182, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f01DE->else_instructions;

               /* IF CONDITION */
               ir_expression *const r01E1 = less(r01D8, body.constant(int(32)));
               ir_if *f01E0 = new(mem_ctx) ir_if(operand(r01E1).val);
               exec_list *const f01E0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f01E0->then_instructions;

                  body.emit(assign(r01D9, lshift(r0183, r01DC), 0x01));

                  ir_expression *const r01E2 = lshift(r0182, r01DC);
                  ir_expression *const r01E3 = rshift(r0183, r01D8);
                  body.emit(assign(r01DA, bit_or(r01E2, r01E3), 0x01));

                  body.emit(assign(r01DB, rshift(r0182, r01D8), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f01E0->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r01E5 = equal(r01D8, body.constant(int(32)));
                  ir_if *f01E4 = new(mem_ctx) ir_if(operand(r01E5).val);
                  exec_list *const f01E4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f01E4->then_instructions;

                     body.emit(assign(r01D9, r0183, 0x01));

                     body.emit(assign(r01DA, r0182, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f01E4->else_instructions;

                     body.emit(assign(r01D7, bit_or(r0184, r0183), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r01E7 = less(r01D8, body.constant(int(64)));
                     ir_if *f01E6 = new(mem_ctx) ir_if(operand(r01E7).val);
                     exec_list *const f01E6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f01E6->then_instructions;

                        body.emit(assign(r01D9, lshift(r0182, r01DC), 0x01));

                        ir_expression *const r01E8 = bit_and(r01D8, body.constant(int(31)));
                        body.emit(assign(r01DA, rshift(r0182, r01E8), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f01E6->else_instructions;

                        ir_variable *const r01E9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r01EB = equal(r01D8, body.constant(int(64)));
                        ir_if *f01EA = new(mem_ctx) ir_if(operand(r01EB).val);
                        exec_list *const f01EA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f01EA->then_instructions;

                           body.emit(assign(r01E9, r0182, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f01EA->else_instructions;

                           ir_expression *const r01EC = nequal(r0182, body.constant(0u));
                           ir_expression *const r01ED = expr(ir_unop_b2i, r01EC);
                           body.emit(assign(r01E9, expr(ir_unop_i2u, r01ED), 0x01));


                        body.instructions = f01EA_parent_instructions;
                        body.emit(f01EA);

                        /* END IF */

                        body.emit(assign(r01D9, r01E9, 0x01));

                        body.emit(assign(r01DA, body.constant(0u), 0x01));


                     body.instructions = f01E6_parent_instructions;
                     body.emit(f01E6);

                     /* END IF */


                  body.instructions = f01E4_parent_instructions;
                  body.emit(f01E4);

                  /* END IF */

                  body.emit(assign(r01DB, body.constant(0u), 0x01));


               body.instructions = f01E0_parent_instructions;
               body.emit(f01E0);

               /* END IF */

               ir_expression *const r01EE = nequal(r01D7, body.constant(0u));
               ir_expression *const r01EF = expr(ir_unop_b2i, r01EE);
               ir_expression *const r01F0 = expr(ir_unop_i2u, r01EF);
               body.emit(assign(r01D9, bit_or(r01D9, r01F0), 0x01));


            body.instructions = f01DE_parent_instructions;
            body.emit(f01DE);

            /* END IF */

            body.emit(assign(r01C1, r01DB, 0x01));

            body.emit(assign(r01C2, r01DA, 0x01));

            body.emit(assign(r01C3, r01D9, 0x01));

            body.emit(assign(r01C0, body.constant(int(0)), 0x01));

            body.emit(assign(r01C6, less(r01D9, body.constant(0u)), 0x01));


         body.instructions = f01D5_parent_instructions;
         body.emit(f01D5);

         /* END IF */


      body.instructions = f01D2_parent_instructions;
      body.emit(f01D2);

      /* END IF */


   body.instructions = f01C8_parent_instructions;
   body.emit(f01C8);

   /* END IF */

   /* IF CONDITION */
   ir_if *f01F1 = new(mem_ctx) ir_if(operand(r01C4).val);
   exec_list *const f01F1_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f01F1->then_instructions;

      /* IF CONDITION */
      ir_if *f01F2 = new(mem_ctx) ir_if(operand(r01C6).val);
      exec_list *const f01F2_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f01F2->then_instructions;

         ir_variable *const r01F3 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r01F3, add(r01C2, body.constant(1u)), 0x01));

         ir_expression *const r01F4 = less(r01F3, r01C2);
         ir_expression *const r01F5 = expr(ir_unop_b2i, r01F4);
         ir_expression *const r01F6 = expr(ir_unop_i2u, r01F5);
         body.emit(assign(r01C1, add(r01C1, r01F6), 0x01));

         ir_expression *const r01F7 = equal(r01C3, body.constant(0u));
         ir_expression *const r01F8 = expr(ir_unop_b2i, r01F7);
         ir_expression *const r01F9 = expr(ir_unop_i2u, r01F8);
         ir_expression *const r01FA = add(r01C3, r01F9);
         ir_expression *const r01FB = bit_and(r01FA, body.constant(1u));
         ir_expression *const r01FC = expr(ir_unop_bit_not, r01FB);
         body.emit(assign(r01C2, bit_and(r01F3, r01FC), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f01F2->else_instructions;

         /* IF CONDITION */
         ir_expression *const r01FE = bit_or(r01C1, r01C2);
         ir_expression *const r01FF = equal(r01FE, body.constant(0u));
         ir_if *f01FD = new(mem_ctx) ir_if(operand(r01FF).val);
         exec_list *const f01FD_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f01FD->then_instructions;

            body.emit(assign(r01C0, body.constant(int(0)), 0x01));


         body.instructions = f01FD_parent_instructions;
         body.emit(f01FD);

         /* END IF */


      body.instructions = f01F2_parent_instructions;
      body.emit(f01F2);

      /* END IF */

      ir_variable *const r0200 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
      body.emit(r0200);
      ir_expression *const r0201 = lshift(r0180, body.constant(int(31)));
      ir_expression *const r0202 = expr(ir_unop_i2u, r01C0);
      ir_expression *const r0203 = lshift(r0202, body.constant(int(20)));
      ir_expression *const r0204 = add(r0201, r0203);
      body.emit(assign(r0200, add(r0204, r01C1), 0x02));

      body.emit(assign(r0200, r01C2, 0x01));

      body.emit(assign(r01C5, r0200, 0x03));

      body.emit(assign(r01C4, body.constant(false), 0x01));


   body.instructions = f01F1_parent_instructions;
   body.emit(f01F1);

   /* END IF */

   body.emit(ret(r01C5));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
propagateFloat64NaN(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0205 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0205);
   ir_variable *const r0206 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0206);
   ir_variable *const r0207 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r0208 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
   ir_expression *const r0209 = lshift(swizzle_x(r0205), body.constant(int(1)));
   ir_expression *const r020A = lequal(body.constant(4292870144u), r0209);
   ir_expression *const r020B = nequal(swizzle_y(r0205), body.constant(0u));
   ir_expression *const r020C = bit_and(swizzle_x(r0205), body.constant(1048575u));
   ir_expression *const r020D = nequal(r020C, body.constant(0u));
   ir_expression *const r020E = logic_or(r020B, r020D);
   body.emit(assign(r0208, logic_and(r020A, r020E), 0x01));

   ir_variable *const r020F = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
   ir_expression *const r0210 = rshift(swizzle_x(r0205), body.constant(int(19)));
   ir_expression *const r0211 = bit_and(r0210, body.constant(4095u));
   ir_expression *const r0212 = equal(r0211, body.constant(4094u));
   ir_expression *const r0213 = nequal(swizzle_y(r0205), body.constant(0u));
   ir_expression *const r0214 = bit_and(swizzle_x(r0205), body.constant(524287u));
   ir_expression *const r0215 = nequal(r0214, body.constant(0u));
   ir_expression *const r0216 = logic_or(r0213, r0215);
   body.emit(assign(r020F, logic_and(r0212, r0216), 0x01));

   ir_variable *const r0217 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
   ir_expression *const r0218 = lshift(swizzle_x(r0206), body.constant(int(1)));
   ir_expression *const r0219 = lequal(body.constant(4292870144u), r0218);
   ir_expression *const r021A = nequal(swizzle_y(r0206), body.constant(0u));
   ir_expression *const r021B = bit_and(swizzle_x(r0206), body.constant(1048575u));
   ir_expression *const r021C = nequal(r021B, body.constant(0u));
   ir_expression *const r021D = logic_or(r021A, r021C);
   body.emit(assign(r0217, logic_and(r0219, r021D), 0x01));

   body.emit(assign(r0205, bit_or(swizzle_x(r0205), body.constant(524288u)), 0x01));

   body.emit(assign(r0206, bit_or(swizzle_x(r0206), body.constant(524288u)), 0x01));

   /* IF CONDITION */
   ir_if *f021E = new(mem_ctx) ir_if(operand(r0208).val);
   exec_list *const f021E_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f021E->then_instructions;

      ir_variable *const r021F = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r0221 = logic_and(r020F, r0217);
      ir_if *f0220 = new(mem_ctx) ir_if(operand(r0221).val);
      exec_list *const f0220_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0220->then_instructions;

         body.emit(assign(r021F, r0206, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0220->else_instructions;

         body.emit(assign(r021F, r0205, 0x03));


      body.instructions = f0220_parent_instructions;
      body.emit(f0220);

      /* END IF */

      body.emit(assign(r0207, r021F, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f021E->else_instructions;

      body.emit(assign(r0207, r0206, 0x03));


   body.instructions = f021E_parent_instructions;
   body.emit(f021E);

   /* END IF */

   body.emit(ret(r0207));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
addFloat64Fracs(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0222 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0222);
   ir_variable *const r0223 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0223);
   ir_variable *const r0224 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r0224);
   ir_variable *const r0225 = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r0225, body.constant(true), 0x01));

   ir_variable *const r0226 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r0227 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
   body.emit(r0227);
   ir_variable *const r0228 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
   body.emit(r0228);
   ir_variable *const r0229 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
   body.emit(r0229);
   ir_variable *const r022A = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r022A);
   ir_variable *const r022B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
   body.emit(r022B);
   ir_variable *const r022C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r022C);
   body.emit(assign(r022C, body.constant(0u), 0x01));

   body.emit(assign(r022B, body.constant(0u), 0x01));

   ir_variable *const r022D = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
   body.emit(assign(r022D, bit_and(swizzle_y(r0222), body.constant(1048575u)), 0x01));

   body.emit(assign(r022D, swizzle_x(r0222), 0x02));

   body.emit(assign(r0229, r022D, 0x03));

   ir_variable *const r022E = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r022F = rshift(swizzle_y(r0222), body.constant(int(20)));
   ir_expression *const r0230 = bit_and(r022F, body.constant(2047u));
   body.emit(assign(r022E, expr(ir_unop_u2i, r0230), 0x01));

   ir_variable *const r0231 = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
   body.emit(assign(r0231, bit_and(swizzle_y(r0223), body.constant(1048575u)), 0x01));

   body.emit(assign(r0231, swizzle_x(r0223), 0x02));

   body.emit(assign(r0228, r0231, 0x03));

   ir_variable *const r0232 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r0233 = rshift(swizzle_y(r0223), body.constant(int(20)));
   ir_expression *const r0234 = bit_and(r0233, body.constant(2047u));
   body.emit(assign(r0232, expr(ir_unop_u2i, r0234), 0x01));

   ir_variable *const r0235 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   body.emit(assign(r0235, sub(r022E, r0232), 0x01));

   body.emit(assign(r0227, r0235, 0x01));

   /* IF CONDITION */
   ir_expression *const r0237 = less(body.constant(int(0)), r0235);
   ir_if *f0236 = new(mem_ctx) ir_if(operand(r0237).val);
   exec_list *const f0236_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0236->then_instructions;

      /* IF CONDITION */
      ir_expression *const r0239 = equal(r022E, body.constant(int(2047)));
      ir_if *f0238 = new(mem_ctx) ir_if(operand(r0239).val);
      exec_list *const f0238_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0238->then_instructions;

         /* IF CONDITION */
         ir_expression *const r023B = bit_or(swizzle_x(r0222), swizzle_x(r022D));
         ir_expression *const r023C = nequal(r023B, body.constant(0u));
         ir_if *f023A = new(mem_ctx) ir_if(operand(r023C).val);
         exec_list *const f023A_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f023A->then_instructions;

            ir_variable *const r023D = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r023D, swizzle_y(r0222), 0x02));

            ir_variable *const r023E = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r023E, swizzle_y(r0223), 0x02));

            ir_variable *const r023F = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0240 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r0241 = rshift(swizzle_x(r0222), body.constant(int(19)));
            ir_expression *const r0242 = bit_and(r0241, body.constant(4095u));
            ir_expression *const r0243 = equal(r0242, body.constant(4094u));
            ir_expression *const r0244 = nequal(swizzle_y(r0222), body.constant(0u));
            ir_expression *const r0245 = bit_and(swizzle_x(r0222), body.constant(524287u));
            ir_expression *const r0246 = nequal(r0245, body.constant(0u));
            ir_expression *const r0247 = logic_or(r0244, r0246);
            body.emit(assign(r0240, logic_and(r0243, r0247), 0x01));

            ir_variable *const r0248 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r0249 = lshift(swizzle_x(r0223), body.constant(int(1)));
            ir_expression *const r024A = lequal(body.constant(4292870144u), r0249);
            ir_expression *const r024B = nequal(swizzle_y(r0223), body.constant(0u));
            ir_expression *const r024C = bit_and(swizzle_x(r0223), body.constant(1048575u));
            ir_expression *const r024D = nequal(r024C, body.constant(0u));
            ir_expression *const r024E = logic_or(r024B, r024D);
            body.emit(assign(r0248, logic_and(r024A, r024E), 0x01));

            body.emit(assign(r023D, bit_or(swizzle_x(r0222), body.constant(524288u)), 0x01));

            body.emit(assign(r023E, bit_or(swizzle_x(r0223), body.constant(524288u)), 0x01));

            /* IF CONDITION */
            ir_expression *const r0250 = lshift(swizzle_x(r0222), body.constant(int(1)));
            ir_expression *const r0251 = lequal(body.constant(4292870144u), r0250);
            ir_expression *const r0252 = nequal(swizzle_y(r0222), body.constant(0u));
            ir_expression *const r0253 = bit_and(swizzle_x(r0222), body.constant(1048575u));
            ir_expression *const r0254 = nequal(r0253, body.constant(0u));
            ir_expression *const r0255 = logic_or(r0252, r0254);
            ir_expression *const r0256 = logic_and(r0251, r0255);
            ir_if *f024F = new(mem_ctx) ir_if(operand(r0256).val);
            exec_list *const f024F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f024F->then_instructions;

               ir_variable *const r0257 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r0259 = logic_and(r0240, r0248);
               ir_if *f0258 = new(mem_ctx) ir_if(operand(r0259).val);
               exec_list *const f0258_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0258->then_instructions;

                  body.emit(assign(r0257, r023E, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0258->else_instructions;

                  body.emit(assign(r0257, r023D, 0x03));


               body.instructions = f0258_parent_instructions;
               body.emit(f0258);

               /* END IF */

               body.emit(assign(r023F, r0257, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f024F->else_instructions;

               body.emit(assign(r023F, r023E, 0x03));


            body.instructions = f024F_parent_instructions;
            body.emit(f024F);

            /* END IF */

            body.emit(assign(r0226, r023F, 0x03));

            body.emit(assign(r0225, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f023A->else_instructions;

            body.emit(assign(r0226, r0222, 0x03));

            body.emit(assign(r0225, body.constant(false), 0x01));


         body.instructions = f023A_parent_instructions;
         body.emit(f023A);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0238->else_instructions;

         /* IF CONDITION */
         ir_expression *const r025B = equal(r0232, body.constant(int(0)));
         ir_if *f025A = new(mem_ctx) ir_if(operand(r025B).val);
         exec_list *const f025A_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f025A->then_instructions;

            body.emit(assign(r0227, add(r0235, body.constant(int(-1))), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f025A->else_instructions;

            body.emit(assign(r0228, bit_or(swizzle_x(r0223), body.constant(1048576u)), 0x02));


         body.instructions = f025A_parent_instructions;
         body.emit(f025A);

         /* END IF */

         ir_variable *const r025C = body.make_temp(glsl_type::uint_type, "a0");
         body.emit(assign(r025C, swizzle_y(r0228), 0x01));

         ir_variable *const r025D = body.make_temp(glsl_type::uint_type, "a1");
         body.emit(assign(r025D, swizzle_x(r0228), 0x01));

         ir_variable *const r025E = body.make_temp(glsl_type::uint_type, "a2");
         body.emit(assign(r025E, body.constant(0u), 0x01));

         ir_variable *const r025F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
         body.emit(r025F);
         ir_variable *const r0260 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r0260);
         ir_variable *const r0261 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r0261);
         ir_variable *const r0262 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         ir_expression *const r0263 = neg(r0227);
         body.emit(assign(r0262, bit_and(r0263, body.constant(int(31))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0265 = equal(r0227, body.constant(int(0)));
         ir_if *f0264 = new(mem_ctx) ir_if(operand(r0265).val);
         exec_list *const f0264_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0264->then_instructions;

            body.emit(assign(r025F, r025E, 0x01));

            body.emit(assign(r0260, r025D, 0x01));

            body.emit(assign(r0261, r025C, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0264->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0267 = less(r0227, body.constant(int(32)));
            ir_if *f0266 = new(mem_ctx) ir_if(operand(r0267).val);
            exec_list *const f0266_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0266->then_instructions;

               body.emit(assign(r025F, lshift(swizzle_x(r0231), r0262), 0x01));

               ir_expression *const r0268 = lshift(swizzle_y(r0228), r0262);
               ir_expression *const r0269 = rshift(swizzle_x(r0231), r0227);
               body.emit(assign(r0260, bit_or(r0268, r0269), 0x01));

               body.emit(assign(r0261, rshift(swizzle_y(r0228), r0227), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0266->else_instructions;

               /* IF CONDITION */
               ir_expression *const r026B = equal(r0227, body.constant(int(32)));
               ir_if *f026A = new(mem_ctx) ir_if(operand(r026B).val);
               exec_list *const f026A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f026A->then_instructions;

                  body.emit(assign(r025F, r025D, 0x01));

                  body.emit(assign(r0260, r025C, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f026A->else_instructions;

                  body.emit(assign(r025E, bit_or(body.constant(0u), swizzle_x(r0231)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r026D = less(r0227, body.constant(int(64)));
                  ir_if *f026C = new(mem_ctx) ir_if(operand(r026D).val);
                  exec_list *const f026C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f026C->then_instructions;

                     body.emit(assign(r025F, lshift(swizzle_y(r0228), r0262), 0x01));

                     ir_expression *const r026E = bit_and(r0227, body.constant(int(31)));
                     body.emit(assign(r0260, rshift(swizzle_y(r0228), r026E), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f026C->else_instructions;

                     ir_variable *const r026F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0271 = equal(r0227, body.constant(int(64)));
                     ir_if *f0270 = new(mem_ctx) ir_if(operand(r0271).val);
                     exec_list *const f0270_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0270->then_instructions;

                        body.emit(assign(r026F, r025C, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0270->else_instructions;

                        ir_expression *const r0272 = nequal(swizzle_y(r0228), body.constant(0u));
                        ir_expression *const r0273 = expr(ir_unop_b2i, r0272);
                        body.emit(assign(r026F, expr(ir_unop_i2u, r0273), 0x01));


                     body.instructions = f0270_parent_instructions;
                     body.emit(f0270);

                     /* END IF */

                     body.emit(assign(r025F, r026F, 0x01));

                     body.emit(assign(r0260, body.constant(0u), 0x01));


                  body.instructions = f026C_parent_instructions;
                  body.emit(f026C);

                  /* END IF */


               body.instructions = f026A_parent_instructions;
               body.emit(f026A);

               /* END IF */

               body.emit(assign(r0261, body.constant(0u), 0x01));


            body.instructions = f0266_parent_instructions;
            body.emit(f0266);

            /* END IF */

            ir_expression *const r0274 = nequal(r025E, body.constant(0u));
            ir_expression *const r0275 = expr(ir_unop_b2i, r0274);
            ir_expression *const r0276 = expr(ir_unop_i2u, r0275);
            body.emit(assign(r025F, bit_or(r025F, r0276), 0x01));


         body.instructions = f0264_parent_instructions;
         body.emit(f0264);

         /* END IF */

         body.emit(assign(r0228, r0261, 0x02));

         body.emit(assign(r0228, r0260, 0x01));

         body.emit(assign(r022B, r025F, 0x01));

         body.emit(assign(r022A, r022E, 0x01));


      body.instructions = f0238_parent_instructions;
      body.emit(f0238);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0236->else_instructions;

      /* IF CONDITION */
      ir_expression *const r0278 = less(r0227, body.constant(int(0)));
      ir_if *f0277 = new(mem_ctx) ir_if(operand(r0278).val);
      exec_list *const f0277_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0277->then_instructions;

         /* IF CONDITION */
         ir_expression *const r027A = equal(r0232, body.constant(int(2047)));
         ir_if *f0279 = new(mem_ctx) ir_if(operand(r027A).val);
         exec_list *const f0279_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0279->then_instructions;

            /* IF CONDITION */
            ir_expression *const r027C = bit_or(swizzle_y(r0228), swizzle_x(r0228));
            ir_expression *const r027D = nequal(r027C, body.constant(0u));
            ir_if *f027B = new(mem_ctx) ir_if(operand(r027D).val);
            exec_list *const f027B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f027B->then_instructions;

               ir_variable *const r027E = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r027E, swizzle_y(r0222), 0x02));

               ir_variable *const r027F = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r027F, swizzle_y(r0223), 0x02));

               ir_variable *const r0280 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0281 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r0282 = rshift(swizzle_x(r0222), body.constant(int(19)));
               ir_expression *const r0283 = bit_and(r0282, body.constant(4095u));
               ir_expression *const r0284 = equal(r0283, body.constant(4094u));
               ir_expression *const r0285 = nequal(swizzle_y(r0222), body.constant(0u));
               ir_expression *const r0286 = bit_and(swizzle_x(r0222), body.constant(524287u));
               ir_expression *const r0287 = nequal(r0286, body.constant(0u));
               ir_expression *const r0288 = logic_or(r0285, r0287);
               body.emit(assign(r0281, logic_and(r0284, r0288), 0x01));

               ir_variable *const r0289 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r028A = lshift(swizzle_x(r0223), body.constant(int(1)));
               ir_expression *const r028B = lequal(body.constant(4292870144u), r028A);
               ir_expression *const r028C = nequal(swizzle_y(r0223), body.constant(0u));
               ir_expression *const r028D = bit_and(swizzle_x(r0223), body.constant(1048575u));
               ir_expression *const r028E = nequal(r028D, body.constant(0u));
               ir_expression *const r028F = logic_or(r028C, r028E);
               body.emit(assign(r0289, logic_and(r028B, r028F), 0x01));

               body.emit(assign(r027E, bit_or(swizzle_x(r0222), body.constant(524288u)), 0x01));

               body.emit(assign(r027F, bit_or(swizzle_x(r0223), body.constant(524288u)), 0x01));

               /* IF CONDITION */
               ir_expression *const r0291 = lshift(swizzle_x(r0222), body.constant(int(1)));
               ir_expression *const r0292 = lequal(body.constant(4292870144u), r0291);
               ir_expression *const r0293 = nequal(swizzle_y(r0222), body.constant(0u));
               ir_expression *const r0294 = bit_and(swizzle_x(r0222), body.constant(1048575u));
               ir_expression *const r0295 = nequal(r0294, body.constant(0u));
               ir_expression *const r0296 = logic_or(r0293, r0295);
               ir_expression *const r0297 = logic_and(r0292, r0296);
               ir_if *f0290 = new(mem_ctx) ir_if(operand(r0297).val);
               exec_list *const f0290_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0290->then_instructions;

                  ir_variable *const r0298 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r029A = logic_and(r0281, r0289);
                  ir_if *f0299 = new(mem_ctx) ir_if(operand(r029A).val);
                  exec_list *const f0299_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0299->then_instructions;

                     body.emit(assign(r0298, r027F, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0299->else_instructions;

                     body.emit(assign(r0298, r027E, 0x03));


                  body.instructions = f0299_parent_instructions;
                  body.emit(f0299);

                  /* END IF */

                  body.emit(assign(r0280, r0298, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0290->else_instructions;

                  body.emit(assign(r0280, r027F, 0x03));


               body.instructions = f0290_parent_instructions;
               body.emit(f0290);

               /* END IF */

               body.emit(assign(r0226, r0280, 0x03));

               body.emit(assign(r0225, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f027B->else_instructions;

               ir_variable *const r029B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r029B);
               ir_expression *const r029C = lshift(r0224, body.constant(int(31)));
               body.emit(assign(r029B, add(r029C, body.constant(2146435072u)), 0x02));

               body.emit(assign(r029B, body.constant(0u), 0x01));

               body.emit(assign(r0226, r029B, 0x03));

               body.emit(assign(r0225, body.constant(false), 0x01));


            body.instructions = f027B_parent_instructions;
            body.emit(f027B);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0279->else_instructions;

            /* IF CONDITION */
            ir_expression *const r029E = equal(r022E, body.constant(int(0)));
            ir_if *f029D = new(mem_ctx) ir_if(operand(r029E).val);
            exec_list *const f029D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f029D->then_instructions;

               body.emit(assign(r0227, add(r0227, body.constant(int(1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f029D->else_instructions;

               body.emit(assign(r0229, bit_or(swizzle_x(r0222), body.constant(1048576u)), 0x02));


            body.instructions = f029D_parent_instructions;
            body.emit(f029D);

            /* END IF */

            ir_variable *const r029F = body.make_temp(glsl_type::uint_type, "a0");
            body.emit(assign(r029F, swizzle_y(r0229), 0x01));

            ir_variable *const r02A0 = body.make_temp(glsl_type::uint_type, "a1");
            body.emit(assign(r02A0, swizzle_x(r0229), 0x01));

            ir_variable *const r02A1 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r02A1, body.constant(0u), 0x01));

            ir_variable *const r02A2 = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r02A2, neg(r0227), 0x01));

            ir_variable *const r02A3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r02A3);
            ir_variable *const r02A4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r02A4);
            ir_variable *const r02A5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r02A5);
            ir_variable *const r02A6 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r02A7 = neg(r02A2);
            body.emit(assign(r02A6, bit_and(r02A7, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r02A9 = equal(r02A2, body.constant(int(0)));
            ir_if *f02A8 = new(mem_ctx) ir_if(operand(r02A9).val);
            exec_list *const f02A8_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f02A8->then_instructions;

               body.emit(assign(r02A3, r02A1, 0x01));

               body.emit(assign(r02A4, r02A0, 0x01));

               body.emit(assign(r02A5, r029F, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f02A8->else_instructions;

               /* IF CONDITION */
               ir_expression *const r02AB = less(r02A2, body.constant(int(32)));
               ir_if *f02AA = new(mem_ctx) ir_if(operand(r02AB).val);
               exec_list *const f02AA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f02AA->then_instructions;

                  body.emit(assign(r02A3, lshift(swizzle_x(r022D), r02A6), 0x01));

                  ir_expression *const r02AC = lshift(swizzle_y(r0229), r02A6);
                  ir_expression *const r02AD = rshift(swizzle_x(r022D), r02A2);
                  body.emit(assign(r02A4, bit_or(r02AC, r02AD), 0x01));

                  body.emit(assign(r02A5, rshift(swizzle_y(r0229), r02A2), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f02AA->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r02AF = equal(r02A2, body.constant(int(32)));
                  ir_if *f02AE = new(mem_ctx) ir_if(operand(r02AF).val);
                  exec_list *const f02AE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f02AE->then_instructions;

                     body.emit(assign(r02A3, r02A0, 0x01));

                     body.emit(assign(r02A4, r029F, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f02AE->else_instructions;

                     body.emit(assign(r02A1, bit_or(body.constant(0u), swizzle_x(r022D)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r02B1 = less(r02A2, body.constant(int(64)));
                     ir_if *f02B0 = new(mem_ctx) ir_if(operand(r02B1).val);
                     exec_list *const f02B0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f02B0->then_instructions;

                        body.emit(assign(r02A3, lshift(swizzle_y(r0229), r02A6), 0x01));

                        ir_expression *const r02B2 = bit_and(r02A2, body.constant(int(31)));
                        body.emit(assign(r02A4, rshift(swizzle_y(r0229), r02B2), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f02B0->else_instructions;

                        ir_variable *const r02B3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r02B5 = equal(r02A2, body.constant(int(64)));
                        ir_if *f02B4 = new(mem_ctx) ir_if(operand(r02B5).val);
                        exec_list *const f02B4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f02B4->then_instructions;

                           body.emit(assign(r02B3, r029F, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f02B4->else_instructions;

                           ir_expression *const r02B6 = nequal(swizzle_y(r0229), body.constant(0u));
                           ir_expression *const r02B7 = expr(ir_unop_b2i, r02B6);
                           body.emit(assign(r02B3, expr(ir_unop_i2u, r02B7), 0x01));


                        body.instructions = f02B4_parent_instructions;
                        body.emit(f02B4);

                        /* END IF */

                        body.emit(assign(r02A3, r02B3, 0x01));

                        body.emit(assign(r02A4, body.constant(0u), 0x01));


                     body.instructions = f02B0_parent_instructions;
                     body.emit(f02B0);

                     /* END IF */


                  body.instructions = f02AE_parent_instructions;
                  body.emit(f02AE);

                  /* END IF */

                  body.emit(assign(r02A5, body.constant(0u), 0x01));


               body.instructions = f02AA_parent_instructions;
               body.emit(f02AA);

               /* END IF */

               ir_expression *const r02B8 = nequal(r02A1, body.constant(0u));
               ir_expression *const r02B9 = expr(ir_unop_b2i, r02B8);
               ir_expression *const r02BA = expr(ir_unop_i2u, r02B9);
               body.emit(assign(r02A3, bit_or(r02A3, r02BA), 0x01));


            body.instructions = f02A8_parent_instructions;
            body.emit(f02A8);

            /* END IF */

            body.emit(assign(r0229, r02A5, 0x02));

            body.emit(assign(r0229, r02A4, 0x01));

            body.emit(assign(r022B, r02A3, 0x01));

            body.emit(assign(r022A, r0232, 0x01));


         body.instructions = f0279_parent_instructions;
         body.emit(f0279);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0277->else_instructions;

         /* IF CONDITION */
         ir_expression *const r02BC = equal(r022E, body.constant(int(2047)));
         ir_if *f02BB = new(mem_ctx) ir_if(operand(r02BC).val);
         exec_list *const f02BB_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f02BB->then_instructions;

            /* IF CONDITION */
            ir_expression *const r02BE = bit_or(swizzle_y(r0229), swizzle_x(r0229));
            ir_expression *const r02BF = bit_or(swizzle_y(r0228), swizzle_x(r0228));
            ir_expression *const r02C0 = bit_or(r02BE, r02BF);
            ir_expression *const r02C1 = nequal(r02C0, body.constant(0u));
            ir_if *f02BD = new(mem_ctx) ir_if(operand(r02C1).val);
            exec_list *const f02BD_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f02BD->then_instructions;

               ir_variable *const r02C2 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r02C2, swizzle_y(r0222), 0x02));

               ir_variable *const r02C3 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r02C3, swizzle_y(r0223), 0x02));

               ir_variable *const r02C4 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r02C5 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r02C6 = rshift(swizzle_x(r0222), body.constant(int(19)));
               ir_expression *const r02C7 = bit_and(r02C6, body.constant(4095u));
               ir_expression *const r02C8 = equal(r02C7, body.constant(4094u));
               ir_expression *const r02C9 = nequal(swizzle_y(r0222), body.constant(0u));
               ir_expression *const r02CA = bit_and(swizzle_x(r0222), body.constant(524287u));
               ir_expression *const r02CB = nequal(r02CA, body.constant(0u));
               ir_expression *const r02CC = logic_or(r02C9, r02CB);
               body.emit(assign(r02C5, logic_and(r02C8, r02CC), 0x01));

               ir_variable *const r02CD = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r02CE = lshift(swizzle_x(r0223), body.constant(int(1)));
               ir_expression *const r02CF = lequal(body.constant(4292870144u), r02CE);
               ir_expression *const r02D0 = nequal(swizzle_y(r0223), body.constant(0u));
               ir_expression *const r02D1 = bit_and(swizzle_x(r0223), body.constant(1048575u));
               ir_expression *const r02D2 = nequal(r02D1, body.constant(0u));
               ir_expression *const r02D3 = logic_or(r02D0, r02D2);
               body.emit(assign(r02CD, logic_and(r02CF, r02D3), 0x01));

               body.emit(assign(r02C2, bit_or(swizzle_x(r0222), body.constant(524288u)), 0x01));

               body.emit(assign(r02C3, bit_or(swizzle_x(r0223), body.constant(524288u)), 0x01));

               /* IF CONDITION */
               ir_expression *const r02D5 = lshift(swizzle_x(r0222), body.constant(int(1)));
               ir_expression *const r02D6 = lequal(body.constant(4292870144u), r02D5);
               ir_expression *const r02D7 = nequal(swizzle_y(r0222), body.constant(0u));
               ir_expression *const r02D8 = bit_and(swizzle_x(r0222), body.constant(1048575u));
               ir_expression *const r02D9 = nequal(r02D8, body.constant(0u));
               ir_expression *const r02DA = logic_or(r02D7, r02D9);
               ir_expression *const r02DB = logic_and(r02D6, r02DA);
               ir_if *f02D4 = new(mem_ctx) ir_if(operand(r02DB).val);
               exec_list *const f02D4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f02D4->then_instructions;

                  ir_variable *const r02DC = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r02DE = logic_and(r02C5, r02CD);
                  ir_if *f02DD = new(mem_ctx) ir_if(operand(r02DE).val);
                  exec_list *const f02DD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f02DD->then_instructions;

                     body.emit(assign(r02DC, r02C3, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f02DD->else_instructions;

                     body.emit(assign(r02DC, r02C2, 0x03));


                  body.instructions = f02DD_parent_instructions;
                  body.emit(f02DD);

                  /* END IF */

                  body.emit(assign(r02C4, r02DC, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f02D4->else_instructions;

                  body.emit(assign(r02C4, r02C3, 0x03));


               body.instructions = f02D4_parent_instructions;
               body.emit(f02D4);

               /* END IF */

               body.emit(assign(r0226, r02C4, 0x03));

               body.emit(assign(r0225, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f02BD->else_instructions;

               body.emit(assign(r0226, r0222, 0x03));

               body.emit(assign(r0225, body.constant(false), 0x01));


            body.instructions = f02BD_parent_instructions;
            body.emit(f02BD);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f02BB->else_instructions;

            ir_variable *const r02DF = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r02E0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
            body.emit(assign(r02E0, add(swizzle_x(r0229), swizzle_x(r0228)), 0x01));

            ir_expression *const r02E1 = add(swizzle_y(r0229), swizzle_y(r0228));
            ir_expression *const r02E2 = less(r02E0, swizzle_x(r0229));
            ir_expression *const r02E3 = expr(ir_unop_b2i, r02E2);
            ir_expression *const r02E4 = expr(ir_unop_i2u, r02E3);
            body.emit(assign(r02DF, add(r02E1, r02E4), 0x01));

            body.emit(assign(r022C, r02DF, 0x01));

            /* IF CONDITION */
            ir_expression *const r02E6 = equal(r022E, body.constant(int(0)));
            ir_if *f02E5 = new(mem_ctx) ir_if(operand(r02E6).val);
            exec_list *const f02E5_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f02E5->then_instructions;

               ir_variable *const r02E7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r02E7);
               ir_expression *const r02E8 = lshift(r0224, body.constant(int(31)));
               body.emit(assign(r02E7, add(r02E8, r02DF), 0x02));

               body.emit(assign(r02E7, r02E0, 0x01));

               body.emit(assign(r0226, r02E7, 0x03));

               body.emit(assign(r0225, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f02E5->else_instructions;

               body.emit(assign(r022C, bit_or(r02DF, body.constant(2097152u)), 0x01));

               body.emit(assign(r022A, r022E, 0x01));

               ir_variable *const r02E9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r02E9);
               ir_variable *const r02EA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r02EA);
               ir_variable *const r02EB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r02EB);
               body.emit(assign(r02E9, lshift(r02E0, body.constant(int(31))), 0x01));

               ir_expression *const r02EC = lshift(r022C, body.constant(int(31)));
               ir_expression *const r02ED = rshift(r02E0, body.constant(int(1)));
               body.emit(assign(r02EA, bit_or(r02EC, r02ED), 0x01));

               body.emit(assign(r02EB, rshift(r022C, body.constant(int(1))), 0x01));

               body.emit(assign(r02E9, bit_or(r02E9, body.constant(0u)), 0x01));

               body.emit(assign(r022C, r02EB, 0x01));

               body.emit(assign(r022B, r02E9, 0x01));

               ir_variable *const r02EE = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r02EE, r022E, 0x01));

               ir_variable *const r02EF = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r02EF, r02EB, 0x01));

               ir_variable *const r02F0 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r02F0, r02EA, 0x01));

               ir_variable *const r02F1 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r02F1, r02E9, 0x01));

               ir_variable *const r02F2 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r02F2, body.constant(true), 0x01));

               ir_variable *const r02F3 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r02F4 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r02F4);
               ir_expression *const r02F5 = expr(ir_unop_u2i, r02E9);
               body.emit(assign(r02F4, less(r02F5, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r02F7 = lequal(body.constant(int(2045)), r022E);
               ir_if *f02F6 = new(mem_ctx) ir_if(operand(r02F7).val);
               exec_list *const f02F6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f02F6->then_instructions;

                  ir_variable *const r02F8 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r02FA = less(body.constant(int(2045)), r022E);
                  ir_if *f02F9 = new(mem_ctx) ir_if(operand(r02FA).val);
                  exec_list *const f02F9_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f02F9->then_instructions;

                     body.emit(assign(r02F8, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f02F9->else_instructions;

                     ir_variable *const r02FB = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r02FD = equal(r022E, body.constant(int(2045)));
                     ir_if *f02FC = new(mem_ctx) ir_if(operand(r02FD).val);
                     exec_list *const f02FC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f02FC->then_instructions;

                        ir_expression *const r02FE = equal(body.constant(2097151u), r02EB);
                        ir_expression *const r02FF = equal(body.constant(4294967295u), r02EA);
                        body.emit(assign(r02FB, logic_and(r02FE, r02FF), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f02FC->else_instructions;

                        body.emit(assign(r02FB, body.constant(false), 0x01));


                     body.instructions = f02FC_parent_instructions;
                     body.emit(f02FC);

                     /* END IF */

                     body.emit(assign(r02F8, logic_and(r02FB, r02F4), 0x01));


                  body.instructions = f02F9_parent_instructions;
                  body.emit(f02F9);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0300 = new(mem_ctx) ir_if(operand(r02F8).val);
                  exec_list *const f0300_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0300->then_instructions;

                     ir_variable *const r0301 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0301);
                     ir_expression *const r0302 = lshift(r0224, body.constant(int(31)));
                     body.emit(assign(r0301, add(r0302, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r0301, body.constant(0u), 0x01));

                     body.emit(assign(r02F3, r0301, 0x03));

                     body.emit(assign(r02F2, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0300->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0304 = less(r022E, body.constant(int(0)));
                     ir_if *f0303 = new(mem_ctx) ir_if(operand(r0304).val);
                     exec_list *const f0303_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0303->then_instructions;

                        ir_variable *const r0305 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0305, r02E9, 0x01));

                        ir_variable *const r0306 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0306, neg(r022E), 0x01));

                        ir_variable *const r0307 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0307);
                        ir_variable *const r0308 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0308);
                        ir_variable *const r0309 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0309);
                        ir_variable *const r030A = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r030B = neg(r0306);
                        body.emit(assign(r030A, bit_and(r030B, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r030D = equal(r0306, body.constant(int(0)));
                        ir_if *f030C = new(mem_ctx) ir_if(operand(r030D).val);
                        exec_list *const f030C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f030C->then_instructions;

                           body.emit(assign(r0307, r02E9, 0x01));

                           body.emit(assign(r0308, r02EA, 0x01));

                           body.emit(assign(r0309, r02EB, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f030C->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r030F = less(r0306, body.constant(int(32)));
                           ir_if *f030E = new(mem_ctx) ir_if(operand(r030F).val);
                           exec_list *const f030E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f030E->then_instructions;

                              body.emit(assign(r0307, lshift(r02EA, r030A), 0x01));

                              ir_expression *const r0310 = lshift(r02EB, r030A);
                              ir_expression *const r0311 = rshift(r02EA, r0306);
                              body.emit(assign(r0308, bit_or(r0310, r0311), 0x01));

                              body.emit(assign(r0309, rshift(r02EB, r0306), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f030E->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0313 = equal(r0306, body.constant(int(32)));
                              ir_if *f0312 = new(mem_ctx) ir_if(operand(r0313).val);
                              exec_list *const f0312_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0312->then_instructions;

                                 body.emit(assign(r0307, r02EA, 0x01));

                                 body.emit(assign(r0308, r02EB, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0312->else_instructions;

                                 body.emit(assign(r0305, bit_or(r02E9, r02EA), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0315 = less(r0306, body.constant(int(64)));
                                 ir_if *f0314 = new(mem_ctx) ir_if(operand(r0315).val);
                                 exec_list *const f0314_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0314->then_instructions;

                                    body.emit(assign(r0307, lshift(r02EB, r030A), 0x01));

                                    ir_expression *const r0316 = bit_and(r0306, body.constant(int(31)));
                                    body.emit(assign(r0308, rshift(r02EB, r0316), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0314->else_instructions;

                                    ir_variable *const r0317 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r0319 = equal(r0306, body.constant(int(64)));
                                    ir_if *f0318 = new(mem_ctx) ir_if(operand(r0319).val);
                                    exec_list *const f0318_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0318->then_instructions;

                                       body.emit(assign(r0317, r02EB, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0318->else_instructions;

                                       ir_expression *const r031A = nequal(r02EB, body.constant(0u));
                                       ir_expression *const r031B = expr(ir_unop_b2i, r031A);
                                       body.emit(assign(r0317, expr(ir_unop_i2u, r031B), 0x01));


                                    body.instructions = f0318_parent_instructions;
                                    body.emit(f0318);

                                    /* END IF */

                                    body.emit(assign(r0307, r0317, 0x01));

                                    body.emit(assign(r0308, body.constant(0u), 0x01));


                                 body.instructions = f0314_parent_instructions;
                                 body.emit(f0314);

                                 /* END IF */


                              body.instructions = f0312_parent_instructions;
                              body.emit(f0312);

                              /* END IF */

                              body.emit(assign(r0309, body.constant(0u), 0x01));


                           body.instructions = f030E_parent_instructions;
                           body.emit(f030E);

                           /* END IF */

                           ir_expression *const r031C = nequal(r0305, body.constant(0u));
                           ir_expression *const r031D = expr(ir_unop_b2i, r031C);
                           ir_expression *const r031E = expr(ir_unop_i2u, r031D);
                           body.emit(assign(r0307, bit_or(r0307, r031E), 0x01));


                        body.instructions = f030C_parent_instructions;
                        body.emit(f030C);

                        /* END IF */

                        body.emit(assign(r02EF, r0309, 0x01));

                        body.emit(assign(r02F0, r0308, 0x01));

                        body.emit(assign(r02F1, r0307, 0x01));

                        body.emit(assign(r02EE, body.constant(int(0)), 0x01));

                        body.emit(assign(r02F4, less(r0307, body.constant(0u)), 0x01));


                     body.instructions = f0303_parent_instructions;
                     body.emit(f0303);

                     /* END IF */


                  body.instructions = f0300_parent_instructions;
                  body.emit(f0300);

                  /* END IF */


               body.instructions = f02F6_parent_instructions;
               body.emit(f02F6);

               /* END IF */

               /* IF CONDITION */
               ir_if *f031F = new(mem_ctx) ir_if(operand(r02F2).val);
               exec_list *const f031F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f031F->then_instructions;

                  /* IF CONDITION */
                  ir_if *f0320 = new(mem_ctx) ir_if(operand(r02F4).val);
                  exec_list *const f0320_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0320->then_instructions;

                     ir_variable *const r0321 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r0321, add(r02F0, body.constant(1u)), 0x01));

                     ir_expression *const r0322 = less(r0321, r02F0);
                     ir_expression *const r0323 = expr(ir_unop_b2i, r0322);
                     ir_expression *const r0324 = expr(ir_unop_i2u, r0323);
                     body.emit(assign(r02EF, add(r02EF, r0324), 0x01));

                     ir_expression *const r0325 = equal(r02F1, body.constant(0u));
                     ir_expression *const r0326 = expr(ir_unop_b2i, r0325);
                     ir_expression *const r0327 = expr(ir_unop_i2u, r0326);
                     ir_expression *const r0328 = add(r02F1, r0327);
                     ir_expression *const r0329 = bit_and(r0328, body.constant(1u));
                     ir_expression *const r032A = expr(ir_unop_bit_not, r0329);
                     body.emit(assign(r02F0, bit_and(r0321, r032A), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0320->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r032C = bit_or(r02EF, r02F0);
                     ir_expression *const r032D = equal(r032C, body.constant(0u));
                     ir_if *f032B = new(mem_ctx) ir_if(operand(r032D).val);
                     exec_list *const f032B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f032B->then_instructions;

                        body.emit(assign(r02EE, body.constant(int(0)), 0x01));


                     body.instructions = f032B_parent_instructions;
                     body.emit(f032B);

                     /* END IF */


                  body.instructions = f0320_parent_instructions;
                  body.emit(f0320);

                  /* END IF */

                  ir_variable *const r032E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r032E);
                  ir_expression *const r032F = lshift(r0224, body.constant(int(31)));
                  ir_expression *const r0330 = expr(ir_unop_i2u, r02EE);
                  ir_expression *const r0331 = lshift(r0330, body.constant(int(20)));
                  ir_expression *const r0332 = add(r032F, r0331);
                  body.emit(assign(r032E, add(r0332, r02EF), 0x02));

                  body.emit(assign(r032E, r02F0, 0x01));

                  body.emit(assign(r02F3, r032E, 0x03));

                  body.emit(assign(r02F2, body.constant(false), 0x01));


               body.instructions = f031F_parent_instructions;
               body.emit(f031F);

               /* END IF */

               body.emit(assign(r0226, r02F3, 0x03));

               body.emit(assign(r0225, body.constant(false), 0x01));


            body.instructions = f02E5_parent_instructions;
            body.emit(f02E5);

            /* END IF */


         body.instructions = f02BB_parent_instructions;
         body.emit(f02BB);

         /* END IF */


      body.instructions = f0277_parent_instructions;
      body.emit(f0277);

      /* END IF */


   body.instructions = f0236_parent_instructions;
   body.emit(f0236);

   /* END IF */

   /* IF CONDITION */
   ir_if *f0333 = new(mem_ctx) ir_if(operand(r0225).val);
   exec_list *const f0333_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0333->then_instructions;

      body.emit(assign(r0229, bit_or(swizzle_y(r0229), body.constant(1048576u)), 0x02));

      ir_variable *const r0334 = body.make_temp(glsl_type::uint_type, "z0Ptr");
      ir_variable *const r0335 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r0335, add(swizzle_x(r0229), swizzle_x(r0228)), 0x01));

      ir_expression *const r0336 = add(swizzle_y(r0229), swizzle_y(r0228));
      ir_expression *const r0337 = less(r0335, swizzle_x(r0229));
      ir_expression *const r0338 = expr(ir_unop_b2i, r0337);
      ir_expression *const r0339 = expr(ir_unop_i2u, r0338);
      body.emit(assign(r0334, add(r0336, r0339), 0x01));

      body.emit(assign(r022C, r0334, 0x01));

      body.emit(assign(r022A, add(r022A, body.constant(int(-1))), 0x01));

      /* IF CONDITION */
      ir_expression *const r033B = less(r0334, body.constant(2097152u));
      ir_if *f033A = new(mem_ctx) ir_if(operand(r033B).val);
      exec_list *const f033A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f033A->then_instructions;

         ir_variable *const r033C = body.make_temp(glsl_type::int_type, "zExp");
         body.emit(assign(r033C, r022A, 0x01));

         ir_variable *const r033D = body.make_temp(glsl_type::uint_type, "zFrac0");
         body.emit(assign(r033D, r0334, 0x01));

         ir_variable *const r033E = body.make_temp(glsl_type::uint_type, "zFrac1");
         body.emit(assign(r033E, r0335, 0x01));

         ir_variable *const r033F = body.make_temp(glsl_type::uint_type, "zFrac2");
         body.emit(assign(r033F, r022B, 0x01));

         ir_variable *const r0340 = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r0340, body.constant(true), 0x01));

         ir_variable *const r0341 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r0342 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
         body.emit(r0342);
         ir_expression *const r0343 = expr(ir_unop_u2i, r022B);
         body.emit(assign(r0342, less(r0343, body.constant(int(0))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0345 = lequal(body.constant(int(2045)), r022A);
         ir_if *f0344 = new(mem_ctx) ir_if(operand(r0345).val);
         exec_list *const f0344_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0344->then_instructions;

            ir_variable *const r0346 = body.make_temp(glsl_type::bool_type, "or_tmp");
            /* IF CONDITION */
            ir_expression *const r0348 = less(body.constant(int(2045)), r022A);
            ir_if *f0347 = new(mem_ctx) ir_if(operand(r0348).val);
            exec_list *const f0347_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0347->then_instructions;

               body.emit(assign(r0346, body.constant(true), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0347->else_instructions;

               ir_variable *const r0349 = body.make_temp(glsl_type::bool_type, "and_tmp");
               /* IF CONDITION */
               ir_expression *const r034B = equal(r022A, body.constant(int(2045)));
               ir_if *f034A = new(mem_ctx) ir_if(operand(r034B).val);
               exec_list *const f034A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f034A->then_instructions;

                  ir_expression *const r034C = equal(body.constant(2097151u), r0334);
                  ir_expression *const r034D = equal(body.constant(4294967295u), r0335);
                  body.emit(assign(r0349, logic_and(r034C, r034D), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f034A->else_instructions;

                  body.emit(assign(r0349, body.constant(false), 0x01));


               body.instructions = f034A_parent_instructions;
               body.emit(f034A);

               /* END IF */

               body.emit(assign(r0346, logic_and(r0349, r0342), 0x01));


            body.instructions = f0347_parent_instructions;
            body.emit(f0347);

            /* END IF */

            /* IF CONDITION */
            ir_if *f034E = new(mem_ctx) ir_if(operand(r0346).val);
            exec_list *const f034E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f034E->then_instructions;

               ir_variable *const r034F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r034F);
               ir_expression *const r0350 = lshift(r0224, body.constant(int(31)));
               body.emit(assign(r034F, add(r0350, body.constant(2146435072u)), 0x02));

               body.emit(assign(r034F, body.constant(0u), 0x01));

               body.emit(assign(r0341, r034F, 0x03));

               body.emit(assign(r0340, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f034E->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0352 = less(r022A, body.constant(int(0)));
               ir_if *f0351 = new(mem_ctx) ir_if(operand(r0352).val);
               exec_list *const f0351_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0351->then_instructions;

                  ir_variable *const r0353 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r0353, r022B, 0x01));

                  ir_variable *const r0354 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r0354, neg(r022A), 0x01));

                  ir_variable *const r0355 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r0355);
                  ir_variable *const r0356 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r0356);
                  ir_variable *const r0357 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r0357);
                  ir_variable *const r0358 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r0359 = neg(r0354);
                  body.emit(assign(r0358, bit_and(r0359, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r035B = equal(r0354, body.constant(int(0)));
                  ir_if *f035A = new(mem_ctx) ir_if(operand(r035B).val);
                  exec_list *const f035A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f035A->then_instructions;

                     body.emit(assign(r0355, r022B, 0x01));

                     body.emit(assign(r0356, r0335, 0x01));

                     body.emit(assign(r0357, r0334, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f035A->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r035D = less(r0354, body.constant(int(32)));
                     ir_if *f035C = new(mem_ctx) ir_if(operand(r035D).val);
                     exec_list *const f035C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f035C->then_instructions;

                        body.emit(assign(r0355, lshift(r0335, r0358), 0x01));

                        ir_expression *const r035E = lshift(r0334, r0358);
                        ir_expression *const r035F = rshift(r0335, r0354);
                        body.emit(assign(r0356, bit_or(r035E, r035F), 0x01));

                        body.emit(assign(r0357, rshift(r0334, r0354), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f035C->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0361 = equal(r0354, body.constant(int(32)));
                        ir_if *f0360 = new(mem_ctx) ir_if(operand(r0361).val);
                        exec_list *const f0360_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0360->then_instructions;

                           body.emit(assign(r0355, r0335, 0x01));

                           body.emit(assign(r0356, r0334, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0360->else_instructions;

                           body.emit(assign(r0353, bit_or(r022B, r0335), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0363 = less(r0354, body.constant(int(64)));
                           ir_if *f0362 = new(mem_ctx) ir_if(operand(r0363).val);
                           exec_list *const f0362_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0362->then_instructions;

                              body.emit(assign(r0355, lshift(r0334, r0358), 0x01));

                              ir_expression *const r0364 = bit_and(r0354, body.constant(int(31)));
                              body.emit(assign(r0356, rshift(r0334, r0364), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0362->else_instructions;

                              ir_variable *const r0365 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0367 = equal(r0354, body.constant(int(64)));
                              ir_if *f0366 = new(mem_ctx) ir_if(operand(r0367).val);
                              exec_list *const f0366_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0366->then_instructions;

                                 body.emit(assign(r0365, r0334, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0366->else_instructions;

                                 ir_expression *const r0368 = nequal(r0334, body.constant(0u));
                                 ir_expression *const r0369 = expr(ir_unop_b2i, r0368);
                                 body.emit(assign(r0365, expr(ir_unop_i2u, r0369), 0x01));


                              body.instructions = f0366_parent_instructions;
                              body.emit(f0366);

                              /* END IF */

                              body.emit(assign(r0355, r0365, 0x01));

                              body.emit(assign(r0356, body.constant(0u), 0x01));


                           body.instructions = f0362_parent_instructions;
                           body.emit(f0362);

                           /* END IF */


                        body.instructions = f0360_parent_instructions;
                        body.emit(f0360);

                        /* END IF */

                        body.emit(assign(r0357, body.constant(0u), 0x01));


                     body.instructions = f035C_parent_instructions;
                     body.emit(f035C);

                     /* END IF */

                     ir_expression *const r036A = nequal(r0353, body.constant(0u));
                     ir_expression *const r036B = expr(ir_unop_b2i, r036A);
                     ir_expression *const r036C = expr(ir_unop_i2u, r036B);
                     body.emit(assign(r0355, bit_or(r0355, r036C), 0x01));


                  body.instructions = f035A_parent_instructions;
                  body.emit(f035A);

                  /* END IF */

                  body.emit(assign(r033D, r0357, 0x01));

                  body.emit(assign(r033E, r0356, 0x01));

                  body.emit(assign(r033F, r0355, 0x01));

                  body.emit(assign(r033C, body.constant(int(0)), 0x01));

                  body.emit(assign(r0342, less(r0355, body.constant(0u)), 0x01));


               body.instructions = f0351_parent_instructions;
               body.emit(f0351);

               /* END IF */


            body.instructions = f034E_parent_instructions;
            body.emit(f034E);

            /* END IF */


         body.instructions = f0344_parent_instructions;
         body.emit(f0344);

         /* END IF */

         /* IF CONDITION */
         ir_if *f036D = new(mem_ctx) ir_if(operand(r0340).val);
         exec_list *const f036D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f036D->then_instructions;

            /* IF CONDITION */
            ir_if *f036E = new(mem_ctx) ir_if(operand(r0342).val);
            exec_list *const f036E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f036E->then_instructions;

               ir_variable *const r036F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r036F, add(r033E, body.constant(1u)), 0x01));

               ir_expression *const r0370 = less(r036F, r033E);
               ir_expression *const r0371 = expr(ir_unop_b2i, r0370);
               ir_expression *const r0372 = expr(ir_unop_i2u, r0371);
               body.emit(assign(r033D, add(r033D, r0372), 0x01));

               ir_expression *const r0373 = equal(r033F, body.constant(0u));
               ir_expression *const r0374 = expr(ir_unop_b2i, r0373);
               ir_expression *const r0375 = expr(ir_unop_i2u, r0374);
               ir_expression *const r0376 = add(r033F, r0375);
               ir_expression *const r0377 = bit_and(r0376, body.constant(1u));
               ir_expression *const r0378 = expr(ir_unop_bit_not, r0377);
               body.emit(assign(r033E, bit_and(r036F, r0378), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f036E->else_instructions;

               /* IF CONDITION */
               ir_expression *const r037A = bit_or(r033D, r033E);
               ir_expression *const r037B = equal(r037A, body.constant(0u));
               ir_if *f0379 = new(mem_ctx) ir_if(operand(r037B).val);
               exec_list *const f0379_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0379->then_instructions;

                  body.emit(assign(r033C, body.constant(int(0)), 0x01));


               body.instructions = f0379_parent_instructions;
               body.emit(f0379);

               /* END IF */


            body.instructions = f036E_parent_instructions;
            body.emit(f036E);

            /* END IF */

            ir_variable *const r037C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r037C);
            ir_expression *const r037D = lshift(r0224, body.constant(int(31)));
            ir_expression *const r037E = expr(ir_unop_i2u, r033C);
            ir_expression *const r037F = lshift(r037E, body.constant(int(20)));
            ir_expression *const r0380 = add(r037D, r037F);
            body.emit(assign(r037C, add(r0380, r033D), 0x02));

            body.emit(assign(r037C, r033E, 0x01));

            body.emit(assign(r0341, r037C, 0x03));

            body.emit(assign(r0340, body.constant(false), 0x01));


         body.instructions = f036D_parent_instructions;
         body.emit(f036D);

         /* END IF */

         body.emit(assign(r0226, r0341, 0x03));

         body.emit(assign(r0225, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f033A->else_instructions;

         body.emit(assign(r022A, add(r022A, body.constant(int(1))), 0x01));

         ir_variable *const r0381 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
         body.emit(r0381);
         ir_variable *const r0382 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r0382);
         ir_variable *const r0383 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r0383);
         body.emit(assign(r0381, lshift(r0335, body.constant(int(31))), 0x01));

         ir_expression *const r0384 = lshift(r0334, body.constant(int(31)));
         ir_expression *const r0385 = rshift(r0335, body.constant(int(1)));
         body.emit(assign(r0382, bit_or(r0384, r0385), 0x01));

         body.emit(assign(r0383, rshift(r0334, body.constant(int(1))), 0x01));

         ir_expression *const r0386 = nequal(r022B, body.constant(0u));
         ir_expression *const r0387 = expr(ir_unop_b2i, r0386);
         ir_expression *const r0388 = expr(ir_unop_i2u, r0387);
         body.emit(assign(r0381, bit_or(r0381, r0388), 0x01));

         body.emit(assign(r022C, r0383, 0x01));

         body.emit(assign(r022B, r0381, 0x01));

         ir_variable *const r0389 = body.make_temp(glsl_type::int_type, "zExp");
         body.emit(assign(r0389, r022A, 0x01));

         ir_variable *const r038A = body.make_temp(glsl_type::uint_type, "zFrac0");
         body.emit(assign(r038A, r0383, 0x01));

         ir_variable *const r038B = body.make_temp(glsl_type::uint_type, "zFrac1");
         body.emit(assign(r038B, r0382, 0x01));

         ir_variable *const r038C = body.make_temp(glsl_type::uint_type, "zFrac2");
         body.emit(assign(r038C, r0381, 0x01));

         ir_variable *const r038D = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r038D, body.constant(true), 0x01));

         ir_variable *const r038E = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r038F = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
         body.emit(r038F);
         ir_expression *const r0390 = expr(ir_unop_u2i, r0381);
         body.emit(assign(r038F, less(r0390, body.constant(int(0))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0392 = lequal(body.constant(int(2045)), r022A);
         ir_if *f0391 = new(mem_ctx) ir_if(operand(r0392).val);
         exec_list *const f0391_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0391->then_instructions;

            ir_variable *const r0393 = body.make_temp(glsl_type::bool_type, "or_tmp");
            /* IF CONDITION */
            ir_expression *const r0395 = less(body.constant(int(2045)), r022A);
            ir_if *f0394 = new(mem_ctx) ir_if(operand(r0395).val);
            exec_list *const f0394_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0394->then_instructions;

               body.emit(assign(r0393, body.constant(true), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0394->else_instructions;

               ir_variable *const r0396 = body.make_temp(glsl_type::bool_type, "and_tmp");
               /* IF CONDITION */
               ir_expression *const r0398 = equal(r022A, body.constant(int(2045)));
               ir_if *f0397 = new(mem_ctx) ir_if(operand(r0398).val);
               exec_list *const f0397_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0397->then_instructions;

                  ir_expression *const r0399 = equal(body.constant(2097151u), r0383);
                  ir_expression *const r039A = equal(body.constant(4294967295u), r0382);
                  body.emit(assign(r0396, logic_and(r0399, r039A), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0397->else_instructions;

                  body.emit(assign(r0396, body.constant(false), 0x01));


               body.instructions = f0397_parent_instructions;
               body.emit(f0397);

               /* END IF */

               body.emit(assign(r0393, logic_and(r0396, r038F), 0x01));


            body.instructions = f0394_parent_instructions;
            body.emit(f0394);

            /* END IF */

            /* IF CONDITION */
            ir_if *f039B = new(mem_ctx) ir_if(operand(r0393).val);
            exec_list *const f039B_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f039B->then_instructions;

               ir_variable *const r039C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r039C);
               ir_expression *const r039D = lshift(r0224, body.constant(int(31)));
               body.emit(assign(r039C, add(r039D, body.constant(2146435072u)), 0x02));

               body.emit(assign(r039C, body.constant(0u), 0x01));

               body.emit(assign(r038E, r039C, 0x03));

               body.emit(assign(r038D, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f039B->else_instructions;

               /* IF CONDITION */
               ir_expression *const r039F = less(r022A, body.constant(int(0)));
               ir_if *f039E = new(mem_ctx) ir_if(operand(r039F).val);
               exec_list *const f039E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f039E->then_instructions;

                  ir_variable *const r03A0 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r03A0, r0381, 0x01));

                  ir_variable *const r03A1 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r03A1, neg(r022A), 0x01));

                  ir_variable *const r03A2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r03A2);
                  ir_variable *const r03A3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r03A3);
                  ir_variable *const r03A4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r03A4);
                  ir_variable *const r03A5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r03A6 = neg(r03A1);
                  body.emit(assign(r03A5, bit_and(r03A6, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r03A8 = equal(r03A1, body.constant(int(0)));
                  ir_if *f03A7 = new(mem_ctx) ir_if(operand(r03A8).val);
                  exec_list *const f03A7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f03A7->then_instructions;

                     body.emit(assign(r03A2, r0381, 0x01));

                     body.emit(assign(r03A3, r0382, 0x01));

                     body.emit(assign(r03A4, r0383, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f03A7->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r03AA = less(r03A1, body.constant(int(32)));
                     ir_if *f03A9 = new(mem_ctx) ir_if(operand(r03AA).val);
                     exec_list *const f03A9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f03A9->then_instructions;

                        body.emit(assign(r03A2, lshift(r0382, r03A5), 0x01));

                        ir_expression *const r03AB = lshift(r0383, r03A5);
                        ir_expression *const r03AC = rshift(r0382, r03A1);
                        body.emit(assign(r03A3, bit_or(r03AB, r03AC), 0x01));

                        body.emit(assign(r03A4, rshift(r0383, r03A1), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f03A9->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r03AE = equal(r03A1, body.constant(int(32)));
                        ir_if *f03AD = new(mem_ctx) ir_if(operand(r03AE).val);
                        exec_list *const f03AD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f03AD->then_instructions;

                           body.emit(assign(r03A2, r0382, 0x01));

                           body.emit(assign(r03A3, r0383, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f03AD->else_instructions;

                           body.emit(assign(r03A0, bit_or(r0381, r0382), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r03B0 = less(r03A1, body.constant(int(64)));
                           ir_if *f03AF = new(mem_ctx) ir_if(operand(r03B0).val);
                           exec_list *const f03AF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f03AF->then_instructions;

                              body.emit(assign(r03A2, lshift(r0383, r03A5), 0x01));

                              ir_expression *const r03B1 = bit_and(r03A1, body.constant(int(31)));
                              body.emit(assign(r03A3, rshift(r0383, r03B1), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f03AF->else_instructions;

                              ir_variable *const r03B2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r03B4 = equal(r03A1, body.constant(int(64)));
                              ir_if *f03B3 = new(mem_ctx) ir_if(operand(r03B4).val);
                              exec_list *const f03B3_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f03B3->then_instructions;

                                 body.emit(assign(r03B2, r0383, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f03B3->else_instructions;

                                 ir_expression *const r03B5 = nequal(r0383, body.constant(0u));
                                 ir_expression *const r03B6 = expr(ir_unop_b2i, r03B5);
                                 body.emit(assign(r03B2, expr(ir_unop_i2u, r03B6), 0x01));


                              body.instructions = f03B3_parent_instructions;
                              body.emit(f03B3);

                              /* END IF */

                              body.emit(assign(r03A2, r03B2, 0x01));

                              body.emit(assign(r03A3, body.constant(0u), 0x01));


                           body.instructions = f03AF_parent_instructions;
                           body.emit(f03AF);

                           /* END IF */


                        body.instructions = f03AD_parent_instructions;
                        body.emit(f03AD);

                        /* END IF */

                        body.emit(assign(r03A4, body.constant(0u), 0x01));


                     body.instructions = f03A9_parent_instructions;
                     body.emit(f03A9);

                     /* END IF */

                     ir_expression *const r03B7 = nequal(r03A0, body.constant(0u));
                     ir_expression *const r03B8 = expr(ir_unop_b2i, r03B7);
                     ir_expression *const r03B9 = expr(ir_unop_i2u, r03B8);
                     body.emit(assign(r03A2, bit_or(r03A2, r03B9), 0x01));


                  body.instructions = f03A7_parent_instructions;
                  body.emit(f03A7);

                  /* END IF */

                  body.emit(assign(r038A, r03A4, 0x01));

                  body.emit(assign(r038B, r03A3, 0x01));

                  body.emit(assign(r038C, r03A2, 0x01));

                  body.emit(assign(r0389, body.constant(int(0)), 0x01));

                  body.emit(assign(r038F, less(r03A2, body.constant(0u)), 0x01));


               body.instructions = f039E_parent_instructions;
               body.emit(f039E);

               /* END IF */


            body.instructions = f039B_parent_instructions;
            body.emit(f039B);

            /* END IF */


         body.instructions = f0391_parent_instructions;
         body.emit(f0391);

         /* END IF */

         /* IF CONDITION */
         ir_if *f03BA = new(mem_ctx) ir_if(operand(r038D).val);
         exec_list *const f03BA_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f03BA->then_instructions;

            /* IF CONDITION */
            ir_if *f03BB = new(mem_ctx) ir_if(operand(r038F).val);
            exec_list *const f03BB_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f03BB->then_instructions;

               ir_variable *const r03BC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r03BC, add(r038B, body.constant(1u)), 0x01));

               ir_expression *const r03BD = less(r03BC, r038B);
               ir_expression *const r03BE = expr(ir_unop_b2i, r03BD);
               ir_expression *const r03BF = expr(ir_unop_i2u, r03BE);
               body.emit(assign(r038A, add(r038A, r03BF), 0x01));

               ir_expression *const r03C0 = equal(r038C, body.constant(0u));
               ir_expression *const r03C1 = expr(ir_unop_b2i, r03C0);
               ir_expression *const r03C2 = expr(ir_unop_i2u, r03C1);
               ir_expression *const r03C3 = add(r038C, r03C2);
               ir_expression *const r03C4 = bit_and(r03C3, body.constant(1u));
               ir_expression *const r03C5 = expr(ir_unop_bit_not, r03C4);
               body.emit(assign(r038B, bit_and(r03BC, r03C5), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f03BB->else_instructions;

               /* IF CONDITION */
               ir_expression *const r03C7 = bit_or(r038A, r038B);
               ir_expression *const r03C8 = equal(r03C7, body.constant(0u));
               ir_if *f03C6 = new(mem_ctx) ir_if(operand(r03C8).val);
               exec_list *const f03C6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f03C6->then_instructions;

                  body.emit(assign(r0389, body.constant(int(0)), 0x01));


               body.instructions = f03C6_parent_instructions;
               body.emit(f03C6);

               /* END IF */


            body.instructions = f03BB_parent_instructions;
            body.emit(f03BB);

            /* END IF */

            ir_variable *const r03C9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r03C9);
            ir_expression *const r03CA = lshift(r0224, body.constant(int(31)));
            ir_expression *const r03CB = expr(ir_unop_i2u, r0389);
            ir_expression *const r03CC = lshift(r03CB, body.constant(int(20)));
            ir_expression *const r03CD = add(r03CA, r03CC);
            body.emit(assign(r03C9, add(r03CD, r038A), 0x02));

            body.emit(assign(r03C9, r038B, 0x01));

            body.emit(assign(r038E, r03C9, 0x03));

            body.emit(assign(r038D, body.constant(false), 0x01));


         body.instructions = f03BA_parent_instructions;
         body.emit(f03BA);

         /* END IF */

         body.emit(assign(r0226, r038E, 0x03));

         body.emit(assign(r0225, body.constant(false), 0x01));


      body.instructions = f033A_parent_instructions;
      body.emit(f033A);

      /* END IF */


   body.instructions = f0333_parent_instructions;
   body.emit(f0333);

   /* END IF */

   body.emit(ret(r0226));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
subFloat64Fracs(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r03CE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r03CE);
   ir_variable *const r03CF = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r03CF);
   ir_variable *const r03D0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r03D0);
   ir_variable *const r03D1 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r03D2 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
   body.emit(r03D2);
   ir_variable *const r03D3 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
   body.emit(r03D3);
   ir_variable *const r03D4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
   body.emit(r03D4);
   ir_variable *const r03D5 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r03D5);
   ir_variable *const r03D6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
   body.emit(r03D6);
   ir_variable *const r03D7 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r03D7);
   ir_variable *const r03D8 = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
   body.emit(assign(r03D8, bit_and(swizzle_y(r03CE), body.constant(1048575u)), 0x01));

   body.emit(assign(r03D8, swizzle_x(r03CE), 0x02));

   ir_variable *const r03D9 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r03DA = rshift(swizzle_y(r03CE), body.constant(int(20)));
   ir_expression *const r03DB = bit_and(r03DA, body.constant(2047u));
   body.emit(assign(r03D9, expr(ir_unop_u2i, r03DB), 0x01));

   body.emit(assign(r03D5, r03D9, 0x01));

   ir_variable *const r03DC = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
   body.emit(assign(r03DC, bit_and(swizzle_y(r03CF), body.constant(1048575u)), 0x01));

   body.emit(assign(r03DC, swizzle_x(r03CF), 0x02));

   ir_variable *const r03DD = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r03DE = rshift(swizzle_y(r03CF), body.constant(int(20)));
   ir_expression *const r03DF = bit_and(r03DE, body.constant(2047u));
   body.emit(assign(r03DD, expr(ir_unop_u2i, r03DF), 0x01));

   body.emit(assign(r03D3, r03DD, 0x01));

   body.emit(assign(r03D2, sub(r03D9, r03DD), 0x01));

   ir_variable *const r03E0 = body.make_temp(glsl_type::uint_type, "z1Ptr");
   body.emit(assign(r03E0, lshift(swizzle_x(r03D8), body.constant(int(10))), 0x01));

   ir_variable *const r03E1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
   ir_expression *const r03E2 = lshift(swizzle_x(r03CE), body.constant(int(10)));
   ir_expression *const r03E3 = rshift(swizzle_x(r03D8), body.constant(int(22)));
   body.emit(assign(r03E1, bit_or(r03E2, r03E3), 0x01));

   body.emit(assign(r03D6, r03E1, 0x02));

   body.emit(assign(r03D6, r03E0, 0x01));

   ir_variable *const r03E4 = body.make_temp(glsl_type::uint_type, "z1Ptr");
   body.emit(assign(r03E4, lshift(swizzle_x(r03DC), body.constant(int(10))), 0x01));

   ir_variable *const r03E5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
   ir_expression *const r03E6 = lshift(swizzle_x(r03CF), body.constant(int(10)));
   ir_expression *const r03E7 = rshift(swizzle_x(r03DC), body.constant(int(22)));
   body.emit(assign(r03E5, bit_or(r03E6, r03E7), 0x01));

   body.emit(assign(r03D4, r03E5, 0x02));

   body.emit(assign(r03D4, r03E4, 0x01));

   /* IF CONDITION */
   ir_expression *const r03E9 = less(body.constant(int(0)), r03D2);
   ir_if *f03E8 = new(mem_ctx) ir_if(operand(r03E9).val);
   exec_list *const f03E8_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f03E8->then_instructions;

      /* IF CONDITION */
      ir_expression *const r03EB = equal(r03D9, body.constant(int(2047)));
      ir_if *f03EA = new(mem_ctx) ir_if(operand(r03EB).val);
      exec_list *const f03EA_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f03EA->then_instructions;

         /* IF CONDITION */
         ir_expression *const r03ED = bit_or(r03E1, r03E0);
         ir_expression *const r03EE = nequal(r03ED, body.constant(0u));
         ir_if *f03EC = new(mem_ctx) ir_if(operand(r03EE).val);
         exec_list *const f03EC_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f03EC->then_instructions;

            ir_variable *const r03EF = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r03EF, swizzle_y(r03CE), 0x02));

            ir_variable *const r03F0 = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r03F0, swizzle_y(r03CF), 0x02));

            ir_variable *const r03F1 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r03F2 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r03F3 = rshift(swizzle_x(r03CE), body.constant(int(19)));
            ir_expression *const r03F4 = bit_and(r03F3, body.constant(4095u));
            ir_expression *const r03F5 = equal(r03F4, body.constant(4094u));
            ir_expression *const r03F6 = nequal(swizzle_y(r03CE), body.constant(0u));
            ir_expression *const r03F7 = bit_and(swizzle_x(r03CE), body.constant(524287u));
            ir_expression *const r03F8 = nequal(r03F7, body.constant(0u));
            ir_expression *const r03F9 = logic_or(r03F6, r03F8);
            body.emit(assign(r03F2, logic_and(r03F5, r03F9), 0x01));

            ir_variable *const r03FA = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r03FB = lshift(swizzle_x(r03CF), body.constant(int(1)));
            ir_expression *const r03FC = lequal(body.constant(4292870144u), r03FB);
            ir_expression *const r03FD = nequal(swizzle_y(r03CF), body.constant(0u));
            ir_expression *const r03FE = bit_and(swizzle_x(r03CF), body.constant(1048575u));
            ir_expression *const r03FF = nequal(r03FE, body.constant(0u));
            ir_expression *const r0400 = logic_or(r03FD, r03FF);
            body.emit(assign(r03FA, logic_and(r03FC, r0400), 0x01));

            body.emit(assign(r03EF, bit_or(swizzle_x(r03CE), body.constant(524288u)), 0x01));

            body.emit(assign(r03F0, bit_or(swizzle_x(r03CF), body.constant(524288u)), 0x01));

            /* IF CONDITION */
            ir_expression *const r0402 = lshift(swizzle_x(r03CE), body.constant(int(1)));
            ir_expression *const r0403 = lequal(body.constant(4292870144u), r0402);
            ir_expression *const r0404 = nequal(swizzle_y(r03CE), body.constant(0u));
            ir_expression *const r0405 = bit_and(swizzle_x(r03CE), body.constant(1048575u));
            ir_expression *const r0406 = nequal(r0405, body.constant(0u));
            ir_expression *const r0407 = logic_or(r0404, r0406);
            ir_expression *const r0408 = logic_and(r0403, r0407);
            ir_if *f0401 = new(mem_ctx) ir_if(operand(r0408).val);
            exec_list *const f0401_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0401->then_instructions;

               ir_variable *const r0409 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r040B = logic_and(r03F2, r03FA);
               ir_if *f040A = new(mem_ctx) ir_if(operand(r040B).val);
               exec_list *const f040A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f040A->then_instructions;

                  body.emit(assign(r0409, r03F0, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f040A->else_instructions;

                  body.emit(assign(r0409, r03EF, 0x03));


               body.instructions = f040A_parent_instructions;
               body.emit(f040A);

               /* END IF */

               body.emit(assign(r03F1, r0409, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0401->else_instructions;

               body.emit(assign(r03F1, r03F0, 0x03));


            body.instructions = f0401_parent_instructions;
            body.emit(f0401);

            /* END IF */

            body.emit(assign(r03D1, r03F1, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f03EC->else_instructions;

            body.emit(assign(r03D1, r03CE, 0x03));


         body.instructions = f03EC_parent_instructions;
         body.emit(f03EC);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f03EA->else_instructions;

         /* IF CONDITION */
         ir_expression *const r040D = equal(r03DD, body.constant(int(0)));
         ir_if *f040C = new(mem_ctx) ir_if(operand(r040D).val);
         exec_list *const f040C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f040C->then_instructions;

            body.emit(assign(r03D2, add(r03D2, body.constant(int(-1))), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f040C->else_instructions;

            body.emit(assign(r03D4, bit_or(r03E5, body.constant(1073741824u)), 0x02));


         body.instructions = f040C_parent_instructions;
         body.emit(f040C);

         /* END IF */

         ir_variable *const r040E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
         body.emit(r040E);
         ir_variable *const r040F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
         body.emit(r040F);
         ir_variable *const r0410 = body.make_temp(glsl_type::int_type, "assignment_tmp");
         ir_expression *const r0411 = neg(r03D2);
         body.emit(assign(r0410, bit_and(r0411, body.constant(int(31))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0413 = equal(r03D2, body.constant(int(0)));
         ir_if *f0412 = new(mem_ctx) ir_if(operand(r0413).val);
         exec_list *const f0412_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0412->then_instructions;

            body.emit(assign(r040E, swizzle_x(r03D4), 0x01));

            body.emit(assign(r040F, swizzle_y(r03D4), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0412->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0415 = less(r03D2, body.constant(int(32)));
            ir_if *f0414 = new(mem_ctx) ir_if(operand(r0415).val);
            exec_list *const f0414_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0414->then_instructions;

               ir_expression *const r0416 = lshift(swizzle_y(r03D4), r0410);
               ir_expression *const r0417 = rshift(r03E4, r03D2);
               ir_expression *const r0418 = bit_or(r0416, r0417);
               ir_expression *const r0419 = lshift(r03E4, r0410);
               ir_expression *const r041A = nequal(r0419, body.constant(0u));
               ir_expression *const r041B = expr(ir_unop_b2i, r041A);
               ir_expression *const r041C = expr(ir_unop_i2u, r041B);
               body.emit(assign(r040E, bit_or(r0418, r041C), 0x01));

               body.emit(assign(r040F, rshift(swizzle_y(r03D4), r03D2), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0414->else_instructions;

               /* IF CONDITION */
               ir_expression *const r041E = equal(r03D2, body.constant(int(32)));
               ir_if *f041D = new(mem_ctx) ir_if(operand(r041E).val);
               exec_list *const f041D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f041D->then_instructions;

                  ir_expression *const r041F = nequal(r03E4, body.constant(0u));
                  ir_expression *const r0420 = expr(ir_unop_b2i, r041F);
                  ir_expression *const r0421 = expr(ir_unop_i2u, r0420);
                  body.emit(assign(r040E, bit_or(swizzle_y(r03D4), r0421), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f041D->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0423 = less(r03D2, body.constant(int(64)));
                  ir_if *f0422 = new(mem_ctx) ir_if(operand(r0423).val);
                  exec_list *const f0422_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0422->then_instructions;

                     ir_expression *const r0424 = bit_and(r03D2, body.constant(int(31)));
                     ir_expression *const r0425 = rshift(swizzle_y(r03D4), r0424);
                     ir_expression *const r0426 = lshift(swizzle_y(r03D4), r0410);
                     ir_expression *const r0427 = bit_or(r0426, r03E4);
                     ir_expression *const r0428 = nequal(r0427, body.constant(0u));
                     ir_expression *const r0429 = expr(ir_unop_b2i, r0428);
                     ir_expression *const r042A = expr(ir_unop_i2u, r0429);
                     body.emit(assign(r040E, bit_or(r0425, r042A), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0422->else_instructions;

                     ir_expression *const r042B = bit_or(swizzle_y(r03D4), r03E4);
                     ir_expression *const r042C = nequal(r042B, body.constant(0u));
                     ir_expression *const r042D = expr(ir_unop_b2i, r042C);
                     body.emit(assign(r040E, expr(ir_unop_i2u, r042D), 0x01));


                  body.instructions = f0422_parent_instructions;
                  body.emit(f0422);

                  /* END IF */


               body.instructions = f041D_parent_instructions;
               body.emit(f041D);

               /* END IF */

               body.emit(assign(r040F, body.constant(0u), 0x01));


            body.instructions = f0414_parent_instructions;
            body.emit(f0414);

            /* END IF */


         body.instructions = f0412_parent_instructions;
         body.emit(f0412);

         /* END IF */

         body.emit(assign(r03D4, r040F, 0x02));

         body.emit(assign(r03D4, r040E, 0x01));

         body.emit(assign(r03D6, bit_or(r03E1, body.constant(1073741824u)), 0x02));

         ir_variable *const r042E = body.make_temp(glsl_type::uint_type, "z0Ptr");
         ir_variable *const r042F = body.make_temp(glsl_type::uint_type, "z1Ptr");
         body.emit(assign(r042F, sub(r03E0, r040E), 0x01));

         ir_expression *const r0430 = sub(swizzle_y(r03D6), r040F);
         ir_expression *const r0431 = less(r03E0, r040E);
         ir_expression *const r0432 = expr(ir_unop_b2i, r0431);
         ir_expression *const r0433 = expr(ir_unop_i2u, r0432);
         body.emit(assign(r042E, sub(r0430, r0433), 0x01));

         body.emit(assign(r03D7, add(r03D9, body.constant(int(-1))), 0x01));

         ir_variable *const r0434 = body.make_temp(glsl_type::int_type, "zExp");
         body.emit(assign(r0434, add(r03D7, body.constant(int(-10))), 0x01));

         ir_variable *const r0435 = body.make_temp(glsl_type::uint_type, "zFrac0");
         body.emit(assign(r0435, r042E, 0x01));

         ir_variable *const r0436 = body.make_temp(glsl_type::uint_type, "zFrac1");
         body.emit(assign(r0436, r042F, 0x01));

         ir_variable *const r0437 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
         body.emit(r0437);
         ir_variable *const r0438 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
         body.emit(r0438);
         /* IF CONDITION */
         ir_expression *const r043A = equal(r042E, body.constant(0u));
         ir_if *f0439 = new(mem_ctx) ir_if(operand(r043A).val);
         exec_list *const f0439_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0439->then_instructions;

            body.emit(assign(r0435, r042F, 0x01));

            body.emit(assign(r0436, body.constant(0u), 0x01));

            body.emit(assign(r0434, add(r0434, body.constant(int(-32))), 0x01));


         body.instructions = f0439_parent_instructions;
         body.emit(f0439);

         /* END IF */

         ir_variable *const r043B = body.make_temp(glsl_type::uint_type, "a");
         body.emit(assign(r043B, r0435, 0x01));

         ir_variable *const r043C = body.make_temp(glsl_type::int_type, "return_value");
         ir_variable *const r043D = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
         body.emit(r043D);
         /* IF CONDITION */
         ir_expression *const r043F = equal(r0435, body.constant(0u));
         ir_if *f043E = new(mem_ctx) ir_if(operand(r043F).val);
         exec_list *const f043E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f043E->then_instructions;

            body.emit(assign(r043C, body.constant(int(32)), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f043E->else_instructions;

            body.emit(assign(r043D, body.constant(int(0)), 0x01));

            /* IF CONDITION */
            ir_expression *const r0441 = bit_and(r0435, body.constant(4294901760u));
            ir_expression *const r0442 = equal(r0441, body.constant(0u));
            ir_if *f0440 = new(mem_ctx) ir_if(operand(r0442).val);
            exec_list *const f0440_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0440->then_instructions;

               body.emit(assign(r043D, body.constant(int(16)), 0x01));

               body.emit(assign(r043B, lshift(r0435, body.constant(int(16))), 0x01));


            body.instructions = f0440_parent_instructions;
            body.emit(f0440);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r0444 = bit_and(r043B, body.constant(4278190080u));
            ir_expression *const r0445 = equal(r0444, body.constant(0u));
            ir_if *f0443 = new(mem_ctx) ir_if(operand(r0445).val);
            exec_list *const f0443_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0443->then_instructions;

               body.emit(assign(r043D, add(r043D, body.constant(int(8))), 0x01));

               body.emit(assign(r043B, lshift(r043B, body.constant(int(8))), 0x01));


            body.instructions = f0443_parent_instructions;
            body.emit(f0443);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r0447 = bit_and(r043B, body.constant(4026531840u));
            ir_expression *const r0448 = equal(r0447, body.constant(0u));
            ir_if *f0446 = new(mem_ctx) ir_if(operand(r0448).val);
            exec_list *const f0446_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0446->then_instructions;

               body.emit(assign(r043D, add(r043D, body.constant(int(4))), 0x01));

               body.emit(assign(r043B, lshift(r043B, body.constant(int(4))), 0x01));


            body.instructions = f0446_parent_instructions;
            body.emit(f0446);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r044A = bit_and(r043B, body.constant(3221225472u));
            ir_expression *const r044B = equal(r044A, body.constant(0u));
            ir_if *f0449 = new(mem_ctx) ir_if(operand(r044B).val);
            exec_list *const f0449_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0449->then_instructions;

               body.emit(assign(r043D, add(r043D, body.constant(int(2))), 0x01));

               body.emit(assign(r043B, lshift(r043B, body.constant(int(2))), 0x01));


            body.instructions = f0449_parent_instructions;
            body.emit(f0449);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r044D = bit_and(r043B, body.constant(2147483648u));
            ir_expression *const r044E = equal(r044D, body.constant(0u));
            ir_if *f044C = new(mem_ctx) ir_if(operand(r044E).val);
            exec_list *const f044C_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f044C->then_instructions;

               body.emit(assign(r043D, add(r043D, body.constant(int(1))), 0x01));


            body.instructions = f044C_parent_instructions;
            body.emit(f044C);

            /* END IF */

            body.emit(assign(r043C, r043D, 0x01));


         body.instructions = f043E_parent_instructions;
         body.emit(f043E);

         /* END IF */

         body.emit(assign(r0438, add(r043C, body.constant(int(-11))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0450 = lequal(body.constant(int(0)), r0438);
         ir_if *f044F = new(mem_ctx) ir_if(operand(r0450).val);
         exec_list *const f044F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f044F->then_instructions;

            body.emit(assign(r0437, body.constant(0u), 0x01));

            ir_variable *const r0451 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r0451, lshift(r0436, r0438), 0x01));

            ir_variable *const r0452 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r0454 = equal(r0438, body.constant(int(0)));
            ir_if *f0453 = new(mem_ctx) ir_if(operand(r0454).val);
            exec_list *const f0453_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0453->then_instructions;

               body.emit(assign(r0452, r0435, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0453->else_instructions;

               ir_expression *const r0455 = lshift(r0435, r0438);
               ir_expression *const r0456 = neg(r0438);
               ir_expression *const r0457 = bit_and(r0456, body.constant(int(31)));
               ir_expression *const r0458 = rshift(r0436, r0457);
               body.emit(assign(r0452, bit_or(r0455, r0458), 0x01));


            body.instructions = f0453_parent_instructions;
            body.emit(f0453);

            /* END IF */

            body.emit(assign(r0435, r0452, 0x01));

            body.emit(assign(r0436, r0451, 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f044F->else_instructions;

            ir_variable *const r0459 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r0459, body.constant(0u), 0x01));

            ir_variable *const r045A = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r045A, neg(r0438), 0x01));

            ir_variable *const r045B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r045B);
            ir_variable *const r045C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r045C);
            ir_variable *const r045D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r045D);
            ir_variable *const r045E = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r045F = neg(r045A);
            body.emit(assign(r045E, bit_and(r045F, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0461 = equal(r045A, body.constant(int(0)));
            ir_if *f0460 = new(mem_ctx) ir_if(operand(r0461).val);
            exec_list *const f0460_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0460->then_instructions;

               body.emit(assign(r045B, r0459, 0x01));

               body.emit(assign(r045C, r0436, 0x01));

               body.emit(assign(r045D, r0435, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0460->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0463 = less(r045A, body.constant(int(32)));
               ir_if *f0462 = new(mem_ctx) ir_if(operand(r0463).val);
               exec_list *const f0462_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0462->then_instructions;

                  body.emit(assign(r045B, lshift(r0436, r045E), 0x01));

                  ir_expression *const r0464 = lshift(r0435, r045E);
                  ir_expression *const r0465 = rshift(r0436, r045A);
                  body.emit(assign(r045C, bit_or(r0464, r0465), 0x01));

                  body.emit(assign(r045D, rshift(r0435, r045A), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0462->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0467 = equal(r045A, body.constant(int(32)));
                  ir_if *f0466 = new(mem_ctx) ir_if(operand(r0467).val);
                  exec_list *const f0466_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0466->then_instructions;

                     body.emit(assign(r045B, r0436, 0x01));

                     body.emit(assign(r045C, r0435, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0466->else_instructions;

                     body.emit(assign(r0459, bit_or(body.constant(0u), r0436), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0469 = less(r045A, body.constant(int(64)));
                     ir_if *f0468 = new(mem_ctx) ir_if(operand(r0469).val);
                     exec_list *const f0468_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0468->then_instructions;

                        body.emit(assign(r045B, lshift(r0435, r045E), 0x01));

                        ir_expression *const r046A = bit_and(r045A, body.constant(int(31)));
                        body.emit(assign(r045C, rshift(r0435, r046A), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0468->else_instructions;

                        ir_variable *const r046B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r046D = equal(r045A, body.constant(int(64)));
                        ir_if *f046C = new(mem_ctx) ir_if(operand(r046D).val);
                        exec_list *const f046C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f046C->then_instructions;

                           body.emit(assign(r046B, r0435, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f046C->else_instructions;

                           ir_expression *const r046E = nequal(r0435, body.constant(0u));
                           ir_expression *const r046F = expr(ir_unop_b2i, r046E);
                           body.emit(assign(r046B, expr(ir_unop_i2u, r046F), 0x01));


                        body.instructions = f046C_parent_instructions;
                        body.emit(f046C);

                        /* END IF */

                        body.emit(assign(r045B, r046B, 0x01));

                        body.emit(assign(r045C, body.constant(0u), 0x01));


                     body.instructions = f0468_parent_instructions;
                     body.emit(f0468);

                     /* END IF */


                  body.instructions = f0466_parent_instructions;
                  body.emit(f0466);

                  /* END IF */

                  body.emit(assign(r045D, body.constant(0u), 0x01));


               body.instructions = f0462_parent_instructions;
               body.emit(f0462);

               /* END IF */

               ir_expression *const r0470 = nequal(r0459, body.constant(0u));
               ir_expression *const r0471 = expr(ir_unop_b2i, r0470);
               ir_expression *const r0472 = expr(ir_unop_i2u, r0471);
               body.emit(assign(r045B, bit_or(r045B, r0472), 0x01));


            body.instructions = f0460_parent_instructions;
            body.emit(f0460);

            /* END IF */

            body.emit(assign(r0435, r045D, 0x01));

            body.emit(assign(r0436, r045C, 0x01));

            body.emit(assign(r0437, r045B, 0x01));


         body.instructions = f044F_parent_instructions;
         body.emit(f044F);

         /* END IF */

         body.emit(assign(r0434, sub(r0434, r0438), 0x01));

         ir_variable *const r0473 = body.make_temp(glsl_type::int_type, "zExp");
         body.emit(assign(r0473, r0434, 0x01));

         ir_variable *const r0474 = body.make_temp(glsl_type::uint_type, "zFrac0");
         body.emit(assign(r0474, r0435, 0x01));

         ir_variable *const r0475 = body.make_temp(glsl_type::uint_type, "zFrac1");
         body.emit(assign(r0475, r0436, 0x01));

         ir_variable *const r0476 = body.make_temp(glsl_type::uint_type, "zFrac2");
         body.emit(assign(r0476, r0437, 0x01));

         ir_variable *const r0477 = body.make_temp(glsl_type::bool_type, "execute_flag");
         body.emit(assign(r0477, body.constant(true), 0x01));

         ir_variable *const r0478 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r0479 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
         body.emit(r0479);
         ir_expression *const r047A = expr(ir_unop_u2i, r0437);
         body.emit(assign(r0479, less(r047A, body.constant(int(0))), 0x01));

         /* IF CONDITION */
         ir_expression *const r047C = lequal(body.constant(int(2045)), r0434);
         ir_if *f047B = new(mem_ctx) ir_if(operand(r047C).val);
         exec_list *const f047B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f047B->then_instructions;

            ir_variable *const r047D = body.make_temp(glsl_type::bool_type, "or_tmp");
            /* IF CONDITION */
            ir_expression *const r047F = less(body.constant(int(2045)), r0434);
            ir_if *f047E = new(mem_ctx) ir_if(operand(r047F).val);
            exec_list *const f047E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f047E->then_instructions;

               body.emit(assign(r047D, body.constant(true), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f047E->else_instructions;

               ir_variable *const r0480 = body.make_temp(glsl_type::bool_type, "and_tmp");
               /* IF CONDITION */
               ir_expression *const r0482 = equal(r0434, body.constant(int(2045)));
               ir_if *f0481 = new(mem_ctx) ir_if(operand(r0482).val);
               exec_list *const f0481_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0481->then_instructions;

                  ir_expression *const r0483 = equal(body.constant(2097151u), r0435);
                  ir_expression *const r0484 = equal(body.constant(4294967295u), r0436);
                  body.emit(assign(r0480, logic_and(r0483, r0484), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0481->else_instructions;

                  body.emit(assign(r0480, body.constant(false), 0x01));


               body.instructions = f0481_parent_instructions;
               body.emit(f0481);

               /* END IF */

               body.emit(assign(r047D, logic_and(r0480, r0479), 0x01));


            body.instructions = f047E_parent_instructions;
            body.emit(f047E);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0485 = new(mem_ctx) ir_if(operand(r047D).val);
            exec_list *const f0485_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0485->then_instructions;

               ir_variable *const r0486 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0486);
               ir_expression *const r0487 = lshift(r03D0, body.constant(int(31)));
               body.emit(assign(r0486, add(r0487, body.constant(2146435072u)), 0x02));

               body.emit(assign(r0486, body.constant(0u), 0x01));

               body.emit(assign(r0478, r0486, 0x03));

               body.emit(assign(r0477, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0485->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0489 = less(r0434, body.constant(int(0)));
               ir_if *f0488 = new(mem_ctx) ir_if(operand(r0489).val);
               exec_list *const f0488_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0488->then_instructions;

                  ir_variable *const r048A = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r048A, r0437, 0x01));

                  ir_variable *const r048B = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r048B, neg(r0434), 0x01));

                  ir_variable *const r048C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r048C);
                  ir_variable *const r048D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r048D);
                  ir_variable *const r048E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r048E);
                  ir_variable *const r048F = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r0490 = neg(r048B);
                  body.emit(assign(r048F, bit_and(r0490, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0492 = equal(r048B, body.constant(int(0)));
                  ir_if *f0491 = new(mem_ctx) ir_if(operand(r0492).val);
                  exec_list *const f0491_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0491->then_instructions;

                     body.emit(assign(r048C, r0437, 0x01));

                     body.emit(assign(r048D, r0436, 0x01));

                     body.emit(assign(r048E, r0435, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0491->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0494 = less(r048B, body.constant(int(32)));
                     ir_if *f0493 = new(mem_ctx) ir_if(operand(r0494).val);
                     exec_list *const f0493_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0493->then_instructions;

                        body.emit(assign(r048C, lshift(r0436, r048F), 0x01));

                        ir_expression *const r0495 = lshift(r0435, r048F);
                        ir_expression *const r0496 = rshift(r0436, r048B);
                        body.emit(assign(r048D, bit_or(r0495, r0496), 0x01));

                        body.emit(assign(r048E, rshift(r0435, r048B), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0493->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0498 = equal(r048B, body.constant(int(32)));
                        ir_if *f0497 = new(mem_ctx) ir_if(operand(r0498).val);
                        exec_list *const f0497_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0497->then_instructions;

                           body.emit(assign(r048C, r0436, 0x01));

                           body.emit(assign(r048D, r0435, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0497->else_instructions;

                           body.emit(assign(r048A, bit_or(r0437, r0436), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r049A = less(r048B, body.constant(int(64)));
                           ir_if *f0499 = new(mem_ctx) ir_if(operand(r049A).val);
                           exec_list *const f0499_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0499->then_instructions;

                              body.emit(assign(r048C, lshift(r0435, r048F), 0x01));

                              ir_expression *const r049B = bit_and(r048B, body.constant(int(31)));
                              body.emit(assign(r048D, rshift(r0435, r049B), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0499->else_instructions;

                              ir_variable *const r049C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r049E = equal(r048B, body.constant(int(64)));
                              ir_if *f049D = new(mem_ctx) ir_if(operand(r049E).val);
                              exec_list *const f049D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f049D->then_instructions;

                                 body.emit(assign(r049C, r0435, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f049D->else_instructions;

                                 ir_expression *const r049F = nequal(r0435, body.constant(0u));
                                 ir_expression *const r04A0 = expr(ir_unop_b2i, r049F);
                                 body.emit(assign(r049C, expr(ir_unop_i2u, r04A0), 0x01));


                              body.instructions = f049D_parent_instructions;
                              body.emit(f049D);

                              /* END IF */

                              body.emit(assign(r048C, r049C, 0x01));

                              body.emit(assign(r048D, body.constant(0u), 0x01));


                           body.instructions = f0499_parent_instructions;
                           body.emit(f0499);

                           /* END IF */


                        body.instructions = f0497_parent_instructions;
                        body.emit(f0497);

                        /* END IF */

                        body.emit(assign(r048E, body.constant(0u), 0x01));


                     body.instructions = f0493_parent_instructions;
                     body.emit(f0493);

                     /* END IF */

                     ir_expression *const r04A1 = nequal(r048A, body.constant(0u));
                     ir_expression *const r04A2 = expr(ir_unop_b2i, r04A1);
                     ir_expression *const r04A3 = expr(ir_unop_i2u, r04A2);
                     body.emit(assign(r048C, bit_or(r048C, r04A3), 0x01));


                  body.instructions = f0491_parent_instructions;
                  body.emit(f0491);

                  /* END IF */

                  body.emit(assign(r0474, r048E, 0x01));

                  body.emit(assign(r0475, r048D, 0x01));

                  body.emit(assign(r0476, r048C, 0x01));

                  body.emit(assign(r0473, body.constant(int(0)), 0x01));

                  body.emit(assign(r0479, less(r048C, body.constant(0u)), 0x01));


               body.instructions = f0488_parent_instructions;
               body.emit(f0488);

               /* END IF */


            body.instructions = f0485_parent_instructions;
            body.emit(f0485);

            /* END IF */


         body.instructions = f047B_parent_instructions;
         body.emit(f047B);

         /* END IF */

         /* IF CONDITION */
         ir_if *f04A4 = new(mem_ctx) ir_if(operand(r0477).val);
         exec_list *const f04A4_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f04A4->then_instructions;

            /* IF CONDITION */
            ir_if *f04A5 = new(mem_ctx) ir_if(operand(r0479).val);
            exec_list *const f04A5_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f04A5->then_instructions;

               ir_variable *const r04A6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r04A6, add(r0475, body.constant(1u)), 0x01));

               ir_expression *const r04A7 = less(r04A6, r0475);
               ir_expression *const r04A8 = expr(ir_unop_b2i, r04A7);
               ir_expression *const r04A9 = expr(ir_unop_i2u, r04A8);
               body.emit(assign(r0474, add(r0474, r04A9), 0x01));

               ir_expression *const r04AA = equal(r0476, body.constant(0u));
               ir_expression *const r04AB = expr(ir_unop_b2i, r04AA);
               ir_expression *const r04AC = expr(ir_unop_i2u, r04AB);
               ir_expression *const r04AD = add(r0476, r04AC);
               ir_expression *const r04AE = bit_and(r04AD, body.constant(1u));
               ir_expression *const r04AF = expr(ir_unop_bit_not, r04AE);
               body.emit(assign(r0475, bit_and(r04A6, r04AF), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f04A5->else_instructions;

               /* IF CONDITION */
               ir_expression *const r04B1 = bit_or(r0474, r0475);
               ir_expression *const r04B2 = equal(r04B1, body.constant(0u));
               ir_if *f04B0 = new(mem_ctx) ir_if(operand(r04B2).val);
               exec_list *const f04B0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f04B0->then_instructions;

                  body.emit(assign(r0473, body.constant(int(0)), 0x01));


               body.instructions = f04B0_parent_instructions;
               body.emit(f04B0);

               /* END IF */


            body.instructions = f04A5_parent_instructions;
            body.emit(f04A5);

            /* END IF */

            ir_variable *const r04B3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r04B3);
            ir_expression *const r04B4 = lshift(r03D0, body.constant(int(31)));
            ir_expression *const r04B5 = expr(ir_unop_i2u, r0473);
            ir_expression *const r04B6 = lshift(r04B5, body.constant(int(20)));
            ir_expression *const r04B7 = add(r04B4, r04B6);
            body.emit(assign(r04B3, add(r04B7, r0474), 0x02));

            body.emit(assign(r04B3, r0475, 0x01));

            body.emit(assign(r0478, r04B3, 0x03));

            body.emit(assign(r0477, body.constant(false), 0x01));


         body.instructions = f04A4_parent_instructions;
         body.emit(f04A4);

         /* END IF */

         body.emit(assign(r03D1, r0478, 0x03));


      body.instructions = f03EA_parent_instructions;
      body.emit(f03EA);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f03E8->else_instructions;

      /* IF CONDITION */
      ir_expression *const r04B9 = less(r03D2, body.constant(int(0)));
      ir_if *f04B8 = new(mem_ctx) ir_if(operand(r04B9).val);
      exec_list *const f04B8_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f04B8->then_instructions;

         /* IF CONDITION */
         ir_expression *const r04BB = equal(r03DD, body.constant(int(2047)));
         ir_if *f04BA = new(mem_ctx) ir_if(operand(r04BB).val);
         exec_list *const f04BA_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f04BA->then_instructions;

            /* IF CONDITION */
            ir_expression *const r04BD = bit_or(swizzle_y(r03D4), swizzle_x(r03D4));
            ir_expression *const r04BE = nequal(r04BD, body.constant(0u));
            ir_if *f04BC = new(mem_ctx) ir_if(operand(r04BE).val);
            exec_list *const f04BC_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f04BC->then_instructions;

               ir_variable *const r04BF = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r04BF, swizzle_y(r03CE), 0x02));

               ir_variable *const r04C0 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r04C0, swizzle_y(r03CF), 0x02));

               ir_variable *const r04C1 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r04C2 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r04C3 = rshift(swizzle_x(r03CE), body.constant(int(19)));
               ir_expression *const r04C4 = bit_and(r04C3, body.constant(4095u));
               ir_expression *const r04C5 = equal(r04C4, body.constant(4094u));
               ir_expression *const r04C6 = nequal(swizzle_y(r03CE), body.constant(0u));
               ir_expression *const r04C7 = bit_and(swizzle_x(r03CE), body.constant(524287u));
               ir_expression *const r04C8 = nequal(r04C7, body.constant(0u));
               ir_expression *const r04C9 = logic_or(r04C6, r04C8);
               body.emit(assign(r04C2, logic_and(r04C5, r04C9), 0x01));

               ir_variable *const r04CA = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r04CB = lshift(swizzle_x(r03CF), body.constant(int(1)));
               ir_expression *const r04CC = lequal(body.constant(4292870144u), r04CB);
               ir_expression *const r04CD = nequal(swizzle_y(r03CF), body.constant(0u));
               ir_expression *const r04CE = bit_and(swizzle_x(r03CF), body.constant(1048575u));
               ir_expression *const r04CF = nequal(r04CE, body.constant(0u));
               ir_expression *const r04D0 = logic_or(r04CD, r04CF);
               body.emit(assign(r04CA, logic_and(r04CC, r04D0), 0x01));

               body.emit(assign(r04BF, bit_or(swizzle_x(r03CE), body.constant(524288u)), 0x01));

               body.emit(assign(r04C0, bit_or(swizzle_x(r03CF), body.constant(524288u)), 0x01));

               /* IF CONDITION */
               ir_expression *const r04D2 = lshift(swizzle_x(r03CE), body.constant(int(1)));
               ir_expression *const r04D3 = lequal(body.constant(4292870144u), r04D2);
               ir_expression *const r04D4 = nequal(swizzle_y(r03CE), body.constant(0u));
               ir_expression *const r04D5 = bit_and(swizzle_x(r03CE), body.constant(1048575u));
               ir_expression *const r04D6 = nequal(r04D5, body.constant(0u));
               ir_expression *const r04D7 = logic_or(r04D4, r04D6);
               ir_expression *const r04D8 = logic_and(r04D3, r04D7);
               ir_if *f04D1 = new(mem_ctx) ir_if(operand(r04D8).val);
               exec_list *const f04D1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f04D1->then_instructions;

                  ir_variable *const r04D9 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r04DB = logic_and(r04C2, r04CA);
                  ir_if *f04DA = new(mem_ctx) ir_if(operand(r04DB).val);
                  exec_list *const f04DA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f04DA->then_instructions;

                     body.emit(assign(r04D9, r04C0, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f04DA->else_instructions;

                     body.emit(assign(r04D9, r04BF, 0x03));


                  body.instructions = f04DA_parent_instructions;
                  body.emit(f04DA);

                  /* END IF */

                  body.emit(assign(r04C1, r04D9, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f04D1->else_instructions;

                  body.emit(assign(r04C1, r04C0, 0x03));


               body.instructions = f04D1_parent_instructions;
               body.emit(f04D1);

               /* END IF */

               body.emit(assign(r03D1, r04C1, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f04BC->else_instructions;

               ir_variable *const r04DC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r04DC);
               ir_expression *const r04DD = bit_xor(r03D0, body.constant(1u));
               ir_expression *const r04DE = lshift(r04DD, body.constant(int(31)));
               body.emit(assign(r04DC, add(r04DE, body.constant(2146435072u)), 0x02));

               body.emit(assign(r04DC, body.constant(0u), 0x01));

               body.emit(assign(r03D1, r04DC, 0x03));


            body.instructions = f04BC_parent_instructions;
            body.emit(f04BC);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f04BA->else_instructions;

            /* IF CONDITION */
            ir_expression *const r04E0 = equal(r03D9, body.constant(int(0)));
            ir_if *f04DF = new(mem_ctx) ir_if(operand(r04E0).val);
            exec_list *const f04DF_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f04DF->then_instructions;

               body.emit(assign(r03D2, add(r03D2, body.constant(int(1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f04DF->else_instructions;

               body.emit(assign(r03D6, bit_or(swizzle_y(r03D6), body.constant(1073741824u)), 0x02));


            body.instructions = f04DF_parent_instructions;
            body.emit(f04DF);

            /* END IF */

            ir_variable *const r04E1 = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r04E1, neg(r03D2), 0x01));

            ir_variable *const r04E2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r04E2);
            ir_variable *const r04E3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r04E3);
            ir_variable *const r04E4 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r04E5 = neg(r04E1);
            body.emit(assign(r04E4, bit_and(r04E5, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r04E7 = equal(r04E1, body.constant(int(0)));
            ir_if *f04E6 = new(mem_ctx) ir_if(operand(r04E7).val);
            exec_list *const f04E6_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f04E6->then_instructions;

               body.emit(assign(r04E2, swizzle_x(r03D6), 0x01));

               body.emit(assign(r04E3, swizzle_y(r03D6), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f04E6->else_instructions;

               /* IF CONDITION */
               ir_expression *const r04E9 = less(r04E1, body.constant(int(32)));
               ir_if *f04E8 = new(mem_ctx) ir_if(operand(r04E9).val);
               exec_list *const f04E8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f04E8->then_instructions;

                  ir_expression *const r04EA = lshift(swizzle_y(r03D6), r04E4);
                  ir_expression *const r04EB = rshift(r03E0, r04E1);
                  ir_expression *const r04EC = bit_or(r04EA, r04EB);
                  ir_expression *const r04ED = lshift(r03E0, r04E4);
                  ir_expression *const r04EE = nequal(r04ED, body.constant(0u));
                  ir_expression *const r04EF = expr(ir_unop_b2i, r04EE);
                  ir_expression *const r04F0 = expr(ir_unop_i2u, r04EF);
                  body.emit(assign(r04E2, bit_or(r04EC, r04F0), 0x01));

                  body.emit(assign(r04E3, rshift(swizzle_y(r03D6), r04E1), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f04E8->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r04F2 = equal(r04E1, body.constant(int(32)));
                  ir_if *f04F1 = new(mem_ctx) ir_if(operand(r04F2).val);
                  exec_list *const f04F1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f04F1->then_instructions;

                     ir_expression *const r04F3 = nequal(r03E0, body.constant(0u));
                     ir_expression *const r04F4 = expr(ir_unop_b2i, r04F3);
                     ir_expression *const r04F5 = expr(ir_unop_i2u, r04F4);
                     body.emit(assign(r04E2, bit_or(swizzle_y(r03D6), r04F5), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f04F1->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r04F7 = less(r04E1, body.constant(int(64)));
                     ir_if *f04F6 = new(mem_ctx) ir_if(operand(r04F7).val);
                     exec_list *const f04F6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f04F6->then_instructions;

                        ir_expression *const r04F8 = bit_and(r04E1, body.constant(int(31)));
                        ir_expression *const r04F9 = rshift(swizzle_y(r03D6), r04F8);
                        ir_expression *const r04FA = lshift(swizzle_y(r03D6), r04E4);
                        ir_expression *const r04FB = bit_or(r04FA, r03E0);
                        ir_expression *const r04FC = nequal(r04FB, body.constant(0u));
                        ir_expression *const r04FD = expr(ir_unop_b2i, r04FC);
                        ir_expression *const r04FE = expr(ir_unop_i2u, r04FD);
                        body.emit(assign(r04E2, bit_or(r04F9, r04FE), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f04F6->else_instructions;

                        ir_expression *const r04FF = bit_or(swizzle_y(r03D6), r03E0);
                        ir_expression *const r0500 = nequal(r04FF, body.constant(0u));
                        ir_expression *const r0501 = expr(ir_unop_b2i, r0500);
                        body.emit(assign(r04E2, expr(ir_unop_i2u, r0501), 0x01));


                     body.instructions = f04F6_parent_instructions;
                     body.emit(f04F6);

                     /* END IF */


                  body.instructions = f04F1_parent_instructions;
                  body.emit(f04F1);

                  /* END IF */

                  body.emit(assign(r04E3, body.constant(0u), 0x01));


               body.instructions = f04E8_parent_instructions;
               body.emit(f04E8);

               /* END IF */


            body.instructions = f04E6_parent_instructions;
            body.emit(f04E6);

            /* END IF */

            body.emit(assign(r03D6, r04E3, 0x02));

            body.emit(assign(r03D6, r04E2, 0x01));

            body.emit(assign(r03D4, bit_or(swizzle_y(r03D4), body.constant(1073741824u)), 0x02));

            ir_variable *const r0502 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r0503 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r0503, sub(swizzle_x(r03D4), r04E2), 0x01));

            ir_expression *const r0504 = sub(swizzle_y(r03D4), r04E3);
            ir_expression *const r0505 = less(swizzle_x(r03D4), r04E2);
            ir_expression *const r0506 = expr(ir_unop_b2i, r0505);
            ir_expression *const r0507 = expr(ir_unop_i2u, r0506);
            body.emit(assign(r0502, sub(r0504, r0507), 0x01));

            body.emit(assign(r03D0, bit_xor(r03D0, body.constant(1u)), 0x01));

            body.emit(assign(r03D7, add(r03DD, body.constant(int(-1))), 0x01));

            ir_variable *const r0508 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0508, add(r03D7, body.constant(int(-10))), 0x01));

            ir_variable *const r0509 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0509, r0502, 0x01));

            ir_variable *const r050A = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r050A, r0503, 0x01));

            ir_variable *const r050B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
            body.emit(r050B);
            ir_variable *const r050C = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r050C);
            /* IF CONDITION */
            ir_expression *const r050E = equal(r0502, body.constant(0u));
            ir_if *f050D = new(mem_ctx) ir_if(operand(r050E).val);
            exec_list *const f050D_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f050D->then_instructions;

               body.emit(assign(r0509, r0503, 0x01));

               body.emit(assign(r050A, body.constant(0u), 0x01));

               body.emit(assign(r0508, add(r0508, body.constant(int(-32))), 0x01));


            body.instructions = f050D_parent_instructions;
            body.emit(f050D);

            /* END IF */

            ir_variable *const r050F = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r050F, r0509, 0x01));

            ir_variable *const r0510 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r0511 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0511);
            /* IF CONDITION */
            ir_expression *const r0513 = equal(r0509, body.constant(0u));
            ir_if *f0512 = new(mem_ctx) ir_if(operand(r0513).val);
            exec_list *const f0512_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0512->then_instructions;

               body.emit(assign(r0510, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0512->else_instructions;

               body.emit(assign(r0511, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r0515 = bit_and(r0509, body.constant(4294901760u));
               ir_expression *const r0516 = equal(r0515, body.constant(0u));
               ir_if *f0514 = new(mem_ctx) ir_if(operand(r0516).val);
               exec_list *const f0514_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0514->then_instructions;

                  body.emit(assign(r0511, body.constant(int(16)), 0x01));

                  body.emit(assign(r050F, lshift(r0509, body.constant(int(16))), 0x01));


               body.instructions = f0514_parent_instructions;
               body.emit(f0514);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0518 = bit_and(r050F, body.constant(4278190080u));
               ir_expression *const r0519 = equal(r0518, body.constant(0u));
               ir_if *f0517 = new(mem_ctx) ir_if(operand(r0519).val);
               exec_list *const f0517_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0517->then_instructions;

                  body.emit(assign(r0511, add(r0511, body.constant(int(8))), 0x01));

                  body.emit(assign(r050F, lshift(r050F, body.constant(int(8))), 0x01));


               body.instructions = f0517_parent_instructions;
               body.emit(f0517);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r051B = bit_and(r050F, body.constant(4026531840u));
               ir_expression *const r051C = equal(r051B, body.constant(0u));
               ir_if *f051A = new(mem_ctx) ir_if(operand(r051C).val);
               exec_list *const f051A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f051A->then_instructions;

                  body.emit(assign(r0511, add(r0511, body.constant(int(4))), 0x01));

                  body.emit(assign(r050F, lshift(r050F, body.constant(int(4))), 0x01));


               body.instructions = f051A_parent_instructions;
               body.emit(f051A);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r051E = bit_and(r050F, body.constant(3221225472u));
               ir_expression *const r051F = equal(r051E, body.constant(0u));
               ir_if *f051D = new(mem_ctx) ir_if(operand(r051F).val);
               exec_list *const f051D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f051D->then_instructions;

                  body.emit(assign(r0511, add(r0511, body.constant(int(2))), 0x01));

                  body.emit(assign(r050F, lshift(r050F, body.constant(int(2))), 0x01));


               body.instructions = f051D_parent_instructions;
               body.emit(f051D);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0521 = bit_and(r050F, body.constant(2147483648u));
               ir_expression *const r0522 = equal(r0521, body.constant(0u));
               ir_if *f0520 = new(mem_ctx) ir_if(operand(r0522).val);
               exec_list *const f0520_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0520->then_instructions;

                  body.emit(assign(r0511, add(r0511, body.constant(int(1))), 0x01));


               body.instructions = f0520_parent_instructions;
               body.emit(f0520);

               /* END IF */

               body.emit(assign(r0510, r0511, 0x01));


            body.instructions = f0512_parent_instructions;
            body.emit(f0512);

            /* END IF */

            body.emit(assign(r050C, add(r0510, body.constant(int(-11))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0524 = lequal(body.constant(int(0)), r050C);
            ir_if *f0523 = new(mem_ctx) ir_if(operand(r0524).val);
            exec_list *const f0523_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0523->then_instructions;

               body.emit(assign(r050B, body.constant(0u), 0x01));

               ir_variable *const r0525 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r0525, lshift(r050A, r050C), 0x01));

               ir_variable *const r0526 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r0528 = equal(r050C, body.constant(int(0)));
               ir_if *f0527 = new(mem_ctx) ir_if(operand(r0528).val);
               exec_list *const f0527_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0527->then_instructions;

                  body.emit(assign(r0526, r0509, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0527->else_instructions;

                  ir_expression *const r0529 = lshift(r0509, r050C);
                  ir_expression *const r052A = neg(r050C);
                  ir_expression *const r052B = bit_and(r052A, body.constant(int(31)));
                  ir_expression *const r052C = rshift(r050A, r052B);
                  body.emit(assign(r0526, bit_or(r0529, r052C), 0x01));


               body.instructions = f0527_parent_instructions;
               body.emit(f0527);

               /* END IF */

               body.emit(assign(r0509, r0526, 0x01));

               body.emit(assign(r050A, r0525, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0523->else_instructions;

               ir_variable *const r052D = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r052D, body.constant(0u), 0x01));

               ir_variable *const r052E = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r052E, neg(r050C), 0x01));

               ir_variable *const r052F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r052F);
               ir_variable *const r0530 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0530);
               ir_variable *const r0531 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0531);
               ir_variable *const r0532 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0533 = neg(r052E);
               body.emit(assign(r0532, bit_and(r0533, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0535 = equal(r052E, body.constant(int(0)));
               ir_if *f0534 = new(mem_ctx) ir_if(operand(r0535).val);
               exec_list *const f0534_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0534->then_instructions;

                  body.emit(assign(r052F, r052D, 0x01));

                  body.emit(assign(r0530, r050A, 0x01));

                  body.emit(assign(r0531, r0509, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0534->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0537 = less(r052E, body.constant(int(32)));
                  ir_if *f0536 = new(mem_ctx) ir_if(operand(r0537).val);
                  exec_list *const f0536_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0536->then_instructions;

                     body.emit(assign(r052F, lshift(r050A, r0532), 0x01));

                     ir_expression *const r0538 = lshift(r0509, r0532);
                     ir_expression *const r0539 = rshift(r050A, r052E);
                     body.emit(assign(r0530, bit_or(r0538, r0539), 0x01));

                     body.emit(assign(r0531, rshift(r0509, r052E), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0536->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r053B = equal(r052E, body.constant(int(32)));
                     ir_if *f053A = new(mem_ctx) ir_if(operand(r053B).val);
                     exec_list *const f053A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f053A->then_instructions;

                        body.emit(assign(r052F, r050A, 0x01));

                        body.emit(assign(r0530, r0509, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f053A->else_instructions;

                        body.emit(assign(r052D, bit_or(body.constant(0u), r050A), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r053D = less(r052E, body.constant(int(64)));
                        ir_if *f053C = new(mem_ctx) ir_if(operand(r053D).val);
                        exec_list *const f053C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f053C->then_instructions;

                           body.emit(assign(r052F, lshift(r0509, r0532), 0x01));

                           ir_expression *const r053E = bit_and(r052E, body.constant(int(31)));
                           body.emit(assign(r0530, rshift(r0509, r053E), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f053C->else_instructions;

                           ir_variable *const r053F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0541 = equal(r052E, body.constant(int(64)));
                           ir_if *f0540 = new(mem_ctx) ir_if(operand(r0541).val);
                           exec_list *const f0540_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0540->then_instructions;

                              body.emit(assign(r053F, r0509, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0540->else_instructions;

                              ir_expression *const r0542 = nequal(r0509, body.constant(0u));
                              ir_expression *const r0543 = expr(ir_unop_b2i, r0542);
                              body.emit(assign(r053F, expr(ir_unop_i2u, r0543), 0x01));


                           body.instructions = f0540_parent_instructions;
                           body.emit(f0540);

                           /* END IF */

                           body.emit(assign(r052F, r053F, 0x01));

                           body.emit(assign(r0530, body.constant(0u), 0x01));


                        body.instructions = f053C_parent_instructions;
                        body.emit(f053C);

                        /* END IF */


                     body.instructions = f053A_parent_instructions;
                     body.emit(f053A);

                     /* END IF */

                     body.emit(assign(r0531, body.constant(0u), 0x01));


                  body.instructions = f0536_parent_instructions;
                  body.emit(f0536);

                  /* END IF */

                  ir_expression *const r0544 = nequal(r052D, body.constant(0u));
                  ir_expression *const r0545 = expr(ir_unop_b2i, r0544);
                  ir_expression *const r0546 = expr(ir_unop_i2u, r0545);
                  body.emit(assign(r052F, bit_or(r052F, r0546), 0x01));


               body.instructions = f0534_parent_instructions;
               body.emit(f0534);

               /* END IF */

               body.emit(assign(r0509, r0531, 0x01));

               body.emit(assign(r050A, r0530, 0x01));

               body.emit(assign(r050B, r052F, 0x01));


            body.instructions = f0523_parent_instructions;
            body.emit(f0523);

            /* END IF */

            body.emit(assign(r0508, sub(r0508, r050C), 0x01));

            ir_variable *const r0547 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0547, r0508, 0x01));

            ir_variable *const r0548 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0548, r0509, 0x01));

            ir_variable *const r0549 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0549, r050A, 0x01));

            ir_variable *const r054A = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r054A, r050B, 0x01));

            ir_variable *const r054B = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r054B, body.constant(true), 0x01));

            ir_variable *const r054C = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r054D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r054D);
            ir_expression *const r054E = expr(ir_unop_u2i, r050B);
            body.emit(assign(r054D, less(r054E, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0550 = lequal(body.constant(int(2045)), r0508);
            ir_if *f054F = new(mem_ctx) ir_if(operand(r0550).val);
            exec_list *const f054F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f054F->then_instructions;

               ir_variable *const r0551 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0553 = less(body.constant(int(2045)), r0508);
               ir_if *f0552 = new(mem_ctx) ir_if(operand(r0553).val);
               exec_list *const f0552_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0552->then_instructions;

                  body.emit(assign(r0551, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0552->else_instructions;

                  ir_variable *const r0554 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0556 = equal(r0508, body.constant(int(2045)));
                  ir_if *f0555 = new(mem_ctx) ir_if(operand(r0556).val);
                  exec_list *const f0555_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0555->then_instructions;

                     ir_expression *const r0557 = equal(body.constant(2097151u), r0509);
                     ir_expression *const r0558 = equal(body.constant(4294967295u), r050A);
                     body.emit(assign(r0554, logic_and(r0557, r0558), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0555->else_instructions;

                     body.emit(assign(r0554, body.constant(false), 0x01));


                  body.instructions = f0555_parent_instructions;
                  body.emit(f0555);

                  /* END IF */

                  body.emit(assign(r0551, logic_and(r0554, r054D), 0x01));


               body.instructions = f0552_parent_instructions;
               body.emit(f0552);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0559 = new(mem_ctx) ir_if(operand(r0551).val);
               exec_list *const f0559_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0559->then_instructions;

                  ir_variable *const r055A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r055A);
                  ir_expression *const r055B = lshift(r03D0, body.constant(int(31)));
                  body.emit(assign(r055A, add(r055B, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r055A, body.constant(0u), 0x01));

                  body.emit(assign(r054C, r055A, 0x03));

                  body.emit(assign(r054B, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0559->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r055D = less(r0508, body.constant(int(0)));
                  ir_if *f055C = new(mem_ctx) ir_if(operand(r055D).val);
                  exec_list *const f055C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f055C->then_instructions;

                     ir_variable *const r055E = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r055E, r050B, 0x01));

                     ir_variable *const r055F = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r055F, neg(r0508), 0x01));

                     ir_variable *const r0560 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0560);
                     ir_variable *const r0561 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0561);
                     ir_variable *const r0562 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0562);
                     ir_variable *const r0563 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0564 = neg(r055F);
                     body.emit(assign(r0563, bit_and(r0564, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0566 = equal(r055F, body.constant(int(0)));
                     ir_if *f0565 = new(mem_ctx) ir_if(operand(r0566).val);
                     exec_list *const f0565_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0565->then_instructions;

                        body.emit(assign(r0560, r050B, 0x01));

                        body.emit(assign(r0561, r050A, 0x01));

                        body.emit(assign(r0562, r0509, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0565->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0568 = less(r055F, body.constant(int(32)));
                        ir_if *f0567 = new(mem_ctx) ir_if(operand(r0568).val);
                        exec_list *const f0567_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0567->then_instructions;

                           body.emit(assign(r0560, lshift(r050A, r0563), 0x01));

                           ir_expression *const r0569 = lshift(r0509, r0563);
                           ir_expression *const r056A = rshift(r050A, r055F);
                           body.emit(assign(r0561, bit_or(r0569, r056A), 0x01));

                           body.emit(assign(r0562, rshift(r0509, r055F), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0567->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r056C = equal(r055F, body.constant(int(32)));
                           ir_if *f056B = new(mem_ctx) ir_if(operand(r056C).val);
                           exec_list *const f056B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f056B->then_instructions;

                              body.emit(assign(r0560, r050A, 0x01));

                              body.emit(assign(r0561, r0509, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f056B->else_instructions;

                              body.emit(assign(r055E, bit_or(r050B, r050A), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r056E = less(r055F, body.constant(int(64)));
                              ir_if *f056D = new(mem_ctx) ir_if(operand(r056E).val);
                              exec_list *const f056D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f056D->then_instructions;

                                 body.emit(assign(r0560, lshift(r0509, r0563), 0x01));

                                 ir_expression *const r056F = bit_and(r055F, body.constant(int(31)));
                                 body.emit(assign(r0561, rshift(r0509, r056F), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f056D->else_instructions;

                                 ir_variable *const r0570 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0572 = equal(r055F, body.constant(int(64)));
                                 ir_if *f0571 = new(mem_ctx) ir_if(operand(r0572).val);
                                 exec_list *const f0571_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0571->then_instructions;

                                    body.emit(assign(r0570, r0509, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0571->else_instructions;

                                    ir_expression *const r0573 = nequal(r0509, body.constant(0u));
                                    ir_expression *const r0574 = expr(ir_unop_b2i, r0573);
                                    body.emit(assign(r0570, expr(ir_unop_i2u, r0574), 0x01));


                                 body.instructions = f0571_parent_instructions;
                                 body.emit(f0571);

                                 /* END IF */

                                 body.emit(assign(r0560, r0570, 0x01));

                                 body.emit(assign(r0561, body.constant(0u), 0x01));


                              body.instructions = f056D_parent_instructions;
                              body.emit(f056D);

                              /* END IF */


                           body.instructions = f056B_parent_instructions;
                           body.emit(f056B);

                           /* END IF */

                           body.emit(assign(r0562, body.constant(0u), 0x01));


                        body.instructions = f0567_parent_instructions;
                        body.emit(f0567);

                        /* END IF */

                        ir_expression *const r0575 = nequal(r055E, body.constant(0u));
                        ir_expression *const r0576 = expr(ir_unop_b2i, r0575);
                        ir_expression *const r0577 = expr(ir_unop_i2u, r0576);
                        body.emit(assign(r0560, bit_or(r0560, r0577), 0x01));


                     body.instructions = f0565_parent_instructions;
                     body.emit(f0565);

                     /* END IF */

                     body.emit(assign(r0548, r0562, 0x01));

                     body.emit(assign(r0549, r0561, 0x01));

                     body.emit(assign(r054A, r0560, 0x01));

                     body.emit(assign(r0547, body.constant(int(0)), 0x01));

                     body.emit(assign(r054D, less(r0560, body.constant(0u)), 0x01));


                  body.instructions = f055C_parent_instructions;
                  body.emit(f055C);

                  /* END IF */


               body.instructions = f0559_parent_instructions;
               body.emit(f0559);

               /* END IF */


            body.instructions = f054F_parent_instructions;
            body.emit(f054F);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0578 = new(mem_ctx) ir_if(operand(r054B).val);
            exec_list *const f0578_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0578->then_instructions;

               /* IF CONDITION */
               ir_if *f0579 = new(mem_ctx) ir_if(operand(r054D).val);
               exec_list *const f0579_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0579->then_instructions;

                  ir_variable *const r057A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r057A, add(r0549, body.constant(1u)), 0x01));

                  ir_expression *const r057B = less(r057A, r0549);
                  ir_expression *const r057C = expr(ir_unop_b2i, r057B);
                  ir_expression *const r057D = expr(ir_unop_i2u, r057C);
                  body.emit(assign(r0548, add(r0548, r057D), 0x01));

                  ir_expression *const r057E = equal(r054A, body.constant(0u));
                  ir_expression *const r057F = expr(ir_unop_b2i, r057E);
                  ir_expression *const r0580 = expr(ir_unop_i2u, r057F);
                  ir_expression *const r0581 = add(r054A, r0580);
                  ir_expression *const r0582 = bit_and(r0581, body.constant(1u));
                  ir_expression *const r0583 = expr(ir_unop_bit_not, r0582);
                  body.emit(assign(r0549, bit_and(r057A, r0583), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0579->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0585 = bit_or(r0548, r0549);
                  ir_expression *const r0586 = equal(r0585, body.constant(0u));
                  ir_if *f0584 = new(mem_ctx) ir_if(operand(r0586).val);
                  exec_list *const f0584_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0584->then_instructions;

                     body.emit(assign(r0547, body.constant(int(0)), 0x01));


                  body.instructions = f0584_parent_instructions;
                  body.emit(f0584);

                  /* END IF */


               body.instructions = f0579_parent_instructions;
               body.emit(f0579);

               /* END IF */

               ir_variable *const r0587 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0587);
               ir_expression *const r0588 = lshift(r03D0, body.constant(int(31)));
               ir_expression *const r0589 = expr(ir_unop_i2u, r0547);
               ir_expression *const r058A = lshift(r0589, body.constant(int(20)));
               ir_expression *const r058B = add(r0588, r058A);
               body.emit(assign(r0587, add(r058B, r0548), 0x02));

               body.emit(assign(r0587, r0549, 0x01));

               body.emit(assign(r054C, r0587, 0x03));

               body.emit(assign(r054B, body.constant(false), 0x01));


            body.instructions = f0578_parent_instructions;
            body.emit(f0578);

            /* END IF */

            body.emit(assign(r03D1, r054C, 0x03));


         body.instructions = f04BA_parent_instructions;
         body.emit(f04BA);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f04B8->else_instructions;

         /* IF CONDITION */
         ir_expression *const r058D = equal(r03D9, body.constant(int(2047)));
         ir_if *f058C = new(mem_ctx) ir_if(operand(r058D).val);
         exec_list *const f058C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f058C->then_instructions;

            /* IF CONDITION */
            ir_expression *const r058F = bit_or(swizzle_y(r03D6), swizzle_x(r03D6));
            ir_expression *const r0590 = bit_or(swizzle_y(r03D4), swizzle_x(r03D4));
            ir_expression *const r0591 = bit_or(r058F, r0590);
            ir_expression *const r0592 = nequal(r0591, body.constant(0u));
            ir_if *f058E = new(mem_ctx) ir_if(operand(r0592).val);
            exec_list *const f058E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f058E->then_instructions;

               ir_variable *const r0593 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r0593, swizzle_y(r03CE), 0x02));

               ir_variable *const r0594 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r0594, swizzle_y(r03CF), 0x02));

               ir_variable *const r0595 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0596 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r0597 = rshift(swizzle_x(r03CE), body.constant(int(19)));
               ir_expression *const r0598 = bit_and(r0597, body.constant(4095u));
               ir_expression *const r0599 = equal(r0598, body.constant(4094u));
               ir_expression *const r059A = nequal(swizzle_y(r03CE), body.constant(0u));
               ir_expression *const r059B = bit_and(swizzle_x(r03CE), body.constant(524287u));
               ir_expression *const r059C = nequal(r059B, body.constant(0u));
               ir_expression *const r059D = logic_or(r059A, r059C);
               body.emit(assign(r0596, logic_and(r0599, r059D), 0x01));

               ir_variable *const r059E = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r059F = lshift(swizzle_x(r03CF), body.constant(int(1)));
               ir_expression *const r05A0 = lequal(body.constant(4292870144u), r059F);
               ir_expression *const r05A1 = nequal(swizzle_y(r03CF), body.constant(0u));
               ir_expression *const r05A2 = bit_and(swizzle_x(r03CF), body.constant(1048575u));
               ir_expression *const r05A3 = nequal(r05A2, body.constant(0u));
               ir_expression *const r05A4 = logic_or(r05A1, r05A3);
               body.emit(assign(r059E, logic_and(r05A0, r05A4), 0x01));

               body.emit(assign(r0593, bit_or(swizzle_x(r03CE), body.constant(524288u)), 0x01));

               body.emit(assign(r0594, bit_or(swizzle_x(r03CF), body.constant(524288u)), 0x01));

               /* IF CONDITION */
               ir_expression *const r05A6 = lshift(swizzle_x(r03CE), body.constant(int(1)));
               ir_expression *const r05A7 = lequal(body.constant(4292870144u), r05A6);
               ir_expression *const r05A8 = nequal(swizzle_y(r03CE), body.constant(0u));
               ir_expression *const r05A9 = bit_and(swizzle_x(r03CE), body.constant(1048575u));
               ir_expression *const r05AA = nequal(r05A9, body.constant(0u));
               ir_expression *const r05AB = logic_or(r05A8, r05AA);
               ir_expression *const r05AC = logic_and(r05A7, r05AB);
               ir_if *f05A5 = new(mem_ctx) ir_if(operand(r05AC).val);
               exec_list *const f05A5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f05A5->then_instructions;

                  ir_variable *const r05AD = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r05AF = logic_and(r0596, r059E);
                  ir_if *f05AE = new(mem_ctx) ir_if(operand(r05AF).val);
                  exec_list *const f05AE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05AE->then_instructions;

                     body.emit(assign(r05AD, r0594, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f05AE->else_instructions;

                     body.emit(assign(r05AD, r0593, 0x03));


                  body.instructions = f05AE_parent_instructions;
                  body.emit(f05AE);

                  /* END IF */

                  body.emit(assign(r0595, r05AD, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f05A5->else_instructions;

                  body.emit(assign(r0595, r0594, 0x03));


               body.instructions = f05A5_parent_instructions;
               body.emit(f05A5);

               /* END IF */

               body.emit(assign(r03D1, r0595, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f058E->else_instructions;

               ir_constant_data r05B0_data;
               memset(&r05B0_data, 0, sizeof(ir_constant_data));
               r05B0_data.u[0] = 4294967295;
               r05B0_data.u[1] = 4294967295;
               ir_constant *const r05B0 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r05B0_data);
               body.emit(assign(r03D1, r05B0, 0x03));


            body.instructions = f058E_parent_instructions;
            body.emit(f058E);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f058C->else_instructions;

            /* IF CONDITION */
            ir_expression *const r05B2 = equal(r03D9, body.constant(int(0)));
            ir_if *f05B1 = new(mem_ctx) ir_if(operand(r05B2).val);
            exec_list *const f05B1_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f05B1->then_instructions;

               body.emit(assign(r03D5, body.constant(int(1)), 0x01));

               body.emit(assign(r03D3, body.constant(int(1)), 0x01));


            body.instructions = f05B1_parent_instructions;
            body.emit(f05B1);

            /* END IF */

            /* IF CONDITION */
            ir_expression *const r05B4 = less(swizzle_y(r03D4), swizzle_y(r03D6));
            ir_if *f05B3 = new(mem_ctx) ir_if(operand(r05B4).val);
            exec_list *const f05B3_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f05B3->then_instructions;

               ir_variable *const r05B5 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r05B6 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r05B6, sub(swizzle_x(r03D6), swizzle_x(r03D4)), 0x01));

               ir_expression *const r05B7 = sub(swizzle_y(r03D6), swizzle_y(r03D4));
               ir_expression *const r05B8 = less(swizzle_x(r03D6), swizzle_x(r03D4));
               ir_expression *const r05B9 = expr(ir_unop_b2i, r05B8);
               ir_expression *const r05BA = expr(ir_unop_i2u, r05B9);
               body.emit(assign(r05B5, sub(r05B7, r05BA), 0x01));

               body.emit(assign(r03D7, add(r03D5, body.constant(int(-1))), 0x01));

               ir_variable *const r05BB = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r05BB, add(r03D7, body.constant(int(-10))), 0x01));

               ir_variable *const r05BC = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r05BC, r05B5, 0x01));

               ir_variable *const r05BD = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r05BD, r05B6, 0x01));

               ir_variable *const r05BE = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r05BE);
               ir_variable *const r05BF = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r05BF);
               /* IF CONDITION */
               ir_expression *const r05C1 = equal(r05B5, body.constant(0u));
               ir_if *f05C0 = new(mem_ctx) ir_if(operand(r05C1).val);
               exec_list *const f05C0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f05C0->then_instructions;

                  body.emit(assign(r05BC, r05B6, 0x01));

                  body.emit(assign(r05BD, body.constant(0u), 0x01));

                  body.emit(assign(r05BB, add(r05BB, body.constant(int(-32))), 0x01));


               body.instructions = f05C0_parent_instructions;
               body.emit(f05C0);

               /* END IF */

               ir_variable *const r05C2 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r05C2, r05BC, 0x01));

               ir_variable *const r05C3 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r05C4 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r05C4);
               /* IF CONDITION */
               ir_expression *const r05C6 = equal(r05BC, body.constant(0u));
               ir_if *f05C5 = new(mem_ctx) ir_if(operand(r05C6).val);
               exec_list *const f05C5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f05C5->then_instructions;

                  body.emit(assign(r05C3, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f05C5->else_instructions;

                  body.emit(assign(r05C4, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r05C8 = bit_and(r05BC, body.constant(4294901760u));
                  ir_expression *const r05C9 = equal(r05C8, body.constant(0u));
                  ir_if *f05C7 = new(mem_ctx) ir_if(operand(r05C9).val);
                  exec_list *const f05C7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05C7->then_instructions;

                     body.emit(assign(r05C4, body.constant(int(16)), 0x01));

                     body.emit(assign(r05C2, lshift(r05BC, body.constant(int(16))), 0x01));


                  body.instructions = f05C7_parent_instructions;
                  body.emit(f05C7);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r05CB = bit_and(r05C2, body.constant(4278190080u));
                  ir_expression *const r05CC = equal(r05CB, body.constant(0u));
                  ir_if *f05CA = new(mem_ctx) ir_if(operand(r05CC).val);
                  exec_list *const f05CA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05CA->then_instructions;

                     body.emit(assign(r05C4, add(r05C4, body.constant(int(8))), 0x01));

                     body.emit(assign(r05C2, lshift(r05C2, body.constant(int(8))), 0x01));


                  body.instructions = f05CA_parent_instructions;
                  body.emit(f05CA);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r05CE = bit_and(r05C2, body.constant(4026531840u));
                  ir_expression *const r05CF = equal(r05CE, body.constant(0u));
                  ir_if *f05CD = new(mem_ctx) ir_if(operand(r05CF).val);
                  exec_list *const f05CD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05CD->then_instructions;

                     body.emit(assign(r05C4, add(r05C4, body.constant(int(4))), 0x01));

                     body.emit(assign(r05C2, lshift(r05C2, body.constant(int(4))), 0x01));


                  body.instructions = f05CD_parent_instructions;
                  body.emit(f05CD);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r05D1 = bit_and(r05C2, body.constant(3221225472u));
                  ir_expression *const r05D2 = equal(r05D1, body.constant(0u));
                  ir_if *f05D0 = new(mem_ctx) ir_if(operand(r05D2).val);
                  exec_list *const f05D0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05D0->then_instructions;

                     body.emit(assign(r05C4, add(r05C4, body.constant(int(2))), 0x01));

                     body.emit(assign(r05C2, lshift(r05C2, body.constant(int(2))), 0x01));


                  body.instructions = f05D0_parent_instructions;
                  body.emit(f05D0);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r05D4 = bit_and(r05C2, body.constant(2147483648u));
                  ir_expression *const r05D5 = equal(r05D4, body.constant(0u));
                  ir_if *f05D3 = new(mem_ctx) ir_if(operand(r05D5).val);
                  exec_list *const f05D3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05D3->then_instructions;

                     body.emit(assign(r05C4, add(r05C4, body.constant(int(1))), 0x01));


                  body.instructions = f05D3_parent_instructions;
                  body.emit(f05D3);

                  /* END IF */

                  body.emit(assign(r05C3, r05C4, 0x01));


               body.instructions = f05C5_parent_instructions;
               body.emit(f05C5);

               /* END IF */

               body.emit(assign(r05BF, add(r05C3, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r05D7 = lequal(body.constant(int(0)), r05BF);
               ir_if *f05D6 = new(mem_ctx) ir_if(operand(r05D7).val);
               exec_list *const f05D6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f05D6->then_instructions;

                  body.emit(assign(r05BE, body.constant(0u), 0x01));

                  ir_variable *const r05D8 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r05D8, lshift(r05BD, r05BF), 0x01));

                  ir_variable *const r05D9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r05DB = equal(r05BF, body.constant(int(0)));
                  ir_if *f05DA = new(mem_ctx) ir_if(operand(r05DB).val);
                  exec_list *const f05DA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05DA->then_instructions;

                     body.emit(assign(r05D9, r05BC, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f05DA->else_instructions;

                     ir_expression *const r05DC = lshift(r05BC, r05BF);
                     ir_expression *const r05DD = neg(r05BF);
                     ir_expression *const r05DE = bit_and(r05DD, body.constant(int(31)));
                     ir_expression *const r05DF = rshift(r05BD, r05DE);
                     body.emit(assign(r05D9, bit_or(r05DC, r05DF), 0x01));


                  body.instructions = f05DA_parent_instructions;
                  body.emit(f05DA);

                  /* END IF */

                  body.emit(assign(r05BC, r05D9, 0x01));

                  body.emit(assign(r05BD, r05D8, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f05D6->else_instructions;

                  ir_variable *const r05E0 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r05E0, body.constant(0u), 0x01));

                  ir_variable *const r05E1 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r05E1, neg(r05BF), 0x01));

                  ir_variable *const r05E2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r05E2);
                  ir_variable *const r05E3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r05E3);
                  ir_variable *const r05E4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r05E4);
                  ir_variable *const r05E5 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r05E6 = neg(r05E1);
                  body.emit(assign(r05E5, bit_and(r05E6, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r05E8 = equal(r05E1, body.constant(int(0)));
                  ir_if *f05E7 = new(mem_ctx) ir_if(operand(r05E8).val);
                  exec_list *const f05E7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f05E7->then_instructions;

                     body.emit(assign(r05E2, r05E0, 0x01));

                     body.emit(assign(r05E3, r05BD, 0x01));

                     body.emit(assign(r05E4, r05BC, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f05E7->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r05EA = less(r05E1, body.constant(int(32)));
                     ir_if *f05E9 = new(mem_ctx) ir_if(operand(r05EA).val);
                     exec_list *const f05E9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f05E9->then_instructions;

                        body.emit(assign(r05E2, lshift(r05BD, r05E5), 0x01));

                        ir_expression *const r05EB = lshift(r05BC, r05E5);
                        ir_expression *const r05EC = rshift(r05BD, r05E1);
                        body.emit(assign(r05E3, bit_or(r05EB, r05EC), 0x01));

                        body.emit(assign(r05E4, rshift(r05BC, r05E1), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f05E9->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r05EE = equal(r05E1, body.constant(int(32)));
                        ir_if *f05ED = new(mem_ctx) ir_if(operand(r05EE).val);
                        exec_list *const f05ED_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f05ED->then_instructions;

                           body.emit(assign(r05E2, r05BD, 0x01));

                           body.emit(assign(r05E3, r05BC, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f05ED->else_instructions;

                           body.emit(assign(r05E0, bit_or(body.constant(0u), r05BD), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r05F0 = less(r05E1, body.constant(int(64)));
                           ir_if *f05EF = new(mem_ctx) ir_if(operand(r05F0).val);
                           exec_list *const f05EF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f05EF->then_instructions;

                              body.emit(assign(r05E2, lshift(r05BC, r05E5), 0x01));

                              ir_expression *const r05F1 = bit_and(r05E1, body.constant(int(31)));
                              body.emit(assign(r05E3, rshift(r05BC, r05F1), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f05EF->else_instructions;

                              ir_variable *const r05F2 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r05F4 = equal(r05E1, body.constant(int(64)));
                              ir_if *f05F3 = new(mem_ctx) ir_if(operand(r05F4).val);
                              exec_list *const f05F3_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f05F3->then_instructions;

                                 body.emit(assign(r05F2, r05BC, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f05F3->else_instructions;

                                 ir_expression *const r05F5 = nequal(r05BC, body.constant(0u));
                                 ir_expression *const r05F6 = expr(ir_unop_b2i, r05F5);
                                 body.emit(assign(r05F2, expr(ir_unop_i2u, r05F6), 0x01));


                              body.instructions = f05F3_parent_instructions;
                              body.emit(f05F3);

                              /* END IF */

                              body.emit(assign(r05E2, r05F2, 0x01));

                              body.emit(assign(r05E3, body.constant(0u), 0x01));


                           body.instructions = f05EF_parent_instructions;
                           body.emit(f05EF);

                           /* END IF */


                        body.instructions = f05ED_parent_instructions;
                        body.emit(f05ED);

                        /* END IF */

                        body.emit(assign(r05E4, body.constant(0u), 0x01));


                     body.instructions = f05E9_parent_instructions;
                     body.emit(f05E9);

                     /* END IF */

                     ir_expression *const r05F7 = nequal(r05E0, body.constant(0u));
                     ir_expression *const r05F8 = expr(ir_unop_b2i, r05F7);
                     ir_expression *const r05F9 = expr(ir_unop_i2u, r05F8);
                     body.emit(assign(r05E2, bit_or(r05E2, r05F9), 0x01));


                  body.instructions = f05E7_parent_instructions;
                  body.emit(f05E7);

                  /* END IF */

                  body.emit(assign(r05BC, r05E4, 0x01));

                  body.emit(assign(r05BD, r05E3, 0x01));

                  body.emit(assign(r05BE, r05E2, 0x01));


               body.instructions = f05D6_parent_instructions;
               body.emit(f05D6);

               /* END IF */

               body.emit(assign(r05BB, sub(r05BB, r05BF), 0x01));

               ir_variable *const r05FA = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r05FA, r05BB, 0x01));

               ir_variable *const r05FB = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r05FB, r05BC, 0x01));

               ir_variable *const r05FC = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r05FC, r05BD, 0x01));

               ir_variable *const r05FD = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r05FD, r05BE, 0x01));

               ir_variable *const r05FE = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r05FE, body.constant(true), 0x01));

               ir_variable *const r05FF = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0600 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r0600);
               ir_expression *const r0601 = expr(ir_unop_u2i, r05BE);
               body.emit(assign(r0600, less(r0601, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0603 = lequal(body.constant(int(2045)), r05BB);
               ir_if *f0602 = new(mem_ctx) ir_if(operand(r0603).val);
               exec_list *const f0602_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0602->then_instructions;

                  ir_variable *const r0604 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0606 = less(body.constant(int(2045)), r05BB);
                  ir_if *f0605 = new(mem_ctx) ir_if(operand(r0606).val);
                  exec_list *const f0605_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0605->then_instructions;

                     body.emit(assign(r0604, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0605->else_instructions;

                     ir_variable *const r0607 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0609 = equal(r05BB, body.constant(int(2045)));
                     ir_if *f0608 = new(mem_ctx) ir_if(operand(r0609).val);
                     exec_list *const f0608_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0608->then_instructions;

                        ir_expression *const r060A = equal(body.constant(2097151u), r05BC);
                        ir_expression *const r060B = equal(body.constant(4294967295u), r05BD);
                        body.emit(assign(r0607, logic_and(r060A, r060B), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0608->else_instructions;

                        body.emit(assign(r0607, body.constant(false), 0x01));


                     body.instructions = f0608_parent_instructions;
                     body.emit(f0608);

                     /* END IF */

                     body.emit(assign(r0604, logic_and(r0607, r0600), 0x01));


                  body.instructions = f0605_parent_instructions;
                  body.emit(f0605);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f060C = new(mem_ctx) ir_if(operand(r0604).val);
                  exec_list *const f060C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f060C->then_instructions;

                     ir_variable *const r060D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r060D);
                     ir_expression *const r060E = lshift(r03D0, body.constant(int(31)));
                     body.emit(assign(r060D, add(r060E, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r060D, body.constant(0u), 0x01));

                     body.emit(assign(r05FF, r060D, 0x03));

                     body.emit(assign(r05FE, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f060C->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0610 = less(r05BB, body.constant(int(0)));
                     ir_if *f060F = new(mem_ctx) ir_if(operand(r0610).val);
                     exec_list *const f060F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f060F->then_instructions;

                        ir_variable *const r0611 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0611, r05BE, 0x01));

                        ir_variable *const r0612 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0612, neg(r05BB), 0x01));

                        ir_variable *const r0613 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0613);
                        ir_variable *const r0614 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0614);
                        ir_variable *const r0615 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0615);
                        ir_variable *const r0616 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r0617 = neg(r0612);
                        body.emit(assign(r0616, bit_and(r0617, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0619 = equal(r0612, body.constant(int(0)));
                        ir_if *f0618 = new(mem_ctx) ir_if(operand(r0619).val);
                        exec_list *const f0618_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0618->then_instructions;

                           body.emit(assign(r0613, r05BE, 0x01));

                           body.emit(assign(r0614, r05BD, 0x01));

                           body.emit(assign(r0615, r05BC, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0618->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r061B = less(r0612, body.constant(int(32)));
                           ir_if *f061A = new(mem_ctx) ir_if(operand(r061B).val);
                           exec_list *const f061A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f061A->then_instructions;

                              body.emit(assign(r0613, lshift(r05BD, r0616), 0x01));

                              ir_expression *const r061C = lshift(r05BC, r0616);
                              ir_expression *const r061D = rshift(r05BD, r0612);
                              body.emit(assign(r0614, bit_or(r061C, r061D), 0x01));

                              body.emit(assign(r0615, rshift(r05BC, r0612), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f061A->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r061F = equal(r0612, body.constant(int(32)));
                              ir_if *f061E = new(mem_ctx) ir_if(operand(r061F).val);
                              exec_list *const f061E_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f061E->then_instructions;

                                 body.emit(assign(r0613, r05BD, 0x01));

                                 body.emit(assign(r0614, r05BC, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f061E->else_instructions;

                                 body.emit(assign(r0611, bit_or(r05BE, r05BD), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0621 = less(r0612, body.constant(int(64)));
                                 ir_if *f0620 = new(mem_ctx) ir_if(operand(r0621).val);
                                 exec_list *const f0620_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0620->then_instructions;

                                    body.emit(assign(r0613, lshift(r05BC, r0616), 0x01));

                                    ir_expression *const r0622 = bit_and(r0612, body.constant(int(31)));
                                    body.emit(assign(r0614, rshift(r05BC, r0622), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0620->else_instructions;

                                    ir_variable *const r0623 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r0625 = equal(r0612, body.constant(int(64)));
                                    ir_if *f0624 = new(mem_ctx) ir_if(operand(r0625).val);
                                    exec_list *const f0624_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0624->then_instructions;

                                       body.emit(assign(r0623, r05BC, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0624->else_instructions;

                                       ir_expression *const r0626 = nequal(r05BC, body.constant(0u));
                                       ir_expression *const r0627 = expr(ir_unop_b2i, r0626);
                                       body.emit(assign(r0623, expr(ir_unop_i2u, r0627), 0x01));


                                    body.instructions = f0624_parent_instructions;
                                    body.emit(f0624);

                                    /* END IF */

                                    body.emit(assign(r0613, r0623, 0x01));

                                    body.emit(assign(r0614, body.constant(0u), 0x01));


                                 body.instructions = f0620_parent_instructions;
                                 body.emit(f0620);

                                 /* END IF */


                              body.instructions = f061E_parent_instructions;
                              body.emit(f061E);

                              /* END IF */

                              body.emit(assign(r0615, body.constant(0u), 0x01));


                           body.instructions = f061A_parent_instructions;
                           body.emit(f061A);

                           /* END IF */

                           ir_expression *const r0628 = nequal(r0611, body.constant(0u));
                           ir_expression *const r0629 = expr(ir_unop_b2i, r0628);
                           ir_expression *const r062A = expr(ir_unop_i2u, r0629);
                           body.emit(assign(r0613, bit_or(r0613, r062A), 0x01));


                        body.instructions = f0618_parent_instructions;
                        body.emit(f0618);

                        /* END IF */

                        body.emit(assign(r05FB, r0615, 0x01));

                        body.emit(assign(r05FC, r0614, 0x01));

                        body.emit(assign(r05FD, r0613, 0x01));

                        body.emit(assign(r05FA, body.constant(int(0)), 0x01));

                        body.emit(assign(r0600, less(r0613, body.constant(0u)), 0x01));


                     body.instructions = f060F_parent_instructions;
                     body.emit(f060F);

                     /* END IF */


                  body.instructions = f060C_parent_instructions;
                  body.emit(f060C);

                  /* END IF */


               body.instructions = f0602_parent_instructions;
               body.emit(f0602);

               /* END IF */

               /* IF CONDITION */
               ir_if *f062B = new(mem_ctx) ir_if(operand(r05FE).val);
               exec_list *const f062B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f062B->then_instructions;

                  /* IF CONDITION */
                  ir_if *f062C = new(mem_ctx) ir_if(operand(r0600).val);
                  exec_list *const f062C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f062C->then_instructions;

                     ir_variable *const r062D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r062D, add(r05FC, body.constant(1u)), 0x01));

                     ir_expression *const r062E = less(r062D, r05FC);
                     ir_expression *const r062F = expr(ir_unop_b2i, r062E);
                     ir_expression *const r0630 = expr(ir_unop_i2u, r062F);
                     body.emit(assign(r05FB, add(r05FB, r0630), 0x01));

                     ir_expression *const r0631 = equal(r05FD, body.constant(0u));
                     ir_expression *const r0632 = expr(ir_unop_b2i, r0631);
                     ir_expression *const r0633 = expr(ir_unop_i2u, r0632);
                     ir_expression *const r0634 = add(r05FD, r0633);
                     ir_expression *const r0635 = bit_and(r0634, body.constant(1u));
                     ir_expression *const r0636 = expr(ir_unop_bit_not, r0635);
                     body.emit(assign(r05FC, bit_and(r062D, r0636), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f062C->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0638 = bit_or(r05FB, r05FC);
                     ir_expression *const r0639 = equal(r0638, body.constant(0u));
                     ir_if *f0637 = new(mem_ctx) ir_if(operand(r0639).val);
                     exec_list *const f0637_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0637->then_instructions;

                        body.emit(assign(r05FA, body.constant(int(0)), 0x01));


                     body.instructions = f0637_parent_instructions;
                     body.emit(f0637);

                     /* END IF */


                  body.instructions = f062C_parent_instructions;
                  body.emit(f062C);

                  /* END IF */

                  ir_variable *const r063A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r063A);
                  ir_expression *const r063B = lshift(r03D0, body.constant(int(31)));
                  ir_expression *const r063C = expr(ir_unop_i2u, r05FA);
                  ir_expression *const r063D = lshift(r063C, body.constant(int(20)));
                  ir_expression *const r063E = add(r063B, r063D);
                  body.emit(assign(r063A, add(r063E, r05FB), 0x02));

                  body.emit(assign(r063A, r05FC, 0x01));

                  body.emit(assign(r05FF, r063A, 0x03));

                  body.emit(assign(r05FE, body.constant(false), 0x01));


               body.instructions = f062B_parent_instructions;
               body.emit(f062B);

               /* END IF */

               body.emit(assign(r03D1, r05FF, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f05B3->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0640 = less(swizzle_y(r03D6), swizzle_y(r03D4));
               ir_if *f063F = new(mem_ctx) ir_if(operand(r0640).val);
               exec_list *const f063F_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f063F->then_instructions;

                  ir_variable *const r0641 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r0642 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0642, sub(swizzle_x(r03D4), swizzle_x(r03D6)), 0x01));

                  ir_expression *const r0643 = sub(swizzle_y(r03D4), swizzle_y(r03D6));
                  ir_expression *const r0644 = less(swizzle_x(r03D4), swizzle_x(r03D6));
                  ir_expression *const r0645 = expr(ir_unop_b2i, r0644);
                  ir_expression *const r0646 = expr(ir_unop_i2u, r0645);
                  body.emit(assign(r0641, sub(r0643, r0646), 0x01));

                  body.emit(assign(r03D0, bit_xor(r03D0, body.constant(1u)), 0x01));

                  body.emit(assign(r03D7, add(r03D3, body.constant(int(-1))), 0x01));

                  ir_variable *const r0647 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r0647, add(r03D7, body.constant(int(-10))), 0x01));

                  ir_variable *const r0648 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r0648, r0641, 0x01));

                  ir_variable *const r0649 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r0649, r0642, 0x01));

                  ir_variable *const r064A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r064A);
                  ir_variable *const r064B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r064B);
                  /* IF CONDITION */
                  ir_expression *const r064D = equal(r0641, body.constant(0u));
                  ir_if *f064C = new(mem_ctx) ir_if(operand(r064D).val);
                  exec_list *const f064C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f064C->then_instructions;

                     body.emit(assign(r0648, r0642, 0x01));

                     body.emit(assign(r0649, body.constant(0u), 0x01));

                     body.emit(assign(r0647, add(r0647, body.constant(int(-32))), 0x01));


                  body.instructions = f064C_parent_instructions;
                  body.emit(f064C);

                  /* END IF */

                  ir_variable *const r064E = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r064E, r0648, 0x01));

                  ir_variable *const r064F = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r0650 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0650);
                  /* IF CONDITION */
                  ir_expression *const r0652 = equal(r0648, body.constant(0u));
                  ir_if *f0651 = new(mem_ctx) ir_if(operand(r0652).val);
                  exec_list *const f0651_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0651->then_instructions;

                     body.emit(assign(r064F, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0651->else_instructions;

                     body.emit(assign(r0650, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0654 = bit_and(r0648, body.constant(4294901760u));
                     ir_expression *const r0655 = equal(r0654, body.constant(0u));
                     ir_if *f0653 = new(mem_ctx) ir_if(operand(r0655).val);
                     exec_list *const f0653_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0653->then_instructions;

                        body.emit(assign(r0650, body.constant(int(16)), 0x01));

                        body.emit(assign(r064E, lshift(r0648, body.constant(int(16))), 0x01));


                     body.instructions = f0653_parent_instructions;
                     body.emit(f0653);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0657 = bit_and(r064E, body.constant(4278190080u));
                     ir_expression *const r0658 = equal(r0657, body.constant(0u));
                     ir_if *f0656 = new(mem_ctx) ir_if(operand(r0658).val);
                     exec_list *const f0656_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0656->then_instructions;

                        body.emit(assign(r0650, add(r0650, body.constant(int(8))), 0x01));

                        body.emit(assign(r064E, lshift(r064E, body.constant(int(8))), 0x01));


                     body.instructions = f0656_parent_instructions;
                     body.emit(f0656);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r065A = bit_and(r064E, body.constant(4026531840u));
                     ir_expression *const r065B = equal(r065A, body.constant(0u));
                     ir_if *f0659 = new(mem_ctx) ir_if(operand(r065B).val);
                     exec_list *const f0659_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0659->then_instructions;

                        body.emit(assign(r0650, add(r0650, body.constant(int(4))), 0x01));

                        body.emit(assign(r064E, lshift(r064E, body.constant(int(4))), 0x01));


                     body.instructions = f0659_parent_instructions;
                     body.emit(f0659);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r065D = bit_and(r064E, body.constant(3221225472u));
                     ir_expression *const r065E = equal(r065D, body.constant(0u));
                     ir_if *f065C = new(mem_ctx) ir_if(operand(r065E).val);
                     exec_list *const f065C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f065C->then_instructions;

                        body.emit(assign(r0650, add(r0650, body.constant(int(2))), 0x01));

                        body.emit(assign(r064E, lshift(r064E, body.constant(int(2))), 0x01));


                     body.instructions = f065C_parent_instructions;
                     body.emit(f065C);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0660 = bit_and(r064E, body.constant(2147483648u));
                     ir_expression *const r0661 = equal(r0660, body.constant(0u));
                     ir_if *f065F = new(mem_ctx) ir_if(operand(r0661).val);
                     exec_list *const f065F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f065F->then_instructions;

                        body.emit(assign(r0650, add(r0650, body.constant(int(1))), 0x01));


                     body.instructions = f065F_parent_instructions;
                     body.emit(f065F);

                     /* END IF */

                     body.emit(assign(r064F, r0650, 0x01));


                  body.instructions = f0651_parent_instructions;
                  body.emit(f0651);

                  /* END IF */

                  body.emit(assign(r064B, add(r064F, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0663 = lequal(body.constant(int(0)), r064B);
                  ir_if *f0662 = new(mem_ctx) ir_if(operand(r0663).val);
                  exec_list *const f0662_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0662->then_instructions;

                     body.emit(assign(r064A, body.constant(0u), 0x01));

                     ir_variable *const r0664 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r0664, lshift(r0649, r064B), 0x01));

                     ir_variable *const r0665 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0667 = equal(r064B, body.constant(int(0)));
                     ir_if *f0666 = new(mem_ctx) ir_if(operand(r0667).val);
                     exec_list *const f0666_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0666->then_instructions;

                        body.emit(assign(r0665, r0648, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0666->else_instructions;

                        ir_expression *const r0668 = lshift(r0648, r064B);
                        ir_expression *const r0669 = neg(r064B);
                        ir_expression *const r066A = bit_and(r0669, body.constant(int(31)));
                        ir_expression *const r066B = rshift(r0649, r066A);
                        body.emit(assign(r0665, bit_or(r0668, r066B), 0x01));


                     body.instructions = f0666_parent_instructions;
                     body.emit(f0666);

                     /* END IF */

                     body.emit(assign(r0648, r0665, 0x01));

                     body.emit(assign(r0649, r0664, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0662->else_instructions;

                     ir_variable *const r066C = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r066C, body.constant(0u), 0x01));

                     ir_variable *const r066D = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r066D, neg(r064B), 0x01));

                     ir_variable *const r066E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r066E);
                     ir_variable *const r066F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r066F);
                     ir_variable *const r0670 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0670);
                     ir_variable *const r0671 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0672 = neg(r066D);
                     body.emit(assign(r0671, bit_and(r0672, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0674 = equal(r066D, body.constant(int(0)));
                     ir_if *f0673 = new(mem_ctx) ir_if(operand(r0674).val);
                     exec_list *const f0673_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0673->then_instructions;

                        body.emit(assign(r066E, r066C, 0x01));

                        body.emit(assign(r066F, r0649, 0x01));

                        body.emit(assign(r0670, r0648, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0673->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0676 = less(r066D, body.constant(int(32)));
                        ir_if *f0675 = new(mem_ctx) ir_if(operand(r0676).val);
                        exec_list *const f0675_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0675->then_instructions;

                           body.emit(assign(r066E, lshift(r0649, r0671), 0x01));

                           ir_expression *const r0677 = lshift(r0648, r0671);
                           ir_expression *const r0678 = rshift(r0649, r066D);
                           body.emit(assign(r066F, bit_or(r0677, r0678), 0x01));

                           body.emit(assign(r0670, rshift(r0648, r066D), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0675->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r067A = equal(r066D, body.constant(int(32)));
                           ir_if *f0679 = new(mem_ctx) ir_if(operand(r067A).val);
                           exec_list *const f0679_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0679->then_instructions;

                              body.emit(assign(r066E, r0649, 0x01));

                              body.emit(assign(r066F, r0648, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0679->else_instructions;

                              body.emit(assign(r066C, bit_or(body.constant(0u), r0649), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r067C = less(r066D, body.constant(int(64)));
                              ir_if *f067B = new(mem_ctx) ir_if(operand(r067C).val);
                              exec_list *const f067B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f067B->then_instructions;

                                 body.emit(assign(r066E, lshift(r0648, r0671), 0x01));

                                 ir_expression *const r067D = bit_and(r066D, body.constant(int(31)));
                                 body.emit(assign(r066F, rshift(r0648, r067D), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f067B->else_instructions;

                                 ir_variable *const r067E = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0680 = equal(r066D, body.constant(int(64)));
                                 ir_if *f067F = new(mem_ctx) ir_if(operand(r0680).val);
                                 exec_list *const f067F_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f067F->then_instructions;

                                    body.emit(assign(r067E, r0648, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f067F->else_instructions;

                                    ir_expression *const r0681 = nequal(r0648, body.constant(0u));
                                    ir_expression *const r0682 = expr(ir_unop_b2i, r0681);
                                    body.emit(assign(r067E, expr(ir_unop_i2u, r0682), 0x01));


                                 body.instructions = f067F_parent_instructions;
                                 body.emit(f067F);

                                 /* END IF */

                                 body.emit(assign(r066E, r067E, 0x01));

                                 body.emit(assign(r066F, body.constant(0u), 0x01));


                              body.instructions = f067B_parent_instructions;
                              body.emit(f067B);

                              /* END IF */


                           body.instructions = f0679_parent_instructions;
                           body.emit(f0679);

                           /* END IF */

                           body.emit(assign(r0670, body.constant(0u), 0x01));


                        body.instructions = f0675_parent_instructions;
                        body.emit(f0675);

                        /* END IF */

                        ir_expression *const r0683 = nequal(r066C, body.constant(0u));
                        ir_expression *const r0684 = expr(ir_unop_b2i, r0683);
                        ir_expression *const r0685 = expr(ir_unop_i2u, r0684);
                        body.emit(assign(r066E, bit_or(r066E, r0685), 0x01));


                     body.instructions = f0673_parent_instructions;
                     body.emit(f0673);

                     /* END IF */

                     body.emit(assign(r0648, r0670, 0x01));

                     body.emit(assign(r0649, r066F, 0x01));

                     body.emit(assign(r064A, r066E, 0x01));


                  body.instructions = f0662_parent_instructions;
                  body.emit(f0662);

                  /* END IF */

                  body.emit(assign(r0647, sub(r0647, r064B), 0x01));

                  ir_variable *const r0686 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r0686, r0647, 0x01));

                  ir_variable *const r0687 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r0687, r0648, 0x01));

                  ir_variable *const r0688 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r0688, r0649, 0x01));

                  ir_variable *const r0689 = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r0689, r064A, 0x01));

                  ir_variable *const r068A = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r068A, body.constant(true), 0x01));

                  ir_variable *const r068B = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r068C = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r068C);
                  ir_expression *const r068D = expr(ir_unop_u2i, r064A);
                  body.emit(assign(r068C, less(r068D, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r068F = lequal(body.constant(int(2045)), r0647);
                  ir_if *f068E = new(mem_ctx) ir_if(operand(r068F).val);
                  exec_list *const f068E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f068E->then_instructions;

                     ir_variable *const r0690 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0692 = less(body.constant(int(2045)), r0647);
                     ir_if *f0691 = new(mem_ctx) ir_if(operand(r0692).val);
                     exec_list *const f0691_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0691->then_instructions;

                        body.emit(assign(r0690, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0691->else_instructions;

                        ir_variable *const r0693 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0695 = equal(r0647, body.constant(int(2045)));
                        ir_if *f0694 = new(mem_ctx) ir_if(operand(r0695).val);
                        exec_list *const f0694_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0694->then_instructions;

                           ir_expression *const r0696 = equal(body.constant(2097151u), r0648);
                           ir_expression *const r0697 = equal(body.constant(4294967295u), r0649);
                           body.emit(assign(r0693, logic_and(r0696, r0697), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0694->else_instructions;

                           body.emit(assign(r0693, body.constant(false), 0x01));


                        body.instructions = f0694_parent_instructions;
                        body.emit(f0694);

                        /* END IF */

                        body.emit(assign(r0690, logic_and(r0693, r068C), 0x01));


                     body.instructions = f0691_parent_instructions;
                     body.emit(f0691);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f0698 = new(mem_ctx) ir_if(operand(r0690).val);
                     exec_list *const f0698_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0698->then_instructions;

                        ir_variable *const r0699 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r0699);
                        ir_expression *const r069A = lshift(r03D0, body.constant(int(31)));
                        body.emit(assign(r0699, add(r069A, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r0699, body.constant(0u), 0x01));

                        body.emit(assign(r068B, r0699, 0x03));

                        body.emit(assign(r068A, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0698->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r069C = less(r0647, body.constant(int(0)));
                        ir_if *f069B = new(mem_ctx) ir_if(operand(r069C).val);
                        exec_list *const f069B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f069B->then_instructions;

                           ir_variable *const r069D = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r069D, r064A, 0x01));

                           ir_variable *const r069E = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r069E, neg(r0647), 0x01));

                           ir_variable *const r069F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r069F);
                           ir_variable *const r06A0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r06A0);
                           ir_variable *const r06A1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r06A1);
                           ir_variable *const r06A2 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r06A3 = neg(r069E);
                           body.emit(assign(r06A2, bit_and(r06A3, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r06A5 = equal(r069E, body.constant(int(0)));
                           ir_if *f06A4 = new(mem_ctx) ir_if(operand(r06A5).val);
                           exec_list *const f06A4_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f06A4->then_instructions;

                              body.emit(assign(r069F, r064A, 0x01));

                              body.emit(assign(r06A0, r0649, 0x01));

                              body.emit(assign(r06A1, r0648, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f06A4->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r06A7 = less(r069E, body.constant(int(32)));
                              ir_if *f06A6 = new(mem_ctx) ir_if(operand(r06A7).val);
                              exec_list *const f06A6_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f06A6->then_instructions;

                                 body.emit(assign(r069F, lshift(r0649, r06A2), 0x01));

                                 ir_expression *const r06A8 = lshift(r0648, r06A2);
                                 ir_expression *const r06A9 = rshift(r0649, r069E);
                                 body.emit(assign(r06A0, bit_or(r06A8, r06A9), 0x01));

                                 body.emit(assign(r06A1, rshift(r0648, r069E), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f06A6->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r06AB = equal(r069E, body.constant(int(32)));
                                 ir_if *f06AA = new(mem_ctx) ir_if(operand(r06AB).val);
                                 exec_list *const f06AA_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f06AA->then_instructions;

                                    body.emit(assign(r069F, r0649, 0x01));

                                    body.emit(assign(r06A0, r0648, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f06AA->else_instructions;

                                    body.emit(assign(r069D, bit_or(r064A, r0649), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r06AD = less(r069E, body.constant(int(64)));
                                    ir_if *f06AC = new(mem_ctx) ir_if(operand(r06AD).val);
                                    exec_list *const f06AC_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f06AC->then_instructions;

                                       body.emit(assign(r069F, lshift(r0648, r06A2), 0x01));

                                       ir_expression *const r06AE = bit_and(r069E, body.constant(int(31)));
                                       body.emit(assign(r06A0, rshift(r0648, r06AE), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f06AC->else_instructions;

                                       ir_variable *const r06AF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r06B1 = equal(r069E, body.constant(int(64)));
                                       ir_if *f06B0 = new(mem_ctx) ir_if(operand(r06B1).val);
                                       exec_list *const f06B0_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f06B0->then_instructions;

                                          body.emit(assign(r06AF, r0648, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f06B0->else_instructions;

                                          ir_expression *const r06B2 = nequal(r0648, body.constant(0u));
                                          ir_expression *const r06B3 = expr(ir_unop_b2i, r06B2);
                                          body.emit(assign(r06AF, expr(ir_unop_i2u, r06B3), 0x01));


                                       body.instructions = f06B0_parent_instructions;
                                       body.emit(f06B0);

                                       /* END IF */

                                       body.emit(assign(r069F, r06AF, 0x01));

                                       body.emit(assign(r06A0, body.constant(0u), 0x01));


                                    body.instructions = f06AC_parent_instructions;
                                    body.emit(f06AC);

                                    /* END IF */


                                 body.instructions = f06AA_parent_instructions;
                                 body.emit(f06AA);

                                 /* END IF */

                                 body.emit(assign(r06A1, body.constant(0u), 0x01));


                              body.instructions = f06A6_parent_instructions;
                              body.emit(f06A6);

                              /* END IF */

                              ir_expression *const r06B4 = nequal(r069D, body.constant(0u));
                              ir_expression *const r06B5 = expr(ir_unop_b2i, r06B4);
                              ir_expression *const r06B6 = expr(ir_unop_i2u, r06B5);
                              body.emit(assign(r069F, bit_or(r069F, r06B6), 0x01));


                           body.instructions = f06A4_parent_instructions;
                           body.emit(f06A4);

                           /* END IF */

                           body.emit(assign(r0687, r06A1, 0x01));

                           body.emit(assign(r0688, r06A0, 0x01));

                           body.emit(assign(r0689, r069F, 0x01));

                           body.emit(assign(r0686, body.constant(int(0)), 0x01));

                           body.emit(assign(r068C, less(r069F, body.constant(0u)), 0x01));


                        body.instructions = f069B_parent_instructions;
                        body.emit(f069B);

                        /* END IF */


                     body.instructions = f0698_parent_instructions;
                     body.emit(f0698);

                     /* END IF */


                  body.instructions = f068E_parent_instructions;
                  body.emit(f068E);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f06B7 = new(mem_ctx) ir_if(operand(r068A).val);
                  exec_list *const f06B7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f06B7->then_instructions;

                     /* IF CONDITION */
                     ir_if *f06B8 = new(mem_ctx) ir_if(operand(r068C).val);
                     exec_list *const f06B8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f06B8->then_instructions;

                        ir_variable *const r06B9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r06B9, add(r0688, body.constant(1u)), 0x01));

                        ir_expression *const r06BA = less(r06B9, r0688);
                        ir_expression *const r06BB = expr(ir_unop_b2i, r06BA);
                        ir_expression *const r06BC = expr(ir_unop_i2u, r06BB);
                        body.emit(assign(r0687, add(r0687, r06BC), 0x01));

                        ir_expression *const r06BD = equal(r0689, body.constant(0u));
                        ir_expression *const r06BE = expr(ir_unop_b2i, r06BD);
                        ir_expression *const r06BF = expr(ir_unop_i2u, r06BE);
                        ir_expression *const r06C0 = add(r0689, r06BF);
                        ir_expression *const r06C1 = bit_and(r06C0, body.constant(1u));
                        ir_expression *const r06C2 = expr(ir_unop_bit_not, r06C1);
                        body.emit(assign(r0688, bit_and(r06B9, r06C2), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f06B8->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r06C4 = bit_or(r0687, r0688);
                        ir_expression *const r06C5 = equal(r06C4, body.constant(0u));
                        ir_if *f06C3 = new(mem_ctx) ir_if(operand(r06C5).val);
                        exec_list *const f06C3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06C3->then_instructions;

                           body.emit(assign(r0686, body.constant(int(0)), 0x01));


                        body.instructions = f06C3_parent_instructions;
                        body.emit(f06C3);

                        /* END IF */


                     body.instructions = f06B8_parent_instructions;
                     body.emit(f06B8);

                     /* END IF */

                     ir_variable *const r06C6 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r06C6);
                     ir_expression *const r06C7 = lshift(r03D0, body.constant(int(31)));
                     ir_expression *const r06C8 = expr(ir_unop_i2u, r0686);
                     ir_expression *const r06C9 = lshift(r06C8, body.constant(int(20)));
                     ir_expression *const r06CA = add(r06C7, r06C9);
                     body.emit(assign(r06C6, add(r06CA, r0687), 0x02));

                     body.emit(assign(r06C6, r0688, 0x01));

                     body.emit(assign(r068B, r06C6, 0x03));

                     body.emit(assign(r068A, body.constant(false), 0x01));


                  body.instructions = f06B7_parent_instructions;
                  body.emit(f06B7);

                  /* END IF */

                  body.emit(assign(r03D1, r068B, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f063F->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r06CC = less(swizzle_x(r03D4), swizzle_x(r03D6));
                  ir_if *f06CB = new(mem_ctx) ir_if(operand(r06CC).val);
                  exec_list *const f06CB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f06CB->then_instructions;

                     ir_variable *const r06CD = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r06CE = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r06CE, sub(swizzle_x(r03D6), swizzle_x(r03D4)), 0x01));

                     ir_expression *const r06CF = sub(swizzle_y(r03D6), swizzle_y(r03D4));
                     ir_expression *const r06D0 = less(swizzle_x(r03D6), swizzle_x(r03D4));
                     ir_expression *const r06D1 = expr(ir_unop_b2i, r06D0);
                     ir_expression *const r06D2 = expr(ir_unop_i2u, r06D1);
                     body.emit(assign(r06CD, sub(r06CF, r06D2), 0x01));

                     body.emit(assign(r03D7, add(r03D5, body.constant(int(-1))), 0x01));

                     ir_variable *const r06D3 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r06D3, add(r03D7, body.constant(int(-10))), 0x01));

                     ir_variable *const r06D4 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r06D4, r06CD, 0x01));

                     ir_variable *const r06D5 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r06D5, r06CE, 0x01));

                     ir_variable *const r06D6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r06D6);
                     ir_variable *const r06D7 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r06D7);
                     /* IF CONDITION */
                     ir_expression *const r06D9 = equal(r06CD, body.constant(0u));
                     ir_if *f06D8 = new(mem_ctx) ir_if(operand(r06D9).val);
                     exec_list *const f06D8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f06D8->then_instructions;

                        body.emit(assign(r06D4, r06CE, 0x01));

                        body.emit(assign(r06D5, body.constant(0u), 0x01));

                        body.emit(assign(r06D3, add(r06D3, body.constant(int(-32))), 0x01));


                     body.instructions = f06D8_parent_instructions;
                     body.emit(f06D8);

                     /* END IF */

                     ir_variable *const r06DA = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r06DA, r06D4, 0x01));

                     ir_variable *const r06DB = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r06DC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r06DC);
                     /* IF CONDITION */
                     ir_expression *const r06DE = equal(r06D4, body.constant(0u));
                     ir_if *f06DD = new(mem_ctx) ir_if(operand(r06DE).val);
                     exec_list *const f06DD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f06DD->then_instructions;

                        body.emit(assign(r06DB, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f06DD->else_instructions;

                        body.emit(assign(r06DC, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r06E0 = bit_and(r06D4, body.constant(4294901760u));
                        ir_expression *const r06E1 = equal(r06E0, body.constant(0u));
                        ir_if *f06DF = new(mem_ctx) ir_if(operand(r06E1).val);
                        exec_list *const f06DF_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06DF->then_instructions;

                           body.emit(assign(r06DC, body.constant(int(16)), 0x01));

                           body.emit(assign(r06DA, lshift(r06D4, body.constant(int(16))), 0x01));


                        body.instructions = f06DF_parent_instructions;
                        body.emit(f06DF);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r06E3 = bit_and(r06DA, body.constant(4278190080u));
                        ir_expression *const r06E4 = equal(r06E3, body.constant(0u));
                        ir_if *f06E2 = new(mem_ctx) ir_if(operand(r06E4).val);
                        exec_list *const f06E2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06E2->then_instructions;

                           body.emit(assign(r06DC, add(r06DC, body.constant(int(8))), 0x01));

                           body.emit(assign(r06DA, lshift(r06DA, body.constant(int(8))), 0x01));


                        body.instructions = f06E2_parent_instructions;
                        body.emit(f06E2);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r06E6 = bit_and(r06DA, body.constant(4026531840u));
                        ir_expression *const r06E7 = equal(r06E6, body.constant(0u));
                        ir_if *f06E5 = new(mem_ctx) ir_if(operand(r06E7).val);
                        exec_list *const f06E5_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06E5->then_instructions;

                           body.emit(assign(r06DC, add(r06DC, body.constant(int(4))), 0x01));

                           body.emit(assign(r06DA, lshift(r06DA, body.constant(int(4))), 0x01));


                        body.instructions = f06E5_parent_instructions;
                        body.emit(f06E5);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r06E9 = bit_and(r06DA, body.constant(3221225472u));
                        ir_expression *const r06EA = equal(r06E9, body.constant(0u));
                        ir_if *f06E8 = new(mem_ctx) ir_if(operand(r06EA).val);
                        exec_list *const f06E8_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06E8->then_instructions;

                           body.emit(assign(r06DC, add(r06DC, body.constant(int(2))), 0x01));

                           body.emit(assign(r06DA, lshift(r06DA, body.constant(int(2))), 0x01));


                        body.instructions = f06E8_parent_instructions;
                        body.emit(f06E8);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r06EC = bit_and(r06DA, body.constant(2147483648u));
                        ir_expression *const r06ED = equal(r06EC, body.constant(0u));
                        ir_if *f06EB = new(mem_ctx) ir_if(operand(r06ED).val);
                        exec_list *const f06EB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06EB->then_instructions;

                           body.emit(assign(r06DC, add(r06DC, body.constant(int(1))), 0x01));


                        body.instructions = f06EB_parent_instructions;
                        body.emit(f06EB);

                        /* END IF */

                        body.emit(assign(r06DB, r06DC, 0x01));


                     body.instructions = f06DD_parent_instructions;
                     body.emit(f06DD);

                     /* END IF */

                     body.emit(assign(r06D7, add(r06DB, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r06EF = lequal(body.constant(int(0)), r06D7);
                     ir_if *f06EE = new(mem_ctx) ir_if(operand(r06EF).val);
                     exec_list *const f06EE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f06EE->then_instructions;

                        body.emit(assign(r06D6, body.constant(0u), 0x01));

                        ir_variable *const r06F0 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r06F0, lshift(r06D5, r06D7), 0x01));

                        ir_variable *const r06F1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r06F3 = equal(r06D7, body.constant(int(0)));
                        ir_if *f06F2 = new(mem_ctx) ir_if(operand(r06F3).val);
                        exec_list *const f06F2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06F2->then_instructions;

                           body.emit(assign(r06F1, r06D4, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f06F2->else_instructions;

                           ir_expression *const r06F4 = lshift(r06D4, r06D7);
                           ir_expression *const r06F5 = neg(r06D7);
                           ir_expression *const r06F6 = bit_and(r06F5, body.constant(int(31)));
                           ir_expression *const r06F7 = rshift(r06D5, r06F6);
                           body.emit(assign(r06F1, bit_or(r06F4, r06F7), 0x01));


                        body.instructions = f06F2_parent_instructions;
                        body.emit(f06F2);

                        /* END IF */

                        body.emit(assign(r06D4, r06F1, 0x01));

                        body.emit(assign(r06D5, r06F0, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f06EE->else_instructions;

                        ir_variable *const r06F8 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r06F8, body.constant(0u), 0x01));

                        ir_variable *const r06F9 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r06F9, neg(r06D7), 0x01));

                        ir_variable *const r06FA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r06FA);
                        ir_variable *const r06FB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r06FB);
                        ir_variable *const r06FC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r06FC);
                        ir_variable *const r06FD = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r06FE = neg(r06F9);
                        body.emit(assign(r06FD, bit_and(r06FE, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0700 = equal(r06F9, body.constant(int(0)));
                        ir_if *f06FF = new(mem_ctx) ir_if(operand(r0700).val);
                        exec_list *const f06FF_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f06FF->then_instructions;

                           body.emit(assign(r06FA, r06F8, 0x01));

                           body.emit(assign(r06FB, r06D5, 0x01));

                           body.emit(assign(r06FC, r06D4, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f06FF->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0702 = less(r06F9, body.constant(int(32)));
                           ir_if *f0701 = new(mem_ctx) ir_if(operand(r0702).val);
                           exec_list *const f0701_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0701->then_instructions;

                              body.emit(assign(r06FA, lshift(r06D5, r06FD), 0x01));

                              ir_expression *const r0703 = lshift(r06D4, r06FD);
                              ir_expression *const r0704 = rshift(r06D5, r06F9);
                              body.emit(assign(r06FB, bit_or(r0703, r0704), 0x01));

                              body.emit(assign(r06FC, rshift(r06D4, r06F9), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0701->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0706 = equal(r06F9, body.constant(int(32)));
                              ir_if *f0705 = new(mem_ctx) ir_if(operand(r0706).val);
                              exec_list *const f0705_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0705->then_instructions;

                                 body.emit(assign(r06FA, r06D5, 0x01));

                                 body.emit(assign(r06FB, r06D4, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0705->else_instructions;

                                 body.emit(assign(r06F8, bit_or(body.constant(0u), r06D5), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0708 = less(r06F9, body.constant(int(64)));
                                 ir_if *f0707 = new(mem_ctx) ir_if(operand(r0708).val);
                                 exec_list *const f0707_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0707->then_instructions;

                                    body.emit(assign(r06FA, lshift(r06D4, r06FD), 0x01));

                                    ir_expression *const r0709 = bit_and(r06F9, body.constant(int(31)));
                                    body.emit(assign(r06FB, rshift(r06D4, r0709), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0707->else_instructions;

                                    ir_variable *const r070A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r070C = equal(r06F9, body.constant(int(64)));
                                    ir_if *f070B = new(mem_ctx) ir_if(operand(r070C).val);
                                    exec_list *const f070B_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f070B->then_instructions;

                                       body.emit(assign(r070A, r06D4, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f070B->else_instructions;

                                       ir_expression *const r070D = nequal(r06D4, body.constant(0u));
                                       ir_expression *const r070E = expr(ir_unop_b2i, r070D);
                                       body.emit(assign(r070A, expr(ir_unop_i2u, r070E), 0x01));


                                    body.instructions = f070B_parent_instructions;
                                    body.emit(f070B);

                                    /* END IF */

                                    body.emit(assign(r06FA, r070A, 0x01));

                                    body.emit(assign(r06FB, body.constant(0u), 0x01));


                                 body.instructions = f0707_parent_instructions;
                                 body.emit(f0707);

                                 /* END IF */


                              body.instructions = f0705_parent_instructions;
                              body.emit(f0705);

                              /* END IF */

                              body.emit(assign(r06FC, body.constant(0u), 0x01));


                           body.instructions = f0701_parent_instructions;
                           body.emit(f0701);

                           /* END IF */

                           ir_expression *const r070F = nequal(r06F8, body.constant(0u));
                           ir_expression *const r0710 = expr(ir_unop_b2i, r070F);
                           ir_expression *const r0711 = expr(ir_unop_i2u, r0710);
                           body.emit(assign(r06FA, bit_or(r06FA, r0711), 0x01));


                        body.instructions = f06FF_parent_instructions;
                        body.emit(f06FF);

                        /* END IF */

                        body.emit(assign(r06D4, r06FC, 0x01));

                        body.emit(assign(r06D5, r06FB, 0x01));

                        body.emit(assign(r06D6, r06FA, 0x01));


                     body.instructions = f06EE_parent_instructions;
                     body.emit(f06EE);

                     /* END IF */

                     body.emit(assign(r06D3, sub(r06D3, r06D7), 0x01));

                     ir_variable *const r0712 = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r0712, r06D3, 0x01));

                     ir_variable *const r0713 = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r0713, r06D4, 0x01));

                     ir_variable *const r0714 = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r0714, r06D5, 0x01));

                     ir_variable *const r0715 = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r0715, r06D6, 0x01));

                     ir_variable *const r0716 = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r0716, body.constant(true), 0x01));

                     ir_variable *const r0717 = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r0718 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r0718);
                     ir_expression *const r0719 = expr(ir_unop_u2i, r06D6);
                     body.emit(assign(r0718, less(r0719, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r071B = lequal(body.constant(int(2045)), r06D3);
                     ir_if *f071A = new(mem_ctx) ir_if(operand(r071B).val);
                     exec_list *const f071A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f071A->then_instructions;

                        ir_variable *const r071C = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r071E = less(body.constant(int(2045)), r06D3);
                        ir_if *f071D = new(mem_ctx) ir_if(operand(r071E).val);
                        exec_list *const f071D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f071D->then_instructions;

                           body.emit(assign(r071C, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f071D->else_instructions;

                           ir_variable *const r071F = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0721 = equal(r06D3, body.constant(int(2045)));
                           ir_if *f0720 = new(mem_ctx) ir_if(operand(r0721).val);
                           exec_list *const f0720_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0720->then_instructions;

                              ir_expression *const r0722 = equal(body.constant(2097151u), r06D4);
                              ir_expression *const r0723 = equal(body.constant(4294967295u), r06D5);
                              body.emit(assign(r071F, logic_and(r0722, r0723), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0720->else_instructions;

                              body.emit(assign(r071F, body.constant(false), 0x01));


                           body.instructions = f0720_parent_instructions;
                           body.emit(f0720);

                           /* END IF */

                           body.emit(assign(r071C, logic_and(r071F, r0718), 0x01));


                        body.instructions = f071D_parent_instructions;
                        body.emit(f071D);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f0724 = new(mem_ctx) ir_if(operand(r071C).val);
                        exec_list *const f0724_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0724->then_instructions;

                           ir_variable *const r0725 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r0725);
                           ir_expression *const r0726 = lshift(r03D0, body.constant(int(31)));
                           body.emit(assign(r0725, add(r0726, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r0725, body.constant(0u), 0x01));

                           body.emit(assign(r0717, r0725, 0x03));

                           body.emit(assign(r0716, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0724->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0728 = less(r06D3, body.constant(int(0)));
                           ir_if *f0727 = new(mem_ctx) ir_if(operand(r0728).val);
                           exec_list *const f0727_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0727->then_instructions;

                              ir_variable *const r0729 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r0729, r06D6, 0x01));

                              ir_variable *const r072A = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r072A, neg(r06D3), 0x01));

                              ir_variable *const r072B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r072B);
                              ir_variable *const r072C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r072C);
                              ir_variable *const r072D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r072D);
                              ir_variable *const r072E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r072F = neg(r072A);
                              body.emit(assign(r072E, bit_and(r072F, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0731 = equal(r072A, body.constant(int(0)));
                              ir_if *f0730 = new(mem_ctx) ir_if(operand(r0731).val);
                              exec_list *const f0730_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0730->then_instructions;

                                 body.emit(assign(r072B, r06D6, 0x01));

                                 body.emit(assign(r072C, r06D5, 0x01));

                                 body.emit(assign(r072D, r06D4, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0730->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0733 = less(r072A, body.constant(int(32)));
                                 ir_if *f0732 = new(mem_ctx) ir_if(operand(r0733).val);
                                 exec_list *const f0732_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0732->then_instructions;

                                    body.emit(assign(r072B, lshift(r06D5, r072E), 0x01));

                                    ir_expression *const r0734 = lshift(r06D4, r072E);
                                    ir_expression *const r0735 = rshift(r06D5, r072A);
                                    body.emit(assign(r072C, bit_or(r0734, r0735), 0x01));

                                    body.emit(assign(r072D, rshift(r06D4, r072A), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0732->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r0737 = equal(r072A, body.constant(int(32)));
                                    ir_if *f0736 = new(mem_ctx) ir_if(operand(r0737).val);
                                    exec_list *const f0736_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0736->then_instructions;

                                       body.emit(assign(r072B, r06D5, 0x01));

                                       body.emit(assign(r072C, r06D4, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0736->else_instructions;

                                       body.emit(assign(r0729, bit_or(r06D6, r06D5), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r0739 = less(r072A, body.constant(int(64)));
                                       ir_if *f0738 = new(mem_ctx) ir_if(operand(r0739).val);
                                       exec_list *const f0738_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0738->then_instructions;

                                          body.emit(assign(r072B, lshift(r06D4, r072E), 0x01));

                                          ir_expression *const r073A = bit_and(r072A, body.constant(int(31)));
                                          body.emit(assign(r072C, rshift(r06D4, r073A), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0738->else_instructions;

                                          ir_variable *const r073B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r073D = equal(r072A, body.constant(int(64)));
                                          ir_if *f073C = new(mem_ctx) ir_if(operand(r073D).val);
                                          exec_list *const f073C_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f073C->then_instructions;

                                             body.emit(assign(r073B, r06D4, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f073C->else_instructions;

                                             ir_expression *const r073E = nequal(r06D4, body.constant(0u));
                                             ir_expression *const r073F = expr(ir_unop_b2i, r073E);
                                             body.emit(assign(r073B, expr(ir_unop_i2u, r073F), 0x01));


                                          body.instructions = f073C_parent_instructions;
                                          body.emit(f073C);

                                          /* END IF */

                                          body.emit(assign(r072B, r073B, 0x01));

                                          body.emit(assign(r072C, body.constant(0u), 0x01));


                                       body.instructions = f0738_parent_instructions;
                                       body.emit(f0738);

                                       /* END IF */


                                    body.instructions = f0736_parent_instructions;
                                    body.emit(f0736);

                                    /* END IF */

                                    body.emit(assign(r072D, body.constant(0u), 0x01));


                                 body.instructions = f0732_parent_instructions;
                                 body.emit(f0732);

                                 /* END IF */

                                 ir_expression *const r0740 = nequal(r0729, body.constant(0u));
                                 ir_expression *const r0741 = expr(ir_unop_b2i, r0740);
                                 ir_expression *const r0742 = expr(ir_unop_i2u, r0741);
                                 body.emit(assign(r072B, bit_or(r072B, r0742), 0x01));


                              body.instructions = f0730_parent_instructions;
                              body.emit(f0730);

                              /* END IF */

                              body.emit(assign(r0713, r072D, 0x01));

                              body.emit(assign(r0714, r072C, 0x01));

                              body.emit(assign(r0715, r072B, 0x01));

                              body.emit(assign(r0712, body.constant(int(0)), 0x01));

                              body.emit(assign(r0718, less(r072B, body.constant(0u)), 0x01));


                           body.instructions = f0727_parent_instructions;
                           body.emit(f0727);

                           /* END IF */


                        body.instructions = f0724_parent_instructions;
                        body.emit(f0724);

                        /* END IF */


                     body.instructions = f071A_parent_instructions;
                     body.emit(f071A);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f0743 = new(mem_ctx) ir_if(operand(r0716).val);
                     exec_list *const f0743_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0743->then_instructions;

                        /* IF CONDITION */
                        ir_if *f0744 = new(mem_ctx) ir_if(operand(r0718).val);
                        exec_list *const f0744_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0744->then_instructions;

                           ir_variable *const r0745 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r0745, add(r0714, body.constant(1u)), 0x01));

                           ir_expression *const r0746 = less(r0745, r0714);
                           ir_expression *const r0747 = expr(ir_unop_b2i, r0746);
                           ir_expression *const r0748 = expr(ir_unop_i2u, r0747);
                           body.emit(assign(r0713, add(r0713, r0748), 0x01));

                           ir_expression *const r0749 = equal(r0715, body.constant(0u));
                           ir_expression *const r074A = expr(ir_unop_b2i, r0749);
                           ir_expression *const r074B = expr(ir_unop_i2u, r074A);
                           ir_expression *const r074C = add(r0715, r074B);
                           ir_expression *const r074D = bit_and(r074C, body.constant(1u));
                           ir_expression *const r074E = expr(ir_unop_bit_not, r074D);
                           body.emit(assign(r0714, bit_and(r0745, r074E), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0744->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0750 = bit_or(r0713, r0714);
                           ir_expression *const r0751 = equal(r0750, body.constant(0u));
                           ir_if *f074F = new(mem_ctx) ir_if(operand(r0751).val);
                           exec_list *const f074F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f074F->then_instructions;

                              body.emit(assign(r0712, body.constant(int(0)), 0x01));


                           body.instructions = f074F_parent_instructions;
                           body.emit(f074F);

                           /* END IF */


                        body.instructions = f0744_parent_instructions;
                        body.emit(f0744);

                        /* END IF */

                        ir_variable *const r0752 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r0752);
                        ir_expression *const r0753 = lshift(r03D0, body.constant(int(31)));
                        ir_expression *const r0754 = expr(ir_unop_i2u, r0712);
                        ir_expression *const r0755 = lshift(r0754, body.constant(int(20)));
                        ir_expression *const r0756 = add(r0753, r0755);
                        body.emit(assign(r0752, add(r0756, r0713), 0x02));

                        body.emit(assign(r0752, r0714, 0x01));

                        body.emit(assign(r0717, r0752, 0x03));

                        body.emit(assign(r0716, body.constant(false), 0x01));


                     body.instructions = f0743_parent_instructions;
                     body.emit(f0743);

                     /* END IF */

                     body.emit(assign(r03D1, r0717, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f06CB->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0758 = less(swizzle_x(r03D6), swizzle_x(r03D4));
                     ir_if *f0757 = new(mem_ctx) ir_if(operand(r0758).val);
                     exec_list *const f0757_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0757->then_instructions;

                        ir_variable *const r0759 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r075A = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r075A, sub(swizzle_x(r03D4), swizzle_x(r03D6)), 0x01));

                        ir_expression *const r075B = sub(swizzle_y(r03D4), swizzle_y(r03D6));
                        ir_expression *const r075C = less(swizzle_x(r03D4), swizzle_x(r03D6));
                        ir_expression *const r075D = expr(ir_unop_b2i, r075C);
                        ir_expression *const r075E = expr(ir_unop_i2u, r075D);
                        body.emit(assign(r0759, sub(r075B, r075E), 0x01));

                        body.emit(assign(r03D0, bit_xor(r03D0, body.constant(1u)), 0x01));

                        body.emit(assign(r03D7, add(r03D3, body.constant(int(-1))), 0x01));

                        ir_variable *const r075F = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r075F, add(r03D7, body.constant(int(-10))), 0x01));

                        ir_variable *const r0760 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r0760, r0759, 0x01));

                        ir_variable *const r0761 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r0761, r075A, 0x01));

                        ir_variable *const r0762 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r0762);
                        ir_variable *const r0763 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r0763);
                        /* IF CONDITION */
                        ir_expression *const r0765 = equal(r0759, body.constant(0u));
                        ir_if *f0764 = new(mem_ctx) ir_if(operand(r0765).val);
                        exec_list *const f0764_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0764->then_instructions;

                           body.emit(assign(r0760, r075A, 0x01));

                           body.emit(assign(r0761, body.constant(0u), 0x01));

                           body.emit(assign(r075F, add(r075F, body.constant(int(-32))), 0x01));


                        body.instructions = f0764_parent_instructions;
                        body.emit(f0764);

                        /* END IF */

                        ir_variable *const r0766 = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r0766, r0760, 0x01));

                        ir_variable *const r0767 = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r0768 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r0768);
                        /* IF CONDITION */
                        ir_expression *const r076A = equal(r0760, body.constant(0u));
                        ir_if *f0769 = new(mem_ctx) ir_if(operand(r076A).val);
                        exec_list *const f0769_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0769->then_instructions;

                           body.emit(assign(r0767, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0769->else_instructions;

                           body.emit(assign(r0768, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r076C = bit_and(r0760, body.constant(4294901760u));
                           ir_expression *const r076D = equal(r076C, body.constant(0u));
                           ir_if *f076B = new(mem_ctx) ir_if(operand(r076D).val);
                           exec_list *const f076B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f076B->then_instructions;

                              body.emit(assign(r0768, body.constant(int(16)), 0x01));

                              body.emit(assign(r0766, lshift(r0760, body.constant(int(16))), 0x01));


                           body.instructions = f076B_parent_instructions;
                           body.emit(f076B);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r076F = bit_and(r0766, body.constant(4278190080u));
                           ir_expression *const r0770 = equal(r076F, body.constant(0u));
                           ir_if *f076E = new(mem_ctx) ir_if(operand(r0770).val);
                           exec_list *const f076E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f076E->then_instructions;

                              body.emit(assign(r0768, add(r0768, body.constant(int(8))), 0x01));

                              body.emit(assign(r0766, lshift(r0766, body.constant(int(8))), 0x01));


                           body.instructions = f076E_parent_instructions;
                           body.emit(f076E);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0772 = bit_and(r0766, body.constant(4026531840u));
                           ir_expression *const r0773 = equal(r0772, body.constant(0u));
                           ir_if *f0771 = new(mem_ctx) ir_if(operand(r0773).val);
                           exec_list *const f0771_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0771->then_instructions;

                              body.emit(assign(r0768, add(r0768, body.constant(int(4))), 0x01));

                              body.emit(assign(r0766, lshift(r0766, body.constant(int(4))), 0x01));


                           body.instructions = f0771_parent_instructions;
                           body.emit(f0771);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0775 = bit_and(r0766, body.constant(3221225472u));
                           ir_expression *const r0776 = equal(r0775, body.constant(0u));
                           ir_if *f0774 = new(mem_ctx) ir_if(operand(r0776).val);
                           exec_list *const f0774_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0774->then_instructions;

                              body.emit(assign(r0768, add(r0768, body.constant(int(2))), 0x01));

                              body.emit(assign(r0766, lshift(r0766, body.constant(int(2))), 0x01));


                           body.instructions = f0774_parent_instructions;
                           body.emit(f0774);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0778 = bit_and(r0766, body.constant(2147483648u));
                           ir_expression *const r0779 = equal(r0778, body.constant(0u));
                           ir_if *f0777 = new(mem_ctx) ir_if(operand(r0779).val);
                           exec_list *const f0777_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0777->then_instructions;

                              body.emit(assign(r0768, add(r0768, body.constant(int(1))), 0x01));


                           body.instructions = f0777_parent_instructions;
                           body.emit(f0777);

                           /* END IF */

                           body.emit(assign(r0767, r0768, 0x01));


                        body.instructions = f0769_parent_instructions;
                        body.emit(f0769);

                        /* END IF */

                        body.emit(assign(r0763, add(r0767, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r077B = lequal(body.constant(int(0)), r0763);
                        ir_if *f077A = new(mem_ctx) ir_if(operand(r077B).val);
                        exec_list *const f077A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f077A->then_instructions;

                           body.emit(assign(r0762, body.constant(0u), 0x01));

                           ir_variable *const r077C = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r077C, lshift(r0761, r0763), 0x01));

                           ir_variable *const r077D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r077F = equal(r0763, body.constant(int(0)));
                           ir_if *f077E = new(mem_ctx) ir_if(operand(r077F).val);
                           exec_list *const f077E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f077E->then_instructions;

                              body.emit(assign(r077D, r0760, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f077E->else_instructions;

                              ir_expression *const r0780 = lshift(r0760, r0763);
                              ir_expression *const r0781 = neg(r0763);
                              ir_expression *const r0782 = bit_and(r0781, body.constant(int(31)));
                              ir_expression *const r0783 = rshift(r0761, r0782);
                              body.emit(assign(r077D, bit_or(r0780, r0783), 0x01));


                           body.instructions = f077E_parent_instructions;
                           body.emit(f077E);

                           /* END IF */

                           body.emit(assign(r0760, r077D, 0x01));

                           body.emit(assign(r0761, r077C, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f077A->else_instructions;

                           ir_variable *const r0784 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r0784, body.constant(0u), 0x01));

                           ir_variable *const r0785 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r0785, neg(r0763), 0x01));

                           ir_variable *const r0786 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r0786);
                           ir_variable *const r0787 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r0787);
                           ir_variable *const r0788 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r0788);
                           ir_variable *const r0789 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r078A = neg(r0785);
                           body.emit(assign(r0789, bit_and(r078A, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r078C = equal(r0785, body.constant(int(0)));
                           ir_if *f078B = new(mem_ctx) ir_if(operand(r078C).val);
                           exec_list *const f078B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f078B->then_instructions;

                              body.emit(assign(r0786, r0784, 0x01));

                              body.emit(assign(r0787, r0761, 0x01));

                              body.emit(assign(r0788, r0760, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f078B->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r078E = less(r0785, body.constant(int(32)));
                              ir_if *f078D = new(mem_ctx) ir_if(operand(r078E).val);
                              exec_list *const f078D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f078D->then_instructions;

                                 body.emit(assign(r0786, lshift(r0761, r0789), 0x01));

                                 ir_expression *const r078F = lshift(r0760, r0789);
                                 ir_expression *const r0790 = rshift(r0761, r0785);
                                 body.emit(assign(r0787, bit_or(r078F, r0790), 0x01));

                                 body.emit(assign(r0788, rshift(r0760, r0785), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f078D->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0792 = equal(r0785, body.constant(int(32)));
                                 ir_if *f0791 = new(mem_ctx) ir_if(operand(r0792).val);
                                 exec_list *const f0791_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0791->then_instructions;

                                    body.emit(assign(r0786, r0761, 0x01));

                                    body.emit(assign(r0787, r0760, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0791->else_instructions;

                                    body.emit(assign(r0784, bit_or(body.constant(0u), r0761), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r0794 = less(r0785, body.constant(int(64)));
                                    ir_if *f0793 = new(mem_ctx) ir_if(operand(r0794).val);
                                    exec_list *const f0793_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0793->then_instructions;

                                       body.emit(assign(r0786, lshift(r0760, r0789), 0x01));

                                       ir_expression *const r0795 = bit_and(r0785, body.constant(int(31)));
                                       body.emit(assign(r0787, rshift(r0760, r0795), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0793->else_instructions;

                                       ir_variable *const r0796 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r0798 = equal(r0785, body.constant(int(64)));
                                       ir_if *f0797 = new(mem_ctx) ir_if(operand(r0798).val);
                                       exec_list *const f0797_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0797->then_instructions;

                                          body.emit(assign(r0796, r0760, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0797->else_instructions;

                                          ir_expression *const r0799 = nequal(r0760, body.constant(0u));
                                          ir_expression *const r079A = expr(ir_unop_b2i, r0799);
                                          body.emit(assign(r0796, expr(ir_unop_i2u, r079A), 0x01));


                                       body.instructions = f0797_parent_instructions;
                                       body.emit(f0797);

                                       /* END IF */

                                       body.emit(assign(r0786, r0796, 0x01));

                                       body.emit(assign(r0787, body.constant(0u), 0x01));


                                    body.instructions = f0793_parent_instructions;
                                    body.emit(f0793);

                                    /* END IF */


                                 body.instructions = f0791_parent_instructions;
                                 body.emit(f0791);

                                 /* END IF */

                                 body.emit(assign(r0788, body.constant(0u), 0x01));


                              body.instructions = f078D_parent_instructions;
                              body.emit(f078D);

                              /* END IF */

                              ir_expression *const r079B = nequal(r0784, body.constant(0u));
                              ir_expression *const r079C = expr(ir_unop_b2i, r079B);
                              ir_expression *const r079D = expr(ir_unop_i2u, r079C);
                              body.emit(assign(r0786, bit_or(r0786, r079D), 0x01));


                           body.instructions = f078B_parent_instructions;
                           body.emit(f078B);

                           /* END IF */

                           body.emit(assign(r0760, r0788, 0x01));

                           body.emit(assign(r0761, r0787, 0x01));

                           body.emit(assign(r0762, r0786, 0x01));


                        body.instructions = f077A_parent_instructions;
                        body.emit(f077A);

                        /* END IF */

                        body.emit(assign(r075F, sub(r075F, r0763), 0x01));

                        ir_variable *const r079E = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r079E, r075F, 0x01));

                        ir_variable *const r079F = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r079F, r0760, 0x01));

                        ir_variable *const r07A0 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r07A0, r0761, 0x01));

                        ir_variable *const r07A1 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r07A1, r0762, 0x01));

                        ir_variable *const r07A2 = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r07A2, body.constant(true), 0x01));

                        ir_variable *const r07A3 = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r07A4 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r07A4);
                        ir_expression *const r07A5 = expr(ir_unop_u2i, r0762);
                        body.emit(assign(r07A4, less(r07A5, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r07A7 = lequal(body.constant(int(2045)), r075F);
                        ir_if *f07A6 = new(mem_ctx) ir_if(operand(r07A7).val);
                        exec_list *const f07A6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f07A6->then_instructions;

                           ir_variable *const r07A8 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r07AA = less(body.constant(int(2045)), r075F);
                           ir_if *f07A9 = new(mem_ctx) ir_if(operand(r07AA).val);
                           exec_list *const f07A9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f07A9->then_instructions;

                              body.emit(assign(r07A8, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f07A9->else_instructions;

                              ir_variable *const r07AB = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r07AD = equal(r075F, body.constant(int(2045)));
                              ir_if *f07AC = new(mem_ctx) ir_if(operand(r07AD).val);
                              exec_list *const f07AC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f07AC->then_instructions;

                                 ir_expression *const r07AE = equal(body.constant(2097151u), r0760);
                                 ir_expression *const r07AF = equal(body.constant(4294967295u), r0761);
                                 body.emit(assign(r07AB, logic_and(r07AE, r07AF), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f07AC->else_instructions;

                                 body.emit(assign(r07AB, body.constant(false), 0x01));


                              body.instructions = f07AC_parent_instructions;
                              body.emit(f07AC);

                              /* END IF */

                              body.emit(assign(r07A8, logic_and(r07AB, r07A4), 0x01));


                           body.instructions = f07A9_parent_instructions;
                           body.emit(f07A9);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f07B0 = new(mem_ctx) ir_if(operand(r07A8).val);
                           exec_list *const f07B0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f07B0->then_instructions;

                              ir_variable *const r07B1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r07B1);
                              ir_expression *const r07B2 = lshift(r03D0, body.constant(int(31)));
                              body.emit(assign(r07B1, add(r07B2, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r07B1, body.constant(0u), 0x01));

                              body.emit(assign(r07A3, r07B1, 0x03));

                              body.emit(assign(r07A2, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f07B0->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r07B4 = less(r075F, body.constant(int(0)));
                              ir_if *f07B3 = new(mem_ctx) ir_if(operand(r07B4).val);
                              exec_list *const f07B3_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f07B3->then_instructions;

                                 ir_variable *const r07B5 = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r07B5, r0762, 0x01));

                                 ir_variable *const r07B6 = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r07B6, neg(r075F), 0x01));

                                 ir_variable *const r07B7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r07B7);
                                 ir_variable *const r07B8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r07B8);
                                 ir_variable *const r07B9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r07B9);
                                 ir_variable *const r07BA = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r07BB = neg(r07B6);
                                 body.emit(assign(r07BA, bit_and(r07BB, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r07BD = equal(r07B6, body.constant(int(0)));
                                 ir_if *f07BC = new(mem_ctx) ir_if(operand(r07BD).val);
                                 exec_list *const f07BC_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f07BC->then_instructions;

                                    body.emit(assign(r07B7, r0762, 0x01));

                                    body.emit(assign(r07B8, r0761, 0x01));

                                    body.emit(assign(r07B9, r0760, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f07BC->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r07BF = less(r07B6, body.constant(int(32)));
                                    ir_if *f07BE = new(mem_ctx) ir_if(operand(r07BF).val);
                                    exec_list *const f07BE_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f07BE->then_instructions;

                                       body.emit(assign(r07B7, lshift(r0761, r07BA), 0x01));

                                       ir_expression *const r07C0 = lshift(r0760, r07BA);
                                       ir_expression *const r07C1 = rshift(r0761, r07B6);
                                       body.emit(assign(r07B8, bit_or(r07C0, r07C1), 0x01));

                                       body.emit(assign(r07B9, rshift(r0760, r07B6), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f07BE->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r07C3 = equal(r07B6, body.constant(int(32)));
                                       ir_if *f07C2 = new(mem_ctx) ir_if(operand(r07C3).val);
                                       exec_list *const f07C2_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f07C2->then_instructions;

                                          body.emit(assign(r07B7, r0761, 0x01));

                                          body.emit(assign(r07B8, r0760, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f07C2->else_instructions;

                                          body.emit(assign(r07B5, bit_or(r0762, r0761), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r07C5 = less(r07B6, body.constant(int(64)));
                                          ir_if *f07C4 = new(mem_ctx) ir_if(operand(r07C5).val);
                                          exec_list *const f07C4_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f07C4->then_instructions;

                                             body.emit(assign(r07B7, lshift(r0760, r07BA), 0x01));

                                             ir_expression *const r07C6 = bit_and(r07B6, body.constant(int(31)));
                                             body.emit(assign(r07B8, rshift(r0760, r07C6), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f07C4->else_instructions;

                                             ir_variable *const r07C7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r07C9 = equal(r07B6, body.constant(int(64)));
                                             ir_if *f07C8 = new(mem_ctx) ir_if(operand(r07C9).val);
                                             exec_list *const f07C8_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f07C8->then_instructions;

                                                body.emit(assign(r07C7, r0760, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f07C8->else_instructions;

                                                ir_expression *const r07CA = nequal(r0760, body.constant(0u));
                                                ir_expression *const r07CB = expr(ir_unop_b2i, r07CA);
                                                body.emit(assign(r07C7, expr(ir_unop_i2u, r07CB), 0x01));


                                             body.instructions = f07C8_parent_instructions;
                                             body.emit(f07C8);

                                             /* END IF */

                                             body.emit(assign(r07B7, r07C7, 0x01));

                                             body.emit(assign(r07B8, body.constant(0u), 0x01));


                                          body.instructions = f07C4_parent_instructions;
                                          body.emit(f07C4);

                                          /* END IF */


                                       body.instructions = f07C2_parent_instructions;
                                       body.emit(f07C2);

                                       /* END IF */

                                       body.emit(assign(r07B9, body.constant(0u), 0x01));


                                    body.instructions = f07BE_parent_instructions;
                                    body.emit(f07BE);

                                    /* END IF */

                                    ir_expression *const r07CC = nequal(r07B5, body.constant(0u));
                                    ir_expression *const r07CD = expr(ir_unop_b2i, r07CC);
                                    ir_expression *const r07CE = expr(ir_unop_i2u, r07CD);
                                    body.emit(assign(r07B7, bit_or(r07B7, r07CE), 0x01));


                                 body.instructions = f07BC_parent_instructions;
                                 body.emit(f07BC);

                                 /* END IF */

                                 body.emit(assign(r079F, r07B9, 0x01));

                                 body.emit(assign(r07A0, r07B8, 0x01));

                                 body.emit(assign(r07A1, r07B7, 0x01));

                                 body.emit(assign(r079E, body.constant(int(0)), 0x01));

                                 body.emit(assign(r07A4, less(r07B7, body.constant(0u)), 0x01));


                              body.instructions = f07B3_parent_instructions;
                              body.emit(f07B3);

                              /* END IF */


                           body.instructions = f07B0_parent_instructions;
                           body.emit(f07B0);

                           /* END IF */


                        body.instructions = f07A6_parent_instructions;
                        body.emit(f07A6);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f07CF = new(mem_ctx) ir_if(operand(r07A2).val);
                        exec_list *const f07CF_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f07CF->then_instructions;

                           /* IF CONDITION */
                           ir_if *f07D0 = new(mem_ctx) ir_if(operand(r07A4).val);
                           exec_list *const f07D0_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f07D0->then_instructions;

                              ir_variable *const r07D1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r07D1, add(r07A0, body.constant(1u)), 0x01));

                              ir_expression *const r07D2 = less(r07D1, r07A0);
                              ir_expression *const r07D3 = expr(ir_unop_b2i, r07D2);
                              ir_expression *const r07D4 = expr(ir_unop_i2u, r07D3);
                              body.emit(assign(r079F, add(r079F, r07D4), 0x01));

                              ir_expression *const r07D5 = equal(r07A1, body.constant(0u));
                              ir_expression *const r07D6 = expr(ir_unop_b2i, r07D5);
                              ir_expression *const r07D7 = expr(ir_unop_i2u, r07D6);
                              ir_expression *const r07D8 = add(r07A1, r07D7);
                              ir_expression *const r07D9 = bit_and(r07D8, body.constant(1u));
                              ir_expression *const r07DA = expr(ir_unop_bit_not, r07D9);
                              body.emit(assign(r07A0, bit_and(r07D1, r07DA), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f07D0->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r07DC = bit_or(r079F, r07A0);
                              ir_expression *const r07DD = equal(r07DC, body.constant(0u));
                              ir_if *f07DB = new(mem_ctx) ir_if(operand(r07DD).val);
                              exec_list *const f07DB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f07DB->then_instructions;

                                 body.emit(assign(r079E, body.constant(int(0)), 0x01));


                              body.instructions = f07DB_parent_instructions;
                              body.emit(f07DB);

                              /* END IF */


                           body.instructions = f07D0_parent_instructions;
                           body.emit(f07D0);

                           /* END IF */

                           ir_variable *const r07DE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r07DE);
                           ir_expression *const r07DF = lshift(r03D0, body.constant(int(31)));
                           ir_expression *const r07E0 = expr(ir_unop_i2u, r079E);
                           ir_expression *const r07E1 = lshift(r07E0, body.constant(int(20)));
                           ir_expression *const r07E2 = add(r07DF, r07E1);
                           body.emit(assign(r07DE, add(r07E2, r079F), 0x02));

                           body.emit(assign(r07DE, r07A0, 0x01));

                           body.emit(assign(r07A3, r07DE, 0x03));

                           body.emit(assign(r07A2, body.constant(false), 0x01));


                        body.instructions = f07CF_parent_instructions;
                        body.emit(f07CF);

                        /* END IF */

                        body.emit(assign(r03D1, r07A3, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0757->else_instructions;

                        ir_variable *const r07E3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r07E3);
                        body.emit(assign(r07E3, body.constant(0u), 0x02));

                        body.emit(assign(r07E3, body.constant(0u), 0x01));

                        body.emit(assign(r03D1, r07E3, 0x03));


                     body.instructions = f0757_parent_instructions;
                     body.emit(f0757);

                     /* END IF */


                  body.instructions = f06CB_parent_instructions;
                  body.emit(f06CB);

                  /* END IF */


               body.instructions = f063F_parent_instructions;
               body.emit(f063F);

               /* END IF */


            body.instructions = f05B3_parent_instructions;
            body.emit(f05B3);

            /* END IF */


         body.instructions = f058C_parent_instructions;
         body.emit(f058C);

         /* END IF */


      body.instructions = f04B8_parent_instructions;
      body.emit(f04B8);

      /* END IF */


   body.instructions = f03E8_parent_instructions;
   body.emit(f03E8);

   /* END IF */

   body.emit(ret(r03D1));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fadd64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r07E4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r07E4);
   ir_variable *const r07E5 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r07E5);
   ir_variable *const r07E6 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r07E7 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r07E7, rshift(swizzle_y(r07E4), body.constant(int(31))), 0x01));

   ir_variable *const r07E8 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r07E8, rshift(swizzle_y(r07E5), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r07EA = equal(r07E7, r07E8);
   ir_if *f07E9 = new(mem_ctx) ir_if(operand(r07EA).val);
   exec_list *const f07E9_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f07E9->then_instructions;

      ir_variable *const r07EB = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r07EB, body.constant(true), 0x01));

      ir_variable *const r07EC = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r07ED = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r07ED);
      ir_variable *const r07EE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
      body.emit(r07EE);
      ir_variable *const r07EF = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
      body.emit(r07EF);
      ir_variable *const r07F0 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r07F0);
      ir_variable *const r07F1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
      body.emit(r07F1);
      ir_variable *const r07F2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
      body.emit(r07F2);
      body.emit(assign(r07F2, body.constant(0u), 0x01));

      body.emit(assign(r07F1, body.constant(0u), 0x01));

      ir_variable *const r07F3 = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
      body.emit(assign(r07F3, bit_and(swizzle_y(r07E4), body.constant(1048575u)), 0x01));

      body.emit(assign(r07F3, swizzle_x(r07E4), 0x02));

      body.emit(assign(r07EF, r07F3, 0x03));

      ir_variable *const r07F4 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r07F5 = rshift(swizzle_y(r07E4), body.constant(int(20)));
      ir_expression *const r07F6 = bit_and(r07F5, body.constant(2047u));
      body.emit(assign(r07F4, expr(ir_unop_u2i, r07F6), 0x01));

      ir_variable *const r07F7 = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
      body.emit(assign(r07F7, bit_and(swizzle_y(r07E5), body.constant(1048575u)), 0x01));

      body.emit(assign(r07F7, swizzle_x(r07E5), 0x02));

      body.emit(assign(r07EE, r07F7, 0x03));

      ir_variable *const r07F8 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r07F9 = rshift(swizzle_y(r07E5), body.constant(int(20)));
      ir_expression *const r07FA = bit_and(r07F9, body.constant(2047u));
      body.emit(assign(r07F8, expr(ir_unop_u2i, r07FA), 0x01));

      ir_variable *const r07FB = body.make_temp(glsl_type::int_type, "assignment_tmp");
      body.emit(assign(r07FB, sub(r07F4, r07F8), 0x01));

      body.emit(assign(r07ED, r07FB, 0x01));

      /* IF CONDITION */
      ir_expression *const r07FD = less(body.constant(int(0)), r07FB);
      ir_if *f07FC = new(mem_ctx) ir_if(operand(r07FD).val);
      exec_list *const f07FC_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f07FC->then_instructions;

         /* IF CONDITION */
         ir_expression *const r07FF = equal(r07F4, body.constant(int(2047)));
         ir_if *f07FE = new(mem_ctx) ir_if(operand(r07FF).val);
         exec_list *const f07FE_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f07FE->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0801 = bit_or(swizzle_x(r07E4), swizzle_x(r07F3));
            ir_expression *const r0802 = nequal(r0801, body.constant(0u));
            ir_if *f0800 = new(mem_ctx) ir_if(operand(r0802).val);
            exec_list *const f0800_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0800->then_instructions;

               ir_variable *const r0803 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r0803, swizzle_y(r07E4), 0x02));

               ir_variable *const r0804 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r0804, swizzle_y(r07E5), 0x02));

               ir_variable *const r0805 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0806 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r0807 = rshift(swizzle_x(r07E4), body.constant(int(19)));
               ir_expression *const r0808 = bit_and(r0807, body.constant(4095u));
               ir_expression *const r0809 = equal(r0808, body.constant(4094u));
               ir_expression *const r080A = nequal(swizzle_y(r07E4), body.constant(0u));
               ir_expression *const r080B = bit_and(swizzle_x(r07E4), body.constant(524287u));
               ir_expression *const r080C = nequal(r080B, body.constant(0u));
               ir_expression *const r080D = logic_or(r080A, r080C);
               body.emit(assign(r0806, logic_and(r0809, r080D), 0x01));

               ir_variable *const r080E = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r080F = lshift(swizzle_x(r07E5), body.constant(int(1)));
               ir_expression *const r0810 = lequal(body.constant(4292870144u), r080F);
               ir_expression *const r0811 = nequal(swizzle_y(r07E5), body.constant(0u));
               ir_expression *const r0812 = bit_and(swizzle_x(r07E5), body.constant(1048575u));
               ir_expression *const r0813 = nequal(r0812, body.constant(0u));
               ir_expression *const r0814 = logic_or(r0811, r0813);
               body.emit(assign(r080E, logic_and(r0810, r0814), 0x01));

               body.emit(assign(r0803, bit_or(swizzle_x(r07E4), body.constant(524288u)), 0x01));

               body.emit(assign(r0804, bit_or(swizzle_x(r07E5), body.constant(524288u)), 0x01));

               /* IF CONDITION */
               ir_expression *const r0816 = lshift(swizzle_x(r07E4), body.constant(int(1)));
               ir_expression *const r0817 = lequal(body.constant(4292870144u), r0816);
               ir_expression *const r0818 = nequal(swizzle_y(r07E4), body.constant(0u));
               ir_expression *const r0819 = bit_and(swizzle_x(r07E4), body.constant(1048575u));
               ir_expression *const r081A = nequal(r0819, body.constant(0u));
               ir_expression *const r081B = logic_or(r0818, r081A);
               ir_expression *const r081C = logic_and(r0817, r081B);
               ir_if *f0815 = new(mem_ctx) ir_if(operand(r081C).val);
               exec_list *const f0815_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0815->then_instructions;

                  ir_variable *const r081D = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r081F = logic_and(r0806, r080E);
                  ir_if *f081E = new(mem_ctx) ir_if(operand(r081F).val);
                  exec_list *const f081E_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f081E->then_instructions;

                     body.emit(assign(r081D, r0804, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f081E->else_instructions;

                     body.emit(assign(r081D, r0803, 0x03));


                  body.instructions = f081E_parent_instructions;
                  body.emit(f081E);

                  /* END IF */

                  body.emit(assign(r0805, r081D, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0815->else_instructions;

                  body.emit(assign(r0805, r0804, 0x03));


               body.instructions = f0815_parent_instructions;
               body.emit(f0815);

               /* END IF */

               body.emit(assign(r07EC, r0805, 0x03));

               body.emit(assign(r07EB, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0800->else_instructions;

               body.emit(assign(r07EC, r07E4, 0x03));

               body.emit(assign(r07EB, body.constant(false), 0x01));


            body.instructions = f0800_parent_instructions;
            body.emit(f0800);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f07FE->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0821 = equal(r07F8, body.constant(int(0)));
            ir_if *f0820 = new(mem_ctx) ir_if(operand(r0821).val);
            exec_list *const f0820_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0820->then_instructions;

               body.emit(assign(r07ED, add(r07FB, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0820->else_instructions;

               body.emit(assign(r07EE, bit_or(swizzle_x(r07E5), body.constant(1048576u)), 0x02));


            body.instructions = f0820_parent_instructions;
            body.emit(f0820);

            /* END IF */

            ir_variable *const r0822 = body.make_temp(glsl_type::uint_type, "a0");
            body.emit(assign(r0822, swizzle_y(r07EE), 0x01));

            ir_variable *const r0823 = body.make_temp(glsl_type::uint_type, "a1");
            body.emit(assign(r0823, swizzle_x(r07EE), 0x01));

            ir_variable *const r0824 = body.make_temp(glsl_type::uint_type, "a2");
            body.emit(assign(r0824, body.constant(0u), 0x01));

            ir_variable *const r0825 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r0825);
            ir_variable *const r0826 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r0826);
            ir_variable *const r0827 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r0827);
            ir_variable *const r0828 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r0829 = neg(r07ED);
            body.emit(assign(r0828, bit_and(r0829, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r082B = equal(r07ED, body.constant(int(0)));
            ir_if *f082A = new(mem_ctx) ir_if(operand(r082B).val);
            exec_list *const f082A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f082A->then_instructions;

               body.emit(assign(r0825, r0824, 0x01));

               body.emit(assign(r0826, r0823, 0x01));

               body.emit(assign(r0827, r0822, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f082A->else_instructions;

               /* IF CONDITION */
               ir_expression *const r082D = less(r07ED, body.constant(int(32)));
               ir_if *f082C = new(mem_ctx) ir_if(operand(r082D).val);
               exec_list *const f082C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f082C->then_instructions;

                  body.emit(assign(r0825, lshift(swizzle_x(r07F7), r0828), 0x01));

                  ir_expression *const r082E = lshift(swizzle_y(r07EE), r0828);
                  ir_expression *const r082F = rshift(swizzle_x(r07F7), r07ED);
                  body.emit(assign(r0826, bit_or(r082E, r082F), 0x01));

                  body.emit(assign(r0827, rshift(swizzle_y(r07EE), r07ED), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f082C->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0831 = equal(r07ED, body.constant(int(32)));
                  ir_if *f0830 = new(mem_ctx) ir_if(operand(r0831).val);
                  exec_list *const f0830_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0830->then_instructions;

                     body.emit(assign(r0825, r0823, 0x01));

                     body.emit(assign(r0826, r0822, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0830->else_instructions;

                     body.emit(assign(r0824, bit_or(body.constant(0u), swizzle_x(r07F7)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0833 = less(r07ED, body.constant(int(64)));
                     ir_if *f0832 = new(mem_ctx) ir_if(operand(r0833).val);
                     exec_list *const f0832_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0832->then_instructions;

                        body.emit(assign(r0825, lshift(swizzle_y(r07EE), r0828), 0x01));

                        ir_expression *const r0834 = bit_and(r07ED, body.constant(int(31)));
                        body.emit(assign(r0826, rshift(swizzle_y(r07EE), r0834), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0832->else_instructions;

                        ir_variable *const r0835 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0837 = equal(r07ED, body.constant(int(64)));
                        ir_if *f0836 = new(mem_ctx) ir_if(operand(r0837).val);
                        exec_list *const f0836_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0836->then_instructions;

                           body.emit(assign(r0835, r0822, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0836->else_instructions;

                           ir_expression *const r0838 = nequal(swizzle_y(r07EE), body.constant(0u));
                           ir_expression *const r0839 = expr(ir_unop_b2i, r0838);
                           body.emit(assign(r0835, expr(ir_unop_i2u, r0839), 0x01));


                        body.instructions = f0836_parent_instructions;
                        body.emit(f0836);

                        /* END IF */

                        body.emit(assign(r0825, r0835, 0x01));

                        body.emit(assign(r0826, body.constant(0u), 0x01));


                     body.instructions = f0832_parent_instructions;
                     body.emit(f0832);

                     /* END IF */


                  body.instructions = f0830_parent_instructions;
                  body.emit(f0830);

                  /* END IF */

                  body.emit(assign(r0827, body.constant(0u), 0x01));


               body.instructions = f082C_parent_instructions;
               body.emit(f082C);

               /* END IF */

               ir_expression *const r083A = nequal(r0824, body.constant(0u));
               ir_expression *const r083B = expr(ir_unop_b2i, r083A);
               ir_expression *const r083C = expr(ir_unop_i2u, r083B);
               body.emit(assign(r0825, bit_or(r0825, r083C), 0x01));


            body.instructions = f082A_parent_instructions;
            body.emit(f082A);

            /* END IF */

            body.emit(assign(r07EE, r0827, 0x02));

            body.emit(assign(r07EE, r0826, 0x01));

            body.emit(assign(r07F1, r0825, 0x01));

            body.emit(assign(r07F0, r07F4, 0x01));


         body.instructions = f07FE_parent_instructions;
         body.emit(f07FE);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f07FC->else_instructions;

         /* IF CONDITION */
         ir_expression *const r083E = less(r07ED, body.constant(int(0)));
         ir_if *f083D = new(mem_ctx) ir_if(operand(r083E).val);
         exec_list *const f083D_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f083D->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0840 = equal(r07F8, body.constant(int(2047)));
            ir_if *f083F = new(mem_ctx) ir_if(operand(r0840).val);
            exec_list *const f083F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f083F->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0842 = bit_or(swizzle_y(r07EE), swizzle_x(r07EE));
               ir_expression *const r0843 = nequal(r0842, body.constant(0u));
               ir_if *f0841 = new(mem_ctx) ir_if(operand(r0843).val);
               exec_list *const f0841_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0841->then_instructions;

                  ir_variable *const r0844 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r0844, swizzle_y(r07E4), 0x02));

                  ir_variable *const r0845 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r0845, swizzle_y(r07E5), 0x02));

                  ir_variable *const r0846 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0847 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0848 = rshift(swizzle_x(r07E4), body.constant(int(19)));
                  ir_expression *const r0849 = bit_and(r0848, body.constant(4095u));
                  ir_expression *const r084A = equal(r0849, body.constant(4094u));
                  ir_expression *const r084B = nequal(swizzle_y(r07E4), body.constant(0u));
                  ir_expression *const r084C = bit_and(swizzle_x(r07E4), body.constant(524287u));
                  ir_expression *const r084D = nequal(r084C, body.constant(0u));
                  ir_expression *const r084E = logic_or(r084B, r084D);
                  body.emit(assign(r0847, logic_and(r084A, r084E), 0x01));

                  ir_variable *const r084F = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0850 = lshift(swizzle_x(r07E5), body.constant(int(1)));
                  ir_expression *const r0851 = lequal(body.constant(4292870144u), r0850);
                  ir_expression *const r0852 = nequal(swizzle_y(r07E5), body.constant(0u));
                  ir_expression *const r0853 = bit_and(swizzle_x(r07E5), body.constant(1048575u));
                  ir_expression *const r0854 = nequal(r0853, body.constant(0u));
                  ir_expression *const r0855 = logic_or(r0852, r0854);
                  body.emit(assign(r084F, logic_and(r0851, r0855), 0x01));

                  body.emit(assign(r0844, bit_or(swizzle_x(r07E4), body.constant(524288u)), 0x01));

                  body.emit(assign(r0845, bit_or(swizzle_x(r07E5), body.constant(524288u)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0857 = lshift(swizzle_x(r07E4), body.constant(int(1)));
                  ir_expression *const r0858 = lequal(body.constant(4292870144u), r0857);
                  ir_expression *const r0859 = nequal(swizzle_y(r07E4), body.constant(0u));
                  ir_expression *const r085A = bit_and(swizzle_x(r07E4), body.constant(1048575u));
                  ir_expression *const r085B = nequal(r085A, body.constant(0u));
                  ir_expression *const r085C = logic_or(r0859, r085B);
                  ir_expression *const r085D = logic_and(r0858, r085C);
                  ir_if *f0856 = new(mem_ctx) ir_if(operand(r085D).val);
                  exec_list *const f0856_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0856->then_instructions;

                     ir_variable *const r085E = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0860 = logic_and(r0847, r084F);
                     ir_if *f085F = new(mem_ctx) ir_if(operand(r0860).val);
                     exec_list *const f085F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f085F->then_instructions;

                        body.emit(assign(r085E, r0845, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f085F->else_instructions;

                        body.emit(assign(r085E, r0844, 0x03));


                     body.instructions = f085F_parent_instructions;
                     body.emit(f085F);

                     /* END IF */

                     body.emit(assign(r0846, r085E, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0856->else_instructions;

                     body.emit(assign(r0846, r0845, 0x03));


                  body.instructions = f0856_parent_instructions;
                  body.emit(f0856);

                  /* END IF */

                  body.emit(assign(r07EC, r0846, 0x03));

                  body.emit(assign(r07EB, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0841->else_instructions;

                  ir_variable *const r0861 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0861);
                  ir_expression *const r0862 = lshift(r07E7, body.constant(int(31)));
                  body.emit(assign(r0861, add(r0862, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0861, body.constant(0u), 0x01));

                  body.emit(assign(r07EC, r0861, 0x03));

                  body.emit(assign(r07EB, body.constant(false), 0x01));


               body.instructions = f0841_parent_instructions;
               body.emit(f0841);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f083F->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0864 = equal(r07F4, body.constant(int(0)));
               ir_if *f0863 = new(mem_ctx) ir_if(operand(r0864).val);
               exec_list *const f0863_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0863->then_instructions;

                  body.emit(assign(r07ED, add(r07ED, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0863->else_instructions;

                  body.emit(assign(r07EF, bit_or(swizzle_x(r07E4), body.constant(1048576u)), 0x02));


               body.instructions = f0863_parent_instructions;
               body.emit(f0863);

               /* END IF */

               ir_variable *const r0865 = body.make_temp(glsl_type::uint_type, "a0");
               body.emit(assign(r0865, swizzle_y(r07EF), 0x01));

               ir_variable *const r0866 = body.make_temp(glsl_type::uint_type, "a1");
               body.emit(assign(r0866, swizzle_x(r07EF), 0x01));

               ir_variable *const r0867 = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r0867, body.constant(0u), 0x01));

               ir_variable *const r0868 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0868, neg(r07ED), 0x01));

               ir_variable *const r0869 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r0869);
               ir_variable *const r086A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r086A);
               ir_variable *const r086B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r086B);
               ir_variable *const r086C = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r086D = neg(r0868);
               body.emit(assign(r086C, bit_and(r086D, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r086F = equal(r0868, body.constant(int(0)));
               ir_if *f086E = new(mem_ctx) ir_if(operand(r086F).val);
               exec_list *const f086E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f086E->then_instructions;

                  body.emit(assign(r0869, r0867, 0x01));

                  body.emit(assign(r086A, r0866, 0x01));

                  body.emit(assign(r086B, r0865, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f086E->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0871 = less(r0868, body.constant(int(32)));
                  ir_if *f0870 = new(mem_ctx) ir_if(operand(r0871).val);
                  exec_list *const f0870_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0870->then_instructions;

                     body.emit(assign(r0869, lshift(swizzle_x(r07F3), r086C), 0x01));

                     ir_expression *const r0872 = lshift(swizzle_y(r07EF), r086C);
                     ir_expression *const r0873 = rshift(swizzle_x(r07F3), r0868);
                     body.emit(assign(r086A, bit_or(r0872, r0873), 0x01));

                     body.emit(assign(r086B, rshift(swizzle_y(r07EF), r0868), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0870->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0875 = equal(r0868, body.constant(int(32)));
                     ir_if *f0874 = new(mem_ctx) ir_if(operand(r0875).val);
                     exec_list *const f0874_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0874->then_instructions;

                        body.emit(assign(r0869, r0866, 0x01));

                        body.emit(assign(r086A, r0865, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0874->else_instructions;

                        body.emit(assign(r0867, bit_or(body.constant(0u), swizzle_x(r07F3)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0877 = less(r0868, body.constant(int(64)));
                        ir_if *f0876 = new(mem_ctx) ir_if(operand(r0877).val);
                        exec_list *const f0876_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0876->then_instructions;

                           body.emit(assign(r0869, lshift(swizzle_y(r07EF), r086C), 0x01));

                           ir_expression *const r0878 = bit_and(r0868, body.constant(int(31)));
                           body.emit(assign(r086A, rshift(swizzle_y(r07EF), r0878), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0876->else_instructions;

                           ir_variable *const r0879 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r087B = equal(r0868, body.constant(int(64)));
                           ir_if *f087A = new(mem_ctx) ir_if(operand(r087B).val);
                           exec_list *const f087A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f087A->then_instructions;

                              body.emit(assign(r0879, r0865, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f087A->else_instructions;

                              ir_expression *const r087C = nequal(swizzle_y(r07EF), body.constant(0u));
                              ir_expression *const r087D = expr(ir_unop_b2i, r087C);
                              body.emit(assign(r0879, expr(ir_unop_i2u, r087D), 0x01));


                           body.instructions = f087A_parent_instructions;
                           body.emit(f087A);

                           /* END IF */

                           body.emit(assign(r0869, r0879, 0x01));

                           body.emit(assign(r086A, body.constant(0u), 0x01));


                        body.instructions = f0876_parent_instructions;
                        body.emit(f0876);

                        /* END IF */


                     body.instructions = f0874_parent_instructions;
                     body.emit(f0874);

                     /* END IF */

                     body.emit(assign(r086B, body.constant(0u), 0x01));


                  body.instructions = f0870_parent_instructions;
                  body.emit(f0870);

                  /* END IF */

                  ir_expression *const r087E = nequal(r0867, body.constant(0u));
                  ir_expression *const r087F = expr(ir_unop_b2i, r087E);
                  ir_expression *const r0880 = expr(ir_unop_i2u, r087F);
                  body.emit(assign(r0869, bit_or(r0869, r0880), 0x01));


               body.instructions = f086E_parent_instructions;
               body.emit(f086E);

               /* END IF */

               body.emit(assign(r07EF, r086B, 0x02));

               body.emit(assign(r07EF, r086A, 0x01));

               body.emit(assign(r07F1, r0869, 0x01));

               body.emit(assign(r07F0, r07F8, 0x01));


            body.instructions = f083F_parent_instructions;
            body.emit(f083F);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f083D->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0882 = equal(r07F4, body.constant(int(2047)));
            ir_if *f0881 = new(mem_ctx) ir_if(operand(r0882).val);
            exec_list *const f0881_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0881->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0884 = bit_or(swizzle_y(r07EF), swizzle_x(r07EF));
               ir_expression *const r0885 = bit_or(swizzle_y(r07EE), swizzle_x(r07EE));
               ir_expression *const r0886 = bit_or(r0884, r0885);
               ir_expression *const r0887 = nequal(r0886, body.constant(0u));
               ir_if *f0883 = new(mem_ctx) ir_if(operand(r0887).val);
               exec_list *const f0883_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0883->then_instructions;

                  ir_variable *const r0888 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r0888, swizzle_y(r07E4), 0x02));

                  ir_variable *const r0889 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r0889, swizzle_y(r07E5), 0x02));

                  ir_variable *const r088A = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r088B = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r088C = rshift(swizzle_x(r07E4), body.constant(int(19)));
                  ir_expression *const r088D = bit_and(r088C, body.constant(4095u));
                  ir_expression *const r088E = equal(r088D, body.constant(4094u));
                  ir_expression *const r088F = nequal(swizzle_y(r07E4), body.constant(0u));
                  ir_expression *const r0890 = bit_and(swizzle_x(r07E4), body.constant(524287u));
                  ir_expression *const r0891 = nequal(r0890, body.constant(0u));
                  ir_expression *const r0892 = logic_or(r088F, r0891);
                  body.emit(assign(r088B, logic_and(r088E, r0892), 0x01));

                  ir_variable *const r0893 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0894 = lshift(swizzle_x(r07E5), body.constant(int(1)));
                  ir_expression *const r0895 = lequal(body.constant(4292870144u), r0894);
                  ir_expression *const r0896 = nequal(swizzle_y(r07E5), body.constant(0u));
                  ir_expression *const r0897 = bit_and(swizzle_x(r07E5), body.constant(1048575u));
                  ir_expression *const r0898 = nequal(r0897, body.constant(0u));
                  ir_expression *const r0899 = logic_or(r0896, r0898);
                  body.emit(assign(r0893, logic_and(r0895, r0899), 0x01));

                  body.emit(assign(r0888, bit_or(swizzle_x(r07E4), body.constant(524288u)), 0x01));

                  body.emit(assign(r0889, bit_or(swizzle_x(r07E5), body.constant(524288u)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r089B = lshift(swizzle_x(r07E4), body.constant(int(1)));
                  ir_expression *const r089C = lequal(body.constant(4292870144u), r089B);
                  ir_expression *const r089D = nequal(swizzle_y(r07E4), body.constant(0u));
                  ir_expression *const r089E = bit_and(swizzle_x(r07E4), body.constant(1048575u));
                  ir_expression *const r089F = nequal(r089E, body.constant(0u));
                  ir_expression *const r08A0 = logic_or(r089D, r089F);
                  ir_expression *const r08A1 = logic_and(r089C, r08A0);
                  ir_if *f089A = new(mem_ctx) ir_if(operand(r08A1).val);
                  exec_list *const f089A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f089A->then_instructions;

                     ir_variable *const r08A2 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r08A4 = logic_and(r088B, r0893);
                     ir_if *f08A3 = new(mem_ctx) ir_if(operand(r08A4).val);
                     exec_list *const f08A3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f08A3->then_instructions;

                        body.emit(assign(r08A2, r0889, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f08A3->else_instructions;

                        body.emit(assign(r08A2, r0888, 0x03));


                     body.instructions = f08A3_parent_instructions;
                     body.emit(f08A3);

                     /* END IF */

                     body.emit(assign(r088A, r08A2, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f089A->else_instructions;

                     body.emit(assign(r088A, r0889, 0x03));


                  body.instructions = f089A_parent_instructions;
                  body.emit(f089A);

                  /* END IF */

                  body.emit(assign(r07EC, r088A, 0x03));

                  body.emit(assign(r07EB, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0883->else_instructions;

                  body.emit(assign(r07EC, r07E4, 0x03));

                  body.emit(assign(r07EB, body.constant(false), 0x01));


               body.instructions = f0883_parent_instructions;
               body.emit(f0883);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0881->else_instructions;

               ir_variable *const r08A5 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r08A6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r08A6, add(swizzle_x(r07EF), swizzle_x(r07EE)), 0x01));

               ir_expression *const r08A7 = add(swizzle_y(r07EF), swizzle_y(r07EE));
               ir_expression *const r08A8 = less(r08A6, swizzle_x(r07EF));
               ir_expression *const r08A9 = expr(ir_unop_b2i, r08A8);
               ir_expression *const r08AA = expr(ir_unop_i2u, r08A9);
               body.emit(assign(r08A5, add(r08A7, r08AA), 0x01));

               body.emit(assign(r07F2, r08A5, 0x01));

               /* IF CONDITION */
               ir_expression *const r08AC = equal(r07F4, body.constant(int(0)));
               ir_if *f08AB = new(mem_ctx) ir_if(operand(r08AC).val);
               exec_list *const f08AB_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f08AB->then_instructions;

                  ir_variable *const r08AD = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r08AD);
                  ir_expression *const r08AE = lshift(r07E7, body.constant(int(31)));
                  body.emit(assign(r08AD, add(r08AE, r08A5), 0x02));

                  body.emit(assign(r08AD, r08A6, 0x01));

                  body.emit(assign(r07EC, r08AD, 0x03));

                  body.emit(assign(r07EB, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f08AB->else_instructions;

                  body.emit(assign(r07F2, bit_or(r08A5, body.constant(2097152u)), 0x01));

                  body.emit(assign(r07F0, r07F4, 0x01));

                  ir_variable *const r08AF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r08AF);
                  ir_variable *const r08B0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r08B0);
                  ir_variable *const r08B1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r08B1);
                  body.emit(assign(r08AF, lshift(r08A6, body.constant(int(31))), 0x01));

                  ir_expression *const r08B2 = lshift(r07F2, body.constant(int(31)));
                  ir_expression *const r08B3 = rshift(r08A6, body.constant(int(1)));
                  body.emit(assign(r08B0, bit_or(r08B2, r08B3), 0x01));

                  body.emit(assign(r08B1, rshift(r07F2, body.constant(int(1))), 0x01));

                  body.emit(assign(r08AF, bit_or(r08AF, body.constant(0u)), 0x01));

                  body.emit(assign(r07F2, r08B1, 0x01));

                  body.emit(assign(r07F1, r08AF, 0x01));

                  ir_variable *const r08B4 = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r08B4, r07F4, 0x01));

                  ir_variable *const r08B5 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r08B5, r08B1, 0x01));

                  ir_variable *const r08B6 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r08B6, r08B0, 0x01));

                  ir_variable *const r08B7 = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r08B7, r08AF, 0x01));

                  ir_variable *const r08B8 = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r08B8, body.constant(true), 0x01));

                  ir_variable *const r08B9 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r08BA = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r08BA);
                  ir_expression *const r08BB = expr(ir_unop_u2i, r08AF);
                  body.emit(assign(r08BA, less(r08BB, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r08BD = lequal(body.constant(int(2045)), r07F4);
                  ir_if *f08BC = new(mem_ctx) ir_if(operand(r08BD).val);
                  exec_list *const f08BC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f08BC->then_instructions;

                     ir_variable *const r08BE = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r08C0 = less(body.constant(int(2045)), r07F4);
                     ir_if *f08BF = new(mem_ctx) ir_if(operand(r08C0).val);
                     exec_list *const f08BF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f08BF->then_instructions;

                        body.emit(assign(r08BE, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f08BF->else_instructions;

                        ir_variable *const r08C1 = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r08C3 = equal(r07F4, body.constant(int(2045)));
                        ir_if *f08C2 = new(mem_ctx) ir_if(operand(r08C3).val);
                        exec_list *const f08C2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f08C2->then_instructions;

                           ir_expression *const r08C4 = equal(body.constant(2097151u), r08B1);
                           ir_expression *const r08C5 = equal(body.constant(4294967295u), r08B0);
                           body.emit(assign(r08C1, logic_and(r08C4, r08C5), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f08C2->else_instructions;

                           body.emit(assign(r08C1, body.constant(false), 0x01));


                        body.instructions = f08C2_parent_instructions;
                        body.emit(f08C2);

                        /* END IF */

                        body.emit(assign(r08BE, logic_and(r08C1, r08BA), 0x01));


                     body.instructions = f08BF_parent_instructions;
                     body.emit(f08BF);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f08C6 = new(mem_ctx) ir_if(operand(r08BE).val);
                     exec_list *const f08C6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f08C6->then_instructions;

                        ir_variable *const r08C7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r08C7);
                        ir_expression *const r08C8 = lshift(r07E7, body.constant(int(31)));
                        body.emit(assign(r08C7, add(r08C8, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r08C7, body.constant(0u), 0x01));

                        body.emit(assign(r08B9, r08C7, 0x03));

                        body.emit(assign(r08B8, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f08C6->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r08CA = less(r07F4, body.constant(int(0)));
                        ir_if *f08C9 = new(mem_ctx) ir_if(operand(r08CA).val);
                        exec_list *const f08C9_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f08C9->then_instructions;

                           ir_variable *const r08CB = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r08CB, r08AF, 0x01));

                           ir_variable *const r08CC = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r08CC, neg(r07F4), 0x01));

                           ir_variable *const r08CD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r08CD);
                           ir_variable *const r08CE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r08CE);
                           ir_variable *const r08CF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r08CF);
                           ir_variable *const r08D0 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r08D1 = neg(r08CC);
                           body.emit(assign(r08D0, bit_and(r08D1, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r08D3 = equal(r08CC, body.constant(int(0)));
                           ir_if *f08D2 = new(mem_ctx) ir_if(operand(r08D3).val);
                           exec_list *const f08D2_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f08D2->then_instructions;

                              body.emit(assign(r08CD, r08AF, 0x01));

                              body.emit(assign(r08CE, r08B0, 0x01));

                              body.emit(assign(r08CF, r08B1, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f08D2->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r08D5 = less(r08CC, body.constant(int(32)));
                              ir_if *f08D4 = new(mem_ctx) ir_if(operand(r08D5).val);
                              exec_list *const f08D4_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f08D4->then_instructions;

                                 body.emit(assign(r08CD, lshift(r08B0, r08D0), 0x01));

                                 ir_expression *const r08D6 = lshift(r08B1, r08D0);
                                 ir_expression *const r08D7 = rshift(r08B0, r08CC);
                                 body.emit(assign(r08CE, bit_or(r08D6, r08D7), 0x01));

                                 body.emit(assign(r08CF, rshift(r08B1, r08CC), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f08D4->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r08D9 = equal(r08CC, body.constant(int(32)));
                                 ir_if *f08D8 = new(mem_ctx) ir_if(operand(r08D9).val);
                                 exec_list *const f08D8_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f08D8->then_instructions;

                                    body.emit(assign(r08CD, r08B0, 0x01));

                                    body.emit(assign(r08CE, r08B1, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f08D8->else_instructions;

                                    body.emit(assign(r08CB, bit_or(r08AF, r08B0), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r08DB = less(r08CC, body.constant(int(64)));
                                    ir_if *f08DA = new(mem_ctx) ir_if(operand(r08DB).val);
                                    exec_list *const f08DA_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f08DA->then_instructions;

                                       body.emit(assign(r08CD, lshift(r08B1, r08D0), 0x01));

                                       ir_expression *const r08DC = bit_and(r08CC, body.constant(int(31)));
                                       body.emit(assign(r08CE, rshift(r08B1, r08DC), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f08DA->else_instructions;

                                       ir_variable *const r08DD = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r08DF = equal(r08CC, body.constant(int(64)));
                                       ir_if *f08DE = new(mem_ctx) ir_if(operand(r08DF).val);
                                       exec_list *const f08DE_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f08DE->then_instructions;

                                          body.emit(assign(r08DD, r08B1, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f08DE->else_instructions;

                                          ir_expression *const r08E0 = nequal(r08B1, body.constant(0u));
                                          ir_expression *const r08E1 = expr(ir_unop_b2i, r08E0);
                                          body.emit(assign(r08DD, expr(ir_unop_i2u, r08E1), 0x01));


                                       body.instructions = f08DE_parent_instructions;
                                       body.emit(f08DE);

                                       /* END IF */

                                       body.emit(assign(r08CD, r08DD, 0x01));

                                       body.emit(assign(r08CE, body.constant(0u), 0x01));


                                    body.instructions = f08DA_parent_instructions;
                                    body.emit(f08DA);

                                    /* END IF */


                                 body.instructions = f08D8_parent_instructions;
                                 body.emit(f08D8);

                                 /* END IF */

                                 body.emit(assign(r08CF, body.constant(0u), 0x01));


                              body.instructions = f08D4_parent_instructions;
                              body.emit(f08D4);

                              /* END IF */

                              ir_expression *const r08E2 = nequal(r08CB, body.constant(0u));
                              ir_expression *const r08E3 = expr(ir_unop_b2i, r08E2);
                              ir_expression *const r08E4 = expr(ir_unop_i2u, r08E3);
                              body.emit(assign(r08CD, bit_or(r08CD, r08E4), 0x01));


                           body.instructions = f08D2_parent_instructions;
                           body.emit(f08D2);

                           /* END IF */

                           body.emit(assign(r08B5, r08CF, 0x01));

                           body.emit(assign(r08B6, r08CE, 0x01));

                           body.emit(assign(r08B7, r08CD, 0x01));

                           body.emit(assign(r08B4, body.constant(int(0)), 0x01));

                           body.emit(assign(r08BA, less(r08CD, body.constant(0u)), 0x01));


                        body.instructions = f08C9_parent_instructions;
                        body.emit(f08C9);

                        /* END IF */


                     body.instructions = f08C6_parent_instructions;
                     body.emit(f08C6);

                     /* END IF */


                  body.instructions = f08BC_parent_instructions;
                  body.emit(f08BC);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f08E5 = new(mem_ctx) ir_if(operand(r08B8).val);
                  exec_list *const f08E5_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f08E5->then_instructions;

                     /* IF CONDITION */
                     ir_if *f08E6 = new(mem_ctx) ir_if(operand(r08BA).val);
                     exec_list *const f08E6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f08E6->then_instructions;

                        ir_variable *const r08E7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r08E7, add(r08B6, body.constant(1u)), 0x01));

                        ir_expression *const r08E8 = less(r08E7, r08B6);
                        ir_expression *const r08E9 = expr(ir_unop_b2i, r08E8);
                        ir_expression *const r08EA = expr(ir_unop_i2u, r08E9);
                        body.emit(assign(r08B5, add(r08B5, r08EA), 0x01));

                        ir_expression *const r08EB = equal(r08B7, body.constant(0u));
                        ir_expression *const r08EC = expr(ir_unop_b2i, r08EB);
                        ir_expression *const r08ED = expr(ir_unop_i2u, r08EC);
                        ir_expression *const r08EE = add(r08B7, r08ED);
                        ir_expression *const r08EF = bit_and(r08EE, body.constant(1u));
                        ir_expression *const r08F0 = expr(ir_unop_bit_not, r08EF);
                        body.emit(assign(r08B6, bit_and(r08E7, r08F0), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f08E6->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r08F2 = bit_or(r08B5, r08B6);
                        ir_expression *const r08F3 = equal(r08F2, body.constant(0u));
                        ir_if *f08F1 = new(mem_ctx) ir_if(operand(r08F3).val);
                        exec_list *const f08F1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f08F1->then_instructions;

                           body.emit(assign(r08B4, body.constant(int(0)), 0x01));


                        body.instructions = f08F1_parent_instructions;
                        body.emit(f08F1);

                        /* END IF */


                     body.instructions = f08E6_parent_instructions;
                     body.emit(f08E6);

                     /* END IF */

                     ir_variable *const r08F4 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r08F4);
                     ir_expression *const r08F5 = lshift(r07E7, body.constant(int(31)));
                     ir_expression *const r08F6 = expr(ir_unop_i2u, r08B4);
                     ir_expression *const r08F7 = lshift(r08F6, body.constant(int(20)));
                     ir_expression *const r08F8 = add(r08F5, r08F7);
                     body.emit(assign(r08F4, add(r08F8, r08B5), 0x02));

                     body.emit(assign(r08F4, r08B6, 0x01));

                     body.emit(assign(r08B9, r08F4, 0x03));

                     body.emit(assign(r08B8, body.constant(false), 0x01));


                  body.instructions = f08E5_parent_instructions;
                  body.emit(f08E5);

                  /* END IF */

                  body.emit(assign(r07EC, r08B9, 0x03));

                  body.emit(assign(r07EB, body.constant(false), 0x01));


               body.instructions = f08AB_parent_instructions;
               body.emit(f08AB);

               /* END IF */


            body.instructions = f0881_parent_instructions;
            body.emit(f0881);

            /* END IF */


         body.instructions = f083D_parent_instructions;
         body.emit(f083D);

         /* END IF */


      body.instructions = f07FC_parent_instructions;
      body.emit(f07FC);

      /* END IF */

      /* IF CONDITION */
      ir_if *f08F9 = new(mem_ctx) ir_if(operand(r07EB).val);
      exec_list *const f08F9_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f08F9->then_instructions;

         body.emit(assign(r07EF, bit_or(swizzle_y(r07EF), body.constant(1048576u)), 0x02));

         ir_variable *const r08FA = body.make_temp(glsl_type::uint_type, "z0Ptr");
         ir_variable *const r08FB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         body.emit(assign(r08FB, add(swizzle_x(r07EF), swizzle_x(r07EE)), 0x01));

         ir_expression *const r08FC = add(swizzle_y(r07EF), swizzle_y(r07EE));
         ir_expression *const r08FD = less(r08FB, swizzle_x(r07EF));
         ir_expression *const r08FE = expr(ir_unop_b2i, r08FD);
         ir_expression *const r08FF = expr(ir_unop_i2u, r08FE);
         body.emit(assign(r08FA, add(r08FC, r08FF), 0x01));

         body.emit(assign(r07F2, r08FA, 0x01));

         body.emit(assign(r07F0, add(r07F0, body.constant(int(-1))), 0x01));

         /* IF CONDITION */
         ir_expression *const r0901 = less(r08FA, body.constant(2097152u));
         ir_if *f0900 = new(mem_ctx) ir_if(operand(r0901).val);
         exec_list *const f0900_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0900->then_instructions;

            ir_variable *const r0902 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0902, r07F0, 0x01));

            ir_variable *const r0903 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0903, r08FA, 0x01));

            ir_variable *const r0904 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0904, r08FB, 0x01));

            ir_variable *const r0905 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r0905, r07F1, 0x01));

            ir_variable *const r0906 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r0906, body.constant(true), 0x01));

            ir_variable *const r0907 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0908 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r0908);
            ir_expression *const r0909 = expr(ir_unop_u2i, r07F1);
            body.emit(assign(r0908, less(r0909, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r090B = lequal(body.constant(int(2045)), r07F0);
            ir_if *f090A = new(mem_ctx) ir_if(operand(r090B).val);
            exec_list *const f090A_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f090A->then_instructions;

               ir_variable *const r090C = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r090E = less(body.constant(int(2045)), r07F0);
               ir_if *f090D = new(mem_ctx) ir_if(operand(r090E).val);
               exec_list *const f090D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f090D->then_instructions;

                  body.emit(assign(r090C, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f090D->else_instructions;

                  ir_variable *const r090F = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0911 = equal(r07F0, body.constant(int(2045)));
                  ir_if *f0910 = new(mem_ctx) ir_if(operand(r0911).val);
                  exec_list *const f0910_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0910->then_instructions;

                     ir_expression *const r0912 = equal(body.constant(2097151u), r08FA);
                     ir_expression *const r0913 = equal(body.constant(4294967295u), r08FB);
                     body.emit(assign(r090F, logic_and(r0912, r0913), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0910->else_instructions;

                     body.emit(assign(r090F, body.constant(false), 0x01));


                  body.instructions = f0910_parent_instructions;
                  body.emit(f0910);

                  /* END IF */

                  body.emit(assign(r090C, logic_and(r090F, r0908), 0x01));


               body.instructions = f090D_parent_instructions;
               body.emit(f090D);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0914 = new(mem_ctx) ir_if(operand(r090C).val);
               exec_list *const f0914_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0914->then_instructions;

                  ir_variable *const r0915 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0915);
                  ir_expression *const r0916 = lshift(r07E7, body.constant(int(31)));
                  body.emit(assign(r0915, add(r0916, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0915, body.constant(0u), 0x01));

                  body.emit(assign(r0907, r0915, 0x03));

                  body.emit(assign(r0906, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0914->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0918 = less(r07F0, body.constant(int(0)));
                  ir_if *f0917 = new(mem_ctx) ir_if(operand(r0918).val);
                  exec_list *const f0917_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0917->then_instructions;

                     ir_variable *const r0919 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0919, r07F1, 0x01));

                     ir_variable *const r091A = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r091A, neg(r07F0), 0x01));

                     ir_variable *const r091B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r091B);
                     ir_variable *const r091C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r091C);
                     ir_variable *const r091D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r091D);
                     ir_variable *const r091E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r091F = neg(r091A);
                     body.emit(assign(r091E, bit_and(r091F, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0921 = equal(r091A, body.constant(int(0)));
                     ir_if *f0920 = new(mem_ctx) ir_if(operand(r0921).val);
                     exec_list *const f0920_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0920->then_instructions;

                        body.emit(assign(r091B, r07F1, 0x01));

                        body.emit(assign(r091C, r08FB, 0x01));

                        body.emit(assign(r091D, r08FA, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0920->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0923 = less(r091A, body.constant(int(32)));
                        ir_if *f0922 = new(mem_ctx) ir_if(operand(r0923).val);
                        exec_list *const f0922_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0922->then_instructions;

                           body.emit(assign(r091B, lshift(r08FB, r091E), 0x01));

                           ir_expression *const r0924 = lshift(r08FA, r091E);
                           ir_expression *const r0925 = rshift(r08FB, r091A);
                           body.emit(assign(r091C, bit_or(r0924, r0925), 0x01));

                           body.emit(assign(r091D, rshift(r08FA, r091A), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0922->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0927 = equal(r091A, body.constant(int(32)));
                           ir_if *f0926 = new(mem_ctx) ir_if(operand(r0927).val);
                           exec_list *const f0926_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0926->then_instructions;

                              body.emit(assign(r091B, r08FB, 0x01));

                              body.emit(assign(r091C, r08FA, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0926->else_instructions;

                              body.emit(assign(r0919, bit_or(r07F1, r08FB), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0929 = less(r091A, body.constant(int(64)));
                              ir_if *f0928 = new(mem_ctx) ir_if(operand(r0929).val);
                              exec_list *const f0928_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0928->then_instructions;

                                 body.emit(assign(r091B, lshift(r08FA, r091E), 0x01));

                                 ir_expression *const r092A = bit_and(r091A, body.constant(int(31)));
                                 body.emit(assign(r091C, rshift(r08FA, r092A), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0928->else_instructions;

                                 ir_variable *const r092B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r092D = equal(r091A, body.constant(int(64)));
                                 ir_if *f092C = new(mem_ctx) ir_if(operand(r092D).val);
                                 exec_list *const f092C_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f092C->then_instructions;

                                    body.emit(assign(r092B, r08FA, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f092C->else_instructions;

                                    ir_expression *const r092E = nequal(r08FA, body.constant(0u));
                                    ir_expression *const r092F = expr(ir_unop_b2i, r092E);
                                    body.emit(assign(r092B, expr(ir_unop_i2u, r092F), 0x01));


                                 body.instructions = f092C_parent_instructions;
                                 body.emit(f092C);

                                 /* END IF */

                                 body.emit(assign(r091B, r092B, 0x01));

                                 body.emit(assign(r091C, body.constant(0u), 0x01));


                              body.instructions = f0928_parent_instructions;
                              body.emit(f0928);

                              /* END IF */


                           body.instructions = f0926_parent_instructions;
                           body.emit(f0926);

                           /* END IF */

                           body.emit(assign(r091D, body.constant(0u), 0x01));


                        body.instructions = f0922_parent_instructions;
                        body.emit(f0922);

                        /* END IF */

                        ir_expression *const r0930 = nequal(r0919, body.constant(0u));
                        ir_expression *const r0931 = expr(ir_unop_b2i, r0930);
                        ir_expression *const r0932 = expr(ir_unop_i2u, r0931);
                        body.emit(assign(r091B, bit_or(r091B, r0932), 0x01));


                     body.instructions = f0920_parent_instructions;
                     body.emit(f0920);

                     /* END IF */

                     body.emit(assign(r0903, r091D, 0x01));

                     body.emit(assign(r0904, r091C, 0x01));

                     body.emit(assign(r0905, r091B, 0x01));

                     body.emit(assign(r0902, body.constant(int(0)), 0x01));

                     body.emit(assign(r0908, less(r091B, body.constant(0u)), 0x01));


                  body.instructions = f0917_parent_instructions;
                  body.emit(f0917);

                  /* END IF */


               body.instructions = f0914_parent_instructions;
               body.emit(f0914);

               /* END IF */


            body.instructions = f090A_parent_instructions;
            body.emit(f090A);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0933 = new(mem_ctx) ir_if(operand(r0906).val);
            exec_list *const f0933_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0933->then_instructions;

               /* IF CONDITION */
               ir_if *f0934 = new(mem_ctx) ir_if(operand(r0908).val);
               exec_list *const f0934_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0934->then_instructions;

                  ir_variable *const r0935 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r0935, add(r0904, body.constant(1u)), 0x01));

                  ir_expression *const r0936 = less(r0935, r0904);
                  ir_expression *const r0937 = expr(ir_unop_b2i, r0936);
                  ir_expression *const r0938 = expr(ir_unop_i2u, r0937);
                  body.emit(assign(r0903, add(r0903, r0938), 0x01));

                  ir_expression *const r0939 = equal(r0905, body.constant(0u));
                  ir_expression *const r093A = expr(ir_unop_b2i, r0939);
                  ir_expression *const r093B = expr(ir_unop_i2u, r093A);
                  ir_expression *const r093C = add(r0905, r093B);
                  ir_expression *const r093D = bit_and(r093C, body.constant(1u));
                  ir_expression *const r093E = expr(ir_unop_bit_not, r093D);
                  body.emit(assign(r0904, bit_and(r0935, r093E), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0934->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0940 = bit_or(r0903, r0904);
                  ir_expression *const r0941 = equal(r0940, body.constant(0u));
                  ir_if *f093F = new(mem_ctx) ir_if(operand(r0941).val);
                  exec_list *const f093F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f093F->then_instructions;

                     body.emit(assign(r0902, body.constant(int(0)), 0x01));


                  body.instructions = f093F_parent_instructions;
                  body.emit(f093F);

                  /* END IF */


               body.instructions = f0934_parent_instructions;
               body.emit(f0934);

               /* END IF */

               ir_variable *const r0942 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0942);
               ir_expression *const r0943 = lshift(r07E7, body.constant(int(31)));
               ir_expression *const r0944 = expr(ir_unop_i2u, r0902);
               ir_expression *const r0945 = lshift(r0944, body.constant(int(20)));
               ir_expression *const r0946 = add(r0943, r0945);
               body.emit(assign(r0942, add(r0946, r0903), 0x02));

               body.emit(assign(r0942, r0904, 0x01));

               body.emit(assign(r0907, r0942, 0x03));

               body.emit(assign(r0906, body.constant(false), 0x01));


            body.instructions = f0933_parent_instructions;
            body.emit(f0933);

            /* END IF */

            body.emit(assign(r07EC, r0907, 0x03));

            body.emit(assign(r07EB, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0900->else_instructions;

            body.emit(assign(r07F0, add(r07F0, body.constant(int(1))), 0x01));

            ir_variable *const r0947 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
            body.emit(r0947);
            ir_variable *const r0948 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r0948);
            ir_variable *const r0949 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r0949);
            body.emit(assign(r0947, lshift(r08FB, body.constant(int(31))), 0x01));

            ir_expression *const r094A = lshift(r08FA, body.constant(int(31)));
            ir_expression *const r094B = rshift(r08FB, body.constant(int(1)));
            body.emit(assign(r0948, bit_or(r094A, r094B), 0x01));

            body.emit(assign(r0949, rshift(r08FA, body.constant(int(1))), 0x01));

            ir_expression *const r094C = nequal(r07F1, body.constant(0u));
            ir_expression *const r094D = expr(ir_unop_b2i, r094C);
            ir_expression *const r094E = expr(ir_unop_i2u, r094D);
            body.emit(assign(r0947, bit_or(r0947, r094E), 0x01));

            body.emit(assign(r07F2, r0949, 0x01));

            body.emit(assign(r07F1, r0947, 0x01));

            ir_variable *const r094F = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r094F, r07F0, 0x01));

            ir_variable *const r0950 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0950, r0949, 0x01));

            ir_variable *const r0951 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0951, r0948, 0x01));

            ir_variable *const r0952 = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r0952, r0947, 0x01));

            ir_variable *const r0953 = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r0953, body.constant(true), 0x01));

            ir_variable *const r0954 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0955 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r0955);
            ir_expression *const r0956 = expr(ir_unop_u2i, r0947);
            body.emit(assign(r0955, less(r0956, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0958 = lequal(body.constant(int(2045)), r07F0);
            ir_if *f0957 = new(mem_ctx) ir_if(operand(r0958).val);
            exec_list *const f0957_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0957->then_instructions;

               ir_variable *const r0959 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r095B = less(body.constant(int(2045)), r07F0);
               ir_if *f095A = new(mem_ctx) ir_if(operand(r095B).val);
               exec_list *const f095A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f095A->then_instructions;

                  body.emit(assign(r0959, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f095A->else_instructions;

                  ir_variable *const r095C = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r095E = equal(r07F0, body.constant(int(2045)));
                  ir_if *f095D = new(mem_ctx) ir_if(operand(r095E).val);
                  exec_list *const f095D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f095D->then_instructions;

                     ir_expression *const r095F = equal(body.constant(2097151u), r0949);
                     ir_expression *const r0960 = equal(body.constant(4294967295u), r0948);
                     body.emit(assign(r095C, logic_and(r095F, r0960), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f095D->else_instructions;

                     body.emit(assign(r095C, body.constant(false), 0x01));


                  body.instructions = f095D_parent_instructions;
                  body.emit(f095D);

                  /* END IF */

                  body.emit(assign(r0959, logic_and(r095C, r0955), 0x01));


               body.instructions = f095A_parent_instructions;
               body.emit(f095A);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0961 = new(mem_ctx) ir_if(operand(r0959).val);
               exec_list *const f0961_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0961->then_instructions;

                  ir_variable *const r0962 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0962);
                  ir_expression *const r0963 = lshift(r07E7, body.constant(int(31)));
                  body.emit(assign(r0962, add(r0963, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0962, body.constant(0u), 0x01));

                  body.emit(assign(r0954, r0962, 0x03));

                  body.emit(assign(r0953, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0961->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0965 = less(r07F0, body.constant(int(0)));
                  ir_if *f0964 = new(mem_ctx) ir_if(operand(r0965).val);
                  exec_list *const f0964_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0964->then_instructions;

                     ir_variable *const r0966 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0966, r0947, 0x01));

                     ir_variable *const r0967 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0967, neg(r07F0), 0x01));

                     ir_variable *const r0968 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0968);
                     ir_variable *const r0969 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0969);
                     ir_variable *const r096A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r096A);
                     ir_variable *const r096B = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r096C = neg(r0967);
                     body.emit(assign(r096B, bit_and(r096C, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r096E = equal(r0967, body.constant(int(0)));
                     ir_if *f096D = new(mem_ctx) ir_if(operand(r096E).val);
                     exec_list *const f096D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f096D->then_instructions;

                        body.emit(assign(r0968, r0947, 0x01));

                        body.emit(assign(r0969, r0948, 0x01));

                        body.emit(assign(r096A, r0949, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f096D->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0970 = less(r0967, body.constant(int(32)));
                        ir_if *f096F = new(mem_ctx) ir_if(operand(r0970).val);
                        exec_list *const f096F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f096F->then_instructions;

                           body.emit(assign(r0968, lshift(r0948, r096B), 0x01));

                           ir_expression *const r0971 = lshift(r0949, r096B);
                           ir_expression *const r0972 = rshift(r0948, r0967);
                           body.emit(assign(r0969, bit_or(r0971, r0972), 0x01));

                           body.emit(assign(r096A, rshift(r0949, r0967), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f096F->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0974 = equal(r0967, body.constant(int(32)));
                           ir_if *f0973 = new(mem_ctx) ir_if(operand(r0974).val);
                           exec_list *const f0973_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0973->then_instructions;

                              body.emit(assign(r0968, r0948, 0x01));

                              body.emit(assign(r0969, r0949, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0973->else_instructions;

                              body.emit(assign(r0966, bit_or(r0947, r0948), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0976 = less(r0967, body.constant(int(64)));
                              ir_if *f0975 = new(mem_ctx) ir_if(operand(r0976).val);
                              exec_list *const f0975_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0975->then_instructions;

                                 body.emit(assign(r0968, lshift(r0949, r096B), 0x01));

                                 ir_expression *const r0977 = bit_and(r0967, body.constant(int(31)));
                                 body.emit(assign(r0969, rshift(r0949, r0977), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0975->else_instructions;

                                 ir_variable *const r0978 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r097A = equal(r0967, body.constant(int(64)));
                                 ir_if *f0979 = new(mem_ctx) ir_if(operand(r097A).val);
                                 exec_list *const f0979_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0979->then_instructions;

                                    body.emit(assign(r0978, r0949, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0979->else_instructions;

                                    ir_expression *const r097B = nequal(r0949, body.constant(0u));
                                    ir_expression *const r097C = expr(ir_unop_b2i, r097B);
                                    body.emit(assign(r0978, expr(ir_unop_i2u, r097C), 0x01));


                                 body.instructions = f0979_parent_instructions;
                                 body.emit(f0979);

                                 /* END IF */

                                 body.emit(assign(r0968, r0978, 0x01));

                                 body.emit(assign(r0969, body.constant(0u), 0x01));


                              body.instructions = f0975_parent_instructions;
                              body.emit(f0975);

                              /* END IF */


                           body.instructions = f0973_parent_instructions;
                           body.emit(f0973);

                           /* END IF */

                           body.emit(assign(r096A, body.constant(0u), 0x01));


                        body.instructions = f096F_parent_instructions;
                        body.emit(f096F);

                        /* END IF */

                        ir_expression *const r097D = nequal(r0966, body.constant(0u));
                        ir_expression *const r097E = expr(ir_unop_b2i, r097D);
                        ir_expression *const r097F = expr(ir_unop_i2u, r097E);
                        body.emit(assign(r0968, bit_or(r0968, r097F), 0x01));


                     body.instructions = f096D_parent_instructions;
                     body.emit(f096D);

                     /* END IF */

                     body.emit(assign(r0950, r096A, 0x01));

                     body.emit(assign(r0951, r0969, 0x01));

                     body.emit(assign(r0952, r0968, 0x01));

                     body.emit(assign(r094F, body.constant(int(0)), 0x01));

                     body.emit(assign(r0955, less(r0968, body.constant(0u)), 0x01));


                  body.instructions = f0964_parent_instructions;
                  body.emit(f0964);

                  /* END IF */


               body.instructions = f0961_parent_instructions;
               body.emit(f0961);

               /* END IF */


            body.instructions = f0957_parent_instructions;
            body.emit(f0957);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0980 = new(mem_ctx) ir_if(operand(r0953).val);
            exec_list *const f0980_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0980->then_instructions;

               /* IF CONDITION */
               ir_if *f0981 = new(mem_ctx) ir_if(operand(r0955).val);
               exec_list *const f0981_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0981->then_instructions;

                  ir_variable *const r0982 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r0982, add(r0951, body.constant(1u)), 0x01));

                  ir_expression *const r0983 = less(r0982, r0951);
                  ir_expression *const r0984 = expr(ir_unop_b2i, r0983);
                  ir_expression *const r0985 = expr(ir_unop_i2u, r0984);
                  body.emit(assign(r0950, add(r0950, r0985), 0x01));

                  ir_expression *const r0986 = equal(r0952, body.constant(0u));
                  ir_expression *const r0987 = expr(ir_unop_b2i, r0986);
                  ir_expression *const r0988 = expr(ir_unop_i2u, r0987);
                  ir_expression *const r0989 = add(r0952, r0988);
                  ir_expression *const r098A = bit_and(r0989, body.constant(1u));
                  ir_expression *const r098B = expr(ir_unop_bit_not, r098A);
                  body.emit(assign(r0951, bit_and(r0982, r098B), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0981->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r098D = bit_or(r0950, r0951);
                  ir_expression *const r098E = equal(r098D, body.constant(0u));
                  ir_if *f098C = new(mem_ctx) ir_if(operand(r098E).val);
                  exec_list *const f098C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f098C->then_instructions;

                     body.emit(assign(r094F, body.constant(int(0)), 0x01));


                  body.instructions = f098C_parent_instructions;
                  body.emit(f098C);

                  /* END IF */


               body.instructions = f0981_parent_instructions;
               body.emit(f0981);

               /* END IF */

               ir_variable *const r098F = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r098F);
               ir_expression *const r0990 = lshift(r07E7, body.constant(int(31)));
               ir_expression *const r0991 = expr(ir_unop_i2u, r094F);
               ir_expression *const r0992 = lshift(r0991, body.constant(int(20)));
               ir_expression *const r0993 = add(r0990, r0992);
               body.emit(assign(r098F, add(r0993, r0950), 0x02));

               body.emit(assign(r098F, r0951, 0x01));

               body.emit(assign(r0954, r098F, 0x03));

               body.emit(assign(r0953, body.constant(false), 0x01));


            body.instructions = f0980_parent_instructions;
            body.emit(f0980);

            /* END IF */

            body.emit(assign(r07EC, r0954, 0x03));

            body.emit(assign(r07EB, body.constant(false), 0x01));


         body.instructions = f0900_parent_instructions;
         body.emit(f0900);

         /* END IF */


      body.instructions = f08F9_parent_instructions;
      body.emit(f08F9);

      /* END IF */

      body.emit(assign(r07E6, r07EC, 0x03));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f07E9->else_instructions;

      ir_variable *const r0994 = body.make_temp(glsl_type::uint_type, "zSign");
      body.emit(assign(r0994, r07E7, 0x01));

      ir_variable *const r0995 = body.make_temp(glsl_type::uvec2_type, "return_value");
      ir_variable *const r0996 = new(mem_ctx) ir_variable(glsl_type::int_type, "expDiff", ir_var_auto);
      body.emit(r0996);
      ir_variable *const r0997 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
      body.emit(r0997);
      ir_variable *const r0998 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
      body.emit(r0998);
      ir_variable *const r0999 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
      body.emit(r0999);
      ir_variable *const r099A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
      body.emit(r099A);
      ir_variable *const r099B = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
      body.emit(r099B);
      ir_variable *const r099C = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
      body.emit(assign(r099C, bit_and(swizzle_y(r07E4), body.constant(1048575u)), 0x01));

      body.emit(assign(r099C, swizzle_x(r07E4), 0x02));

      ir_variable *const r099D = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r099E = rshift(swizzle_y(r07E4), body.constant(int(20)));
      ir_expression *const r099F = bit_and(r099E, body.constant(2047u));
      body.emit(assign(r099D, expr(ir_unop_u2i, r099F), 0x01));

      body.emit(assign(r0999, r099D, 0x01));

      ir_variable *const r09A0 = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
      body.emit(assign(r09A0, bit_and(swizzle_y(r07E5), body.constant(1048575u)), 0x01));

      body.emit(assign(r09A0, swizzle_x(r07E5), 0x02));

      ir_variable *const r09A1 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
      ir_expression *const r09A2 = rshift(swizzle_y(r07E5), body.constant(int(20)));
      ir_expression *const r09A3 = bit_and(r09A2, body.constant(2047u));
      body.emit(assign(r09A1, expr(ir_unop_u2i, r09A3), 0x01));

      body.emit(assign(r0997, r09A1, 0x01));

      body.emit(assign(r0996, sub(r099D, r09A1), 0x01));

      ir_variable *const r09A4 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r09A4, lshift(swizzle_x(r099C), body.constant(int(10))), 0x01));

      ir_variable *const r09A5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r09A6 = lshift(swizzle_x(r07E4), body.constant(int(10)));
      ir_expression *const r09A7 = rshift(swizzle_x(r099C), body.constant(int(22)));
      body.emit(assign(r09A5, bit_or(r09A6, r09A7), 0x01));

      body.emit(assign(r099A, r09A5, 0x02));

      body.emit(assign(r099A, r09A4, 0x01));

      ir_variable *const r09A8 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r09A8, lshift(swizzle_x(r09A0), body.constant(int(10))), 0x01));

      ir_variable *const r09A9 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      ir_expression *const r09AA = lshift(swizzle_x(r07E5), body.constant(int(10)));
      ir_expression *const r09AB = rshift(swizzle_x(r09A0), body.constant(int(22)));
      body.emit(assign(r09A9, bit_or(r09AA, r09AB), 0x01));

      body.emit(assign(r0998, r09A9, 0x02));

      body.emit(assign(r0998, r09A8, 0x01));

      /* IF CONDITION */
      ir_expression *const r09AD = less(body.constant(int(0)), r0996);
      ir_if *f09AC = new(mem_ctx) ir_if(operand(r09AD).val);
      exec_list *const f09AC_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f09AC->then_instructions;

         /* IF CONDITION */
         ir_expression *const r09AF = equal(r099D, body.constant(int(2047)));
         ir_if *f09AE = new(mem_ctx) ir_if(operand(r09AF).val);
         exec_list *const f09AE_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f09AE->then_instructions;

            /* IF CONDITION */
            ir_expression *const r09B1 = bit_or(r09A5, r09A4);
            ir_expression *const r09B2 = nequal(r09B1, body.constant(0u));
            ir_if *f09B0 = new(mem_ctx) ir_if(operand(r09B2).val);
            exec_list *const f09B0_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f09B0->then_instructions;

               ir_variable *const r09B3 = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r09B3, swizzle_y(r07E4), 0x02));

               ir_variable *const r09B4 = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r09B4, swizzle_y(r07E5), 0x02));

               ir_variable *const r09B5 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r09B6 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r09B7 = rshift(swizzle_x(r07E4), body.constant(int(19)));
               ir_expression *const r09B8 = bit_and(r09B7, body.constant(4095u));
               ir_expression *const r09B9 = equal(r09B8, body.constant(4094u));
               ir_expression *const r09BA = nequal(swizzle_y(r07E4), body.constant(0u));
               ir_expression *const r09BB = bit_and(swizzle_x(r07E4), body.constant(524287u));
               ir_expression *const r09BC = nequal(r09BB, body.constant(0u));
               ir_expression *const r09BD = logic_or(r09BA, r09BC);
               body.emit(assign(r09B6, logic_and(r09B9, r09BD), 0x01));

               ir_variable *const r09BE = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r09BF = lshift(swizzle_x(r07E5), body.constant(int(1)));
               ir_expression *const r09C0 = lequal(body.constant(4292870144u), r09BF);
               ir_expression *const r09C1 = nequal(swizzle_y(r07E5), body.constant(0u));
               ir_expression *const r09C2 = bit_and(swizzle_x(r07E5), body.constant(1048575u));
               ir_expression *const r09C3 = nequal(r09C2, body.constant(0u));
               ir_expression *const r09C4 = logic_or(r09C1, r09C3);
               body.emit(assign(r09BE, logic_and(r09C0, r09C4), 0x01));

               body.emit(assign(r09B3, bit_or(swizzle_x(r07E4), body.constant(524288u)), 0x01));

               body.emit(assign(r09B4, bit_or(swizzle_x(r07E5), body.constant(524288u)), 0x01));

               /* IF CONDITION */
               ir_expression *const r09C6 = lshift(swizzle_x(r07E4), body.constant(int(1)));
               ir_expression *const r09C7 = lequal(body.constant(4292870144u), r09C6);
               ir_expression *const r09C8 = nequal(swizzle_y(r07E4), body.constant(0u));
               ir_expression *const r09C9 = bit_and(swizzle_x(r07E4), body.constant(1048575u));
               ir_expression *const r09CA = nequal(r09C9, body.constant(0u));
               ir_expression *const r09CB = logic_or(r09C8, r09CA);
               ir_expression *const r09CC = logic_and(r09C7, r09CB);
               ir_if *f09C5 = new(mem_ctx) ir_if(operand(r09CC).val);
               exec_list *const f09C5_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f09C5->then_instructions;

                  ir_variable *const r09CD = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r09CF = logic_and(r09B6, r09BE);
                  ir_if *f09CE = new(mem_ctx) ir_if(operand(r09CF).val);
                  exec_list *const f09CE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f09CE->then_instructions;

                     body.emit(assign(r09CD, r09B4, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f09CE->else_instructions;

                     body.emit(assign(r09CD, r09B3, 0x03));


                  body.instructions = f09CE_parent_instructions;
                  body.emit(f09CE);

                  /* END IF */

                  body.emit(assign(r09B5, r09CD, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f09C5->else_instructions;

                  body.emit(assign(r09B5, r09B4, 0x03));


               body.instructions = f09C5_parent_instructions;
               body.emit(f09C5);

               /* END IF */

               body.emit(assign(r0995, r09B5, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f09B0->else_instructions;

               body.emit(assign(r0995, r07E4, 0x03));


            body.instructions = f09B0_parent_instructions;
            body.emit(f09B0);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f09AE->else_instructions;

            /* IF CONDITION */
            ir_expression *const r09D1 = equal(r09A1, body.constant(int(0)));
            ir_if *f09D0 = new(mem_ctx) ir_if(operand(r09D1).val);
            exec_list *const f09D0_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f09D0->then_instructions;

               body.emit(assign(r0996, add(r0996, body.constant(int(-1))), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f09D0->else_instructions;

               body.emit(assign(r0998, bit_or(r09A9, body.constant(1073741824u)), 0x02));


            body.instructions = f09D0_parent_instructions;
            body.emit(f09D0);

            /* END IF */

            ir_variable *const r09D2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
            body.emit(r09D2);
            ir_variable *const r09D3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
            body.emit(r09D3);
            ir_variable *const r09D4 = body.make_temp(glsl_type::int_type, "assignment_tmp");
            ir_expression *const r09D5 = neg(r0996);
            body.emit(assign(r09D4, bit_and(r09D5, body.constant(int(31))), 0x01));

            /* IF CONDITION */
            ir_expression *const r09D7 = equal(r0996, body.constant(int(0)));
            ir_if *f09D6 = new(mem_ctx) ir_if(operand(r09D7).val);
            exec_list *const f09D6_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f09D6->then_instructions;

               body.emit(assign(r09D2, swizzle_x(r0998), 0x01));

               body.emit(assign(r09D3, swizzle_y(r0998), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f09D6->else_instructions;

               /* IF CONDITION */
               ir_expression *const r09D9 = less(r0996, body.constant(int(32)));
               ir_if *f09D8 = new(mem_ctx) ir_if(operand(r09D9).val);
               exec_list *const f09D8_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f09D8->then_instructions;

                  ir_expression *const r09DA = lshift(swizzle_y(r0998), r09D4);
                  ir_expression *const r09DB = rshift(r09A8, r0996);
                  ir_expression *const r09DC = bit_or(r09DA, r09DB);
                  ir_expression *const r09DD = lshift(r09A8, r09D4);
                  ir_expression *const r09DE = nequal(r09DD, body.constant(0u));
                  ir_expression *const r09DF = expr(ir_unop_b2i, r09DE);
                  ir_expression *const r09E0 = expr(ir_unop_i2u, r09DF);
                  body.emit(assign(r09D2, bit_or(r09DC, r09E0), 0x01));

                  body.emit(assign(r09D3, rshift(swizzle_y(r0998), r0996), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f09D8->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r09E2 = equal(r0996, body.constant(int(32)));
                  ir_if *f09E1 = new(mem_ctx) ir_if(operand(r09E2).val);
                  exec_list *const f09E1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f09E1->then_instructions;

                     ir_expression *const r09E3 = nequal(r09A8, body.constant(0u));
                     ir_expression *const r09E4 = expr(ir_unop_b2i, r09E3);
                     ir_expression *const r09E5 = expr(ir_unop_i2u, r09E4);
                     body.emit(assign(r09D2, bit_or(swizzle_y(r0998), r09E5), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f09E1->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r09E7 = less(r0996, body.constant(int(64)));
                     ir_if *f09E6 = new(mem_ctx) ir_if(operand(r09E7).val);
                     exec_list *const f09E6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f09E6->then_instructions;

                        ir_expression *const r09E8 = bit_and(r0996, body.constant(int(31)));
                        ir_expression *const r09E9 = rshift(swizzle_y(r0998), r09E8);
                        ir_expression *const r09EA = lshift(swizzle_y(r0998), r09D4);
                        ir_expression *const r09EB = bit_or(r09EA, r09A8);
                        ir_expression *const r09EC = nequal(r09EB, body.constant(0u));
                        ir_expression *const r09ED = expr(ir_unop_b2i, r09EC);
                        ir_expression *const r09EE = expr(ir_unop_i2u, r09ED);
                        body.emit(assign(r09D2, bit_or(r09E9, r09EE), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f09E6->else_instructions;

                        ir_expression *const r09EF = bit_or(swizzle_y(r0998), r09A8);
                        ir_expression *const r09F0 = nequal(r09EF, body.constant(0u));
                        ir_expression *const r09F1 = expr(ir_unop_b2i, r09F0);
                        body.emit(assign(r09D2, expr(ir_unop_i2u, r09F1), 0x01));


                     body.instructions = f09E6_parent_instructions;
                     body.emit(f09E6);

                     /* END IF */


                  body.instructions = f09E1_parent_instructions;
                  body.emit(f09E1);

                  /* END IF */

                  body.emit(assign(r09D3, body.constant(0u), 0x01));


               body.instructions = f09D8_parent_instructions;
               body.emit(f09D8);

               /* END IF */


            body.instructions = f09D6_parent_instructions;
            body.emit(f09D6);

            /* END IF */

            body.emit(assign(r0998, r09D3, 0x02));

            body.emit(assign(r0998, r09D2, 0x01));

            body.emit(assign(r099A, bit_or(r09A5, body.constant(1073741824u)), 0x02));

            ir_variable *const r09F2 = body.make_temp(glsl_type::uint_type, "z0Ptr");
            ir_variable *const r09F3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
            body.emit(assign(r09F3, sub(r09A4, r09D2), 0x01));

            ir_expression *const r09F4 = sub(swizzle_y(r099A), r09D3);
            ir_expression *const r09F5 = less(r09A4, r09D2);
            ir_expression *const r09F6 = expr(ir_unop_b2i, r09F5);
            ir_expression *const r09F7 = expr(ir_unop_i2u, r09F6);
            body.emit(assign(r09F2, sub(r09F4, r09F7), 0x01));

            body.emit(assign(r099B, add(r099D, body.constant(int(-1))), 0x01));

            ir_variable *const r09F8 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r09F8, add(r099B, body.constant(int(-10))), 0x01));

            ir_variable *const r09F9 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r09F9, r09F2, 0x01));

            ir_variable *const r09FA = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r09FA, r09F3, 0x01));

            ir_variable *const r09FB = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
            body.emit(r09FB);
            ir_variable *const r09FC = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r09FC);
            /* IF CONDITION */
            ir_expression *const r09FE = equal(r09F2, body.constant(0u));
            ir_if *f09FD = new(mem_ctx) ir_if(operand(r09FE).val);
            exec_list *const f09FD_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f09FD->then_instructions;

               body.emit(assign(r09F9, r09F3, 0x01));

               body.emit(assign(r09FA, body.constant(0u), 0x01));

               body.emit(assign(r09F8, add(r09F8, body.constant(int(-32))), 0x01));


            body.instructions = f09FD_parent_instructions;
            body.emit(f09FD);

            /* END IF */

            ir_variable *const r09FF = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r09FF, r09F9, 0x01));

            ir_variable *const r0A00 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r0A01 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r0A01);
            /* IF CONDITION */
            ir_expression *const r0A03 = equal(r09F9, body.constant(0u));
            ir_if *f0A02 = new(mem_ctx) ir_if(operand(r0A03).val);
            exec_list *const f0A02_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A02->then_instructions;

               body.emit(assign(r0A00, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0A02->else_instructions;

               body.emit(assign(r0A01, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r0A05 = bit_and(r09F9, body.constant(4294901760u));
               ir_expression *const r0A06 = equal(r0A05, body.constant(0u));
               ir_if *f0A04 = new(mem_ctx) ir_if(operand(r0A06).val);
               exec_list *const f0A04_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A04->then_instructions;

                  body.emit(assign(r0A01, body.constant(int(16)), 0x01));

                  body.emit(assign(r09FF, lshift(r09F9, body.constant(int(16))), 0x01));


               body.instructions = f0A04_parent_instructions;
               body.emit(f0A04);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0A08 = bit_and(r09FF, body.constant(4278190080u));
               ir_expression *const r0A09 = equal(r0A08, body.constant(0u));
               ir_if *f0A07 = new(mem_ctx) ir_if(operand(r0A09).val);
               exec_list *const f0A07_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A07->then_instructions;

                  body.emit(assign(r0A01, add(r0A01, body.constant(int(8))), 0x01));

                  body.emit(assign(r09FF, lshift(r09FF, body.constant(int(8))), 0x01));


               body.instructions = f0A07_parent_instructions;
               body.emit(f0A07);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0A0B = bit_and(r09FF, body.constant(4026531840u));
               ir_expression *const r0A0C = equal(r0A0B, body.constant(0u));
               ir_if *f0A0A = new(mem_ctx) ir_if(operand(r0A0C).val);
               exec_list *const f0A0A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A0A->then_instructions;

                  body.emit(assign(r0A01, add(r0A01, body.constant(int(4))), 0x01));

                  body.emit(assign(r09FF, lshift(r09FF, body.constant(int(4))), 0x01));


               body.instructions = f0A0A_parent_instructions;
               body.emit(f0A0A);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0A0E = bit_and(r09FF, body.constant(3221225472u));
               ir_expression *const r0A0F = equal(r0A0E, body.constant(0u));
               ir_if *f0A0D = new(mem_ctx) ir_if(operand(r0A0F).val);
               exec_list *const f0A0D_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A0D->then_instructions;

                  body.emit(assign(r0A01, add(r0A01, body.constant(int(2))), 0x01));

                  body.emit(assign(r09FF, lshift(r09FF, body.constant(int(2))), 0x01));


               body.instructions = f0A0D_parent_instructions;
               body.emit(f0A0D);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0A11 = bit_and(r09FF, body.constant(2147483648u));
               ir_expression *const r0A12 = equal(r0A11, body.constant(0u));
               ir_if *f0A10 = new(mem_ctx) ir_if(operand(r0A12).val);
               exec_list *const f0A10_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A10->then_instructions;

                  body.emit(assign(r0A01, add(r0A01, body.constant(int(1))), 0x01));


               body.instructions = f0A10_parent_instructions;
               body.emit(f0A10);

               /* END IF */

               body.emit(assign(r0A00, r0A01, 0x01));


            body.instructions = f0A02_parent_instructions;
            body.emit(f0A02);

            /* END IF */

            body.emit(assign(r09FC, add(r0A00, body.constant(int(-11))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0A14 = lequal(body.constant(int(0)), r09FC);
            ir_if *f0A13 = new(mem_ctx) ir_if(operand(r0A14).val);
            exec_list *const f0A13_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A13->then_instructions;

               body.emit(assign(r09FB, body.constant(0u), 0x01));

               ir_variable *const r0A15 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r0A15, lshift(r09FA, r09FC), 0x01));

               ir_variable *const r0A16 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r0A18 = equal(r09FC, body.constant(int(0)));
               ir_if *f0A17 = new(mem_ctx) ir_if(operand(r0A18).val);
               exec_list *const f0A17_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A17->then_instructions;

                  body.emit(assign(r0A16, r09F9, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A17->else_instructions;

                  ir_expression *const r0A19 = lshift(r09F9, r09FC);
                  ir_expression *const r0A1A = neg(r09FC);
                  ir_expression *const r0A1B = bit_and(r0A1A, body.constant(int(31)));
                  ir_expression *const r0A1C = rshift(r09FA, r0A1B);
                  body.emit(assign(r0A16, bit_or(r0A19, r0A1C), 0x01));


               body.instructions = f0A17_parent_instructions;
               body.emit(f0A17);

               /* END IF */

               body.emit(assign(r09F9, r0A16, 0x01));

               body.emit(assign(r09FA, r0A15, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0A13->else_instructions;

               ir_variable *const r0A1D = body.make_temp(glsl_type::uint_type, "a2");
               body.emit(assign(r0A1D, body.constant(0u), 0x01));

               ir_variable *const r0A1E = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0A1E, neg(r09FC), 0x01));

               ir_variable *const r0A1F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r0A1F);
               ir_variable *const r0A20 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0A20);
               ir_variable *const r0A21 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0A21);
               ir_variable *const r0A22 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0A23 = neg(r0A1E);
               body.emit(assign(r0A22, bit_and(r0A23, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0A25 = equal(r0A1E, body.constant(int(0)));
               ir_if *f0A24 = new(mem_ctx) ir_if(operand(r0A25).val);
               exec_list *const f0A24_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A24->then_instructions;

                  body.emit(assign(r0A1F, r0A1D, 0x01));

                  body.emit(assign(r0A20, r09FA, 0x01));

                  body.emit(assign(r0A21, r09F9, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A24->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0A27 = less(r0A1E, body.constant(int(32)));
                  ir_if *f0A26 = new(mem_ctx) ir_if(operand(r0A27).val);
                  exec_list *const f0A26_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A26->then_instructions;

                     body.emit(assign(r0A1F, lshift(r09FA, r0A22), 0x01));

                     ir_expression *const r0A28 = lshift(r09F9, r0A22);
                     ir_expression *const r0A29 = rshift(r09FA, r0A1E);
                     body.emit(assign(r0A20, bit_or(r0A28, r0A29), 0x01));

                     body.emit(assign(r0A21, rshift(r09F9, r0A1E), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0A26->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0A2B = equal(r0A1E, body.constant(int(32)));
                     ir_if *f0A2A = new(mem_ctx) ir_if(operand(r0A2B).val);
                     exec_list *const f0A2A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0A2A->then_instructions;

                        body.emit(assign(r0A1F, r09FA, 0x01));

                        body.emit(assign(r0A20, r09F9, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0A2A->else_instructions;

                        body.emit(assign(r0A1D, bit_or(body.constant(0u), r09FA), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0A2D = less(r0A1E, body.constant(int(64)));
                        ir_if *f0A2C = new(mem_ctx) ir_if(operand(r0A2D).val);
                        exec_list *const f0A2C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0A2C->then_instructions;

                           body.emit(assign(r0A1F, lshift(r09F9, r0A22), 0x01));

                           ir_expression *const r0A2E = bit_and(r0A1E, body.constant(int(31)));
                           body.emit(assign(r0A20, rshift(r09F9, r0A2E), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0A2C->else_instructions;

                           ir_variable *const r0A2F = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0A31 = equal(r0A1E, body.constant(int(64)));
                           ir_if *f0A30 = new(mem_ctx) ir_if(operand(r0A31).val);
                           exec_list *const f0A30_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0A30->then_instructions;

                              body.emit(assign(r0A2F, r09F9, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0A30->else_instructions;

                              ir_expression *const r0A32 = nequal(r09F9, body.constant(0u));
                              ir_expression *const r0A33 = expr(ir_unop_b2i, r0A32);
                              body.emit(assign(r0A2F, expr(ir_unop_i2u, r0A33), 0x01));


                           body.instructions = f0A30_parent_instructions;
                           body.emit(f0A30);

                           /* END IF */

                           body.emit(assign(r0A1F, r0A2F, 0x01));

                           body.emit(assign(r0A20, body.constant(0u), 0x01));


                        body.instructions = f0A2C_parent_instructions;
                        body.emit(f0A2C);

                        /* END IF */


                     body.instructions = f0A2A_parent_instructions;
                     body.emit(f0A2A);

                     /* END IF */

                     body.emit(assign(r0A21, body.constant(0u), 0x01));


                  body.instructions = f0A26_parent_instructions;
                  body.emit(f0A26);

                  /* END IF */

                  ir_expression *const r0A34 = nequal(r0A1D, body.constant(0u));
                  ir_expression *const r0A35 = expr(ir_unop_b2i, r0A34);
                  ir_expression *const r0A36 = expr(ir_unop_i2u, r0A35);
                  body.emit(assign(r0A1F, bit_or(r0A1F, r0A36), 0x01));


               body.instructions = f0A24_parent_instructions;
               body.emit(f0A24);

               /* END IF */

               body.emit(assign(r09F9, r0A21, 0x01));

               body.emit(assign(r09FA, r0A20, 0x01));

               body.emit(assign(r09FB, r0A1F, 0x01));


            body.instructions = f0A13_parent_instructions;
            body.emit(f0A13);

            /* END IF */

            body.emit(assign(r09F8, sub(r09F8, r09FC), 0x01));

            ir_variable *const r0A37 = body.make_temp(glsl_type::int_type, "zExp");
            body.emit(assign(r0A37, r09F8, 0x01));

            ir_variable *const r0A38 = body.make_temp(glsl_type::uint_type, "zFrac0");
            body.emit(assign(r0A38, r09F9, 0x01));

            ir_variable *const r0A39 = body.make_temp(glsl_type::uint_type, "zFrac1");
            body.emit(assign(r0A39, r09FA, 0x01));

            ir_variable *const r0A3A = body.make_temp(glsl_type::uint_type, "zFrac2");
            body.emit(assign(r0A3A, r09FB, 0x01));

            ir_variable *const r0A3B = body.make_temp(glsl_type::bool_type, "execute_flag");
            body.emit(assign(r0A3B, body.constant(true), 0x01));

            ir_variable *const r0A3C = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0A3D = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
            body.emit(r0A3D);
            ir_expression *const r0A3E = expr(ir_unop_u2i, r09FB);
            body.emit(assign(r0A3D, less(r0A3E, body.constant(int(0))), 0x01));

            /* IF CONDITION */
            ir_expression *const r0A40 = lequal(body.constant(int(2045)), r09F8);
            ir_if *f0A3F = new(mem_ctx) ir_if(operand(r0A40).val);
            exec_list *const f0A3F_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A3F->then_instructions;

               ir_variable *const r0A41 = body.make_temp(glsl_type::bool_type, "or_tmp");
               /* IF CONDITION */
               ir_expression *const r0A43 = less(body.constant(int(2045)), r09F8);
               ir_if *f0A42 = new(mem_ctx) ir_if(operand(r0A43).val);
               exec_list *const f0A42_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A42->then_instructions;

                  body.emit(assign(r0A41, body.constant(true), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A42->else_instructions;

                  ir_variable *const r0A44 = body.make_temp(glsl_type::bool_type, "and_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0A46 = equal(r09F8, body.constant(int(2045)));
                  ir_if *f0A45 = new(mem_ctx) ir_if(operand(r0A46).val);
                  exec_list *const f0A45_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A45->then_instructions;

                     ir_expression *const r0A47 = equal(body.constant(2097151u), r09F9);
                     ir_expression *const r0A48 = equal(body.constant(4294967295u), r09FA);
                     body.emit(assign(r0A44, logic_and(r0A47, r0A48), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0A45->else_instructions;

                     body.emit(assign(r0A44, body.constant(false), 0x01));


                  body.instructions = f0A45_parent_instructions;
                  body.emit(f0A45);

                  /* END IF */

                  body.emit(assign(r0A41, logic_and(r0A44, r0A3D), 0x01));


               body.instructions = f0A42_parent_instructions;
               body.emit(f0A42);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0A49 = new(mem_ctx) ir_if(operand(r0A41).val);
               exec_list *const f0A49_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A49->then_instructions;

                  ir_variable *const r0A4A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0A4A);
                  ir_expression *const r0A4B = lshift(r07E7, body.constant(int(31)));
                  body.emit(assign(r0A4A, add(r0A4B, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0A4A, body.constant(0u), 0x01));

                  body.emit(assign(r0A3C, r0A4A, 0x03));

                  body.emit(assign(r0A3B, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A49->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0A4D = less(r09F8, body.constant(int(0)));
                  ir_if *f0A4C = new(mem_ctx) ir_if(operand(r0A4D).val);
                  exec_list *const f0A4C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A4C->then_instructions;

                     ir_variable *const r0A4E = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0A4E, r09FB, 0x01));

                     ir_variable *const r0A4F = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0A4F, neg(r09F8), 0x01));

                     ir_variable *const r0A50 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0A50);
                     ir_variable *const r0A51 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0A51);
                     ir_variable *const r0A52 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0A52);
                     ir_variable *const r0A53 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0A54 = neg(r0A4F);
                     body.emit(assign(r0A53, bit_and(r0A54, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0A56 = equal(r0A4F, body.constant(int(0)));
                     ir_if *f0A55 = new(mem_ctx) ir_if(operand(r0A56).val);
                     exec_list *const f0A55_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0A55->then_instructions;

                        body.emit(assign(r0A50, r09FB, 0x01));

                        body.emit(assign(r0A51, r09FA, 0x01));

                        body.emit(assign(r0A52, r09F9, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0A55->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0A58 = less(r0A4F, body.constant(int(32)));
                        ir_if *f0A57 = new(mem_ctx) ir_if(operand(r0A58).val);
                        exec_list *const f0A57_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0A57->then_instructions;

                           body.emit(assign(r0A50, lshift(r09FA, r0A53), 0x01));

                           ir_expression *const r0A59 = lshift(r09F9, r0A53);
                           ir_expression *const r0A5A = rshift(r09FA, r0A4F);
                           body.emit(assign(r0A51, bit_or(r0A59, r0A5A), 0x01));

                           body.emit(assign(r0A52, rshift(r09F9, r0A4F), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0A57->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0A5C = equal(r0A4F, body.constant(int(32)));
                           ir_if *f0A5B = new(mem_ctx) ir_if(operand(r0A5C).val);
                           exec_list *const f0A5B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0A5B->then_instructions;

                              body.emit(assign(r0A50, r09FA, 0x01));

                              body.emit(assign(r0A51, r09F9, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0A5B->else_instructions;

                              body.emit(assign(r0A4E, bit_or(r09FB, r09FA), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0A5E = less(r0A4F, body.constant(int(64)));
                              ir_if *f0A5D = new(mem_ctx) ir_if(operand(r0A5E).val);
                              exec_list *const f0A5D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0A5D->then_instructions;

                                 body.emit(assign(r0A50, lshift(r09F9, r0A53), 0x01));

                                 ir_expression *const r0A5F = bit_and(r0A4F, body.constant(int(31)));
                                 body.emit(assign(r0A51, rshift(r09F9, r0A5F), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0A5D->else_instructions;

                                 ir_variable *const r0A60 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0A62 = equal(r0A4F, body.constant(int(64)));
                                 ir_if *f0A61 = new(mem_ctx) ir_if(operand(r0A62).val);
                                 exec_list *const f0A61_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0A61->then_instructions;

                                    body.emit(assign(r0A60, r09F9, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0A61->else_instructions;

                                    ir_expression *const r0A63 = nequal(r09F9, body.constant(0u));
                                    ir_expression *const r0A64 = expr(ir_unop_b2i, r0A63);
                                    body.emit(assign(r0A60, expr(ir_unop_i2u, r0A64), 0x01));


                                 body.instructions = f0A61_parent_instructions;
                                 body.emit(f0A61);

                                 /* END IF */

                                 body.emit(assign(r0A50, r0A60, 0x01));

                                 body.emit(assign(r0A51, body.constant(0u), 0x01));


                              body.instructions = f0A5D_parent_instructions;
                              body.emit(f0A5D);

                              /* END IF */


                           body.instructions = f0A5B_parent_instructions;
                           body.emit(f0A5B);

                           /* END IF */

                           body.emit(assign(r0A52, body.constant(0u), 0x01));


                        body.instructions = f0A57_parent_instructions;
                        body.emit(f0A57);

                        /* END IF */

                        ir_expression *const r0A65 = nequal(r0A4E, body.constant(0u));
                        ir_expression *const r0A66 = expr(ir_unop_b2i, r0A65);
                        ir_expression *const r0A67 = expr(ir_unop_i2u, r0A66);
                        body.emit(assign(r0A50, bit_or(r0A50, r0A67), 0x01));


                     body.instructions = f0A55_parent_instructions;
                     body.emit(f0A55);

                     /* END IF */

                     body.emit(assign(r0A38, r0A52, 0x01));

                     body.emit(assign(r0A39, r0A51, 0x01));

                     body.emit(assign(r0A3A, r0A50, 0x01));

                     body.emit(assign(r0A37, body.constant(int(0)), 0x01));

                     body.emit(assign(r0A3D, less(r0A50, body.constant(0u)), 0x01));


                  body.instructions = f0A4C_parent_instructions;
                  body.emit(f0A4C);

                  /* END IF */


               body.instructions = f0A49_parent_instructions;
               body.emit(f0A49);

               /* END IF */


            body.instructions = f0A3F_parent_instructions;
            body.emit(f0A3F);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0A68 = new(mem_ctx) ir_if(operand(r0A3B).val);
            exec_list *const f0A68_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A68->then_instructions;

               /* IF CONDITION */
               ir_if *f0A69 = new(mem_ctx) ir_if(operand(r0A3D).val);
               exec_list *const f0A69_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A69->then_instructions;

                  ir_variable *const r0A6A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r0A6A, add(r0A39, body.constant(1u)), 0x01));

                  ir_expression *const r0A6B = less(r0A6A, r0A39);
                  ir_expression *const r0A6C = expr(ir_unop_b2i, r0A6B);
                  ir_expression *const r0A6D = expr(ir_unop_i2u, r0A6C);
                  body.emit(assign(r0A38, add(r0A38, r0A6D), 0x01));

                  ir_expression *const r0A6E = equal(r0A3A, body.constant(0u));
                  ir_expression *const r0A6F = expr(ir_unop_b2i, r0A6E);
                  ir_expression *const r0A70 = expr(ir_unop_i2u, r0A6F);
                  ir_expression *const r0A71 = add(r0A3A, r0A70);
                  ir_expression *const r0A72 = bit_and(r0A71, body.constant(1u));
                  ir_expression *const r0A73 = expr(ir_unop_bit_not, r0A72);
                  body.emit(assign(r0A39, bit_and(r0A6A, r0A73), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A69->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0A75 = bit_or(r0A38, r0A39);
                  ir_expression *const r0A76 = equal(r0A75, body.constant(0u));
                  ir_if *f0A74 = new(mem_ctx) ir_if(operand(r0A76).val);
                  exec_list *const f0A74_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A74->then_instructions;

                     body.emit(assign(r0A37, body.constant(int(0)), 0x01));


                  body.instructions = f0A74_parent_instructions;
                  body.emit(f0A74);

                  /* END IF */


               body.instructions = f0A69_parent_instructions;
               body.emit(f0A69);

               /* END IF */

               ir_variable *const r0A77 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0A77);
               ir_expression *const r0A78 = lshift(r07E7, body.constant(int(31)));
               ir_expression *const r0A79 = expr(ir_unop_i2u, r0A37);
               ir_expression *const r0A7A = lshift(r0A79, body.constant(int(20)));
               ir_expression *const r0A7B = add(r0A78, r0A7A);
               body.emit(assign(r0A77, add(r0A7B, r0A38), 0x02));

               body.emit(assign(r0A77, r0A39, 0x01));

               body.emit(assign(r0A3C, r0A77, 0x03));

               body.emit(assign(r0A3B, body.constant(false), 0x01));


            body.instructions = f0A68_parent_instructions;
            body.emit(f0A68);

            /* END IF */

            body.emit(assign(r0995, r0A3C, 0x03));


         body.instructions = f09AE_parent_instructions;
         body.emit(f09AE);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f09AC->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0A7D = less(r0996, body.constant(int(0)));
         ir_if *f0A7C = new(mem_ctx) ir_if(operand(r0A7D).val);
         exec_list *const f0A7C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0A7C->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0A7F = equal(r09A1, body.constant(int(2047)));
            ir_if *f0A7E = new(mem_ctx) ir_if(operand(r0A7F).val);
            exec_list *const f0A7E_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0A7E->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0A81 = bit_or(swizzle_y(r0998), swizzle_x(r0998));
               ir_expression *const r0A82 = nequal(r0A81, body.constant(0u));
               ir_if *f0A80 = new(mem_ctx) ir_if(operand(r0A82).val);
               exec_list *const f0A80_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0A80->then_instructions;

                  ir_variable *const r0A83 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r0A83, swizzle_y(r07E4), 0x02));

                  ir_variable *const r0A84 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r0A84, swizzle_y(r07E5), 0x02));

                  ir_variable *const r0A85 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0A86 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0A87 = rshift(swizzle_x(r07E4), body.constant(int(19)));
                  ir_expression *const r0A88 = bit_and(r0A87, body.constant(4095u));
                  ir_expression *const r0A89 = equal(r0A88, body.constant(4094u));
                  ir_expression *const r0A8A = nequal(swizzle_y(r07E4), body.constant(0u));
                  ir_expression *const r0A8B = bit_and(swizzle_x(r07E4), body.constant(524287u));
                  ir_expression *const r0A8C = nequal(r0A8B, body.constant(0u));
                  ir_expression *const r0A8D = logic_or(r0A8A, r0A8C);
                  body.emit(assign(r0A86, logic_and(r0A89, r0A8D), 0x01));

                  ir_variable *const r0A8E = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0A8F = lshift(swizzle_x(r07E5), body.constant(int(1)));
                  ir_expression *const r0A90 = lequal(body.constant(4292870144u), r0A8F);
                  ir_expression *const r0A91 = nequal(swizzle_y(r07E5), body.constant(0u));
                  ir_expression *const r0A92 = bit_and(swizzle_x(r07E5), body.constant(1048575u));
                  ir_expression *const r0A93 = nequal(r0A92, body.constant(0u));
                  ir_expression *const r0A94 = logic_or(r0A91, r0A93);
                  body.emit(assign(r0A8E, logic_and(r0A90, r0A94), 0x01));

                  body.emit(assign(r0A83, bit_or(swizzle_x(r07E4), body.constant(524288u)), 0x01));

                  body.emit(assign(r0A84, bit_or(swizzle_x(r07E5), body.constant(524288u)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0A96 = lshift(swizzle_x(r07E4), body.constant(int(1)));
                  ir_expression *const r0A97 = lequal(body.constant(4292870144u), r0A96);
                  ir_expression *const r0A98 = nequal(swizzle_y(r07E4), body.constant(0u));
                  ir_expression *const r0A99 = bit_and(swizzle_x(r07E4), body.constant(1048575u));
                  ir_expression *const r0A9A = nequal(r0A99, body.constant(0u));
                  ir_expression *const r0A9B = logic_or(r0A98, r0A9A);
                  ir_expression *const r0A9C = logic_and(r0A97, r0A9B);
                  ir_if *f0A95 = new(mem_ctx) ir_if(operand(r0A9C).val);
                  exec_list *const f0A95_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0A95->then_instructions;

                     ir_variable *const r0A9D = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0A9F = logic_and(r0A86, r0A8E);
                     ir_if *f0A9E = new(mem_ctx) ir_if(operand(r0A9F).val);
                     exec_list *const f0A9E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0A9E->then_instructions;

                        body.emit(assign(r0A9D, r0A84, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0A9E->else_instructions;

                        body.emit(assign(r0A9D, r0A83, 0x03));


                     body.instructions = f0A9E_parent_instructions;
                     body.emit(f0A9E);

                     /* END IF */

                     body.emit(assign(r0A85, r0A9D, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0A95->else_instructions;

                     body.emit(assign(r0A85, r0A84, 0x03));


                  body.instructions = f0A95_parent_instructions;
                  body.emit(f0A95);

                  /* END IF */

                  body.emit(assign(r0995, r0A85, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0A80->else_instructions;

                  ir_variable *const r0AA0 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0AA0);
                  ir_expression *const r0AA1 = bit_xor(r07E7, body.constant(1u));
                  ir_expression *const r0AA2 = lshift(r0AA1, body.constant(int(31)));
                  body.emit(assign(r0AA0, add(r0AA2, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r0AA0, body.constant(0u), 0x01));

                  body.emit(assign(r0995, r0AA0, 0x03));


               body.instructions = f0A80_parent_instructions;
               body.emit(f0A80);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0A7E->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0AA4 = equal(r099D, body.constant(int(0)));
               ir_if *f0AA3 = new(mem_ctx) ir_if(operand(r0AA4).val);
               exec_list *const f0AA3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0AA3->then_instructions;

                  body.emit(assign(r0996, add(r0996, body.constant(int(1))), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0AA3->else_instructions;

                  body.emit(assign(r099A, bit_or(swizzle_y(r099A), body.constant(1073741824u)), 0x02));


               body.instructions = f0AA3_parent_instructions;
               body.emit(f0AA3);

               /* END IF */

               ir_variable *const r0AA5 = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r0AA5, neg(r0996), 0x01));

               ir_variable *const r0AA6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0AA6);
               ir_variable *const r0AA7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0AA7);
               ir_variable *const r0AA8 = body.make_temp(glsl_type::int_type, "assignment_tmp");
               ir_expression *const r0AA9 = neg(r0AA5);
               body.emit(assign(r0AA8, bit_and(r0AA9, body.constant(int(31))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0AAB = equal(r0AA5, body.constant(int(0)));
               ir_if *f0AAA = new(mem_ctx) ir_if(operand(r0AAB).val);
               exec_list *const f0AAA_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0AAA->then_instructions;

                  body.emit(assign(r0AA6, swizzle_x(r099A), 0x01));

                  body.emit(assign(r0AA7, swizzle_y(r099A), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0AAA->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0AAD = less(r0AA5, body.constant(int(32)));
                  ir_if *f0AAC = new(mem_ctx) ir_if(operand(r0AAD).val);
                  exec_list *const f0AAC_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AAC->then_instructions;

                     ir_expression *const r0AAE = lshift(swizzle_y(r099A), r0AA8);
                     ir_expression *const r0AAF = rshift(r09A4, r0AA5);
                     ir_expression *const r0AB0 = bit_or(r0AAE, r0AAF);
                     ir_expression *const r0AB1 = lshift(r09A4, r0AA8);
                     ir_expression *const r0AB2 = nequal(r0AB1, body.constant(0u));
                     ir_expression *const r0AB3 = expr(ir_unop_b2i, r0AB2);
                     ir_expression *const r0AB4 = expr(ir_unop_i2u, r0AB3);
                     body.emit(assign(r0AA6, bit_or(r0AB0, r0AB4), 0x01));

                     body.emit(assign(r0AA7, rshift(swizzle_y(r099A), r0AA5), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0AAC->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0AB6 = equal(r0AA5, body.constant(int(32)));
                     ir_if *f0AB5 = new(mem_ctx) ir_if(operand(r0AB6).val);
                     exec_list *const f0AB5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0AB5->then_instructions;

                        ir_expression *const r0AB7 = nequal(r09A4, body.constant(0u));
                        ir_expression *const r0AB8 = expr(ir_unop_b2i, r0AB7);
                        ir_expression *const r0AB9 = expr(ir_unop_i2u, r0AB8);
                        body.emit(assign(r0AA6, bit_or(swizzle_y(r099A), r0AB9), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0AB5->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0ABB = less(r0AA5, body.constant(int(64)));
                        ir_if *f0ABA = new(mem_ctx) ir_if(operand(r0ABB).val);
                        exec_list *const f0ABA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0ABA->then_instructions;

                           ir_expression *const r0ABC = bit_and(r0AA5, body.constant(int(31)));
                           ir_expression *const r0ABD = rshift(swizzle_y(r099A), r0ABC);
                           ir_expression *const r0ABE = lshift(swizzle_y(r099A), r0AA8);
                           ir_expression *const r0ABF = bit_or(r0ABE, r09A4);
                           ir_expression *const r0AC0 = nequal(r0ABF, body.constant(0u));
                           ir_expression *const r0AC1 = expr(ir_unop_b2i, r0AC0);
                           ir_expression *const r0AC2 = expr(ir_unop_i2u, r0AC1);
                           body.emit(assign(r0AA6, bit_or(r0ABD, r0AC2), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0ABA->else_instructions;

                           ir_expression *const r0AC3 = bit_or(swizzle_y(r099A), r09A4);
                           ir_expression *const r0AC4 = nequal(r0AC3, body.constant(0u));
                           ir_expression *const r0AC5 = expr(ir_unop_b2i, r0AC4);
                           body.emit(assign(r0AA6, expr(ir_unop_i2u, r0AC5), 0x01));


                        body.instructions = f0ABA_parent_instructions;
                        body.emit(f0ABA);

                        /* END IF */


                     body.instructions = f0AB5_parent_instructions;
                     body.emit(f0AB5);

                     /* END IF */

                     body.emit(assign(r0AA7, body.constant(0u), 0x01));


                  body.instructions = f0AAC_parent_instructions;
                  body.emit(f0AAC);

                  /* END IF */


               body.instructions = f0AAA_parent_instructions;
               body.emit(f0AAA);

               /* END IF */

               body.emit(assign(r099A, r0AA7, 0x02));

               body.emit(assign(r099A, r0AA6, 0x01));

               body.emit(assign(r0998, bit_or(swizzle_y(r0998), body.constant(1073741824u)), 0x02));

               ir_variable *const r0AC6 = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r0AC7 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r0AC7, sub(swizzle_x(r0998), r0AA6), 0x01));

               ir_expression *const r0AC8 = sub(swizzle_y(r0998), r0AA7);
               ir_expression *const r0AC9 = less(swizzle_x(r0998), r0AA6);
               ir_expression *const r0ACA = expr(ir_unop_b2i, r0AC9);
               ir_expression *const r0ACB = expr(ir_unop_i2u, r0ACA);
               body.emit(assign(r0AC6, sub(r0AC8, r0ACB), 0x01));

               body.emit(assign(r0994, bit_xor(r07E7, body.constant(1u)), 0x01));

               body.emit(assign(r099B, add(r09A1, body.constant(int(-1))), 0x01));

               ir_variable *const r0ACC = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r0ACC, add(r099B, body.constant(int(-10))), 0x01));

               ir_variable *const r0ACD = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0ACD, r0AC6, 0x01));

               ir_variable *const r0ACE = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0ACE, r0AC7, 0x01));

               ir_variable *const r0ACF = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
               body.emit(r0ACF);
               ir_variable *const r0AD0 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r0AD0);
               /* IF CONDITION */
               ir_expression *const r0AD2 = equal(r0AC6, body.constant(0u));
               ir_if *f0AD1 = new(mem_ctx) ir_if(operand(r0AD2).val);
               exec_list *const f0AD1_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0AD1->then_instructions;

                  body.emit(assign(r0ACD, r0AC7, 0x01));

                  body.emit(assign(r0ACE, body.constant(0u), 0x01));

                  body.emit(assign(r0ACC, add(r0ACC, body.constant(int(-32))), 0x01));


               body.instructions = f0AD1_parent_instructions;
               body.emit(f0AD1);

               /* END IF */

               ir_variable *const r0AD3 = body.make_temp(glsl_type::uint_type, "a");
               body.emit(assign(r0AD3, r0ACD, 0x01));

               ir_variable *const r0AD4 = body.make_temp(glsl_type::int_type, "return_value");
               ir_variable *const r0AD5 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r0AD5);
               /* IF CONDITION */
               ir_expression *const r0AD7 = equal(r0ACD, body.constant(0u));
               ir_if *f0AD6 = new(mem_ctx) ir_if(operand(r0AD7).val);
               exec_list *const f0AD6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0AD6->then_instructions;

                  body.emit(assign(r0AD4, body.constant(int(32)), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0AD6->else_instructions;

                  body.emit(assign(r0AD5, body.constant(int(0)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0AD9 = bit_and(r0ACD, body.constant(4294901760u));
                  ir_expression *const r0ADA = equal(r0AD9, body.constant(0u));
                  ir_if *f0AD8 = new(mem_ctx) ir_if(operand(r0ADA).val);
                  exec_list *const f0AD8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AD8->then_instructions;

                     body.emit(assign(r0AD5, body.constant(int(16)), 0x01));

                     body.emit(assign(r0AD3, lshift(r0ACD, body.constant(int(16))), 0x01));


                  body.instructions = f0AD8_parent_instructions;
                  body.emit(f0AD8);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0ADC = bit_and(r0AD3, body.constant(4278190080u));
                  ir_expression *const r0ADD = equal(r0ADC, body.constant(0u));
                  ir_if *f0ADB = new(mem_ctx) ir_if(operand(r0ADD).val);
                  exec_list *const f0ADB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0ADB->then_instructions;

                     body.emit(assign(r0AD5, add(r0AD5, body.constant(int(8))), 0x01));

                     body.emit(assign(r0AD3, lshift(r0AD3, body.constant(int(8))), 0x01));


                  body.instructions = f0ADB_parent_instructions;
                  body.emit(f0ADB);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0ADF = bit_and(r0AD3, body.constant(4026531840u));
                  ir_expression *const r0AE0 = equal(r0ADF, body.constant(0u));
                  ir_if *f0ADE = new(mem_ctx) ir_if(operand(r0AE0).val);
                  exec_list *const f0ADE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0ADE->then_instructions;

                     body.emit(assign(r0AD5, add(r0AD5, body.constant(int(4))), 0x01));

                     body.emit(assign(r0AD3, lshift(r0AD3, body.constant(int(4))), 0x01));


                  body.instructions = f0ADE_parent_instructions;
                  body.emit(f0ADE);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0AE2 = bit_and(r0AD3, body.constant(3221225472u));
                  ir_expression *const r0AE3 = equal(r0AE2, body.constant(0u));
                  ir_if *f0AE1 = new(mem_ctx) ir_if(operand(r0AE3).val);
                  exec_list *const f0AE1_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AE1->then_instructions;

                     body.emit(assign(r0AD5, add(r0AD5, body.constant(int(2))), 0x01));

                     body.emit(assign(r0AD3, lshift(r0AD3, body.constant(int(2))), 0x01));


                  body.instructions = f0AE1_parent_instructions;
                  body.emit(f0AE1);

                  /* END IF */

                  /* IF CONDITION */
                  ir_expression *const r0AE5 = bit_and(r0AD3, body.constant(2147483648u));
                  ir_expression *const r0AE6 = equal(r0AE5, body.constant(0u));
                  ir_if *f0AE4 = new(mem_ctx) ir_if(operand(r0AE6).val);
                  exec_list *const f0AE4_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AE4->then_instructions;

                     body.emit(assign(r0AD5, add(r0AD5, body.constant(int(1))), 0x01));


                  body.instructions = f0AE4_parent_instructions;
                  body.emit(f0AE4);

                  /* END IF */

                  body.emit(assign(r0AD4, r0AD5, 0x01));


               body.instructions = f0AD6_parent_instructions;
               body.emit(f0AD6);

               /* END IF */

               body.emit(assign(r0AD0, add(r0AD4, body.constant(int(-11))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0AE8 = lequal(body.constant(int(0)), r0AD0);
               ir_if *f0AE7 = new(mem_ctx) ir_if(operand(r0AE8).val);
               exec_list *const f0AE7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0AE7->then_instructions;

                  body.emit(assign(r0ACF, body.constant(0u), 0x01));

                  ir_variable *const r0AE9 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0AE9, lshift(r0ACE, r0AD0), 0x01));

                  ir_variable *const r0AEA = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0AEC = equal(r0AD0, body.constant(int(0)));
                  ir_if *f0AEB = new(mem_ctx) ir_if(operand(r0AEC).val);
                  exec_list *const f0AEB_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AEB->then_instructions;

                     body.emit(assign(r0AEA, r0ACD, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0AEB->else_instructions;

                     ir_expression *const r0AED = lshift(r0ACD, r0AD0);
                     ir_expression *const r0AEE = neg(r0AD0);
                     ir_expression *const r0AEF = bit_and(r0AEE, body.constant(int(31)));
                     ir_expression *const r0AF0 = rshift(r0ACE, r0AEF);
                     body.emit(assign(r0AEA, bit_or(r0AED, r0AF0), 0x01));


                  body.instructions = f0AEB_parent_instructions;
                  body.emit(f0AEB);

                  /* END IF */

                  body.emit(assign(r0ACD, r0AEA, 0x01));

                  body.emit(assign(r0ACE, r0AE9, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0AE7->else_instructions;

                  ir_variable *const r0AF1 = body.make_temp(glsl_type::uint_type, "a2");
                  body.emit(assign(r0AF1, body.constant(0u), 0x01));

                  ir_variable *const r0AF2 = body.make_temp(glsl_type::int_type, "count");
                  body.emit(assign(r0AF2, neg(r0AD0), 0x01));

                  ir_variable *const r0AF3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r0AF3);
                  ir_variable *const r0AF4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r0AF4);
                  ir_variable *const r0AF5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r0AF5);
                  ir_variable *const r0AF6 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                  ir_expression *const r0AF7 = neg(r0AF2);
                  body.emit(assign(r0AF6, bit_and(r0AF7, body.constant(int(31))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0AF9 = equal(r0AF2, body.constant(int(0)));
                  ir_if *f0AF8 = new(mem_ctx) ir_if(operand(r0AF9).val);
                  exec_list *const f0AF8_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0AF8->then_instructions;

                     body.emit(assign(r0AF3, r0AF1, 0x01));

                     body.emit(assign(r0AF4, r0ACE, 0x01));

                     body.emit(assign(r0AF5, r0ACD, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0AF8->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0AFB = less(r0AF2, body.constant(int(32)));
                     ir_if *f0AFA = new(mem_ctx) ir_if(operand(r0AFB).val);
                     exec_list *const f0AFA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0AFA->then_instructions;

                        body.emit(assign(r0AF3, lshift(r0ACE, r0AF6), 0x01));

                        ir_expression *const r0AFC = lshift(r0ACD, r0AF6);
                        ir_expression *const r0AFD = rshift(r0ACE, r0AF2);
                        body.emit(assign(r0AF4, bit_or(r0AFC, r0AFD), 0x01));

                        body.emit(assign(r0AF5, rshift(r0ACD, r0AF2), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0AFA->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0AFF = equal(r0AF2, body.constant(int(32)));
                        ir_if *f0AFE = new(mem_ctx) ir_if(operand(r0AFF).val);
                        exec_list *const f0AFE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0AFE->then_instructions;

                           body.emit(assign(r0AF3, r0ACE, 0x01));

                           body.emit(assign(r0AF4, r0ACD, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0AFE->else_instructions;

                           body.emit(assign(r0AF1, bit_or(body.constant(0u), r0ACE), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0B01 = less(r0AF2, body.constant(int(64)));
                           ir_if *f0B00 = new(mem_ctx) ir_if(operand(r0B01).val);
                           exec_list *const f0B00_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0B00->then_instructions;

                              body.emit(assign(r0AF3, lshift(r0ACD, r0AF6), 0x01));

                              ir_expression *const r0B02 = bit_and(r0AF2, body.constant(int(31)));
                              body.emit(assign(r0AF4, rshift(r0ACD, r0B02), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0B00->else_instructions;

                              ir_variable *const r0B03 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0B05 = equal(r0AF2, body.constant(int(64)));
                              ir_if *f0B04 = new(mem_ctx) ir_if(operand(r0B05).val);
                              exec_list *const f0B04_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0B04->then_instructions;

                                 body.emit(assign(r0B03, r0ACD, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0B04->else_instructions;

                                 ir_expression *const r0B06 = nequal(r0ACD, body.constant(0u));
                                 ir_expression *const r0B07 = expr(ir_unop_b2i, r0B06);
                                 body.emit(assign(r0B03, expr(ir_unop_i2u, r0B07), 0x01));


                              body.instructions = f0B04_parent_instructions;
                              body.emit(f0B04);

                              /* END IF */

                              body.emit(assign(r0AF3, r0B03, 0x01));

                              body.emit(assign(r0AF4, body.constant(0u), 0x01));


                           body.instructions = f0B00_parent_instructions;
                           body.emit(f0B00);

                           /* END IF */


                        body.instructions = f0AFE_parent_instructions;
                        body.emit(f0AFE);

                        /* END IF */

                        body.emit(assign(r0AF5, body.constant(0u), 0x01));


                     body.instructions = f0AFA_parent_instructions;
                     body.emit(f0AFA);

                     /* END IF */

                     ir_expression *const r0B08 = nequal(r0AF1, body.constant(0u));
                     ir_expression *const r0B09 = expr(ir_unop_b2i, r0B08);
                     ir_expression *const r0B0A = expr(ir_unop_i2u, r0B09);
                     body.emit(assign(r0AF3, bit_or(r0AF3, r0B0A), 0x01));


                  body.instructions = f0AF8_parent_instructions;
                  body.emit(f0AF8);

                  /* END IF */

                  body.emit(assign(r0ACD, r0AF5, 0x01));

                  body.emit(assign(r0ACE, r0AF4, 0x01));

                  body.emit(assign(r0ACF, r0AF3, 0x01));


               body.instructions = f0AE7_parent_instructions;
               body.emit(f0AE7);

               /* END IF */

               body.emit(assign(r0ACC, sub(r0ACC, r0AD0), 0x01));

               ir_variable *const r0B0B = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r0B0B, r0ACC, 0x01));

               ir_variable *const r0B0C = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0B0C, r0ACD, 0x01));

               ir_variable *const r0B0D = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0B0D, r0ACE, 0x01));

               ir_variable *const r0B0E = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r0B0E, r0ACF, 0x01));

               ir_variable *const r0B0F = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r0B0F, body.constant(true), 0x01));

               ir_variable *const r0B10 = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0B11 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r0B11);
               ir_expression *const r0B12 = expr(ir_unop_u2i, r0ACF);
               body.emit(assign(r0B11, less(r0B12, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0B14 = lequal(body.constant(int(2045)), r0ACC);
               ir_if *f0B13 = new(mem_ctx) ir_if(operand(r0B14).val);
               exec_list *const f0B13_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B13->then_instructions;

                  ir_variable *const r0B15 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0B17 = less(body.constant(int(2045)), r0ACC);
                  ir_if *f0B16 = new(mem_ctx) ir_if(operand(r0B17).val);
                  exec_list *const f0B16_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B16->then_instructions;

                     body.emit(assign(r0B15, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B16->else_instructions;

                     ir_variable *const r0B18 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0B1A = equal(r0ACC, body.constant(int(2045)));
                     ir_if *f0B19 = new(mem_ctx) ir_if(operand(r0B1A).val);
                     exec_list *const f0B19_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B19->then_instructions;

                        ir_expression *const r0B1B = equal(body.constant(2097151u), r0ACD);
                        ir_expression *const r0B1C = equal(body.constant(4294967295u), r0ACE);
                        body.emit(assign(r0B18, logic_and(r0B1B, r0B1C), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0B19->else_instructions;

                        body.emit(assign(r0B18, body.constant(false), 0x01));


                     body.instructions = f0B19_parent_instructions;
                     body.emit(f0B19);

                     /* END IF */

                     body.emit(assign(r0B15, logic_and(r0B18, r0B11), 0x01));


                  body.instructions = f0B16_parent_instructions;
                  body.emit(f0B16);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0B1D = new(mem_ctx) ir_if(operand(r0B15).val);
                  exec_list *const f0B1D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B1D->then_instructions;

                     ir_variable *const r0B1E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0B1E);
                     ir_expression *const r0B1F = lshift(r0994, body.constant(int(31)));
                     body.emit(assign(r0B1E, add(r0B1F, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r0B1E, body.constant(0u), 0x01));

                     body.emit(assign(r0B10, r0B1E, 0x03));

                     body.emit(assign(r0B0F, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B1D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0B21 = less(r0ACC, body.constant(int(0)));
                     ir_if *f0B20 = new(mem_ctx) ir_if(operand(r0B21).val);
                     exec_list *const f0B20_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B20->then_instructions;

                        ir_variable *const r0B22 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0B22, r0ACF, 0x01));

                        ir_variable *const r0B23 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0B23, neg(r0ACC), 0x01));

                        ir_variable *const r0B24 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0B24);
                        ir_variable *const r0B25 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0B25);
                        ir_variable *const r0B26 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0B26);
                        ir_variable *const r0B27 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r0B28 = neg(r0B23);
                        body.emit(assign(r0B27, bit_and(r0B28, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0B2A = equal(r0B23, body.constant(int(0)));
                        ir_if *f0B29 = new(mem_ctx) ir_if(operand(r0B2A).val);
                        exec_list *const f0B29_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0B29->then_instructions;

                           body.emit(assign(r0B24, r0ACF, 0x01));

                           body.emit(assign(r0B25, r0ACE, 0x01));

                           body.emit(assign(r0B26, r0ACD, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0B29->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0B2C = less(r0B23, body.constant(int(32)));
                           ir_if *f0B2B = new(mem_ctx) ir_if(operand(r0B2C).val);
                           exec_list *const f0B2B_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0B2B->then_instructions;

                              body.emit(assign(r0B24, lshift(r0ACE, r0B27), 0x01));

                              ir_expression *const r0B2D = lshift(r0ACD, r0B27);
                              ir_expression *const r0B2E = rshift(r0ACE, r0B23);
                              body.emit(assign(r0B25, bit_or(r0B2D, r0B2E), 0x01));

                              body.emit(assign(r0B26, rshift(r0ACD, r0B23), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0B2B->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0B30 = equal(r0B23, body.constant(int(32)));
                              ir_if *f0B2F = new(mem_ctx) ir_if(operand(r0B30).val);
                              exec_list *const f0B2F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0B2F->then_instructions;

                                 body.emit(assign(r0B24, r0ACE, 0x01));

                                 body.emit(assign(r0B25, r0ACD, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0B2F->else_instructions;

                                 body.emit(assign(r0B22, bit_or(r0ACF, r0ACE), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0B32 = less(r0B23, body.constant(int(64)));
                                 ir_if *f0B31 = new(mem_ctx) ir_if(operand(r0B32).val);
                                 exec_list *const f0B31_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0B31->then_instructions;

                                    body.emit(assign(r0B24, lshift(r0ACD, r0B27), 0x01));

                                    ir_expression *const r0B33 = bit_and(r0B23, body.constant(int(31)));
                                    body.emit(assign(r0B25, rshift(r0ACD, r0B33), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0B31->else_instructions;

                                    ir_variable *const r0B34 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r0B36 = equal(r0B23, body.constant(int(64)));
                                    ir_if *f0B35 = new(mem_ctx) ir_if(operand(r0B36).val);
                                    exec_list *const f0B35_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0B35->then_instructions;

                                       body.emit(assign(r0B34, r0ACD, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0B35->else_instructions;

                                       ir_expression *const r0B37 = nequal(r0ACD, body.constant(0u));
                                       ir_expression *const r0B38 = expr(ir_unop_b2i, r0B37);
                                       body.emit(assign(r0B34, expr(ir_unop_i2u, r0B38), 0x01));


                                    body.instructions = f0B35_parent_instructions;
                                    body.emit(f0B35);

                                    /* END IF */

                                    body.emit(assign(r0B24, r0B34, 0x01));

                                    body.emit(assign(r0B25, body.constant(0u), 0x01));


                                 body.instructions = f0B31_parent_instructions;
                                 body.emit(f0B31);

                                 /* END IF */


                              body.instructions = f0B2F_parent_instructions;
                              body.emit(f0B2F);

                              /* END IF */

                              body.emit(assign(r0B26, body.constant(0u), 0x01));


                           body.instructions = f0B2B_parent_instructions;
                           body.emit(f0B2B);

                           /* END IF */

                           ir_expression *const r0B39 = nequal(r0B22, body.constant(0u));
                           ir_expression *const r0B3A = expr(ir_unop_b2i, r0B39);
                           ir_expression *const r0B3B = expr(ir_unop_i2u, r0B3A);
                           body.emit(assign(r0B24, bit_or(r0B24, r0B3B), 0x01));


                        body.instructions = f0B29_parent_instructions;
                        body.emit(f0B29);

                        /* END IF */

                        body.emit(assign(r0B0C, r0B26, 0x01));

                        body.emit(assign(r0B0D, r0B25, 0x01));

                        body.emit(assign(r0B0E, r0B24, 0x01));

                        body.emit(assign(r0B0B, body.constant(int(0)), 0x01));

                        body.emit(assign(r0B11, less(r0B24, body.constant(0u)), 0x01));


                     body.instructions = f0B20_parent_instructions;
                     body.emit(f0B20);

                     /* END IF */


                  body.instructions = f0B1D_parent_instructions;
                  body.emit(f0B1D);

                  /* END IF */


               body.instructions = f0B13_parent_instructions;
               body.emit(f0B13);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0B3C = new(mem_ctx) ir_if(operand(r0B0F).val);
               exec_list *const f0B3C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B3C->then_instructions;

                  /* IF CONDITION */
                  ir_if *f0B3D = new(mem_ctx) ir_if(operand(r0B11).val);
                  exec_list *const f0B3D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B3D->then_instructions;

                     ir_variable *const r0B3E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r0B3E, add(r0B0D, body.constant(1u)), 0x01));

                     ir_expression *const r0B3F = less(r0B3E, r0B0D);
                     ir_expression *const r0B40 = expr(ir_unop_b2i, r0B3F);
                     ir_expression *const r0B41 = expr(ir_unop_i2u, r0B40);
                     body.emit(assign(r0B0C, add(r0B0C, r0B41), 0x01));

                     ir_expression *const r0B42 = equal(r0B0E, body.constant(0u));
                     ir_expression *const r0B43 = expr(ir_unop_b2i, r0B42);
                     ir_expression *const r0B44 = expr(ir_unop_i2u, r0B43);
                     ir_expression *const r0B45 = add(r0B0E, r0B44);
                     ir_expression *const r0B46 = bit_and(r0B45, body.constant(1u));
                     ir_expression *const r0B47 = expr(ir_unop_bit_not, r0B46);
                     body.emit(assign(r0B0D, bit_and(r0B3E, r0B47), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B3D->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0B49 = bit_or(r0B0C, r0B0D);
                     ir_expression *const r0B4A = equal(r0B49, body.constant(0u));
                     ir_if *f0B48 = new(mem_ctx) ir_if(operand(r0B4A).val);
                     exec_list *const f0B48_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B48->then_instructions;

                        body.emit(assign(r0B0B, body.constant(int(0)), 0x01));


                     body.instructions = f0B48_parent_instructions;
                     body.emit(f0B48);

                     /* END IF */


                  body.instructions = f0B3D_parent_instructions;
                  body.emit(f0B3D);

                  /* END IF */

                  ir_variable *const r0B4B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0B4B);
                  ir_expression *const r0B4C = lshift(r0994, body.constant(int(31)));
                  ir_expression *const r0B4D = expr(ir_unop_i2u, r0B0B);
                  ir_expression *const r0B4E = lshift(r0B4D, body.constant(int(20)));
                  ir_expression *const r0B4F = add(r0B4C, r0B4E);
                  body.emit(assign(r0B4B, add(r0B4F, r0B0C), 0x02));

                  body.emit(assign(r0B4B, r0B0D, 0x01));

                  body.emit(assign(r0B10, r0B4B, 0x03));

                  body.emit(assign(r0B0F, body.constant(false), 0x01));


               body.instructions = f0B3C_parent_instructions;
               body.emit(f0B3C);

               /* END IF */

               body.emit(assign(r0995, r0B10, 0x03));


            body.instructions = f0A7E_parent_instructions;
            body.emit(f0A7E);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0A7C->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0B51 = equal(r099D, body.constant(int(2047)));
            ir_if *f0B50 = new(mem_ctx) ir_if(operand(r0B51).val);
            exec_list *const f0B50_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0B50->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0B53 = bit_or(swizzle_y(r099A), swizzle_x(r099A));
               ir_expression *const r0B54 = bit_or(swizzle_y(r0998), swizzle_x(r0998));
               ir_expression *const r0B55 = bit_or(r0B53, r0B54);
               ir_expression *const r0B56 = nequal(r0B55, body.constant(0u));
               ir_if *f0B52 = new(mem_ctx) ir_if(operand(r0B56).val);
               exec_list *const f0B52_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B52->then_instructions;

                  ir_variable *const r0B57 = body.make_temp(glsl_type::uvec2_type, "a");
                  body.emit(assign(r0B57, swizzle_y(r07E4), 0x02));

                  ir_variable *const r0B58 = body.make_temp(glsl_type::uvec2_type, "b");
                  body.emit(assign(r0B58, swizzle_y(r07E5), 0x02));

                  ir_variable *const r0B59 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0B5A = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
                  ir_expression *const r0B5B = rshift(swizzle_x(r07E4), body.constant(int(19)));
                  ir_expression *const r0B5C = bit_and(r0B5B, body.constant(4095u));
                  ir_expression *const r0B5D = equal(r0B5C, body.constant(4094u));
                  ir_expression *const r0B5E = nequal(swizzle_y(r07E4), body.constant(0u));
                  ir_expression *const r0B5F = bit_and(swizzle_x(r07E4), body.constant(524287u));
                  ir_expression *const r0B60 = nequal(r0B5F, body.constant(0u));
                  ir_expression *const r0B61 = logic_or(r0B5E, r0B60);
                  body.emit(assign(r0B5A, logic_and(r0B5D, r0B61), 0x01));

                  ir_variable *const r0B62 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
                  ir_expression *const r0B63 = lshift(swizzle_x(r07E5), body.constant(int(1)));
                  ir_expression *const r0B64 = lequal(body.constant(4292870144u), r0B63);
                  ir_expression *const r0B65 = nequal(swizzle_y(r07E5), body.constant(0u));
                  ir_expression *const r0B66 = bit_and(swizzle_x(r07E5), body.constant(1048575u));
                  ir_expression *const r0B67 = nequal(r0B66, body.constant(0u));
                  ir_expression *const r0B68 = logic_or(r0B65, r0B67);
                  body.emit(assign(r0B62, logic_and(r0B64, r0B68), 0x01));

                  body.emit(assign(r0B57, bit_or(swizzle_x(r07E4), body.constant(524288u)), 0x01));

                  body.emit(assign(r0B58, bit_or(swizzle_x(r07E5), body.constant(524288u)), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0B6A = lshift(swizzle_x(r07E4), body.constant(int(1)));
                  ir_expression *const r0B6B = lequal(body.constant(4292870144u), r0B6A);
                  ir_expression *const r0B6C = nequal(swizzle_y(r07E4), body.constant(0u));
                  ir_expression *const r0B6D = bit_and(swizzle_x(r07E4), body.constant(1048575u));
                  ir_expression *const r0B6E = nequal(r0B6D, body.constant(0u));
                  ir_expression *const r0B6F = logic_or(r0B6C, r0B6E);
                  ir_expression *const r0B70 = logic_and(r0B6B, r0B6F);
                  ir_if *f0B69 = new(mem_ctx) ir_if(operand(r0B70).val);
                  exec_list *const f0B69_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B69->then_instructions;

                     ir_variable *const r0B71 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0B73 = logic_and(r0B5A, r0B62);
                     ir_if *f0B72 = new(mem_ctx) ir_if(operand(r0B73).val);
                     exec_list *const f0B72_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B72->then_instructions;

                        body.emit(assign(r0B71, r0B58, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0B72->else_instructions;

                        body.emit(assign(r0B71, r0B57, 0x03));


                     body.instructions = f0B72_parent_instructions;
                     body.emit(f0B72);

                     /* END IF */

                     body.emit(assign(r0B59, r0B71, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B69->else_instructions;

                     body.emit(assign(r0B59, r0B58, 0x03));


                  body.instructions = f0B69_parent_instructions;
                  body.emit(f0B69);

                  /* END IF */

                  body.emit(assign(r0995, r0B59, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0B52->else_instructions;

                  ir_constant_data r0B74_data;
                  memset(&r0B74_data, 0, sizeof(ir_constant_data));
                  r0B74_data.u[0] = 4294967295;
                  r0B74_data.u[1] = 4294967295;
                  ir_constant *const r0B74 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r0B74_data);
                  body.emit(assign(r0995, r0B74, 0x03));


               body.instructions = f0B52_parent_instructions;
               body.emit(f0B52);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0B50->else_instructions;

               /* IF CONDITION */
               ir_expression *const r0B76 = equal(r099D, body.constant(int(0)));
               ir_if *f0B75 = new(mem_ctx) ir_if(operand(r0B76).val);
               exec_list *const f0B75_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B75->then_instructions;

                  body.emit(assign(r0999, body.constant(int(1)), 0x01));

                  body.emit(assign(r0997, body.constant(int(1)), 0x01));


               body.instructions = f0B75_parent_instructions;
               body.emit(f0B75);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r0B78 = less(swizzle_y(r0998), swizzle_y(r099A));
               ir_if *f0B77 = new(mem_ctx) ir_if(operand(r0B78).val);
               exec_list *const f0B77_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0B77->then_instructions;

                  ir_variable *const r0B79 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                  ir_variable *const r0B7A = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0B7A, sub(swizzle_x(r099A), swizzle_x(r0998)), 0x01));

                  ir_expression *const r0B7B = sub(swizzle_y(r099A), swizzle_y(r0998));
                  ir_expression *const r0B7C = less(swizzle_x(r099A), swizzle_x(r0998));
                  ir_expression *const r0B7D = expr(ir_unop_b2i, r0B7C);
                  ir_expression *const r0B7E = expr(ir_unop_i2u, r0B7D);
                  body.emit(assign(r0B79, sub(r0B7B, r0B7E), 0x01));

                  body.emit(assign(r099B, add(r0999, body.constant(int(-1))), 0x01));

                  ir_variable *const r0B7F = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r0B7F, add(r099B, body.constant(int(-10))), 0x01));

                  ir_variable *const r0B80 = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r0B80, r0B79, 0x01));

                  ir_variable *const r0B81 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r0B81, r0B7A, 0x01));

                  ir_variable *const r0B82 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                  body.emit(r0B82);
                  ir_variable *const r0B83 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0B83);
                  /* IF CONDITION */
                  ir_expression *const r0B85 = equal(r0B79, body.constant(0u));
                  ir_if *f0B84 = new(mem_ctx) ir_if(operand(r0B85).val);
                  exec_list *const f0B84_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B84->then_instructions;

                     body.emit(assign(r0B80, r0B7A, 0x01));

                     body.emit(assign(r0B81, body.constant(0u), 0x01));

                     body.emit(assign(r0B7F, add(r0B7F, body.constant(int(-32))), 0x01));


                  body.instructions = f0B84_parent_instructions;
                  body.emit(f0B84);

                  /* END IF */

                  ir_variable *const r0B86 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r0B86, r0B80, 0x01));

                  ir_variable *const r0B87 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r0B88 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0B88);
                  /* IF CONDITION */
                  ir_expression *const r0B8A = equal(r0B80, body.constant(0u));
                  ir_if *f0B89 = new(mem_ctx) ir_if(operand(r0B8A).val);
                  exec_list *const f0B89_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B89->then_instructions;

                     body.emit(assign(r0B87, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B89->else_instructions;

                     body.emit(assign(r0B88, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0B8C = bit_and(r0B80, body.constant(4294901760u));
                     ir_expression *const r0B8D = equal(r0B8C, body.constant(0u));
                     ir_if *f0B8B = new(mem_ctx) ir_if(operand(r0B8D).val);
                     exec_list *const f0B8B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B8B->then_instructions;

                        body.emit(assign(r0B88, body.constant(int(16)), 0x01));

                        body.emit(assign(r0B86, lshift(r0B80, body.constant(int(16))), 0x01));


                     body.instructions = f0B8B_parent_instructions;
                     body.emit(f0B8B);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0B8F = bit_and(r0B86, body.constant(4278190080u));
                     ir_expression *const r0B90 = equal(r0B8F, body.constant(0u));
                     ir_if *f0B8E = new(mem_ctx) ir_if(operand(r0B90).val);
                     exec_list *const f0B8E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B8E->then_instructions;

                        body.emit(assign(r0B88, add(r0B88, body.constant(int(8))), 0x01));

                        body.emit(assign(r0B86, lshift(r0B86, body.constant(int(8))), 0x01));


                     body.instructions = f0B8E_parent_instructions;
                     body.emit(f0B8E);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0B92 = bit_and(r0B86, body.constant(4026531840u));
                     ir_expression *const r0B93 = equal(r0B92, body.constant(0u));
                     ir_if *f0B91 = new(mem_ctx) ir_if(operand(r0B93).val);
                     exec_list *const f0B91_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B91->then_instructions;

                        body.emit(assign(r0B88, add(r0B88, body.constant(int(4))), 0x01));

                        body.emit(assign(r0B86, lshift(r0B86, body.constant(int(4))), 0x01));


                     body.instructions = f0B91_parent_instructions;
                     body.emit(f0B91);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0B95 = bit_and(r0B86, body.constant(3221225472u));
                     ir_expression *const r0B96 = equal(r0B95, body.constant(0u));
                     ir_if *f0B94 = new(mem_ctx) ir_if(operand(r0B96).val);
                     exec_list *const f0B94_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B94->then_instructions;

                        body.emit(assign(r0B88, add(r0B88, body.constant(int(2))), 0x01));

                        body.emit(assign(r0B86, lshift(r0B86, body.constant(int(2))), 0x01));


                     body.instructions = f0B94_parent_instructions;
                     body.emit(f0B94);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0B98 = bit_and(r0B86, body.constant(2147483648u));
                     ir_expression *const r0B99 = equal(r0B98, body.constant(0u));
                     ir_if *f0B97 = new(mem_ctx) ir_if(operand(r0B99).val);
                     exec_list *const f0B97_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B97->then_instructions;

                        body.emit(assign(r0B88, add(r0B88, body.constant(int(1))), 0x01));


                     body.instructions = f0B97_parent_instructions;
                     body.emit(f0B97);

                     /* END IF */

                     body.emit(assign(r0B87, r0B88, 0x01));


                  body.instructions = f0B89_parent_instructions;
                  body.emit(f0B89);

                  /* END IF */

                  body.emit(assign(r0B83, add(r0B87, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0B9B = lequal(body.constant(int(0)), r0B83);
                  ir_if *f0B9A = new(mem_ctx) ir_if(operand(r0B9B).val);
                  exec_list *const f0B9A_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0B9A->then_instructions;

                     body.emit(assign(r0B82, body.constant(0u), 0x01));

                     ir_variable *const r0B9C = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r0B9C, lshift(r0B81, r0B83), 0x01));

                     ir_variable *const r0B9D = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0B9F = equal(r0B83, body.constant(int(0)));
                     ir_if *f0B9E = new(mem_ctx) ir_if(operand(r0B9F).val);
                     exec_list *const f0B9E_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0B9E->then_instructions;

                        body.emit(assign(r0B9D, r0B80, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0B9E->else_instructions;

                        ir_expression *const r0BA0 = lshift(r0B80, r0B83);
                        ir_expression *const r0BA1 = neg(r0B83);
                        ir_expression *const r0BA2 = bit_and(r0BA1, body.constant(int(31)));
                        ir_expression *const r0BA3 = rshift(r0B81, r0BA2);
                        body.emit(assign(r0B9D, bit_or(r0BA0, r0BA3), 0x01));


                     body.instructions = f0B9E_parent_instructions;
                     body.emit(f0B9E);

                     /* END IF */

                     body.emit(assign(r0B80, r0B9D, 0x01));

                     body.emit(assign(r0B81, r0B9C, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0B9A->else_instructions;

                     ir_variable *const r0BA4 = body.make_temp(glsl_type::uint_type, "a2");
                     body.emit(assign(r0BA4, body.constant(0u), 0x01));

                     ir_variable *const r0BA5 = body.make_temp(glsl_type::int_type, "count");
                     body.emit(assign(r0BA5, neg(r0B83), 0x01));

                     ir_variable *const r0BA6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                     body.emit(r0BA6);
                     ir_variable *const r0BA7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r0BA7);
                     ir_variable *const r0BA8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r0BA8);
                     ir_variable *const r0BA9 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                     ir_expression *const r0BAA = neg(r0BA5);
                     body.emit(assign(r0BA9, bit_and(r0BAA, body.constant(int(31))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0BAC = equal(r0BA5, body.constant(int(0)));
                     ir_if *f0BAB = new(mem_ctx) ir_if(operand(r0BAC).val);
                     exec_list *const f0BAB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BAB->then_instructions;

                        body.emit(assign(r0BA6, r0BA4, 0x01));

                        body.emit(assign(r0BA7, r0B81, 0x01));

                        body.emit(assign(r0BA8, r0B80, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BAB->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0BAE = less(r0BA5, body.constant(int(32)));
                        ir_if *f0BAD = new(mem_ctx) ir_if(operand(r0BAE).val);
                        exec_list *const f0BAD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0BAD->then_instructions;

                           body.emit(assign(r0BA6, lshift(r0B81, r0BA9), 0x01));

                           ir_expression *const r0BAF = lshift(r0B80, r0BA9);
                           ir_expression *const r0BB0 = rshift(r0B81, r0BA5);
                           body.emit(assign(r0BA7, bit_or(r0BAF, r0BB0), 0x01));

                           body.emit(assign(r0BA8, rshift(r0B80, r0BA5), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0BAD->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0BB2 = equal(r0BA5, body.constant(int(32)));
                           ir_if *f0BB1 = new(mem_ctx) ir_if(operand(r0BB2).val);
                           exec_list *const f0BB1_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0BB1->then_instructions;

                              body.emit(assign(r0BA6, r0B81, 0x01));

                              body.emit(assign(r0BA7, r0B80, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0BB1->else_instructions;

                              body.emit(assign(r0BA4, bit_or(body.constant(0u), r0B81), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0BB4 = less(r0BA5, body.constant(int(64)));
                              ir_if *f0BB3 = new(mem_ctx) ir_if(operand(r0BB4).val);
                              exec_list *const f0BB3_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0BB3->then_instructions;

                                 body.emit(assign(r0BA6, lshift(r0B80, r0BA9), 0x01));

                                 ir_expression *const r0BB5 = bit_and(r0BA5, body.constant(int(31)));
                                 body.emit(assign(r0BA7, rshift(r0B80, r0BB5), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0BB3->else_instructions;

                                 ir_variable *const r0BB6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0BB8 = equal(r0BA5, body.constant(int(64)));
                                 ir_if *f0BB7 = new(mem_ctx) ir_if(operand(r0BB8).val);
                                 exec_list *const f0BB7_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0BB7->then_instructions;

                                    body.emit(assign(r0BB6, r0B80, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0BB7->else_instructions;

                                    ir_expression *const r0BB9 = nequal(r0B80, body.constant(0u));
                                    ir_expression *const r0BBA = expr(ir_unop_b2i, r0BB9);
                                    body.emit(assign(r0BB6, expr(ir_unop_i2u, r0BBA), 0x01));


                                 body.instructions = f0BB7_parent_instructions;
                                 body.emit(f0BB7);

                                 /* END IF */

                                 body.emit(assign(r0BA6, r0BB6, 0x01));

                                 body.emit(assign(r0BA7, body.constant(0u), 0x01));


                              body.instructions = f0BB3_parent_instructions;
                              body.emit(f0BB3);

                              /* END IF */


                           body.instructions = f0BB1_parent_instructions;
                           body.emit(f0BB1);

                           /* END IF */

                           body.emit(assign(r0BA8, body.constant(0u), 0x01));


                        body.instructions = f0BAD_parent_instructions;
                        body.emit(f0BAD);

                        /* END IF */

                        ir_expression *const r0BBB = nequal(r0BA4, body.constant(0u));
                        ir_expression *const r0BBC = expr(ir_unop_b2i, r0BBB);
                        ir_expression *const r0BBD = expr(ir_unop_i2u, r0BBC);
                        body.emit(assign(r0BA6, bit_or(r0BA6, r0BBD), 0x01));


                     body.instructions = f0BAB_parent_instructions;
                     body.emit(f0BAB);

                     /* END IF */

                     body.emit(assign(r0B80, r0BA8, 0x01));

                     body.emit(assign(r0B81, r0BA7, 0x01));

                     body.emit(assign(r0B82, r0BA6, 0x01));


                  body.instructions = f0B9A_parent_instructions;
                  body.emit(f0B9A);

                  /* END IF */

                  body.emit(assign(r0B7F, sub(r0B7F, r0B83), 0x01));

                  ir_variable *const r0BBE = body.make_temp(glsl_type::int_type, "zExp");
                  body.emit(assign(r0BBE, r0B7F, 0x01));

                  ir_variable *const r0BBF = body.make_temp(glsl_type::uint_type, "zFrac0");
                  body.emit(assign(r0BBF, r0B80, 0x01));

                  ir_variable *const r0BC0 = body.make_temp(glsl_type::uint_type, "zFrac1");
                  body.emit(assign(r0BC0, r0B81, 0x01));

                  ir_variable *const r0BC1 = body.make_temp(glsl_type::uint_type, "zFrac2");
                  body.emit(assign(r0BC1, r0B82, 0x01));

                  ir_variable *const r0BC2 = body.make_temp(glsl_type::bool_type, "execute_flag");
                  body.emit(assign(r0BC2, body.constant(true), 0x01));

                  ir_variable *const r0BC3 = body.make_temp(glsl_type::uvec2_type, "return_value");
                  ir_variable *const r0BC4 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                  body.emit(r0BC4);
                  ir_expression *const r0BC5 = expr(ir_unop_u2i, r0B82);
                  body.emit(assign(r0BC4, less(r0BC5, body.constant(int(0))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0BC7 = lequal(body.constant(int(2045)), r0B7F);
                  ir_if *f0BC6 = new(mem_ctx) ir_if(operand(r0BC7).val);
                  exec_list *const f0BC6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0BC6->then_instructions;

                     ir_variable *const r0BC8 = body.make_temp(glsl_type::bool_type, "or_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0BCA = less(body.constant(int(2045)), r0B7F);
                     ir_if *f0BC9 = new(mem_ctx) ir_if(operand(r0BCA).val);
                     exec_list *const f0BC9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BC9->then_instructions;

                        body.emit(assign(r0BC8, body.constant(true), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BC9->else_instructions;

                        ir_variable *const r0BCB = body.make_temp(glsl_type::bool_type, "and_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0BCD = equal(r0B7F, body.constant(int(2045)));
                        ir_if *f0BCC = new(mem_ctx) ir_if(operand(r0BCD).val);
                        exec_list *const f0BCC_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0BCC->then_instructions;

                           ir_expression *const r0BCE = equal(body.constant(2097151u), r0B80);
                           ir_expression *const r0BCF = equal(body.constant(4294967295u), r0B81);
                           body.emit(assign(r0BCB, logic_and(r0BCE, r0BCF), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0BCC->else_instructions;

                           body.emit(assign(r0BCB, body.constant(false), 0x01));


                        body.instructions = f0BCC_parent_instructions;
                        body.emit(f0BCC);

                        /* END IF */

                        body.emit(assign(r0BC8, logic_and(r0BCB, r0BC4), 0x01));


                     body.instructions = f0BC9_parent_instructions;
                     body.emit(f0BC9);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f0BD0 = new(mem_ctx) ir_if(operand(r0BC8).val);
                     exec_list *const f0BD0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BD0->then_instructions;

                        ir_variable *const r0BD1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r0BD1);
                        ir_expression *const r0BD2 = lshift(r0994, body.constant(int(31)));
                        body.emit(assign(r0BD1, add(r0BD2, body.constant(2146435072u)), 0x02));

                        body.emit(assign(r0BD1, body.constant(0u), 0x01));

                        body.emit(assign(r0BC3, r0BD1, 0x03));

                        body.emit(assign(r0BC2, body.constant(false), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BD0->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0BD4 = less(r0B7F, body.constant(int(0)));
                        ir_if *f0BD3 = new(mem_ctx) ir_if(operand(r0BD4).val);
                        exec_list *const f0BD3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0BD3->then_instructions;

                           ir_variable *const r0BD5 = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r0BD5, r0B82, 0x01));

                           ir_variable *const r0BD6 = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r0BD6, neg(r0B7F), 0x01));

                           ir_variable *const r0BD7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r0BD7);
                           ir_variable *const r0BD8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r0BD8);
                           ir_variable *const r0BD9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r0BD9);
                           ir_variable *const r0BDA = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r0BDB = neg(r0BD6);
                           body.emit(assign(r0BDA, bit_and(r0BDB, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0BDD = equal(r0BD6, body.constant(int(0)));
                           ir_if *f0BDC = new(mem_ctx) ir_if(operand(r0BDD).val);
                           exec_list *const f0BDC_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0BDC->then_instructions;

                              body.emit(assign(r0BD7, r0B82, 0x01));

                              body.emit(assign(r0BD8, r0B81, 0x01));

                              body.emit(assign(r0BD9, r0B80, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0BDC->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0BDF = less(r0BD6, body.constant(int(32)));
                              ir_if *f0BDE = new(mem_ctx) ir_if(operand(r0BDF).val);
                              exec_list *const f0BDE_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0BDE->then_instructions;

                                 body.emit(assign(r0BD7, lshift(r0B81, r0BDA), 0x01));

                                 ir_expression *const r0BE0 = lshift(r0B80, r0BDA);
                                 ir_expression *const r0BE1 = rshift(r0B81, r0BD6);
                                 body.emit(assign(r0BD8, bit_or(r0BE0, r0BE1), 0x01));

                                 body.emit(assign(r0BD9, rshift(r0B80, r0BD6), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0BDE->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0BE3 = equal(r0BD6, body.constant(int(32)));
                                 ir_if *f0BE2 = new(mem_ctx) ir_if(operand(r0BE3).val);
                                 exec_list *const f0BE2_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0BE2->then_instructions;

                                    body.emit(assign(r0BD7, r0B81, 0x01));

                                    body.emit(assign(r0BD8, r0B80, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0BE2->else_instructions;

                                    body.emit(assign(r0BD5, bit_or(r0B82, r0B81), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r0BE5 = less(r0BD6, body.constant(int(64)));
                                    ir_if *f0BE4 = new(mem_ctx) ir_if(operand(r0BE5).val);
                                    exec_list *const f0BE4_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0BE4->then_instructions;

                                       body.emit(assign(r0BD7, lshift(r0B80, r0BDA), 0x01));

                                       ir_expression *const r0BE6 = bit_and(r0BD6, body.constant(int(31)));
                                       body.emit(assign(r0BD8, rshift(r0B80, r0BE6), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0BE4->else_instructions;

                                       ir_variable *const r0BE7 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r0BE9 = equal(r0BD6, body.constant(int(64)));
                                       ir_if *f0BE8 = new(mem_ctx) ir_if(operand(r0BE9).val);
                                       exec_list *const f0BE8_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0BE8->then_instructions;

                                          body.emit(assign(r0BE7, r0B80, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0BE8->else_instructions;

                                          ir_expression *const r0BEA = nequal(r0B80, body.constant(0u));
                                          ir_expression *const r0BEB = expr(ir_unop_b2i, r0BEA);
                                          body.emit(assign(r0BE7, expr(ir_unop_i2u, r0BEB), 0x01));


                                       body.instructions = f0BE8_parent_instructions;
                                       body.emit(f0BE8);

                                       /* END IF */

                                       body.emit(assign(r0BD7, r0BE7, 0x01));

                                       body.emit(assign(r0BD8, body.constant(0u), 0x01));


                                    body.instructions = f0BE4_parent_instructions;
                                    body.emit(f0BE4);

                                    /* END IF */


                                 body.instructions = f0BE2_parent_instructions;
                                 body.emit(f0BE2);

                                 /* END IF */

                                 body.emit(assign(r0BD9, body.constant(0u), 0x01));


                              body.instructions = f0BDE_parent_instructions;
                              body.emit(f0BDE);

                              /* END IF */

                              ir_expression *const r0BEC = nequal(r0BD5, body.constant(0u));
                              ir_expression *const r0BED = expr(ir_unop_b2i, r0BEC);
                              ir_expression *const r0BEE = expr(ir_unop_i2u, r0BED);
                              body.emit(assign(r0BD7, bit_or(r0BD7, r0BEE), 0x01));


                           body.instructions = f0BDC_parent_instructions;
                           body.emit(f0BDC);

                           /* END IF */

                           body.emit(assign(r0BBF, r0BD9, 0x01));

                           body.emit(assign(r0BC0, r0BD8, 0x01));

                           body.emit(assign(r0BC1, r0BD7, 0x01));

                           body.emit(assign(r0BBE, body.constant(int(0)), 0x01));

                           body.emit(assign(r0BC4, less(r0BD7, body.constant(0u)), 0x01));


                        body.instructions = f0BD3_parent_instructions;
                        body.emit(f0BD3);

                        /* END IF */


                     body.instructions = f0BD0_parent_instructions;
                     body.emit(f0BD0);

                     /* END IF */


                  body.instructions = f0BC6_parent_instructions;
                  body.emit(f0BC6);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0BEF = new(mem_ctx) ir_if(operand(r0BC2).val);
                  exec_list *const f0BEF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0BEF->then_instructions;

                     /* IF CONDITION */
                     ir_if *f0BF0 = new(mem_ctx) ir_if(operand(r0BC4).val);
                     exec_list *const f0BF0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0BF0->then_instructions;

                        ir_variable *const r0BF1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                        body.emit(assign(r0BF1, add(r0BC0, body.constant(1u)), 0x01));

                        ir_expression *const r0BF2 = less(r0BF1, r0BC0);
                        ir_expression *const r0BF3 = expr(ir_unop_b2i, r0BF2);
                        ir_expression *const r0BF4 = expr(ir_unop_i2u, r0BF3);
                        body.emit(assign(r0BBF, add(r0BBF, r0BF4), 0x01));

                        ir_expression *const r0BF5 = equal(r0BC1, body.constant(0u));
                        ir_expression *const r0BF6 = expr(ir_unop_b2i, r0BF5);
                        ir_expression *const r0BF7 = expr(ir_unop_i2u, r0BF6);
                        ir_expression *const r0BF8 = add(r0BC1, r0BF7);
                        ir_expression *const r0BF9 = bit_and(r0BF8, body.constant(1u));
                        ir_expression *const r0BFA = expr(ir_unop_bit_not, r0BF9);
                        body.emit(assign(r0BC0, bit_and(r0BF1, r0BFA), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0BF0->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0BFC = bit_or(r0BBF, r0BC0);
                        ir_expression *const r0BFD = equal(r0BFC, body.constant(0u));
                        ir_if *f0BFB = new(mem_ctx) ir_if(operand(r0BFD).val);
                        exec_list *const f0BFB_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0BFB->then_instructions;

                           body.emit(assign(r0BBE, body.constant(int(0)), 0x01));


                        body.instructions = f0BFB_parent_instructions;
                        body.emit(f0BFB);

                        /* END IF */


                     body.instructions = f0BF0_parent_instructions;
                     body.emit(f0BF0);

                     /* END IF */

                     ir_variable *const r0BFE = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0BFE);
                     ir_expression *const r0BFF = lshift(r0994, body.constant(int(31)));
                     ir_expression *const r0C00 = expr(ir_unop_i2u, r0BBE);
                     ir_expression *const r0C01 = lshift(r0C00, body.constant(int(20)));
                     ir_expression *const r0C02 = add(r0BFF, r0C01);
                     body.emit(assign(r0BFE, add(r0C02, r0BBF), 0x02));

                     body.emit(assign(r0BFE, r0BC0, 0x01));

                     body.emit(assign(r0BC3, r0BFE, 0x03));

                     body.emit(assign(r0BC2, body.constant(false), 0x01));


                  body.instructions = f0BEF_parent_instructions;
                  body.emit(f0BEF);

                  /* END IF */

                  body.emit(assign(r0995, r0BC3, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0B77->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r0C04 = less(swizzle_y(r099A), swizzle_y(r0998));
                  ir_if *f0C03 = new(mem_ctx) ir_if(operand(r0C04).val);
                  exec_list *const f0C03_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0C03->then_instructions;

                     ir_variable *const r0C05 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                     ir_variable *const r0C06 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r0C06, sub(swizzle_x(r0998), swizzle_x(r099A)), 0x01));

                     ir_expression *const r0C07 = sub(swizzle_y(r0998), swizzle_y(r099A));
                     ir_expression *const r0C08 = less(swizzle_x(r0998), swizzle_x(r099A));
                     ir_expression *const r0C09 = expr(ir_unop_b2i, r0C08);
                     ir_expression *const r0C0A = expr(ir_unop_i2u, r0C09);
                     body.emit(assign(r0C05, sub(r0C07, r0C0A), 0x01));

                     body.emit(assign(r0994, bit_xor(r0994, body.constant(1u)), 0x01));

                     body.emit(assign(r099B, add(r0997, body.constant(int(-1))), 0x01));

                     ir_variable *const r0C0B = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r0C0B, add(r099B, body.constant(int(-10))), 0x01));

                     ir_variable *const r0C0C = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r0C0C, r0C05, 0x01));

                     ir_variable *const r0C0D = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r0C0D, r0C06, 0x01));

                     ir_variable *const r0C0E = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                     body.emit(r0C0E);
                     ir_variable *const r0C0F = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r0C0F);
                     /* IF CONDITION */
                     ir_expression *const r0C11 = equal(r0C05, body.constant(0u));
                     ir_if *f0C10 = new(mem_ctx) ir_if(operand(r0C11).val);
                     exec_list *const f0C10_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C10->then_instructions;

                        body.emit(assign(r0C0C, r0C06, 0x01));

                        body.emit(assign(r0C0D, body.constant(0u), 0x01));

                        body.emit(assign(r0C0B, add(r0C0B, body.constant(int(-32))), 0x01));


                     body.instructions = f0C10_parent_instructions;
                     body.emit(f0C10);

                     /* END IF */

                     ir_variable *const r0C12 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r0C12, r0C0C, 0x01));

                     ir_variable *const r0C13 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r0C14 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r0C14);
                     /* IF CONDITION */
                     ir_expression *const r0C16 = equal(r0C0C, body.constant(0u));
                     ir_if *f0C15 = new(mem_ctx) ir_if(operand(r0C16).val);
                     exec_list *const f0C15_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C15->then_instructions;

                        body.emit(assign(r0C13, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0C15->else_instructions;

                        body.emit(assign(r0C14, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0C18 = bit_and(r0C0C, body.constant(4294901760u));
                        ir_expression *const r0C19 = equal(r0C18, body.constant(0u));
                        ir_if *f0C17 = new(mem_ctx) ir_if(operand(r0C19).val);
                        exec_list *const f0C17_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C17->then_instructions;

                           body.emit(assign(r0C14, body.constant(int(16)), 0x01));

                           body.emit(assign(r0C12, lshift(r0C0C, body.constant(int(16))), 0x01));


                        body.instructions = f0C17_parent_instructions;
                        body.emit(f0C17);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0C1B = bit_and(r0C12, body.constant(4278190080u));
                        ir_expression *const r0C1C = equal(r0C1B, body.constant(0u));
                        ir_if *f0C1A = new(mem_ctx) ir_if(operand(r0C1C).val);
                        exec_list *const f0C1A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C1A->then_instructions;

                           body.emit(assign(r0C14, add(r0C14, body.constant(int(8))), 0x01));

                           body.emit(assign(r0C12, lshift(r0C12, body.constant(int(8))), 0x01));


                        body.instructions = f0C1A_parent_instructions;
                        body.emit(f0C1A);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0C1E = bit_and(r0C12, body.constant(4026531840u));
                        ir_expression *const r0C1F = equal(r0C1E, body.constant(0u));
                        ir_if *f0C1D = new(mem_ctx) ir_if(operand(r0C1F).val);
                        exec_list *const f0C1D_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C1D->then_instructions;

                           body.emit(assign(r0C14, add(r0C14, body.constant(int(4))), 0x01));

                           body.emit(assign(r0C12, lshift(r0C12, body.constant(int(4))), 0x01));


                        body.instructions = f0C1D_parent_instructions;
                        body.emit(f0C1D);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0C21 = bit_and(r0C12, body.constant(3221225472u));
                        ir_expression *const r0C22 = equal(r0C21, body.constant(0u));
                        ir_if *f0C20 = new(mem_ctx) ir_if(operand(r0C22).val);
                        exec_list *const f0C20_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C20->then_instructions;

                           body.emit(assign(r0C14, add(r0C14, body.constant(int(2))), 0x01));

                           body.emit(assign(r0C12, lshift(r0C12, body.constant(int(2))), 0x01));


                        body.instructions = f0C20_parent_instructions;
                        body.emit(f0C20);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0C24 = bit_and(r0C12, body.constant(2147483648u));
                        ir_expression *const r0C25 = equal(r0C24, body.constant(0u));
                        ir_if *f0C23 = new(mem_ctx) ir_if(operand(r0C25).val);
                        exec_list *const f0C23_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C23->then_instructions;

                           body.emit(assign(r0C14, add(r0C14, body.constant(int(1))), 0x01));


                        body.instructions = f0C23_parent_instructions;
                        body.emit(f0C23);

                        /* END IF */

                        body.emit(assign(r0C13, r0C14, 0x01));


                     body.instructions = f0C15_parent_instructions;
                     body.emit(f0C15);

                     /* END IF */

                     body.emit(assign(r0C0F, add(r0C13, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0C27 = lequal(body.constant(int(0)), r0C0F);
                     ir_if *f0C26 = new(mem_ctx) ir_if(operand(r0C27).val);
                     exec_list *const f0C26_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C26->then_instructions;

                        body.emit(assign(r0C0E, body.constant(0u), 0x01));

                        ir_variable *const r0C28 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r0C28, lshift(r0C0D, r0C0F), 0x01));

                        ir_variable *const r0C29 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0C2B = equal(r0C0F, body.constant(int(0)));
                        ir_if *f0C2A = new(mem_ctx) ir_if(operand(r0C2B).val);
                        exec_list *const f0C2A_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C2A->then_instructions;

                           body.emit(assign(r0C29, r0C0C, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C2A->else_instructions;

                           ir_expression *const r0C2C = lshift(r0C0C, r0C0F);
                           ir_expression *const r0C2D = neg(r0C0F);
                           ir_expression *const r0C2E = bit_and(r0C2D, body.constant(int(31)));
                           ir_expression *const r0C2F = rshift(r0C0D, r0C2E);
                           body.emit(assign(r0C29, bit_or(r0C2C, r0C2F), 0x01));


                        body.instructions = f0C2A_parent_instructions;
                        body.emit(f0C2A);

                        /* END IF */

                        body.emit(assign(r0C0C, r0C29, 0x01));

                        body.emit(assign(r0C0D, r0C28, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0C26->else_instructions;

                        ir_variable *const r0C30 = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0C30, body.constant(0u), 0x01));

                        ir_variable *const r0C31 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0C31, neg(r0C0F), 0x01));

                        ir_variable *const r0C32 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0C32);
                        ir_variable *const r0C33 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0C33);
                        ir_variable *const r0C34 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0C34);
                        ir_variable *const r0C35 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r0C36 = neg(r0C31);
                        body.emit(assign(r0C35, bit_and(r0C36, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0C38 = equal(r0C31, body.constant(int(0)));
                        ir_if *f0C37 = new(mem_ctx) ir_if(operand(r0C38).val);
                        exec_list *const f0C37_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C37->then_instructions;

                           body.emit(assign(r0C32, r0C30, 0x01));

                           body.emit(assign(r0C33, r0C0D, 0x01));

                           body.emit(assign(r0C34, r0C0C, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C37->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0C3A = less(r0C31, body.constant(int(32)));
                           ir_if *f0C39 = new(mem_ctx) ir_if(operand(r0C3A).val);
                           exec_list *const f0C39_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0C39->then_instructions;

                              body.emit(assign(r0C32, lshift(r0C0D, r0C35), 0x01));

                              ir_expression *const r0C3B = lshift(r0C0C, r0C35);
                              ir_expression *const r0C3C = rshift(r0C0D, r0C31);
                              body.emit(assign(r0C33, bit_or(r0C3B, r0C3C), 0x01));

                              body.emit(assign(r0C34, rshift(r0C0C, r0C31), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0C39->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0C3E = equal(r0C31, body.constant(int(32)));
                              ir_if *f0C3D = new(mem_ctx) ir_if(operand(r0C3E).val);
                              exec_list *const f0C3D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0C3D->then_instructions;

                                 body.emit(assign(r0C32, r0C0D, 0x01));

                                 body.emit(assign(r0C33, r0C0C, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0C3D->else_instructions;

                                 body.emit(assign(r0C30, bit_or(body.constant(0u), r0C0D), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0C40 = less(r0C31, body.constant(int(64)));
                                 ir_if *f0C3F = new(mem_ctx) ir_if(operand(r0C40).val);
                                 exec_list *const f0C3F_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0C3F->then_instructions;

                                    body.emit(assign(r0C32, lshift(r0C0C, r0C35), 0x01));

                                    ir_expression *const r0C41 = bit_and(r0C31, body.constant(int(31)));
                                    body.emit(assign(r0C33, rshift(r0C0C, r0C41), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0C3F->else_instructions;

                                    ir_variable *const r0C42 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r0C44 = equal(r0C31, body.constant(int(64)));
                                    ir_if *f0C43 = new(mem_ctx) ir_if(operand(r0C44).val);
                                    exec_list *const f0C43_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0C43->then_instructions;

                                       body.emit(assign(r0C42, r0C0C, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0C43->else_instructions;

                                       ir_expression *const r0C45 = nequal(r0C0C, body.constant(0u));
                                       ir_expression *const r0C46 = expr(ir_unop_b2i, r0C45);
                                       body.emit(assign(r0C42, expr(ir_unop_i2u, r0C46), 0x01));


                                    body.instructions = f0C43_parent_instructions;
                                    body.emit(f0C43);

                                    /* END IF */

                                    body.emit(assign(r0C32, r0C42, 0x01));

                                    body.emit(assign(r0C33, body.constant(0u), 0x01));


                                 body.instructions = f0C3F_parent_instructions;
                                 body.emit(f0C3F);

                                 /* END IF */


                              body.instructions = f0C3D_parent_instructions;
                              body.emit(f0C3D);

                              /* END IF */

                              body.emit(assign(r0C34, body.constant(0u), 0x01));


                           body.instructions = f0C39_parent_instructions;
                           body.emit(f0C39);

                           /* END IF */

                           ir_expression *const r0C47 = nequal(r0C30, body.constant(0u));
                           ir_expression *const r0C48 = expr(ir_unop_b2i, r0C47);
                           ir_expression *const r0C49 = expr(ir_unop_i2u, r0C48);
                           body.emit(assign(r0C32, bit_or(r0C32, r0C49), 0x01));


                        body.instructions = f0C37_parent_instructions;
                        body.emit(f0C37);

                        /* END IF */

                        body.emit(assign(r0C0C, r0C34, 0x01));

                        body.emit(assign(r0C0D, r0C33, 0x01));

                        body.emit(assign(r0C0E, r0C32, 0x01));


                     body.instructions = f0C26_parent_instructions;
                     body.emit(f0C26);

                     /* END IF */

                     body.emit(assign(r0C0B, sub(r0C0B, r0C0F), 0x01));

                     ir_variable *const r0C4A = body.make_temp(glsl_type::int_type, "zExp");
                     body.emit(assign(r0C4A, r0C0B, 0x01));

                     ir_variable *const r0C4B = body.make_temp(glsl_type::uint_type, "zFrac0");
                     body.emit(assign(r0C4B, r0C0C, 0x01));

                     ir_variable *const r0C4C = body.make_temp(glsl_type::uint_type, "zFrac1");
                     body.emit(assign(r0C4C, r0C0D, 0x01));

                     ir_variable *const r0C4D = body.make_temp(glsl_type::uint_type, "zFrac2");
                     body.emit(assign(r0C4D, r0C0E, 0x01));

                     ir_variable *const r0C4E = body.make_temp(glsl_type::bool_type, "execute_flag");
                     body.emit(assign(r0C4E, body.constant(true), 0x01));

                     ir_variable *const r0C4F = body.make_temp(glsl_type::uvec2_type, "return_value");
                     ir_variable *const r0C50 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                     body.emit(r0C50);
                     ir_expression *const r0C51 = expr(ir_unop_u2i, r0C0E);
                     body.emit(assign(r0C50, less(r0C51, body.constant(int(0))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0C53 = lequal(body.constant(int(2045)), r0C0B);
                     ir_if *f0C52 = new(mem_ctx) ir_if(operand(r0C53).val);
                     exec_list *const f0C52_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C52->then_instructions;

                        ir_variable *const r0C54 = body.make_temp(glsl_type::bool_type, "or_tmp");
                        /* IF CONDITION */
                        ir_expression *const r0C56 = less(body.constant(int(2045)), r0C0B);
                        ir_if *f0C55 = new(mem_ctx) ir_if(operand(r0C56).val);
                        exec_list *const f0C55_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C55->then_instructions;

                           body.emit(assign(r0C54, body.constant(true), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C55->else_instructions;

                           ir_variable *const r0C57 = body.make_temp(glsl_type::bool_type, "and_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0C59 = equal(r0C0B, body.constant(int(2045)));
                           ir_if *f0C58 = new(mem_ctx) ir_if(operand(r0C59).val);
                           exec_list *const f0C58_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0C58->then_instructions;

                              ir_expression *const r0C5A = equal(body.constant(2097151u), r0C0C);
                              ir_expression *const r0C5B = equal(body.constant(4294967295u), r0C0D);
                              body.emit(assign(r0C57, logic_and(r0C5A, r0C5B), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0C58->else_instructions;

                              body.emit(assign(r0C57, body.constant(false), 0x01));


                           body.instructions = f0C58_parent_instructions;
                           body.emit(f0C58);

                           /* END IF */

                           body.emit(assign(r0C54, logic_and(r0C57, r0C50), 0x01));


                        body.instructions = f0C55_parent_instructions;
                        body.emit(f0C55);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f0C5C = new(mem_ctx) ir_if(operand(r0C54).val);
                        exec_list *const f0C5C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C5C->then_instructions;

                           ir_variable *const r0C5D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r0C5D);
                           ir_expression *const r0C5E = lshift(r0994, body.constant(int(31)));
                           body.emit(assign(r0C5D, add(r0C5E, body.constant(2146435072u)), 0x02));

                           body.emit(assign(r0C5D, body.constant(0u), 0x01));

                           body.emit(assign(r0C4F, r0C5D, 0x03));

                           body.emit(assign(r0C4E, body.constant(false), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C5C->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0C60 = less(r0C0B, body.constant(int(0)));
                           ir_if *f0C5F = new(mem_ctx) ir_if(operand(r0C60).val);
                           exec_list *const f0C5F_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0C5F->then_instructions;

                              ir_variable *const r0C61 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r0C61, r0C0E, 0x01));

                              ir_variable *const r0C62 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r0C62, neg(r0C0B), 0x01));

                              ir_variable *const r0C63 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r0C63);
                              ir_variable *const r0C64 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r0C64);
                              ir_variable *const r0C65 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r0C65);
                              ir_variable *const r0C66 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r0C67 = neg(r0C62);
                              body.emit(assign(r0C66, bit_and(r0C67, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0C69 = equal(r0C62, body.constant(int(0)));
                              ir_if *f0C68 = new(mem_ctx) ir_if(operand(r0C69).val);
                              exec_list *const f0C68_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0C68->then_instructions;

                                 body.emit(assign(r0C63, r0C0E, 0x01));

                                 body.emit(assign(r0C64, r0C0D, 0x01));

                                 body.emit(assign(r0C65, r0C0C, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0C68->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0C6B = less(r0C62, body.constant(int(32)));
                                 ir_if *f0C6A = new(mem_ctx) ir_if(operand(r0C6B).val);
                                 exec_list *const f0C6A_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0C6A->then_instructions;

                                    body.emit(assign(r0C63, lshift(r0C0D, r0C66), 0x01));

                                    ir_expression *const r0C6C = lshift(r0C0C, r0C66);
                                    ir_expression *const r0C6D = rshift(r0C0D, r0C62);
                                    body.emit(assign(r0C64, bit_or(r0C6C, r0C6D), 0x01));

                                    body.emit(assign(r0C65, rshift(r0C0C, r0C62), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0C6A->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r0C6F = equal(r0C62, body.constant(int(32)));
                                    ir_if *f0C6E = new(mem_ctx) ir_if(operand(r0C6F).val);
                                    exec_list *const f0C6E_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0C6E->then_instructions;

                                       body.emit(assign(r0C63, r0C0D, 0x01));

                                       body.emit(assign(r0C64, r0C0C, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0C6E->else_instructions;

                                       body.emit(assign(r0C61, bit_or(r0C0E, r0C0D), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r0C71 = less(r0C62, body.constant(int(64)));
                                       ir_if *f0C70 = new(mem_ctx) ir_if(operand(r0C71).val);
                                       exec_list *const f0C70_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0C70->then_instructions;

                                          body.emit(assign(r0C63, lshift(r0C0C, r0C66), 0x01));

                                          ir_expression *const r0C72 = bit_and(r0C62, body.constant(int(31)));
                                          body.emit(assign(r0C64, rshift(r0C0C, r0C72), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0C70->else_instructions;

                                          ir_variable *const r0C73 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r0C75 = equal(r0C62, body.constant(int(64)));
                                          ir_if *f0C74 = new(mem_ctx) ir_if(operand(r0C75).val);
                                          exec_list *const f0C74_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0C74->then_instructions;

                                             body.emit(assign(r0C73, r0C0C, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0C74->else_instructions;

                                             ir_expression *const r0C76 = nequal(r0C0C, body.constant(0u));
                                             ir_expression *const r0C77 = expr(ir_unop_b2i, r0C76);
                                             body.emit(assign(r0C73, expr(ir_unop_i2u, r0C77), 0x01));


                                          body.instructions = f0C74_parent_instructions;
                                          body.emit(f0C74);

                                          /* END IF */

                                          body.emit(assign(r0C63, r0C73, 0x01));

                                          body.emit(assign(r0C64, body.constant(0u), 0x01));


                                       body.instructions = f0C70_parent_instructions;
                                       body.emit(f0C70);

                                       /* END IF */


                                    body.instructions = f0C6E_parent_instructions;
                                    body.emit(f0C6E);

                                    /* END IF */

                                    body.emit(assign(r0C65, body.constant(0u), 0x01));


                                 body.instructions = f0C6A_parent_instructions;
                                 body.emit(f0C6A);

                                 /* END IF */

                                 ir_expression *const r0C78 = nequal(r0C61, body.constant(0u));
                                 ir_expression *const r0C79 = expr(ir_unop_b2i, r0C78);
                                 ir_expression *const r0C7A = expr(ir_unop_i2u, r0C79);
                                 body.emit(assign(r0C63, bit_or(r0C63, r0C7A), 0x01));


                              body.instructions = f0C68_parent_instructions;
                              body.emit(f0C68);

                              /* END IF */

                              body.emit(assign(r0C4B, r0C65, 0x01));

                              body.emit(assign(r0C4C, r0C64, 0x01));

                              body.emit(assign(r0C4D, r0C63, 0x01));

                              body.emit(assign(r0C4A, body.constant(int(0)), 0x01));

                              body.emit(assign(r0C50, less(r0C63, body.constant(0u)), 0x01));


                           body.instructions = f0C5F_parent_instructions;
                           body.emit(f0C5F);

                           /* END IF */


                        body.instructions = f0C5C_parent_instructions;
                        body.emit(f0C5C);

                        /* END IF */


                     body.instructions = f0C52_parent_instructions;
                     body.emit(f0C52);

                     /* END IF */

                     /* IF CONDITION */
                     ir_if *f0C7B = new(mem_ctx) ir_if(operand(r0C4E).val);
                     exec_list *const f0C7B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C7B->then_instructions;

                        /* IF CONDITION */
                        ir_if *f0C7C = new(mem_ctx) ir_if(operand(r0C50).val);
                        exec_list *const f0C7C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C7C->then_instructions;

                           ir_variable *const r0C7D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                           body.emit(assign(r0C7D, add(r0C4C, body.constant(1u)), 0x01));

                           ir_expression *const r0C7E = less(r0C7D, r0C4C);
                           ir_expression *const r0C7F = expr(ir_unop_b2i, r0C7E);
                           ir_expression *const r0C80 = expr(ir_unop_i2u, r0C7F);
                           body.emit(assign(r0C4B, add(r0C4B, r0C80), 0x01));

                           ir_expression *const r0C81 = equal(r0C4D, body.constant(0u));
                           ir_expression *const r0C82 = expr(ir_unop_b2i, r0C81);
                           ir_expression *const r0C83 = expr(ir_unop_i2u, r0C82);
                           ir_expression *const r0C84 = add(r0C4D, r0C83);
                           ir_expression *const r0C85 = bit_and(r0C84, body.constant(1u));
                           ir_expression *const r0C86 = expr(ir_unop_bit_not, r0C85);
                           body.emit(assign(r0C4C, bit_and(r0C7D, r0C86), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0C7C->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0C88 = bit_or(r0C4B, r0C4C);
                           ir_expression *const r0C89 = equal(r0C88, body.constant(0u));
                           ir_if *f0C87 = new(mem_ctx) ir_if(operand(r0C89).val);
                           exec_list *const f0C87_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0C87->then_instructions;

                              body.emit(assign(r0C4A, body.constant(int(0)), 0x01));


                           body.instructions = f0C87_parent_instructions;
                           body.emit(f0C87);

                           /* END IF */


                        body.instructions = f0C7C_parent_instructions;
                        body.emit(f0C7C);

                        /* END IF */

                        ir_variable *const r0C8A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                        body.emit(r0C8A);
                        ir_expression *const r0C8B = lshift(r0994, body.constant(int(31)));
                        ir_expression *const r0C8C = expr(ir_unop_i2u, r0C4A);
                        ir_expression *const r0C8D = lshift(r0C8C, body.constant(int(20)));
                        ir_expression *const r0C8E = add(r0C8B, r0C8D);
                        body.emit(assign(r0C8A, add(r0C8E, r0C4B), 0x02));

                        body.emit(assign(r0C8A, r0C4C, 0x01));

                        body.emit(assign(r0C4F, r0C8A, 0x03));

                        body.emit(assign(r0C4E, body.constant(false), 0x01));


                     body.instructions = f0C7B_parent_instructions;
                     body.emit(f0C7B);

                     /* END IF */

                     body.emit(assign(r0995, r0C4F, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0C03->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0C90 = less(swizzle_x(r0998), swizzle_x(r099A));
                     ir_if *f0C8F = new(mem_ctx) ir_if(operand(r0C90).val);
                     exec_list *const f0C8F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0C8F->then_instructions;

                        ir_variable *const r0C91 = body.make_temp(glsl_type::uint_type, "z0Ptr");
                        ir_variable *const r0C92 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                        body.emit(assign(r0C92, sub(swizzle_x(r099A), swizzle_x(r0998)), 0x01));

                        ir_expression *const r0C93 = sub(swizzle_y(r099A), swizzle_y(r0998));
                        ir_expression *const r0C94 = less(swizzle_x(r099A), swizzle_x(r0998));
                        ir_expression *const r0C95 = expr(ir_unop_b2i, r0C94);
                        ir_expression *const r0C96 = expr(ir_unop_i2u, r0C95);
                        body.emit(assign(r0C91, sub(r0C93, r0C96), 0x01));

                        body.emit(assign(r099B, add(r0999, body.constant(int(-1))), 0x01));

                        ir_variable *const r0C97 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r0C97, add(r099B, body.constant(int(-10))), 0x01));

                        ir_variable *const r0C98 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r0C98, r0C91, 0x01));

                        ir_variable *const r0C99 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r0C99, r0C92, 0x01));

                        ir_variable *const r0C9A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                        body.emit(r0C9A);
                        ir_variable *const r0C9B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r0C9B);
                        /* IF CONDITION */
                        ir_expression *const r0C9D = equal(r0C91, body.constant(0u));
                        ir_if *f0C9C = new(mem_ctx) ir_if(operand(r0C9D).val);
                        exec_list *const f0C9C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0C9C->then_instructions;

                           body.emit(assign(r0C98, r0C92, 0x01));

                           body.emit(assign(r0C99, body.constant(0u), 0x01));

                           body.emit(assign(r0C97, add(r0C97, body.constant(int(-32))), 0x01));


                        body.instructions = f0C9C_parent_instructions;
                        body.emit(f0C9C);

                        /* END IF */

                        ir_variable *const r0C9E = body.make_temp(glsl_type::uint_type, "a");
                        body.emit(assign(r0C9E, r0C98, 0x01));

                        ir_variable *const r0C9F = body.make_temp(glsl_type::int_type, "return_value");
                        ir_variable *const r0CA0 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                        body.emit(r0CA0);
                        /* IF CONDITION */
                        ir_expression *const r0CA2 = equal(r0C98, body.constant(0u));
                        ir_if *f0CA1 = new(mem_ctx) ir_if(operand(r0CA2).val);
                        exec_list *const f0CA1_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0CA1->then_instructions;

                           body.emit(assign(r0C9F, body.constant(int(32)), 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0CA1->else_instructions;

                           body.emit(assign(r0CA0, body.constant(int(0)), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0CA4 = bit_and(r0C98, body.constant(4294901760u));
                           ir_expression *const r0CA5 = equal(r0CA4, body.constant(0u));
                           ir_if *f0CA3 = new(mem_ctx) ir_if(operand(r0CA5).val);
                           exec_list *const f0CA3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CA3->then_instructions;

                              body.emit(assign(r0CA0, body.constant(int(16)), 0x01));

                              body.emit(assign(r0C9E, lshift(r0C98, body.constant(int(16))), 0x01));


                           body.instructions = f0CA3_parent_instructions;
                           body.emit(f0CA3);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0CA7 = bit_and(r0C9E, body.constant(4278190080u));
                           ir_expression *const r0CA8 = equal(r0CA7, body.constant(0u));
                           ir_if *f0CA6 = new(mem_ctx) ir_if(operand(r0CA8).val);
                           exec_list *const f0CA6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CA6->then_instructions;

                              body.emit(assign(r0CA0, add(r0CA0, body.constant(int(8))), 0x01));

                              body.emit(assign(r0C9E, lshift(r0C9E, body.constant(int(8))), 0x01));


                           body.instructions = f0CA6_parent_instructions;
                           body.emit(f0CA6);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0CAA = bit_and(r0C9E, body.constant(4026531840u));
                           ir_expression *const r0CAB = equal(r0CAA, body.constant(0u));
                           ir_if *f0CA9 = new(mem_ctx) ir_if(operand(r0CAB).val);
                           exec_list *const f0CA9_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CA9->then_instructions;

                              body.emit(assign(r0CA0, add(r0CA0, body.constant(int(4))), 0x01));

                              body.emit(assign(r0C9E, lshift(r0C9E, body.constant(int(4))), 0x01));


                           body.instructions = f0CA9_parent_instructions;
                           body.emit(f0CA9);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0CAD = bit_and(r0C9E, body.constant(3221225472u));
                           ir_expression *const r0CAE = equal(r0CAD, body.constant(0u));
                           ir_if *f0CAC = new(mem_ctx) ir_if(operand(r0CAE).val);
                           exec_list *const f0CAC_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CAC->then_instructions;

                              body.emit(assign(r0CA0, add(r0CA0, body.constant(int(2))), 0x01));

                              body.emit(assign(r0C9E, lshift(r0C9E, body.constant(int(2))), 0x01));


                           body.instructions = f0CAC_parent_instructions;
                           body.emit(f0CAC);

                           /* END IF */

                           /* IF CONDITION */
                           ir_expression *const r0CB0 = bit_and(r0C9E, body.constant(2147483648u));
                           ir_expression *const r0CB1 = equal(r0CB0, body.constant(0u));
                           ir_if *f0CAF = new(mem_ctx) ir_if(operand(r0CB1).val);
                           exec_list *const f0CAF_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CAF->then_instructions;

                              body.emit(assign(r0CA0, add(r0CA0, body.constant(int(1))), 0x01));


                           body.instructions = f0CAF_parent_instructions;
                           body.emit(f0CAF);

                           /* END IF */

                           body.emit(assign(r0C9F, r0CA0, 0x01));


                        body.instructions = f0CA1_parent_instructions;
                        body.emit(f0CA1);

                        /* END IF */

                        body.emit(assign(r0C9B, add(r0C9F, body.constant(int(-11))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0CB3 = lequal(body.constant(int(0)), r0C9B);
                        ir_if *f0CB2 = new(mem_ctx) ir_if(operand(r0CB3).val);
                        exec_list *const f0CB2_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0CB2->then_instructions;

                           body.emit(assign(r0C9A, body.constant(0u), 0x01));

                           ir_variable *const r0CB4 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r0CB4, lshift(r0C99, r0C9B), 0x01));

                           ir_variable *const r0CB5 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0CB7 = equal(r0C9B, body.constant(int(0)));
                           ir_if *f0CB6 = new(mem_ctx) ir_if(operand(r0CB7).val);
                           exec_list *const f0CB6_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CB6->then_instructions;

                              body.emit(assign(r0CB5, r0C98, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0CB6->else_instructions;

                              ir_expression *const r0CB8 = lshift(r0C98, r0C9B);
                              ir_expression *const r0CB9 = neg(r0C9B);
                              ir_expression *const r0CBA = bit_and(r0CB9, body.constant(int(31)));
                              ir_expression *const r0CBB = rshift(r0C99, r0CBA);
                              body.emit(assign(r0CB5, bit_or(r0CB8, r0CBB), 0x01));


                           body.instructions = f0CB6_parent_instructions;
                           body.emit(f0CB6);

                           /* END IF */

                           body.emit(assign(r0C98, r0CB5, 0x01));

                           body.emit(assign(r0C99, r0CB4, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0CB2->else_instructions;

                           ir_variable *const r0CBC = body.make_temp(glsl_type::uint_type, "a2");
                           body.emit(assign(r0CBC, body.constant(0u), 0x01));

                           ir_variable *const r0CBD = body.make_temp(glsl_type::int_type, "count");
                           body.emit(assign(r0CBD, neg(r0C9B), 0x01));

                           ir_variable *const r0CBE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                           body.emit(r0CBE);
                           ir_variable *const r0CBF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                           body.emit(r0CBF);
                           ir_variable *const r0CC0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                           body.emit(r0CC0);
                           ir_variable *const r0CC1 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                           ir_expression *const r0CC2 = neg(r0CBD);
                           body.emit(assign(r0CC1, bit_and(r0CC2, body.constant(int(31))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0CC4 = equal(r0CBD, body.constant(int(0)));
                           ir_if *f0CC3 = new(mem_ctx) ir_if(operand(r0CC4).val);
                           exec_list *const f0CC3_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CC3->then_instructions;

                              body.emit(assign(r0CBE, r0CBC, 0x01));

                              body.emit(assign(r0CBF, r0C99, 0x01));

                              body.emit(assign(r0CC0, r0C98, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0CC3->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0CC6 = less(r0CBD, body.constant(int(32)));
                              ir_if *f0CC5 = new(mem_ctx) ir_if(operand(r0CC6).val);
                              exec_list *const f0CC5_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0CC5->then_instructions;

                                 body.emit(assign(r0CBE, lshift(r0C99, r0CC1), 0x01));

                                 ir_expression *const r0CC7 = lshift(r0C98, r0CC1);
                                 ir_expression *const r0CC8 = rshift(r0C99, r0CBD);
                                 body.emit(assign(r0CBF, bit_or(r0CC7, r0CC8), 0x01));

                                 body.emit(assign(r0CC0, rshift(r0C98, r0CBD), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0CC5->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0CCA = equal(r0CBD, body.constant(int(32)));
                                 ir_if *f0CC9 = new(mem_ctx) ir_if(operand(r0CCA).val);
                                 exec_list *const f0CC9_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0CC9->then_instructions;

                                    body.emit(assign(r0CBE, r0C99, 0x01));

                                    body.emit(assign(r0CBF, r0C98, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0CC9->else_instructions;

                                    body.emit(assign(r0CBC, bit_or(body.constant(0u), r0C99), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r0CCC = less(r0CBD, body.constant(int(64)));
                                    ir_if *f0CCB = new(mem_ctx) ir_if(operand(r0CCC).val);
                                    exec_list *const f0CCB_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0CCB->then_instructions;

                                       body.emit(assign(r0CBE, lshift(r0C98, r0CC1), 0x01));

                                       ir_expression *const r0CCD = bit_and(r0CBD, body.constant(int(31)));
                                       body.emit(assign(r0CBF, rshift(r0C98, r0CCD), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0CCB->else_instructions;

                                       ir_variable *const r0CCE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                       /* IF CONDITION */
                                       ir_expression *const r0CD0 = equal(r0CBD, body.constant(int(64)));
                                       ir_if *f0CCF = new(mem_ctx) ir_if(operand(r0CD0).val);
                                       exec_list *const f0CCF_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0CCF->then_instructions;

                                          body.emit(assign(r0CCE, r0C98, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0CCF->else_instructions;

                                          ir_expression *const r0CD1 = nequal(r0C98, body.constant(0u));
                                          ir_expression *const r0CD2 = expr(ir_unop_b2i, r0CD1);
                                          body.emit(assign(r0CCE, expr(ir_unop_i2u, r0CD2), 0x01));


                                       body.instructions = f0CCF_parent_instructions;
                                       body.emit(f0CCF);

                                       /* END IF */

                                       body.emit(assign(r0CBE, r0CCE, 0x01));

                                       body.emit(assign(r0CBF, body.constant(0u), 0x01));


                                    body.instructions = f0CCB_parent_instructions;
                                    body.emit(f0CCB);

                                    /* END IF */


                                 body.instructions = f0CC9_parent_instructions;
                                 body.emit(f0CC9);

                                 /* END IF */

                                 body.emit(assign(r0CC0, body.constant(0u), 0x01));


                              body.instructions = f0CC5_parent_instructions;
                              body.emit(f0CC5);

                              /* END IF */

                              ir_expression *const r0CD3 = nequal(r0CBC, body.constant(0u));
                              ir_expression *const r0CD4 = expr(ir_unop_b2i, r0CD3);
                              ir_expression *const r0CD5 = expr(ir_unop_i2u, r0CD4);
                              body.emit(assign(r0CBE, bit_or(r0CBE, r0CD5), 0x01));


                           body.instructions = f0CC3_parent_instructions;
                           body.emit(f0CC3);

                           /* END IF */

                           body.emit(assign(r0C98, r0CC0, 0x01));

                           body.emit(assign(r0C99, r0CBF, 0x01));

                           body.emit(assign(r0C9A, r0CBE, 0x01));


                        body.instructions = f0CB2_parent_instructions;
                        body.emit(f0CB2);

                        /* END IF */

                        body.emit(assign(r0C97, sub(r0C97, r0C9B), 0x01));

                        ir_variable *const r0CD6 = body.make_temp(glsl_type::int_type, "zExp");
                        body.emit(assign(r0CD6, r0C97, 0x01));

                        ir_variable *const r0CD7 = body.make_temp(glsl_type::uint_type, "zFrac0");
                        body.emit(assign(r0CD7, r0C98, 0x01));

                        ir_variable *const r0CD8 = body.make_temp(glsl_type::uint_type, "zFrac1");
                        body.emit(assign(r0CD8, r0C99, 0x01));

                        ir_variable *const r0CD9 = body.make_temp(glsl_type::uint_type, "zFrac2");
                        body.emit(assign(r0CD9, r0C9A, 0x01));

                        ir_variable *const r0CDA = body.make_temp(glsl_type::bool_type, "execute_flag");
                        body.emit(assign(r0CDA, body.constant(true), 0x01));

                        ir_variable *const r0CDB = body.make_temp(glsl_type::uvec2_type, "return_value");
                        ir_variable *const r0CDC = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                        body.emit(r0CDC);
                        ir_expression *const r0CDD = expr(ir_unop_u2i, r0C9A);
                        body.emit(assign(r0CDC, less(r0CDD, body.constant(int(0))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0CDF = lequal(body.constant(int(2045)), r0C97);
                        ir_if *f0CDE = new(mem_ctx) ir_if(operand(r0CDF).val);
                        exec_list *const f0CDE_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0CDE->then_instructions;

                           ir_variable *const r0CE0 = body.make_temp(glsl_type::bool_type, "or_tmp");
                           /* IF CONDITION */
                           ir_expression *const r0CE2 = less(body.constant(int(2045)), r0C97);
                           ir_if *f0CE1 = new(mem_ctx) ir_if(operand(r0CE2).val);
                           exec_list *const f0CE1_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CE1->then_instructions;

                              body.emit(assign(r0CE0, body.constant(true), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0CE1->else_instructions;

                              ir_variable *const r0CE3 = body.make_temp(glsl_type::bool_type, "and_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0CE5 = equal(r0C97, body.constant(int(2045)));
                              ir_if *f0CE4 = new(mem_ctx) ir_if(operand(r0CE5).val);
                              exec_list *const f0CE4_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0CE4->then_instructions;

                                 ir_expression *const r0CE6 = equal(body.constant(2097151u), r0C98);
                                 ir_expression *const r0CE7 = equal(body.constant(4294967295u), r0C99);
                                 body.emit(assign(r0CE3, logic_and(r0CE6, r0CE7), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0CE4->else_instructions;

                                 body.emit(assign(r0CE3, body.constant(false), 0x01));


                              body.instructions = f0CE4_parent_instructions;
                              body.emit(f0CE4);

                              /* END IF */

                              body.emit(assign(r0CE0, logic_and(r0CE3, r0CDC), 0x01));


                           body.instructions = f0CE1_parent_instructions;
                           body.emit(f0CE1);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f0CE8 = new(mem_ctx) ir_if(operand(r0CE0).val);
                           exec_list *const f0CE8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0CE8->then_instructions;

                              ir_variable *const r0CE9 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r0CE9);
                              ir_expression *const r0CEA = lshift(r0994, body.constant(int(31)));
                              body.emit(assign(r0CE9, add(r0CEA, body.constant(2146435072u)), 0x02));

                              body.emit(assign(r0CE9, body.constant(0u), 0x01));

                              body.emit(assign(r0CDB, r0CE9, 0x03));

                              body.emit(assign(r0CDA, body.constant(false), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0CE8->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0CEC = less(r0C97, body.constant(int(0)));
                              ir_if *f0CEB = new(mem_ctx) ir_if(operand(r0CEC).val);
                              exec_list *const f0CEB_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0CEB->then_instructions;

                                 ir_variable *const r0CED = body.make_temp(glsl_type::uint_type, "a2");
                                 body.emit(assign(r0CED, r0C9A, 0x01));

                                 ir_variable *const r0CEE = body.make_temp(glsl_type::int_type, "count");
                                 body.emit(assign(r0CEE, neg(r0C97), 0x01));

                                 ir_variable *const r0CEF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                 body.emit(r0CEF);
                                 ir_variable *const r0CF0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                 body.emit(r0CF0);
                                 ir_variable *const r0CF1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                 body.emit(r0CF1);
                                 ir_variable *const r0CF2 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                 ir_expression *const r0CF3 = neg(r0CEE);
                                 body.emit(assign(r0CF2, bit_and(r0CF3, body.constant(int(31))), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0CF5 = equal(r0CEE, body.constant(int(0)));
                                 ir_if *f0CF4 = new(mem_ctx) ir_if(operand(r0CF5).val);
                                 exec_list *const f0CF4_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0CF4->then_instructions;

                                    body.emit(assign(r0CEF, r0C9A, 0x01));

                                    body.emit(assign(r0CF0, r0C99, 0x01));

                                    body.emit(assign(r0CF1, r0C98, 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0CF4->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r0CF7 = less(r0CEE, body.constant(int(32)));
                                    ir_if *f0CF6 = new(mem_ctx) ir_if(operand(r0CF7).val);
                                    exec_list *const f0CF6_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0CF6->then_instructions;

                                       body.emit(assign(r0CEF, lshift(r0C99, r0CF2), 0x01));

                                       ir_expression *const r0CF8 = lshift(r0C98, r0CF2);
                                       ir_expression *const r0CF9 = rshift(r0C99, r0CEE);
                                       body.emit(assign(r0CF0, bit_or(r0CF8, r0CF9), 0x01));

                                       body.emit(assign(r0CF1, rshift(r0C98, r0CEE), 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0CF6->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r0CFB = equal(r0CEE, body.constant(int(32)));
                                       ir_if *f0CFA = new(mem_ctx) ir_if(operand(r0CFB).val);
                                       exec_list *const f0CFA_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0CFA->then_instructions;

                                          body.emit(assign(r0CEF, r0C99, 0x01));

                                          body.emit(assign(r0CF0, r0C98, 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0CFA->else_instructions;

                                          body.emit(assign(r0CED, bit_or(r0C9A, r0C99), 0x01));

                                          /* IF CONDITION */
                                          ir_expression *const r0CFD = less(r0CEE, body.constant(int(64)));
                                          ir_if *f0CFC = new(mem_ctx) ir_if(operand(r0CFD).val);
                                          exec_list *const f0CFC_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0CFC->then_instructions;

                                             body.emit(assign(r0CEF, lshift(r0C98, r0CF2), 0x01));

                                             ir_expression *const r0CFE = bit_and(r0CEE, body.constant(int(31)));
                                             body.emit(assign(r0CF0, rshift(r0C98, r0CFE), 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0CFC->else_instructions;

                                             ir_variable *const r0CFF = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                             /* IF CONDITION */
                                             ir_expression *const r0D01 = equal(r0CEE, body.constant(int(64)));
                                             ir_if *f0D00 = new(mem_ctx) ir_if(operand(r0D01).val);
                                             exec_list *const f0D00_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f0D00->then_instructions;

                                                body.emit(assign(r0CFF, r0C98, 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f0D00->else_instructions;

                                                ir_expression *const r0D02 = nequal(r0C98, body.constant(0u));
                                                ir_expression *const r0D03 = expr(ir_unop_b2i, r0D02);
                                                body.emit(assign(r0CFF, expr(ir_unop_i2u, r0D03), 0x01));


                                             body.instructions = f0D00_parent_instructions;
                                             body.emit(f0D00);

                                             /* END IF */

                                             body.emit(assign(r0CEF, r0CFF, 0x01));

                                             body.emit(assign(r0CF0, body.constant(0u), 0x01));


                                          body.instructions = f0CFC_parent_instructions;
                                          body.emit(f0CFC);

                                          /* END IF */


                                       body.instructions = f0CFA_parent_instructions;
                                       body.emit(f0CFA);

                                       /* END IF */

                                       body.emit(assign(r0CF1, body.constant(0u), 0x01));


                                    body.instructions = f0CF6_parent_instructions;
                                    body.emit(f0CF6);

                                    /* END IF */

                                    ir_expression *const r0D04 = nequal(r0CED, body.constant(0u));
                                    ir_expression *const r0D05 = expr(ir_unop_b2i, r0D04);
                                    ir_expression *const r0D06 = expr(ir_unop_i2u, r0D05);
                                    body.emit(assign(r0CEF, bit_or(r0CEF, r0D06), 0x01));


                                 body.instructions = f0CF4_parent_instructions;
                                 body.emit(f0CF4);

                                 /* END IF */

                                 body.emit(assign(r0CD7, r0CF1, 0x01));

                                 body.emit(assign(r0CD8, r0CF0, 0x01));

                                 body.emit(assign(r0CD9, r0CEF, 0x01));

                                 body.emit(assign(r0CD6, body.constant(int(0)), 0x01));

                                 body.emit(assign(r0CDC, less(r0CEF, body.constant(0u)), 0x01));


                              body.instructions = f0CEB_parent_instructions;
                              body.emit(f0CEB);

                              /* END IF */


                           body.instructions = f0CE8_parent_instructions;
                           body.emit(f0CE8);

                           /* END IF */


                        body.instructions = f0CDE_parent_instructions;
                        body.emit(f0CDE);

                        /* END IF */

                        /* IF CONDITION */
                        ir_if *f0D07 = new(mem_ctx) ir_if(operand(r0CDA).val);
                        exec_list *const f0D07_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0D07->then_instructions;

                           /* IF CONDITION */
                           ir_if *f0D08 = new(mem_ctx) ir_if(operand(r0CDC).val);
                           exec_list *const f0D08_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D08->then_instructions;

                              ir_variable *const r0D09 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                              body.emit(assign(r0D09, add(r0CD8, body.constant(1u)), 0x01));

                              ir_expression *const r0D0A = less(r0D09, r0CD8);
                              ir_expression *const r0D0B = expr(ir_unop_b2i, r0D0A);
                              ir_expression *const r0D0C = expr(ir_unop_i2u, r0D0B);
                              body.emit(assign(r0CD7, add(r0CD7, r0D0C), 0x01));

                              ir_expression *const r0D0D = equal(r0CD9, body.constant(0u));
                              ir_expression *const r0D0E = expr(ir_unop_b2i, r0D0D);
                              ir_expression *const r0D0F = expr(ir_unop_i2u, r0D0E);
                              ir_expression *const r0D10 = add(r0CD9, r0D0F);
                              ir_expression *const r0D11 = bit_and(r0D10, body.constant(1u));
                              ir_expression *const r0D12 = expr(ir_unop_bit_not, r0D11);
                              body.emit(assign(r0CD8, bit_and(r0D09, r0D12), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0D08->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0D14 = bit_or(r0CD7, r0CD8);
                              ir_expression *const r0D15 = equal(r0D14, body.constant(0u));
                              ir_if *f0D13 = new(mem_ctx) ir_if(operand(r0D15).val);
                              exec_list *const f0D13_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D13->then_instructions;

                                 body.emit(assign(r0CD6, body.constant(int(0)), 0x01));


                              body.instructions = f0D13_parent_instructions;
                              body.emit(f0D13);

                              /* END IF */


                           body.instructions = f0D08_parent_instructions;
                           body.emit(f0D08);

                           /* END IF */

                           ir_variable *const r0D16 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r0D16);
                           ir_expression *const r0D17 = lshift(r0994, body.constant(int(31)));
                           ir_expression *const r0D18 = expr(ir_unop_i2u, r0CD6);
                           ir_expression *const r0D19 = lshift(r0D18, body.constant(int(20)));
                           ir_expression *const r0D1A = add(r0D17, r0D19);
                           body.emit(assign(r0D16, add(r0D1A, r0CD7), 0x02));

                           body.emit(assign(r0D16, r0CD8, 0x01));

                           body.emit(assign(r0CDB, r0D16, 0x03));

                           body.emit(assign(r0CDA, body.constant(false), 0x01));


                        body.instructions = f0D07_parent_instructions;
                        body.emit(f0D07);

                        /* END IF */

                        body.emit(assign(r0995, r0CDB, 0x03));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0C8F->else_instructions;

                        /* IF CONDITION */
                        ir_expression *const r0D1C = less(swizzle_x(r099A), swizzle_x(r0998));
                        ir_if *f0D1B = new(mem_ctx) ir_if(operand(r0D1C).val);
                        exec_list *const f0D1B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0D1B->then_instructions;

                           ir_variable *const r0D1D = body.make_temp(glsl_type::uint_type, "z0Ptr");
                           ir_variable *const r0D1E = body.make_temp(glsl_type::uint_type, "z1Ptr");
                           body.emit(assign(r0D1E, sub(swizzle_x(r0998), swizzle_x(r099A)), 0x01));

                           ir_expression *const r0D1F = sub(swizzle_y(r0998), swizzle_y(r099A));
                           ir_expression *const r0D20 = less(swizzle_x(r0998), swizzle_x(r099A));
                           ir_expression *const r0D21 = expr(ir_unop_b2i, r0D20);
                           ir_expression *const r0D22 = expr(ir_unop_i2u, r0D21);
                           body.emit(assign(r0D1D, sub(r0D1F, r0D22), 0x01));

                           body.emit(assign(r0994, bit_xor(r0994, body.constant(1u)), 0x01));

                           body.emit(assign(r099B, add(r0997, body.constant(int(-1))), 0x01));

                           ir_variable *const r0D23 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r0D23, add(r099B, body.constant(int(-10))), 0x01));

                           ir_variable *const r0D24 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r0D24, r0D1D, 0x01));

                           ir_variable *const r0D25 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r0D25, r0D1E, 0x01));

                           ir_variable *const r0D26 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
                           body.emit(r0D26);
                           ir_variable *const r0D27 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r0D27);
                           /* IF CONDITION */
                           ir_expression *const r0D29 = equal(r0D1D, body.constant(0u));
                           ir_if *f0D28 = new(mem_ctx) ir_if(operand(r0D29).val);
                           exec_list *const f0D28_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D28->then_instructions;

                              body.emit(assign(r0D24, r0D1E, 0x01));

                              body.emit(assign(r0D25, body.constant(0u), 0x01));

                              body.emit(assign(r0D23, add(r0D23, body.constant(int(-32))), 0x01));


                           body.instructions = f0D28_parent_instructions;
                           body.emit(f0D28);

                           /* END IF */

                           ir_variable *const r0D2A = body.make_temp(glsl_type::uint_type, "a");
                           body.emit(assign(r0D2A, r0D24, 0x01));

                           ir_variable *const r0D2B = body.make_temp(glsl_type::int_type, "return_value");
                           ir_variable *const r0D2C = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                           body.emit(r0D2C);
                           /* IF CONDITION */
                           ir_expression *const r0D2E = equal(r0D24, body.constant(0u));
                           ir_if *f0D2D = new(mem_ctx) ir_if(operand(r0D2E).val);
                           exec_list *const f0D2D_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D2D->then_instructions;

                              body.emit(assign(r0D2B, body.constant(int(32)), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0D2D->else_instructions;

                              body.emit(assign(r0D2C, body.constant(int(0)), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0D30 = bit_and(r0D24, body.constant(4294901760u));
                              ir_expression *const r0D31 = equal(r0D30, body.constant(0u));
                              ir_if *f0D2F = new(mem_ctx) ir_if(operand(r0D31).val);
                              exec_list *const f0D2F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D2F->then_instructions;

                                 body.emit(assign(r0D2C, body.constant(int(16)), 0x01));

                                 body.emit(assign(r0D2A, lshift(r0D24, body.constant(int(16))), 0x01));


                              body.instructions = f0D2F_parent_instructions;
                              body.emit(f0D2F);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r0D33 = bit_and(r0D2A, body.constant(4278190080u));
                              ir_expression *const r0D34 = equal(r0D33, body.constant(0u));
                              ir_if *f0D32 = new(mem_ctx) ir_if(operand(r0D34).val);
                              exec_list *const f0D32_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D32->then_instructions;

                                 body.emit(assign(r0D2C, add(r0D2C, body.constant(int(8))), 0x01));

                                 body.emit(assign(r0D2A, lshift(r0D2A, body.constant(int(8))), 0x01));


                              body.instructions = f0D32_parent_instructions;
                              body.emit(f0D32);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r0D36 = bit_and(r0D2A, body.constant(4026531840u));
                              ir_expression *const r0D37 = equal(r0D36, body.constant(0u));
                              ir_if *f0D35 = new(mem_ctx) ir_if(operand(r0D37).val);
                              exec_list *const f0D35_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D35->then_instructions;

                                 body.emit(assign(r0D2C, add(r0D2C, body.constant(int(4))), 0x01));

                                 body.emit(assign(r0D2A, lshift(r0D2A, body.constant(int(4))), 0x01));


                              body.instructions = f0D35_parent_instructions;
                              body.emit(f0D35);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r0D39 = bit_and(r0D2A, body.constant(3221225472u));
                              ir_expression *const r0D3A = equal(r0D39, body.constant(0u));
                              ir_if *f0D38 = new(mem_ctx) ir_if(operand(r0D3A).val);
                              exec_list *const f0D38_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D38->then_instructions;

                                 body.emit(assign(r0D2C, add(r0D2C, body.constant(int(2))), 0x01));

                                 body.emit(assign(r0D2A, lshift(r0D2A, body.constant(int(2))), 0x01));


                              body.instructions = f0D38_parent_instructions;
                              body.emit(f0D38);

                              /* END IF */

                              /* IF CONDITION */
                              ir_expression *const r0D3C = bit_and(r0D2A, body.constant(2147483648u));
                              ir_expression *const r0D3D = equal(r0D3C, body.constant(0u));
                              ir_if *f0D3B = new(mem_ctx) ir_if(operand(r0D3D).val);
                              exec_list *const f0D3B_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D3B->then_instructions;

                                 body.emit(assign(r0D2C, add(r0D2C, body.constant(int(1))), 0x01));


                              body.instructions = f0D3B_parent_instructions;
                              body.emit(f0D3B);

                              /* END IF */

                              body.emit(assign(r0D2B, r0D2C, 0x01));


                           body.instructions = f0D2D_parent_instructions;
                           body.emit(f0D2D);

                           /* END IF */

                           body.emit(assign(r0D27, add(r0D2B, body.constant(int(-11))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0D3F = lequal(body.constant(int(0)), r0D27);
                           ir_if *f0D3E = new(mem_ctx) ir_if(operand(r0D3F).val);
                           exec_list *const f0D3E_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D3E->then_instructions;

                              body.emit(assign(r0D26, body.constant(0u), 0x01));

                              ir_variable *const r0D40 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                              body.emit(assign(r0D40, lshift(r0D25, r0D27), 0x01));

                              ir_variable *const r0D41 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0D43 = equal(r0D27, body.constant(int(0)));
                              ir_if *f0D42 = new(mem_ctx) ir_if(operand(r0D43).val);
                              exec_list *const f0D42_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D42->then_instructions;

                                 body.emit(assign(r0D41, r0D24, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D42->else_instructions;

                                 ir_expression *const r0D44 = lshift(r0D24, r0D27);
                                 ir_expression *const r0D45 = neg(r0D27);
                                 ir_expression *const r0D46 = bit_and(r0D45, body.constant(int(31)));
                                 ir_expression *const r0D47 = rshift(r0D25, r0D46);
                                 body.emit(assign(r0D41, bit_or(r0D44, r0D47), 0x01));


                              body.instructions = f0D42_parent_instructions;
                              body.emit(f0D42);

                              /* END IF */

                              body.emit(assign(r0D24, r0D41, 0x01));

                              body.emit(assign(r0D25, r0D40, 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0D3E->else_instructions;

                              ir_variable *const r0D48 = body.make_temp(glsl_type::uint_type, "a2");
                              body.emit(assign(r0D48, body.constant(0u), 0x01));

                              ir_variable *const r0D49 = body.make_temp(glsl_type::int_type, "count");
                              body.emit(assign(r0D49, neg(r0D27), 0x01));

                              ir_variable *const r0D4A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                              body.emit(r0D4A);
                              ir_variable *const r0D4B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                              body.emit(r0D4B);
                              ir_variable *const r0D4C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                              body.emit(r0D4C);
                              ir_variable *const r0D4D = body.make_temp(glsl_type::int_type, "assignment_tmp");
                              ir_expression *const r0D4E = neg(r0D49);
                              body.emit(assign(r0D4D, bit_and(r0D4E, body.constant(int(31))), 0x01));

                              /* IF CONDITION */
                              ir_expression *const r0D50 = equal(r0D49, body.constant(int(0)));
                              ir_if *f0D4F = new(mem_ctx) ir_if(operand(r0D50).val);
                              exec_list *const f0D4F_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D4F->then_instructions;

                                 body.emit(assign(r0D4A, r0D48, 0x01));

                                 body.emit(assign(r0D4B, r0D25, 0x01));

                                 body.emit(assign(r0D4C, r0D24, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D4F->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0D52 = less(r0D49, body.constant(int(32)));
                                 ir_if *f0D51 = new(mem_ctx) ir_if(operand(r0D52).val);
                                 exec_list *const f0D51_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0D51->then_instructions;

                                    body.emit(assign(r0D4A, lshift(r0D25, r0D4D), 0x01));

                                    ir_expression *const r0D53 = lshift(r0D24, r0D4D);
                                    ir_expression *const r0D54 = rshift(r0D25, r0D49);
                                    body.emit(assign(r0D4B, bit_or(r0D53, r0D54), 0x01));

                                    body.emit(assign(r0D4C, rshift(r0D24, r0D49), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0D51->else_instructions;

                                    /* IF CONDITION */
                                    ir_expression *const r0D56 = equal(r0D49, body.constant(int(32)));
                                    ir_if *f0D55 = new(mem_ctx) ir_if(operand(r0D56).val);
                                    exec_list *const f0D55_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0D55->then_instructions;

                                       body.emit(assign(r0D4A, r0D25, 0x01));

                                       body.emit(assign(r0D4B, r0D24, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0D55->else_instructions;

                                       body.emit(assign(r0D48, bit_or(body.constant(0u), r0D25), 0x01));

                                       /* IF CONDITION */
                                       ir_expression *const r0D58 = less(r0D49, body.constant(int(64)));
                                       ir_if *f0D57 = new(mem_ctx) ir_if(operand(r0D58).val);
                                       exec_list *const f0D57_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0D57->then_instructions;

                                          body.emit(assign(r0D4A, lshift(r0D24, r0D4D), 0x01));

                                          ir_expression *const r0D59 = bit_and(r0D49, body.constant(int(31)));
                                          body.emit(assign(r0D4B, rshift(r0D24, r0D59), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0D57->else_instructions;

                                          ir_variable *const r0D5A = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                          /* IF CONDITION */
                                          ir_expression *const r0D5C = equal(r0D49, body.constant(int(64)));
                                          ir_if *f0D5B = new(mem_ctx) ir_if(operand(r0D5C).val);
                                          exec_list *const f0D5B_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0D5B->then_instructions;

                                             body.emit(assign(r0D5A, r0D24, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0D5B->else_instructions;

                                             ir_expression *const r0D5D = nequal(r0D24, body.constant(0u));
                                             ir_expression *const r0D5E = expr(ir_unop_b2i, r0D5D);
                                             body.emit(assign(r0D5A, expr(ir_unop_i2u, r0D5E), 0x01));


                                          body.instructions = f0D5B_parent_instructions;
                                          body.emit(f0D5B);

                                          /* END IF */

                                          body.emit(assign(r0D4A, r0D5A, 0x01));

                                          body.emit(assign(r0D4B, body.constant(0u), 0x01));


                                       body.instructions = f0D57_parent_instructions;
                                       body.emit(f0D57);

                                       /* END IF */


                                    body.instructions = f0D55_parent_instructions;
                                    body.emit(f0D55);

                                    /* END IF */

                                    body.emit(assign(r0D4C, body.constant(0u), 0x01));


                                 body.instructions = f0D51_parent_instructions;
                                 body.emit(f0D51);

                                 /* END IF */

                                 ir_expression *const r0D5F = nequal(r0D48, body.constant(0u));
                                 ir_expression *const r0D60 = expr(ir_unop_b2i, r0D5F);
                                 ir_expression *const r0D61 = expr(ir_unop_i2u, r0D60);
                                 body.emit(assign(r0D4A, bit_or(r0D4A, r0D61), 0x01));


                              body.instructions = f0D4F_parent_instructions;
                              body.emit(f0D4F);

                              /* END IF */

                              body.emit(assign(r0D24, r0D4C, 0x01));

                              body.emit(assign(r0D25, r0D4B, 0x01));

                              body.emit(assign(r0D26, r0D4A, 0x01));


                           body.instructions = f0D3E_parent_instructions;
                           body.emit(f0D3E);

                           /* END IF */

                           body.emit(assign(r0D23, sub(r0D23, r0D27), 0x01));

                           ir_variable *const r0D62 = body.make_temp(glsl_type::int_type, "zExp");
                           body.emit(assign(r0D62, r0D23, 0x01));

                           ir_variable *const r0D63 = body.make_temp(glsl_type::uint_type, "zFrac0");
                           body.emit(assign(r0D63, r0D24, 0x01));

                           ir_variable *const r0D64 = body.make_temp(glsl_type::uint_type, "zFrac1");
                           body.emit(assign(r0D64, r0D25, 0x01));

                           ir_variable *const r0D65 = body.make_temp(glsl_type::uint_type, "zFrac2");
                           body.emit(assign(r0D65, r0D26, 0x01));

                           ir_variable *const r0D66 = body.make_temp(glsl_type::bool_type, "execute_flag");
                           body.emit(assign(r0D66, body.constant(true), 0x01));

                           ir_variable *const r0D67 = body.make_temp(glsl_type::uvec2_type, "return_value");
                           ir_variable *const r0D68 = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
                           body.emit(r0D68);
                           ir_expression *const r0D69 = expr(ir_unop_u2i, r0D26);
                           body.emit(assign(r0D68, less(r0D69, body.constant(int(0))), 0x01));

                           /* IF CONDITION */
                           ir_expression *const r0D6B = lequal(body.constant(int(2045)), r0D23);
                           ir_if *f0D6A = new(mem_ctx) ir_if(operand(r0D6B).val);
                           exec_list *const f0D6A_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D6A->then_instructions;

                              ir_variable *const r0D6C = body.make_temp(glsl_type::bool_type, "or_tmp");
                              /* IF CONDITION */
                              ir_expression *const r0D6E = less(body.constant(int(2045)), r0D23);
                              ir_if *f0D6D = new(mem_ctx) ir_if(operand(r0D6E).val);
                              exec_list *const f0D6D_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D6D->then_instructions;

                                 body.emit(assign(r0D6C, body.constant(true), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D6D->else_instructions;

                                 ir_variable *const r0D6F = body.make_temp(glsl_type::bool_type, "and_tmp");
                                 /* IF CONDITION */
                                 ir_expression *const r0D71 = equal(r0D23, body.constant(int(2045)));
                                 ir_if *f0D70 = new(mem_ctx) ir_if(operand(r0D71).val);
                                 exec_list *const f0D70_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0D70->then_instructions;

                                    ir_expression *const r0D72 = equal(body.constant(2097151u), r0D24);
                                    ir_expression *const r0D73 = equal(body.constant(4294967295u), r0D25);
                                    body.emit(assign(r0D6F, logic_and(r0D72, r0D73), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0D70->else_instructions;

                                    body.emit(assign(r0D6F, body.constant(false), 0x01));


                                 body.instructions = f0D70_parent_instructions;
                                 body.emit(f0D70);

                                 /* END IF */

                                 body.emit(assign(r0D6C, logic_and(r0D6F, r0D68), 0x01));


                              body.instructions = f0D6D_parent_instructions;
                              body.emit(f0D6D);

                              /* END IF */

                              /* IF CONDITION */
                              ir_if *f0D74 = new(mem_ctx) ir_if(operand(r0D6C).val);
                              exec_list *const f0D74_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D74->then_instructions;

                                 ir_variable *const r0D75 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                                 body.emit(r0D75);
                                 ir_expression *const r0D76 = lshift(r0994, body.constant(int(31)));
                                 body.emit(assign(r0D75, add(r0D76, body.constant(2146435072u)), 0x02));

                                 body.emit(assign(r0D75, body.constant(0u), 0x01));

                                 body.emit(assign(r0D67, r0D75, 0x03));

                                 body.emit(assign(r0D66, body.constant(false), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D74->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0D78 = less(r0D23, body.constant(int(0)));
                                 ir_if *f0D77 = new(mem_ctx) ir_if(operand(r0D78).val);
                                 exec_list *const f0D77_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0D77->then_instructions;

                                    ir_variable *const r0D79 = body.make_temp(glsl_type::uint_type, "a2");
                                    body.emit(assign(r0D79, r0D26, 0x01));

                                    ir_variable *const r0D7A = body.make_temp(glsl_type::int_type, "count");
                                    body.emit(assign(r0D7A, neg(r0D23), 0x01));

                                    ir_variable *const r0D7B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                                    body.emit(r0D7B);
                                    ir_variable *const r0D7C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                                    body.emit(r0D7C);
                                    ir_variable *const r0D7D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                                    body.emit(r0D7D);
                                    ir_variable *const r0D7E = body.make_temp(glsl_type::int_type, "assignment_tmp");
                                    ir_expression *const r0D7F = neg(r0D7A);
                                    body.emit(assign(r0D7E, bit_and(r0D7F, body.constant(int(31))), 0x01));

                                    /* IF CONDITION */
                                    ir_expression *const r0D81 = equal(r0D7A, body.constant(int(0)));
                                    ir_if *f0D80 = new(mem_ctx) ir_if(operand(r0D81).val);
                                    exec_list *const f0D80_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0D80->then_instructions;

                                       body.emit(assign(r0D7B, r0D26, 0x01));

                                       body.emit(assign(r0D7C, r0D25, 0x01));

                                       body.emit(assign(r0D7D, r0D24, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0D80->else_instructions;

                                       /* IF CONDITION */
                                       ir_expression *const r0D83 = less(r0D7A, body.constant(int(32)));
                                       ir_if *f0D82 = new(mem_ctx) ir_if(operand(r0D83).val);
                                       exec_list *const f0D82_parent_instructions = body.instructions;

                                          /* THEN INSTRUCTIONS */
                                          body.instructions = &f0D82->then_instructions;

                                          body.emit(assign(r0D7B, lshift(r0D25, r0D7E), 0x01));

                                          ir_expression *const r0D84 = lshift(r0D24, r0D7E);
                                          ir_expression *const r0D85 = rshift(r0D25, r0D7A);
                                          body.emit(assign(r0D7C, bit_or(r0D84, r0D85), 0x01));

                                          body.emit(assign(r0D7D, rshift(r0D24, r0D7A), 0x01));


                                          /* ELSE INSTRUCTIONS */
                                          body.instructions = &f0D82->else_instructions;

                                          /* IF CONDITION */
                                          ir_expression *const r0D87 = equal(r0D7A, body.constant(int(32)));
                                          ir_if *f0D86 = new(mem_ctx) ir_if(operand(r0D87).val);
                                          exec_list *const f0D86_parent_instructions = body.instructions;

                                             /* THEN INSTRUCTIONS */
                                             body.instructions = &f0D86->then_instructions;

                                             body.emit(assign(r0D7B, r0D25, 0x01));

                                             body.emit(assign(r0D7C, r0D24, 0x01));


                                             /* ELSE INSTRUCTIONS */
                                             body.instructions = &f0D86->else_instructions;

                                             body.emit(assign(r0D79, bit_or(r0D26, r0D25), 0x01));

                                             /* IF CONDITION */
                                             ir_expression *const r0D89 = less(r0D7A, body.constant(int(64)));
                                             ir_if *f0D88 = new(mem_ctx) ir_if(operand(r0D89).val);
                                             exec_list *const f0D88_parent_instructions = body.instructions;

                                                /* THEN INSTRUCTIONS */
                                                body.instructions = &f0D88->then_instructions;

                                                body.emit(assign(r0D7B, lshift(r0D24, r0D7E), 0x01));

                                                ir_expression *const r0D8A = bit_and(r0D7A, body.constant(int(31)));
                                                body.emit(assign(r0D7C, rshift(r0D24, r0D8A), 0x01));


                                                /* ELSE INSTRUCTIONS */
                                                body.instructions = &f0D88->else_instructions;

                                                ir_variable *const r0D8B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                                /* IF CONDITION */
                                                ir_expression *const r0D8D = equal(r0D7A, body.constant(int(64)));
                                                ir_if *f0D8C = new(mem_ctx) ir_if(operand(r0D8D).val);
                                                exec_list *const f0D8C_parent_instructions = body.instructions;

                                                   /* THEN INSTRUCTIONS */
                                                   body.instructions = &f0D8C->then_instructions;

                                                   body.emit(assign(r0D8B, r0D24, 0x01));


                                                   /* ELSE INSTRUCTIONS */
                                                   body.instructions = &f0D8C->else_instructions;

                                                   ir_expression *const r0D8E = nequal(r0D24, body.constant(0u));
                                                   ir_expression *const r0D8F = expr(ir_unop_b2i, r0D8E);
                                                   body.emit(assign(r0D8B, expr(ir_unop_i2u, r0D8F), 0x01));


                                                body.instructions = f0D8C_parent_instructions;
                                                body.emit(f0D8C);

                                                /* END IF */

                                                body.emit(assign(r0D7B, r0D8B, 0x01));

                                                body.emit(assign(r0D7C, body.constant(0u), 0x01));


                                             body.instructions = f0D88_parent_instructions;
                                             body.emit(f0D88);

                                             /* END IF */


                                          body.instructions = f0D86_parent_instructions;
                                          body.emit(f0D86);

                                          /* END IF */

                                          body.emit(assign(r0D7D, body.constant(0u), 0x01));


                                       body.instructions = f0D82_parent_instructions;
                                       body.emit(f0D82);

                                       /* END IF */

                                       ir_expression *const r0D90 = nequal(r0D79, body.constant(0u));
                                       ir_expression *const r0D91 = expr(ir_unop_b2i, r0D90);
                                       ir_expression *const r0D92 = expr(ir_unop_i2u, r0D91);
                                       body.emit(assign(r0D7B, bit_or(r0D7B, r0D92), 0x01));


                                    body.instructions = f0D80_parent_instructions;
                                    body.emit(f0D80);

                                    /* END IF */

                                    body.emit(assign(r0D63, r0D7D, 0x01));

                                    body.emit(assign(r0D64, r0D7C, 0x01));

                                    body.emit(assign(r0D65, r0D7B, 0x01));

                                    body.emit(assign(r0D62, body.constant(int(0)), 0x01));

                                    body.emit(assign(r0D68, less(r0D7B, body.constant(0u)), 0x01));


                                 body.instructions = f0D77_parent_instructions;
                                 body.emit(f0D77);

                                 /* END IF */


                              body.instructions = f0D74_parent_instructions;
                              body.emit(f0D74);

                              /* END IF */


                           body.instructions = f0D6A_parent_instructions;
                           body.emit(f0D6A);

                           /* END IF */

                           /* IF CONDITION */
                           ir_if *f0D93 = new(mem_ctx) ir_if(operand(r0D66).val);
                           exec_list *const f0D93_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0D93->then_instructions;

                              /* IF CONDITION */
                              ir_if *f0D94 = new(mem_ctx) ir_if(operand(r0D68).val);
                              exec_list *const f0D94_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0D94->then_instructions;

                                 ir_variable *const r0D95 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                                 body.emit(assign(r0D95, add(r0D64, body.constant(1u)), 0x01));

                                 ir_expression *const r0D96 = less(r0D95, r0D64);
                                 ir_expression *const r0D97 = expr(ir_unop_b2i, r0D96);
                                 ir_expression *const r0D98 = expr(ir_unop_i2u, r0D97);
                                 body.emit(assign(r0D63, add(r0D63, r0D98), 0x01));

                                 ir_expression *const r0D99 = equal(r0D65, body.constant(0u));
                                 ir_expression *const r0D9A = expr(ir_unop_b2i, r0D99);
                                 ir_expression *const r0D9B = expr(ir_unop_i2u, r0D9A);
                                 ir_expression *const r0D9C = add(r0D65, r0D9B);
                                 ir_expression *const r0D9D = bit_and(r0D9C, body.constant(1u));
                                 ir_expression *const r0D9E = expr(ir_unop_bit_not, r0D9D);
                                 body.emit(assign(r0D64, bit_and(r0D95, r0D9E), 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0D94->else_instructions;

                                 /* IF CONDITION */
                                 ir_expression *const r0DA0 = bit_or(r0D63, r0D64);
                                 ir_expression *const r0DA1 = equal(r0DA0, body.constant(0u));
                                 ir_if *f0D9F = new(mem_ctx) ir_if(operand(r0DA1).val);
                                 exec_list *const f0D9F_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0D9F->then_instructions;

                                    body.emit(assign(r0D62, body.constant(int(0)), 0x01));


                                 body.instructions = f0D9F_parent_instructions;
                                 body.emit(f0D9F);

                                 /* END IF */


                              body.instructions = f0D94_parent_instructions;
                              body.emit(f0D94);

                              /* END IF */

                              ir_variable *const r0DA2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                              body.emit(r0DA2);
                              ir_expression *const r0DA3 = lshift(r0994, body.constant(int(31)));
                              ir_expression *const r0DA4 = expr(ir_unop_i2u, r0D62);
                              ir_expression *const r0DA5 = lshift(r0DA4, body.constant(int(20)));
                              ir_expression *const r0DA6 = add(r0DA3, r0DA5);
                              body.emit(assign(r0DA2, add(r0DA6, r0D63), 0x02));

                              body.emit(assign(r0DA2, r0D64, 0x01));

                              body.emit(assign(r0D67, r0DA2, 0x03));

                              body.emit(assign(r0D66, body.constant(false), 0x01));


                           body.instructions = f0D93_parent_instructions;
                           body.emit(f0D93);

                           /* END IF */

                           body.emit(assign(r0995, r0D67, 0x03));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0D1B->else_instructions;

                           ir_variable *const r0DA7 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                           body.emit(r0DA7);
                           body.emit(assign(r0DA7, body.constant(0u), 0x02));

                           body.emit(assign(r0DA7, body.constant(0u), 0x01));

                           body.emit(assign(r0995, r0DA7, 0x03));


                        body.instructions = f0D1B_parent_instructions;
                        body.emit(f0D1B);

                        /* END IF */


                     body.instructions = f0C8F_parent_instructions;
                     body.emit(f0C8F);

                     /* END IF */


                  body.instructions = f0C03_parent_instructions;
                  body.emit(f0C03);

                  /* END IF */


               body.instructions = f0B77_parent_instructions;
               body.emit(f0B77);

               /* END IF */


            body.instructions = f0B50_parent_instructions;
            body.emit(f0B50);

            /* END IF */


         body.instructions = f0A7C_parent_instructions;
         body.emit(f0A7C);

         /* END IF */


      body.instructions = f09AC_parent_instructions;
      body.emit(f09AC);

      /* END IF */

      body.emit(assign(r07E6, r0995, 0x03));


   body.instructions = f07E9_parent_instructions;
   body.emit(f07E9);

   /* END IF */

   body.emit(ret(r07E6));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
mul32To64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0DA8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0DA8);
   ir_variable *const r0DA9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0DA9);
   ir_variable *const r0DAA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0DAA);
   ir_variable *const r0DAB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0DAB);
   ir_variable *const r0DAC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r0DAC);
   ir_variable *const r0DAD = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r0DAD);
   ir_variable *const r0DAE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r0DAE);
   ir_variable *const r0DAF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DAF, rshift(r0DA8, body.constant(int(16))), 0x01));

   ir_variable *const r0DB0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DB0, rshift(r0DA9, body.constant(int(16))), 0x01));

   ir_variable *const r0DB1 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DB1, mul(r0DAF, r0DA9), 0x01));

   ir_expression *const r0DB2 = mul(r0DA8, r0DB0);
   body.emit(assign(r0DAD, add(r0DB2, r0DB1), 0x01));

   ir_expression *const r0DB3 = mul(r0DAF, r0DB0);
   ir_expression *const r0DB4 = less(r0DAD, r0DB1);
   ir_expression *const r0DB5 = expr(ir_unop_b2i, r0DB4);
   ir_expression *const r0DB6 = expr(ir_unop_i2u, r0DB5);
   ir_expression *const r0DB7 = lshift(r0DB6, body.constant(int(16)));
   ir_expression *const r0DB8 = rshift(r0DAD, body.constant(int(16)));
   ir_expression *const r0DB9 = add(r0DB7, r0DB8);
   body.emit(assign(r0DAC, add(r0DB3, r0DB9), 0x01));

   body.emit(assign(r0DAD, lshift(r0DAD, body.constant(int(16))), 0x01));

   ir_expression *const r0DBA = mul(r0DA8, r0DA9);
   body.emit(assign(r0DAE, add(r0DBA, r0DAD), 0x01));

   ir_expression *const r0DBB = less(r0DAE, r0DAD);
   ir_expression *const r0DBC = expr(ir_unop_b2i, r0DBB);
   ir_expression *const r0DBD = expr(ir_unop_i2u, r0DBC);
   body.emit(assign(r0DAC, add(r0DAC, r0DBD), 0x01));

   body.emit(assign(r0DAB, r0DAE, 0x01));

   body.emit(assign(r0DAA, r0DAC, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
mul64To128(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0DBE = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r0DBE);
   ir_variable *const r0DBF = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r0DBF);
   ir_variable *const r0DC0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r0DC0);
   ir_variable *const r0DC1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r0DC1);
   ir_variable *const r0DC2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0DC2);
   ir_variable *const r0DC3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0DC3);
   ir_variable *const r0DC4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0DC4);
   ir_variable *const r0DC5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z3Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0DC5);
   ir_variable *const r0DC6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r0DC6);
   ir_variable *const r0DC7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r0DC7);
   ir_variable *const r0DC8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r0DC8);
   ir_variable *const r0DC9 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DC9, rshift(r0DBF, body.constant(int(16))), 0x01));

   ir_variable *const r0DCA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DCA, rshift(r0DC1, body.constant(int(16))), 0x01));

   ir_variable *const r0DCB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DCB, mul(r0DC9, r0DC1), 0x01));

   ir_expression *const r0DCC = mul(r0DBF, r0DCA);
   body.emit(assign(r0DC7, add(r0DCC, r0DCB), 0x01));

   ir_expression *const r0DCD = mul(r0DC9, r0DCA);
   ir_expression *const r0DCE = less(r0DC7, r0DCB);
   ir_expression *const r0DCF = expr(ir_unop_b2i, r0DCE);
   ir_expression *const r0DD0 = expr(ir_unop_i2u, r0DCF);
   ir_expression *const r0DD1 = lshift(r0DD0, body.constant(int(16)));
   ir_expression *const r0DD2 = rshift(r0DC7, body.constant(int(16)));
   ir_expression *const r0DD3 = add(r0DD1, r0DD2);
   body.emit(assign(r0DC6, add(r0DCD, r0DD3), 0x01));

   body.emit(assign(r0DC7, lshift(r0DC7, body.constant(int(16))), 0x01));

   ir_expression *const r0DD4 = mul(r0DBF, r0DC1);
   body.emit(assign(r0DC8, add(r0DD4, r0DC7), 0x01));

   ir_expression *const r0DD5 = less(r0DC8, r0DC7);
   ir_expression *const r0DD6 = expr(ir_unop_b2i, r0DD5);
   ir_expression *const r0DD7 = expr(ir_unop_i2u, r0DD6);
   body.emit(assign(r0DC6, add(r0DC6, r0DD7), 0x01));

   ir_variable *const r0DD8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r0DD8);
   ir_variable *const r0DD9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r0DD9);
   ir_variable *const r0DDA = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r0DDA);
   ir_variable *const r0DDB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DDB, rshift(r0DBF, body.constant(int(16))), 0x01));

   ir_variable *const r0DDC = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DDC, rshift(r0DC0, body.constant(int(16))), 0x01));

   ir_variable *const r0DDD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DDD, mul(r0DDB, r0DC0), 0x01));

   ir_expression *const r0DDE = mul(r0DBF, r0DDC);
   body.emit(assign(r0DD9, add(r0DDE, r0DDD), 0x01));

   ir_expression *const r0DDF = mul(r0DDB, r0DDC);
   ir_expression *const r0DE0 = less(r0DD9, r0DDD);
   ir_expression *const r0DE1 = expr(ir_unop_b2i, r0DE0);
   ir_expression *const r0DE2 = expr(ir_unop_i2u, r0DE1);
   ir_expression *const r0DE3 = lshift(r0DE2, body.constant(int(16)));
   ir_expression *const r0DE4 = rshift(r0DD9, body.constant(int(16)));
   ir_expression *const r0DE5 = add(r0DE3, r0DE4);
   body.emit(assign(r0DD8, add(r0DDF, r0DE5), 0x01));

   body.emit(assign(r0DD9, lshift(r0DD9, body.constant(int(16))), 0x01));

   ir_expression *const r0DE6 = mul(r0DBF, r0DC0);
   body.emit(assign(r0DDA, add(r0DE6, r0DD9), 0x01));

   ir_expression *const r0DE7 = less(r0DDA, r0DD9);
   ir_expression *const r0DE8 = expr(ir_unop_b2i, r0DE7);
   ir_expression *const r0DE9 = expr(ir_unop_i2u, r0DE8);
   body.emit(assign(r0DD8, add(r0DD8, r0DE9), 0x01));

   ir_variable *const r0DEA = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DEA, add(r0DDA, r0DC6), 0x01));

   ir_variable *const r0DEB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r0DEB);
   ir_variable *const r0DEC = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r0DEC);
   ir_variable *const r0DED = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r0DED);
   ir_variable *const r0DEE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DEE, rshift(r0DBE, body.constant(int(16))), 0x01));

   ir_variable *const r0DEF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DEF, rshift(r0DC0, body.constant(int(16))), 0x01));

   ir_variable *const r0DF0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0DF0, mul(r0DEE, r0DC0), 0x01));

   ir_expression *const r0DF1 = mul(r0DBE, r0DEF);
   body.emit(assign(r0DEC, add(r0DF1, r0DF0), 0x01));

   ir_expression *const r0DF2 = mul(r0DEE, r0DEF);
   ir_expression *const r0DF3 = less(r0DEC, r0DF0);
   ir_expression *const r0DF4 = expr(ir_unop_b2i, r0DF3);
   ir_expression *const r0DF5 = expr(ir_unop_i2u, r0DF4);
   ir_expression *const r0DF6 = lshift(r0DF5, body.constant(int(16)));
   ir_expression *const r0DF7 = rshift(r0DEC, body.constant(int(16)));
   ir_expression *const r0DF8 = add(r0DF6, r0DF7);
   body.emit(assign(r0DEB, add(r0DF2, r0DF8), 0x01));

   body.emit(assign(r0DEC, lshift(r0DEC, body.constant(int(16))), 0x01));

   ir_expression *const r0DF9 = mul(r0DBE, r0DC0);
   body.emit(assign(r0DED, add(r0DF9, r0DEC), 0x01));

   ir_expression *const r0DFA = less(r0DED, r0DEC);
   ir_expression *const r0DFB = expr(ir_unop_b2i, r0DFA);
   ir_expression *const r0DFC = expr(ir_unop_i2u, r0DFB);
   body.emit(assign(r0DEB, add(r0DEB, r0DFC), 0x01));

   ir_variable *const r0DFD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   ir_expression *const r0DFE = less(r0DEA, r0DDA);
   ir_expression *const r0DFF = expr(ir_unop_b2i, r0DFE);
   ir_expression *const r0E00 = expr(ir_unop_i2u, r0DFF);
   ir_expression *const r0E01 = add(r0DD8, r0E00);
   body.emit(assign(r0DFD, add(r0DED, r0E01), 0x01));

   ir_variable *const r0E02 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r0E02);
   ir_variable *const r0E03 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r0E03);
   ir_variable *const r0E04 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r0E04);
   ir_variable *const r0E05 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0E05, rshift(r0DBE, body.constant(int(16))), 0x01));

   ir_variable *const r0E06 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0E06, rshift(r0DC1, body.constant(int(16))), 0x01));

   ir_variable *const r0E07 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0E07, mul(r0E05, r0DC1), 0x01));

   ir_expression *const r0E08 = mul(r0DBE, r0E06);
   body.emit(assign(r0E03, add(r0E08, r0E07), 0x01));

   ir_expression *const r0E09 = mul(r0E05, r0E06);
   ir_expression *const r0E0A = less(r0E03, r0E07);
   ir_expression *const r0E0B = expr(ir_unop_b2i, r0E0A);
   ir_expression *const r0E0C = expr(ir_unop_i2u, r0E0B);
   ir_expression *const r0E0D = lshift(r0E0C, body.constant(int(16)));
   ir_expression *const r0E0E = rshift(r0E03, body.constant(int(16)));
   ir_expression *const r0E0F = add(r0E0D, r0E0E);
   body.emit(assign(r0E02, add(r0E09, r0E0F), 0x01));

   body.emit(assign(r0E03, lshift(r0E03, body.constant(int(16))), 0x01));

   ir_expression *const r0E10 = mul(r0DBE, r0DC1);
   body.emit(assign(r0E04, add(r0E10, r0E03), 0x01));

   ir_expression *const r0E11 = less(r0E04, r0E03);
   ir_expression *const r0E12 = expr(ir_unop_b2i, r0E11);
   ir_expression *const r0E13 = expr(ir_unop_i2u, r0E12);
   body.emit(assign(r0E02, add(r0E02, r0E13), 0x01));

   ir_variable *const r0E14 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r0E14, add(r0E04, r0DEA), 0x01));

   ir_variable *const r0E15 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   ir_expression *const r0E16 = less(r0E14, r0E04);
   ir_expression *const r0E17 = expr(ir_unop_b2i, r0E16);
   ir_expression *const r0E18 = expr(ir_unop_i2u, r0E17);
   ir_expression *const r0E19 = add(r0E02, r0E18);
   body.emit(assign(r0E15, add(r0DFD, r0E19), 0x01));

   body.emit(assign(r0DC5, r0DC8, 0x01));

   body.emit(assign(r0DC4, r0E14, 0x01));

   body.emit(assign(r0DC3, r0E15, 0x01));

   ir_expression *const r0E1A = less(r0DFD, r0DED);
   ir_expression *const r0E1B = expr(ir_unop_b2i, r0E1A);
   ir_expression *const r0E1C = expr(ir_unop_i2u, r0E1B);
   ir_expression *const r0E1D = add(r0DEB, r0E1C);
   ir_expression *const r0E1E = less(r0E15, r0DFD);
   ir_expression *const r0E1F = expr(ir_unop_b2i, r0E1E);
   ir_expression *const r0E20 = expr(ir_unop_i2u, r0E1F);
   body.emit(assign(r0DC2, add(r0E1D, r0E20), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
normalizeFloat64Subnormal(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0E21 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac0", ir_var_function_in);
   sig_parameters.push_tail(r0E21);
   ir_variable *const r0E22 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac1", ir_var_function_in);
   sig_parameters.push_tail(r0E22);
   ir_variable *const r0E23 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExpPtr", ir_var_function_inout);
   sig_parameters.push_tail(r0E23);
   ir_variable *const r0E24 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0E24);
   ir_variable *const r0E25 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r0E25);
   ir_variable *const r0E26 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r0E26);
   /* IF CONDITION */
   ir_expression *const r0E28 = equal(r0E21, body.constant(0u));
   ir_if *f0E27 = new(mem_ctx) ir_if(operand(r0E28).val);
   exec_list *const f0E27_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0E27->then_instructions;

      ir_variable *const r0E29 = body.make_temp(glsl_type::uint_type, "a");
      body.emit(assign(r0E29, r0E22, 0x01));

      ir_variable *const r0E2A = body.make_temp(glsl_type::int_type, "return_value");
      ir_variable *const r0E2B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
      body.emit(r0E2B);
      /* IF CONDITION */
      ir_expression *const r0E2D = equal(r0E22, body.constant(0u));
      ir_if *f0E2C = new(mem_ctx) ir_if(operand(r0E2D).val);
      exec_list *const f0E2C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0E2C->then_instructions;

         body.emit(assign(r0E2A, body.constant(int(32)), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0E2C->else_instructions;

         body.emit(assign(r0E2B, body.constant(int(0)), 0x01));

         /* IF CONDITION */
         ir_expression *const r0E2F = bit_and(r0E22, body.constant(4294901760u));
         ir_expression *const r0E30 = equal(r0E2F, body.constant(0u));
         ir_if *f0E2E = new(mem_ctx) ir_if(operand(r0E30).val);
         exec_list *const f0E2E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0E2E->then_instructions;

            body.emit(assign(r0E2B, body.constant(int(16)), 0x01));

            body.emit(assign(r0E29, lshift(r0E22, body.constant(int(16))), 0x01));


         body.instructions = f0E2E_parent_instructions;
         body.emit(f0E2E);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r0E32 = bit_and(r0E29, body.constant(4278190080u));
         ir_expression *const r0E33 = equal(r0E32, body.constant(0u));
         ir_if *f0E31 = new(mem_ctx) ir_if(operand(r0E33).val);
         exec_list *const f0E31_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0E31->then_instructions;

            body.emit(assign(r0E2B, add(r0E2B, body.constant(int(8))), 0x01));

            body.emit(assign(r0E29, lshift(r0E29, body.constant(int(8))), 0x01));


         body.instructions = f0E31_parent_instructions;
         body.emit(f0E31);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r0E35 = bit_and(r0E29, body.constant(4026531840u));
         ir_expression *const r0E36 = equal(r0E35, body.constant(0u));
         ir_if *f0E34 = new(mem_ctx) ir_if(operand(r0E36).val);
         exec_list *const f0E34_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0E34->then_instructions;

            body.emit(assign(r0E2B, add(r0E2B, body.constant(int(4))), 0x01));

            body.emit(assign(r0E29, lshift(r0E29, body.constant(int(4))), 0x01));


         body.instructions = f0E34_parent_instructions;
         body.emit(f0E34);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r0E38 = bit_and(r0E29, body.constant(3221225472u));
         ir_expression *const r0E39 = equal(r0E38, body.constant(0u));
         ir_if *f0E37 = new(mem_ctx) ir_if(operand(r0E39).val);
         exec_list *const f0E37_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0E37->then_instructions;

            body.emit(assign(r0E2B, add(r0E2B, body.constant(int(2))), 0x01));

            body.emit(assign(r0E29, lshift(r0E29, body.constant(int(2))), 0x01));


         body.instructions = f0E37_parent_instructions;
         body.emit(f0E37);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r0E3B = bit_and(r0E29, body.constant(2147483648u));
         ir_expression *const r0E3C = equal(r0E3B, body.constant(0u));
         ir_if *f0E3A = new(mem_ctx) ir_if(operand(r0E3C).val);
         exec_list *const f0E3A_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0E3A->then_instructions;

            body.emit(assign(r0E2B, add(r0E2B, body.constant(int(1))), 0x01));


         body.instructions = f0E3A_parent_instructions;
         body.emit(f0E3A);

         /* END IF */

         body.emit(assign(r0E2A, r0E2B, 0x01));


      body.instructions = f0E2C_parent_instructions;
      body.emit(f0E2C);

      /* END IF */

      body.emit(assign(r0E26, add(r0E2A, body.constant(int(-11))), 0x01));

      /* IF CONDITION */
      ir_expression *const r0E3E = less(r0E26, body.constant(int(0)));
      ir_if *f0E3D = new(mem_ctx) ir_if(operand(r0E3E).val);
      exec_list *const f0E3D_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0E3D->then_instructions;

         ir_expression *const r0E3F = neg(r0E26);
         body.emit(assign(r0E24, rshift(r0E22, r0E3F), 0x01));

         ir_expression *const r0E40 = bit_and(r0E26, body.constant(int(31)));
         body.emit(assign(r0E25, lshift(r0E22, r0E40), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0E3D->else_instructions;

         body.emit(assign(r0E24, lshift(r0E22, r0E26), 0x01));

         body.emit(assign(r0E25, body.constant(0u), 0x01));


      body.instructions = f0E3D_parent_instructions;
      body.emit(f0E3D);

      /* END IF */

      body.emit(assign(r0E23, sub(body.constant(int(-31)), r0E26), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0E27->else_instructions;

      ir_variable *const r0E41 = body.make_temp(glsl_type::uint_type, "a");
      body.emit(assign(r0E41, r0E21, 0x01));

      ir_variable *const r0E42 = body.make_temp(glsl_type::int_type, "return_value");
      ir_variable *const r0E43 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
      body.emit(r0E43);
      /* IF CONDITION */
      ir_expression *const r0E45 = equal(r0E21, body.constant(0u));
      ir_if *f0E44 = new(mem_ctx) ir_if(operand(r0E45).val);
      exec_list *const f0E44_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0E44->then_instructions;

         body.emit(assign(r0E42, body.constant(int(32)), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0E44->else_instructions;

         body.emit(assign(r0E43, body.constant(int(0)), 0x01));

         /* IF CONDITION */
         ir_expression *const r0E47 = bit_and(r0E21, body.constant(4294901760u));
         ir_expression *const r0E48 = equal(r0E47, body.constant(0u));
         ir_if *f0E46 = new(mem_ctx) ir_if(operand(r0E48).val);
         exec_list *const f0E46_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0E46->then_instructions;

            body.emit(assign(r0E43, body.constant(int(16)), 0x01));

            body.emit(assign(r0E41, lshift(r0E21, body.constant(int(16))), 0x01));


         body.instructions = f0E46_parent_instructions;
         body.emit(f0E46);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r0E4A = bit_and(r0E41, body.constant(4278190080u));
         ir_expression *const r0E4B = equal(r0E4A, body.constant(0u));
         ir_if *f0E49 = new(mem_ctx) ir_if(operand(r0E4B).val);
         exec_list *const f0E49_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0E49->then_instructions;

            body.emit(assign(r0E43, add(r0E43, body.constant(int(8))), 0x01));

            body.emit(assign(r0E41, lshift(r0E41, body.constant(int(8))), 0x01));


         body.instructions = f0E49_parent_instructions;
         body.emit(f0E49);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r0E4D = bit_and(r0E41, body.constant(4026531840u));
         ir_expression *const r0E4E = equal(r0E4D, body.constant(0u));
         ir_if *f0E4C = new(mem_ctx) ir_if(operand(r0E4E).val);
         exec_list *const f0E4C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0E4C->then_instructions;

            body.emit(assign(r0E43, add(r0E43, body.constant(int(4))), 0x01));

            body.emit(assign(r0E41, lshift(r0E41, body.constant(int(4))), 0x01));


         body.instructions = f0E4C_parent_instructions;
         body.emit(f0E4C);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r0E50 = bit_and(r0E41, body.constant(3221225472u));
         ir_expression *const r0E51 = equal(r0E50, body.constant(0u));
         ir_if *f0E4F = new(mem_ctx) ir_if(operand(r0E51).val);
         exec_list *const f0E4F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0E4F->then_instructions;

            body.emit(assign(r0E43, add(r0E43, body.constant(int(2))), 0x01));

            body.emit(assign(r0E41, lshift(r0E41, body.constant(int(2))), 0x01));


         body.instructions = f0E4F_parent_instructions;
         body.emit(f0E4F);

         /* END IF */

         /* IF CONDITION */
         ir_expression *const r0E53 = bit_and(r0E41, body.constant(2147483648u));
         ir_expression *const r0E54 = equal(r0E53, body.constant(0u));
         ir_if *f0E52 = new(mem_ctx) ir_if(operand(r0E54).val);
         exec_list *const f0E52_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0E52->then_instructions;

            body.emit(assign(r0E43, add(r0E43, body.constant(int(1))), 0x01));


         body.instructions = f0E52_parent_instructions;
         body.emit(f0E52);

         /* END IF */

         body.emit(assign(r0E42, r0E43, 0x01));


      body.instructions = f0E44_parent_instructions;
      body.emit(f0E44);

      /* END IF */

      body.emit(assign(r0E26, add(r0E42, body.constant(int(-11))), 0x01));

      ir_variable *const r0E55 = body.make_temp(glsl_type::uint_type, "z1Ptr");
      body.emit(assign(r0E55, lshift(r0E22, r0E26), 0x01));

      ir_variable *const r0E56 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r0E58 = equal(r0E26, body.constant(int(0)));
      ir_if *f0E57 = new(mem_ctx) ir_if(operand(r0E58).val);
      exec_list *const f0E57_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0E57->then_instructions;

         body.emit(assign(r0E56, r0E21, 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0E57->else_instructions;

         ir_expression *const r0E59 = lshift(r0E21, r0E26);
         ir_expression *const r0E5A = neg(r0E26);
         ir_expression *const r0E5B = bit_and(r0E5A, body.constant(int(31)));
         ir_expression *const r0E5C = rshift(r0E22, r0E5B);
         body.emit(assign(r0E56, bit_or(r0E59, r0E5C), 0x01));


      body.instructions = f0E57_parent_instructions;
      body.emit(f0E57);

      /* END IF */

      body.emit(assign(r0E24, r0E56, 0x01));

      body.emit(assign(r0E25, r0E55, 0x01));

      body.emit(assign(r0E23, sub(body.constant(int(1)), r0E26), 0x01));


   body.instructions = f0E27_parent_instructions;
   body.emit(f0E27);

   /* END IF */

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fmul64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r0E5D = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r0E5D);
   ir_variable *const r0E5E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r0E5E);
   ir_variable *const r0E5F = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r0E5F, body.constant(true), 0x01));

   ir_variable *const r0E60 = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r0E61 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_auto);
   body.emit(r0E61);
   ir_variable *const r0E62 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
   body.emit(r0E62);
   ir_variable *const r0E63 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
   body.emit(r0E63);
   ir_variable *const r0E64 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r0E64);
   ir_variable *const r0E65 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
   body.emit(r0E65);
   ir_variable *const r0E66 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r0E66);
   ir_variable *const r0E67 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac2", ir_var_auto);
   body.emit(r0E67);
   ir_variable *const r0E68 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r0E68);
   ir_variable *const r0E69 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r0E69);
   body.emit(assign(r0E69, body.constant(0u), 0x01));

   body.emit(assign(r0E68, body.constant(0u), 0x01));

   body.emit(assign(r0E67, body.constant(0u), 0x01));

   ir_variable *const r0E6A = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
   body.emit(assign(r0E6A, bit_and(swizzle_y(r0E5D), body.constant(1048575u)), 0x01));

   body.emit(assign(r0E6A, swizzle_x(r0E5D), 0x02));

   body.emit(assign(r0E65, r0E6A, 0x03));

   ir_variable *const r0E6B = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r0E6C = rshift(swizzle_y(r0E5D), body.constant(int(20)));
   ir_expression *const r0E6D = bit_and(r0E6C, body.constant(2047u));
   body.emit(assign(r0E6B, expr(ir_unop_u2i, r0E6D), 0x01));

   body.emit(assign(r0E64, r0E6B, 0x01));

   ir_variable *const r0E6E = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
   body.emit(assign(r0E6E, bit_and(swizzle_y(r0E5E), body.constant(1048575u)), 0x01));

   body.emit(assign(r0E6E, swizzle_x(r0E5E), 0x02));

   body.emit(assign(r0E63, r0E6E, 0x03));

   ir_variable *const r0E6F = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r0E70 = rshift(swizzle_y(r0E5E), body.constant(int(20)));
   ir_expression *const r0E71 = bit_and(r0E70, body.constant(2047u));
   body.emit(assign(r0E6F, expr(ir_unop_u2i, r0E71), 0x01));

   body.emit(assign(r0E62, r0E6F, 0x01));

   ir_expression *const r0E72 = rshift(swizzle_y(r0E5D), body.constant(int(31)));
   ir_expression *const r0E73 = rshift(swizzle_y(r0E5E), body.constant(int(31)));
   body.emit(assign(r0E61, bit_xor(r0E72, r0E73), 0x01));

   /* IF CONDITION */
   ir_expression *const r0E75 = equal(r0E6B, body.constant(int(2047)));
   ir_if *f0E74 = new(mem_ctx) ir_if(operand(r0E75).val);
   exec_list *const f0E74_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f0E74->then_instructions;

      /* IF CONDITION */
      ir_expression *const r0E77 = bit_or(swizzle_x(r0E5D), swizzle_x(r0E6A));
      ir_expression *const r0E78 = nequal(r0E77, body.constant(0u));
      ir_expression *const r0E79 = equal(r0E6F, body.constant(int(2047)));
      ir_expression *const r0E7A = bit_or(swizzle_x(r0E5E), swizzle_x(r0E6E));
      ir_expression *const r0E7B = nequal(r0E7A, body.constant(0u));
      ir_expression *const r0E7C = logic_and(r0E79, r0E7B);
      ir_expression *const r0E7D = logic_or(r0E78, r0E7C);
      ir_if *f0E76 = new(mem_ctx) ir_if(operand(r0E7D).val);
      exec_list *const f0E76_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0E76->then_instructions;

         ir_variable *const r0E7E = body.make_temp(glsl_type::uvec2_type, "a");
         body.emit(assign(r0E7E, swizzle_y(r0E5D), 0x02));

         ir_variable *const r0E7F = body.make_temp(glsl_type::uvec2_type, "b");
         body.emit(assign(r0E7F, swizzle_y(r0E5E), 0x02));

         ir_variable *const r0E80 = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r0E81 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
         ir_expression *const r0E82 = rshift(swizzle_x(r0E5D), body.constant(int(19)));
         ir_expression *const r0E83 = bit_and(r0E82, body.constant(4095u));
         ir_expression *const r0E84 = equal(r0E83, body.constant(4094u));
         ir_expression *const r0E85 = nequal(swizzle_y(r0E5D), body.constant(0u));
         ir_expression *const r0E86 = bit_and(swizzle_x(r0E5D), body.constant(524287u));
         ir_expression *const r0E87 = nequal(r0E86, body.constant(0u));
         ir_expression *const r0E88 = logic_or(r0E85, r0E87);
         body.emit(assign(r0E81, logic_and(r0E84, r0E88), 0x01));

         ir_variable *const r0E89 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
         ir_expression *const r0E8A = lshift(swizzle_x(r0E5E), body.constant(int(1)));
         ir_expression *const r0E8B = lequal(body.constant(4292870144u), r0E8A);
         ir_expression *const r0E8C = nequal(swizzle_y(r0E5E), body.constant(0u));
         ir_expression *const r0E8D = bit_and(swizzle_x(r0E5E), body.constant(1048575u));
         ir_expression *const r0E8E = nequal(r0E8D, body.constant(0u));
         ir_expression *const r0E8F = logic_or(r0E8C, r0E8E);
         body.emit(assign(r0E89, logic_and(r0E8B, r0E8F), 0x01));

         body.emit(assign(r0E7E, bit_or(swizzle_x(r0E5D), body.constant(524288u)), 0x01));

         body.emit(assign(r0E7F, bit_or(swizzle_x(r0E5E), body.constant(524288u)), 0x01));

         /* IF CONDITION */
         ir_expression *const r0E91 = lshift(swizzle_x(r0E5D), body.constant(int(1)));
         ir_expression *const r0E92 = lequal(body.constant(4292870144u), r0E91);
         ir_expression *const r0E93 = nequal(swizzle_y(r0E5D), body.constant(0u));
         ir_expression *const r0E94 = bit_and(swizzle_x(r0E5D), body.constant(1048575u));
         ir_expression *const r0E95 = nequal(r0E94, body.constant(0u));
         ir_expression *const r0E96 = logic_or(r0E93, r0E95);
         ir_expression *const r0E97 = logic_and(r0E92, r0E96);
         ir_if *f0E90 = new(mem_ctx) ir_if(operand(r0E97).val);
         exec_list *const f0E90_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0E90->then_instructions;

            ir_variable *const r0E98 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r0E9A = logic_and(r0E81, r0E89);
            ir_if *f0E99 = new(mem_ctx) ir_if(operand(r0E9A).val);
            exec_list *const f0E99_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0E99->then_instructions;

               body.emit(assign(r0E98, r0E7F, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0E99->else_instructions;

               body.emit(assign(r0E98, r0E7E, 0x03));


            body.instructions = f0E99_parent_instructions;
            body.emit(f0E99);

            /* END IF */

            body.emit(assign(r0E80, r0E98, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0E90->else_instructions;

            body.emit(assign(r0E80, r0E7F, 0x03));


         body.instructions = f0E90_parent_instructions;
         body.emit(f0E90);

         /* END IF */

         body.emit(assign(r0E60, r0E80, 0x03));

         body.emit(assign(r0E5F, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0E76->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0E9C = expr(ir_unop_i2u, r0E6F);
         ir_expression *const r0E9D = bit_or(r0E9C, swizzle_x(r0E5E));
         ir_expression *const r0E9E = bit_or(r0E9D, swizzle_x(r0E6E));
         ir_expression *const r0E9F = equal(r0E9E, body.constant(0u));
         ir_if *f0E9B = new(mem_ctx) ir_if(operand(r0E9F).val);
         exec_list *const f0E9B_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0E9B->then_instructions;

            ir_constant_data r0EA0_data;
            memset(&r0EA0_data, 0, sizeof(ir_constant_data));
            r0EA0_data.u[0] = 4294967295;
            r0EA0_data.u[1] = 4294967295;
            ir_constant *const r0EA0 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r0EA0_data);
            body.emit(assign(r0E60, r0EA0, 0x03));

            body.emit(assign(r0E5F, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0E9B->else_instructions;

            ir_variable *const r0EA1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r0EA1);
            ir_expression *const r0EA2 = lshift(r0E61, body.constant(int(31)));
            body.emit(assign(r0EA1, add(r0EA2, body.constant(2146435072u)), 0x02));

            body.emit(assign(r0EA1, body.constant(0u), 0x01));

            body.emit(assign(r0E60, r0EA1, 0x03));

            body.emit(assign(r0E5F, body.constant(false), 0x01));


         body.instructions = f0E9B_parent_instructions;
         body.emit(f0E9B);

         /* END IF */


      body.instructions = f0E76_parent_instructions;
      body.emit(f0E76);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f0E74->else_instructions;

      /* IF CONDITION */
      ir_expression *const r0EA4 = equal(r0E6F, body.constant(int(2047)));
      ir_if *f0EA3 = new(mem_ctx) ir_if(operand(r0EA4).val);
      exec_list *const f0EA3_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f0EA3->then_instructions;

         /* IF CONDITION */
         ir_expression *const r0EA6 = bit_or(swizzle_x(r0E5E), swizzle_x(r0E6E));
         ir_expression *const r0EA7 = nequal(r0EA6, body.constant(0u));
         ir_if *f0EA5 = new(mem_ctx) ir_if(operand(r0EA7).val);
         exec_list *const f0EA5_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0EA5->then_instructions;

            ir_variable *const r0EA8 = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r0EA8, swizzle_y(r0E5D), 0x02));

            ir_variable *const r0EA9 = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r0EA9, swizzle_y(r0E5E), 0x02));

            ir_variable *const r0EAA = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r0EAB = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r0EAC = rshift(swizzle_x(r0E5D), body.constant(int(19)));
            ir_expression *const r0EAD = bit_and(r0EAC, body.constant(4095u));
            ir_expression *const r0EAE = equal(r0EAD, body.constant(4094u));
            ir_expression *const r0EAF = nequal(swizzle_y(r0E5D), body.constant(0u));
            ir_expression *const r0EB0 = bit_and(swizzle_x(r0E5D), body.constant(524287u));
            ir_expression *const r0EB1 = nequal(r0EB0, body.constant(0u));
            ir_expression *const r0EB2 = logic_or(r0EAF, r0EB1);
            body.emit(assign(r0EAB, logic_and(r0EAE, r0EB2), 0x01));

            ir_variable *const r0EB3 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r0EB4 = lshift(swizzle_x(r0E5E), body.constant(int(1)));
            ir_expression *const r0EB5 = lequal(body.constant(4292870144u), r0EB4);
            ir_expression *const r0EB6 = nequal(swizzle_y(r0E5E), body.constant(0u));
            ir_expression *const r0EB7 = bit_and(swizzle_x(r0E5E), body.constant(1048575u));
            ir_expression *const r0EB8 = nequal(r0EB7, body.constant(0u));
            ir_expression *const r0EB9 = logic_or(r0EB6, r0EB8);
            body.emit(assign(r0EB3, logic_and(r0EB5, r0EB9), 0x01));

            body.emit(assign(r0EA8, bit_or(swizzle_x(r0E5D), body.constant(524288u)), 0x01));

            body.emit(assign(r0EA9, bit_or(swizzle_x(r0E5E), body.constant(524288u)), 0x01));

            /* IF CONDITION */
            ir_expression *const r0EBB = lshift(swizzle_x(r0E5D), body.constant(int(1)));
            ir_expression *const r0EBC = lequal(body.constant(4292870144u), r0EBB);
            ir_expression *const r0EBD = nequal(swizzle_y(r0E5D), body.constant(0u));
            ir_expression *const r0EBE = bit_and(swizzle_x(r0E5D), body.constant(1048575u));
            ir_expression *const r0EBF = nequal(r0EBE, body.constant(0u));
            ir_expression *const r0EC0 = logic_or(r0EBD, r0EBF);
            ir_expression *const r0EC1 = logic_and(r0EBC, r0EC0);
            ir_if *f0EBA = new(mem_ctx) ir_if(operand(r0EC1).val);
            exec_list *const f0EBA_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0EBA->then_instructions;

               ir_variable *const r0EC2 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r0EC4 = logic_and(r0EAB, r0EB3);
               ir_if *f0EC3 = new(mem_ctx) ir_if(operand(r0EC4).val);
               exec_list *const f0EC3_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0EC3->then_instructions;

                  body.emit(assign(r0EC2, r0EA9, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0EC3->else_instructions;

                  body.emit(assign(r0EC2, r0EA8, 0x03));


               body.instructions = f0EC3_parent_instructions;
               body.emit(f0EC3);

               /* END IF */

               body.emit(assign(r0EAA, r0EC2, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0EBA->else_instructions;

               body.emit(assign(r0EAA, r0EA9, 0x03));


            body.instructions = f0EBA_parent_instructions;
            body.emit(f0EBA);

            /* END IF */

            body.emit(assign(r0E60, r0EAA, 0x03));

            body.emit(assign(r0E5F, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f0EA5->else_instructions;

            /* IF CONDITION */
            ir_expression *const r0EC6 = expr(ir_unop_i2u, r0E6B);
            ir_expression *const r0EC7 = bit_or(r0EC6, swizzle_x(r0E5D));
            ir_expression *const r0EC8 = bit_or(r0EC7, swizzle_x(r0E6A));
            ir_expression *const r0EC9 = equal(r0EC8, body.constant(0u));
            ir_if *f0EC5 = new(mem_ctx) ir_if(operand(r0EC9).val);
            exec_list *const f0EC5_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0EC5->then_instructions;

               ir_constant_data r0ECA_data;
               memset(&r0ECA_data, 0, sizeof(ir_constant_data));
               r0ECA_data.u[0] = 4294967295;
               r0ECA_data.u[1] = 4294967295;
               ir_constant *const r0ECA = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r0ECA_data);
               body.emit(assign(r0E60, r0ECA, 0x03));

               body.emit(assign(r0E5F, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0EC5->else_instructions;

               ir_variable *const r0ECB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0ECB);
               ir_expression *const r0ECC = lshift(r0E61, body.constant(int(31)));
               body.emit(assign(r0ECB, add(r0ECC, body.constant(2146435072u)), 0x02));

               body.emit(assign(r0ECB, body.constant(0u), 0x01));

               body.emit(assign(r0E60, r0ECB, 0x03));

               body.emit(assign(r0E5F, body.constant(false), 0x01));


            body.instructions = f0EC5_parent_instructions;
            body.emit(f0EC5);

            /* END IF */


         body.instructions = f0EA5_parent_instructions;
         body.emit(f0EA5);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f0EA3->else_instructions;

         /* IF CONDITION */
         ir_expression *const r0ECE = equal(r0E6B, body.constant(int(0)));
         ir_if *f0ECD = new(mem_ctx) ir_if(operand(r0ECE).val);
         exec_list *const f0ECD_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0ECD->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0ED0 = bit_or(swizzle_x(r0E5D), swizzle_x(r0E6A));
            ir_expression *const r0ED1 = equal(r0ED0, body.constant(0u));
            ir_if *f0ECF = new(mem_ctx) ir_if(operand(r0ED1).val);
            exec_list *const f0ECF_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0ECF->then_instructions;

               ir_variable *const r0ED2 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
               body.emit(r0ED2);
               body.emit(assign(r0ED2, lshift(r0E61, body.constant(int(31))), 0x02));

               body.emit(assign(r0ED2, body.constant(0u), 0x01));

               body.emit(assign(r0E60, r0ED2, 0x03));

               body.emit(assign(r0E5F, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f0ECF->else_instructions;

               ir_variable *const r0ED3 = body.make_temp(glsl_type::uint_type, "aFrac0");
               body.emit(assign(r0ED3, swizzle_y(r0E6A), 0x01));

               ir_variable *const r0ED4 = body.make_temp(glsl_type::uint_type, "aFrac1");
               body.emit(assign(r0ED4, swizzle_x(r0E6A), 0x01));

               ir_variable *const r0ED5 = body.make_temp(glsl_type::int_type, "zExpPtr");
               body.emit(assign(r0ED5, r0E6B, 0x01));

               ir_variable *const r0ED6 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
               body.emit(assign(r0ED6, swizzle_y(r0E6A), 0x01));

               ir_variable *const r0ED7 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
               body.emit(assign(r0ED7, swizzle_x(r0E6A), 0x01));

               ir_variable *const r0ED8 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r0ED8);
               /* IF CONDITION */
               ir_expression *const r0EDA = equal(swizzle_x(r0E5D), body.constant(0u));
               ir_if *f0ED9 = new(mem_ctx) ir_if(operand(r0EDA).val);
               exec_list *const f0ED9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0ED9->then_instructions;

                  ir_variable *const r0EDB = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r0EDB, r0ED4, 0x01));

                  ir_variable *const r0EDC = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r0EDD = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0EDD);
                  /* IF CONDITION */
                  ir_expression *const r0EDF = equal(swizzle_x(r0E6A), body.constant(0u));
                  ir_if *f0EDE = new(mem_ctx) ir_if(operand(r0EDF).val);
                  exec_list *const f0EDE_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0EDE->then_instructions;

                     body.emit(assign(r0EDC, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0EDE->else_instructions;

                     body.emit(assign(r0EDD, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0EE1 = bit_and(swizzle_x(r0E6A), body.constant(4294901760u));
                     ir_expression *const r0EE2 = equal(r0EE1, body.constant(0u));
                     ir_if *f0EE0 = new(mem_ctx) ir_if(operand(r0EE2).val);
                     exec_list *const f0EE0_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0EE0->then_instructions;

                        body.emit(assign(r0EDD, body.constant(int(16)), 0x01));

                        body.emit(assign(r0EDB, lshift(swizzle_x(r0E6A), body.constant(int(16))), 0x01));


                     body.instructions = f0EE0_parent_instructions;
                     body.emit(f0EE0);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0EE4 = bit_and(r0EDB, body.constant(4278190080u));
                     ir_expression *const r0EE5 = equal(r0EE4, body.constant(0u));
                     ir_if *f0EE3 = new(mem_ctx) ir_if(operand(r0EE5).val);
                     exec_list *const f0EE3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0EE3->then_instructions;

                        body.emit(assign(r0EDD, add(r0EDD, body.constant(int(8))), 0x01));

                        body.emit(assign(r0EDB, lshift(r0EDB, body.constant(int(8))), 0x01));


                     body.instructions = f0EE3_parent_instructions;
                     body.emit(f0EE3);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0EE7 = bit_and(r0EDB, body.constant(4026531840u));
                     ir_expression *const r0EE8 = equal(r0EE7, body.constant(0u));
                     ir_if *f0EE6 = new(mem_ctx) ir_if(operand(r0EE8).val);
                     exec_list *const f0EE6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0EE6->then_instructions;

                        body.emit(assign(r0EDD, add(r0EDD, body.constant(int(4))), 0x01));

                        body.emit(assign(r0EDB, lshift(r0EDB, body.constant(int(4))), 0x01));


                     body.instructions = f0EE6_parent_instructions;
                     body.emit(f0EE6);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0EEA = bit_and(r0EDB, body.constant(3221225472u));
                     ir_expression *const r0EEB = equal(r0EEA, body.constant(0u));
                     ir_if *f0EE9 = new(mem_ctx) ir_if(operand(r0EEB).val);
                     exec_list *const f0EE9_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0EE9->then_instructions;

                        body.emit(assign(r0EDD, add(r0EDD, body.constant(int(2))), 0x01));

                        body.emit(assign(r0EDB, lshift(r0EDB, body.constant(int(2))), 0x01));


                     body.instructions = f0EE9_parent_instructions;
                     body.emit(f0EE9);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0EED = bit_and(r0EDB, body.constant(2147483648u));
                     ir_expression *const r0EEE = equal(r0EED, body.constant(0u));
                     ir_if *f0EEC = new(mem_ctx) ir_if(operand(r0EEE).val);
                     exec_list *const f0EEC_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0EEC->then_instructions;

                        body.emit(assign(r0EDD, add(r0EDD, body.constant(int(1))), 0x01));


                     body.instructions = f0EEC_parent_instructions;
                     body.emit(f0EEC);

                     /* END IF */

                     body.emit(assign(r0EDC, r0EDD, 0x01));


                  body.instructions = f0EDE_parent_instructions;
                  body.emit(f0EDE);

                  /* END IF */

                  body.emit(assign(r0ED8, add(r0EDC, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r0EF0 = less(r0ED8, body.constant(int(0)));
                  ir_if *f0EEF = new(mem_ctx) ir_if(operand(r0EF0).val);
                  exec_list *const f0EEF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0EEF->then_instructions;

                     ir_expression *const r0EF1 = neg(r0ED8);
                     body.emit(assign(r0ED6, rshift(swizzle_x(r0E6A), r0EF1), 0x01));

                     ir_expression *const r0EF2 = bit_and(r0ED8, body.constant(int(31)));
                     body.emit(assign(r0ED7, lshift(swizzle_x(r0E6A), r0EF2), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0EEF->else_instructions;

                     body.emit(assign(r0ED6, lshift(swizzle_x(r0E6A), r0ED8), 0x01));

                     body.emit(assign(r0ED7, body.constant(0u), 0x01));


                  body.instructions = f0EEF_parent_instructions;
                  body.emit(f0EEF);

                  /* END IF */

                  body.emit(assign(r0ED5, sub(body.constant(int(-31)), r0ED8), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0ED9->else_instructions;

                  ir_variable *const r0EF3 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r0EF3, r0ED3, 0x01));

                  ir_variable *const r0EF4 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r0EF5 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0EF5);
                  /* IF CONDITION */
                  ir_expression *const r0EF7 = equal(swizzle_x(r0E5D), body.constant(0u));
                  ir_if *f0EF6 = new(mem_ctx) ir_if(operand(r0EF7).val);
                  exec_list *const f0EF6_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0EF6->then_instructions;

                     body.emit(assign(r0EF4, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0EF6->else_instructions;

                     body.emit(assign(r0EF5, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0EF9 = bit_and(swizzle_x(r0E5D), body.constant(4294901760u));
                     ir_expression *const r0EFA = equal(r0EF9, body.constant(0u));
                     ir_if *f0EF8 = new(mem_ctx) ir_if(operand(r0EFA).val);
                     exec_list *const f0EF8_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0EF8->then_instructions;

                        body.emit(assign(r0EF5, body.constant(int(16)), 0x01));

                        body.emit(assign(r0EF3, lshift(swizzle_x(r0E5D), body.constant(int(16))), 0x01));


                     body.instructions = f0EF8_parent_instructions;
                     body.emit(f0EF8);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0EFC = bit_and(r0EF3, body.constant(4278190080u));
                     ir_expression *const r0EFD = equal(r0EFC, body.constant(0u));
                     ir_if *f0EFB = new(mem_ctx) ir_if(operand(r0EFD).val);
                     exec_list *const f0EFB_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0EFB->then_instructions;

                        body.emit(assign(r0EF5, add(r0EF5, body.constant(int(8))), 0x01));

                        body.emit(assign(r0EF3, lshift(r0EF3, body.constant(int(8))), 0x01));


                     body.instructions = f0EFB_parent_instructions;
                     body.emit(f0EFB);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0EFF = bit_and(r0EF3, body.constant(4026531840u));
                     ir_expression *const r0F00 = equal(r0EFF, body.constant(0u));
                     ir_if *f0EFE = new(mem_ctx) ir_if(operand(r0F00).val);
                     exec_list *const f0EFE_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0EFE->then_instructions;

                        body.emit(assign(r0EF5, add(r0EF5, body.constant(int(4))), 0x01));

                        body.emit(assign(r0EF3, lshift(r0EF3, body.constant(int(4))), 0x01));


                     body.instructions = f0EFE_parent_instructions;
                     body.emit(f0EFE);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0F02 = bit_and(r0EF3, body.constant(3221225472u));
                     ir_expression *const r0F03 = equal(r0F02, body.constant(0u));
                     ir_if *f0F01 = new(mem_ctx) ir_if(operand(r0F03).val);
                     exec_list *const f0F01_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F01->then_instructions;

                        body.emit(assign(r0EF5, add(r0EF5, body.constant(int(2))), 0x01));

                        body.emit(assign(r0EF3, lshift(r0EF3, body.constant(int(2))), 0x01));


                     body.instructions = f0F01_parent_instructions;
                     body.emit(f0F01);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r0F05 = bit_and(r0EF3, body.constant(2147483648u));
                     ir_expression *const r0F06 = equal(r0F05, body.constant(0u));
                     ir_if *f0F04 = new(mem_ctx) ir_if(operand(r0F06).val);
                     exec_list *const f0F04_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F04->then_instructions;

                        body.emit(assign(r0EF5, add(r0EF5, body.constant(int(1))), 0x01));


                     body.instructions = f0F04_parent_instructions;
                     body.emit(f0F04);

                     /* END IF */

                     body.emit(assign(r0EF4, r0EF5, 0x01));


                  body.instructions = f0EF6_parent_instructions;
                  body.emit(f0EF6);

                  /* END IF */

                  body.emit(assign(r0ED8, add(r0EF4, body.constant(int(-11))), 0x01));

                  ir_variable *const r0F07 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r0F07, lshift(swizzle_x(r0E6A), r0ED8), 0x01));

                  ir_variable *const r0F08 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0F0A = equal(r0ED8, body.constant(int(0)));
                  ir_if *f0F09 = new(mem_ctx) ir_if(operand(r0F0A).val);
                  exec_list *const f0F09_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F09->then_instructions;

                     body.emit(assign(r0F08, r0ED3, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F09->else_instructions;

                     ir_expression *const r0F0B = lshift(swizzle_x(r0E5D), r0ED8);
                     ir_expression *const r0F0C = neg(r0ED8);
                     ir_expression *const r0F0D = bit_and(r0F0C, body.constant(int(31)));
                     ir_expression *const r0F0E = rshift(swizzle_x(r0E6A), r0F0D);
                     body.emit(assign(r0F08, bit_or(r0F0B, r0F0E), 0x01));


                  body.instructions = f0F09_parent_instructions;
                  body.emit(f0F09);

                  /* END IF */

                  body.emit(assign(r0ED6, r0F08, 0x01));

                  body.emit(assign(r0ED7, r0F07, 0x01));

                  body.emit(assign(r0ED5, sub(body.constant(int(1)), r0ED8), 0x01));


               body.instructions = f0ED9_parent_instructions;
               body.emit(f0ED9);

               /* END IF */

               body.emit(assign(r0E64, r0ED5, 0x01));

               body.emit(assign(r0E65, r0ED6, 0x02));

               body.emit(assign(r0E65, r0ED7, 0x01));


            body.instructions = f0ECF_parent_instructions;
            body.emit(f0ECF);

            /* END IF */


         body.instructions = f0ECD_parent_instructions;
         body.emit(f0ECD);

         /* END IF */

         /* IF CONDITION */
         ir_if *f0F0F = new(mem_ctx) ir_if(operand(r0E5F).val);
         exec_list *const f0F0F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f0F0F->then_instructions;

            /* IF CONDITION */
            ir_expression *const r0F11 = equal(r0E6F, body.constant(int(0)));
            ir_if *f0F10 = new(mem_ctx) ir_if(operand(r0F11).val);
            exec_list *const f0F10_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0F10->then_instructions;

               /* IF CONDITION */
               ir_expression *const r0F13 = bit_or(swizzle_x(r0E5E), swizzle_x(r0E6E));
               ir_expression *const r0F14 = equal(r0F13, body.constant(0u));
               ir_if *f0F12 = new(mem_ctx) ir_if(operand(r0F14).val);
               exec_list *const f0F12_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0F12->then_instructions;

                  ir_variable *const r0F15 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r0F15);
                  body.emit(assign(r0F15, lshift(r0E61, body.constant(int(31))), 0x02));

                  body.emit(assign(r0F15, body.constant(0u), 0x01));

                  body.emit(assign(r0E60, r0F15, 0x03));

                  body.emit(assign(r0E5F, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f0F12->else_instructions;

                  ir_variable *const r0F16 = body.make_temp(glsl_type::uint_type, "aFrac0");
                  body.emit(assign(r0F16, swizzle_y(r0E6E), 0x01));

                  ir_variable *const r0F17 = body.make_temp(glsl_type::uint_type, "aFrac1");
                  body.emit(assign(r0F17, swizzle_x(r0E6E), 0x01));

                  ir_variable *const r0F18 = body.make_temp(glsl_type::int_type, "zExpPtr");
                  body.emit(assign(r0F18, r0E6F, 0x01));

                  ir_variable *const r0F19 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
                  body.emit(assign(r0F19, swizzle_y(r0E6E), 0x01));

                  ir_variable *const r0F1A = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
                  body.emit(assign(r0F1A, swizzle_x(r0E6E), 0x01));

                  ir_variable *const r0F1B = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r0F1B);
                  /* IF CONDITION */
                  ir_expression *const r0F1D = equal(swizzle_x(r0E5E), body.constant(0u));
                  ir_if *f0F1C = new(mem_ctx) ir_if(operand(r0F1D).val);
                  exec_list *const f0F1C_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0F1C->then_instructions;

                     ir_variable *const r0F1E = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r0F1E, r0F17, 0x01));

                     ir_variable *const r0F1F = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r0F20 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r0F20);
                     /* IF CONDITION */
                     ir_expression *const r0F22 = equal(swizzle_x(r0E6E), body.constant(0u));
                     ir_if *f0F21 = new(mem_ctx) ir_if(operand(r0F22).val);
                     exec_list *const f0F21_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F21->then_instructions;

                        body.emit(assign(r0F1F, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0F21->else_instructions;

                        body.emit(assign(r0F20, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0F24 = bit_and(swizzle_x(r0E6E), body.constant(4294901760u));
                        ir_expression *const r0F25 = equal(r0F24, body.constant(0u));
                        ir_if *f0F23 = new(mem_ctx) ir_if(operand(r0F25).val);
                        exec_list *const f0F23_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F23->then_instructions;

                           body.emit(assign(r0F20, body.constant(int(16)), 0x01));

                           body.emit(assign(r0F1E, lshift(swizzle_x(r0E6E), body.constant(int(16))), 0x01));


                        body.instructions = f0F23_parent_instructions;
                        body.emit(f0F23);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0F27 = bit_and(r0F1E, body.constant(4278190080u));
                        ir_expression *const r0F28 = equal(r0F27, body.constant(0u));
                        ir_if *f0F26 = new(mem_ctx) ir_if(operand(r0F28).val);
                        exec_list *const f0F26_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F26->then_instructions;

                           body.emit(assign(r0F20, add(r0F20, body.constant(int(8))), 0x01));

                           body.emit(assign(r0F1E, lshift(r0F1E, body.constant(int(8))), 0x01));


                        body.instructions = f0F26_parent_instructions;
                        body.emit(f0F26);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0F2A = bit_and(r0F1E, body.constant(4026531840u));
                        ir_expression *const r0F2B = equal(r0F2A, body.constant(0u));
                        ir_if *f0F29 = new(mem_ctx) ir_if(operand(r0F2B).val);
                        exec_list *const f0F29_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F29->then_instructions;

                           body.emit(assign(r0F20, add(r0F20, body.constant(int(4))), 0x01));

                           body.emit(assign(r0F1E, lshift(r0F1E, body.constant(int(4))), 0x01));


                        body.instructions = f0F29_parent_instructions;
                        body.emit(f0F29);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0F2D = bit_and(r0F1E, body.constant(3221225472u));
                        ir_expression *const r0F2E = equal(r0F2D, body.constant(0u));
                        ir_if *f0F2C = new(mem_ctx) ir_if(operand(r0F2E).val);
                        exec_list *const f0F2C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F2C->then_instructions;

                           body.emit(assign(r0F20, add(r0F20, body.constant(int(2))), 0x01));

                           body.emit(assign(r0F1E, lshift(r0F1E, body.constant(int(2))), 0x01));


                        body.instructions = f0F2C_parent_instructions;
                        body.emit(f0F2C);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0F30 = bit_and(r0F1E, body.constant(2147483648u));
                        ir_expression *const r0F31 = equal(r0F30, body.constant(0u));
                        ir_if *f0F2F = new(mem_ctx) ir_if(operand(r0F31).val);
                        exec_list *const f0F2F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F2F->then_instructions;

                           body.emit(assign(r0F20, add(r0F20, body.constant(int(1))), 0x01));


                        body.instructions = f0F2F_parent_instructions;
                        body.emit(f0F2F);

                        /* END IF */

                        body.emit(assign(r0F1F, r0F20, 0x01));


                     body.instructions = f0F21_parent_instructions;
                     body.emit(f0F21);

                     /* END IF */

                     body.emit(assign(r0F1B, add(r0F1F, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r0F33 = less(r0F1B, body.constant(int(0)));
                     ir_if *f0F32 = new(mem_ctx) ir_if(operand(r0F33).val);
                     exec_list *const f0F32_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F32->then_instructions;

                        ir_expression *const r0F34 = neg(r0F1B);
                        body.emit(assign(r0F19, rshift(swizzle_x(r0E6E), r0F34), 0x01));

                        ir_expression *const r0F35 = bit_and(r0F1B, body.constant(int(31)));
                        body.emit(assign(r0F1A, lshift(swizzle_x(r0E6E), r0F35), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0F32->else_instructions;

                        body.emit(assign(r0F19, lshift(swizzle_x(r0E6E), r0F1B), 0x01));

                        body.emit(assign(r0F1A, body.constant(0u), 0x01));


                     body.instructions = f0F32_parent_instructions;
                     body.emit(f0F32);

                     /* END IF */

                     body.emit(assign(r0F18, sub(body.constant(int(-31)), r0F1B), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0F1C->else_instructions;

                     ir_variable *const r0F36 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r0F36, r0F16, 0x01));

                     ir_variable *const r0F37 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r0F38 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r0F38);
                     /* IF CONDITION */
                     ir_expression *const r0F3A = equal(swizzle_x(r0E5E), body.constant(0u));
                     ir_if *f0F39 = new(mem_ctx) ir_if(operand(r0F3A).val);
                     exec_list *const f0F39_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F39->then_instructions;

                        body.emit(assign(r0F37, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0F39->else_instructions;

                        body.emit(assign(r0F38, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0F3C = bit_and(swizzle_x(r0E5E), body.constant(4294901760u));
                        ir_expression *const r0F3D = equal(r0F3C, body.constant(0u));
                        ir_if *f0F3B = new(mem_ctx) ir_if(operand(r0F3D).val);
                        exec_list *const f0F3B_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F3B->then_instructions;

                           body.emit(assign(r0F38, body.constant(int(16)), 0x01));

                           body.emit(assign(r0F36, lshift(swizzle_x(r0E5E), body.constant(int(16))), 0x01));


                        body.instructions = f0F3B_parent_instructions;
                        body.emit(f0F3B);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0F3F = bit_and(r0F36, body.constant(4278190080u));
                        ir_expression *const r0F40 = equal(r0F3F, body.constant(0u));
                        ir_if *f0F3E = new(mem_ctx) ir_if(operand(r0F40).val);
                        exec_list *const f0F3E_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F3E->then_instructions;

                           body.emit(assign(r0F38, add(r0F38, body.constant(int(8))), 0x01));

                           body.emit(assign(r0F36, lshift(r0F36, body.constant(int(8))), 0x01));


                        body.instructions = f0F3E_parent_instructions;
                        body.emit(f0F3E);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0F42 = bit_and(r0F36, body.constant(4026531840u));
                        ir_expression *const r0F43 = equal(r0F42, body.constant(0u));
                        ir_if *f0F41 = new(mem_ctx) ir_if(operand(r0F43).val);
                        exec_list *const f0F41_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F41->then_instructions;

                           body.emit(assign(r0F38, add(r0F38, body.constant(int(4))), 0x01));

                           body.emit(assign(r0F36, lshift(r0F36, body.constant(int(4))), 0x01));


                        body.instructions = f0F41_parent_instructions;
                        body.emit(f0F41);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0F45 = bit_and(r0F36, body.constant(3221225472u));
                        ir_expression *const r0F46 = equal(r0F45, body.constant(0u));
                        ir_if *f0F44 = new(mem_ctx) ir_if(operand(r0F46).val);
                        exec_list *const f0F44_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F44->then_instructions;

                           body.emit(assign(r0F38, add(r0F38, body.constant(int(2))), 0x01));

                           body.emit(assign(r0F36, lshift(r0F36, body.constant(int(2))), 0x01));


                        body.instructions = f0F44_parent_instructions;
                        body.emit(f0F44);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r0F48 = bit_and(r0F36, body.constant(2147483648u));
                        ir_expression *const r0F49 = equal(r0F48, body.constant(0u));
                        ir_if *f0F47 = new(mem_ctx) ir_if(operand(r0F49).val);
                        exec_list *const f0F47_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0F47->then_instructions;

                           body.emit(assign(r0F38, add(r0F38, body.constant(int(1))), 0x01));


                        body.instructions = f0F47_parent_instructions;
                        body.emit(f0F47);

                        /* END IF */

                        body.emit(assign(r0F37, r0F38, 0x01));


                     body.instructions = f0F39_parent_instructions;
                     body.emit(f0F39);

                     /* END IF */

                     body.emit(assign(r0F1B, add(r0F37, body.constant(int(-11))), 0x01));

                     ir_variable *const r0F4A = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r0F4A, lshift(swizzle_x(r0E6E), r0F1B), 0x01));

                     ir_variable *const r0F4B = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0F4D = equal(r0F1B, body.constant(int(0)));
                     ir_if *f0F4C = new(mem_ctx) ir_if(operand(r0F4D).val);
                     exec_list *const f0F4C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0F4C->then_instructions;

                        body.emit(assign(r0F4B, r0F16, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0F4C->else_instructions;

                        ir_expression *const r0F4E = lshift(swizzle_x(r0E5E), r0F1B);
                        ir_expression *const r0F4F = neg(r0F1B);
                        ir_expression *const r0F50 = bit_and(r0F4F, body.constant(int(31)));
                        ir_expression *const r0F51 = rshift(swizzle_x(r0E6E), r0F50);
                        body.emit(assign(r0F4B, bit_or(r0F4E, r0F51), 0x01));


                     body.instructions = f0F4C_parent_instructions;
                     body.emit(f0F4C);

                     /* END IF */

                     body.emit(assign(r0F19, r0F4B, 0x01));

                     body.emit(assign(r0F1A, r0F4A, 0x01));

                     body.emit(assign(r0F18, sub(body.constant(int(1)), r0F1B), 0x01));


                  body.instructions = f0F1C_parent_instructions;
                  body.emit(f0F1C);

                  /* END IF */

                  body.emit(assign(r0E62, r0F18, 0x01));

                  body.emit(assign(r0E63, r0F19, 0x02));

                  body.emit(assign(r0E63, r0F1A, 0x01));


               body.instructions = f0F12_parent_instructions;
               body.emit(f0F12);

               /* END IF */


            body.instructions = f0F10_parent_instructions;
            body.emit(f0F10);

            /* END IF */

            /* IF CONDITION */
            ir_if *f0F52 = new(mem_ctx) ir_if(operand(r0E5F).val);
            exec_list *const f0F52_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f0F52->then_instructions;

               ir_expression *const r0F53 = add(r0E64, r0E62);
               body.emit(assign(r0E66, add(r0F53, body.constant(int(-1024))), 0x01));

               body.emit(assign(r0E65, bit_or(swizzle_y(r0E65), body.constant(1048576u)), 0x02));

               ir_variable *const r0F54 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r0F54, lshift(swizzle_x(r0E63), body.constant(int(12))), 0x01));

               ir_variable *const r0F55 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r0F56 = lshift(swizzle_y(r0E63), body.constant(int(12)));
               ir_expression *const r0F57 = rshift(swizzle_x(r0E63), body.constant(int(20)));
               body.emit(assign(r0F55, bit_or(r0F56, r0F57), 0x01));

               body.emit(assign(r0E63, r0F55, 0x02));

               body.emit(assign(r0E63, r0F54, 0x01));

               ir_variable *const r0F58 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0F58);
               ir_variable *const r0F59 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r0F59);
               ir_variable *const r0F5A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0F5A);
               ir_variable *const r0F5B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F5B, rshift(swizzle_x(r0E65), body.constant(int(16))), 0x01));

               ir_variable *const r0F5C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F5C, rshift(r0F54, body.constant(int(16))), 0x01));

               ir_variable *const r0F5D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F5D, mul(r0F5B, r0F54), 0x01));

               ir_expression *const r0F5E = mul(swizzle_x(r0E65), r0F5C);
               body.emit(assign(r0F59, add(r0F5E, r0F5D), 0x01));

               ir_expression *const r0F5F = mul(r0F5B, r0F5C);
               ir_expression *const r0F60 = less(r0F59, r0F5D);
               ir_expression *const r0F61 = expr(ir_unop_b2i, r0F60);
               ir_expression *const r0F62 = expr(ir_unop_i2u, r0F61);
               ir_expression *const r0F63 = lshift(r0F62, body.constant(int(16)));
               ir_expression *const r0F64 = rshift(r0F59, body.constant(int(16)));
               ir_expression *const r0F65 = add(r0F63, r0F64);
               body.emit(assign(r0F58, add(r0F5F, r0F65), 0x01));

               body.emit(assign(r0F59, lshift(r0F59, body.constant(int(16))), 0x01));

               ir_expression *const r0F66 = mul(swizzle_x(r0E65), r0F54);
               body.emit(assign(r0F5A, add(r0F66, r0F59), 0x01));

               ir_expression *const r0F67 = less(r0F5A, r0F59);
               ir_expression *const r0F68 = expr(ir_unop_b2i, r0F67);
               ir_expression *const r0F69 = expr(ir_unop_i2u, r0F68);
               body.emit(assign(r0F58, add(r0F58, r0F69), 0x01));

               ir_variable *const r0F6A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0F6A);
               ir_variable *const r0F6B = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r0F6B);
               ir_variable *const r0F6C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0F6C);
               ir_variable *const r0F6D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F6D, rshift(swizzle_x(r0E65), body.constant(int(16))), 0x01));

               ir_variable *const r0F6E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F6E, rshift(r0F55, body.constant(int(16))), 0x01));

               ir_variable *const r0F6F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F6F, mul(r0F6D, r0F55), 0x01));

               ir_expression *const r0F70 = mul(swizzle_x(r0E65), r0F6E);
               body.emit(assign(r0F6B, add(r0F70, r0F6F), 0x01));

               ir_expression *const r0F71 = mul(r0F6D, r0F6E);
               ir_expression *const r0F72 = less(r0F6B, r0F6F);
               ir_expression *const r0F73 = expr(ir_unop_b2i, r0F72);
               ir_expression *const r0F74 = expr(ir_unop_i2u, r0F73);
               ir_expression *const r0F75 = lshift(r0F74, body.constant(int(16)));
               ir_expression *const r0F76 = rshift(r0F6B, body.constant(int(16)));
               ir_expression *const r0F77 = add(r0F75, r0F76);
               body.emit(assign(r0F6A, add(r0F71, r0F77), 0x01));

               body.emit(assign(r0F6B, lshift(r0F6B, body.constant(int(16))), 0x01));

               ir_expression *const r0F78 = mul(swizzle_x(r0E65), r0F55);
               body.emit(assign(r0F6C, add(r0F78, r0F6B), 0x01));

               ir_expression *const r0F79 = less(r0F6C, r0F6B);
               ir_expression *const r0F7A = expr(ir_unop_b2i, r0F79);
               ir_expression *const r0F7B = expr(ir_unop_i2u, r0F7A);
               body.emit(assign(r0F6A, add(r0F6A, r0F7B), 0x01));

               ir_variable *const r0F7C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F7C, add(r0F6C, r0F58), 0x01));

               ir_variable *const r0F7D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0F7D);
               ir_variable *const r0F7E = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r0F7E);
               ir_variable *const r0F7F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0F7F);
               ir_variable *const r0F80 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F80, rshift(swizzle_y(r0E65), body.constant(int(16))), 0x01));

               ir_variable *const r0F81 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F81, rshift(r0F55, body.constant(int(16))), 0x01));

               ir_variable *const r0F82 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F82, mul(r0F80, r0F55), 0x01));

               ir_expression *const r0F83 = mul(swizzle_y(r0E65), r0F81);
               body.emit(assign(r0F7E, add(r0F83, r0F82), 0x01));

               ir_expression *const r0F84 = mul(r0F80, r0F81);
               ir_expression *const r0F85 = less(r0F7E, r0F82);
               ir_expression *const r0F86 = expr(ir_unop_b2i, r0F85);
               ir_expression *const r0F87 = expr(ir_unop_i2u, r0F86);
               ir_expression *const r0F88 = lshift(r0F87, body.constant(int(16)));
               ir_expression *const r0F89 = rshift(r0F7E, body.constant(int(16)));
               ir_expression *const r0F8A = add(r0F88, r0F89);
               body.emit(assign(r0F7D, add(r0F84, r0F8A), 0x01));

               body.emit(assign(r0F7E, lshift(r0F7E, body.constant(int(16))), 0x01));

               ir_expression *const r0F8B = mul(swizzle_y(r0E65), r0F55);
               body.emit(assign(r0F7F, add(r0F8B, r0F7E), 0x01));

               ir_expression *const r0F8C = less(r0F7F, r0F7E);
               ir_expression *const r0F8D = expr(ir_unop_b2i, r0F8C);
               ir_expression *const r0F8E = expr(ir_unop_i2u, r0F8D);
               body.emit(assign(r0F7D, add(r0F7D, r0F8E), 0x01));

               ir_variable *const r0F8F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r0F90 = less(r0F7C, r0F6C);
               ir_expression *const r0F91 = expr(ir_unop_b2i, r0F90);
               ir_expression *const r0F92 = expr(ir_unop_i2u, r0F91);
               ir_expression *const r0F93 = add(r0F6A, r0F92);
               body.emit(assign(r0F8F, add(r0F7F, r0F93), 0x01));

               ir_variable *const r0F94 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r0F94);
               ir_variable *const r0F95 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r0F95);
               ir_variable *const r0F96 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r0F96);
               ir_variable *const r0F97 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F97, rshift(swizzle_y(r0E65), body.constant(int(16))), 0x01));

               ir_variable *const r0F98 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F98, rshift(r0F54, body.constant(int(16))), 0x01));

               ir_variable *const r0F99 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0F99, mul(r0F97, r0F54), 0x01));

               ir_expression *const r0F9A = mul(swizzle_y(r0E65), r0F98);
               body.emit(assign(r0F95, add(r0F9A, r0F99), 0x01));

               ir_expression *const r0F9B = mul(r0F97, r0F98);
               ir_expression *const r0F9C = less(r0F95, r0F99);
               ir_expression *const r0F9D = expr(ir_unop_b2i, r0F9C);
               ir_expression *const r0F9E = expr(ir_unop_i2u, r0F9D);
               ir_expression *const r0F9F = lshift(r0F9E, body.constant(int(16)));
               ir_expression *const r0FA0 = rshift(r0F95, body.constant(int(16)));
               ir_expression *const r0FA1 = add(r0F9F, r0FA0);
               body.emit(assign(r0F94, add(r0F9B, r0FA1), 0x01));

               body.emit(assign(r0F95, lshift(r0F95, body.constant(int(16))), 0x01));

               ir_expression *const r0FA2 = mul(swizzle_y(r0E65), r0F54);
               body.emit(assign(r0F96, add(r0FA2, r0F95), 0x01));

               ir_expression *const r0FA3 = less(r0F96, r0F95);
               ir_expression *const r0FA4 = expr(ir_unop_b2i, r0FA3);
               ir_expression *const r0FA5 = expr(ir_unop_i2u, r0FA4);
               body.emit(assign(r0F94, add(r0F94, r0FA5), 0x01));

               ir_variable *const r0FA6 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0FA6, add(r0F96, r0F7C), 0x01));

               ir_variable *const r0FA7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r0FA8 = less(r0FA6, r0F96);
               ir_expression *const r0FA9 = expr(ir_unop_b2i, r0FA8);
               ir_expression *const r0FAA = expr(ir_unop_i2u, r0FA9);
               ir_expression *const r0FAB = add(r0F94, r0FAA);
               body.emit(assign(r0FA7, add(r0F8F, r0FAB), 0x01));

               ir_variable *const r0FAC = body.make_temp(glsl_type::uint_type, "z0Ptr");
               ir_variable *const r0FAD = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r0FAD, add(r0FA7, swizzle_x(r0E65)), 0x01));

               ir_expression *const r0FAE = less(r0F8F, r0F7F);
               ir_expression *const r0FAF = expr(ir_unop_b2i, r0FAE);
               ir_expression *const r0FB0 = expr(ir_unop_i2u, r0FAF);
               ir_expression *const r0FB1 = add(r0F7D, r0FB0);
               ir_expression *const r0FB2 = less(r0FA7, r0F8F);
               ir_expression *const r0FB3 = expr(ir_unop_b2i, r0FB2);
               ir_expression *const r0FB4 = expr(ir_unop_i2u, r0FB3);
               ir_expression *const r0FB5 = add(r0FB1, r0FB4);
               ir_expression *const r0FB6 = add(r0FB5, swizzle_y(r0E65));
               ir_expression *const r0FB7 = less(r0FAD, r0FA7);
               ir_expression *const r0FB8 = expr(ir_unop_b2i, r0FB7);
               ir_expression *const r0FB9 = expr(ir_unop_i2u, r0FB8);
               body.emit(assign(r0FAC, add(r0FB6, r0FB9), 0x01));

               body.emit(assign(r0E69, r0FAC, 0x01));

               body.emit(assign(r0E68, r0FAD, 0x01));

               ir_expression *const r0FBA = nequal(r0F5A, body.constant(0u));
               ir_expression *const r0FBB = expr(ir_unop_b2i, r0FBA);
               ir_expression *const r0FBC = expr(ir_unop_i2u, r0FBB);
               body.emit(assign(r0E67, bit_or(r0FA6, r0FBC), 0x01));

               /* IF CONDITION */
               ir_expression *const r0FBE = lequal(body.constant(2097152u), r0FAC);
               ir_if *f0FBD = new(mem_ctx) ir_if(operand(r0FBE).val);
               exec_list *const f0FBD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0FBD->then_instructions;

                  ir_variable *const r0FBF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                  body.emit(r0FBF);
                  body.emit(assign(r0FBF, lshift(r0FAD, body.constant(int(31))), 0x01));

                  ir_expression *const r0FC0 = nequal(r0E67, body.constant(0u));
                  ir_expression *const r0FC1 = expr(ir_unop_b2i, r0FC0);
                  ir_expression *const r0FC2 = expr(ir_unop_i2u, r0FC1);
                  body.emit(assign(r0FBF, bit_or(r0FBF, r0FC2), 0x01));

                  body.emit(assign(r0E69, rshift(r0FAC, body.constant(int(1))), 0x01));

                  ir_expression *const r0FC3 = lshift(r0FAC, body.constant(int(31)));
                  ir_expression *const r0FC4 = rshift(r0FAD, body.constant(int(1)));
                  body.emit(assign(r0E68, bit_or(r0FC3, r0FC4), 0x01));

                  body.emit(assign(r0E67, r0FBF, 0x01));

                  body.emit(assign(r0E66, add(r0E66, body.constant(int(1))), 0x01));


               body.instructions = f0FBD_parent_instructions;
               body.emit(f0FBD);

               /* END IF */

               ir_variable *const r0FC5 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r0FC5, r0E66, 0x01));

               ir_variable *const r0FC6 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r0FC6, r0E69, 0x01));

               ir_variable *const r0FC7 = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r0FC7, r0E68, 0x01));

               ir_variable *const r0FC8 = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r0FC8, r0E67, 0x01));

               ir_variable *const r0FC9 = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r0FC9, body.constant(true), 0x01));

               ir_variable *const r0FCA = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r0FCB = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r0FCB);
               ir_expression *const r0FCC = expr(ir_unop_u2i, r0E67);
               body.emit(assign(r0FCB, less(r0FCC, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r0FCE = lequal(body.constant(int(2045)), r0E66);
               ir_if *f0FCD = new(mem_ctx) ir_if(operand(r0FCE).val);
               exec_list *const f0FCD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0FCD->then_instructions;

                  ir_variable *const r0FCF = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r0FD1 = less(body.constant(int(2045)), r0E66);
                  ir_if *f0FD0 = new(mem_ctx) ir_if(operand(r0FD1).val);
                  exec_list *const f0FD0_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0FD0->then_instructions;

                     body.emit(assign(r0FCF, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0FD0->else_instructions;

                     ir_variable *const r0FD2 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r0FD4 = equal(r0E66, body.constant(int(2045)));
                     ir_if *f0FD3 = new(mem_ctx) ir_if(operand(r0FD4).val);
                     exec_list *const f0FD3_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FD3->then_instructions;

                        ir_expression *const r0FD5 = equal(body.constant(2097151u), r0E69);
                        ir_expression *const r0FD6 = equal(body.constant(4294967295u), r0E68);
                        body.emit(assign(r0FD2, logic_and(r0FD5, r0FD6), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f0FD3->else_instructions;

                        body.emit(assign(r0FD2, body.constant(false), 0x01));


                     body.instructions = f0FD3_parent_instructions;
                     body.emit(f0FD3);

                     /* END IF */

                     body.emit(assign(r0FCF, logic_and(r0FD2, r0FCB), 0x01));


                  body.instructions = f0FD0_parent_instructions;
                  body.emit(f0FD0);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f0FD7 = new(mem_ctx) ir_if(operand(r0FCF).val);
                  exec_list *const f0FD7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0FD7->then_instructions;

                     ir_variable *const r0FD8 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r0FD8);
                     ir_expression *const r0FD9 = lshift(r0E61, body.constant(int(31)));
                     body.emit(assign(r0FD8, add(r0FD9, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r0FD8, body.constant(0u), 0x01));

                     body.emit(assign(r0FCA, r0FD8, 0x03));

                     body.emit(assign(r0FC9, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0FD7->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r0FDB = less(r0E66, body.constant(int(0)));
                     ir_if *f0FDA = new(mem_ctx) ir_if(operand(r0FDB).val);
                     exec_list *const f0FDA_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f0FDA->then_instructions;

                        ir_variable *const r0FDC = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r0FDC, r0E67, 0x01));

                        ir_variable *const r0FDD = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r0FDD, neg(r0E66), 0x01));

                        ir_variable *const r0FDE = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r0FDE);
                        ir_variable *const r0FDF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r0FDF);
                        ir_variable *const r0FE0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r0FE0);
                        ir_variable *const r0FE1 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r0FE2 = neg(r0FDD);
                        body.emit(assign(r0FE1, bit_and(r0FE2, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r0FE4 = equal(r0FDD, body.constant(int(0)));
                        ir_if *f0FE3 = new(mem_ctx) ir_if(operand(r0FE4).val);
                        exec_list *const f0FE3_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f0FE3->then_instructions;

                           body.emit(assign(r0FDE, r0E67, 0x01));

                           body.emit(assign(r0FDF, r0E68, 0x01));

                           body.emit(assign(r0FE0, r0E69, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f0FE3->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r0FE6 = less(r0FDD, body.constant(int(32)));
                           ir_if *f0FE5 = new(mem_ctx) ir_if(operand(r0FE6).val);
                           exec_list *const f0FE5_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f0FE5->then_instructions;

                              body.emit(assign(r0FDE, lshift(r0E68, r0FE1), 0x01));

                              ir_expression *const r0FE7 = lshift(r0E69, r0FE1);
                              ir_expression *const r0FE8 = rshift(r0E68, r0FDD);
                              body.emit(assign(r0FDF, bit_or(r0FE7, r0FE8), 0x01));

                              body.emit(assign(r0FE0, rshift(r0E69, r0FDD), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f0FE5->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r0FEA = equal(r0FDD, body.constant(int(32)));
                              ir_if *f0FE9 = new(mem_ctx) ir_if(operand(r0FEA).val);
                              exec_list *const f0FE9_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f0FE9->then_instructions;

                                 body.emit(assign(r0FDE, r0E68, 0x01));

                                 body.emit(assign(r0FDF, r0E69, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f0FE9->else_instructions;

                                 body.emit(assign(r0FDC, bit_or(r0E67, r0E68), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r0FEC = less(r0FDD, body.constant(int(64)));
                                 ir_if *f0FEB = new(mem_ctx) ir_if(operand(r0FEC).val);
                                 exec_list *const f0FEB_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f0FEB->then_instructions;

                                    body.emit(assign(r0FDE, lshift(r0E69, r0FE1), 0x01));

                                    ir_expression *const r0FED = bit_and(r0FDD, body.constant(int(31)));
                                    body.emit(assign(r0FDF, rshift(r0E69, r0FED), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f0FEB->else_instructions;

                                    ir_variable *const r0FEE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r0FF0 = equal(r0FDD, body.constant(int(64)));
                                    ir_if *f0FEF = new(mem_ctx) ir_if(operand(r0FF0).val);
                                    exec_list *const f0FEF_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f0FEF->then_instructions;

                                       body.emit(assign(r0FEE, r0E69, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f0FEF->else_instructions;

                                       ir_expression *const r0FF1 = nequal(r0E69, body.constant(0u));
                                       ir_expression *const r0FF2 = expr(ir_unop_b2i, r0FF1);
                                       body.emit(assign(r0FEE, expr(ir_unop_i2u, r0FF2), 0x01));


                                    body.instructions = f0FEF_parent_instructions;
                                    body.emit(f0FEF);

                                    /* END IF */

                                    body.emit(assign(r0FDE, r0FEE, 0x01));

                                    body.emit(assign(r0FDF, body.constant(0u), 0x01));


                                 body.instructions = f0FEB_parent_instructions;
                                 body.emit(f0FEB);

                                 /* END IF */


                              body.instructions = f0FE9_parent_instructions;
                              body.emit(f0FE9);

                              /* END IF */

                              body.emit(assign(r0FE0, body.constant(0u), 0x01));


                           body.instructions = f0FE5_parent_instructions;
                           body.emit(f0FE5);

                           /* END IF */

                           ir_expression *const r0FF3 = nequal(r0FDC, body.constant(0u));
                           ir_expression *const r0FF4 = expr(ir_unop_b2i, r0FF3);
                           ir_expression *const r0FF5 = expr(ir_unop_i2u, r0FF4);
                           body.emit(assign(r0FDE, bit_or(r0FDE, r0FF5), 0x01));


                        body.instructions = f0FE3_parent_instructions;
                        body.emit(f0FE3);

                        /* END IF */

                        body.emit(assign(r0FC6, r0FE0, 0x01));

                        body.emit(assign(r0FC7, r0FDF, 0x01));

                        body.emit(assign(r0FC8, r0FDE, 0x01));

                        body.emit(assign(r0FC5, body.constant(int(0)), 0x01));

                        body.emit(assign(r0FCB, less(r0FDE, body.constant(0u)), 0x01));


                     body.instructions = f0FDA_parent_instructions;
                     body.emit(f0FDA);

                     /* END IF */


                  body.instructions = f0FD7_parent_instructions;
                  body.emit(f0FD7);

                  /* END IF */


               body.instructions = f0FCD_parent_instructions;
               body.emit(f0FCD);

               /* END IF */

               /* IF CONDITION */
               ir_if *f0FF6 = new(mem_ctx) ir_if(operand(r0FC9).val);
               exec_list *const f0FF6_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f0FF6->then_instructions;

                  /* IF CONDITION */
                  ir_if *f0FF7 = new(mem_ctx) ir_if(operand(r0FCB).val);
                  exec_list *const f0FF7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f0FF7->then_instructions;

                     ir_variable *const r0FF8 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r0FF8, add(r0FC7, body.constant(1u)), 0x01));

                     ir_expression *const r0FF9 = less(r0FF8, r0FC7);
                     ir_expression *const r0FFA = expr(ir_unop_b2i, r0FF9);
                     ir_expression *const r0FFB = expr(ir_unop_i2u, r0FFA);
                     body.emit(assign(r0FC6, add(r0FC6, r0FFB), 0x01));

                     ir_expression *const r0FFC = equal(r0FC8, body.constant(0u));
                     ir_expression *const r0FFD = expr(ir_unop_b2i, r0FFC);
                     ir_expression *const r0FFE = expr(ir_unop_i2u, r0FFD);
                     ir_expression *const r0FFF = add(r0FC8, r0FFE);
                     ir_expression *const r1000 = bit_and(r0FFF, body.constant(1u));
                     ir_expression *const r1001 = expr(ir_unop_bit_not, r1000);
                     body.emit(assign(r0FC7, bit_and(r0FF8, r1001), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f0FF7->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1003 = bit_or(r0FC6, r0FC7);
                     ir_expression *const r1004 = equal(r1003, body.constant(0u));
                     ir_if *f1002 = new(mem_ctx) ir_if(operand(r1004).val);
                     exec_list *const f1002_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1002->then_instructions;

                        body.emit(assign(r0FC5, body.constant(int(0)), 0x01));


                     body.instructions = f1002_parent_instructions;
                     body.emit(f1002);

                     /* END IF */


                  body.instructions = f0FF7_parent_instructions;
                  body.emit(f0FF7);

                  /* END IF */

                  ir_variable *const r1005 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1005);
                  ir_expression *const r1006 = lshift(r0E61, body.constant(int(31)));
                  ir_expression *const r1007 = expr(ir_unop_i2u, r0FC5);
                  ir_expression *const r1008 = lshift(r1007, body.constant(int(20)));
                  ir_expression *const r1009 = add(r1006, r1008);
                  body.emit(assign(r1005, add(r1009, r0FC6), 0x02));

                  body.emit(assign(r1005, r0FC7, 0x01));

                  body.emit(assign(r0FCA, r1005, 0x03));

                  body.emit(assign(r0FC9, body.constant(false), 0x01));


               body.instructions = f0FF6_parent_instructions;
               body.emit(f0FF6);

               /* END IF */

               body.emit(assign(r0E60, r0FCA, 0x03));

               body.emit(assign(r0E5F, body.constant(false), 0x01));


            body.instructions = f0F52_parent_instructions;
            body.emit(f0F52);

            /* END IF */


         body.instructions = f0F0F_parent_instructions;
         body.emit(f0F0F);

         /* END IF */


      body.instructions = f0EA3_parent_instructions;
      body.emit(f0EA3);

      /* END IF */


   body.instructions = f0E74_parent_instructions;
   body.emit(f0E74);

   /* END IF */

   body.emit(ret(r0E60));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
add96(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r100A = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r100A);
   ir_variable *const r100B = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r100B);
   ir_variable *const r100C = new(mem_ctx) ir_variable(glsl_type::uint_type, "a2", ir_var_function_in);
   sig_parameters.push_tail(r100C);
   ir_variable *const r100D = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r100D);
   ir_variable *const r100E = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r100E);
   ir_variable *const r100F = new(mem_ctx) ir_variable(glsl_type::uint_type, "b2", ir_var_function_in);
   sig_parameters.push_tail(r100F);
   ir_variable *const r1010 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1010);
   ir_variable *const r1011 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1011);
   ir_variable *const r1012 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1012);
   ir_variable *const r1013 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r1013);
   ir_variable *const r1014 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r1014);
   ir_variable *const r1015 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1015, add(r100C, r100F), 0x01));

   ir_variable *const r1016 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   ir_expression *const r1017 = less(r1015, r100C);
   ir_expression *const r1018 = expr(ir_unop_b2i, r1017);
   body.emit(assign(r1016, expr(ir_unop_i2u, r1018), 0x01));

   ir_variable *const r1019 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1019, add(r100B, r100E), 0x01));

   body.emit(assign(r1014, add(r1019, r1016), 0x01));

   ir_expression *const r101A = add(r100A, r100D);
   ir_expression *const r101B = less(r1014, r1016);
   ir_expression *const r101C = expr(ir_unop_b2i, r101B);
   ir_expression *const r101D = expr(ir_unop_i2u, r101C);
   body.emit(assign(r1013, add(r101A, r101D), 0x01));

   ir_expression *const r101E = less(r1019, r100B);
   ir_expression *const r101F = expr(ir_unop_b2i, r101E);
   ir_expression *const r1020 = expr(ir_unop_i2u, r101F);
   body.emit(assign(r1013, add(r1013, r1020), 0x01));

   body.emit(assign(r1012, r1015, 0x01));

   body.emit(assign(r1011, r1014, 0x01));

   body.emit(assign(r1010, r1013, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
sub96(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1021 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r1021);
   ir_variable *const r1022 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r1022);
   ir_variable *const r1023 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a2", ir_var_function_in);
   sig_parameters.push_tail(r1023);
   ir_variable *const r1024 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_function_in);
   sig_parameters.push_tail(r1024);
   ir_variable *const r1025 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b1", ir_var_function_in);
   sig_parameters.push_tail(r1025);
   ir_variable *const r1026 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b2", ir_var_function_in);
   sig_parameters.push_tail(r1026);
   ir_variable *const r1027 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1027);
   ir_variable *const r1028 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1028);
   ir_variable *const r1029 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1029);
   ir_variable *const r102A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r102A);
   ir_variable *const r102B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   ir_expression *const r102C = less(r1023, r1026);
   ir_expression *const r102D = expr(ir_unop_b2i, r102C);
   body.emit(assign(r102B, expr(ir_unop_i2u, r102D), 0x01));

   ir_variable *const r102E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r102E, sub(r1022, r1025), 0x01));

   ir_expression *const r102F = sub(r1021, r1024);
   ir_expression *const r1030 = less(r102E, r102B);
   ir_expression *const r1031 = expr(ir_unop_b2i, r1030);
   ir_expression *const r1032 = expr(ir_unop_i2u, r1031);
   body.emit(assign(r102A, sub(r102F, r1032), 0x01));

   ir_expression *const r1033 = less(r1022, r1025);
   ir_expression *const r1034 = expr(ir_unop_b2i, r1033);
   ir_expression *const r1035 = expr(ir_unop_i2u, r1034);
   body.emit(assign(r102A, sub(r102A, r1035), 0x01));

   body.emit(assign(r1029, sub(r1023, r1026), 0x01));

   body.emit(assign(r1028, sub(r102E, r102B), 0x01));

   body.emit(assign(r1027, r102A, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift64Right(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1036 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r1036);
   ir_variable *const r1037 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r1037);
   ir_variable *const r1038 = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r1038);
   ir_variable *const r1039 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1039);
   ir_variable *const r103A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r103A);
   ir_variable *const r103B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r103B);
   ir_variable *const r103C = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r103C);
   ir_variable *const r103D = body.make_temp(glsl_type::int_type, "assignment_tmp");
   ir_expression *const r103E = neg(r1038);
   body.emit(assign(r103D, bit_and(r103E, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1040 = equal(r1038, body.constant(int(0)));
   ir_if *f103F = new(mem_ctx) ir_if(operand(r1040).val);
   exec_list *const f103F_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f103F->then_instructions;

      body.emit(assign(r103B, r1037, 0x01));

      body.emit(assign(r103C, r1036, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f103F->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1042 = less(r1038, body.constant(int(32)));
      ir_if *f1041 = new(mem_ctx) ir_if(operand(r1042).val);
      exec_list *const f1041_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1041->then_instructions;

         ir_expression *const r1043 = lshift(r1036, r103D);
         ir_expression *const r1044 = rshift(r1037, r1038);
         body.emit(assign(r103B, bit_or(r1043, r1044), 0x01));

         body.emit(assign(r103C, rshift(r1036, r1038), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1041->else_instructions;

         ir_variable *const r1045 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
         /* IF CONDITION */
         ir_expression *const r1047 = less(r1038, body.constant(int(64)));
         ir_if *f1046 = new(mem_ctx) ir_if(operand(r1047).val);
         exec_list *const f1046_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1046->then_instructions;

            ir_expression *const r1048 = bit_and(r1038, body.constant(int(31)));
            body.emit(assign(r1045, rshift(r1036, r1048), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f1046->else_instructions;

            body.emit(assign(r1045, body.constant(0u), 0x01));


         body.instructions = f1046_parent_instructions;
         body.emit(f1046);

         /* END IF */

         body.emit(assign(r103B, r1045, 0x01));

         body.emit(assign(r103C, body.constant(0u), 0x01));


      body.instructions = f1041_parent_instructions;
      body.emit(f1041);

      /* END IF */


   body.instructions = f103F_parent_instructions;
   body.emit(f103F);

   /* END IF */

   body.emit(assign(r103A, r103B, 0x01));

   body.emit(assign(r1039, r103C, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
estimateDiv64To32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1049 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r1049);
   ir_variable *const r104A = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r104A);
   ir_variable *const r104B = new(mem_ctx) ir_variable(glsl_type::uint_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r104B);
   ir_variable *const r104C = body.make_temp(glsl_type::uint_type, "return_value");
   ir_variable *const r104D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
   body.emit(r104D);
   ir_variable *const r104E = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
   body.emit(r104E);
   ir_variable *const r104F = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
   body.emit(r104F);
   ir_variable *const r1050 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
   body.emit(r1050);
   body.emit(assign(r104F, body.constant(0u), 0x01));

   body.emit(assign(r104E, body.constant(0u), 0x01));

   /* IF CONDITION */
   ir_expression *const r1052 = lequal(r104B, r1049);
   ir_if *f1051 = new(mem_ctx) ir_if(operand(r1052).val);
   exec_list *const f1051_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1051->then_instructions;

      body.emit(assign(r104C, body.constant(4294967295u), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1051->else_instructions;

      body.emit(assign(r1050, rshift(r104B, body.constant(int(16))), 0x01));

      ir_variable *const r1053 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r1055 = lshift(r1050, body.constant(int(16)));
      ir_expression *const r1056 = lequal(r1055, r1049);
      ir_if *f1054 = new(mem_ctx) ir_if(operand(r1056).val);
      exec_list *const f1054_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1054->then_instructions;

         body.emit(assign(r1053, body.constant(4294901760u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1054->else_instructions;

         ir_expression *const r1057 = expr(ir_binop_div, r1049, r1050);
         body.emit(assign(r1053, lshift(r1057, body.constant(int(16))), 0x01));


      body.instructions = f1054_parent_instructions;
      body.emit(f1054);

      /* END IF */

      body.emit(assign(r104D, r1053, 0x01));

      ir_variable *const r1058 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r1058);
      ir_variable *const r1059 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
      body.emit(r1059);
      ir_variable *const r105A = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r105A);
      ir_variable *const r105B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r105B, rshift(r104B, body.constant(int(16))), 0x01));

      ir_variable *const r105C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r105C, rshift(r1053, body.constant(int(16))), 0x01));

      ir_variable *const r105D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
      body.emit(assign(r105D, mul(r105B, r1053), 0x01));

      ir_expression *const r105E = mul(r104B, r105C);
      body.emit(assign(r1059, add(r105E, r105D), 0x01));

      ir_expression *const r105F = mul(r105B, r105C);
      ir_expression *const r1060 = less(r1059, r105D);
      ir_expression *const r1061 = expr(ir_unop_b2i, r1060);
      ir_expression *const r1062 = expr(ir_unop_i2u, r1061);
      ir_expression *const r1063 = lshift(r1062, body.constant(int(16)));
      ir_expression *const r1064 = rshift(r1059, body.constant(int(16)));
      ir_expression *const r1065 = add(r1063, r1064);
      body.emit(assign(r1058, add(r105F, r1065), 0x01));

      body.emit(assign(r1059, lshift(r1059, body.constant(int(16))), 0x01));

      ir_expression *const r1066 = mul(r104B, r1053);
      body.emit(assign(r105A, add(r1066, r1059), 0x01));

      ir_expression *const r1067 = less(r105A, r1059);
      ir_expression *const r1068 = expr(ir_unop_b2i, r1067);
      ir_expression *const r1069 = expr(ir_unop_i2u, r1068);
      body.emit(assign(r1058, add(r1058, r1069), 0x01));

      ir_expression *const r106A = sub(r1049, r1058);
      ir_expression *const r106B = less(r104A, r105A);
      ir_expression *const r106C = expr(ir_unop_b2i, r106B);
      ir_expression *const r106D = expr(ir_unop_i2u, r106C);
      body.emit(assign(r104F, sub(r106A, r106D), 0x01));

      body.emit(assign(r104E, sub(r104A, r105A), 0x01));

      /* LOOP BEGIN */
      ir_loop *f106E = new(mem_ctx) ir_loop();
      exec_list *const f106E_parent_instructions = body.instructions;

         body.instructions = &f106E->body_instructions;

         /* IF CONDITION */
         ir_expression *const r1070 = gequal(r104F, body.constant(0u));
         ir_if *f106F = new(mem_ctx) ir_if(operand(r1070).val);
         exec_list *const f106F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f106F->then_instructions;

            body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


         body.instructions = f106F_parent_instructions;
         body.emit(f106F);

         /* END IF */

         body.emit(assign(r104D, add(r104D, body.constant(4294901760u)), 0x01));

         ir_variable *const r1071 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
         ir_expression *const r1072 = lshift(r104B, body.constant(int(16)));
         body.emit(assign(r1071, add(r104E, r1072), 0x01));

         ir_expression *const r1073 = add(r104F, r1050);
         ir_expression *const r1074 = less(r1071, r104E);
         ir_expression *const r1075 = expr(ir_unop_b2i, r1074);
         ir_expression *const r1076 = expr(ir_unop_i2u, r1075);
         body.emit(assign(r104F, add(r1073, r1076), 0x01));

         body.emit(assign(r104E, r1071, 0x01));

      /* LOOP END */

      body.instructions = f106E_parent_instructions;
      body.emit(f106E);

      ir_expression *const r1077 = lshift(r104F, body.constant(int(16)));
      ir_expression *const r1078 = rshift(r104E, body.constant(int(16)));
      body.emit(assign(r104F, bit_or(r1077, r1078), 0x01));

      ir_variable *const r1079 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
      /* IF CONDITION */
      ir_expression *const r107B = lshift(r1050, body.constant(int(16)));
      ir_expression *const r107C = lequal(r107B, r104F);
      ir_if *f107A = new(mem_ctx) ir_if(operand(r107C).val);
      exec_list *const f107A_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f107A->then_instructions;

         body.emit(assign(r1079, body.constant(65535u), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f107A->else_instructions;

         body.emit(assign(r1079, expr(ir_binop_div, r104F, r1050), 0x01));


      body.instructions = f107A_parent_instructions;
      body.emit(f107A);

      /* END IF */

      body.emit(assign(r104D, bit_or(r104D, r1079), 0x01));

      body.emit(assign(r104C, r104D, 0x01));


   body.instructions = f1051_parent_instructions;
   body.emit(f1051);

   /* END IF */

   body.emit(ret(r104C));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
mul64By32To96(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r107D = new(mem_ctx) ir_variable(glsl_type::uint_type, "a0", ir_var_function_in);
   sig_parameters.push_tail(r107D);
   ir_variable *const r107E = new(mem_ctx) ir_variable(glsl_type::uint_type, "a1", ir_var_function_in);
   sig_parameters.push_tail(r107E);
   ir_variable *const r107F = new(mem_ctx) ir_variable(glsl_type::uint_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r107F);
   ir_variable *const r1080 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1080);
   ir_variable *const r1081 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1081);
   ir_variable *const r1082 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2Ptr", ir_var_function_inout);
   sig_parameters.push_tail(r1082);
   ir_variable *const r1083 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r1083);
   ir_variable *const r1084 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r1084);
   ir_variable *const r1085 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r1085);
   ir_variable *const r1086 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1086, rshift(r107E, body.constant(int(16))), 0x01));

   ir_variable *const r1087 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1087, rshift(r107F, body.constant(int(16))), 0x01));

   ir_variable *const r1088 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1088, mul(r1086, r107F), 0x01));

   ir_expression *const r1089 = mul(r107E, r1087);
   body.emit(assign(r1084, add(r1089, r1088), 0x01));

   ir_expression *const r108A = mul(r1086, r1087);
   ir_expression *const r108B = less(r1084, r1088);
   ir_expression *const r108C = expr(ir_unop_b2i, r108B);
   ir_expression *const r108D = expr(ir_unop_i2u, r108C);
   ir_expression *const r108E = lshift(r108D, body.constant(int(16)));
   ir_expression *const r108F = rshift(r1084, body.constant(int(16)));
   ir_expression *const r1090 = add(r108E, r108F);
   body.emit(assign(r1083, add(r108A, r1090), 0x01));

   body.emit(assign(r1084, lshift(r1084, body.constant(int(16))), 0x01));

   ir_expression *const r1091 = mul(r107E, r107F);
   body.emit(assign(r1085, add(r1091, r1084), 0x01));

   ir_expression *const r1092 = less(r1085, r1084);
   ir_expression *const r1093 = expr(ir_unop_b2i, r1092);
   ir_expression *const r1094 = expr(ir_unop_i2u, r1093);
   body.emit(assign(r1083, add(r1083, r1094), 0x01));

   ir_variable *const r1095 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
   body.emit(r1095);
   ir_variable *const r1096 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
   body.emit(r1096);
   ir_variable *const r1097 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
   body.emit(r1097);
   ir_variable *const r1098 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1098, rshift(r107D, body.constant(int(16))), 0x01));

   ir_variable *const r1099 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r1099, rshift(r107F, body.constant(int(16))), 0x01));

   ir_variable *const r109A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r109A, mul(r1098, r107F), 0x01));

   ir_expression *const r109B = mul(r107D, r1099);
   body.emit(assign(r1096, add(r109B, r109A), 0x01));

   ir_expression *const r109C = mul(r1098, r1099);
   ir_expression *const r109D = less(r1096, r109A);
   ir_expression *const r109E = expr(ir_unop_b2i, r109D);
   ir_expression *const r109F = expr(ir_unop_i2u, r109E);
   ir_expression *const r10A0 = lshift(r109F, body.constant(int(16)));
   ir_expression *const r10A1 = rshift(r1096, body.constant(int(16)));
   ir_expression *const r10A2 = add(r10A0, r10A1);
   body.emit(assign(r1095, add(r109C, r10A2), 0x01));

   body.emit(assign(r1096, lshift(r1096, body.constant(int(16))), 0x01));

   ir_expression *const r10A3 = mul(r107D, r107F);
   body.emit(assign(r1097, add(r10A3, r1096), 0x01));

   ir_expression *const r10A4 = less(r1097, r1096);
   ir_expression *const r10A5 = expr(ir_unop_b2i, r10A4);
   ir_expression *const r10A6 = expr(ir_unop_i2u, r10A5);
   body.emit(assign(r1095, add(r1095, r10A6), 0x01));

   ir_variable *const r10A7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
   body.emit(assign(r10A7, add(r1097, r1083), 0x01));

   body.emit(assign(r1082, r1085, 0x01));

   body.emit(assign(r1081, r10A7, 0x01));

   ir_expression *const r10A8 = less(r10A7, r1097);
   ir_expression *const r10A9 = expr(ir_unop_b2i, r10A8);
   ir_expression *const r10AA = expr(ir_unop_i2u, r10A9);
   body.emit(assign(r1080, add(r1095, r10AA), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fdiv64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r10AB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r10AB);
   ir_variable *const r10AC = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "b", ir_var_function_in);
   sig_parameters.push_tail(r10AC);
   ir_variable *const r10AD = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r10AD, body.constant(true), 0x01));

   ir_variable *const r10AE = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r10AF = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_auto);
   body.emit(r10AF);
   ir_variable *const r10B0 = new(mem_ctx) ir_variable(glsl_type::int_type, "bExp", ir_var_auto);
   body.emit(r10B0);
   ir_variable *const r10B1 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "bFrac", ir_var_auto);
   body.emit(r10B1);
   ir_variable *const r10B2 = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r10B2);
   ir_variable *const r10B3 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "aFrac", ir_var_auto);
   body.emit(r10B3);
   ir_variable *const r10B4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem3", ir_var_auto);
   body.emit(r10B4);
   ir_variable *const r10B5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem2", ir_var_auto);
   body.emit(r10B5);
   ir_variable *const r10B6 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
   body.emit(r10B6);
   ir_variable *const r10B7 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
   body.emit(r10B7);
   ir_variable *const r10B8 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac1", ir_var_auto);
   body.emit(r10B8);
   ir_variable *const r10B9 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac0", ir_var_auto);
   body.emit(r10B9);
   ir_variable *const r10BA = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_auto);
   body.emit(r10BA);
   body.emit(assign(r10B9, body.constant(0u), 0x01));

   body.emit(assign(r10B8, body.constant(0u), 0x01));

   body.emit(assign(r10B7, body.constant(0u), 0x01));

   body.emit(assign(r10B6, body.constant(0u), 0x01));

   body.emit(assign(r10B5, body.constant(0u), 0x01));

   body.emit(assign(r10B4, body.constant(0u), 0x01));

   ir_variable *const r10BB = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
   body.emit(assign(r10BB, bit_and(swizzle_y(r10AB), body.constant(1048575u)), 0x01));

   body.emit(assign(r10BB, swizzle_x(r10AB), 0x02));

   body.emit(assign(r10B3, r10BB, 0x03));

   ir_variable *const r10BC = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r10BD = rshift(swizzle_y(r10AB), body.constant(int(20)));
   ir_expression *const r10BE = bit_and(r10BD, body.constant(2047u));
   body.emit(assign(r10BC, expr(ir_unop_u2i, r10BE), 0x01));

   body.emit(assign(r10B2, r10BC, 0x01));

   ir_variable *const r10BF = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
   body.emit(assign(r10BF, bit_and(swizzle_y(r10AC), body.constant(1048575u)), 0x01));

   body.emit(assign(r10BF, swizzle_x(r10AC), 0x02));

   body.emit(assign(r10B1, r10BF, 0x03));

   ir_variable *const r10C0 = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r10C1 = rshift(swizzle_y(r10AC), body.constant(int(20)));
   ir_expression *const r10C2 = bit_and(r10C1, body.constant(2047u));
   body.emit(assign(r10C0, expr(ir_unop_u2i, r10C2), 0x01));

   body.emit(assign(r10B0, r10C0, 0x01));

   ir_expression *const r10C3 = rshift(swizzle_y(r10AB), body.constant(int(31)));
   ir_expression *const r10C4 = rshift(swizzle_y(r10AC), body.constant(int(31)));
   body.emit(assign(r10AF, bit_xor(r10C3, r10C4), 0x01));

   /* IF CONDITION */
   ir_expression *const r10C6 = equal(r10BC, body.constant(int(2047)));
   ir_if *f10C5 = new(mem_ctx) ir_if(operand(r10C6).val);
   exec_list *const f10C5_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f10C5->then_instructions;

      /* IF CONDITION */
      ir_expression *const r10C8 = bit_or(swizzle_x(r10AB), swizzle_x(r10BB));
      ir_expression *const r10C9 = nequal(r10C8, body.constant(0u));
      ir_if *f10C7 = new(mem_ctx) ir_if(operand(r10C9).val);
      exec_list *const f10C7_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f10C7->then_instructions;

         ir_variable *const r10CA = body.make_temp(glsl_type::uvec2_type, "a");
         body.emit(assign(r10CA, swizzle_y(r10AB), 0x02));

         ir_variable *const r10CB = body.make_temp(glsl_type::uvec2_type, "b");
         body.emit(assign(r10CB, swizzle_y(r10AC), 0x02));

         ir_variable *const r10CC = body.make_temp(glsl_type::uvec2_type, "return_value");
         ir_variable *const r10CD = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
         ir_expression *const r10CE = rshift(swizzle_x(r10AB), body.constant(int(19)));
         ir_expression *const r10CF = bit_and(r10CE, body.constant(4095u));
         ir_expression *const r10D0 = equal(r10CF, body.constant(4094u));
         ir_expression *const r10D1 = nequal(swizzle_y(r10AB), body.constant(0u));
         ir_expression *const r10D2 = bit_and(swizzle_x(r10AB), body.constant(524287u));
         ir_expression *const r10D3 = nequal(r10D2, body.constant(0u));
         ir_expression *const r10D4 = logic_or(r10D1, r10D3);
         body.emit(assign(r10CD, logic_and(r10D0, r10D4), 0x01));

         ir_variable *const r10D5 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
         ir_expression *const r10D6 = lshift(swizzle_x(r10AC), body.constant(int(1)));
         ir_expression *const r10D7 = lequal(body.constant(4292870144u), r10D6);
         ir_expression *const r10D8 = nequal(swizzle_y(r10AC), body.constant(0u));
         ir_expression *const r10D9 = bit_and(swizzle_x(r10AC), body.constant(1048575u));
         ir_expression *const r10DA = nequal(r10D9, body.constant(0u));
         ir_expression *const r10DB = logic_or(r10D8, r10DA);
         body.emit(assign(r10D5, logic_and(r10D7, r10DB), 0x01));

         body.emit(assign(r10CA, bit_or(swizzle_x(r10AB), body.constant(524288u)), 0x01));

         body.emit(assign(r10CB, bit_or(swizzle_x(r10AC), body.constant(524288u)), 0x01));

         /* IF CONDITION */
         ir_expression *const r10DD = lshift(swizzle_x(r10AB), body.constant(int(1)));
         ir_expression *const r10DE = lequal(body.constant(4292870144u), r10DD);
         ir_expression *const r10DF = nequal(swizzle_y(r10AB), body.constant(0u));
         ir_expression *const r10E0 = bit_and(swizzle_x(r10AB), body.constant(1048575u));
         ir_expression *const r10E1 = nequal(r10E0, body.constant(0u));
         ir_expression *const r10E2 = logic_or(r10DF, r10E1);
         ir_expression *const r10E3 = logic_and(r10DE, r10E2);
         ir_if *f10DC = new(mem_ctx) ir_if(operand(r10E3).val);
         exec_list *const f10DC_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f10DC->then_instructions;

            ir_variable *const r10E4 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
            /* IF CONDITION */
            ir_expression *const r10E6 = logic_and(r10CD, r10D5);
            ir_if *f10E5 = new(mem_ctx) ir_if(operand(r10E6).val);
            exec_list *const f10E5_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f10E5->then_instructions;

               body.emit(assign(r10E4, r10CB, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f10E5->else_instructions;

               body.emit(assign(r10E4, r10CA, 0x03));


            body.instructions = f10E5_parent_instructions;
            body.emit(f10E5);

            /* END IF */

            body.emit(assign(r10CC, r10E4, 0x03));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f10DC->else_instructions;

            body.emit(assign(r10CC, r10CB, 0x03));


         body.instructions = f10DC_parent_instructions;
         body.emit(f10DC);

         /* END IF */

         body.emit(assign(r10AE, r10CC, 0x03));

         body.emit(assign(r10AD, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f10C7->else_instructions;

         /* IF CONDITION */
         ir_expression *const r10E8 = equal(r10C0, body.constant(int(2047)));
         ir_if *f10E7 = new(mem_ctx) ir_if(operand(r10E8).val);
         exec_list *const f10E7_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f10E7->then_instructions;

            /* IF CONDITION */
            ir_expression *const r10EA = bit_or(swizzle_x(r10AC), swizzle_x(r10BF));
            ir_expression *const r10EB = nequal(r10EA, body.constant(0u));
            ir_if *f10E9 = new(mem_ctx) ir_if(operand(r10EB).val);
            exec_list *const f10E9_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f10E9->then_instructions;

               ir_variable *const r10EC = body.make_temp(glsl_type::uvec2_type, "a");
               body.emit(assign(r10EC, swizzle_y(r10AB), 0x02));

               ir_variable *const r10ED = body.make_temp(glsl_type::uvec2_type, "b");
               body.emit(assign(r10ED, swizzle_y(r10AC), 0x02));

               ir_variable *const r10EE = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r10EF = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
               ir_expression *const r10F0 = rshift(swizzle_x(r10AB), body.constant(int(19)));
               ir_expression *const r10F1 = bit_and(r10F0, body.constant(4095u));
               ir_expression *const r10F2 = equal(r10F1, body.constant(4094u));
               ir_expression *const r10F3 = nequal(swizzle_y(r10AB), body.constant(0u));
               ir_expression *const r10F4 = bit_and(swizzle_x(r10AB), body.constant(524287u));
               ir_expression *const r10F5 = nequal(r10F4, body.constant(0u));
               ir_expression *const r10F6 = logic_or(r10F3, r10F5);
               body.emit(assign(r10EF, logic_and(r10F2, r10F6), 0x01));

               ir_variable *const r10F7 = body.make_temp(glsl_type::bool_type, "is_nan_retval");
               ir_expression *const r10F8 = lshift(swizzle_x(r10AC), body.constant(int(1)));
               ir_expression *const r10F9 = lequal(body.constant(4292870144u), r10F8);
               ir_expression *const r10FA = nequal(swizzle_y(r10AC), body.constant(0u));
               ir_expression *const r10FB = bit_and(swizzle_x(r10AC), body.constant(1048575u));
               ir_expression *const r10FC = nequal(r10FB, body.constant(0u));
               ir_expression *const r10FD = logic_or(r10FA, r10FC);
               body.emit(assign(r10F7, logic_and(r10F9, r10FD), 0x01));

               body.emit(assign(r10EC, bit_or(swizzle_x(r10AB), body.constant(524288u)), 0x01));

               body.emit(assign(r10ED, bit_or(swizzle_x(r10AC), body.constant(524288u)), 0x01));

               /* IF CONDITION */
               ir_expression *const r10FF = lshift(swizzle_x(r10AB), body.constant(int(1)));
               ir_expression *const r1100 = lequal(body.constant(4292870144u), r10FF);
               ir_expression *const r1101 = nequal(swizzle_y(r10AB), body.constant(0u));
               ir_expression *const r1102 = bit_and(swizzle_x(r10AB), body.constant(1048575u));
               ir_expression *const r1103 = nequal(r1102, body.constant(0u));
               ir_expression *const r1104 = logic_or(r1101, r1103);
               ir_expression *const r1105 = logic_and(r1100, r1104);
               ir_if *f10FE = new(mem_ctx) ir_if(operand(r1105).val);
               exec_list *const f10FE_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f10FE->then_instructions;

                  ir_variable *const r1106 = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1108 = logic_and(r10EF, r10F7);
                  ir_if *f1107 = new(mem_ctx) ir_if(operand(r1108).val);
                  exec_list *const f1107_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1107->then_instructions;

                     body.emit(assign(r1106, r10ED, 0x03));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1107->else_instructions;

                     body.emit(assign(r1106, r10EC, 0x03));


                  body.instructions = f1107_parent_instructions;
                  body.emit(f1107);

                  /* END IF */

                  body.emit(assign(r10EE, r1106, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f10FE->else_instructions;

                  body.emit(assign(r10EE, r10ED, 0x03));


               body.instructions = f10FE_parent_instructions;
               body.emit(f10FE);

               /* END IF */

               body.emit(assign(r10AE, r10EE, 0x03));

               body.emit(assign(r10AD, body.constant(false), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f10E9->else_instructions;

               ir_constant_data r1109_data;
               memset(&r1109_data, 0, sizeof(ir_constant_data));
               r1109_data.u[0] = 4294967295;
               r1109_data.u[1] = 4294967295;
               ir_constant *const r1109 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r1109_data);
               body.emit(assign(r10AE, r1109, 0x03));

               body.emit(assign(r10AD, body.constant(false), 0x01));


            body.instructions = f10E9_parent_instructions;
            body.emit(f10E9);

            /* END IF */


            /* ELSE INSTRUCTIONS */
            body.instructions = &f10E7->else_instructions;

            ir_variable *const r110A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r110A);
            ir_expression *const r110B = lshift(r10AF, body.constant(int(31)));
            body.emit(assign(r110A, add(r110B, body.constant(2146435072u)), 0x02));

            body.emit(assign(r110A, body.constant(0u), 0x01));

            body.emit(assign(r10AE, r110A, 0x03));

            body.emit(assign(r10AD, body.constant(false), 0x01));


         body.instructions = f10E7_parent_instructions;
         body.emit(f10E7);

         /* END IF */


      body.instructions = f10C7_parent_instructions;
      body.emit(f10C7);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f10C5->else_instructions;

      /* IF CONDITION */
      ir_expression *const r110D = equal(r10C0, body.constant(int(2047)));
      ir_if *f110C = new(mem_ctx) ir_if(operand(r110D).val);
      exec_list *const f110C_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f110C->then_instructions;

         /* IF CONDITION */
         ir_expression *const r110F = bit_or(swizzle_x(r10AC), swizzle_x(r10BF));
         ir_expression *const r1110 = nequal(r110F, body.constant(0u));
         ir_if *f110E = new(mem_ctx) ir_if(operand(r1110).val);
         exec_list *const f110E_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f110E->then_instructions;

            ir_variable *const r1111 = body.make_temp(glsl_type::uvec2_type, "a");
            body.emit(assign(r1111, swizzle_y(r10AB), 0x02));

            ir_variable *const r1112 = body.make_temp(glsl_type::uvec2_type, "b");
            body.emit(assign(r1112, swizzle_y(r10AC), 0x02));

            ir_variable *const r1113 = body.make_temp(glsl_type::uvec2_type, "return_value");
            ir_variable *const r1114 = body.make_temp(glsl_type::bool_type, "float64_is_signaling_nan_retval");
            ir_expression *const r1115 = rshift(swizzle_x(r10AB), body.constant(int(19)));
            ir_expression *const r1116 = bit_and(r1115, body.constant(4095u));
            ir_expression *const r1117 = equal(r1116, body.constant(4094u));
            ir_expression *const r1118 = nequal(swizzle_y(r10AB), body.constant(0u));
            ir_expression *const r1119 = bit_and(swizzle_x(r10AB), body.constant(524287u));
            ir_expression *const r111A = nequal(r1119, body.constant(0u));
            ir_expression *const r111B = logic_or(r1118, r111A);
            body.emit(assign(r1114, logic_and(r1117, r111B), 0x01));

            ir_variable *const r111C = body.make_temp(glsl_type::bool_type, "is_nan_retval");
            ir_expression *const r111D = lshift(swizzle_x(r10AC), body.constant(int(1)));
            ir_expression *const r111E = lequal(body.constant(4292870144u), r111D);
            ir_expression *const r111F = nequal(swizzle_y(r10AC), body.constant(0u));
            ir_expression *const r1120 = bit_and(swizzle_x(r10AC), body.constant(1048575u));
            ir_expression *const r1121 = nequal(r1120, body.constant(0u));
            ir_expression *const r1122 = logic_or(r111F, r1121);
            body.emit(assign(r111C, logic_and(r111E, r1122), 0x01));

            body.emit(assign(r1111, bit_or(swizzle_x(r10AB), body.constant(524288u)), 0x01));

            body.emit(assign(r1112, bit_or(swizzle_x(r10AC), body.constant(524288u)), 0x01));

            /* IF CONDITION */
            ir_expression *const r1124 = lshift(swizzle_x(r10AB), body.constant(int(1)));
            ir_expression *const r1125 = lequal(body.constant(4292870144u), r1124);
            ir_expression *const r1126 = nequal(swizzle_y(r10AB), body.constant(0u));
            ir_expression *const r1127 = bit_and(swizzle_x(r10AB), body.constant(1048575u));
            ir_expression *const r1128 = nequal(r1127, body.constant(0u));
            ir_expression *const r1129 = logic_or(r1126, r1128);
            ir_expression *const r112A = logic_and(r1125, r1129);
            ir_if *f1123 = new(mem_ctx) ir_if(operand(r112A).val);
            exec_list *const f1123_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1123->then_instructions;

               ir_variable *const r112B = body.make_temp(glsl_type::uvec2_type, "conditional_tmp");
               /* IF CONDITION */
               ir_expression *const r112D = logic_and(r1114, r111C);
               ir_if *f112C = new(mem_ctx) ir_if(operand(r112D).val);
               exec_list *const f112C_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f112C->then_instructions;

                  body.emit(assign(r112B, r1112, 0x03));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f112C->else_instructions;

                  body.emit(assign(r112B, r1111, 0x03));


               body.instructions = f112C_parent_instructions;
               body.emit(f112C);

               /* END IF */

               body.emit(assign(r1113, r112B, 0x03));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1123->else_instructions;

               body.emit(assign(r1113, r1112, 0x03));


            body.instructions = f1123_parent_instructions;
            body.emit(f1123);

            /* END IF */

            body.emit(assign(r10AE, r1113, 0x03));

            body.emit(assign(r10AD, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f110E->else_instructions;

            ir_variable *const r112E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
            body.emit(r112E);
            body.emit(assign(r112E, lshift(r10AF, body.constant(int(31))), 0x02));

            body.emit(assign(r112E, body.constant(0u), 0x01));

            body.emit(assign(r10AE, r112E, 0x03));

            body.emit(assign(r10AD, body.constant(false), 0x01));


         body.instructions = f110E_parent_instructions;
         body.emit(f110E);

         /* END IF */


         /* ELSE INSTRUCTIONS */
         body.instructions = &f110C->else_instructions;

         /* IF CONDITION */
         ir_expression *const r1130 = equal(r10C0, body.constant(int(0)));
         ir_if *f112F = new(mem_ctx) ir_if(operand(r1130).val);
         exec_list *const f112F_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f112F->then_instructions;

            /* IF CONDITION */
            ir_expression *const r1132 = bit_or(swizzle_x(r10AC), swizzle_x(r10BF));
            ir_expression *const r1133 = equal(r1132, body.constant(0u));
            ir_if *f1131 = new(mem_ctx) ir_if(operand(r1133).val);
            exec_list *const f1131_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1131->then_instructions;

               /* IF CONDITION */
               ir_expression *const r1135 = expr(ir_unop_i2u, r10BC);
               ir_expression *const r1136 = bit_or(r1135, swizzle_x(r10AB));
               ir_expression *const r1137 = bit_or(r1136, swizzle_x(r10BB));
               ir_expression *const r1138 = equal(r1137, body.constant(0u));
               ir_if *f1134 = new(mem_ctx) ir_if(operand(r1138).val);
               exec_list *const f1134_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1134->then_instructions;

                  ir_constant_data r1139_data;
                  memset(&r1139_data, 0, sizeof(ir_constant_data));
                  r1139_data.u[0] = 4294967295;
                  r1139_data.u[1] = 4294967295;
                  ir_constant *const r1139 = new(mem_ctx) ir_constant(glsl_type::uvec2_type, &r1139_data);
                  body.emit(assign(r10AE, r1139, 0x03));

                  body.emit(assign(r10AD, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1134->else_instructions;

                  ir_variable *const r113A = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r113A);
                  ir_expression *const r113B = lshift(r10AF, body.constant(int(31)));
                  body.emit(assign(r113A, add(r113B, body.constant(2146435072u)), 0x02));

                  body.emit(assign(r113A, body.constant(0u), 0x01));

                  body.emit(assign(r10AE, r113A, 0x03));

                  body.emit(assign(r10AD, body.constant(false), 0x01));


               body.instructions = f1134_parent_instructions;
               body.emit(f1134);

               /* END IF */


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1131->else_instructions;

               ir_variable *const r113C = body.make_temp(glsl_type::uint_type, "aFrac0");
               body.emit(assign(r113C, swizzle_y(r10BF), 0x01));

               ir_variable *const r113D = body.make_temp(glsl_type::uint_type, "aFrac1");
               body.emit(assign(r113D, swizzle_x(r10BF), 0x01));

               ir_variable *const r113E = body.make_temp(glsl_type::int_type, "zExpPtr");
               body.emit(assign(r113E, r10C0, 0x01));

               ir_variable *const r113F = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
               body.emit(assign(r113F, swizzle_y(r10BF), 0x01));

               ir_variable *const r1140 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
               body.emit(assign(r1140, swizzle_x(r10BF), 0x01));

               ir_variable *const r1141 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
               body.emit(r1141);
               /* IF CONDITION */
               ir_expression *const r1143 = equal(swizzle_x(r10AC), body.constant(0u));
               ir_if *f1142 = new(mem_ctx) ir_if(operand(r1143).val);
               exec_list *const f1142_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1142->then_instructions;

                  ir_variable *const r1144 = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r1144, r113D, 0x01));

                  ir_variable *const r1145 = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r1146 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r1146);
                  /* IF CONDITION */
                  ir_expression *const r1148 = equal(swizzle_x(r10BF), body.constant(0u));
                  ir_if *f1147 = new(mem_ctx) ir_if(operand(r1148).val);
                  exec_list *const f1147_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1147->then_instructions;

                     body.emit(assign(r1145, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1147->else_instructions;

                     body.emit(assign(r1146, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r114A = bit_and(swizzle_x(r10BF), body.constant(4294901760u));
                     ir_expression *const r114B = equal(r114A, body.constant(0u));
                     ir_if *f1149 = new(mem_ctx) ir_if(operand(r114B).val);
                     exec_list *const f1149_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1149->then_instructions;

                        body.emit(assign(r1146, body.constant(int(16)), 0x01));

                        body.emit(assign(r1144, lshift(swizzle_x(r10BF), body.constant(int(16))), 0x01));


                     body.instructions = f1149_parent_instructions;
                     body.emit(f1149);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r114D = bit_and(r1144, body.constant(4278190080u));
                     ir_expression *const r114E = equal(r114D, body.constant(0u));
                     ir_if *f114C = new(mem_ctx) ir_if(operand(r114E).val);
                     exec_list *const f114C_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f114C->then_instructions;

                        body.emit(assign(r1146, add(r1146, body.constant(int(8))), 0x01));

                        body.emit(assign(r1144, lshift(r1144, body.constant(int(8))), 0x01));


                     body.instructions = f114C_parent_instructions;
                     body.emit(f114C);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1150 = bit_and(r1144, body.constant(4026531840u));
                     ir_expression *const r1151 = equal(r1150, body.constant(0u));
                     ir_if *f114F = new(mem_ctx) ir_if(operand(r1151).val);
                     exec_list *const f114F_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f114F->then_instructions;

                        body.emit(assign(r1146, add(r1146, body.constant(int(4))), 0x01));

                        body.emit(assign(r1144, lshift(r1144, body.constant(int(4))), 0x01));


                     body.instructions = f114F_parent_instructions;
                     body.emit(f114F);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1153 = bit_and(r1144, body.constant(3221225472u));
                     ir_expression *const r1154 = equal(r1153, body.constant(0u));
                     ir_if *f1152 = new(mem_ctx) ir_if(operand(r1154).val);
                     exec_list *const f1152_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1152->then_instructions;

                        body.emit(assign(r1146, add(r1146, body.constant(int(2))), 0x01));

                        body.emit(assign(r1144, lshift(r1144, body.constant(int(2))), 0x01));


                     body.instructions = f1152_parent_instructions;
                     body.emit(f1152);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1156 = bit_and(r1144, body.constant(2147483648u));
                     ir_expression *const r1157 = equal(r1156, body.constant(0u));
                     ir_if *f1155 = new(mem_ctx) ir_if(operand(r1157).val);
                     exec_list *const f1155_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1155->then_instructions;

                        body.emit(assign(r1146, add(r1146, body.constant(int(1))), 0x01));


                     body.instructions = f1155_parent_instructions;
                     body.emit(f1155);

                     /* END IF */

                     body.emit(assign(r1145, r1146, 0x01));


                  body.instructions = f1147_parent_instructions;
                  body.emit(f1147);

                  /* END IF */

                  body.emit(assign(r1141, add(r1145, body.constant(int(-11))), 0x01));

                  /* IF CONDITION */
                  ir_expression *const r1159 = less(r1141, body.constant(int(0)));
                  ir_if *f1158 = new(mem_ctx) ir_if(operand(r1159).val);
                  exec_list *const f1158_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1158->then_instructions;

                     ir_expression *const r115A = neg(r1141);
                     body.emit(assign(r113F, rshift(swizzle_x(r10BF), r115A), 0x01));

                     ir_expression *const r115B = bit_and(r1141, body.constant(int(31)));
                     body.emit(assign(r1140, lshift(swizzle_x(r10BF), r115B), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1158->else_instructions;

                     body.emit(assign(r113F, lshift(swizzle_x(r10BF), r1141), 0x01));

                     body.emit(assign(r1140, body.constant(0u), 0x01));


                  body.instructions = f1158_parent_instructions;
                  body.emit(f1158);

                  /* END IF */

                  body.emit(assign(r113E, sub(body.constant(int(-31)), r1141), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1142->else_instructions;

                  ir_variable *const r115C = body.make_temp(glsl_type::uint_type, "a");
                  body.emit(assign(r115C, r113C, 0x01));

                  ir_variable *const r115D = body.make_temp(glsl_type::int_type, "return_value");
                  ir_variable *const r115E = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r115E);
                  /* IF CONDITION */
                  ir_expression *const r1160 = equal(swizzle_x(r10AC), body.constant(0u));
                  ir_if *f115F = new(mem_ctx) ir_if(operand(r1160).val);
                  exec_list *const f115F_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f115F->then_instructions;

                     body.emit(assign(r115D, body.constant(int(32)), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f115F->else_instructions;

                     body.emit(assign(r115E, body.constant(int(0)), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r1162 = bit_and(swizzle_x(r10AC), body.constant(4294901760u));
                     ir_expression *const r1163 = equal(r1162, body.constant(0u));
                     ir_if *f1161 = new(mem_ctx) ir_if(operand(r1163).val);
                     exec_list *const f1161_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1161->then_instructions;

                        body.emit(assign(r115E, body.constant(int(16)), 0x01));

                        body.emit(assign(r115C, lshift(swizzle_x(r10AC), body.constant(int(16))), 0x01));


                     body.instructions = f1161_parent_instructions;
                     body.emit(f1161);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1165 = bit_and(r115C, body.constant(4278190080u));
                     ir_expression *const r1166 = equal(r1165, body.constant(0u));
                     ir_if *f1164 = new(mem_ctx) ir_if(operand(r1166).val);
                     exec_list *const f1164_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1164->then_instructions;

                        body.emit(assign(r115E, add(r115E, body.constant(int(8))), 0x01));

                        body.emit(assign(r115C, lshift(r115C, body.constant(int(8))), 0x01));


                     body.instructions = f1164_parent_instructions;
                     body.emit(f1164);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r1168 = bit_and(r115C, body.constant(4026531840u));
                     ir_expression *const r1169 = equal(r1168, body.constant(0u));
                     ir_if *f1167 = new(mem_ctx) ir_if(operand(r1169).val);
                     exec_list *const f1167_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1167->then_instructions;

                        body.emit(assign(r115E, add(r115E, body.constant(int(4))), 0x01));

                        body.emit(assign(r115C, lshift(r115C, body.constant(int(4))), 0x01));


                     body.instructions = f1167_parent_instructions;
                     body.emit(f1167);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r116B = bit_and(r115C, body.constant(3221225472u));
                     ir_expression *const r116C = equal(r116B, body.constant(0u));
                     ir_if *f116A = new(mem_ctx) ir_if(operand(r116C).val);
                     exec_list *const f116A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f116A->then_instructions;

                        body.emit(assign(r115E, add(r115E, body.constant(int(2))), 0x01));

                        body.emit(assign(r115C, lshift(r115C, body.constant(int(2))), 0x01));


                     body.instructions = f116A_parent_instructions;
                     body.emit(f116A);

                     /* END IF */

                     /* IF CONDITION */
                     ir_expression *const r116E = bit_and(r115C, body.constant(2147483648u));
                     ir_expression *const r116F = equal(r116E, body.constant(0u));
                     ir_if *f116D = new(mem_ctx) ir_if(operand(r116F).val);
                     exec_list *const f116D_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f116D->then_instructions;

                        body.emit(assign(r115E, add(r115E, body.constant(int(1))), 0x01));


                     body.instructions = f116D_parent_instructions;
                     body.emit(f116D);

                     /* END IF */

                     body.emit(assign(r115D, r115E, 0x01));


                  body.instructions = f115F_parent_instructions;
                  body.emit(f115F);

                  /* END IF */

                  body.emit(assign(r1141, add(r115D, body.constant(int(-11))), 0x01));

                  ir_variable *const r1170 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                  body.emit(assign(r1170, lshift(swizzle_x(r10BF), r1141), 0x01));

                  ir_variable *const r1171 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1173 = equal(r1141, body.constant(int(0)));
                  ir_if *f1172 = new(mem_ctx) ir_if(operand(r1173).val);
                  exec_list *const f1172_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1172->then_instructions;

                     body.emit(assign(r1171, r113C, 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1172->else_instructions;

                     ir_expression *const r1174 = lshift(swizzle_x(r10AC), r1141);
                     ir_expression *const r1175 = neg(r1141);
                     ir_expression *const r1176 = bit_and(r1175, body.constant(int(31)));
                     ir_expression *const r1177 = rshift(swizzle_x(r10BF), r1176);
                     body.emit(assign(r1171, bit_or(r1174, r1177), 0x01));


                  body.instructions = f1172_parent_instructions;
                  body.emit(f1172);

                  /* END IF */

                  body.emit(assign(r113F, r1171, 0x01));

                  body.emit(assign(r1140, r1170, 0x01));

                  body.emit(assign(r113E, sub(body.constant(int(1)), r1141), 0x01));


               body.instructions = f1142_parent_instructions;
               body.emit(f1142);

               /* END IF */

               body.emit(assign(r10B0, r113E, 0x01));

               body.emit(assign(r10B1, r113F, 0x02));

               body.emit(assign(r10B1, r1140, 0x01));


            body.instructions = f1131_parent_instructions;
            body.emit(f1131);

            /* END IF */


         body.instructions = f112F_parent_instructions;
         body.emit(f112F);

         /* END IF */

         /* IF CONDITION */
         ir_if *f1178 = new(mem_ctx) ir_if(operand(r10AD).val);
         exec_list *const f1178_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1178->then_instructions;

            /* IF CONDITION */
            ir_expression *const r117A = equal(r10BC, body.constant(int(0)));
            ir_if *f1179 = new(mem_ctx) ir_if(operand(r117A).val);
            exec_list *const f1179_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1179->then_instructions;

               /* IF CONDITION */
               ir_expression *const r117C = bit_or(swizzle_x(r10AB), swizzle_x(r10BB));
               ir_expression *const r117D = equal(r117C, body.constant(0u));
               ir_if *f117B = new(mem_ctx) ir_if(operand(r117D).val);
               exec_list *const f117B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f117B->then_instructions;

                  ir_variable *const r117E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r117E);
                  body.emit(assign(r117E, lshift(r10AF, body.constant(int(31))), 0x02));

                  body.emit(assign(r117E, body.constant(0u), 0x01));

                  body.emit(assign(r10AE, r117E, 0x03));

                  body.emit(assign(r10AD, body.constant(false), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f117B->else_instructions;

                  ir_variable *const r117F = body.make_temp(glsl_type::uint_type, "aFrac0");
                  body.emit(assign(r117F, swizzle_y(r10BB), 0x01));

                  ir_variable *const r1180 = body.make_temp(glsl_type::uint_type, "aFrac1");
                  body.emit(assign(r1180, swizzle_x(r10BB), 0x01));

                  ir_variable *const r1181 = body.make_temp(glsl_type::int_type, "zExpPtr");
                  body.emit(assign(r1181, r10BC, 0x01));

                  ir_variable *const r1182 = body.make_temp(glsl_type::uint_type, "zFrac0Ptr");
                  body.emit(assign(r1182, swizzle_y(r10BB), 0x01));

                  ir_variable *const r1183 = body.make_temp(glsl_type::uint_type, "zFrac1Ptr");
                  body.emit(assign(r1183, swizzle_x(r10BB), 0x01));

                  ir_variable *const r1184 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                  body.emit(r1184);
                  /* IF CONDITION */
                  ir_expression *const r1186 = equal(swizzle_x(r10AB), body.constant(0u));
                  ir_if *f1185 = new(mem_ctx) ir_if(operand(r1186).val);
                  exec_list *const f1185_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1185->then_instructions;

                     ir_variable *const r1187 = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r1187, r1180, 0x01));

                     ir_variable *const r1188 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r1189 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r1189);
                     /* IF CONDITION */
                     ir_expression *const r118B = equal(swizzle_x(r10BB), body.constant(0u));
                     ir_if *f118A = new(mem_ctx) ir_if(operand(r118B).val);
                     exec_list *const f118A_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f118A->then_instructions;

                        body.emit(assign(r1188, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f118A->else_instructions;

                        body.emit(assign(r1189, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r118D = bit_and(swizzle_x(r10BB), body.constant(4294901760u));
                        ir_expression *const r118E = equal(r118D, body.constant(0u));
                        ir_if *f118C = new(mem_ctx) ir_if(operand(r118E).val);
                        exec_list *const f118C_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f118C->then_instructions;

                           body.emit(assign(r1189, body.constant(int(16)), 0x01));

                           body.emit(assign(r1187, lshift(swizzle_x(r10BB), body.constant(int(16))), 0x01));


                        body.instructions = f118C_parent_instructions;
                        body.emit(f118C);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1190 = bit_and(r1187, body.constant(4278190080u));
                        ir_expression *const r1191 = equal(r1190, body.constant(0u));
                        ir_if *f118F = new(mem_ctx) ir_if(operand(r1191).val);
                        exec_list *const f118F_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f118F->then_instructions;

                           body.emit(assign(r1189, add(r1189, body.constant(int(8))), 0x01));

                           body.emit(assign(r1187, lshift(r1187, body.constant(int(8))), 0x01));


                        body.instructions = f118F_parent_instructions;
                        body.emit(f118F);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1193 = bit_and(r1187, body.constant(4026531840u));
                        ir_expression *const r1194 = equal(r1193, body.constant(0u));
                        ir_if *f1192 = new(mem_ctx) ir_if(operand(r1194).val);
                        exec_list *const f1192_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1192->then_instructions;

                           body.emit(assign(r1189, add(r1189, body.constant(int(4))), 0x01));

                           body.emit(assign(r1187, lshift(r1187, body.constant(int(4))), 0x01));


                        body.instructions = f1192_parent_instructions;
                        body.emit(f1192);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1196 = bit_and(r1187, body.constant(3221225472u));
                        ir_expression *const r1197 = equal(r1196, body.constant(0u));
                        ir_if *f1195 = new(mem_ctx) ir_if(operand(r1197).val);
                        exec_list *const f1195_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1195->then_instructions;

                           body.emit(assign(r1189, add(r1189, body.constant(int(2))), 0x01));

                           body.emit(assign(r1187, lshift(r1187, body.constant(int(2))), 0x01));


                        body.instructions = f1195_parent_instructions;
                        body.emit(f1195);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r1199 = bit_and(r1187, body.constant(2147483648u));
                        ir_expression *const r119A = equal(r1199, body.constant(0u));
                        ir_if *f1198 = new(mem_ctx) ir_if(operand(r119A).val);
                        exec_list *const f1198_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f1198->then_instructions;

                           body.emit(assign(r1189, add(r1189, body.constant(int(1))), 0x01));


                        body.instructions = f1198_parent_instructions;
                        body.emit(f1198);

                        /* END IF */

                        body.emit(assign(r1188, r1189, 0x01));


                     body.instructions = f118A_parent_instructions;
                     body.emit(f118A);

                     /* END IF */

                     body.emit(assign(r1184, add(r1188, body.constant(int(-11))), 0x01));

                     /* IF CONDITION */
                     ir_expression *const r119C = less(r1184, body.constant(int(0)));
                     ir_if *f119B = new(mem_ctx) ir_if(operand(r119C).val);
                     exec_list *const f119B_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f119B->then_instructions;

                        ir_expression *const r119D = neg(r1184);
                        body.emit(assign(r1182, rshift(swizzle_x(r10BB), r119D), 0x01));

                        ir_expression *const r119E = bit_and(r1184, body.constant(int(31)));
                        body.emit(assign(r1183, lshift(swizzle_x(r10BB), r119E), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f119B->else_instructions;

                        body.emit(assign(r1182, lshift(swizzle_x(r10BB), r1184), 0x01));

                        body.emit(assign(r1183, body.constant(0u), 0x01));


                     body.instructions = f119B_parent_instructions;
                     body.emit(f119B);

                     /* END IF */

                     body.emit(assign(r1181, sub(body.constant(int(-31)), r1184), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1185->else_instructions;

                     ir_variable *const r119F = body.make_temp(glsl_type::uint_type, "a");
                     body.emit(assign(r119F, r117F, 0x01));

                     ir_variable *const r11A0 = body.make_temp(glsl_type::int_type, "return_value");
                     ir_variable *const r11A1 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
                     body.emit(r11A1);
                     /* IF CONDITION */
                     ir_expression *const r11A3 = equal(swizzle_x(r10AB), body.constant(0u));
                     ir_if *f11A2 = new(mem_ctx) ir_if(operand(r11A3).val);
                     exec_list *const f11A2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f11A2->then_instructions;

                        body.emit(assign(r11A0, body.constant(int(32)), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f11A2->else_instructions;

                        body.emit(assign(r11A1, body.constant(int(0)), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r11A5 = bit_and(swizzle_x(r10AB), body.constant(4294901760u));
                        ir_expression *const r11A6 = equal(r11A5, body.constant(0u));
                        ir_if *f11A4 = new(mem_ctx) ir_if(operand(r11A6).val);
                        exec_list *const f11A4_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f11A4->then_instructions;

                           body.emit(assign(r11A1, body.constant(int(16)), 0x01));

                           body.emit(assign(r119F, lshift(swizzle_x(r10AB), body.constant(int(16))), 0x01));


                        body.instructions = f11A4_parent_instructions;
                        body.emit(f11A4);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r11A8 = bit_and(r119F, body.constant(4278190080u));
                        ir_expression *const r11A9 = equal(r11A8, body.constant(0u));
                        ir_if *f11A7 = new(mem_ctx) ir_if(operand(r11A9).val);
                        exec_list *const f11A7_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f11A7->then_instructions;

                           body.emit(assign(r11A1, add(r11A1, body.constant(int(8))), 0x01));

                           body.emit(assign(r119F, lshift(r119F, body.constant(int(8))), 0x01));


                        body.instructions = f11A7_parent_instructions;
                        body.emit(f11A7);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r11AB = bit_and(r119F, body.constant(4026531840u));
                        ir_expression *const r11AC = equal(r11AB, body.constant(0u));
                        ir_if *f11AA = new(mem_ctx) ir_if(operand(r11AC).val);
                        exec_list *const f11AA_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f11AA->then_instructions;

                           body.emit(assign(r11A1, add(r11A1, body.constant(int(4))), 0x01));

                           body.emit(assign(r119F, lshift(r119F, body.constant(int(4))), 0x01));


                        body.instructions = f11AA_parent_instructions;
                        body.emit(f11AA);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r11AE = bit_and(r119F, body.constant(3221225472u));
                        ir_expression *const r11AF = equal(r11AE, body.constant(0u));
                        ir_if *f11AD = new(mem_ctx) ir_if(operand(r11AF).val);
                        exec_list *const f11AD_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f11AD->then_instructions;

                           body.emit(assign(r11A1, add(r11A1, body.constant(int(2))), 0x01));

                           body.emit(assign(r119F, lshift(r119F, body.constant(int(2))), 0x01));


                        body.instructions = f11AD_parent_instructions;
                        body.emit(f11AD);

                        /* END IF */

                        /* IF CONDITION */
                        ir_expression *const r11B1 = bit_and(r119F, body.constant(2147483648u));
                        ir_expression *const r11B2 = equal(r11B1, body.constant(0u));
                        ir_if *f11B0 = new(mem_ctx) ir_if(operand(r11B2).val);
                        exec_list *const f11B0_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f11B0->then_instructions;

                           body.emit(assign(r11A1, add(r11A1, body.constant(int(1))), 0x01));


                        body.instructions = f11B0_parent_instructions;
                        body.emit(f11B0);

                        /* END IF */

                        body.emit(assign(r11A0, r11A1, 0x01));


                     body.instructions = f11A2_parent_instructions;
                     body.emit(f11A2);

                     /* END IF */

                     body.emit(assign(r1184, add(r11A0, body.constant(int(-11))), 0x01));

                     ir_variable *const r11B3 = body.make_temp(glsl_type::uint_type, "z1Ptr");
                     body.emit(assign(r11B3, lshift(swizzle_x(r10BB), r1184), 0x01));

                     ir_variable *const r11B4 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                     /* IF CONDITION */
                     ir_expression *const r11B6 = equal(r1184, body.constant(int(0)));
                     ir_if *f11B5 = new(mem_ctx) ir_if(operand(r11B6).val);
                     exec_list *const f11B5_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f11B5->then_instructions;

                        body.emit(assign(r11B4, r117F, 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f11B5->else_instructions;

                        ir_expression *const r11B7 = lshift(swizzle_x(r10AB), r1184);
                        ir_expression *const r11B8 = neg(r1184);
                        ir_expression *const r11B9 = bit_and(r11B8, body.constant(int(31)));
                        ir_expression *const r11BA = rshift(swizzle_x(r10BB), r11B9);
                        body.emit(assign(r11B4, bit_or(r11B7, r11BA), 0x01));


                     body.instructions = f11B5_parent_instructions;
                     body.emit(f11B5);

                     /* END IF */

                     body.emit(assign(r1182, r11B4, 0x01));

                     body.emit(assign(r1183, r11B3, 0x01));

                     body.emit(assign(r1181, sub(body.constant(int(1)), r1184), 0x01));


                  body.instructions = f1185_parent_instructions;
                  body.emit(f1185);

                  /* END IF */

                  body.emit(assign(r10B2, r1181, 0x01));

                  body.emit(assign(r10B3, r1182, 0x02));

                  body.emit(assign(r10B3, r1183, 0x01));


               body.instructions = f117B_parent_instructions;
               body.emit(f117B);

               /* END IF */


            body.instructions = f1179_parent_instructions;
            body.emit(f1179);

            /* END IF */

            /* IF CONDITION */
            ir_if *f11BB = new(mem_ctx) ir_if(operand(r10AD).val);
            exec_list *const f11BB_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f11BB->then_instructions;

               ir_expression *const r11BC = sub(r10B2, r10B0);
               body.emit(assign(r10BA, add(r11BC, body.constant(int(1021))), 0x01));

               ir_variable *const r11BD = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r11BD, lshift(swizzle_x(r10B3), body.constant(int(11))), 0x01));

               ir_variable *const r11BE = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r11BF = bit_or(swizzle_y(r10B3), body.constant(1048576u));
               ir_expression *const r11C0 = lshift(r11BF, body.constant(int(11)));
               ir_expression *const r11C1 = rshift(swizzle_x(r10B3), body.constant(int(21)));
               body.emit(assign(r11BE, bit_or(r11C0, r11C1), 0x01));

               body.emit(assign(r10B3, r11BE, 0x02));

               body.emit(assign(r10B3, r11BD, 0x01));

               ir_variable *const r11C2 = body.make_temp(glsl_type::uint_type, "z1Ptr");
               body.emit(assign(r11C2, lshift(swizzle_x(r10B1), body.constant(int(11))), 0x01));

               ir_variable *const r11C3 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
               ir_expression *const r11C4 = bit_or(swizzle_y(r10B1), body.constant(1048576u));
               ir_expression *const r11C5 = lshift(r11C4, body.constant(int(11)));
               ir_expression *const r11C6 = rshift(swizzle_x(r10B1), body.constant(int(21)));
               body.emit(assign(r11C3, bit_or(r11C5, r11C6), 0x01));

               body.emit(assign(r10B1, r11C3, 0x02));

               body.emit(assign(r10B1, r11C2, 0x01));

               /* IF CONDITION */
               ir_expression *const r11C8 = less(r11C3, r11BE);
               ir_expression *const r11C9 = equal(r11C3, r11BE);
               ir_expression *const r11CA = lequal(r11C2, r11BD);
               ir_expression *const r11CB = logic_and(r11C9, r11CA);
               ir_expression *const r11CC = logic_or(r11C8, r11CB);
               ir_if *f11C7 = new(mem_ctx) ir_if(operand(r11CC).val);
               exec_list *const f11C7_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f11C7->then_instructions;

                  body.emit(assign(r10B3, rshift(r11BE, body.constant(int(1))), 0x02));

                  ir_expression *const r11CD = lshift(r11BE, body.constant(int(31)));
                  ir_expression *const r11CE = rshift(r11BD, body.constant(int(1)));
                  body.emit(assign(r10B3, bit_or(r11CD, r11CE), 0x01));

                  body.emit(assign(r10BA, add(r10BA, body.constant(int(1))), 0x01));


               body.instructions = f11C7_parent_instructions;
               body.emit(f11C7);

               /* END IF */

               ir_variable *const r11CF = body.make_temp(glsl_type::uint_type, "return_value");
               ir_variable *const r11D0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r11D0);
               ir_variable *const r11D1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
               body.emit(r11D1);
               ir_variable *const r11D2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
               body.emit(r11D2);
               ir_variable *const r11D3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
               body.emit(r11D3);
               body.emit(assign(r11D2, body.constant(0u), 0x01));

               body.emit(assign(r11D1, body.constant(0u), 0x01));

               /* IF CONDITION */
               ir_expression *const r11D5 = lequal(r11C3, swizzle_y(r10B3));
               ir_if *f11D4 = new(mem_ctx) ir_if(operand(r11D5).val);
               exec_list *const f11D4_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f11D4->then_instructions;

                  body.emit(assign(r11CF, body.constant(4294967295u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f11D4->else_instructions;

                  body.emit(assign(r11D3, rshift(r11C3, body.constant(int(16))), 0x01));

                  ir_variable *const r11D6 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r11D8 = lshift(r11D3, body.constant(int(16)));
                  ir_expression *const r11D9 = lequal(r11D8, swizzle_y(r10B3));
                  ir_if *f11D7 = new(mem_ctx) ir_if(operand(r11D9).val);
                  exec_list *const f11D7_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f11D7->then_instructions;

                     body.emit(assign(r11D6, body.constant(4294901760u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f11D7->else_instructions;

                     ir_expression *const r11DA = expr(ir_binop_div, swizzle_y(r10B3), r11D3);
                     body.emit(assign(r11D6, lshift(r11DA, body.constant(int(16))), 0x01));


                  body.instructions = f11D7_parent_instructions;
                  body.emit(f11D7);

                  /* END IF */

                  body.emit(assign(r11D0, r11D6, 0x01));

                  ir_variable *const r11DB = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r11DB);
                  ir_variable *const r11DC = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r11DC);
                  ir_variable *const r11DD = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r11DD);
                  ir_variable *const r11DE = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r11DE, rshift(r11C3, body.constant(int(16))), 0x01));

                  ir_variable *const r11DF = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r11DF, rshift(r11D6, body.constant(int(16))), 0x01));

                  ir_variable *const r11E0 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r11E0, mul(r11DE, r11D6), 0x01));

                  ir_expression *const r11E1 = mul(r11C3, r11DF);
                  body.emit(assign(r11DC, add(r11E1, r11E0), 0x01));

                  ir_expression *const r11E2 = mul(r11DE, r11DF);
                  ir_expression *const r11E3 = less(r11DC, r11E0);
                  ir_expression *const r11E4 = expr(ir_unop_b2i, r11E3);
                  ir_expression *const r11E5 = expr(ir_unop_i2u, r11E4);
                  ir_expression *const r11E6 = lshift(r11E5, body.constant(int(16)));
                  ir_expression *const r11E7 = rshift(r11DC, body.constant(int(16)));
                  ir_expression *const r11E8 = add(r11E6, r11E7);
                  body.emit(assign(r11DB, add(r11E2, r11E8), 0x01));

                  body.emit(assign(r11DC, lshift(r11DC, body.constant(int(16))), 0x01));

                  ir_expression *const r11E9 = mul(r11C3, r11D6);
                  body.emit(assign(r11DD, add(r11E9, r11DC), 0x01));

                  ir_expression *const r11EA = less(r11DD, r11DC);
                  ir_expression *const r11EB = expr(ir_unop_b2i, r11EA);
                  ir_expression *const r11EC = expr(ir_unop_i2u, r11EB);
                  body.emit(assign(r11DB, add(r11DB, r11EC), 0x01));

                  ir_expression *const r11ED = sub(swizzle_y(r10B3), r11DB);
                  ir_expression *const r11EE = less(swizzle_x(r10B3), r11DD);
                  ir_expression *const r11EF = expr(ir_unop_b2i, r11EE);
                  ir_expression *const r11F0 = expr(ir_unop_i2u, r11EF);
                  body.emit(assign(r11D2, sub(r11ED, r11F0), 0x01));

                  body.emit(assign(r11D1, sub(swizzle_x(r10B3), r11DD), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f11F1 = new(mem_ctx) ir_loop();
                  exec_list *const f11F1_parent_instructions = body.instructions;

                     body.instructions = &f11F1->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r11F3 = gequal(r11D2, body.constant(0u));
                     ir_if *f11F2 = new(mem_ctx) ir_if(operand(r11F3).val);
                     exec_list *const f11F2_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f11F2->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f11F2_parent_instructions;
                     body.emit(f11F2);

                     /* END IF */

                     body.emit(assign(r11D0, add(r11D0, body.constant(4294901760u)), 0x01));

                     ir_variable *const r11F4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r11F5 = lshift(r11C3, body.constant(int(16)));
                     body.emit(assign(r11F4, add(r11D1, r11F5), 0x01));

                     ir_expression *const r11F6 = add(r11D2, r11D3);
                     ir_expression *const r11F7 = less(r11F4, r11D1);
                     ir_expression *const r11F8 = expr(ir_unop_b2i, r11F7);
                     ir_expression *const r11F9 = expr(ir_unop_i2u, r11F8);
                     body.emit(assign(r11D2, add(r11F6, r11F9), 0x01));

                     body.emit(assign(r11D1, r11F4, 0x01));

                  /* LOOP END */

                  body.instructions = f11F1_parent_instructions;
                  body.emit(f11F1);

                  ir_expression *const r11FA = lshift(r11D2, body.constant(int(16)));
                  ir_expression *const r11FB = rshift(r11D1, body.constant(int(16)));
                  body.emit(assign(r11D2, bit_or(r11FA, r11FB), 0x01));

                  ir_variable *const r11FC = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r11FE = lshift(r11D3, body.constant(int(16)));
                  ir_expression *const r11FF = lequal(r11FE, r11D2);
                  ir_if *f11FD = new(mem_ctx) ir_if(operand(r11FF).val);
                  exec_list *const f11FD_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f11FD->then_instructions;

                     body.emit(assign(r11FC, body.constant(65535u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f11FD->else_instructions;

                     body.emit(assign(r11FC, expr(ir_binop_div, r11D2, r11D3), 0x01));


                  body.instructions = f11FD_parent_instructions;
                  body.emit(f11FD);

                  /* END IF */

                  body.emit(assign(r11D0, bit_or(r11D0, r11FC), 0x01));

                  body.emit(assign(r11CF, r11D0, 0x01));


               body.instructions = f11D4_parent_instructions;
               body.emit(f11D4);

               /* END IF */

               body.emit(assign(r10B9, r11CF, 0x01));

               ir_variable *const r1200 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1200);
               ir_variable *const r1201 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r1201);
               ir_variable *const r1202 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1202);
               ir_variable *const r1203 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1203, rshift(r11C2, body.constant(int(16))), 0x01));

               ir_variable *const r1204 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1204, rshift(r11CF, body.constant(int(16))), 0x01));

               ir_variable *const r1205 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1205, mul(r1203, r11CF), 0x01));

               ir_expression *const r1206 = mul(r11C2, r1204);
               body.emit(assign(r1201, add(r1206, r1205), 0x01));

               ir_expression *const r1207 = mul(r1203, r1204);
               ir_expression *const r1208 = less(r1201, r1205);
               ir_expression *const r1209 = expr(ir_unop_b2i, r1208);
               ir_expression *const r120A = expr(ir_unop_i2u, r1209);
               ir_expression *const r120B = lshift(r120A, body.constant(int(16)));
               ir_expression *const r120C = rshift(r1201, body.constant(int(16)));
               ir_expression *const r120D = add(r120B, r120C);
               body.emit(assign(r1200, add(r1207, r120D), 0x01));

               body.emit(assign(r1201, lshift(r1201, body.constant(int(16))), 0x01));

               ir_expression *const r120E = mul(r11C2, r11CF);
               body.emit(assign(r1202, add(r120E, r1201), 0x01));

               ir_expression *const r120F = less(r1202, r1201);
               ir_expression *const r1210 = expr(ir_unop_b2i, r120F);
               ir_expression *const r1211 = expr(ir_unop_i2u, r1210);
               body.emit(assign(r1200, add(r1200, r1211), 0x01));

               ir_variable *const r1212 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1212);
               ir_variable *const r1213 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
               body.emit(r1213);
               ir_variable *const r1214 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r1214);
               ir_variable *const r1215 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1215, rshift(r11C3, body.constant(int(16))), 0x01));

               ir_variable *const r1216 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1216, rshift(r11CF, body.constant(int(16))), 0x01));

               ir_variable *const r1217 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1217, mul(r1215, r11CF), 0x01));

               ir_expression *const r1218 = mul(r11C3, r1216);
               body.emit(assign(r1213, add(r1218, r1217), 0x01));

               ir_expression *const r1219 = mul(r1215, r1216);
               ir_expression *const r121A = less(r1213, r1217);
               ir_expression *const r121B = expr(ir_unop_b2i, r121A);
               ir_expression *const r121C = expr(ir_unop_i2u, r121B);
               ir_expression *const r121D = lshift(r121C, body.constant(int(16)));
               ir_expression *const r121E = rshift(r1213, body.constant(int(16)));
               ir_expression *const r121F = add(r121D, r121E);
               body.emit(assign(r1212, add(r1219, r121F), 0x01));

               body.emit(assign(r1213, lshift(r1213, body.constant(int(16))), 0x01));

               ir_expression *const r1220 = mul(r11C3, r11CF);
               body.emit(assign(r1214, add(r1220, r1213), 0x01));

               ir_expression *const r1221 = less(r1214, r1213);
               ir_expression *const r1222 = expr(ir_unop_b2i, r1221);
               ir_expression *const r1223 = expr(ir_unop_i2u, r1222);
               body.emit(assign(r1212, add(r1212, r1223), 0x01));

               ir_variable *const r1224 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1224, add(r1214, r1200), 0x01));

               ir_variable *const r1225 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r1225);
               ir_variable *const r1226 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               ir_expression *const r1227 = less(body.constant(0u), r1202);
               ir_expression *const r1228 = expr(ir_unop_b2i, r1227);
               body.emit(assign(r1226, expr(ir_unop_i2u, r1228), 0x01));

               ir_variable *const r1229 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
               body.emit(assign(r1229, sub(swizzle_x(r10B3), r1224), 0x01));

               ir_expression *const r122A = less(r1224, r1214);
               ir_expression *const r122B = expr(ir_unop_b2i, r122A);
               ir_expression *const r122C = expr(ir_unop_i2u, r122B);
               ir_expression *const r122D = add(r1212, r122C);
               ir_expression *const r122E = sub(swizzle_y(r10B3), r122D);
               ir_expression *const r122F = less(r1229, r1226);
               ir_expression *const r1230 = expr(ir_unop_b2i, r122F);
               ir_expression *const r1231 = expr(ir_unop_i2u, r1230);
               body.emit(assign(r1225, sub(r122E, r1231), 0x01));

               ir_expression *const r1232 = less(swizzle_x(r10B3), r1224);
               ir_expression *const r1233 = expr(ir_unop_b2i, r1232);
               ir_expression *const r1234 = expr(ir_unop_i2u, r1233);
               body.emit(assign(r1225, sub(r1225, r1234), 0x01));

               body.emit(assign(r10B7, r1225, 0x01));

               body.emit(assign(r10B6, sub(r1229, r1226), 0x01));

               body.emit(assign(r10B5, neg(r1202), 0x01));

               /* LOOP BEGIN */
               ir_loop *f1235 = new(mem_ctx) ir_loop();
               exec_list *const f1235_parent_instructions = body.instructions;

                  body.instructions = &f1235->body_instructions;

                  /* IF CONDITION */
                  ir_expression *const r1237 = gequal(r10B7, body.constant(0u));
                  ir_if *f1236 = new(mem_ctx) ir_if(operand(r1237).val);
                  exec_list *const f1236_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1236->then_instructions;

                     body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                  body.instructions = f1236_parent_instructions;
                  body.emit(f1236);

                  /* END IF */

                  body.emit(assign(r10B9, add(r10B9, body.constant(4294967295u)), 0x01));

                  ir_variable *const r1238 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1238);
                  ir_variable *const r1239 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1239);
                  ir_variable *const r123A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r123A, add(r10B5, r11C2), 0x01));

                  ir_variable *const r123B = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  ir_expression *const r123C = less(r123A, r10B5);
                  ir_expression *const r123D = expr(ir_unop_b2i, r123C);
                  body.emit(assign(r123B, expr(ir_unop_i2u, r123D), 0x01));

                  ir_variable *const r123E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r123E, add(r10B6, r11C3), 0x01));

                  body.emit(assign(r1239, add(r123E, r123B), 0x01));

                  ir_expression *const r123F = less(r1239, r123B);
                  ir_expression *const r1240 = expr(ir_unop_b2i, r123F);
                  ir_expression *const r1241 = expr(ir_unop_i2u, r1240);
                  body.emit(assign(r1238, add(r10B7, r1241), 0x01));

                  ir_expression *const r1242 = less(r123E, r10B6);
                  ir_expression *const r1243 = expr(ir_unop_b2i, r1242);
                  ir_expression *const r1244 = expr(ir_unop_i2u, r1243);
                  body.emit(assign(r1238, add(r1238, r1244), 0x01));

                  body.emit(assign(r10B7, r1238, 0x01));

                  body.emit(assign(r10B6, r1239, 0x01));

                  body.emit(assign(r10B5, r123A, 0x01));

               /* LOOP END */

               body.instructions = f1235_parent_instructions;
               body.emit(f1235);

               ir_variable *const r1245 = body.make_temp(glsl_type::uint_type, "return_value");
               ir_variable *const r1246 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r1246);
               ir_variable *const r1247 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem1", ir_var_auto);
               body.emit(r1247);
               ir_variable *const r1248 = new(mem_ctx) ir_variable(glsl_type::uint_type, "rem0", ir_var_auto);
               body.emit(r1248);
               ir_variable *const r1249 = new(mem_ctx) ir_variable(glsl_type::uint_type, "b0", ir_var_auto);
               body.emit(r1249);
               body.emit(assign(r1248, body.constant(0u), 0x01));

               body.emit(assign(r1247, body.constant(0u), 0x01));

               /* IF CONDITION */
               ir_expression *const r124B = lequal(r11C3, r10B6);
               ir_if *f124A = new(mem_ctx) ir_if(operand(r124B).val);
               exec_list *const f124A_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f124A->then_instructions;

                  body.emit(assign(r1245, body.constant(4294967295u), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f124A->else_instructions;

                  body.emit(assign(r1249, rshift(r11C3, body.constant(int(16))), 0x01));

                  ir_variable *const r124C = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r124E = lshift(r1249, body.constant(int(16)));
                  ir_expression *const r124F = lequal(r124E, r10B6);
                  ir_if *f124D = new(mem_ctx) ir_if(operand(r124F).val);
                  exec_list *const f124D_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f124D->then_instructions;

                     body.emit(assign(r124C, body.constant(4294901760u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f124D->else_instructions;

                     ir_expression *const r1250 = expr(ir_binop_div, r10B6, r1249);
                     body.emit(assign(r124C, lshift(r1250, body.constant(int(16))), 0x01));


                  body.instructions = f124D_parent_instructions;
                  body.emit(f124D);

                  /* END IF */

                  body.emit(assign(r1246, r124C, 0x01));

                  ir_variable *const r1251 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1251);
                  ir_variable *const r1252 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r1252);
                  ir_variable *const r1253 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r1253);
                  ir_variable *const r1254 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1254, rshift(r11C3, body.constant(int(16))), 0x01));

                  ir_variable *const r1255 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1255, rshift(r124C, body.constant(int(16))), 0x01));

                  ir_variable *const r1256 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1256, mul(r1254, r124C), 0x01));

                  ir_expression *const r1257 = mul(r11C3, r1255);
                  body.emit(assign(r1252, add(r1257, r1256), 0x01));

                  ir_expression *const r1258 = mul(r1254, r1255);
                  ir_expression *const r1259 = less(r1252, r1256);
                  ir_expression *const r125A = expr(ir_unop_b2i, r1259);
                  ir_expression *const r125B = expr(ir_unop_i2u, r125A);
                  ir_expression *const r125C = lshift(r125B, body.constant(int(16)));
                  ir_expression *const r125D = rshift(r1252, body.constant(int(16)));
                  ir_expression *const r125E = add(r125C, r125D);
                  body.emit(assign(r1251, add(r1258, r125E), 0x01));

                  body.emit(assign(r1252, lshift(r1252, body.constant(int(16))), 0x01));

                  ir_expression *const r125F = mul(r11C3, r124C);
                  body.emit(assign(r1253, add(r125F, r1252), 0x01));

                  ir_expression *const r1260 = less(r1253, r1252);
                  ir_expression *const r1261 = expr(ir_unop_b2i, r1260);
                  ir_expression *const r1262 = expr(ir_unop_i2u, r1261);
                  body.emit(assign(r1251, add(r1251, r1262), 0x01));

                  ir_expression *const r1263 = sub(r10B6, r1251);
                  ir_expression *const r1264 = less(r10B5, r1253);
                  ir_expression *const r1265 = expr(ir_unop_b2i, r1264);
                  ir_expression *const r1266 = expr(ir_unop_i2u, r1265);
                  body.emit(assign(r1248, sub(r1263, r1266), 0x01));

                  body.emit(assign(r1247, sub(r10B5, r1253), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f1267 = new(mem_ctx) ir_loop();
                  exec_list *const f1267_parent_instructions = body.instructions;

                     body.instructions = &f1267->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1269 = gequal(r1248, body.constant(0u));
                     ir_if *f1268 = new(mem_ctx) ir_if(operand(r1269).val);
                     exec_list *const f1268_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1268->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f1268_parent_instructions;
                     body.emit(f1268);

                     /* END IF */

                     body.emit(assign(r1246, add(r1246, body.constant(4294901760u)), 0x01));

                     ir_variable *const r126A = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r126B = lshift(r11C3, body.constant(int(16)));
                     body.emit(assign(r126A, add(r1247, r126B), 0x01));

                     ir_expression *const r126C = add(r1248, r1249);
                     ir_expression *const r126D = less(r126A, r1247);
                     ir_expression *const r126E = expr(ir_unop_b2i, r126D);
                     ir_expression *const r126F = expr(ir_unop_i2u, r126E);
                     body.emit(assign(r1248, add(r126C, r126F), 0x01));

                     body.emit(assign(r1247, r126A, 0x01));

                  /* LOOP END */

                  body.instructions = f1267_parent_instructions;
                  body.emit(f1267);

                  ir_expression *const r1270 = lshift(r1248, body.constant(int(16)));
                  ir_expression *const r1271 = rshift(r1247, body.constant(int(16)));
                  body.emit(assign(r1248, bit_or(r1270, r1271), 0x01));

                  ir_variable *const r1272 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                  /* IF CONDITION */
                  ir_expression *const r1274 = lshift(r1249, body.constant(int(16)));
                  ir_expression *const r1275 = lequal(r1274, r1248);
                  ir_if *f1273 = new(mem_ctx) ir_if(operand(r1275).val);
                  exec_list *const f1273_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f1273->then_instructions;

                     body.emit(assign(r1272, body.constant(65535u), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f1273->else_instructions;

                     body.emit(assign(r1272, expr(ir_binop_div, r1248, r1249), 0x01));


                  body.instructions = f1273_parent_instructions;
                  body.emit(f1273);

                  /* END IF */

                  body.emit(assign(r1246, bit_or(r1246, r1272), 0x01));

                  body.emit(assign(r1245, r1246, 0x01));


               body.instructions = f124A_parent_instructions;
               body.emit(f124A);

               /* END IF */

               body.emit(assign(r10B8, r1245, 0x01));

               /* IF CONDITION */
               ir_expression *const r1277 = bit_and(r1245, body.constant(1023u));
               ir_expression *const r1278 = lequal(r1277, body.constant(4u));
               ir_if *f1276 = new(mem_ctx) ir_if(operand(r1278).val);
               exec_list *const f1276_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1276->then_instructions;

                  ir_variable *const r1279 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r1279);
                  ir_variable *const r127A = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r127A);
                  ir_variable *const r127B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r127B);
                  ir_variable *const r127C = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r127C, rshift(r11C2, body.constant(int(16))), 0x01));

                  ir_variable *const r127D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r127D, rshift(r1245, body.constant(int(16))), 0x01));

                  ir_variable *const r127E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r127E, mul(r127C, r1245), 0x01));

                  ir_expression *const r127F = mul(r11C2, r127D);
                  body.emit(assign(r127A, add(r127F, r127E), 0x01));

                  ir_expression *const r1280 = mul(r127C, r127D);
                  ir_expression *const r1281 = less(r127A, r127E);
                  ir_expression *const r1282 = expr(ir_unop_b2i, r1281);
                  ir_expression *const r1283 = expr(ir_unop_i2u, r1282);
                  ir_expression *const r1284 = lshift(r1283, body.constant(int(16)));
                  ir_expression *const r1285 = rshift(r127A, body.constant(int(16)));
                  ir_expression *const r1286 = add(r1284, r1285);
                  body.emit(assign(r1279, add(r1280, r1286), 0x01));

                  body.emit(assign(r127A, lshift(r127A, body.constant(int(16))), 0x01));

                  ir_expression *const r1287 = mul(r11C2, r1245);
                  body.emit(assign(r127B, add(r1287, r127A), 0x01));

                  ir_expression *const r1288 = less(r127B, r127A);
                  ir_expression *const r1289 = expr(ir_unop_b2i, r1288);
                  ir_expression *const r128A = expr(ir_unop_i2u, r1289);
                  body.emit(assign(r1279, add(r1279, r128A), 0x01));

                  ir_variable *const r128B = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r128B);
                  ir_variable *const r128C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zMiddleA", ir_var_auto);
                  body.emit(r128C);
                  ir_variable *const r128D = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                  body.emit(r128D);
                  ir_variable *const r128E = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r128E, rshift(r11C3, body.constant(int(16))), 0x01));

                  ir_variable *const r128F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r128F, rshift(r1245, body.constant(int(16))), 0x01));

                  ir_variable *const r1290 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r1290, mul(r128E, r1245), 0x01));

                  ir_expression *const r1291 = mul(r11C3, r128F);
                  body.emit(assign(r128C, add(r1291, r1290), 0x01));

                  ir_expression *const r1292 = mul(r128E, r128F);
                  ir_expression *const r1293 = less(r128C, r1290);
                  ir_expression *const r1294 = expr(ir_unop_b2i, r1293);
                  ir_expression *const r1295 = expr(ir_unop_i2u, r1294);
                  ir_expression *const r1296 = lshift(r1295, body.constant(int(16)));
                  ir_expression *const r1297 = rshift(r128C, body.constant(int(16)));
                  ir_expression *const r1298 = add(r1296, r1297);
                  body.emit(assign(r128B, add(r1292, r1298), 0x01));

                  body.emit(assign(r128C, lshift(r128C, body.constant(int(16))), 0x01));

                  ir_expression *const r1299 = mul(r11C3, r1245);
                  body.emit(assign(r128D, add(r1299, r128C), 0x01));

                  ir_expression *const r129A = less(r128D, r128C);
                  ir_expression *const r129B = expr(ir_unop_b2i, r129A);
                  ir_expression *const r129C = expr(ir_unop_i2u, r129B);
                  body.emit(assign(r128B, add(r128B, r129C), 0x01));

                  ir_variable *const r129D = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r129D, add(r128D, r1279), 0x01));

                  ir_variable *const r129E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                  body.emit(r129E);
                  ir_variable *const r129F = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  ir_expression *const r12A0 = less(body.constant(0u), r127B);
                  ir_expression *const r12A1 = expr(ir_unop_b2i, r12A0);
                  body.emit(assign(r129F, expr(ir_unop_i2u, r12A1), 0x01));

                  ir_variable *const r12A2 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                  body.emit(assign(r12A2, sub(r10B5, r129D), 0x01));

                  ir_expression *const r12A3 = less(r129D, r128D);
                  ir_expression *const r12A4 = expr(ir_unop_b2i, r12A3);
                  ir_expression *const r12A5 = expr(ir_unop_i2u, r12A4);
                  ir_expression *const r12A6 = add(r128B, r12A5);
                  ir_expression *const r12A7 = sub(r10B6, r12A6);
                  ir_expression *const r12A8 = less(r12A2, r129F);
                  ir_expression *const r12A9 = expr(ir_unop_b2i, r12A8);
                  ir_expression *const r12AA = expr(ir_unop_i2u, r12A9);
                  body.emit(assign(r129E, sub(r12A7, r12AA), 0x01));

                  ir_expression *const r12AB = less(r10B5, r129D);
                  ir_expression *const r12AC = expr(ir_unop_b2i, r12AB);
                  ir_expression *const r12AD = expr(ir_unop_i2u, r12AC);
                  body.emit(assign(r129E, sub(r129E, r12AD), 0x01));

                  body.emit(assign(r10B6, r129E, 0x01));

                  body.emit(assign(r10B5, sub(r12A2, r129F), 0x01));

                  body.emit(assign(r10B4, neg(r127B), 0x01));

                  /* LOOP BEGIN */
                  ir_loop *f12AE = new(mem_ctx) ir_loop();
                  exec_list *const f12AE_parent_instructions = body.instructions;

                     body.instructions = &f12AE->body_instructions;

                     /* IF CONDITION */
                     ir_expression *const r12B0 = gequal(r10B6, body.constant(0u));
                     ir_if *f12AF = new(mem_ctx) ir_if(operand(r12B0).val);
                     exec_list *const f12AF_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f12AF->then_instructions;

                        body.emit(new(mem_ctx) ir_loop_jump(ir_loop_jump::jump_break));


                     body.instructions = f12AF_parent_instructions;
                     body.emit(f12AF);

                     /* END IF */

                     body.emit(assign(r10B8, add(r10B8, body.constant(4294967295u)), 0x01));

                     ir_variable *const r12B1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                     body.emit(r12B1);
                     ir_variable *const r12B2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                     body.emit(r12B2);
                     ir_variable *const r12B3 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r12B3, add(r10B4, r11C2), 0x01));

                     ir_variable *const r12B4 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     ir_expression *const r12B5 = less(r12B3, r10B4);
                     ir_expression *const r12B6 = expr(ir_unop_b2i, r12B5);
                     body.emit(assign(r12B4, expr(ir_unop_i2u, r12B6), 0x01));

                     ir_variable *const r12B7 = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r12B7, add(r10B5, r11C3), 0x01));

                     body.emit(assign(r12B2, add(r12B7, r12B4), 0x01));

                     ir_expression *const r12B8 = less(r12B2, r12B4);
                     ir_expression *const r12B9 = expr(ir_unop_b2i, r12B8);
                     ir_expression *const r12BA = expr(ir_unop_i2u, r12B9);
                     body.emit(assign(r12B1, add(r10B6, r12BA), 0x01));

                     ir_expression *const r12BB = less(r12B7, r10B5);
                     ir_expression *const r12BC = expr(ir_unop_b2i, r12BB);
                     ir_expression *const r12BD = expr(ir_unop_i2u, r12BC);
                     body.emit(assign(r12B1, add(r12B1, r12BD), 0x01));

                     body.emit(assign(r10B6, r12B1, 0x01));

                     body.emit(assign(r10B5, r12B2, 0x01));

                     body.emit(assign(r10B4, r12B3, 0x01));

                  /* LOOP END */

                  body.instructions = f12AE_parent_instructions;
                  body.emit(f12AE);

                  ir_expression *const r12BE = bit_or(r10B6, r10B5);
                  ir_expression *const r12BF = bit_or(r12BE, r10B4);
                  ir_expression *const r12C0 = nequal(r12BF, body.constant(0u));
                  ir_expression *const r12C1 = expr(ir_unop_b2i, r12C0);
                  ir_expression *const r12C2 = expr(ir_unop_i2u, r12C1);
                  body.emit(assign(r10B8, bit_or(r10B8, r12C2), 0x01));


               body.instructions = f1276_parent_instructions;
               body.emit(f1276);

               /* END IF */

               ir_variable *const r12C3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
               body.emit(r12C3);
               ir_variable *const r12C4 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
               body.emit(r12C4);
               ir_variable *const r12C5 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
               body.emit(r12C5);
               body.emit(assign(r12C3, lshift(r10B8, body.constant(int(21))), 0x01));

               ir_expression *const r12C6 = lshift(r10B9, body.constant(int(21)));
               ir_expression *const r12C7 = rshift(r10B8, body.constant(int(11)));
               body.emit(assign(r12C4, bit_or(r12C6, r12C7), 0x01));

               body.emit(assign(r12C5, rshift(r10B9, body.constant(int(11))), 0x01));

               body.emit(assign(r12C3, bit_or(r12C3, body.constant(0u)), 0x01));

               body.emit(assign(r10B9, r12C5, 0x01));

               body.emit(assign(r10B8, r12C4, 0x01));

               ir_variable *const r12C8 = body.make_temp(glsl_type::int_type, "zExp");
               body.emit(assign(r12C8, r10BA, 0x01));

               ir_variable *const r12C9 = body.make_temp(glsl_type::uint_type, "zFrac0");
               body.emit(assign(r12C9, r12C5, 0x01));

               ir_variable *const r12CA = body.make_temp(glsl_type::uint_type, "zFrac1");
               body.emit(assign(r12CA, r12C4, 0x01));

               ir_variable *const r12CB = body.make_temp(glsl_type::uint_type, "zFrac2");
               body.emit(assign(r12CB, r12C3, 0x01));

               ir_variable *const r12CC = body.make_temp(glsl_type::bool_type, "execute_flag");
               body.emit(assign(r12CC, body.constant(true), 0x01));

               ir_variable *const r12CD = body.make_temp(glsl_type::uvec2_type, "return_value");
               ir_variable *const r12CE = new(mem_ctx) ir_variable(glsl_type::bool_type, "increment", ir_var_auto);
               body.emit(r12CE);
               ir_expression *const r12CF = expr(ir_unop_u2i, r12C3);
               body.emit(assign(r12CE, less(r12CF, body.constant(int(0))), 0x01));

               /* IF CONDITION */
               ir_expression *const r12D1 = lequal(body.constant(int(2045)), r10BA);
               ir_if *f12D0 = new(mem_ctx) ir_if(operand(r12D1).val);
               exec_list *const f12D0_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f12D0->then_instructions;

                  ir_variable *const r12D2 = body.make_temp(glsl_type::bool_type, "or_tmp");
                  /* IF CONDITION */
                  ir_expression *const r12D4 = less(body.constant(int(2045)), r10BA);
                  ir_if *f12D3 = new(mem_ctx) ir_if(operand(r12D4).val);
                  exec_list *const f12D3_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f12D3->then_instructions;

                     body.emit(assign(r12D2, body.constant(true), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f12D3->else_instructions;

                     ir_variable *const r12D5 = body.make_temp(glsl_type::bool_type, "and_tmp");
                     /* IF CONDITION */
                     ir_expression *const r12D7 = equal(r10BA, body.constant(int(2045)));
                     ir_if *f12D6 = new(mem_ctx) ir_if(operand(r12D7).val);
                     exec_list *const f12D6_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f12D6->then_instructions;

                        ir_expression *const r12D8 = equal(body.constant(2097151u), r12C5);
                        ir_expression *const r12D9 = equal(body.constant(4294967295u), r12C4);
                        body.emit(assign(r12D5, logic_and(r12D8, r12D9), 0x01));


                        /* ELSE INSTRUCTIONS */
                        body.instructions = &f12D6->else_instructions;

                        body.emit(assign(r12D5, body.constant(false), 0x01));


                     body.instructions = f12D6_parent_instructions;
                     body.emit(f12D6);

                     /* END IF */

                     body.emit(assign(r12D2, logic_and(r12D5, r12CE), 0x01));


                  body.instructions = f12D3_parent_instructions;
                  body.emit(f12D3);

                  /* END IF */

                  /* IF CONDITION */
                  ir_if *f12DA = new(mem_ctx) ir_if(operand(r12D2).val);
                  exec_list *const f12DA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f12DA->then_instructions;

                     ir_variable *const r12DB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                     body.emit(r12DB);
                     ir_expression *const r12DC = lshift(r10AF, body.constant(int(31)));
                     body.emit(assign(r12DB, add(r12DC, body.constant(2146435072u)), 0x02));

                     body.emit(assign(r12DB, body.constant(0u), 0x01));

                     body.emit(assign(r12CD, r12DB, 0x03));

                     body.emit(assign(r12CC, body.constant(false), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f12DA->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r12DE = less(r10BA, body.constant(int(0)));
                     ir_if *f12DD = new(mem_ctx) ir_if(operand(r12DE).val);
                     exec_list *const f12DD_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f12DD->then_instructions;

                        ir_variable *const r12DF = body.make_temp(glsl_type::uint_type, "a2");
                        body.emit(assign(r12DF, r12C3, 0x01));

                        ir_variable *const r12E0 = body.make_temp(glsl_type::int_type, "count");
                        body.emit(assign(r12E0, neg(r10BA), 0x01));

                        ir_variable *const r12E1 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z2", ir_var_auto);
                        body.emit(r12E1);
                        ir_variable *const r12E2 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
                        body.emit(r12E2);
                        ir_variable *const r12E3 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
                        body.emit(r12E3);
                        ir_variable *const r12E4 = body.make_temp(glsl_type::int_type, "assignment_tmp");
                        ir_expression *const r12E5 = neg(r12E0);
                        body.emit(assign(r12E4, bit_and(r12E5, body.constant(int(31))), 0x01));

                        /* IF CONDITION */
                        ir_expression *const r12E7 = equal(r12E0, body.constant(int(0)));
                        ir_if *f12E6 = new(mem_ctx) ir_if(operand(r12E7).val);
                        exec_list *const f12E6_parent_instructions = body.instructions;

                           /* THEN INSTRUCTIONS */
                           body.instructions = &f12E6->then_instructions;

                           body.emit(assign(r12E1, r12C3, 0x01));

                           body.emit(assign(r12E2, r12C4, 0x01));

                           body.emit(assign(r12E3, r12C5, 0x01));


                           /* ELSE INSTRUCTIONS */
                           body.instructions = &f12E6->else_instructions;

                           /* IF CONDITION */
                           ir_expression *const r12E9 = less(r12E0, body.constant(int(32)));
                           ir_if *f12E8 = new(mem_ctx) ir_if(operand(r12E9).val);
                           exec_list *const f12E8_parent_instructions = body.instructions;

                              /* THEN INSTRUCTIONS */
                              body.instructions = &f12E8->then_instructions;

                              body.emit(assign(r12E1, lshift(r12C4, r12E4), 0x01));

                              ir_expression *const r12EA = lshift(r12C5, r12E4);
                              ir_expression *const r12EB = rshift(r12C4, r12E0);
                              body.emit(assign(r12E2, bit_or(r12EA, r12EB), 0x01));

                              body.emit(assign(r12E3, rshift(r12C5, r12E0), 0x01));


                              /* ELSE INSTRUCTIONS */
                              body.instructions = &f12E8->else_instructions;

                              /* IF CONDITION */
                              ir_expression *const r12ED = equal(r12E0, body.constant(int(32)));
                              ir_if *f12EC = new(mem_ctx) ir_if(operand(r12ED).val);
                              exec_list *const f12EC_parent_instructions = body.instructions;

                                 /* THEN INSTRUCTIONS */
                                 body.instructions = &f12EC->then_instructions;

                                 body.emit(assign(r12E1, r12C4, 0x01));

                                 body.emit(assign(r12E2, r12C5, 0x01));


                                 /* ELSE INSTRUCTIONS */
                                 body.instructions = &f12EC->else_instructions;

                                 body.emit(assign(r12DF, bit_or(r12C3, r12C4), 0x01));

                                 /* IF CONDITION */
                                 ir_expression *const r12EF = less(r12E0, body.constant(int(64)));
                                 ir_if *f12EE = new(mem_ctx) ir_if(operand(r12EF).val);
                                 exec_list *const f12EE_parent_instructions = body.instructions;

                                    /* THEN INSTRUCTIONS */
                                    body.instructions = &f12EE->then_instructions;

                                    body.emit(assign(r12E1, lshift(r12C5, r12E4), 0x01));

                                    ir_expression *const r12F0 = bit_and(r12E0, body.constant(int(31)));
                                    body.emit(assign(r12E2, rshift(r12C5, r12F0), 0x01));


                                    /* ELSE INSTRUCTIONS */
                                    body.instructions = &f12EE->else_instructions;

                                    ir_variable *const r12F1 = body.make_temp(glsl_type::uint_type, "conditional_tmp");
                                    /* IF CONDITION */
                                    ir_expression *const r12F3 = equal(r12E0, body.constant(int(64)));
                                    ir_if *f12F2 = new(mem_ctx) ir_if(operand(r12F3).val);
                                    exec_list *const f12F2_parent_instructions = body.instructions;

                                       /* THEN INSTRUCTIONS */
                                       body.instructions = &f12F2->then_instructions;

                                       body.emit(assign(r12F1, r12C5, 0x01));


                                       /* ELSE INSTRUCTIONS */
                                       body.instructions = &f12F2->else_instructions;

                                       ir_expression *const r12F4 = nequal(r12C5, body.constant(0u));
                                       ir_expression *const r12F5 = expr(ir_unop_b2i, r12F4);
                                       body.emit(assign(r12F1, expr(ir_unop_i2u, r12F5), 0x01));


                                    body.instructions = f12F2_parent_instructions;
                                    body.emit(f12F2);

                                    /* END IF */

                                    body.emit(assign(r12E1, r12F1, 0x01));

                                    body.emit(assign(r12E2, body.constant(0u), 0x01));


                                 body.instructions = f12EE_parent_instructions;
                                 body.emit(f12EE);

                                 /* END IF */


                              body.instructions = f12EC_parent_instructions;
                              body.emit(f12EC);

                              /* END IF */

                              body.emit(assign(r12E3, body.constant(0u), 0x01));


                           body.instructions = f12E8_parent_instructions;
                           body.emit(f12E8);

                           /* END IF */

                           ir_expression *const r12F6 = nequal(r12DF, body.constant(0u));
                           ir_expression *const r12F7 = expr(ir_unop_b2i, r12F6);
                           ir_expression *const r12F8 = expr(ir_unop_i2u, r12F7);
                           body.emit(assign(r12E1, bit_or(r12E1, r12F8), 0x01));


                        body.instructions = f12E6_parent_instructions;
                        body.emit(f12E6);

                        /* END IF */

                        body.emit(assign(r12C9, r12E3, 0x01));

                        body.emit(assign(r12CA, r12E2, 0x01));

                        body.emit(assign(r12CB, r12E1, 0x01));

                        body.emit(assign(r12C8, body.constant(int(0)), 0x01));

                        body.emit(assign(r12CE, less(r12E1, body.constant(0u)), 0x01));


                     body.instructions = f12DD_parent_instructions;
                     body.emit(f12DD);

                     /* END IF */


                  body.instructions = f12DA_parent_instructions;
                  body.emit(f12DA);

                  /* END IF */


               body.instructions = f12D0_parent_instructions;
               body.emit(f12D0);

               /* END IF */

               /* IF CONDITION */
               ir_if *f12F9 = new(mem_ctx) ir_if(operand(r12CC).val);
               exec_list *const f12F9_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f12F9->then_instructions;

                  /* IF CONDITION */
                  ir_if *f12FA = new(mem_ctx) ir_if(operand(r12CE).val);
                  exec_list *const f12FA_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f12FA->then_instructions;

                     ir_variable *const r12FB = body.make_temp(glsl_type::uint_type, "assignment_tmp");
                     body.emit(assign(r12FB, add(r12CA, body.constant(1u)), 0x01));

                     ir_expression *const r12FC = less(r12FB, r12CA);
                     ir_expression *const r12FD = expr(ir_unop_b2i, r12FC);
                     ir_expression *const r12FE = expr(ir_unop_i2u, r12FD);
                     body.emit(assign(r12C9, add(r12C9, r12FE), 0x01));

                     ir_expression *const r12FF = equal(r12CB, body.constant(0u));
                     ir_expression *const r1300 = expr(ir_unop_b2i, r12FF);
                     ir_expression *const r1301 = expr(ir_unop_i2u, r1300);
                     ir_expression *const r1302 = add(r12CB, r1301);
                     ir_expression *const r1303 = bit_and(r1302, body.constant(1u));
                     ir_expression *const r1304 = expr(ir_unop_bit_not, r1303);
                     body.emit(assign(r12CA, bit_and(r12FB, r1304), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f12FA->else_instructions;

                     /* IF CONDITION */
                     ir_expression *const r1306 = bit_or(r12C9, r12CA);
                     ir_expression *const r1307 = equal(r1306, body.constant(0u));
                     ir_if *f1305 = new(mem_ctx) ir_if(operand(r1307).val);
                     exec_list *const f1305_parent_instructions = body.instructions;

                        /* THEN INSTRUCTIONS */
                        body.instructions = &f1305->then_instructions;

                        body.emit(assign(r12C8, body.constant(int(0)), 0x01));


                     body.instructions = f1305_parent_instructions;
                     body.emit(f1305);

                     /* END IF */


                  body.instructions = f12FA_parent_instructions;
                  body.emit(f12FA);

                  /* END IF */

                  ir_variable *const r1308 = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
                  body.emit(r1308);
                  ir_expression *const r1309 = lshift(r10AF, body.constant(int(31)));
                  ir_expression *const r130A = expr(ir_unop_i2u, r12C8);
                  ir_expression *const r130B = lshift(r130A, body.constant(int(20)));
                  ir_expression *const r130C = add(r1309, r130B);
                  body.emit(assign(r1308, add(r130C, r12C9), 0x02));

                  body.emit(assign(r1308, r12CA, 0x01));

                  body.emit(assign(r12CD, r1308, 0x03));

                  body.emit(assign(r12CC, body.constant(false), 0x01));


               body.instructions = f12F9_parent_instructions;
               body.emit(f12F9);

               /* END IF */

               body.emit(assign(r10AE, r12CD, 0x03));

               body.emit(assign(r10AD, body.constant(false), 0x01));


            body.instructions = f11BB_parent_instructions;
            body.emit(f11BB);

            /* END IF */


         body.instructions = f1178_parent_instructions;
         body.emit(f1178);

         /* END IF */


      body.instructions = f110C_parent_instructions;
      body.emit(f110C);

      /* END IF */


   body.instructions = f10C5_parent_instructions;
   body.emit(f10C5);

   /* END IF */

   body.emit(ret(r10AE));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
normalizeFloat32Subnormal(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r130D = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac", ir_var_function_in);
   sig_parameters.push_tail(r130D);
   ir_variable *const r130E = new(mem_ctx) ir_variable(glsl_type::int_type, "zExpPtr", ir_var_function_inout);
   sig_parameters.push_tail(r130E);
   ir_variable *const r130F = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFracPtr", ir_var_function_inout);
   sig_parameters.push_tail(r130F);
   ir_variable *const r1310 = body.make_temp(glsl_type::uint_type, "a");
   body.emit(assign(r1310, r130D, 0x01));

   ir_variable *const r1311 = body.make_temp(glsl_type::int_type, "return_value");
   ir_variable *const r1312 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
   body.emit(r1312);
   /* IF CONDITION */
   ir_expression *const r1314 = equal(r130D, body.constant(0u));
   ir_if *f1313 = new(mem_ctx) ir_if(operand(r1314).val);
   exec_list *const f1313_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1313->then_instructions;

      body.emit(assign(r1311, body.constant(int(32)), 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1313->else_instructions;

      body.emit(assign(r1312, body.constant(int(0)), 0x01));

      /* IF CONDITION */
      ir_expression *const r1316 = bit_and(r130D, body.constant(4294901760u));
      ir_expression *const r1317 = equal(r1316, body.constant(0u));
      ir_if *f1315 = new(mem_ctx) ir_if(operand(r1317).val);
      exec_list *const f1315_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1315->then_instructions;

         body.emit(assign(r1312, body.constant(int(16)), 0x01));

         body.emit(assign(r1310, lshift(r130D, body.constant(int(16))), 0x01));


      body.instructions = f1315_parent_instructions;
      body.emit(f1315);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1319 = bit_and(r1310, body.constant(4278190080u));
      ir_expression *const r131A = equal(r1319, body.constant(0u));
      ir_if *f1318 = new(mem_ctx) ir_if(operand(r131A).val);
      exec_list *const f1318_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1318->then_instructions;

         body.emit(assign(r1312, add(r1312, body.constant(int(8))), 0x01));

         body.emit(assign(r1310, lshift(r1310, body.constant(int(8))), 0x01));


      body.instructions = f1318_parent_instructions;
      body.emit(f1318);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r131C = bit_and(r1310, body.constant(4026531840u));
      ir_expression *const r131D = equal(r131C, body.constant(0u));
      ir_if *f131B = new(mem_ctx) ir_if(operand(r131D).val);
      exec_list *const f131B_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f131B->then_instructions;

         body.emit(assign(r1312, add(r1312, body.constant(int(4))), 0x01));

         body.emit(assign(r1310, lshift(r1310, body.constant(int(4))), 0x01));


      body.instructions = f131B_parent_instructions;
      body.emit(f131B);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r131F = bit_and(r1310, body.constant(3221225472u));
      ir_expression *const r1320 = equal(r131F, body.constant(0u));
      ir_if *f131E = new(mem_ctx) ir_if(operand(r1320).val);
      exec_list *const f131E_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f131E->then_instructions;

         body.emit(assign(r1312, add(r1312, body.constant(int(2))), 0x01));

         body.emit(assign(r1310, lshift(r1310, body.constant(int(2))), 0x01));


      body.instructions = f131E_parent_instructions;
      body.emit(f131E);

      /* END IF */

      /* IF CONDITION */
      ir_expression *const r1322 = bit_and(r1310, body.constant(2147483648u));
      ir_expression *const r1323 = equal(r1322, body.constant(0u));
      ir_if *f1321 = new(mem_ctx) ir_if(operand(r1323).val);
      exec_list *const f1321_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1321->then_instructions;

         body.emit(assign(r1312, add(r1312, body.constant(int(1))), 0x01));


      body.instructions = f1321_parent_instructions;
      body.emit(f1321);

      /* END IF */

      body.emit(assign(r1311, r1312, 0x01));


   body.instructions = f1313_parent_instructions;
   body.emit(f1313);

   /* END IF */

   ir_variable *const r1324 = body.make_temp(glsl_type::int_type, "assignment_tmp");
   body.emit(assign(r1324, add(r1311, body.constant(int(-8))), 0x01));

   body.emit(assign(r130F, lshift(r130D, r1324), 0x01));

   body.emit(assign(r130E, sub(body.constant(int(1)), r1324), 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat32Frac(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1325 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1325);
   ir_expression *const r1326 = bit_and(r1325, body.constant(8388607u));
   body.emit(ret(r1326));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat32Exp(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::int_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1327 = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r1327);
   ir_expression *const r1328 = rshift(r1327, body.constant(int(23)));
   ir_expression *const r1329 = bit_and(r1328, body.constant(255u));
   ir_expression *const r132A = expr(ir_unop_u2i, r1329);
   body.emit(ret(r132A));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
extractFloat32Sign(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r132B = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r132B);
   ir_expression *const r132C = rshift(r132B, body.constant(int(31)));
   body.emit(ret(r132C));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fp32_to_fp64(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uvec2_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r132D = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r132D);
   ir_variable *const r132E = body.make_temp(glsl_type::uvec2_type, "return_value");
   ir_variable *const r132F = new(mem_ctx) ir_variable(glsl_type::int_type, "aExp", ir_var_auto);
   body.emit(r132F);
   ir_variable *const r1330 = new(mem_ctx) ir_variable(glsl_type::uint_type, "aFrac", ir_var_auto);
   body.emit(r1330);
   ir_variable *const r1331 = body.make_temp(glsl_type::uint_type, "extractFloat32Frac_retval");
   body.emit(assign(r1331, bit_and(r132D, body.constant(8388607u)), 0x01));

   body.emit(assign(r1330, r1331, 0x01));

   ir_variable *const r1332 = body.make_temp(glsl_type::int_type, "extractFloat32Exp_retval");
   ir_expression *const r1333 = rshift(r132D, body.constant(int(23)));
   ir_expression *const r1334 = bit_and(r1333, body.constant(255u));
   body.emit(assign(r1332, expr(ir_unop_u2i, r1334), 0x01));

   body.emit(assign(r132F, r1332, 0x01));

   ir_variable *const r1335 = body.make_temp(glsl_type::uint_type, "extractFloat32Sign_retval");
   body.emit(assign(r1335, rshift(r132D, body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r1337 = equal(r1332, body.constant(int(255)));
   ir_if *f1336 = new(mem_ctx) ir_if(operand(r1337).val);
   exec_list *const f1336_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1336->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1339 = nequal(r1331, body.constant(0u));
      ir_if *f1338 = new(mem_ctx) ir_if(operand(r1339).val);
      exec_list *const f1338_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1338->then_instructions;

         ir_variable *const r133A = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
         ir_expression *const r133B = lshift(r1335, body.constant(int(31)));
         ir_expression *const r133C = bit_or(r133B, body.constant(2146435072u));
         ir_expression *const r133D = rshift(r1331, body.constant(int(3)));
         body.emit(assign(r133A, bit_or(r133C, r133D), 0x01));

         body.emit(assign(r133A, lshift(r1331, body.constant(int(29))), 0x02));

         body.emit(assign(r132E, r133A, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1338->else_instructions;

         ir_variable *const r133E = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r133E);
         ir_expression *const r133F = lshift(r1335, body.constant(int(31)));
         body.emit(assign(r133E, add(r133F, body.constant(2146435072u)), 0x02));

         body.emit(assign(r133E, body.constant(0u), 0x01));

         body.emit(assign(r132E, r133E, 0x03));


      body.instructions = f1338_parent_instructions;
      body.emit(f1338);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f1336->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1341 = equal(r1332, body.constant(int(0)));
      ir_if *f1340 = new(mem_ctx) ir_if(operand(r1341).val);
      exec_list *const f1340_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1340->then_instructions;

         /* IF CONDITION */
         ir_expression *const r1343 = nequal(r1331, body.constant(0u));
         ir_if *f1342 = new(mem_ctx) ir_if(operand(r1343).val);
         exec_list *const f1342_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f1342->then_instructions;

            ir_variable *const r1344 = body.make_temp(glsl_type::int_type, "zExpPtr");
            body.emit(assign(r1344, r1332, 0x01));

            ir_variable *const r1345 = body.make_temp(glsl_type::uint_type, "zFracPtr");
            body.emit(assign(r1345, r1331, 0x01));

            ir_variable *const r1346 = body.make_temp(glsl_type::uint_type, "a");
            body.emit(assign(r1346, r1331, 0x01));

            ir_variable *const r1347 = body.make_temp(glsl_type::int_type, "return_value");
            ir_variable *const r1348 = new(mem_ctx) ir_variable(glsl_type::int_type, "shiftCount", ir_var_auto);
            body.emit(r1348);
            /* IF CONDITION */
            ir_expression *const r134A = equal(r1331, body.constant(0u));
            ir_if *f1349 = new(mem_ctx) ir_if(operand(r134A).val);
            exec_list *const f1349_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1349->then_instructions;

               body.emit(assign(r1347, body.constant(int(32)), 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1349->else_instructions;

               body.emit(assign(r1348, body.constant(int(0)), 0x01));

               /* IF CONDITION */
               ir_expression *const r134C = bit_and(r1331, body.constant(4294901760u));
               ir_expression *const r134D = equal(r134C, body.constant(0u));
               ir_if *f134B = new(mem_ctx) ir_if(operand(r134D).val);
               exec_list *const f134B_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f134B->then_instructions;

                  body.emit(assign(r1348, body.constant(int(16)), 0x01));

                  body.emit(assign(r1346, lshift(r1331, body.constant(int(16))), 0x01));


               body.instructions = f134B_parent_instructions;
               body.emit(f134B);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r134F = bit_and(r1346, body.constant(4278190080u));
               ir_expression *const r1350 = equal(r134F, body.constant(0u));
               ir_if *f134E = new(mem_ctx) ir_if(operand(r1350).val);
               exec_list *const f134E_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f134E->then_instructions;

                  body.emit(assign(r1348, add(r1348, body.constant(int(8))), 0x01));

                  body.emit(assign(r1346, lshift(r1346, body.constant(int(8))), 0x01));


               body.instructions = f134E_parent_instructions;
               body.emit(f134E);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1352 = bit_and(r1346, body.constant(4026531840u));
               ir_expression *const r1353 = equal(r1352, body.constant(0u));
               ir_if *f1351 = new(mem_ctx) ir_if(operand(r1353).val);
               exec_list *const f1351_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1351->then_instructions;

                  body.emit(assign(r1348, add(r1348, body.constant(int(4))), 0x01));

                  body.emit(assign(r1346, lshift(r1346, body.constant(int(4))), 0x01));


               body.instructions = f1351_parent_instructions;
               body.emit(f1351);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1355 = bit_and(r1346, body.constant(3221225472u));
               ir_expression *const r1356 = equal(r1355, body.constant(0u));
               ir_if *f1354 = new(mem_ctx) ir_if(operand(r1356).val);
               exec_list *const f1354_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1354->then_instructions;

                  body.emit(assign(r1348, add(r1348, body.constant(int(2))), 0x01));

                  body.emit(assign(r1346, lshift(r1346, body.constant(int(2))), 0x01));


               body.instructions = f1354_parent_instructions;
               body.emit(f1354);

               /* END IF */

               /* IF CONDITION */
               ir_expression *const r1358 = bit_and(r1346, body.constant(2147483648u));
               ir_expression *const r1359 = equal(r1358, body.constant(0u));
               ir_if *f1357 = new(mem_ctx) ir_if(operand(r1359).val);
               exec_list *const f1357_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1357->then_instructions;

                  body.emit(assign(r1348, add(r1348, body.constant(int(1))), 0x01));


               body.instructions = f1357_parent_instructions;
               body.emit(f1357);

               /* END IF */

               body.emit(assign(r1347, r1348, 0x01));


            body.instructions = f1349_parent_instructions;
            body.emit(f1349);

            /* END IF */

            ir_variable *const r135A = body.make_temp(glsl_type::int_type, "assignment_tmp");
            body.emit(assign(r135A, add(r1347, body.constant(int(-8))), 0x01));

            body.emit(assign(r1345, lshift(r1331, r135A), 0x01));

            body.emit(assign(r1344, sub(body.constant(int(1)), r135A), 0x01));

            body.emit(assign(r1330, r1345, 0x01));

            body.emit(assign(r132F, add(r1344, body.constant(int(-1))), 0x01));


         body.instructions = f1342_parent_instructions;
         body.emit(f1342);

         /* END IF */

         ir_variable *const r135B = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r135B);
         body.emit(assign(r135B, lshift(r1335, body.constant(int(31))), 0x02));

         body.emit(assign(r135B, body.constant(0u), 0x01));

         body.emit(assign(r132E, r135B, 0x03));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1340->else_instructions;

         ir_variable *const r135C = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "z", ir_var_auto);
         body.emit(r135C);
         ir_expression *const r135D = lshift(r1335, body.constant(int(31)));
         ir_expression *const r135E = add(r132F, body.constant(int(896)));
         ir_expression *const r135F = expr(ir_unop_i2u, r135E);
         ir_expression *const r1360 = lshift(r135F, body.constant(int(20)));
         ir_expression *const r1361 = add(r135D, r1360);
         ir_expression *const r1362 = rshift(r1330, body.constant(int(3)));
         body.emit(assign(r135C, add(r1361, r1362), 0x02));

         body.emit(assign(r135C, lshift(r1330, body.constant(int(29))), 0x01));

         body.emit(assign(r132E, r135C, 0x03));


      body.instructions = f1340_parent_instructions;
      body.emit(f1340);

      /* END IF */


   body.instructions = f1336_parent_instructions;
   body.emit(f1336);

   /* END IF */

   body.emit(ret(r132E));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
packFloat32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r1363 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r1363);
   ir_variable *const r1364 = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r1364);
   ir_variable *const r1365 = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac", ir_var_function_in);
   sig_parameters.push_tail(r1365);
   ir_expression *const r1366 = lshift(r1363, body.constant(int(31)));
   ir_expression *const r1367 = expr(ir_unop_i2u, r1364);
   ir_expression *const r1368 = lshift(r1367, body.constant(int(23)));
   ir_expression *const r1369 = add(r1366, r1368);
   ir_expression *const r136A = add(r1369, r1365);
   body.emit(ret(r136A));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
shift32RightJamming(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::void_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r136B = new(mem_ctx) ir_variable(glsl_type::uint_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r136B);
   ir_variable *const r136C = new(mem_ctx) ir_variable(glsl_type::int_type, "count", ir_var_function_in);
   sig_parameters.push_tail(r136C);
   ir_variable *const r136D = new(mem_ctx) ir_variable(glsl_type::uint_type, "zPtr", ir_var_function_inout);
   sig_parameters.push_tail(r136D);
   ir_variable *const r136E = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
   body.emit(r136E);
   /* IF CONDITION */
   ir_expression *const r1370 = equal(r136C, body.constant(int(0)));
   ir_if *f136F = new(mem_ctx) ir_if(operand(r1370).val);
   exec_list *const f136F_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f136F->then_instructions;

      body.emit(assign(r136E, r136B, 0x01));


      /* ELSE INSTRUCTIONS */
      body.instructions = &f136F->else_instructions;

      /* IF CONDITION */
      ir_expression *const r1372 = less(r136C, body.constant(int(32)));
      ir_if *f1371 = new(mem_ctx) ir_if(operand(r1372).val);
      exec_list *const f1371_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1371->then_instructions;

         ir_expression *const r1373 = rshift(r136B, r136C);
         ir_expression *const r1374 = neg(r136C);
         ir_expression *const r1375 = bit_and(r1374, body.constant(int(31)));
         ir_expression *const r1376 = lshift(r136B, r1375);
         ir_expression *const r1377 = nequal(r1376, body.constant(0u));
         ir_expression *const r1378 = expr(ir_unop_b2i, r1377);
         ir_expression *const r1379 = expr(ir_unop_i2u, r1378);
         body.emit(assign(r136E, bit_or(r1373, r1379), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1371->else_instructions;

         ir_expression *const r137A = nequal(r136B, body.constant(0u));
         ir_expression *const r137B = expr(ir_unop_b2i, r137A);
         body.emit(assign(r136E, expr(ir_unop_i2u, r137B), 0x01));


      body.instructions = f1371_parent_instructions;
      body.emit(f1371);

      /* END IF */


   body.instructions = f136F_parent_instructions;
   body.emit(f136F);

   /* END IF */

   body.emit(assign(r136D, r136E, 0x01));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
roundAndPackFloat32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r137C = new(mem_ctx) ir_variable(glsl_type::uint_type, "zSign", ir_var_function_in);
   sig_parameters.push_tail(r137C);
   ir_variable *const r137D = new(mem_ctx) ir_variable(glsl_type::int_type, "zExp", ir_var_function_in);
   sig_parameters.push_tail(r137D);
   ir_variable *const r137E = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac", ir_var_function_in);
   sig_parameters.push_tail(r137E);
   ir_variable *const r137F = body.make_temp(glsl_type::bool_type, "execute_flag");
   body.emit(assign(r137F, body.constant(true), 0x01));

   ir_variable *const r1380 = body.make_temp(glsl_type::uint_type, "return_value");
   ir_variable *const r1381 = new(mem_ctx) ir_variable(glsl_type::uint_type, "roundBits", ir_var_auto);
   body.emit(r1381);
   body.emit(assign(r1381, bit_and(r137E, body.constant(127u)), 0x01));

   /* IF CONDITION */
   ir_expression *const r1383 = expr(ir_unop_i2u, r137D);
   ir_expression *const r1384 = lequal(body.constant(253u), r1383);
   ir_if *f1382 = new(mem_ctx) ir_if(operand(r1384).val);
   exec_list *const f1382_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f1382->then_instructions;

      /* IF CONDITION */
      ir_expression *const r1386 = less(body.constant(int(253)), r137D);
      ir_expression *const r1387 = equal(r137D, body.constant(int(253)));
      ir_expression *const r1388 = less(r137E, body.constant(4294967232u));
      ir_expression *const r1389 = logic_and(r1387, r1388);
      ir_expression *const r138A = logic_or(r1386, r1389);
      ir_if *f1385 = new(mem_ctx) ir_if(operand(r138A).val);
      exec_list *const f1385_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f1385->then_instructions;

         ir_expression *const r138B = lshift(r137C, body.constant(int(31)));
         body.emit(assign(r1380, add(r138B, body.constant(2139095040u)), 0x01));

         body.emit(assign(r137F, body.constant(false), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f1385->else_instructions;

         /* IF CONDITION */
         ir_expression *const r138D = less(r137D, body.constant(int(0)));
         ir_if *f138C = new(mem_ctx) ir_if(operand(r138D).val);
         exec_list *const f138C_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f138C->then_instructions;

            ir_variable *const r138E = body.make_temp(glsl_type::int_type, "count");
            body.emit(assign(r138E, neg(r137D), 0x01));

            ir_variable *const r138F = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
            body.emit(r138F);
            /* IF CONDITION */
            ir_expression *const r1391 = equal(r138E, body.constant(int(0)));
            ir_if *f1390 = new(mem_ctx) ir_if(operand(r1391).val);
            exec_list *const f1390_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f1390->then_instructions;

               body.emit(assign(r138F, r137E, 0x01));


               /* ELSE INSTRUCTIONS */
               body.instructions = &f1390->else_instructions;

               /* IF CONDITION */
               ir_expression *const r1393 = less(r138E, body.constant(int(32)));
               ir_if *f1392 = new(mem_ctx) ir_if(operand(r1393).val);
               exec_list *const f1392_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f1392->then_instructions;

                  ir_expression *const r1394 = rshift(r137E, r138E);
                  ir_expression *const r1395 = neg(r138E);
                  ir_expression *const r1396 = bit_and(r1395, body.constant(int(31)));
                  ir_expression *const r1397 = lshift(r137E, r1396);
                  ir_expression *const r1398 = nequal(r1397, body.constant(0u));
                  ir_expression *const r1399 = expr(ir_unop_b2i, r1398);
                  ir_expression *const r139A = expr(ir_unop_i2u, r1399);
                  body.emit(assign(r138F, bit_or(r1394, r139A), 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f1392->else_instructions;

                  ir_expression *const r139B = nequal(r137E, body.constant(0u));
                  ir_expression *const r139C = expr(ir_unop_b2i, r139B);
                  body.emit(assign(r138F, expr(ir_unop_i2u, r139C), 0x01));


               body.instructions = f1392_parent_instructions;
               body.emit(f1392);

               /* END IF */


            body.instructions = f1390_parent_instructions;
            body.emit(f1390);

            /* END IF */

            body.emit(assign(r137E, r138F, 0x01));

            body.emit(assign(r137D, body.constant(int(0)), 0x01));

            body.emit(assign(r1381, bit_and(r138F, body.constant(127u)), 0x01));


         body.instructions = f138C_parent_instructions;
         body.emit(f138C);

         /* END IF */


      body.instructions = f1385_parent_instructions;
      body.emit(f1385);

      /* END IF */


   body.instructions = f1382_parent_instructions;
   body.emit(f1382);

   /* END IF */

   /* IF CONDITION */
   ir_if *f139D = new(mem_ctx) ir_if(operand(r137F).val);
   exec_list *const f139D_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f139D->then_instructions;

      ir_expression *const r139E = add(r137E, body.constant(64u));
      body.emit(assign(r137E, rshift(r139E, body.constant(int(7))), 0x01));

      ir_expression *const r139F = bit_xor(r1381, body.constant(64u));
      ir_expression *const r13A0 = equal(r139F, body.constant(0u));
      ir_expression *const r13A1 = expr(ir_unop_b2i, r13A0);
      ir_expression *const r13A2 = expr(ir_unop_i2u, r13A1);
      ir_expression *const r13A3 = bit_and(r13A2, body.constant(1u));
      ir_expression *const r13A4 = expr(ir_unop_bit_not, r13A3);
      body.emit(assign(r137E, bit_and(r137E, r13A4), 0x01));

      /* IF CONDITION */
      ir_expression *const r13A6 = equal(r137E, body.constant(0u));
      ir_if *f13A5 = new(mem_ctx) ir_if(operand(r13A6).val);
      exec_list *const f13A5_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f13A5->then_instructions;

         body.emit(assign(r137D, body.constant(int(0)), 0x01));


      body.instructions = f13A5_parent_instructions;
      body.emit(f13A5);

      /* END IF */

      ir_expression *const r13A7 = lshift(r137C, body.constant(int(31)));
      ir_expression *const r13A8 = expr(ir_unop_i2u, r137D);
      ir_expression *const r13A9 = lshift(r13A8, body.constant(int(23)));
      ir_expression *const r13AA = add(r13A7, r13A9);
      body.emit(assign(r1380, add(r13AA, r137E), 0x01));

      body.emit(assign(r137F, body.constant(false), 0x01));


   body.instructions = f139D_parent_instructions;
   body.emit(f139D);

   /* END IF */

   body.emit(ret(r1380));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
ir_function_signature *
fp64_to_fp32(void *mem_ctx, builtin_available_predicate avail)
{
   ir_function_signature *const sig =
      new(mem_ctx) ir_function_signature(glsl_type::uint_type, avail);
   ir_factory body(&sig->body, mem_ctx);
   sig->is_defined = true;

   exec_list sig_parameters;

   ir_variable *const r13AB = new(mem_ctx) ir_variable(glsl_type::uvec2_type, "a", ir_var_function_in);
   sig_parameters.push_tail(r13AB);
   ir_variable *const r13AC = body.make_temp(glsl_type::uint_type, "return_value");
   ir_variable *const r13AD = new(mem_ctx) ir_variable(glsl_type::uint_type, "zFrac", ir_var_auto);
   body.emit(r13AD);
   body.emit(assign(r13AD, body.constant(0u), 0x01));

   ir_variable *const r13AE = body.make_temp(glsl_type::uvec2_type, "vec_ctor");
   body.emit(assign(r13AE, bit_and(swizzle_y(r13AB), body.constant(1048575u)), 0x01));

   body.emit(assign(r13AE, swizzle_x(r13AB), 0x02));

   ir_variable *const r13AF = body.make_temp(glsl_type::int_type, "extractFloat64Exp_retval");
   ir_expression *const r13B0 = rshift(swizzle_y(r13AB), body.constant(int(20)));
   ir_expression *const r13B1 = bit_and(r13B0, body.constant(2047u));
   body.emit(assign(r13AF, expr(ir_unop_u2i, r13B1), 0x01));

   ir_variable *const r13B2 = body.make_temp(glsl_type::uint_type, "extractFloat64Sign_retval");
   body.emit(assign(r13B2, rshift(swizzle_y(r13AB), body.constant(int(31))), 0x01));

   /* IF CONDITION */
   ir_expression *const r13B4 = equal(r13AF, body.constant(int(2047)));
   ir_if *f13B3 = new(mem_ctx) ir_if(operand(r13B4).val);
   exec_list *const f13B3_parent_instructions = body.instructions;

      /* THEN INSTRUCTIONS */
      body.instructions = &f13B3->then_instructions;

      /* IF CONDITION */
      ir_expression *const r13B6 = bit_or(swizzle_x(r13AB), swizzle_x(r13AE));
      ir_expression *const r13B7 = nequal(r13B6, body.constant(0u));
      ir_if *f13B5 = new(mem_ctx) ir_if(operand(r13B7).val);
      exec_list *const f13B5_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f13B5->then_instructions;

         ir_expression *const r13B8 = lshift(r13B2, body.constant(int(31)));
         ir_expression *const r13B9 = bit_or(r13B8, body.constant(2143289344u));
         ir_expression *const r13BA = bit_and(swizzle_x(r13AB), body.constant(1048575u));
         ir_expression *const r13BB = lshift(r13BA, body.constant(int(3)));
         ir_expression *const r13BC = bit_or(r13B9, r13BB);
         ir_expression *const r13BD = rshift(swizzle_x(r13AE), body.constant(int(29)));
         body.emit(assign(r13AC, bit_or(r13BC, r13BD), 0x01));


         /* ELSE INSTRUCTIONS */
         body.instructions = &f13B5->else_instructions;

         ir_expression *const r13BE = lshift(r13B2, body.constant(int(31)));
         body.emit(assign(r13AC, add(r13BE, body.constant(2139095040u)), 0x01));


      body.instructions = f13B5_parent_instructions;
      body.emit(f13B5);

      /* END IF */


      /* ELSE INSTRUCTIONS */
      body.instructions = &f13B3->else_instructions;

      ir_variable *const r13BF = new(mem_ctx) ir_variable(glsl_type::uint_type, "z1", ir_var_auto);
      body.emit(r13BF);
      ir_variable *const r13C0 = new(mem_ctx) ir_variable(glsl_type::uint_type, "z0", ir_var_auto);
      body.emit(r13C0);
      ir_expression *const r13C1 = lshift(swizzle_x(r13AB), body.constant(int(10)));
      ir_expression *const r13C2 = rshift(swizzle_x(r13AE), body.constant(int(22)));
      ir_expression *const r13C3 = bit_or(r13C1, r13C2);
      ir_expression *const r13C4 = lshift(swizzle_x(r13AE), body.constant(int(10)));
      ir_expression *const r13C5 = nequal(r13C4, body.constant(0u));
      ir_expression *const r13C6 = expr(ir_unop_b2i, r13C5);
      ir_expression *const r13C7 = expr(ir_unop_i2u, r13C6);
      body.emit(assign(r13BF, bit_or(r13C3, r13C7), 0x01));

      body.emit(assign(r13C0, rshift(swizzle_x(r13AB), body.constant(int(22))), 0x01));

      body.emit(assign(r13AD, r13BF, 0x01));

      /* IF CONDITION */
      ir_expression *const r13C9 = nequal(r13AF, body.constant(int(0)));
      ir_if *f13C8 = new(mem_ctx) ir_if(operand(r13C9).val);
      exec_list *const f13C8_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f13C8->then_instructions;

         body.emit(assign(r13AD, bit_or(r13BF, body.constant(1073741824u)), 0x01));


      body.instructions = f13C8_parent_instructions;
      body.emit(f13C8);

      /* END IF */

      ir_variable *const r13CA = body.make_temp(glsl_type::int_type, "zExp");
      body.emit(assign(r13CA, add(r13AF, body.constant(int(-897))), 0x01));

      ir_variable *const r13CB = body.make_temp(glsl_type::uint_type, "zFrac");
      body.emit(assign(r13CB, r13AD, 0x01));

      ir_variable *const r13CC = body.make_temp(glsl_type::bool_type, "execute_flag");
      body.emit(assign(r13CC, body.constant(true), 0x01));

      ir_variable *const r13CD = body.make_temp(glsl_type::uint_type, "return_value");
      ir_variable *const r13CE = new(mem_ctx) ir_variable(glsl_type::uint_type, "roundBits", ir_var_auto);
      body.emit(r13CE);
      body.emit(assign(r13CE, bit_and(r13AD, body.constant(127u)), 0x01));

      /* IF CONDITION */
      ir_expression *const r13D0 = expr(ir_unop_i2u, r13CA);
      ir_expression *const r13D1 = lequal(body.constant(253u), r13D0);
      ir_if *f13CF = new(mem_ctx) ir_if(operand(r13D1).val);
      exec_list *const f13CF_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f13CF->then_instructions;

         /* IF CONDITION */
         ir_expression *const r13D3 = less(body.constant(int(253)), r13CA);
         ir_expression *const r13D4 = equal(r13CA, body.constant(int(253)));
         ir_expression *const r13D5 = less(r13AD, body.constant(4294967232u));
         ir_expression *const r13D6 = logic_and(r13D4, r13D5);
         ir_expression *const r13D7 = logic_or(r13D3, r13D6);
         ir_if *f13D2 = new(mem_ctx) ir_if(operand(r13D7).val);
         exec_list *const f13D2_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f13D2->then_instructions;

            ir_expression *const r13D8 = lshift(r13B2, body.constant(int(31)));
            body.emit(assign(r13CD, add(r13D8, body.constant(2139095040u)), 0x01));

            body.emit(assign(r13CC, body.constant(false), 0x01));


            /* ELSE INSTRUCTIONS */
            body.instructions = &f13D2->else_instructions;

            /* IF CONDITION */
            ir_expression *const r13DA = less(r13CA, body.constant(int(0)));
            ir_if *f13D9 = new(mem_ctx) ir_if(operand(r13DA).val);
            exec_list *const f13D9_parent_instructions = body.instructions;

               /* THEN INSTRUCTIONS */
               body.instructions = &f13D9->then_instructions;

               ir_variable *const r13DB = body.make_temp(glsl_type::int_type, "count");
               body.emit(assign(r13DB, neg(r13CA), 0x01));

               ir_variable *const r13DC = new(mem_ctx) ir_variable(glsl_type::uint_type, "z", ir_var_auto);
               body.emit(r13DC);
               /* IF CONDITION */
               ir_expression *const r13DE = equal(r13DB, body.constant(int(0)));
               ir_if *f13DD = new(mem_ctx) ir_if(operand(r13DE).val);
               exec_list *const f13DD_parent_instructions = body.instructions;

                  /* THEN INSTRUCTIONS */
                  body.instructions = &f13DD->then_instructions;

                  body.emit(assign(r13DC, r13AD, 0x01));


                  /* ELSE INSTRUCTIONS */
                  body.instructions = &f13DD->else_instructions;

                  /* IF CONDITION */
                  ir_expression *const r13E0 = less(r13DB, body.constant(int(32)));
                  ir_if *f13DF = new(mem_ctx) ir_if(operand(r13E0).val);
                  exec_list *const f13DF_parent_instructions = body.instructions;

                     /* THEN INSTRUCTIONS */
                     body.instructions = &f13DF->then_instructions;

                     ir_expression *const r13E1 = rshift(r13AD, r13DB);
                     ir_expression *const r13E2 = neg(r13DB);
                     ir_expression *const r13E3 = bit_and(r13E2, body.constant(int(31)));
                     ir_expression *const r13E4 = lshift(r13AD, r13E3);
                     ir_expression *const r13E5 = nequal(r13E4, body.constant(0u));
                     ir_expression *const r13E6 = expr(ir_unop_b2i, r13E5);
                     ir_expression *const r13E7 = expr(ir_unop_i2u, r13E6);
                     body.emit(assign(r13DC, bit_or(r13E1, r13E7), 0x01));


                     /* ELSE INSTRUCTIONS */
                     body.instructions = &f13DF->else_instructions;

                     ir_expression *const r13E8 = nequal(r13AD, body.constant(0u));
                     ir_expression *const r13E9 = expr(ir_unop_b2i, r13E8);
                     body.emit(assign(r13DC, expr(ir_unop_i2u, r13E9), 0x01));


                  body.instructions = f13DF_parent_instructions;
                  body.emit(f13DF);

                  /* END IF */


               body.instructions = f13DD_parent_instructions;
               body.emit(f13DD);

               /* END IF */

               body.emit(assign(r13CB, r13DC, 0x01));

               body.emit(assign(r13CA, body.constant(int(0)), 0x01));

               body.emit(assign(r13CE, bit_and(r13DC, body.constant(127u)), 0x01));


            body.instructions = f13D9_parent_instructions;
            body.emit(f13D9);

            /* END IF */


         body.instructions = f13D2_parent_instructions;
         body.emit(f13D2);

         /* END IF */


      body.instructions = f13CF_parent_instructions;
      body.emit(f13CF);

      /* END IF */

      /* IF CONDITION */
      ir_if *f13EA = new(mem_ctx) ir_if(operand(r13CC).val);
      exec_list *const f13EA_parent_instructions = body.instructions;

         /* THEN INSTRUCTIONS */
         body.instructions = &f13EA->then_instructions;

         ir_expression *const r13EB = add(r13CB, body.constant(64u));
         body.emit(assign(r13CB, rshift(r13EB, body.constant(int(7))), 0x01));

         ir_expression *const r13EC = bit_xor(r13CE, body.constant(64u));
         ir_expression *const r13ED = equal(r13EC, body.constant(0u));
         ir_expression *const r13EE = expr(ir_unop_b2i, r13ED);
         ir_expression *const r13EF = expr(ir_unop_i2u, r13EE);
         ir_expression *const r13F0 = bit_and(r13EF, body.constant(1u));
         ir_expression *const r13F1 = expr(ir_unop_bit_not, r13F0);
         body.emit(assign(r13CB, bit_and(r13CB, r13F1), 0x01));

         /* IF CONDITION */
         ir_expression *const r13F3 = equal(r13CB, body.constant(0u));
         ir_if *f13F2 = new(mem_ctx) ir_if(operand(r13F3).val);
         exec_list *const f13F2_parent_instructions = body.instructions;

            /* THEN INSTRUCTIONS */
            body.instructions = &f13F2->then_instructions;

            body.emit(assign(r13CA, body.constant(int(0)), 0x01));


         body.instructions = f13F2_parent_instructions;
         body.emit(f13F2);

         /* END IF */

         ir_expression *const r13F4 = lshift(r13B2, body.constant(int(31)));
         ir_expression *const r13F5 = expr(ir_unop_i2u, r13CA);
         ir_expression *const r13F6 = lshift(r13F5, body.constant(int(23)));
         ir_expression *const r13F7 = add(r13F4, r13F6);
         body.emit(assign(r13CD, add(r13F7, r13CB), 0x01));

         body.emit(assign(r13CC, body.constant(false), 0x01));


      body.instructions = f13EA_parent_instructions;
      body.emit(f13EA);

      /* END IF */

      body.emit(assign(r13AC, r13CD, 0x01));


   body.instructions = f13B3_parent_instructions;
   body.emit(f13B3);

   /* END IF */

   body.emit(ret(r13AC));

   sig->replace_parameters(&sig_parameters);
   return sig;
}
